[
  {
    "function_name": "rf_EOWriteDoubleRecoveryFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_evenodd_dagfuncs.c",
    "lines": "843-970",
    "snippet": "int \nrf_EOWriteDoubleRecoveryFunc(node)\n\tRF_DagNode_t *node;\n{\n\tint     np = node->numParams;\n\tRF_AccessStripeMap_t *asmap = (RF_AccessStripeMap_t *) node->params[np - 1].p;\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[np - 2].p;\n\tRF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & (raidPtr->Layout);\n\tRF_SectorNum_t sector;\n\tRF_RowCol_t col, scol;\n\tint     prm, i, j;\n\tRF_SectorCount_t secPerSU = layoutPtr->sectorsPerStripeUnit;\n\tunsigned sosAddr;\n\tunsigned bytesPerSector = rf_RaidAddressToByte(raidPtr, 1);\n\tRF_int64 numbytes;\n\tRF_SectorNum_t startSector, endSector;\n\tRF_PhysDiskAddr_t *ppda, *epda, *pda, *fpda, npda;\n\tRF_RowCol_t fcol[2], numDataCol = layoutPtr->numDataCol;\n\tchar  **buf;\t\t/* buf[0], buf[1], buf[2], ...etc. point to\n\t\t\t\t * buffer storing data read from col0, col1,\n\t\t\t\t * col2 */\n\tchar   *ebuf, *pbuf, *dest[2], *olddata[2];\n\tRF_Etimer_t timer;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\n\tRF_ASSERT(asmap->numDataFailed == 1);\t/* currently only support this\n\t\t\t\t\t\t * case, the other failed SU\n\t\t\t\t\t\t * is not being accessed */\n\tRF_ETIMER_START(timer);\n\tRF_Malloc(buf, numDataCol * sizeof(char *), (char **));\n\n\tppda = node->results[0];/* Instead of being buffers, node->results[0]\n\t\t\t\t * and [1] are Ppda and Epda  */\n\tepda = node->results[1];\n\tfpda = asmap->failedPDAs[0];\n\n\t/* First, recovery the failed old SU using EvenOdd double decoding      */\n\t/* determine the startSector and endSector for decoding */\n\tstartSector = rf_StripeUnitOffset(layoutPtr, fpda->startSector);\n\tendSector = startSector + fpda->numSector;\n\t/* Assign buf[col] pointers to point to each non-failed colume  and\n\t * initialize the pbuf and ebuf to point at the beginning of each\n\t * source buffers and destination buffers */\n\tfor (prm = 0; prm < numDataCol - 2; prm++) {\n\t\tpda = (RF_PhysDiskAddr_t *) node->params[prm].p;\n\t\tcol = rf_EUCol(layoutPtr, pda->raidAddress);\n\t\tbuf[col] = pda->bufPtr;\n\t}\n\t/* pbuf and ebuf:  they will change values as double recovery decoding\n\t * goes on */\n\tpbuf = ppda->bufPtr;\n\tebuf = epda->bufPtr;\n\t/* find out the logical colume numbers in the encoding matrix of the\n\t * two failed columes */\n\tfcol[0] = rf_EUCol(layoutPtr, fpda->raidAddress);\n\n\t/* find out the other failed colume not accessed this time */\n\tsosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, asmap->raidAddress);\n\tfor (i = 0; i < numDataCol; i++) {\n\t\tnpda.raidAddress = sosAddr + (i * secPerSU);\n\t\t(raidPtr->Layout.map->MapSector) (raidPtr, npda.raidAddress, &(npda.row), &(npda.col), &(npda.startSector), 0);\n\t\t/* skip over dead disks */\n\t\tif (RF_DEAD_DISK(raidPtr->Disks[npda.row][npda.col].status))\n\t\t\tif (i != fcol[0])\n\t\t\t\tbreak;\n\t}\n\tRF_ASSERT(i < numDataCol);\n\tfcol[1] = i;\n\t/* assign temporary space to put recovered failed SU */\n\tnumbytes = fpda->numSector * bytesPerSector;\n\tRF_Malloc(olddata[0], numbytes, (char *));\n\tRF_Malloc(olddata[1], numbytes, (char *));\n\tdest[0] = olddata[0];\n\tdest[1] = olddata[1];\n\tbzero(olddata[0], numbytes);\n\tbzero(olddata[1], numbytes);\n\t/* Begin the recovery decoding, initially buf[j],  ebuf, pbuf, dest[j]\n\t * have already pointed at the beginning of each source buffers and\n\t * destination buffers */\n\tfor (sector = startSector, i = 0; sector < endSector; sector++, i++) {\n\t\trf_doubleEOdecode(raidPtr, buf, dest, fcol, pbuf, ebuf);\n\t\tfor (j = 0; j < numDataCol; j++)\n\t\t\tif ((j != fcol[0]) && (j != fcol[1]))\n\t\t\t\tbuf[j] += bytesPerSector;\n\t\tdest[0] += bytesPerSector;\n\t\tdest[1] += bytesPerSector;\n\t\tebuf += bytesPerSector;\n\t\tpbuf += bytesPerSector;\n\t}\n\t/* after recovery, the buffer pointed by olddata[0] is the old failed\n\t * data. With new writing data and this old data, use small write to\n\t * calculate the new redundant informations */\n\t/* node->params[ 0, ... PDAPerDisk * (numDataCol - 2)-1 ] are Pdas of\n\t * Rrd; params[ PDAPerDisk*(numDataCol - 2), ... PDAPerDisk*numDataCol\n\t * -1 ] are Pdas of Rp, ( Rp2 ), Re, ( Re2 ) ; params[\n\t * PDAPerDisk*numDataCol, ... PDAPerDisk*numDataCol\n\t * +asmap->numStripeUnitsAccessed -asmap->numDataFailed-1] are Pdas of\n\t * wudNodes; For current implementation, we assume the simplest case:\n\t * asmap->numStripeUnitsAccessed == 1 and asmap->numDataFailed == 1\n\t * ie. PDAPerDisk = 1 then node->params[numDataCol] must be the new\n\t * data to be written to the failed disk. We first bxor the new data\n\t * into the old recovered data, then do the same things as small\n\t * write. */\n\n\trf_bxor(((RF_PhysDiskAddr_t *) node->params[numDataCol].p)->bufPtr, olddata[0], numbytes, node->dagHdr->bp);\n\t/* do new 'E' calculation  */\n\t/* find out the corresponding colume in encoding matrix for write\n\t * colume to be encoded into redundant disk 'E' */\n\tscol = rf_EUCol(layoutPtr, fpda->raidAddress);\n\t/* olddata[0] now is source buffer pointer; epda->bufPtr is the dest\n\t * buffer pointer               */\n\trf_e_encToBuf(raidPtr, scol, olddata[0], RF_EO_MATRIX_DIM - 2, epda->bufPtr, fpda->numSector);\n\n\t/* do new 'P' calculation  */\n\trf_bxor(olddata[0], ppda->bufPtr, numbytes, node->dagHdr->bp);\n\t/* Free the allocated buffer  */\n\tRF_Free(olddata[0], numbytes);\n\tRF_Free(olddata[1], numbytes);\n\tRF_Free(buf, numDataCol * sizeof(char *));\n\n\tRF_ETIMER_STOP(timer);\n\tRF_ETIMER_EVAL(timer);\n\tif (tracerec) {\n\t\ttracerec->q_us += RF_ETIMER_VAL_US(timer);\n\t}\n\trf_GenericWakeupFunc(node, 0);\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_evenodd_dagfuncs.h\"",
      "#include \"rf_evenodd.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_GenericWakeupFunc",
          "args": [
            "node",
            "0"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "rf_GenericWakeupFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
          "lines": "425-460",
          "snippet": "int \nrf_GenericWakeupFunc(node, status)\n\tRF_DagNode_t *node;\n\tint     status;\n{\n\tswitch (node->status) {\n\tcase rf_bwd1:\n\t\tnode->status = rf_bwd2;\n\t\tif (node->dagFuncData)\n\t\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\t\treturn (rf_DiskWriteFuncForThreads(node));\n\t\tbreak;\n\tcase rf_fired:\n\t\tif (status)\n\t\t\tnode->status = rf_bad;\n\t\telse\n\t\t\tnode->status = rf_good;\n\t\tbreak;\n\tcase rf_recover:\n\t\t/* probably should never reach this case */\n\t\tif (status)\n\t\t\tnode->status = rf_panic;\n\t\telse\n\t\t\tnode->status = rf_undone;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"rf_GenericWakeupFunc:\");\n\t\tprintf(\"node->status is %d,\", node->status);\n\t\tprintf(\"status is %d \\n\", status);\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\tif (node->dagFuncData)\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\treturn (rf_FinishNode(node, RF_INTR_CONTEXT));\n}",
          "includes": [
            "#include \"rf_paritylog.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_GenericWakeupFunc(node, status)\n\tRF_DagNode_t *node;\n\tint     status;\n{\n\tswitch (node->status) {\n\tcase rf_bwd1:\n\t\tnode->status = rf_bwd2;\n\t\tif (node->dagFuncData)\n\t\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\t\treturn (rf_DiskWriteFuncForThreads(node));\n\t\tbreak;\n\tcase rf_fired:\n\t\tif (status)\n\t\t\tnode->status = rf_bad;\n\t\telse\n\t\t\tnode->status = rf_good;\n\t\tbreak;\n\tcase rf_recover:\n\t\t/* probably should never reach this case */\n\t\tif (status)\n\t\t\tnode->status = rf_panic;\n\t\telse\n\t\t\tnode->status = rf_undone;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"rf_GenericWakeupFunc:\");\n\t\tprintf(\"node->status is %d,\", node->status);\n\t\tprintf(\"status is %d \\n\", status);\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\tif (node->dagFuncData)\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\treturn (rf_FinishNode(node, RF_INTR_CONTEXT));\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_VAL_US",
          "args": [
            "timer"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_EVAL",
          "args": [
            "timer"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_STOP",
          "args": [
            "timer"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "buf",
            "numDataCol * sizeof(char *)"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "olddata[1]",
            "numbytes"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "olddata[0]",
            "numbytes"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_bxor",
          "args": [
            "olddata[0]",
            "ppda->bufPtr",
            "numbytes",
            "node->dagHdr->bp"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "rf_bxor3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
          "lines": "880-893",
          "snippet": "int \nrf_bxor3(dst, a, b, c, len, bp)\n\tregister unsigned char *dst;\n\tregister unsigned char *a;\n\tregister unsigned char *b;\n\tregister unsigned char *c;\n\tunsigned long len;\n\tvoid   *bp;\n{\n\tRF_ASSERT(((RF_UL(dst) | RF_UL(a) | RF_UL(b) | RF_UL(c) | len) & 0x7) == 0);\n\n\treturn (rf_longword_bxor3((unsigned long *) dst, (unsigned long *) a,\n\t\t(unsigned long *) b, (unsigned long *) c, len >> RF_LONGSHIFT, bp));\n}",
          "includes": [
            "#include \"rf_paritylog.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint \nrf_bxor3(dst, a, b, c, len, bp)\n\tregister unsigned char *dst;\n\tregister unsigned char *a;\n\tregister unsigned char *b;\n\tregister unsigned char *c;\n\tunsigned long len;\n\tvoid   *bp;\n{\n\tRF_ASSERT(((RF_UL(dst) | RF_UL(a) | RF_UL(b) | RF_UL(c) | len) & 0x7) == 0);\n\n\treturn (rf_longword_bxor3((unsigned long *) dst, (unsigned long *) a,\n\t\t(unsigned long *) b, (unsigned long *) c, len >> RF_LONGSHIFT, bp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_e_encToBuf",
          "args": [
            "raidPtr",
            "scol",
            "olddata[0]",
            "RF_EO_MATRIX_DIM - 2",
            "epda->bufPtr",
            "fpda->numSector"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "rf_e_encToBuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_evenodd_dagfuncs.c",
          "lines": "371-387",
          "snippet": "void \nrf_e_encToBuf(\n    RF_Raid_t * raidPtr,\n    RF_RowCol_t srcLogicCol,\n    char *srcbuf,\n    RF_RowCol_t destLogicCol,\n    char *destbuf,\n    int numSector)\n{\n\tint     i, bytesPerSector = rf_RaidAddressToByte(raidPtr, 1);\n\n\tfor (i = 0; i < numSector; i++) {\n\t\trf_e_EncOneSect(srcLogicCol, srcbuf, destLogicCol, destbuf, bytesPerSector);\n\t\tsrcbuf += bytesPerSector;\n\t\tdestbuf += bytesPerSector;\n\t}\n}",
          "includes": [
            "#include \"rf_evenodd_dagfuncs.h\"",
            "#include \"rf_evenodd.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dagdegwr.h\"",
            "#include \"rf_dagdegrd.h\"",
            "#include \"rf_dagffwr.h\"",
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_evenodd_dagfuncs.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_configure.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_e_encToBuf(\n    RF_Raid_t * raidPtr,\n    RF_RowCol_t srcLogicCol,\n    char *srcbuf,\n    RF_RowCol_t destLogicCol,\n    char *destbuf,\n    int numSector)\n{\n\tint     i, bytesPerSector = rf_RaidAddressToByte(raidPtr, 1);\n\n\tfor (i = 0; i < numSector; i++) {\n\t\trf_e_EncOneSect(srcLogicCol, srcbuf, destLogicCol, destbuf, bytesPerSector);\n\t\tsrcbuf += bytesPerSector;\n\t\tdestbuf += bytesPerSector;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_EUCol",
          "args": [
            "layoutPtr",
            "fpda->raidAddress"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_doubleEOdecode",
          "args": [
            "raidPtr",
            "buf",
            "dest",
            "fcol",
            "pbuf",
            "ebuf"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "rf_doubleEOdecode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_evenodd_dagfuncs.c",
          "lines": "452-637",
          "snippet": "void \nrf_doubleEOdecode(\n    RF_Raid_t * raidPtr,\n    char **rrdbuf,\n    char **dest,\n    RF_RowCol_t * fcol,\n    char *pbuf,\n    char *ebuf)\n{\n\tRF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & (raidPtr->Layout);\n\tint     i, j, k, f1, f2, row;\n\tint     rrdrow, erow, count = 0;\n\tint     bytesPerSector = rf_RaidAddressToByte(raidPtr, 1);\n\tint     numRowInEncMatix = (RF_EO_MATRIX_DIM) - 1;\n#if 0\n\tint     pcol = (RF_EO_MATRIX_DIM) - 1;\n#endif\n\tint     ecol = (RF_EO_MATRIX_DIM) - 2;\n\tint     bytesPerEU = bytesPerSector / numRowInEncMatix;\n\tint     numDataCol = layoutPtr->numDataCol;\n#if RF_EO_MATRIX_DIM > 17\n\tint     shortsPerEU = bytesPerEU / sizeof(short);\n\tshort  *rrdbuf_current, *pbuf_current, *ebuf_current;\n\tshort  *dest_smaller, *dest_smaller_current, *dest_larger, *dest_larger_current;\n\tregister short *temp;\n\tshort  *P;\n\n\tRF_ASSERT(bytesPerEU % sizeof(short) == 0);\n\tRF_Malloc(P, bytesPerEU, (short *));\n\tRF_Malloc(temp, bytesPerEU, (short *));\n#elif RF_EO_MATRIX_DIM == 17\n\tint     longsPerEU = bytesPerEU / sizeof(long);\n\tlong   *rrdbuf_current, *pbuf_current, *ebuf_current;\n\tlong   *dest_smaller, *dest_smaller_current, *dest_larger, *dest_larger_current;\n\tregister long *temp;\n\tlong   *P;\n\n\tRF_ASSERT(bytesPerEU % sizeof(long) == 0);\n\tRF_Malloc(P, bytesPerEU, (long *));\n\tRF_Malloc(temp, bytesPerEU, (long *));\n#endif\n\tRF_ASSERT(*((long *) dest[0]) == 0);\n\tRF_ASSERT(*((long *) dest[1]) == 0);\n\tbzero((char *) P, bytesPerEU);\n\tbzero((char *) temp, bytesPerEU);\n\tRF_ASSERT(*P == 0);\n\t/* calculate the 'P' parameter, which, not parity, is the Xor of all\n\t * elements in the last two column, ie. 'E' and 'parity' colume, see\n\t * the Ref. paper by Blaum, et al 1993  */\n\tfor (i = 0; i < numRowInEncMatix; i++)\n\t\tfor (k = 0; k < longsPerEU; k++) {\n#if RF_EO_MATRIX_DIM > 17\n\t\t\tebuf_current = ((short *) ebuf) + i * shortsPerEU + k;\n\t\t\tpbuf_current = ((short *) pbuf) + i * shortsPerEU + k;\n#elif RF_EO_MATRIX_DIM == 17\n\t\t\tebuf_current = ((long *) ebuf) + i * longsPerEU + k;\n\t\t\tpbuf_current = ((long *) pbuf) + i * longsPerEU + k;\n#endif\n\t\t\tP[k] ^= *ebuf_current;\n\t\t\tP[k] ^= *pbuf_current;\n\t\t}\n\tRF_ASSERT(fcol[0] != fcol[1]);\n\tif (fcol[0] < fcol[1]) {\n#if RF_EO_MATRIX_DIM > 17\n\t\tdest_smaller = (short *) (dest[0]);\n\t\tdest_larger = (short *) (dest[1]);\n#elif RF_EO_MATRIX_DIM == 17\n\t\tdest_smaller = (long *) (dest[0]);\n\t\tdest_larger = (long *) (dest[1]);\n#endif\n\t\tf1 = fcol[0];\n\t\tf2 = fcol[1];\n\t} else {\n#if RF_EO_MATRIX_DIM > 17\n\t\tdest_smaller = (short *) (dest[1]);\n\t\tdest_larger = (short *) (dest[0]);\n#elif RF_EO_MATRIX_DIM == 17\n\t\tdest_smaller = (long *) (dest[1]);\n\t\tdest_larger = (long *) (dest[0]);\n#endif\n\t\tf1 = fcol[1];\n\t\tf2 = fcol[0];\n\t}\n\trow = (RF_EO_MATRIX_DIM) - 1;\n\twhile ((row = rf_EO_Mod((row + f1 - f2), RF_EO_MATRIX_DIM)) != ((RF_EO_MATRIX_DIM) - 1)) {\n#if RF_EO_MATRIX_DIM > 17\n\t\tdest_larger_current = dest_larger + row * shortsPerEU;\n\t\tdest_smaller_current = dest_smaller + row * shortsPerEU;\n#elif RF_EO_MATRIX_DIM == 17\n\t\tdest_larger_current = dest_larger + row * longsPerEU;\n\t\tdest_smaller_current = dest_smaller + row * longsPerEU;\n#endif\n\t\t/**    Do the diagonal recovery. Initially, temp[k] = (failed 1),\n\t\t       which is the failed data in the colume which has smaller col index. **/\n\t\t/* step 1:  ^(SUM of nonfailed in-diagonal A(rrdrow,0..m-3))         */\n\t\tfor (j = 0; j < numDataCol; j++) {\n\t\t\tif (j == f1 || j == f2)\n\t\t\t\tcontinue;\n\t\t\trrdrow = rf_EO_Mod((row + f2 - j), RF_EO_MATRIX_DIM);\n\t\t\tif (rrdrow != (RF_EO_MATRIX_DIM) - 1) {\n#if RF_EO_MATRIX_DIM > 17\n\t\t\t\trrdbuf_current = (short *) (rrdbuf[j]) + rrdrow * shortsPerEU;\n\t\t\t\tfor (k = 0; k < shortsPerEU; k++)\n\t\t\t\t\ttemp[k] ^= *(rrdbuf_current + k);\n#elif RF_EO_MATRIX_DIM == 17\n\t\t\t\trrdbuf_current = (long *) (rrdbuf[j]) + rrdrow * longsPerEU;\n\t\t\t\tfor (k = 0; k < longsPerEU; k++)\n\t\t\t\t\ttemp[k] ^= *(rrdbuf_current + k);\n#endif\n\t\t\t}\n\t\t}\n\t\t/* step 2:  ^E(erow,m-2), If erow is at the buttom row, don't\n\t\t * Xor into it  E(erow,m-2) = (principle diagonal) ^ (failed\n\t\t * 1) ^ (failed 2) ^ ( SUM of nonfailed in-diagonal\n\t\t * A(rrdrow,0..m-3) ) After this step, temp[k] = (principle\n\t\t * diagonal) ^ (failed 2)       */\n\n\t\terow = rf_EO_Mod((row + f2 - ecol), (RF_EO_MATRIX_DIM));\n\t\tif (erow != (RF_EO_MATRIX_DIM) - 1) {\n#if RF_EO_MATRIX_DIM > 17\n\t\t\tebuf_current = (short *) ebuf + shortsPerEU * erow;\n\t\t\tfor (k = 0; k < shortsPerEU; k++)\n\t\t\t\ttemp[k] ^= *(ebuf_current + k);\n#elif RF_EO_MATRIX_DIM == 17\n\t\t\tebuf_current = (long *) ebuf + longsPerEU * erow;\n\t\t\tfor (k = 0; k < longsPerEU; k++)\n\t\t\t\ttemp[k] ^= *(ebuf_current + k);\n#endif\n\t\t}\n\t\t/* step 3: ^P to obtain the failed data (failed 2).  P can be\n\t\t * proved to be actually  (principle diagonal)  After this\n\t\t * step, temp[k] = (failed 2), the failed data to be recovered */\n#if RF_EO_MATRIX_DIM > 17\n\t\tfor (k = 0; k < shortsPerEU; k++)\n\t\t\ttemp[k] ^= P[k];\n\t\t/* Put the data to the destination buffer                              */\n\t\tfor (k = 0; k < shortsPerEU; k++)\n\t\t\tdest_larger_current[k] = temp[k];\n#elif RF_EO_MATRIX_DIM == 17\n\t\tfor (k = 0; k < longsPerEU; k++)\n\t\t\ttemp[k] ^= P[k];\n\t\t/* Put the data to the destination buffer                              */\n\t\tfor (k = 0; k < longsPerEU; k++)\n\t\t\tdest_larger_current[k] = temp[k];\n#endif\n\n\t\t/**          THE FOLLOWING DO THE HORIZONTAL XOR                **/\n\t\t/* step 1:  ^(SUM of A(row,0..m-3)), ie. all nonfailed data\n\t\t * columes    */\n\t\tfor (j = 0; j < numDataCol; j++) {\n\t\t\tif (j == f1 || j == f2)\n\t\t\t\tcontinue;\n#if RF_EO_MATRIX_DIM > 17\n\t\t\trrdbuf_current = (short *) (rrdbuf[j]) + row * shortsPerEU;\n\t\t\tfor (k = 0; k < shortsPerEU; k++)\n\t\t\t\ttemp[k] ^= *(rrdbuf_current + k);\n#elif RF_EO_MATRIX_DIM == 17\n\t\t\trrdbuf_current = (long *) (rrdbuf[j]) + row * longsPerEU;\n\t\t\tfor (k = 0; k < longsPerEU; k++)\n\t\t\t\ttemp[k] ^= *(rrdbuf_current + k);\n#endif\n\t\t}\n\t\t/* step 2: ^A(row,m-1) */\n\t\t/* step 3: Put the data to the destination buffer                             \t */\n#if RF_EO_MATRIX_DIM > 17\n\t\tpbuf_current = (short *) pbuf + shortsPerEU * row;\n\t\tfor (k = 0; k < shortsPerEU; k++)\n\t\t\ttemp[k] ^= *(pbuf_current + k);\n\t\tfor (k = 0; k < shortsPerEU; k++)\n\t\t\tdest_smaller_current[k] = temp[k];\n#elif RF_EO_MATRIX_DIM == 17\n\t\tpbuf_current = (long *) pbuf + longsPerEU * row;\n\t\tfor (k = 0; k < longsPerEU; k++)\n\t\t\ttemp[k] ^= *(pbuf_current + k);\n\t\tfor (k = 0; k < longsPerEU; k++)\n\t\t\tdest_smaller_current[k] = temp[k];\n#endif\n\t\tcount++;\n\t}\n\t/* Check if all Encoding Unit in the data buffer have been decoded,\n\t * according EvenOdd theory, if \"RF_EO_MATRIX_DIM\" is a prime number,\n\t * this algorithm will covered all buffer \t\t\t\t */\n\tRF_ASSERT(count == numRowInEncMatix);\n\tRF_Free((char *) P, bytesPerEU);\n\tRF_Free((char *) temp, bytesPerEU);\n}",
          "includes": [
            "#include \"rf_evenodd_dagfuncs.h\"",
            "#include \"rf_evenodd.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dagdegwr.h\"",
            "#include \"rf_dagdegrd.h\"",
            "#include \"rf_dagffwr.h\"",
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_evenodd_dagfuncs.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_configure.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_doubleEOdecode(\n    RF_Raid_t * raidPtr,\n    char **rrdbuf,\n    char **dest,\n    RF_RowCol_t * fcol,\n    char *pbuf,\n    char *ebuf)\n{\n\tRF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & (raidPtr->Layout);\n\tint     i, j, k, f1, f2, row;\n\tint     rrdrow, erow, count = 0;\n\tint     bytesPerSector = rf_RaidAddressToByte(raidPtr, 1);\n\tint     numRowInEncMatix = (RF_EO_MATRIX_DIM) - 1;\n#if 0\n\tint     pcol = (RF_EO_MATRIX_DIM) - 1;\n#endif\n\tint     ecol = (RF_EO_MATRIX_DIM) - 2;\n\tint     bytesPerEU = bytesPerSector / numRowInEncMatix;\n\tint     numDataCol = layoutPtr->numDataCol;\n#if RF_EO_MATRIX_DIM > 17\n\tint     shortsPerEU = bytesPerEU / sizeof(short);\n\tshort  *rrdbuf_current, *pbuf_current, *ebuf_current;\n\tshort  *dest_smaller, *dest_smaller_current, *dest_larger, *dest_larger_current;\n\tregister short *temp;\n\tshort  *P;\n\n\tRF_ASSERT(bytesPerEU % sizeof(short) == 0);\n\tRF_Malloc(P, bytesPerEU, (short *));\n\tRF_Malloc(temp, bytesPerEU, (short *));\n#elif RF_EO_MATRIX_DIM == 17\n\tint     longsPerEU = bytesPerEU / sizeof(long);\n\tlong   *rrdbuf_current, *pbuf_current, *ebuf_current;\n\tlong   *dest_smaller, *dest_smaller_current, *dest_larger, *dest_larger_current;\n\tregister long *temp;\n\tlong   *P;\n\n\tRF_ASSERT(bytesPerEU % sizeof(long) == 0);\n\tRF_Malloc(P, bytesPerEU, (long *));\n\tRF_Malloc(temp, bytesPerEU, (long *));\n#endif\n\tRF_ASSERT(*((long *) dest[0]) == 0);\n\tRF_ASSERT(*((long *) dest[1]) == 0);\n\tbzero((char *) P, bytesPerEU);\n\tbzero((char *) temp, bytesPerEU);\n\tRF_ASSERT(*P == 0);\n\t/* calculate the 'P' parameter, which, not parity, is the Xor of all\n\t * elements in the last two column, ie. 'E' and 'parity' colume, see\n\t * the Ref. paper by Blaum, et al 1993  */\n\tfor (i = 0; i < numRowInEncMatix; i++)\n\t\tfor (k = 0; k < longsPerEU; k++) {\n#if RF_EO_MATRIX_DIM > 17\n\t\t\tebuf_current = ((short *) ebuf) + i * shortsPerEU + k;\n\t\t\tpbuf_current = ((short *) pbuf) + i * shortsPerEU + k;\n#elif RF_EO_MATRIX_DIM == 17\n\t\t\tebuf_current = ((long *) ebuf) + i * longsPerEU + k;\n\t\t\tpbuf_current = ((long *) pbuf) + i * longsPerEU + k;\n#endif\n\t\t\tP[k] ^= *ebuf_current;\n\t\t\tP[k] ^= *pbuf_current;\n\t\t}\n\tRF_ASSERT(fcol[0] != fcol[1]);\n\tif (fcol[0] < fcol[1]) {\n#if RF_EO_MATRIX_DIM > 17\n\t\tdest_smaller = (short *) (dest[0]);\n\t\tdest_larger = (short *) (dest[1]);\n#elif RF_EO_MATRIX_DIM == 17\n\t\tdest_smaller = (long *) (dest[0]);\n\t\tdest_larger = (long *) (dest[1]);\n#endif\n\t\tf1 = fcol[0];\n\t\tf2 = fcol[1];\n\t} else {\n#if RF_EO_MATRIX_DIM > 17\n\t\tdest_smaller = (short *) (dest[1]);\n\t\tdest_larger = (short *) (dest[0]);\n#elif RF_EO_MATRIX_DIM == 17\n\t\tdest_smaller = (long *) (dest[1]);\n\t\tdest_larger = (long *) (dest[0]);\n#endif\n\t\tf1 = fcol[1];\n\t\tf2 = fcol[0];\n\t}\n\trow = (RF_EO_MATRIX_DIM) - 1;\n\twhile ((row = rf_EO_Mod((row + f1 - f2), RF_EO_MATRIX_DIM)) != ((RF_EO_MATRIX_DIM) - 1)) {\n#if RF_EO_MATRIX_DIM > 17\n\t\tdest_larger_current = dest_larger + row * shortsPerEU;\n\t\tdest_smaller_current = dest_smaller + row * shortsPerEU;\n#elif RF_EO_MATRIX_DIM == 17\n\t\tdest_larger_current = dest_larger + row * longsPerEU;\n\t\tdest_smaller_current = dest_smaller + row * longsPerEU;\n#endif\n\t\t/**    Do the diagonal recovery. Initially, temp[k] = (failed 1),\n\t\t       which is the failed data in the colume which has smaller col index. **/\n\t\t/* step 1:  ^(SUM of nonfailed in-diagonal A(rrdrow,0..m-3))         */\n\t\tfor (j = 0; j < numDataCol; j++) {\n\t\t\tif (j == f1 || j == f2)\n\t\t\t\tcontinue;\n\t\t\trrdrow = rf_EO_Mod((row + f2 - j), RF_EO_MATRIX_DIM);\n\t\t\tif (rrdrow != (RF_EO_MATRIX_DIM) - 1) {\n#if RF_EO_MATRIX_DIM > 17\n\t\t\t\trrdbuf_current = (short *) (rrdbuf[j]) + rrdrow * shortsPerEU;\n\t\t\t\tfor (k = 0; k < shortsPerEU; k++)\n\t\t\t\t\ttemp[k] ^= *(rrdbuf_current + k);\n#elif RF_EO_MATRIX_DIM == 17\n\t\t\t\trrdbuf_current = (long *) (rrdbuf[j]) + rrdrow * longsPerEU;\n\t\t\t\tfor (k = 0; k < longsPerEU; k++)\n\t\t\t\t\ttemp[k] ^= *(rrdbuf_current + k);\n#endif\n\t\t\t}\n\t\t}\n\t\t/* step 2:  ^E(erow,m-2), If erow is at the buttom row, don't\n\t\t * Xor into it  E(erow,m-2) = (principle diagonal) ^ (failed\n\t\t * 1) ^ (failed 2) ^ ( SUM of nonfailed in-diagonal\n\t\t * A(rrdrow,0..m-3) ) After this step, temp[k] = (principle\n\t\t * diagonal) ^ (failed 2)       */\n\n\t\terow = rf_EO_Mod((row + f2 - ecol), (RF_EO_MATRIX_DIM));\n\t\tif (erow != (RF_EO_MATRIX_DIM) - 1) {\n#if RF_EO_MATRIX_DIM > 17\n\t\t\tebuf_current = (short *) ebuf + shortsPerEU * erow;\n\t\t\tfor (k = 0; k < shortsPerEU; k++)\n\t\t\t\ttemp[k] ^= *(ebuf_current + k);\n#elif RF_EO_MATRIX_DIM == 17\n\t\t\tebuf_current = (long *) ebuf + longsPerEU * erow;\n\t\t\tfor (k = 0; k < longsPerEU; k++)\n\t\t\t\ttemp[k] ^= *(ebuf_current + k);\n#endif\n\t\t}\n\t\t/* step 3: ^P to obtain the failed data (failed 2).  P can be\n\t\t * proved to be actually  (principle diagonal)  After this\n\t\t * step, temp[k] = (failed 2), the failed data to be recovered */\n#if RF_EO_MATRIX_DIM > 17\n\t\tfor (k = 0; k < shortsPerEU; k++)\n\t\t\ttemp[k] ^= P[k];\n\t\t/* Put the data to the destination buffer                              */\n\t\tfor (k = 0; k < shortsPerEU; k++)\n\t\t\tdest_larger_current[k] = temp[k];\n#elif RF_EO_MATRIX_DIM == 17\n\t\tfor (k = 0; k < longsPerEU; k++)\n\t\t\ttemp[k] ^= P[k];\n\t\t/* Put the data to the destination buffer                              */\n\t\tfor (k = 0; k < longsPerEU; k++)\n\t\t\tdest_larger_current[k] = temp[k];\n#endif\n\n\t\t/**          THE FOLLOWING DO THE HORIZONTAL XOR                **/\n\t\t/* step 1:  ^(SUM of A(row,0..m-3)), ie. all nonfailed data\n\t\t * columes    */\n\t\tfor (j = 0; j < numDataCol; j++) {\n\t\t\tif (j == f1 || j == f2)\n\t\t\t\tcontinue;\n#if RF_EO_MATRIX_DIM > 17\n\t\t\trrdbuf_current = (short *) (rrdbuf[j]) + row * shortsPerEU;\n\t\t\tfor (k = 0; k < shortsPerEU; k++)\n\t\t\t\ttemp[k] ^= *(rrdbuf_current + k);\n#elif RF_EO_MATRIX_DIM == 17\n\t\t\trrdbuf_current = (long *) (rrdbuf[j]) + row * longsPerEU;\n\t\t\tfor (k = 0; k < longsPerEU; k++)\n\t\t\t\ttemp[k] ^= *(rrdbuf_current + k);\n#endif\n\t\t}\n\t\t/* step 2: ^A(row,m-1) */\n\t\t/* step 3: Put the data to the destination buffer                             \t */\n#if RF_EO_MATRIX_DIM > 17\n\t\tpbuf_current = (short *) pbuf + shortsPerEU * row;\n\t\tfor (k = 0; k < shortsPerEU; k++)\n\t\t\ttemp[k] ^= *(pbuf_current + k);\n\t\tfor (k = 0; k < shortsPerEU; k++)\n\t\t\tdest_smaller_current[k] = temp[k];\n#elif RF_EO_MATRIX_DIM == 17\n\t\tpbuf_current = (long *) pbuf + longsPerEU * row;\n\t\tfor (k = 0; k < longsPerEU; k++)\n\t\t\ttemp[k] ^= *(pbuf_current + k);\n\t\tfor (k = 0; k < longsPerEU; k++)\n\t\t\tdest_smaller_current[k] = temp[k];\n#endif\n\t\tcount++;\n\t}\n\t/* Check if all Encoding Unit in the data buffer have been decoded,\n\t * according EvenOdd theory, if \"RF_EO_MATRIX_DIM\" is a prime number,\n\t * this algorithm will covered all buffer \t\t\t\t */\n\tRF_ASSERT(count == numRowInEncMatix);\n\tRF_Free((char *) P, bytesPerEU);\n\tRF_Free((char *) temp, bytesPerEU);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "olddata[1]",
            "numbytes"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "olddata[0]",
            "numbytes"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "olddata[1]",
            "numbytes",
            "(char *)"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "olddata[0]",
            "numbytes",
            "(char *)"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "i < numDataCol"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_DEAD_DISK",
          "args": [
            "raidPtr->Disks[npda.row][npda.col].status"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "raidPtr",
            "npda.raidAddress",
            "&(npda.row)",
            "&(npda.col)",
            "&(npda.startSector)",
            "0"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressOfPrevStripeBoundary",
          "args": [
            "layoutPtr",
            "asmap->raidAddress"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_EUCol",
          "args": [
            "layoutPtr",
            "fpda->raidAddress"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_EUCol",
          "args": [
            "layoutPtr",
            "pda->raidAddress"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_StripeUnitOffset",
          "args": [
            "layoutPtr",
            "fpda->startSector"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "buf",
            "numDataCol * sizeof(char *)",
            "(char **)"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_START",
          "args": [
            "timer"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "asmap->numDataFailed == 1"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "1"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_evenodd_dagfuncs.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_configure.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nint \nrf_EOWriteDoubleRecoveryFunc(node)\n\tRF_DagNode_t *node;\n{\n\tint     np = node->numParams;\n\tRF_AccessStripeMap_t *asmap = (RF_AccessStripeMap_t *) node->params[np - 1].p;\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[np - 2].p;\n\tRF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & (raidPtr->Layout);\n\tRF_SectorNum_t sector;\n\tRF_RowCol_t col, scol;\n\tint     prm, i, j;\n\tRF_SectorCount_t secPerSU = layoutPtr->sectorsPerStripeUnit;\n\tunsigned sosAddr;\n\tunsigned bytesPerSector = rf_RaidAddressToByte(raidPtr, 1);\n\tRF_int64 numbytes;\n\tRF_SectorNum_t startSector, endSector;\n\tRF_PhysDiskAddr_t *ppda, *epda, *pda, *fpda, npda;\n\tRF_RowCol_t fcol[2], numDataCol = layoutPtr->numDataCol;\n\tchar  **buf;\t\t/* buf[0], buf[1], buf[2], ...etc. point to\n\t\t\t\t * buffer storing data read from col0, col1,\n\t\t\t\t * col2 */\n\tchar   *ebuf, *pbuf, *dest[2], *olddata[2];\n\tRF_Etimer_t timer;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\n\tRF_ASSERT(asmap->numDataFailed == 1);\t/* currently only support this\n\t\t\t\t\t\t * case, the other failed SU\n\t\t\t\t\t\t * is not being accessed */\n\tRF_ETIMER_START(timer);\n\tRF_Malloc(buf, numDataCol * sizeof(char *), (char **));\n\n\tppda = node->results[0];/* Instead of being buffers, node->results[0]\n\t\t\t\t * and [1] are Ppda and Epda  */\n\tepda = node->results[1];\n\tfpda = asmap->failedPDAs[0];\n\n\t/* First, recovery the failed old SU using EvenOdd double decoding      */\n\t/* determine the startSector and endSector for decoding */\n\tstartSector = rf_StripeUnitOffset(layoutPtr, fpda->startSector);\n\tendSector = startSector + fpda->numSector;\n\t/* Assign buf[col] pointers to point to each non-failed colume  and\n\t * initialize the pbuf and ebuf to point at the beginning of each\n\t * source buffers and destination buffers */\n\tfor (prm = 0; prm < numDataCol - 2; prm++) {\n\t\tpda = (RF_PhysDiskAddr_t *) node->params[prm].p;\n\t\tcol = rf_EUCol(layoutPtr, pda->raidAddress);\n\t\tbuf[col] = pda->bufPtr;\n\t}\n\t/* pbuf and ebuf:  they will change values as double recovery decoding\n\t * goes on */\n\tpbuf = ppda->bufPtr;\n\tebuf = epda->bufPtr;\n\t/* find out the logical colume numbers in the encoding matrix of the\n\t * two failed columes */\n\tfcol[0] = rf_EUCol(layoutPtr, fpda->raidAddress);\n\n\t/* find out the other failed colume not accessed this time */\n\tsosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, asmap->raidAddress);\n\tfor (i = 0; i < numDataCol; i++) {\n\t\tnpda.raidAddress = sosAddr + (i * secPerSU);\n\t\t(raidPtr->Layout.map->MapSector) (raidPtr, npda.raidAddress, &(npda.row), &(npda.col), &(npda.startSector), 0);\n\t\t/* skip over dead disks */\n\t\tif (RF_DEAD_DISK(raidPtr->Disks[npda.row][npda.col].status))\n\t\t\tif (i != fcol[0])\n\t\t\t\tbreak;\n\t}\n\tRF_ASSERT(i < numDataCol);\n\tfcol[1] = i;\n\t/* assign temporary space to put recovered failed SU */\n\tnumbytes = fpda->numSector * bytesPerSector;\n\tRF_Malloc(olddata[0], numbytes, (char *));\n\tRF_Malloc(olddata[1], numbytes, (char *));\n\tdest[0] = olddata[0];\n\tdest[1] = olddata[1];\n\tbzero(olddata[0], numbytes);\n\tbzero(olddata[1], numbytes);\n\t/* Begin the recovery decoding, initially buf[j],  ebuf, pbuf, dest[j]\n\t * have already pointed at the beginning of each source buffers and\n\t * destination buffers */\n\tfor (sector = startSector, i = 0; sector < endSector; sector++, i++) {\n\t\trf_doubleEOdecode(raidPtr, buf, dest, fcol, pbuf, ebuf);\n\t\tfor (j = 0; j < numDataCol; j++)\n\t\t\tif ((j != fcol[0]) && (j != fcol[1]))\n\t\t\t\tbuf[j] += bytesPerSector;\n\t\tdest[0] += bytesPerSector;\n\t\tdest[1] += bytesPerSector;\n\t\tebuf += bytesPerSector;\n\t\tpbuf += bytesPerSector;\n\t}\n\t/* after recovery, the buffer pointed by olddata[0] is the old failed\n\t * data. With new writing data and this old data, use small write to\n\t * calculate the new redundant informations */\n\t/* node->params[ 0, ... PDAPerDisk * (numDataCol - 2)-1 ] are Pdas of\n\t * Rrd; params[ PDAPerDisk*(numDataCol - 2), ... PDAPerDisk*numDataCol\n\t * -1 ] are Pdas of Rp, ( Rp2 ), Re, ( Re2 ) ; params[\n\t * PDAPerDisk*numDataCol, ... PDAPerDisk*numDataCol\n\t * +asmap->numStripeUnitsAccessed -asmap->numDataFailed-1] are Pdas of\n\t * wudNodes; For current implementation, we assume the simplest case:\n\t * asmap->numStripeUnitsAccessed == 1 and asmap->numDataFailed == 1\n\t * ie. PDAPerDisk = 1 then node->params[numDataCol] must be the new\n\t * data to be written to the failed disk. We first bxor the new data\n\t * into the old recovered data, then do the same things as small\n\t * write. */\n\n\trf_bxor(((RF_PhysDiskAddr_t *) node->params[numDataCol].p)->bufPtr, olddata[0], numbytes, node->dagHdr->bp);\n\t/* do new 'E' calculation  */\n\t/* find out the corresponding colume in encoding matrix for write\n\t * colume to be encoded into redundant disk 'E' */\n\tscol = rf_EUCol(layoutPtr, fpda->raidAddress);\n\t/* olddata[0] now is source buffer pointer; epda->bufPtr is the dest\n\t * buffer pointer               */\n\trf_e_encToBuf(raidPtr, scol, olddata[0], RF_EO_MATRIX_DIM - 2, epda->bufPtr, fpda->numSector);\n\n\t/* do new 'P' calculation  */\n\trf_bxor(olddata[0], ppda->bufPtr, numbytes, node->dagHdr->bp);\n\t/* Free the allocated buffer  */\n\tRF_Free(olddata[0], numbytes);\n\tRF_Free(olddata[1], numbytes);\n\tRF_Free(buf, numDataCol * sizeof(char *));\n\n\tRF_ETIMER_STOP(timer);\n\tRF_ETIMER_EVAL(timer);\n\tif (tracerec) {\n\t\ttracerec->q_us += RF_ETIMER_VAL_US(timer);\n\t}\n\trf_GenericWakeupFunc(node, 0);\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_EvenOddDoubleRecoveryFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_evenodd_dagfuncs.c",
    "lines": "645-835",
    "snippet": "int \nrf_EvenOddDoubleRecoveryFunc(node)\n\tRF_DagNode_t *node;\n{\n\tint     ndataParam = 0;\n\tint     np = node->numParams;\n\tRF_AccessStripeMap_t *asmap = (RF_AccessStripeMap_t *) node->params[np - 1].p;\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[np - 2].p;\n\tRF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & (raidPtr->Layout);\n\tint     i, prm, sector, nresults = node->numResults;\n\tRF_SectorCount_t secPerSU = layoutPtr->sectorsPerStripeUnit;\n\tunsigned sosAddr;\n\tint     two = 0, mallc_one = 0, mallc_two = 0;\t/* flags to indicate if\n\t\t\t\t\t\t\t * memory is allocated */\n\tint     bytesPerSector = rf_RaidAddressToByte(raidPtr, 1);\n\tRF_PhysDiskAddr_t *ppda, *ppda2, *epda, *epda2, *pda, *pda0, *pda1,\n\t        npda;\n\tRF_RowCol_t fcol[2], fsuoff[2], fsuend[2], numDataCol = layoutPtr->numDataCol;\n\tchar  **buf, *ebuf, *pbuf, *dest[2];\n\tlong   *suoff = NULL, *suend = NULL, *prmToCol = NULL, psuoff, esuoff;\n\tRF_SectorNum_t startSector, endSector;\n\tRF_Etimer_t timer;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\n\tRF_ETIMER_START(timer);\n\n\t/* Find out the number of parameters which are pdas for data\n\t * information */\n\tfor (i = 0; i <= np; i++)\n\t\tif (((RF_PhysDiskAddr_t *) node->params[i].p)->type != RF_PDA_TYPE_DATA) {\n\t\t\tndataParam = i;\n\t\t\tbreak;\n\t\t}\n\tRF_Malloc(buf, numDataCol * sizeof(char *), (char **));\n\tif (ndataParam != 0) {\n\t\tRF_Malloc(suoff, ndataParam * sizeof(long), (long *));\n\t\tRF_Malloc(suend, ndataParam * sizeof(long), (long *));\n\t\tRF_Malloc(prmToCol, ndataParam * sizeof(long), (long *));\n\t}\n\tif (asmap->failedPDAs[1] &&\n\t    (asmap->failedPDAs[1]->numSector + asmap->failedPDAs[0]->numSector < secPerSU)) {\n\t\tRF_ASSERT(0);\t/* currently, no support for this situation */\n\t\tppda = node->params[np - 6].p;\n\t\tppda2 = node->params[np - 5].p;\n\t\tRF_ASSERT(ppda2->type == RF_PDA_TYPE_PARITY);\n\t\tepda = node->params[np - 4].p;\n\t\tepda2 = node->params[np - 3].p;\n\t\tRF_ASSERT(epda2->type == RF_PDA_TYPE_Q);\n\t\ttwo = 1;\n\t} else {\n\t\tppda = node->params[np - 4].p;\n\t\tepda = node->params[np - 3].p;\n\t\tpsuoff = rf_StripeUnitOffset(layoutPtr, ppda->startSector);\n\t\tesuoff = rf_StripeUnitOffset(layoutPtr, epda->startSector);\n\t\tRF_ASSERT(psuoff == esuoff);\n\t}\n\t/*\n            the followings have three goals:\n            1. determine the startSector to begin decoding and endSector to end decoding.\n            2. determine the colume numbers of the two failed disks.\n            3. determine the offset and end offset of the access within each failed stripe unit.\n         */\n\tif (nresults == 1) {\n\t\t/* find the startSector to begin decoding */\n\t\tpda = node->results[0];\n\t\tbzero(pda->bufPtr, bytesPerSector * pda->numSector);\n\t\tfsuoff[0] = rf_StripeUnitOffset(layoutPtr, pda->startSector);\n\t\tfsuend[0] = fsuoff[0] + pda->numSector;\n\t\tstartSector = fsuoff[0];\n\t\tendSector = fsuend[0];\n\n\t\t/* find out the the column of failed disk being accessed */\n\t\tfcol[0] = rf_EUCol(layoutPtr, pda->raidAddress);\n\n\t\t/* find out the other failed colume not accessed */\n\t\tsosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, asmap->raidAddress);\n\t\tfor (i = 0; i < numDataCol; i++) {\n\t\t\tnpda.raidAddress = sosAddr + (i * secPerSU);\n\t\t\t(raidPtr->Layout.map->MapSector) (raidPtr, npda.raidAddress, &(npda.row), &(npda.col), &(npda.startSector), 0);\n\t\t\t/* skip over dead disks */\n\t\t\tif (RF_DEAD_DISK(raidPtr->Disks[npda.row][npda.col].status))\n\t\t\t\tif (i != fcol[0])\n\t\t\t\t\tbreak;\n\t\t}\n\t\tRF_ASSERT(i < numDataCol);\n\t\tfcol[1] = i;\n\t} else {\n\t\tRF_ASSERT(nresults == 2);\n\t\tpda0 = node->results[0];\n\t\tbzero(pda0->bufPtr, bytesPerSector * pda0->numSector);\n\t\tpda1 = node->results[1];\n\t\tbzero(pda1->bufPtr, bytesPerSector * pda1->numSector);\n\t\t/* determine the failed colume numbers of the two failed\n\t\t * disks. */\n\t\tfcol[0] = rf_EUCol(layoutPtr, pda0->raidAddress);\n\t\tfcol[1] = rf_EUCol(layoutPtr, pda1->raidAddress);\n\t\t/* determine the offset and end offset of the access within\n\t\t * each failed stripe unit. */\n\t\tfsuoff[0] = rf_StripeUnitOffset(layoutPtr, pda0->startSector);\n\t\tfsuend[0] = fsuoff[0] + pda0->numSector;\n\t\tfsuoff[1] = rf_StripeUnitOffset(layoutPtr, pda1->startSector);\n\t\tfsuend[1] = fsuoff[1] + pda1->numSector;\n\t\t/* determine the startSector to begin decoding */\n\t\tstartSector = RF_MIN(pda0->startSector, pda1->startSector);\n\t\t/* determine the endSector to end decoding */\n\t\tendSector = RF_MAX(fsuend[0], fsuend[1]);\n\t}\n\t/*\n\t      assign the beginning sector and the end sector for each parameter\n\t      find out the corresponding colume # for each parameter\n        */\n\tfor (prm = 0; prm < ndataParam; prm++) {\n\t\tpda = node->params[prm].p;\n\t\tsuoff[prm] = rf_StripeUnitOffset(layoutPtr, pda->startSector);\n\t\tsuend[prm] = suoff[prm] + pda->numSector;\n\t\tprmToCol[prm] = rf_EUCol(layoutPtr, pda->raidAddress);\n\t}\n\t/* 'sector' is the sector for the current decoding algorithm. For each\n\t * sector in the failed SU, find out the corresponding parameters that\n\t * cover the current sector and that are needed for decoding of this\n\t * sector in failed SU. 2.  Find out if sector is in the shadow of any\n\t * accessed failed SU. If not, malloc a temporary space of a sector in\n\t * size. */\n\tfor (sector = startSector; sector < endSector; sector++) {\n\t\tif (nresults == 2)\n\t\t\tif (!(fsuoff[0] <= sector && sector < fsuend[0]) && !(fsuoff[1] <= sector && sector < fsuend[1]))\n\t\t\t\tcontinue;\n\t\tfor (prm = 0; prm < ndataParam; prm++)\n\t\t\tif (suoff[prm] <= sector && sector < suend[prm])\n\t\t\t\tbuf[(prmToCol[prm])] = ((RF_PhysDiskAddr_t *) node->params[prm].p)->bufPtr +\n\t\t\t\t    rf_RaidAddressToByte(raidPtr, sector - suoff[prm]);\n\t\t/* find out if sector is in the shadow of any accessed failed\n\t\t * SU. If yes, assign dest[0], dest[1] to point at suitable\n\t\t * position of the buffer corresponding to failed SUs. if no,\n\t\t * malloc a temporary space of a sector in size for\n\t\t * destination of decoding. */\n\t\tRF_ASSERT(nresults == 1 || nresults == 2);\n\t\tif (nresults == 1) {\n\t\t\tdest[0] = ((RF_PhysDiskAddr_t *) node->results[0])->bufPtr + rf_RaidAddressToByte(raidPtr, sector - fsuoff[0]);\n\t\t\t/* Always malloc temp buffer to dest[1]  */\n\t\t\tRF_Malloc(dest[1], bytesPerSector, (char *));\n\t\t\tbzero(dest[1], bytesPerSector);\n\t\t\tmallc_two = 1;\n\t\t} else {\n\t\t\tif (fsuoff[0] <= sector && sector < fsuend[0])\n\t\t\t\tdest[0] = ((RF_PhysDiskAddr_t *) node->results[0])->bufPtr + rf_RaidAddressToByte(raidPtr, sector - fsuoff[0]);\n\t\t\telse {\n\t\t\t\tRF_Malloc(dest[0], bytesPerSector, (char *));\n\t\t\t\tbzero(dest[0], bytesPerSector);\n\t\t\t\tmallc_one = 1;\n\t\t\t}\n\t\t\tif (fsuoff[1] <= sector && sector < fsuend[1])\n\t\t\t\tdest[1] = ((RF_PhysDiskAddr_t *) node->results[1])->bufPtr + rf_RaidAddressToByte(raidPtr, sector - fsuoff[1]);\n\t\t\telse {\n\t\t\t\tRF_Malloc(dest[1], bytesPerSector, (char *));\n\t\t\t\tbzero(dest[1], bytesPerSector);\n\t\t\t\tmallc_two = 1;\n\t\t\t}\n\t\t\tRF_ASSERT(mallc_one == 0 || mallc_two == 0);\n\t\t}\n\t\tpbuf = ppda->bufPtr + rf_RaidAddressToByte(raidPtr, sector - psuoff);\n\t\tebuf = epda->bufPtr + rf_RaidAddressToByte(raidPtr, sector - esuoff);\n\t\t/*\n\t         * After finish finding all needed sectors, call doubleEOdecode function for decoding\n\t         * one sector to destination.\n\t         */\n\t\trf_doubleEOdecode(raidPtr, buf, dest, fcol, pbuf, ebuf);\n\t\t/* free all allocated memory, and mark flag to indicate no\n\t\t * memory is being allocated */\n\t\tif (mallc_one == 1)\n\t\t\tRF_Free(dest[0], bytesPerSector);\n\t\tif (mallc_two == 1)\n\t\t\tRF_Free(dest[1], bytesPerSector);\n\t\tmallc_one = mallc_two = 0;\n\t}\n\tRF_Free(buf, numDataCol * sizeof(char *));\n\tif (ndataParam != 0) {\n\t\tRF_Free(suoff, ndataParam * sizeof(long));\n\t\tRF_Free(suend, ndataParam * sizeof(long));\n\t\tRF_Free(prmToCol, ndataParam * sizeof(long));\n\t}\n\tRF_ETIMER_STOP(timer);\n\tRF_ETIMER_EVAL(timer);\n\tif (tracerec) {\n\t\ttracerec->q_us += RF_ETIMER_VAL_US(timer);\n\t}\n\trf_GenericWakeupFunc(node, 0);\n#if 1\n\treturn (0);\t\t/* XXX is this even close!!?!?!!? GO */\n#endif\n}",
    "includes": [
      "#include \"rf_evenodd_dagfuncs.h\"",
      "#include \"rf_evenodd.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_GenericWakeupFunc",
          "args": [
            "node",
            "0"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "rf_GenericWakeupFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
          "lines": "425-460",
          "snippet": "int \nrf_GenericWakeupFunc(node, status)\n\tRF_DagNode_t *node;\n\tint     status;\n{\n\tswitch (node->status) {\n\tcase rf_bwd1:\n\t\tnode->status = rf_bwd2;\n\t\tif (node->dagFuncData)\n\t\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\t\treturn (rf_DiskWriteFuncForThreads(node));\n\t\tbreak;\n\tcase rf_fired:\n\t\tif (status)\n\t\t\tnode->status = rf_bad;\n\t\telse\n\t\t\tnode->status = rf_good;\n\t\tbreak;\n\tcase rf_recover:\n\t\t/* probably should never reach this case */\n\t\tif (status)\n\t\t\tnode->status = rf_panic;\n\t\telse\n\t\t\tnode->status = rf_undone;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"rf_GenericWakeupFunc:\");\n\t\tprintf(\"node->status is %d,\", node->status);\n\t\tprintf(\"status is %d \\n\", status);\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\tif (node->dagFuncData)\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\treturn (rf_FinishNode(node, RF_INTR_CONTEXT));\n}",
          "includes": [
            "#include \"rf_paritylog.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_GenericWakeupFunc(node, status)\n\tRF_DagNode_t *node;\n\tint     status;\n{\n\tswitch (node->status) {\n\tcase rf_bwd1:\n\t\tnode->status = rf_bwd2;\n\t\tif (node->dagFuncData)\n\t\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\t\treturn (rf_DiskWriteFuncForThreads(node));\n\t\tbreak;\n\tcase rf_fired:\n\t\tif (status)\n\t\t\tnode->status = rf_bad;\n\t\telse\n\t\t\tnode->status = rf_good;\n\t\tbreak;\n\tcase rf_recover:\n\t\t/* probably should never reach this case */\n\t\tif (status)\n\t\t\tnode->status = rf_panic;\n\t\telse\n\t\t\tnode->status = rf_undone;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"rf_GenericWakeupFunc:\");\n\t\tprintf(\"node->status is %d,\", node->status);\n\t\tprintf(\"status is %d \\n\", status);\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\tif (node->dagFuncData)\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\treturn (rf_FinishNode(node, RF_INTR_CONTEXT));\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_VAL_US",
          "args": [
            "timer"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_EVAL",
          "args": [
            "timer"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_STOP",
          "args": [
            "timer"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "prmToCol",
            "ndataParam * sizeof(long)"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "suend",
            "ndataParam * sizeof(long)"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "suoff",
            "ndataParam * sizeof(long)"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "buf",
            "numDataCol * sizeof(char *)"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "dest[1]",
            "bytesPerSector"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "dest[0]",
            "bytesPerSector"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_doubleEOdecode",
          "args": [
            "raidPtr",
            "buf",
            "dest",
            "fcol",
            "pbuf",
            "ebuf"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "rf_doubleEOdecode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_evenodd_dagfuncs.c",
          "lines": "452-637",
          "snippet": "void \nrf_doubleEOdecode(\n    RF_Raid_t * raidPtr,\n    char **rrdbuf,\n    char **dest,\n    RF_RowCol_t * fcol,\n    char *pbuf,\n    char *ebuf)\n{\n\tRF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & (raidPtr->Layout);\n\tint     i, j, k, f1, f2, row;\n\tint     rrdrow, erow, count = 0;\n\tint     bytesPerSector = rf_RaidAddressToByte(raidPtr, 1);\n\tint     numRowInEncMatix = (RF_EO_MATRIX_DIM) - 1;\n#if 0\n\tint     pcol = (RF_EO_MATRIX_DIM) - 1;\n#endif\n\tint     ecol = (RF_EO_MATRIX_DIM) - 2;\n\tint     bytesPerEU = bytesPerSector / numRowInEncMatix;\n\tint     numDataCol = layoutPtr->numDataCol;\n#if RF_EO_MATRIX_DIM > 17\n\tint     shortsPerEU = bytesPerEU / sizeof(short);\n\tshort  *rrdbuf_current, *pbuf_current, *ebuf_current;\n\tshort  *dest_smaller, *dest_smaller_current, *dest_larger, *dest_larger_current;\n\tregister short *temp;\n\tshort  *P;\n\n\tRF_ASSERT(bytesPerEU % sizeof(short) == 0);\n\tRF_Malloc(P, bytesPerEU, (short *));\n\tRF_Malloc(temp, bytesPerEU, (short *));\n#elif RF_EO_MATRIX_DIM == 17\n\tint     longsPerEU = bytesPerEU / sizeof(long);\n\tlong   *rrdbuf_current, *pbuf_current, *ebuf_current;\n\tlong   *dest_smaller, *dest_smaller_current, *dest_larger, *dest_larger_current;\n\tregister long *temp;\n\tlong   *P;\n\n\tRF_ASSERT(bytesPerEU % sizeof(long) == 0);\n\tRF_Malloc(P, bytesPerEU, (long *));\n\tRF_Malloc(temp, bytesPerEU, (long *));\n#endif\n\tRF_ASSERT(*((long *) dest[0]) == 0);\n\tRF_ASSERT(*((long *) dest[1]) == 0);\n\tbzero((char *) P, bytesPerEU);\n\tbzero((char *) temp, bytesPerEU);\n\tRF_ASSERT(*P == 0);\n\t/* calculate the 'P' parameter, which, not parity, is the Xor of all\n\t * elements in the last two column, ie. 'E' and 'parity' colume, see\n\t * the Ref. paper by Blaum, et al 1993  */\n\tfor (i = 0; i < numRowInEncMatix; i++)\n\t\tfor (k = 0; k < longsPerEU; k++) {\n#if RF_EO_MATRIX_DIM > 17\n\t\t\tebuf_current = ((short *) ebuf) + i * shortsPerEU + k;\n\t\t\tpbuf_current = ((short *) pbuf) + i * shortsPerEU + k;\n#elif RF_EO_MATRIX_DIM == 17\n\t\t\tebuf_current = ((long *) ebuf) + i * longsPerEU + k;\n\t\t\tpbuf_current = ((long *) pbuf) + i * longsPerEU + k;\n#endif\n\t\t\tP[k] ^= *ebuf_current;\n\t\t\tP[k] ^= *pbuf_current;\n\t\t}\n\tRF_ASSERT(fcol[0] != fcol[1]);\n\tif (fcol[0] < fcol[1]) {\n#if RF_EO_MATRIX_DIM > 17\n\t\tdest_smaller = (short *) (dest[0]);\n\t\tdest_larger = (short *) (dest[1]);\n#elif RF_EO_MATRIX_DIM == 17\n\t\tdest_smaller = (long *) (dest[0]);\n\t\tdest_larger = (long *) (dest[1]);\n#endif\n\t\tf1 = fcol[0];\n\t\tf2 = fcol[1];\n\t} else {\n#if RF_EO_MATRIX_DIM > 17\n\t\tdest_smaller = (short *) (dest[1]);\n\t\tdest_larger = (short *) (dest[0]);\n#elif RF_EO_MATRIX_DIM == 17\n\t\tdest_smaller = (long *) (dest[1]);\n\t\tdest_larger = (long *) (dest[0]);\n#endif\n\t\tf1 = fcol[1];\n\t\tf2 = fcol[0];\n\t}\n\trow = (RF_EO_MATRIX_DIM) - 1;\n\twhile ((row = rf_EO_Mod((row + f1 - f2), RF_EO_MATRIX_DIM)) != ((RF_EO_MATRIX_DIM) - 1)) {\n#if RF_EO_MATRIX_DIM > 17\n\t\tdest_larger_current = dest_larger + row * shortsPerEU;\n\t\tdest_smaller_current = dest_smaller + row * shortsPerEU;\n#elif RF_EO_MATRIX_DIM == 17\n\t\tdest_larger_current = dest_larger + row * longsPerEU;\n\t\tdest_smaller_current = dest_smaller + row * longsPerEU;\n#endif\n\t\t/**    Do the diagonal recovery. Initially, temp[k] = (failed 1),\n\t\t       which is the failed data in the colume which has smaller col index. **/\n\t\t/* step 1:  ^(SUM of nonfailed in-diagonal A(rrdrow,0..m-3))         */\n\t\tfor (j = 0; j < numDataCol; j++) {\n\t\t\tif (j == f1 || j == f2)\n\t\t\t\tcontinue;\n\t\t\trrdrow = rf_EO_Mod((row + f2 - j), RF_EO_MATRIX_DIM);\n\t\t\tif (rrdrow != (RF_EO_MATRIX_DIM) - 1) {\n#if RF_EO_MATRIX_DIM > 17\n\t\t\t\trrdbuf_current = (short *) (rrdbuf[j]) + rrdrow * shortsPerEU;\n\t\t\t\tfor (k = 0; k < shortsPerEU; k++)\n\t\t\t\t\ttemp[k] ^= *(rrdbuf_current + k);\n#elif RF_EO_MATRIX_DIM == 17\n\t\t\t\trrdbuf_current = (long *) (rrdbuf[j]) + rrdrow * longsPerEU;\n\t\t\t\tfor (k = 0; k < longsPerEU; k++)\n\t\t\t\t\ttemp[k] ^= *(rrdbuf_current + k);\n#endif\n\t\t\t}\n\t\t}\n\t\t/* step 2:  ^E(erow,m-2), If erow is at the buttom row, don't\n\t\t * Xor into it  E(erow,m-2) = (principle diagonal) ^ (failed\n\t\t * 1) ^ (failed 2) ^ ( SUM of nonfailed in-diagonal\n\t\t * A(rrdrow,0..m-3) ) After this step, temp[k] = (principle\n\t\t * diagonal) ^ (failed 2)       */\n\n\t\terow = rf_EO_Mod((row + f2 - ecol), (RF_EO_MATRIX_DIM));\n\t\tif (erow != (RF_EO_MATRIX_DIM) - 1) {\n#if RF_EO_MATRIX_DIM > 17\n\t\t\tebuf_current = (short *) ebuf + shortsPerEU * erow;\n\t\t\tfor (k = 0; k < shortsPerEU; k++)\n\t\t\t\ttemp[k] ^= *(ebuf_current + k);\n#elif RF_EO_MATRIX_DIM == 17\n\t\t\tebuf_current = (long *) ebuf + longsPerEU * erow;\n\t\t\tfor (k = 0; k < longsPerEU; k++)\n\t\t\t\ttemp[k] ^= *(ebuf_current + k);\n#endif\n\t\t}\n\t\t/* step 3: ^P to obtain the failed data (failed 2).  P can be\n\t\t * proved to be actually  (principle diagonal)  After this\n\t\t * step, temp[k] = (failed 2), the failed data to be recovered */\n#if RF_EO_MATRIX_DIM > 17\n\t\tfor (k = 0; k < shortsPerEU; k++)\n\t\t\ttemp[k] ^= P[k];\n\t\t/* Put the data to the destination buffer                              */\n\t\tfor (k = 0; k < shortsPerEU; k++)\n\t\t\tdest_larger_current[k] = temp[k];\n#elif RF_EO_MATRIX_DIM == 17\n\t\tfor (k = 0; k < longsPerEU; k++)\n\t\t\ttemp[k] ^= P[k];\n\t\t/* Put the data to the destination buffer                              */\n\t\tfor (k = 0; k < longsPerEU; k++)\n\t\t\tdest_larger_current[k] = temp[k];\n#endif\n\n\t\t/**          THE FOLLOWING DO THE HORIZONTAL XOR                **/\n\t\t/* step 1:  ^(SUM of A(row,0..m-3)), ie. all nonfailed data\n\t\t * columes    */\n\t\tfor (j = 0; j < numDataCol; j++) {\n\t\t\tif (j == f1 || j == f2)\n\t\t\t\tcontinue;\n#if RF_EO_MATRIX_DIM > 17\n\t\t\trrdbuf_current = (short *) (rrdbuf[j]) + row * shortsPerEU;\n\t\t\tfor (k = 0; k < shortsPerEU; k++)\n\t\t\t\ttemp[k] ^= *(rrdbuf_current + k);\n#elif RF_EO_MATRIX_DIM == 17\n\t\t\trrdbuf_current = (long *) (rrdbuf[j]) + row * longsPerEU;\n\t\t\tfor (k = 0; k < longsPerEU; k++)\n\t\t\t\ttemp[k] ^= *(rrdbuf_current + k);\n#endif\n\t\t}\n\t\t/* step 2: ^A(row,m-1) */\n\t\t/* step 3: Put the data to the destination buffer                             \t */\n#if RF_EO_MATRIX_DIM > 17\n\t\tpbuf_current = (short *) pbuf + shortsPerEU * row;\n\t\tfor (k = 0; k < shortsPerEU; k++)\n\t\t\ttemp[k] ^= *(pbuf_current + k);\n\t\tfor (k = 0; k < shortsPerEU; k++)\n\t\t\tdest_smaller_current[k] = temp[k];\n#elif RF_EO_MATRIX_DIM == 17\n\t\tpbuf_current = (long *) pbuf + longsPerEU * row;\n\t\tfor (k = 0; k < longsPerEU; k++)\n\t\t\ttemp[k] ^= *(pbuf_current + k);\n\t\tfor (k = 0; k < longsPerEU; k++)\n\t\t\tdest_smaller_current[k] = temp[k];\n#endif\n\t\tcount++;\n\t}\n\t/* Check if all Encoding Unit in the data buffer have been decoded,\n\t * according EvenOdd theory, if \"RF_EO_MATRIX_DIM\" is a prime number,\n\t * this algorithm will covered all buffer \t\t\t\t */\n\tRF_ASSERT(count == numRowInEncMatix);\n\tRF_Free((char *) P, bytesPerEU);\n\tRF_Free((char *) temp, bytesPerEU);\n}",
          "includes": [
            "#include \"rf_evenodd_dagfuncs.h\"",
            "#include \"rf_evenodd.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dagdegwr.h\"",
            "#include \"rf_dagdegrd.h\"",
            "#include \"rf_dagffwr.h\"",
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_evenodd_dagfuncs.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_configure.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_doubleEOdecode(\n    RF_Raid_t * raidPtr,\n    char **rrdbuf,\n    char **dest,\n    RF_RowCol_t * fcol,\n    char *pbuf,\n    char *ebuf)\n{\n\tRF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & (raidPtr->Layout);\n\tint     i, j, k, f1, f2, row;\n\tint     rrdrow, erow, count = 0;\n\tint     bytesPerSector = rf_RaidAddressToByte(raidPtr, 1);\n\tint     numRowInEncMatix = (RF_EO_MATRIX_DIM) - 1;\n#if 0\n\tint     pcol = (RF_EO_MATRIX_DIM) - 1;\n#endif\n\tint     ecol = (RF_EO_MATRIX_DIM) - 2;\n\tint     bytesPerEU = bytesPerSector / numRowInEncMatix;\n\tint     numDataCol = layoutPtr->numDataCol;\n#if RF_EO_MATRIX_DIM > 17\n\tint     shortsPerEU = bytesPerEU / sizeof(short);\n\tshort  *rrdbuf_current, *pbuf_current, *ebuf_current;\n\tshort  *dest_smaller, *dest_smaller_current, *dest_larger, *dest_larger_current;\n\tregister short *temp;\n\tshort  *P;\n\n\tRF_ASSERT(bytesPerEU % sizeof(short) == 0);\n\tRF_Malloc(P, bytesPerEU, (short *));\n\tRF_Malloc(temp, bytesPerEU, (short *));\n#elif RF_EO_MATRIX_DIM == 17\n\tint     longsPerEU = bytesPerEU / sizeof(long);\n\tlong   *rrdbuf_current, *pbuf_current, *ebuf_current;\n\tlong   *dest_smaller, *dest_smaller_current, *dest_larger, *dest_larger_current;\n\tregister long *temp;\n\tlong   *P;\n\n\tRF_ASSERT(bytesPerEU % sizeof(long) == 0);\n\tRF_Malloc(P, bytesPerEU, (long *));\n\tRF_Malloc(temp, bytesPerEU, (long *));\n#endif\n\tRF_ASSERT(*((long *) dest[0]) == 0);\n\tRF_ASSERT(*((long *) dest[1]) == 0);\n\tbzero((char *) P, bytesPerEU);\n\tbzero((char *) temp, bytesPerEU);\n\tRF_ASSERT(*P == 0);\n\t/* calculate the 'P' parameter, which, not parity, is the Xor of all\n\t * elements in the last two column, ie. 'E' and 'parity' colume, see\n\t * the Ref. paper by Blaum, et al 1993  */\n\tfor (i = 0; i < numRowInEncMatix; i++)\n\t\tfor (k = 0; k < longsPerEU; k++) {\n#if RF_EO_MATRIX_DIM > 17\n\t\t\tebuf_current = ((short *) ebuf) + i * shortsPerEU + k;\n\t\t\tpbuf_current = ((short *) pbuf) + i * shortsPerEU + k;\n#elif RF_EO_MATRIX_DIM == 17\n\t\t\tebuf_current = ((long *) ebuf) + i * longsPerEU + k;\n\t\t\tpbuf_current = ((long *) pbuf) + i * longsPerEU + k;\n#endif\n\t\t\tP[k] ^= *ebuf_current;\n\t\t\tP[k] ^= *pbuf_current;\n\t\t}\n\tRF_ASSERT(fcol[0] != fcol[1]);\n\tif (fcol[0] < fcol[1]) {\n#if RF_EO_MATRIX_DIM > 17\n\t\tdest_smaller = (short *) (dest[0]);\n\t\tdest_larger = (short *) (dest[1]);\n#elif RF_EO_MATRIX_DIM == 17\n\t\tdest_smaller = (long *) (dest[0]);\n\t\tdest_larger = (long *) (dest[1]);\n#endif\n\t\tf1 = fcol[0];\n\t\tf2 = fcol[1];\n\t} else {\n#if RF_EO_MATRIX_DIM > 17\n\t\tdest_smaller = (short *) (dest[1]);\n\t\tdest_larger = (short *) (dest[0]);\n#elif RF_EO_MATRIX_DIM == 17\n\t\tdest_smaller = (long *) (dest[1]);\n\t\tdest_larger = (long *) (dest[0]);\n#endif\n\t\tf1 = fcol[1];\n\t\tf2 = fcol[0];\n\t}\n\trow = (RF_EO_MATRIX_DIM) - 1;\n\twhile ((row = rf_EO_Mod((row + f1 - f2), RF_EO_MATRIX_DIM)) != ((RF_EO_MATRIX_DIM) - 1)) {\n#if RF_EO_MATRIX_DIM > 17\n\t\tdest_larger_current = dest_larger + row * shortsPerEU;\n\t\tdest_smaller_current = dest_smaller + row * shortsPerEU;\n#elif RF_EO_MATRIX_DIM == 17\n\t\tdest_larger_current = dest_larger + row * longsPerEU;\n\t\tdest_smaller_current = dest_smaller + row * longsPerEU;\n#endif\n\t\t/**    Do the diagonal recovery. Initially, temp[k] = (failed 1),\n\t\t       which is the failed data in the colume which has smaller col index. **/\n\t\t/* step 1:  ^(SUM of nonfailed in-diagonal A(rrdrow,0..m-3))         */\n\t\tfor (j = 0; j < numDataCol; j++) {\n\t\t\tif (j == f1 || j == f2)\n\t\t\t\tcontinue;\n\t\t\trrdrow = rf_EO_Mod((row + f2 - j), RF_EO_MATRIX_DIM);\n\t\t\tif (rrdrow != (RF_EO_MATRIX_DIM) - 1) {\n#if RF_EO_MATRIX_DIM > 17\n\t\t\t\trrdbuf_current = (short *) (rrdbuf[j]) + rrdrow * shortsPerEU;\n\t\t\t\tfor (k = 0; k < shortsPerEU; k++)\n\t\t\t\t\ttemp[k] ^= *(rrdbuf_current + k);\n#elif RF_EO_MATRIX_DIM == 17\n\t\t\t\trrdbuf_current = (long *) (rrdbuf[j]) + rrdrow * longsPerEU;\n\t\t\t\tfor (k = 0; k < longsPerEU; k++)\n\t\t\t\t\ttemp[k] ^= *(rrdbuf_current + k);\n#endif\n\t\t\t}\n\t\t}\n\t\t/* step 2:  ^E(erow,m-2), If erow is at the buttom row, don't\n\t\t * Xor into it  E(erow,m-2) = (principle diagonal) ^ (failed\n\t\t * 1) ^ (failed 2) ^ ( SUM of nonfailed in-diagonal\n\t\t * A(rrdrow,0..m-3) ) After this step, temp[k] = (principle\n\t\t * diagonal) ^ (failed 2)       */\n\n\t\terow = rf_EO_Mod((row + f2 - ecol), (RF_EO_MATRIX_DIM));\n\t\tif (erow != (RF_EO_MATRIX_DIM) - 1) {\n#if RF_EO_MATRIX_DIM > 17\n\t\t\tebuf_current = (short *) ebuf + shortsPerEU * erow;\n\t\t\tfor (k = 0; k < shortsPerEU; k++)\n\t\t\t\ttemp[k] ^= *(ebuf_current + k);\n#elif RF_EO_MATRIX_DIM == 17\n\t\t\tebuf_current = (long *) ebuf + longsPerEU * erow;\n\t\t\tfor (k = 0; k < longsPerEU; k++)\n\t\t\t\ttemp[k] ^= *(ebuf_current + k);\n#endif\n\t\t}\n\t\t/* step 3: ^P to obtain the failed data (failed 2).  P can be\n\t\t * proved to be actually  (principle diagonal)  After this\n\t\t * step, temp[k] = (failed 2), the failed data to be recovered */\n#if RF_EO_MATRIX_DIM > 17\n\t\tfor (k = 0; k < shortsPerEU; k++)\n\t\t\ttemp[k] ^= P[k];\n\t\t/* Put the data to the destination buffer                              */\n\t\tfor (k = 0; k < shortsPerEU; k++)\n\t\t\tdest_larger_current[k] = temp[k];\n#elif RF_EO_MATRIX_DIM == 17\n\t\tfor (k = 0; k < longsPerEU; k++)\n\t\t\ttemp[k] ^= P[k];\n\t\t/* Put the data to the destination buffer                              */\n\t\tfor (k = 0; k < longsPerEU; k++)\n\t\t\tdest_larger_current[k] = temp[k];\n#endif\n\n\t\t/**          THE FOLLOWING DO THE HORIZONTAL XOR                **/\n\t\t/* step 1:  ^(SUM of A(row,0..m-3)), ie. all nonfailed data\n\t\t * columes    */\n\t\tfor (j = 0; j < numDataCol; j++) {\n\t\t\tif (j == f1 || j == f2)\n\t\t\t\tcontinue;\n#if RF_EO_MATRIX_DIM > 17\n\t\t\trrdbuf_current = (short *) (rrdbuf[j]) + row * shortsPerEU;\n\t\t\tfor (k = 0; k < shortsPerEU; k++)\n\t\t\t\ttemp[k] ^= *(rrdbuf_current + k);\n#elif RF_EO_MATRIX_DIM == 17\n\t\t\trrdbuf_current = (long *) (rrdbuf[j]) + row * longsPerEU;\n\t\t\tfor (k = 0; k < longsPerEU; k++)\n\t\t\t\ttemp[k] ^= *(rrdbuf_current + k);\n#endif\n\t\t}\n\t\t/* step 2: ^A(row,m-1) */\n\t\t/* step 3: Put the data to the destination buffer                             \t */\n#if RF_EO_MATRIX_DIM > 17\n\t\tpbuf_current = (short *) pbuf + shortsPerEU * row;\n\t\tfor (k = 0; k < shortsPerEU; k++)\n\t\t\ttemp[k] ^= *(pbuf_current + k);\n\t\tfor (k = 0; k < shortsPerEU; k++)\n\t\t\tdest_smaller_current[k] = temp[k];\n#elif RF_EO_MATRIX_DIM == 17\n\t\tpbuf_current = (long *) pbuf + longsPerEU * row;\n\t\tfor (k = 0; k < longsPerEU; k++)\n\t\t\ttemp[k] ^= *(pbuf_current + k);\n\t\tfor (k = 0; k < longsPerEU; k++)\n\t\t\tdest_smaller_current[k] = temp[k];\n#endif\n\t\tcount++;\n\t}\n\t/* Check if all Encoding Unit in the data buffer have been decoded,\n\t * according EvenOdd theory, if \"RF_EO_MATRIX_DIM\" is a prime number,\n\t * this algorithm will covered all buffer \t\t\t\t */\n\tRF_ASSERT(count == numRowInEncMatix);\n\tRF_Free((char *) P, bytesPerEU);\n\tRF_Free((char *) temp, bytesPerEU);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "sector - esuoff"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "sector - psuoff"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "mallc_one == 0 || mallc_two == 0"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "dest[1]",
            "bytesPerSector"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "dest[1]",
            "bytesPerSector",
            "(char *)"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "sector - fsuoff[1]"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "dest[0]",
            "bytesPerSector"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "dest[0]",
            "bytesPerSector",
            "(char *)"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "sector - fsuoff[0]"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "dest[1]",
            "bytesPerSector"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "dest[1]",
            "bytesPerSector",
            "(char *)"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "sector - fsuoff[0]"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "nresults == 1 || nresults == 2"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "sector - suoff[prm]"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_EUCol",
          "args": [
            "layoutPtr",
            "pda->raidAddress"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_StripeUnitOffset",
          "args": [
            "layoutPtr",
            "pda->startSector"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_MAX",
          "args": [
            "fsuend[0]",
            "fsuend[1]"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_MIN",
          "args": [
            "pda0->startSector",
            "pda1->startSector"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_StripeUnitOffset",
          "args": [
            "layoutPtr",
            "pda1->startSector"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_StripeUnitOffset",
          "args": [
            "layoutPtr",
            "pda0->startSector"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_EUCol",
          "args": [
            "layoutPtr",
            "pda1->raidAddress"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_EUCol",
          "args": [
            "layoutPtr",
            "pda0->raidAddress"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "pda1->bufPtr",
            "bytesPerSector * pda1->numSector"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "pda0->bufPtr",
            "bytesPerSector * pda0->numSector"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "nresults == 2"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "i < numDataCol"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_DEAD_DISK",
          "args": [
            "raidPtr->Disks[npda.row][npda.col].status"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "raidPtr",
            "npda.raidAddress",
            "&(npda.row)",
            "&(npda.col)",
            "&(npda.startSector)",
            "0"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressOfPrevStripeBoundary",
          "args": [
            "layoutPtr",
            "asmap->raidAddress"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_EUCol",
          "args": [
            "layoutPtr",
            "pda->raidAddress"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_StripeUnitOffset",
          "args": [
            "layoutPtr",
            "pda->startSector"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "pda->bufPtr",
            "bytesPerSector * pda->numSector"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "psuoff == esuoff"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_StripeUnitOffset",
          "args": [
            "layoutPtr",
            "epda->startSector"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_StripeUnitOffset",
          "args": [
            "layoutPtr",
            "ppda->startSector"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "epda2->type == RF_PDA_TYPE_Q"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "ppda2->type == RF_PDA_TYPE_PARITY"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "0"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "prmToCol",
            "ndataParam * sizeof(long)",
            "(long *)"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "suend",
            "ndataParam * sizeof(long)",
            "(long *)"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "suoff",
            "ndataParam * sizeof(long)",
            "(long *)"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "buf",
            "numDataCol * sizeof(char *)",
            "(char **)"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_START",
          "args": [
            "timer"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "1"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_evenodd_dagfuncs.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_configure.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nint \nrf_EvenOddDoubleRecoveryFunc(node)\n\tRF_DagNode_t *node;\n{\n\tint     ndataParam = 0;\n\tint     np = node->numParams;\n\tRF_AccessStripeMap_t *asmap = (RF_AccessStripeMap_t *) node->params[np - 1].p;\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[np - 2].p;\n\tRF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & (raidPtr->Layout);\n\tint     i, prm, sector, nresults = node->numResults;\n\tRF_SectorCount_t secPerSU = layoutPtr->sectorsPerStripeUnit;\n\tunsigned sosAddr;\n\tint     two = 0, mallc_one = 0, mallc_two = 0;\t/* flags to indicate if\n\t\t\t\t\t\t\t * memory is allocated */\n\tint     bytesPerSector = rf_RaidAddressToByte(raidPtr, 1);\n\tRF_PhysDiskAddr_t *ppda, *ppda2, *epda, *epda2, *pda, *pda0, *pda1,\n\t        npda;\n\tRF_RowCol_t fcol[2], fsuoff[2], fsuend[2], numDataCol = layoutPtr->numDataCol;\n\tchar  **buf, *ebuf, *pbuf, *dest[2];\n\tlong   *suoff = NULL, *suend = NULL, *prmToCol = NULL, psuoff, esuoff;\n\tRF_SectorNum_t startSector, endSector;\n\tRF_Etimer_t timer;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\n\tRF_ETIMER_START(timer);\n\n\t/* Find out the number of parameters which are pdas for data\n\t * information */\n\tfor (i = 0; i <= np; i++)\n\t\tif (((RF_PhysDiskAddr_t *) node->params[i].p)->type != RF_PDA_TYPE_DATA) {\n\t\t\tndataParam = i;\n\t\t\tbreak;\n\t\t}\n\tRF_Malloc(buf, numDataCol * sizeof(char *), (char **));\n\tif (ndataParam != 0) {\n\t\tRF_Malloc(suoff, ndataParam * sizeof(long), (long *));\n\t\tRF_Malloc(suend, ndataParam * sizeof(long), (long *));\n\t\tRF_Malloc(prmToCol, ndataParam * sizeof(long), (long *));\n\t}\n\tif (asmap->failedPDAs[1] &&\n\t    (asmap->failedPDAs[1]->numSector + asmap->failedPDAs[0]->numSector < secPerSU)) {\n\t\tRF_ASSERT(0);\t/* currently, no support for this situation */\n\t\tppda = node->params[np - 6].p;\n\t\tppda2 = node->params[np - 5].p;\n\t\tRF_ASSERT(ppda2->type == RF_PDA_TYPE_PARITY);\n\t\tepda = node->params[np - 4].p;\n\t\tepda2 = node->params[np - 3].p;\n\t\tRF_ASSERT(epda2->type == RF_PDA_TYPE_Q);\n\t\ttwo = 1;\n\t} else {\n\t\tppda = node->params[np - 4].p;\n\t\tepda = node->params[np - 3].p;\n\t\tpsuoff = rf_StripeUnitOffset(layoutPtr, ppda->startSector);\n\t\tesuoff = rf_StripeUnitOffset(layoutPtr, epda->startSector);\n\t\tRF_ASSERT(psuoff == esuoff);\n\t}\n\t/*\n            the followings have three goals:\n            1. determine the startSector to begin decoding and endSector to end decoding.\n            2. determine the colume numbers of the two failed disks.\n            3. determine the offset and end offset of the access within each failed stripe unit.\n         */\n\tif (nresults == 1) {\n\t\t/* find the startSector to begin decoding */\n\t\tpda = node->results[0];\n\t\tbzero(pda->bufPtr, bytesPerSector * pda->numSector);\n\t\tfsuoff[0] = rf_StripeUnitOffset(layoutPtr, pda->startSector);\n\t\tfsuend[0] = fsuoff[0] + pda->numSector;\n\t\tstartSector = fsuoff[0];\n\t\tendSector = fsuend[0];\n\n\t\t/* find out the the column of failed disk being accessed */\n\t\tfcol[0] = rf_EUCol(layoutPtr, pda->raidAddress);\n\n\t\t/* find out the other failed colume not accessed */\n\t\tsosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, asmap->raidAddress);\n\t\tfor (i = 0; i < numDataCol; i++) {\n\t\t\tnpda.raidAddress = sosAddr + (i * secPerSU);\n\t\t\t(raidPtr->Layout.map->MapSector) (raidPtr, npda.raidAddress, &(npda.row), &(npda.col), &(npda.startSector), 0);\n\t\t\t/* skip over dead disks */\n\t\t\tif (RF_DEAD_DISK(raidPtr->Disks[npda.row][npda.col].status))\n\t\t\t\tif (i != fcol[0])\n\t\t\t\t\tbreak;\n\t\t}\n\t\tRF_ASSERT(i < numDataCol);\n\t\tfcol[1] = i;\n\t} else {\n\t\tRF_ASSERT(nresults == 2);\n\t\tpda0 = node->results[0];\n\t\tbzero(pda0->bufPtr, bytesPerSector * pda0->numSector);\n\t\tpda1 = node->results[1];\n\t\tbzero(pda1->bufPtr, bytesPerSector * pda1->numSector);\n\t\t/* determine the failed colume numbers of the two failed\n\t\t * disks. */\n\t\tfcol[0] = rf_EUCol(layoutPtr, pda0->raidAddress);\n\t\tfcol[1] = rf_EUCol(layoutPtr, pda1->raidAddress);\n\t\t/* determine the offset and end offset of the access within\n\t\t * each failed stripe unit. */\n\t\tfsuoff[0] = rf_StripeUnitOffset(layoutPtr, pda0->startSector);\n\t\tfsuend[0] = fsuoff[0] + pda0->numSector;\n\t\tfsuoff[1] = rf_StripeUnitOffset(layoutPtr, pda1->startSector);\n\t\tfsuend[1] = fsuoff[1] + pda1->numSector;\n\t\t/* determine the startSector to begin decoding */\n\t\tstartSector = RF_MIN(pda0->startSector, pda1->startSector);\n\t\t/* determine the endSector to end decoding */\n\t\tendSector = RF_MAX(fsuend[0], fsuend[1]);\n\t}\n\t/*\n\t      assign the beginning sector and the end sector for each parameter\n\t      find out the corresponding colume # for each parameter\n        */\n\tfor (prm = 0; prm < ndataParam; prm++) {\n\t\tpda = node->params[prm].p;\n\t\tsuoff[prm] = rf_StripeUnitOffset(layoutPtr, pda->startSector);\n\t\tsuend[prm] = suoff[prm] + pda->numSector;\n\t\tprmToCol[prm] = rf_EUCol(layoutPtr, pda->raidAddress);\n\t}\n\t/* 'sector' is the sector for the current decoding algorithm. For each\n\t * sector in the failed SU, find out the corresponding parameters that\n\t * cover the current sector and that are needed for decoding of this\n\t * sector in failed SU. 2.  Find out if sector is in the shadow of any\n\t * accessed failed SU. If not, malloc a temporary space of a sector in\n\t * size. */\n\tfor (sector = startSector; sector < endSector; sector++) {\n\t\tif (nresults == 2)\n\t\t\tif (!(fsuoff[0] <= sector && sector < fsuend[0]) && !(fsuoff[1] <= sector && sector < fsuend[1]))\n\t\t\t\tcontinue;\n\t\tfor (prm = 0; prm < ndataParam; prm++)\n\t\t\tif (suoff[prm] <= sector && sector < suend[prm])\n\t\t\t\tbuf[(prmToCol[prm])] = ((RF_PhysDiskAddr_t *) node->params[prm].p)->bufPtr +\n\t\t\t\t    rf_RaidAddressToByte(raidPtr, sector - suoff[prm]);\n\t\t/* find out if sector is in the shadow of any accessed failed\n\t\t * SU. If yes, assign dest[0], dest[1] to point at suitable\n\t\t * position of the buffer corresponding to failed SUs. if no,\n\t\t * malloc a temporary space of a sector in size for\n\t\t * destination of decoding. */\n\t\tRF_ASSERT(nresults == 1 || nresults == 2);\n\t\tif (nresults == 1) {\n\t\t\tdest[0] = ((RF_PhysDiskAddr_t *) node->results[0])->bufPtr + rf_RaidAddressToByte(raidPtr, sector - fsuoff[0]);\n\t\t\t/* Always malloc temp buffer to dest[1]  */\n\t\t\tRF_Malloc(dest[1], bytesPerSector, (char *));\n\t\t\tbzero(dest[1], bytesPerSector);\n\t\t\tmallc_two = 1;\n\t\t} else {\n\t\t\tif (fsuoff[0] <= sector && sector < fsuend[0])\n\t\t\t\tdest[0] = ((RF_PhysDiskAddr_t *) node->results[0])->bufPtr + rf_RaidAddressToByte(raidPtr, sector - fsuoff[0]);\n\t\t\telse {\n\t\t\t\tRF_Malloc(dest[0], bytesPerSector, (char *));\n\t\t\t\tbzero(dest[0], bytesPerSector);\n\t\t\t\tmallc_one = 1;\n\t\t\t}\n\t\t\tif (fsuoff[1] <= sector && sector < fsuend[1])\n\t\t\t\tdest[1] = ((RF_PhysDiskAddr_t *) node->results[1])->bufPtr + rf_RaidAddressToByte(raidPtr, sector - fsuoff[1]);\n\t\t\telse {\n\t\t\t\tRF_Malloc(dest[1], bytesPerSector, (char *));\n\t\t\t\tbzero(dest[1], bytesPerSector);\n\t\t\t\tmallc_two = 1;\n\t\t\t}\n\t\t\tRF_ASSERT(mallc_one == 0 || mallc_two == 0);\n\t\t}\n\t\tpbuf = ppda->bufPtr + rf_RaidAddressToByte(raidPtr, sector - psuoff);\n\t\tebuf = epda->bufPtr + rf_RaidAddressToByte(raidPtr, sector - esuoff);\n\t\t/*\n\t         * After finish finding all needed sectors, call doubleEOdecode function for decoding\n\t         * one sector to destination.\n\t         */\n\t\trf_doubleEOdecode(raidPtr, buf, dest, fcol, pbuf, ebuf);\n\t\t/* free all allocated memory, and mark flag to indicate no\n\t\t * memory is being allocated */\n\t\tif (mallc_one == 1)\n\t\t\tRF_Free(dest[0], bytesPerSector);\n\t\tif (mallc_two == 1)\n\t\t\tRF_Free(dest[1], bytesPerSector);\n\t\tmallc_one = mallc_two = 0;\n\t}\n\tRF_Free(buf, numDataCol * sizeof(char *));\n\tif (ndataParam != 0) {\n\t\tRF_Free(suoff, ndataParam * sizeof(long));\n\t\tRF_Free(suend, ndataParam * sizeof(long));\n\t\tRF_Free(prmToCol, ndataParam * sizeof(long));\n\t}\n\tRF_ETIMER_STOP(timer);\n\tRF_ETIMER_EVAL(timer);\n\tif (tracerec) {\n\t\ttracerec->q_us += RF_ETIMER_VAL_US(timer);\n\t}\n\trf_GenericWakeupFunc(node, 0);\n#if 1\n\treturn (0);\t\t/* XXX is this even close!!?!?!!? GO */\n#endif\n}"
  },
  {
    "function_name": "rf_doubleEOdecode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_evenodd_dagfuncs.c",
    "lines": "452-637",
    "snippet": "void \nrf_doubleEOdecode(\n    RF_Raid_t * raidPtr,\n    char **rrdbuf,\n    char **dest,\n    RF_RowCol_t * fcol,\n    char *pbuf,\n    char *ebuf)\n{\n\tRF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & (raidPtr->Layout);\n\tint     i, j, k, f1, f2, row;\n\tint     rrdrow, erow, count = 0;\n\tint     bytesPerSector = rf_RaidAddressToByte(raidPtr, 1);\n\tint     numRowInEncMatix = (RF_EO_MATRIX_DIM) - 1;\n#if 0\n\tint     pcol = (RF_EO_MATRIX_DIM) - 1;\n#endif\n\tint     ecol = (RF_EO_MATRIX_DIM) - 2;\n\tint     bytesPerEU = bytesPerSector / numRowInEncMatix;\n\tint     numDataCol = layoutPtr->numDataCol;\n#if RF_EO_MATRIX_DIM > 17\n\tint     shortsPerEU = bytesPerEU / sizeof(short);\n\tshort  *rrdbuf_current, *pbuf_current, *ebuf_current;\n\tshort  *dest_smaller, *dest_smaller_current, *dest_larger, *dest_larger_current;\n\tregister short *temp;\n\tshort  *P;\n\n\tRF_ASSERT(bytesPerEU % sizeof(short) == 0);\n\tRF_Malloc(P, bytesPerEU, (short *));\n\tRF_Malloc(temp, bytesPerEU, (short *));\n#elif RF_EO_MATRIX_DIM == 17\n\tint     longsPerEU = bytesPerEU / sizeof(long);\n\tlong   *rrdbuf_current, *pbuf_current, *ebuf_current;\n\tlong   *dest_smaller, *dest_smaller_current, *dest_larger, *dest_larger_current;\n\tregister long *temp;\n\tlong   *P;\n\n\tRF_ASSERT(bytesPerEU % sizeof(long) == 0);\n\tRF_Malloc(P, bytesPerEU, (long *));\n\tRF_Malloc(temp, bytesPerEU, (long *));\n#endif\n\tRF_ASSERT(*((long *) dest[0]) == 0);\n\tRF_ASSERT(*((long *) dest[1]) == 0);\n\tbzero((char *) P, bytesPerEU);\n\tbzero((char *) temp, bytesPerEU);\n\tRF_ASSERT(*P == 0);\n\t/* calculate the 'P' parameter, which, not parity, is the Xor of all\n\t * elements in the last two column, ie. 'E' and 'parity' colume, see\n\t * the Ref. paper by Blaum, et al 1993  */\n\tfor (i = 0; i < numRowInEncMatix; i++)\n\t\tfor (k = 0; k < longsPerEU; k++) {\n#if RF_EO_MATRIX_DIM > 17\n\t\t\tebuf_current = ((short *) ebuf) + i * shortsPerEU + k;\n\t\t\tpbuf_current = ((short *) pbuf) + i * shortsPerEU + k;\n#elif RF_EO_MATRIX_DIM == 17\n\t\t\tebuf_current = ((long *) ebuf) + i * longsPerEU + k;\n\t\t\tpbuf_current = ((long *) pbuf) + i * longsPerEU + k;\n#endif\n\t\t\tP[k] ^= *ebuf_current;\n\t\t\tP[k] ^= *pbuf_current;\n\t\t}\n\tRF_ASSERT(fcol[0] != fcol[1]);\n\tif (fcol[0] < fcol[1]) {\n#if RF_EO_MATRIX_DIM > 17\n\t\tdest_smaller = (short *) (dest[0]);\n\t\tdest_larger = (short *) (dest[1]);\n#elif RF_EO_MATRIX_DIM == 17\n\t\tdest_smaller = (long *) (dest[0]);\n\t\tdest_larger = (long *) (dest[1]);\n#endif\n\t\tf1 = fcol[0];\n\t\tf2 = fcol[1];\n\t} else {\n#if RF_EO_MATRIX_DIM > 17\n\t\tdest_smaller = (short *) (dest[1]);\n\t\tdest_larger = (short *) (dest[0]);\n#elif RF_EO_MATRIX_DIM == 17\n\t\tdest_smaller = (long *) (dest[1]);\n\t\tdest_larger = (long *) (dest[0]);\n#endif\n\t\tf1 = fcol[1];\n\t\tf2 = fcol[0];\n\t}\n\trow = (RF_EO_MATRIX_DIM) - 1;\n\twhile ((row = rf_EO_Mod((row + f1 - f2), RF_EO_MATRIX_DIM)) != ((RF_EO_MATRIX_DIM) - 1)) {\n#if RF_EO_MATRIX_DIM > 17\n\t\tdest_larger_current = dest_larger + row * shortsPerEU;\n\t\tdest_smaller_current = dest_smaller + row * shortsPerEU;\n#elif RF_EO_MATRIX_DIM == 17\n\t\tdest_larger_current = dest_larger + row * longsPerEU;\n\t\tdest_smaller_current = dest_smaller + row * longsPerEU;\n#endif\n\t\t/**    Do the diagonal recovery. Initially, temp[k] = (failed 1),\n\t\t       which is the failed data in the colume which has smaller col index. **/\n\t\t/* step 1:  ^(SUM of nonfailed in-diagonal A(rrdrow,0..m-3))         */\n\t\tfor (j = 0; j < numDataCol; j++) {\n\t\t\tif (j == f1 || j == f2)\n\t\t\t\tcontinue;\n\t\t\trrdrow = rf_EO_Mod((row + f2 - j), RF_EO_MATRIX_DIM);\n\t\t\tif (rrdrow != (RF_EO_MATRIX_DIM) - 1) {\n#if RF_EO_MATRIX_DIM > 17\n\t\t\t\trrdbuf_current = (short *) (rrdbuf[j]) + rrdrow * shortsPerEU;\n\t\t\t\tfor (k = 0; k < shortsPerEU; k++)\n\t\t\t\t\ttemp[k] ^= *(rrdbuf_current + k);\n#elif RF_EO_MATRIX_DIM == 17\n\t\t\t\trrdbuf_current = (long *) (rrdbuf[j]) + rrdrow * longsPerEU;\n\t\t\t\tfor (k = 0; k < longsPerEU; k++)\n\t\t\t\t\ttemp[k] ^= *(rrdbuf_current + k);\n#endif\n\t\t\t}\n\t\t}\n\t\t/* step 2:  ^E(erow,m-2), If erow is at the buttom row, don't\n\t\t * Xor into it  E(erow,m-2) = (principle diagonal) ^ (failed\n\t\t * 1) ^ (failed 2) ^ ( SUM of nonfailed in-diagonal\n\t\t * A(rrdrow,0..m-3) ) After this step, temp[k] = (principle\n\t\t * diagonal) ^ (failed 2)       */\n\n\t\terow = rf_EO_Mod((row + f2 - ecol), (RF_EO_MATRIX_DIM));\n\t\tif (erow != (RF_EO_MATRIX_DIM) - 1) {\n#if RF_EO_MATRIX_DIM > 17\n\t\t\tebuf_current = (short *) ebuf + shortsPerEU * erow;\n\t\t\tfor (k = 0; k < shortsPerEU; k++)\n\t\t\t\ttemp[k] ^= *(ebuf_current + k);\n#elif RF_EO_MATRIX_DIM == 17\n\t\t\tebuf_current = (long *) ebuf + longsPerEU * erow;\n\t\t\tfor (k = 0; k < longsPerEU; k++)\n\t\t\t\ttemp[k] ^= *(ebuf_current + k);\n#endif\n\t\t}\n\t\t/* step 3: ^P to obtain the failed data (failed 2).  P can be\n\t\t * proved to be actually  (principle diagonal)  After this\n\t\t * step, temp[k] = (failed 2), the failed data to be recovered */\n#if RF_EO_MATRIX_DIM > 17\n\t\tfor (k = 0; k < shortsPerEU; k++)\n\t\t\ttemp[k] ^= P[k];\n\t\t/* Put the data to the destination buffer                              */\n\t\tfor (k = 0; k < shortsPerEU; k++)\n\t\t\tdest_larger_current[k] = temp[k];\n#elif RF_EO_MATRIX_DIM == 17\n\t\tfor (k = 0; k < longsPerEU; k++)\n\t\t\ttemp[k] ^= P[k];\n\t\t/* Put the data to the destination buffer                              */\n\t\tfor (k = 0; k < longsPerEU; k++)\n\t\t\tdest_larger_current[k] = temp[k];\n#endif\n\n\t\t/**          THE FOLLOWING DO THE HORIZONTAL XOR                **/\n\t\t/* step 1:  ^(SUM of A(row,0..m-3)), ie. all nonfailed data\n\t\t * columes    */\n\t\tfor (j = 0; j < numDataCol; j++) {\n\t\t\tif (j == f1 || j == f2)\n\t\t\t\tcontinue;\n#if RF_EO_MATRIX_DIM > 17\n\t\t\trrdbuf_current = (short *) (rrdbuf[j]) + row * shortsPerEU;\n\t\t\tfor (k = 0; k < shortsPerEU; k++)\n\t\t\t\ttemp[k] ^= *(rrdbuf_current + k);\n#elif RF_EO_MATRIX_DIM == 17\n\t\t\trrdbuf_current = (long *) (rrdbuf[j]) + row * longsPerEU;\n\t\t\tfor (k = 0; k < longsPerEU; k++)\n\t\t\t\ttemp[k] ^= *(rrdbuf_current + k);\n#endif\n\t\t}\n\t\t/* step 2: ^A(row,m-1) */\n\t\t/* step 3: Put the data to the destination buffer                             \t */\n#if RF_EO_MATRIX_DIM > 17\n\t\tpbuf_current = (short *) pbuf + shortsPerEU * row;\n\t\tfor (k = 0; k < shortsPerEU; k++)\n\t\t\ttemp[k] ^= *(pbuf_current + k);\n\t\tfor (k = 0; k < shortsPerEU; k++)\n\t\t\tdest_smaller_current[k] = temp[k];\n#elif RF_EO_MATRIX_DIM == 17\n\t\tpbuf_current = (long *) pbuf + longsPerEU * row;\n\t\tfor (k = 0; k < longsPerEU; k++)\n\t\t\ttemp[k] ^= *(pbuf_current + k);\n\t\tfor (k = 0; k < longsPerEU; k++)\n\t\t\tdest_smaller_current[k] = temp[k];\n#endif\n\t\tcount++;\n\t}\n\t/* Check if all Encoding Unit in the data buffer have been decoded,\n\t * according EvenOdd theory, if \"RF_EO_MATRIX_DIM\" is a prime number,\n\t * this algorithm will covered all buffer \t\t\t\t */\n\tRF_ASSERT(count == numRowInEncMatix);\n\tRF_Free((char *) P, bytesPerEU);\n\tRF_Free((char *) temp, bytesPerEU);\n}",
    "includes": [
      "#include \"rf_evenodd_dagfuncs.h\"",
      "#include \"rf_evenodd.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "(char *) temp",
            "bytesPerEU"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "(char *) P",
            "bytesPerEU"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "count == numRowInEncMatix"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_EO_Mod",
          "args": [
            "(row + f2 - ecol)",
            "(RF_EO_MATRIX_DIM)"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_EO_Mod",
          "args": [
            "(row + f2 - j)",
            "RF_EO_MATRIX_DIM"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_EO_Mod",
          "args": [
            "(row + f1 - f2)",
            "RF_EO_MATRIX_DIM"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "fcol[0] != fcol[1]"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "*P == 0"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *) temp",
            "bytesPerEU"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *) P",
            "bytesPerEU"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "*((long *) dest[1]) == 0"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "*((long *) dest[0]) == 0"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "temp",
            "bytesPerEU",
            "(long *)"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "P",
            "bytesPerEU",
            "(long *)"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "bytesPerEU % sizeof(long) == 0"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "temp",
            "bytesPerEU",
            "(short *)"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "P",
            "bytesPerEU",
            "(short *)"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "bytesPerEU % sizeof(short) == 0"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "1"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_evenodd_dagfuncs.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_configure.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_doubleEOdecode(\n    RF_Raid_t * raidPtr,\n    char **rrdbuf,\n    char **dest,\n    RF_RowCol_t * fcol,\n    char *pbuf,\n    char *ebuf)\n{\n\tRF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & (raidPtr->Layout);\n\tint     i, j, k, f1, f2, row;\n\tint     rrdrow, erow, count = 0;\n\tint     bytesPerSector = rf_RaidAddressToByte(raidPtr, 1);\n\tint     numRowInEncMatix = (RF_EO_MATRIX_DIM) - 1;\n#if 0\n\tint     pcol = (RF_EO_MATRIX_DIM) - 1;\n#endif\n\tint     ecol = (RF_EO_MATRIX_DIM) - 2;\n\tint     bytesPerEU = bytesPerSector / numRowInEncMatix;\n\tint     numDataCol = layoutPtr->numDataCol;\n#if RF_EO_MATRIX_DIM > 17\n\tint     shortsPerEU = bytesPerEU / sizeof(short);\n\tshort  *rrdbuf_current, *pbuf_current, *ebuf_current;\n\tshort  *dest_smaller, *dest_smaller_current, *dest_larger, *dest_larger_current;\n\tregister short *temp;\n\tshort  *P;\n\n\tRF_ASSERT(bytesPerEU % sizeof(short) == 0);\n\tRF_Malloc(P, bytesPerEU, (short *));\n\tRF_Malloc(temp, bytesPerEU, (short *));\n#elif RF_EO_MATRIX_DIM == 17\n\tint     longsPerEU = bytesPerEU / sizeof(long);\n\tlong   *rrdbuf_current, *pbuf_current, *ebuf_current;\n\tlong   *dest_smaller, *dest_smaller_current, *dest_larger, *dest_larger_current;\n\tregister long *temp;\n\tlong   *P;\n\n\tRF_ASSERT(bytesPerEU % sizeof(long) == 0);\n\tRF_Malloc(P, bytesPerEU, (long *));\n\tRF_Malloc(temp, bytesPerEU, (long *));\n#endif\n\tRF_ASSERT(*((long *) dest[0]) == 0);\n\tRF_ASSERT(*((long *) dest[1]) == 0);\n\tbzero((char *) P, bytesPerEU);\n\tbzero((char *) temp, bytesPerEU);\n\tRF_ASSERT(*P == 0);\n\t/* calculate the 'P' parameter, which, not parity, is the Xor of all\n\t * elements in the last two column, ie. 'E' and 'parity' colume, see\n\t * the Ref. paper by Blaum, et al 1993  */\n\tfor (i = 0; i < numRowInEncMatix; i++)\n\t\tfor (k = 0; k < longsPerEU; k++) {\n#if RF_EO_MATRIX_DIM > 17\n\t\t\tebuf_current = ((short *) ebuf) + i * shortsPerEU + k;\n\t\t\tpbuf_current = ((short *) pbuf) + i * shortsPerEU + k;\n#elif RF_EO_MATRIX_DIM == 17\n\t\t\tebuf_current = ((long *) ebuf) + i * longsPerEU + k;\n\t\t\tpbuf_current = ((long *) pbuf) + i * longsPerEU + k;\n#endif\n\t\t\tP[k] ^= *ebuf_current;\n\t\t\tP[k] ^= *pbuf_current;\n\t\t}\n\tRF_ASSERT(fcol[0] != fcol[1]);\n\tif (fcol[0] < fcol[1]) {\n#if RF_EO_MATRIX_DIM > 17\n\t\tdest_smaller = (short *) (dest[0]);\n\t\tdest_larger = (short *) (dest[1]);\n#elif RF_EO_MATRIX_DIM == 17\n\t\tdest_smaller = (long *) (dest[0]);\n\t\tdest_larger = (long *) (dest[1]);\n#endif\n\t\tf1 = fcol[0];\n\t\tf2 = fcol[1];\n\t} else {\n#if RF_EO_MATRIX_DIM > 17\n\t\tdest_smaller = (short *) (dest[1]);\n\t\tdest_larger = (short *) (dest[0]);\n#elif RF_EO_MATRIX_DIM == 17\n\t\tdest_smaller = (long *) (dest[1]);\n\t\tdest_larger = (long *) (dest[0]);\n#endif\n\t\tf1 = fcol[1];\n\t\tf2 = fcol[0];\n\t}\n\trow = (RF_EO_MATRIX_DIM) - 1;\n\twhile ((row = rf_EO_Mod((row + f1 - f2), RF_EO_MATRIX_DIM)) != ((RF_EO_MATRIX_DIM) - 1)) {\n#if RF_EO_MATRIX_DIM > 17\n\t\tdest_larger_current = dest_larger + row * shortsPerEU;\n\t\tdest_smaller_current = dest_smaller + row * shortsPerEU;\n#elif RF_EO_MATRIX_DIM == 17\n\t\tdest_larger_current = dest_larger + row * longsPerEU;\n\t\tdest_smaller_current = dest_smaller + row * longsPerEU;\n#endif\n\t\t/**    Do the diagonal recovery. Initially, temp[k] = (failed 1),\n\t\t       which is the failed data in the colume which has smaller col index. **/\n\t\t/* step 1:  ^(SUM of nonfailed in-diagonal A(rrdrow,0..m-3))         */\n\t\tfor (j = 0; j < numDataCol; j++) {\n\t\t\tif (j == f1 || j == f2)\n\t\t\t\tcontinue;\n\t\t\trrdrow = rf_EO_Mod((row + f2 - j), RF_EO_MATRIX_DIM);\n\t\t\tif (rrdrow != (RF_EO_MATRIX_DIM) - 1) {\n#if RF_EO_MATRIX_DIM > 17\n\t\t\t\trrdbuf_current = (short *) (rrdbuf[j]) + rrdrow * shortsPerEU;\n\t\t\t\tfor (k = 0; k < shortsPerEU; k++)\n\t\t\t\t\ttemp[k] ^= *(rrdbuf_current + k);\n#elif RF_EO_MATRIX_DIM == 17\n\t\t\t\trrdbuf_current = (long *) (rrdbuf[j]) + rrdrow * longsPerEU;\n\t\t\t\tfor (k = 0; k < longsPerEU; k++)\n\t\t\t\t\ttemp[k] ^= *(rrdbuf_current + k);\n#endif\n\t\t\t}\n\t\t}\n\t\t/* step 2:  ^E(erow,m-2), If erow is at the buttom row, don't\n\t\t * Xor into it  E(erow,m-2) = (principle diagonal) ^ (failed\n\t\t * 1) ^ (failed 2) ^ ( SUM of nonfailed in-diagonal\n\t\t * A(rrdrow,0..m-3) ) After this step, temp[k] = (principle\n\t\t * diagonal) ^ (failed 2)       */\n\n\t\terow = rf_EO_Mod((row + f2 - ecol), (RF_EO_MATRIX_DIM));\n\t\tif (erow != (RF_EO_MATRIX_DIM) - 1) {\n#if RF_EO_MATRIX_DIM > 17\n\t\t\tebuf_current = (short *) ebuf + shortsPerEU * erow;\n\t\t\tfor (k = 0; k < shortsPerEU; k++)\n\t\t\t\ttemp[k] ^= *(ebuf_current + k);\n#elif RF_EO_MATRIX_DIM == 17\n\t\t\tebuf_current = (long *) ebuf + longsPerEU * erow;\n\t\t\tfor (k = 0; k < longsPerEU; k++)\n\t\t\t\ttemp[k] ^= *(ebuf_current + k);\n#endif\n\t\t}\n\t\t/* step 3: ^P to obtain the failed data (failed 2).  P can be\n\t\t * proved to be actually  (principle diagonal)  After this\n\t\t * step, temp[k] = (failed 2), the failed data to be recovered */\n#if RF_EO_MATRIX_DIM > 17\n\t\tfor (k = 0; k < shortsPerEU; k++)\n\t\t\ttemp[k] ^= P[k];\n\t\t/* Put the data to the destination buffer                              */\n\t\tfor (k = 0; k < shortsPerEU; k++)\n\t\t\tdest_larger_current[k] = temp[k];\n#elif RF_EO_MATRIX_DIM == 17\n\t\tfor (k = 0; k < longsPerEU; k++)\n\t\t\ttemp[k] ^= P[k];\n\t\t/* Put the data to the destination buffer                              */\n\t\tfor (k = 0; k < longsPerEU; k++)\n\t\t\tdest_larger_current[k] = temp[k];\n#endif\n\n\t\t/**          THE FOLLOWING DO THE HORIZONTAL XOR                **/\n\t\t/* step 1:  ^(SUM of A(row,0..m-3)), ie. all nonfailed data\n\t\t * columes    */\n\t\tfor (j = 0; j < numDataCol; j++) {\n\t\t\tif (j == f1 || j == f2)\n\t\t\t\tcontinue;\n#if RF_EO_MATRIX_DIM > 17\n\t\t\trrdbuf_current = (short *) (rrdbuf[j]) + row * shortsPerEU;\n\t\t\tfor (k = 0; k < shortsPerEU; k++)\n\t\t\t\ttemp[k] ^= *(rrdbuf_current + k);\n#elif RF_EO_MATRIX_DIM == 17\n\t\t\trrdbuf_current = (long *) (rrdbuf[j]) + row * longsPerEU;\n\t\t\tfor (k = 0; k < longsPerEU; k++)\n\t\t\t\ttemp[k] ^= *(rrdbuf_current + k);\n#endif\n\t\t}\n\t\t/* step 2: ^A(row,m-1) */\n\t\t/* step 3: Put the data to the destination buffer                             \t */\n#if RF_EO_MATRIX_DIM > 17\n\t\tpbuf_current = (short *) pbuf + shortsPerEU * row;\n\t\tfor (k = 0; k < shortsPerEU; k++)\n\t\t\ttemp[k] ^= *(pbuf_current + k);\n\t\tfor (k = 0; k < shortsPerEU; k++)\n\t\t\tdest_smaller_current[k] = temp[k];\n#elif RF_EO_MATRIX_DIM == 17\n\t\tpbuf_current = (long *) pbuf + longsPerEU * row;\n\t\tfor (k = 0; k < longsPerEU; k++)\n\t\t\ttemp[k] ^= *(pbuf_current + k);\n\t\tfor (k = 0; k < longsPerEU; k++)\n\t\t\tdest_smaller_current[k] = temp[k];\n#endif\n\t\tcount++;\n\t}\n\t/* Check if all Encoding Unit in the data buffer have been decoded,\n\t * according EvenOdd theory, if \"RF_EO_MATRIX_DIM\" is a prime number,\n\t * this algorithm will covered all buffer \t\t\t\t */\n\tRF_ASSERT(count == numRowInEncMatix);\n\tRF_Free((char *) P, bytesPerEU);\n\tRF_Free((char *) temp, bytesPerEU);\n}"
  },
  {
    "function_name": "rf_EO_DegradedWriteEFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_evenodd_dagfuncs.c",
    "lines": "436-444",
    "snippet": "int \nrf_EO_DegradedWriteEFunc(RF_DagNode_t * node)\n{\n\trf_DegrESubroutine(node, node->results[0]);\n\trf_GenericWakeupFunc(node, 0);\n#if 1\n\treturn (0);\t\t/* XXX Yet another one!! GO */\n#endif\n}",
    "includes": [
      "#include \"rf_evenodd_dagfuncs.h\"",
      "#include \"rf_evenodd.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_GenericWakeupFunc",
          "args": [
            "node",
            "0"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "rf_GenericWakeupFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
          "lines": "425-460",
          "snippet": "int \nrf_GenericWakeupFunc(node, status)\n\tRF_DagNode_t *node;\n\tint     status;\n{\n\tswitch (node->status) {\n\tcase rf_bwd1:\n\t\tnode->status = rf_bwd2;\n\t\tif (node->dagFuncData)\n\t\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\t\treturn (rf_DiskWriteFuncForThreads(node));\n\t\tbreak;\n\tcase rf_fired:\n\t\tif (status)\n\t\t\tnode->status = rf_bad;\n\t\telse\n\t\t\tnode->status = rf_good;\n\t\tbreak;\n\tcase rf_recover:\n\t\t/* probably should never reach this case */\n\t\tif (status)\n\t\t\tnode->status = rf_panic;\n\t\telse\n\t\t\tnode->status = rf_undone;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"rf_GenericWakeupFunc:\");\n\t\tprintf(\"node->status is %d,\", node->status);\n\t\tprintf(\"status is %d \\n\", status);\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\tif (node->dagFuncData)\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\treturn (rf_FinishNode(node, RF_INTR_CONTEXT));\n}",
          "includes": [
            "#include \"rf_paritylog.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_GenericWakeupFunc(node, status)\n\tRF_DagNode_t *node;\n\tint     status;\n{\n\tswitch (node->status) {\n\tcase rf_bwd1:\n\t\tnode->status = rf_bwd2;\n\t\tif (node->dagFuncData)\n\t\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\t\treturn (rf_DiskWriteFuncForThreads(node));\n\t\tbreak;\n\tcase rf_fired:\n\t\tif (status)\n\t\t\tnode->status = rf_bad;\n\t\telse\n\t\t\tnode->status = rf_good;\n\t\tbreak;\n\tcase rf_recover:\n\t\t/* probably should never reach this case */\n\t\tif (status)\n\t\t\tnode->status = rf_panic;\n\t\telse\n\t\t\tnode->status = rf_undone;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"rf_GenericWakeupFunc:\");\n\t\tprintf(\"node->status is %d,\", node->status);\n\t\tprintf(\"status is %d \\n\", status);\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\tif (node->dagFuncData)\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\treturn (rf_FinishNode(node, RF_INTR_CONTEXT));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_DegrESubroutine",
          "args": [
            "node",
            "node->results[0]"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "rf_DegrESubroutine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_evenodd_dagfuncs.c",
          "lines": "242-271",
          "snippet": "void \nrf_DegrESubroutine(node, ebuf)\n\tRF_DagNode_t *node;\n\tchar   *ebuf;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tRF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & raidPtr->Layout;\n\tRF_PhysDiskAddr_t *failedPDA = (RF_PhysDiskAddr_t *) node->params[node->numParams - 2].p;\n\tRF_PhysDiskAddr_t *pda;\n\tint     i, suoffset, failedSUOffset = rf_StripeUnitOffset(layoutPtr, failedPDA->startSector);\n\tRF_RowCol_t scol;\n\tchar   *srcbuf, *destbuf;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\n\tRF_ETIMER_START(timer);\n\tfor (i = 0; i < node->numParams - 2; i += 2) {\n\t\tRF_ASSERT(node->params[i + 1].p != ebuf);\n\t\tpda = (RF_PhysDiskAddr_t *) node->params[i].p;\n\t\tsuoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);\n\t\tscol = rf_EUCol(layoutPtr, pda->raidAddress);\n\t\tsrcbuf = (char *) node->params[i + 1].p;\n\t\tdestbuf = ebuf + rf_RaidAddressToByte(raidPtr, suoffset - failedSUOffset);\n\t\trf_e_encToBuf(raidPtr, scol, srcbuf, RF_EO_MATRIX_DIM - 2, destbuf, pda->numSector);\n\t}\n\n\tRF_ETIMER_STOP(timer);\n\tRF_ETIMER_EVAL(timer);\n\ttracerec->q_us += RF_ETIMER_VAL_US(timer);\n}",
          "includes": [
            "#include \"rf_evenodd_dagfuncs.h\"",
            "#include \"rf_evenodd.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dagdegwr.h\"",
            "#include \"rf_dagdegrd.h\"",
            "#include \"rf_dagffwr.h\"",
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_evenodd_dagfuncs.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_configure.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_DegrESubroutine(node, ebuf)\n\tRF_DagNode_t *node;\n\tchar   *ebuf;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tRF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & raidPtr->Layout;\n\tRF_PhysDiskAddr_t *failedPDA = (RF_PhysDiskAddr_t *) node->params[node->numParams - 2].p;\n\tRF_PhysDiskAddr_t *pda;\n\tint     i, suoffset, failedSUOffset = rf_StripeUnitOffset(layoutPtr, failedPDA->startSector);\n\tRF_RowCol_t scol;\n\tchar   *srcbuf, *destbuf;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\n\tRF_ETIMER_START(timer);\n\tfor (i = 0; i < node->numParams - 2; i += 2) {\n\t\tRF_ASSERT(node->params[i + 1].p != ebuf);\n\t\tpda = (RF_PhysDiskAddr_t *) node->params[i].p;\n\t\tsuoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);\n\t\tscol = rf_EUCol(layoutPtr, pda->raidAddress);\n\t\tsrcbuf = (char *) node->params[i + 1].p;\n\t\tdestbuf = ebuf + rf_RaidAddressToByte(raidPtr, suoffset - failedSUOffset);\n\t\trf_e_encToBuf(raidPtr, scol, srcbuf, RF_EO_MATRIX_DIM - 2, destbuf, pda->numSector);\n\t}\n\n\tRF_ETIMER_STOP(timer);\n\tRF_ETIMER_EVAL(timer);\n\ttracerec->q_us += RF_ETIMER_VAL_US(timer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_evenodd_dagfuncs.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_configure.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nint \nrf_EO_DegradedWriteEFunc(RF_DagNode_t * node)\n{\n\trf_DegrESubroutine(node, node->results[0]);\n\trf_GenericWakeupFunc(node, 0);\n#if 1\n\treturn (0);\t\t/* XXX Yet another one!! GO */\n#endif\n}"
  },
  {
    "function_name": "rf_RecoveryEFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_evenodd_dagfuncs.c",
    "lines": "393-431",
    "snippet": "int \nrf_RecoveryEFunc(node)\n\tRF_DagNode_t *node;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tRF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & raidPtr->Layout;\n\tRF_PhysDiskAddr_t *failedPDA = (RF_PhysDiskAddr_t *) node->params[node->numParams - 2].p;\n\tRF_RowCol_t scol,\t/* source logical column */\n\t        fcol = rf_EUCol(layoutPtr, failedPDA->raidAddress);\t/* logical column of\n\t\t\t\t\t\t\t\t\t * failed SU */\n\tint     i;\n\tRF_PhysDiskAddr_t *pda;\n\tint     suoffset, failedSUOffset = rf_StripeUnitOffset(layoutPtr, failedPDA->startSector);\n\tchar   *srcbuf, *destbuf;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\n\tbzero((char *) node->results[0], rf_RaidAddressToByte(raidPtr, failedPDA->numSector));\n\tif (node->dagHdr->status == rf_enable) {\n\t\tRF_ETIMER_START(timer);\n\t\tfor (i = 0; i < node->numParams - 2; i += 2)\n\t\t\tif (node->params[i + 1].p != node->results[0]) {\n\t\t\t\tpda = (RF_PhysDiskAddr_t *) node->params[i].p;\n\t\t\t\tif (i == node->numParams - 4)\n\t\t\t\t\tscol = RF_EO_MATRIX_DIM - 2;\t/* the colume of\n\t\t\t\t\t\t\t\t\t * redundant E */\n\t\t\t\telse\n\t\t\t\t\tscol = rf_EUCol(layoutPtr, pda->raidAddress);\n\t\t\t\tsrcbuf = (char *) node->params[i + 1].p;\n\t\t\t\tsuoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);\n\t\t\t\tdestbuf = ((char *) node->results[0]) + rf_RaidAddressToByte(raidPtr, suoffset - failedSUOffset);\n\t\t\t\trf_e_encToBuf(raidPtr, scol, srcbuf, fcol, destbuf, pda->numSector);\n\t\t\t}\n\t\tRF_ETIMER_STOP(timer);\n\t\tRF_ETIMER_EVAL(timer);\n\t\ttracerec->xor_us += RF_ETIMER_VAL_US(timer);\n\t}\n\treturn (rf_GenericWakeupFunc(node, 0));\t/* node execute successfully */\n}",
    "includes": [
      "#include \"rf_evenodd_dagfuncs.h\"",
      "#include \"rf_evenodd.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_GenericWakeupFunc",
          "args": [
            "node",
            "0"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "rf_GenericWakeupFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
          "lines": "425-460",
          "snippet": "int \nrf_GenericWakeupFunc(node, status)\n\tRF_DagNode_t *node;\n\tint     status;\n{\n\tswitch (node->status) {\n\tcase rf_bwd1:\n\t\tnode->status = rf_bwd2;\n\t\tif (node->dagFuncData)\n\t\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\t\treturn (rf_DiskWriteFuncForThreads(node));\n\t\tbreak;\n\tcase rf_fired:\n\t\tif (status)\n\t\t\tnode->status = rf_bad;\n\t\telse\n\t\t\tnode->status = rf_good;\n\t\tbreak;\n\tcase rf_recover:\n\t\t/* probably should never reach this case */\n\t\tif (status)\n\t\t\tnode->status = rf_panic;\n\t\telse\n\t\t\tnode->status = rf_undone;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"rf_GenericWakeupFunc:\");\n\t\tprintf(\"node->status is %d,\", node->status);\n\t\tprintf(\"status is %d \\n\", status);\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\tif (node->dagFuncData)\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\treturn (rf_FinishNode(node, RF_INTR_CONTEXT));\n}",
          "includes": [
            "#include \"rf_paritylog.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_GenericWakeupFunc(node, status)\n\tRF_DagNode_t *node;\n\tint     status;\n{\n\tswitch (node->status) {\n\tcase rf_bwd1:\n\t\tnode->status = rf_bwd2;\n\t\tif (node->dagFuncData)\n\t\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\t\treturn (rf_DiskWriteFuncForThreads(node));\n\t\tbreak;\n\tcase rf_fired:\n\t\tif (status)\n\t\t\tnode->status = rf_bad;\n\t\telse\n\t\t\tnode->status = rf_good;\n\t\tbreak;\n\tcase rf_recover:\n\t\t/* probably should never reach this case */\n\t\tif (status)\n\t\t\tnode->status = rf_panic;\n\t\telse\n\t\t\tnode->status = rf_undone;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"rf_GenericWakeupFunc:\");\n\t\tprintf(\"node->status is %d,\", node->status);\n\t\tprintf(\"status is %d \\n\", status);\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\tif (node->dagFuncData)\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\treturn (rf_FinishNode(node, RF_INTR_CONTEXT));\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_VAL_US",
          "args": [
            "timer"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_EVAL",
          "args": [
            "timer"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_STOP",
          "args": [
            "timer"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_e_encToBuf",
          "args": [
            "raidPtr",
            "scol",
            "srcbuf",
            "fcol",
            "destbuf",
            "pda->numSector"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "rf_e_encToBuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_evenodd_dagfuncs.c",
          "lines": "371-387",
          "snippet": "void \nrf_e_encToBuf(\n    RF_Raid_t * raidPtr,\n    RF_RowCol_t srcLogicCol,\n    char *srcbuf,\n    RF_RowCol_t destLogicCol,\n    char *destbuf,\n    int numSector)\n{\n\tint     i, bytesPerSector = rf_RaidAddressToByte(raidPtr, 1);\n\n\tfor (i = 0; i < numSector; i++) {\n\t\trf_e_EncOneSect(srcLogicCol, srcbuf, destLogicCol, destbuf, bytesPerSector);\n\t\tsrcbuf += bytesPerSector;\n\t\tdestbuf += bytesPerSector;\n\t}\n}",
          "includes": [
            "#include \"rf_evenodd_dagfuncs.h\"",
            "#include \"rf_evenodd.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dagdegwr.h\"",
            "#include \"rf_dagdegrd.h\"",
            "#include \"rf_dagffwr.h\"",
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_evenodd_dagfuncs.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_configure.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_e_encToBuf(\n    RF_Raid_t * raidPtr,\n    RF_RowCol_t srcLogicCol,\n    char *srcbuf,\n    RF_RowCol_t destLogicCol,\n    char *destbuf,\n    int numSector)\n{\n\tint     i, bytesPerSector = rf_RaidAddressToByte(raidPtr, 1);\n\n\tfor (i = 0; i < numSector; i++) {\n\t\trf_e_EncOneSect(srcLogicCol, srcbuf, destLogicCol, destbuf, bytesPerSector);\n\t\tsrcbuf += bytesPerSector;\n\t\tdestbuf += bytesPerSector;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "suoffset - failedSUOffset"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_StripeUnitOffset",
          "args": [
            "layoutPtr",
            "pda->startSector"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_EUCol",
          "args": [
            "layoutPtr",
            "pda->raidAddress"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_START",
          "args": [
            "timer"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *) node->results[0]",
            "rf_RaidAddressToByte(raidPtr, failedPDA->numSector)"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "failedPDA->numSector"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_StripeUnitOffset",
          "args": [
            "layoutPtr",
            "failedPDA->startSector"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_EUCol",
          "args": [
            "layoutPtr",
            "failedPDA->raidAddress"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_evenodd_dagfuncs.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_configure.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nint \nrf_RecoveryEFunc(node)\n\tRF_DagNode_t *node;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tRF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & raidPtr->Layout;\n\tRF_PhysDiskAddr_t *failedPDA = (RF_PhysDiskAddr_t *) node->params[node->numParams - 2].p;\n\tRF_RowCol_t scol,\t/* source logical column */\n\t        fcol = rf_EUCol(layoutPtr, failedPDA->raidAddress);\t/* logical column of\n\t\t\t\t\t\t\t\t\t * failed SU */\n\tint     i;\n\tRF_PhysDiskAddr_t *pda;\n\tint     suoffset, failedSUOffset = rf_StripeUnitOffset(layoutPtr, failedPDA->startSector);\n\tchar   *srcbuf, *destbuf;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\n\tbzero((char *) node->results[0], rf_RaidAddressToByte(raidPtr, failedPDA->numSector));\n\tif (node->dagHdr->status == rf_enable) {\n\t\tRF_ETIMER_START(timer);\n\t\tfor (i = 0; i < node->numParams - 2; i += 2)\n\t\t\tif (node->params[i + 1].p != node->results[0]) {\n\t\t\t\tpda = (RF_PhysDiskAddr_t *) node->params[i].p;\n\t\t\t\tif (i == node->numParams - 4)\n\t\t\t\t\tscol = RF_EO_MATRIX_DIM - 2;\t/* the colume of\n\t\t\t\t\t\t\t\t\t * redundant E */\n\t\t\t\telse\n\t\t\t\t\tscol = rf_EUCol(layoutPtr, pda->raidAddress);\n\t\t\t\tsrcbuf = (char *) node->params[i + 1].p;\n\t\t\t\tsuoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);\n\t\t\t\tdestbuf = ((char *) node->results[0]) + rf_RaidAddressToByte(raidPtr, suoffset - failedSUOffset);\n\t\t\t\trf_e_encToBuf(raidPtr, scol, srcbuf, fcol, destbuf, pda->numSector);\n\t\t\t}\n\t\tRF_ETIMER_STOP(timer);\n\t\tRF_ETIMER_EVAL(timer);\n\t\ttracerec->xor_us += RF_ETIMER_VAL_US(timer);\n\t}\n\treturn (rf_GenericWakeupFunc(node, 0));\t/* node execute successfully */\n}"
  },
  {
    "function_name": "rf_e_encToBuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_evenodd_dagfuncs.c",
    "lines": "371-387",
    "snippet": "void \nrf_e_encToBuf(\n    RF_Raid_t * raidPtr,\n    RF_RowCol_t srcLogicCol,\n    char *srcbuf,\n    RF_RowCol_t destLogicCol,\n    char *destbuf,\n    int numSector)\n{\n\tint     i, bytesPerSector = rf_RaidAddressToByte(raidPtr, 1);\n\n\tfor (i = 0; i < numSector; i++) {\n\t\trf_e_EncOneSect(srcLogicCol, srcbuf, destLogicCol, destbuf, bytesPerSector);\n\t\tsrcbuf += bytesPerSector;\n\t\tdestbuf += bytesPerSector;\n\t}\n}",
    "includes": [
      "#include \"rf_evenodd_dagfuncs.h\"",
      "#include \"rf_evenodd.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_e_EncOneSect",
          "args": [
            "srcLogicCol",
            "srcbuf",
            "destLogicCol",
            "destbuf",
            "bytesPerSector"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "rf_e_EncOneSect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_evenodd_dagfuncs.c",
          "lines": "296-369",
          "snippet": "void \nrf_e_EncOneSect(\n    RF_RowCol_t srcLogicCol,\n    char *srcSecbuf,\n    RF_RowCol_t destLogicCol,\n    char *destSecbuf,\n    int bytesPerSector)\n{\n\tint     S_index;\t/* index of the EU in the src col which need\n\t\t\t\t * be Xored into all EUs in a dest sector */\n\tint     numRowInEncMatix = (RF_EO_MATRIX_DIM) - 1;\n\tRF_RowCol_t j, indexInDest,\t/* row index of an encoding unit in\n\t\t\t\t\t * the destination colume of encoding\n\t\t\t\t\t * matrix */\n\t        indexInSrc;\t/* row index of an encoding unit in the source\n\t\t\t\t * colume used for recovery */\n\tint     bytesPerEU = bytesPerSector / numRowInEncMatix;\n\n#if RF_EO_MATRIX_DIM > 17\n\tint     shortsPerEU = bytesPerEU / sizeof(short);\n\tshort  *destShortBuf, *srcShortBuf1, *srcShortBuf2;\n\tregister short temp1;\n#elif RF_EO_MATRIX_DIM == 17\n\tint     longsPerEU = bytesPerEU / sizeof(long);\n\tlong   *destLongBuf, *srcLongBuf1, *srcLongBuf2;\n\tregister long temp1;\n#endif\n\n#if RF_EO_MATRIX_DIM > 17\n\tRF_ASSERT(sizeof(short) == 2 || sizeof(short) == 1);\n\tRF_ASSERT(bytesPerEU % sizeof(short) == 0);\n#elif RF_EO_MATRIX_DIM == 17\n\tRF_ASSERT(sizeof(long) == 8 || sizeof(long) == 4);\n\tRF_ASSERT(bytesPerEU % sizeof(long) == 0);\n#endif\n\n\tS_index = rf_EO_Mod((RF_EO_MATRIX_DIM - 1 + destLogicCol - srcLogicCol), RF_EO_MATRIX_DIM);\n#if RF_EO_MATRIX_DIM > 17\n\tsrcShortBuf1 = (short *) (srcSecbuf + S_index * bytesPerEU);\n#elif RF_EO_MATRIX_DIM == 17\n\tsrcLongBuf1 = (long *) (srcSecbuf + S_index * bytesPerEU);\n#endif\n\n\tfor (indexInDest = 0; indexInDest < numRowInEncMatix; indexInDest++) {\n\t\tindexInSrc = rf_EO_Mod((indexInDest + destLogicCol - srcLogicCol), RF_EO_MATRIX_DIM);\n\n#if RF_EO_MATRIX_DIM > 17\n\t\tdestShortBuf = (short *) (destSecbuf + indexInDest * bytesPerEU);\n\t\tsrcShortBuf2 = (short *) (srcSecbuf + indexInSrc * bytesPerEU);\n\t\tfor (j = 0; j < shortsPerEU; j++) {\n\t\t\ttemp1 = destShortBuf[j] ^ srcShortBuf1[j];\n\t\t\t/* note: S_index won't be at the end row for any src\n\t\t\t * col! */\n\t\t\tif (indexInSrc != RF_EO_MATRIX_DIM - 1)\n\t\t\t\tdestShortBuf[j] = (srcShortBuf2[j]) ^ temp1;\n\t\t\t/* if indexInSrc is at the end row, ie.\n\t\t\t * RF_EO_MATRIX_DIM -1, then all elements are zero! */\n\t\t\telse\n\t\t\t\tdestShortBuf[j] = temp1;\n\t\t}\n\n#elif RF_EO_MATRIX_DIM == 17\n\t\tdestLongBuf = (long *) (destSecbuf + indexInDest * bytesPerEU);\n\t\tsrcLongBuf2 = (long *) (srcSecbuf + indexInSrc * bytesPerEU);\n\t\tfor (j = 0; j < longsPerEU; j++) {\n\t\t\ttemp1 = destLongBuf[j] ^ srcLongBuf1[j];\n\t\t\tif (indexInSrc != RF_EO_MATRIX_DIM - 1)\n\t\t\t\tdestLongBuf[j] = (srcLongBuf2[j]) ^ temp1;\n\t\t\telse\n\t\t\t\tdestLongBuf[j] = temp1;\n\t\t}\n#endif\n\t}\n}",
          "includes": [
            "#include \"rf_evenodd_dagfuncs.h\"",
            "#include \"rf_evenodd.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dagdegwr.h\"",
            "#include \"rf_dagdegrd.h\"",
            "#include \"rf_dagffwr.h\"",
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_evenodd_dagfuncs.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_configure.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_e_EncOneSect(\n    RF_RowCol_t srcLogicCol,\n    char *srcSecbuf,\n    RF_RowCol_t destLogicCol,\n    char *destSecbuf,\n    int bytesPerSector)\n{\n\tint     S_index;\t/* index of the EU in the src col which need\n\t\t\t\t * be Xored into all EUs in a dest sector */\n\tint     numRowInEncMatix = (RF_EO_MATRIX_DIM) - 1;\n\tRF_RowCol_t j, indexInDest,\t/* row index of an encoding unit in\n\t\t\t\t\t * the destination colume of encoding\n\t\t\t\t\t * matrix */\n\t        indexInSrc;\t/* row index of an encoding unit in the source\n\t\t\t\t * colume used for recovery */\n\tint     bytesPerEU = bytesPerSector / numRowInEncMatix;\n\n#if RF_EO_MATRIX_DIM > 17\n\tint     shortsPerEU = bytesPerEU / sizeof(short);\n\tshort  *destShortBuf, *srcShortBuf1, *srcShortBuf2;\n\tregister short temp1;\n#elif RF_EO_MATRIX_DIM == 17\n\tint     longsPerEU = bytesPerEU / sizeof(long);\n\tlong   *destLongBuf, *srcLongBuf1, *srcLongBuf2;\n\tregister long temp1;\n#endif\n\n#if RF_EO_MATRIX_DIM > 17\n\tRF_ASSERT(sizeof(short) == 2 || sizeof(short) == 1);\n\tRF_ASSERT(bytesPerEU % sizeof(short) == 0);\n#elif RF_EO_MATRIX_DIM == 17\n\tRF_ASSERT(sizeof(long) == 8 || sizeof(long) == 4);\n\tRF_ASSERT(bytesPerEU % sizeof(long) == 0);\n#endif\n\n\tS_index = rf_EO_Mod((RF_EO_MATRIX_DIM - 1 + destLogicCol - srcLogicCol), RF_EO_MATRIX_DIM);\n#if RF_EO_MATRIX_DIM > 17\n\tsrcShortBuf1 = (short *) (srcSecbuf + S_index * bytesPerEU);\n#elif RF_EO_MATRIX_DIM == 17\n\tsrcLongBuf1 = (long *) (srcSecbuf + S_index * bytesPerEU);\n#endif\n\n\tfor (indexInDest = 0; indexInDest < numRowInEncMatix; indexInDest++) {\n\t\tindexInSrc = rf_EO_Mod((indexInDest + destLogicCol - srcLogicCol), RF_EO_MATRIX_DIM);\n\n#if RF_EO_MATRIX_DIM > 17\n\t\tdestShortBuf = (short *) (destSecbuf + indexInDest * bytesPerEU);\n\t\tsrcShortBuf2 = (short *) (srcSecbuf + indexInSrc * bytesPerEU);\n\t\tfor (j = 0; j < shortsPerEU; j++) {\n\t\t\ttemp1 = destShortBuf[j] ^ srcShortBuf1[j];\n\t\t\t/* note: S_index won't be at the end row for any src\n\t\t\t * col! */\n\t\t\tif (indexInSrc != RF_EO_MATRIX_DIM - 1)\n\t\t\t\tdestShortBuf[j] = (srcShortBuf2[j]) ^ temp1;\n\t\t\t/* if indexInSrc is at the end row, ie.\n\t\t\t * RF_EO_MATRIX_DIM -1, then all elements are zero! */\n\t\t\telse\n\t\t\t\tdestShortBuf[j] = temp1;\n\t\t}\n\n#elif RF_EO_MATRIX_DIM == 17\n\t\tdestLongBuf = (long *) (destSecbuf + indexInDest * bytesPerEU);\n\t\tsrcLongBuf2 = (long *) (srcSecbuf + indexInSrc * bytesPerEU);\n\t\tfor (j = 0; j < longsPerEU; j++) {\n\t\t\ttemp1 = destLongBuf[j] ^ srcLongBuf1[j];\n\t\t\tif (indexInSrc != RF_EO_MATRIX_DIM - 1)\n\t\t\t\tdestLongBuf[j] = (srcLongBuf2[j]) ^ temp1;\n\t\t\telse\n\t\t\t\tdestLongBuf[j] = temp1;\n\t\t}\n#endif\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "1"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_evenodd_dagfuncs.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_configure.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_e_encToBuf(\n    RF_Raid_t * raidPtr,\n    RF_RowCol_t srcLogicCol,\n    char *srcbuf,\n    RF_RowCol_t destLogicCol,\n    char *destbuf,\n    int numSector)\n{\n\tint     i, bytesPerSector = rf_RaidAddressToByte(raidPtr, 1);\n\n\tfor (i = 0; i < numSector; i++) {\n\t\trf_e_EncOneSect(srcLogicCol, srcbuf, destLogicCol, destbuf, bytesPerSector);\n\t\tsrcbuf += bytesPerSector;\n\t\tdestbuf += bytesPerSector;\n\t}\n}"
  },
  {
    "function_name": "rf_e_EncOneSect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_evenodd_dagfuncs.c",
    "lines": "296-369",
    "snippet": "void \nrf_e_EncOneSect(\n    RF_RowCol_t srcLogicCol,\n    char *srcSecbuf,\n    RF_RowCol_t destLogicCol,\n    char *destSecbuf,\n    int bytesPerSector)\n{\n\tint     S_index;\t/* index of the EU in the src col which need\n\t\t\t\t * be Xored into all EUs in a dest sector */\n\tint     numRowInEncMatix = (RF_EO_MATRIX_DIM) - 1;\n\tRF_RowCol_t j, indexInDest,\t/* row index of an encoding unit in\n\t\t\t\t\t * the destination colume of encoding\n\t\t\t\t\t * matrix */\n\t        indexInSrc;\t/* row index of an encoding unit in the source\n\t\t\t\t * colume used for recovery */\n\tint     bytesPerEU = bytesPerSector / numRowInEncMatix;\n\n#if RF_EO_MATRIX_DIM > 17\n\tint     shortsPerEU = bytesPerEU / sizeof(short);\n\tshort  *destShortBuf, *srcShortBuf1, *srcShortBuf2;\n\tregister short temp1;\n#elif RF_EO_MATRIX_DIM == 17\n\tint     longsPerEU = bytesPerEU / sizeof(long);\n\tlong   *destLongBuf, *srcLongBuf1, *srcLongBuf2;\n\tregister long temp1;\n#endif\n\n#if RF_EO_MATRIX_DIM > 17\n\tRF_ASSERT(sizeof(short) == 2 || sizeof(short) == 1);\n\tRF_ASSERT(bytesPerEU % sizeof(short) == 0);\n#elif RF_EO_MATRIX_DIM == 17\n\tRF_ASSERT(sizeof(long) == 8 || sizeof(long) == 4);\n\tRF_ASSERT(bytesPerEU % sizeof(long) == 0);\n#endif\n\n\tS_index = rf_EO_Mod((RF_EO_MATRIX_DIM - 1 + destLogicCol - srcLogicCol), RF_EO_MATRIX_DIM);\n#if RF_EO_MATRIX_DIM > 17\n\tsrcShortBuf1 = (short *) (srcSecbuf + S_index * bytesPerEU);\n#elif RF_EO_MATRIX_DIM == 17\n\tsrcLongBuf1 = (long *) (srcSecbuf + S_index * bytesPerEU);\n#endif\n\n\tfor (indexInDest = 0; indexInDest < numRowInEncMatix; indexInDest++) {\n\t\tindexInSrc = rf_EO_Mod((indexInDest + destLogicCol - srcLogicCol), RF_EO_MATRIX_DIM);\n\n#if RF_EO_MATRIX_DIM > 17\n\t\tdestShortBuf = (short *) (destSecbuf + indexInDest * bytesPerEU);\n\t\tsrcShortBuf2 = (short *) (srcSecbuf + indexInSrc * bytesPerEU);\n\t\tfor (j = 0; j < shortsPerEU; j++) {\n\t\t\ttemp1 = destShortBuf[j] ^ srcShortBuf1[j];\n\t\t\t/* note: S_index won't be at the end row for any src\n\t\t\t * col! */\n\t\t\tif (indexInSrc != RF_EO_MATRIX_DIM - 1)\n\t\t\t\tdestShortBuf[j] = (srcShortBuf2[j]) ^ temp1;\n\t\t\t/* if indexInSrc is at the end row, ie.\n\t\t\t * RF_EO_MATRIX_DIM -1, then all elements are zero! */\n\t\t\telse\n\t\t\t\tdestShortBuf[j] = temp1;\n\t\t}\n\n#elif RF_EO_MATRIX_DIM == 17\n\t\tdestLongBuf = (long *) (destSecbuf + indexInDest * bytesPerEU);\n\t\tsrcLongBuf2 = (long *) (srcSecbuf + indexInSrc * bytesPerEU);\n\t\tfor (j = 0; j < longsPerEU; j++) {\n\t\t\ttemp1 = destLongBuf[j] ^ srcLongBuf1[j];\n\t\t\tif (indexInSrc != RF_EO_MATRIX_DIM - 1)\n\t\t\t\tdestLongBuf[j] = (srcLongBuf2[j]) ^ temp1;\n\t\t\telse\n\t\t\t\tdestLongBuf[j] = temp1;\n\t\t}\n#endif\n\t}\n}",
    "includes": [
      "#include \"rf_evenodd_dagfuncs.h\"",
      "#include \"rf_evenodd.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_EO_Mod",
          "args": [
            "(indexInDest + destLogicCol - srcLogicCol)",
            "RF_EO_MATRIX_DIM"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_EO_Mod",
          "args": [
            "(RF_EO_MATRIX_DIM - 1 + destLogicCol - srcLogicCol)",
            "RF_EO_MATRIX_DIM"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "bytesPerEU % sizeof(long) == 0"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "sizeof(long) == 8 || sizeof(long) == 4"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "bytesPerEU % sizeof(short) == 0"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "sizeof(short) == 2 || sizeof(short) == 1"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_evenodd_dagfuncs.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_configure.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_e_EncOneSect(\n    RF_RowCol_t srcLogicCol,\n    char *srcSecbuf,\n    RF_RowCol_t destLogicCol,\n    char *destSecbuf,\n    int bytesPerSector)\n{\n\tint     S_index;\t/* index of the EU in the src col which need\n\t\t\t\t * be Xored into all EUs in a dest sector */\n\tint     numRowInEncMatix = (RF_EO_MATRIX_DIM) - 1;\n\tRF_RowCol_t j, indexInDest,\t/* row index of an encoding unit in\n\t\t\t\t\t * the destination colume of encoding\n\t\t\t\t\t * matrix */\n\t        indexInSrc;\t/* row index of an encoding unit in the source\n\t\t\t\t * colume used for recovery */\n\tint     bytesPerEU = bytesPerSector / numRowInEncMatix;\n\n#if RF_EO_MATRIX_DIM > 17\n\tint     shortsPerEU = bytesPerEU / sizeof(short);\n\tshort  *destShortBuf, *srcShortBuf1, *srcShortBuf2;\n\tregister short temp1;\n#elif RF_EO_MATRIX_DIM == 17\n\tint     longsPerEU = bytesPerEU / sizeof(long);\n\tlong   *destLongBuf, *srcLongBuf1, *srcLongBuf2;\n\tregister long temp1;\n#endif\n\n#if RF_EO_MATRIX_DIM > 17\n\tRF_ASSERT(sizeof(short) == 2 || sizeof(short) == 1);\n\tRF_ASSERT(bytesPerEU % sizeof(short) == 0);\n#elif RF_EO_MATRIX_DIM == 17\n\tRF_ASSERT(sizeof(long) == 8 || sizeof(long) == 4);\n\tRF_ASSERT(bytesPerEU % sizeof(long) == 0);\n#endif\n\n\tS_index = rf_EO_Mod((RF_EO_MATRIX_DIM - 1 + destLogicCol - srcLogicCol), RF_EO_MATRIX_DIM);\n#if RF_EO_MATRIX_DIM > 17\n\tsrcShortBuf1 = (short *) (srcSecbuf + S_index * bytesPerEU);\n#elif RF_EO_MATRIX_DIM == 17\n\tsrcLongBuf1 = (long *) (srcSecbuf + S_index * bytesPerEU);\n#endif\n\n\tfor (indexInDest = 0; indexInDest < numRowInEncMatix; indexInDest++) {\n\t\tindexInSrc = rf_EO_Mod((indexInDest + destLogicCol - srcLogicCol), RF_EO_MATRIX_DIM);\n\n#if RF_EO_MATRIX_DIM > 17\n\t\tdestShortBuf = (short *) (destSecbuf + indexInDest * bytesPerEU);\n\t\tsrcShortBuf2 = (short *) (srcSecbuf + indexInSrc * bytesPerEU);\n\t\tfor (j = 0; j < shortsPerEU; j++) {\n\t\t\ttemp1 = destShortBuf[j] ^ srcShortBuf1[j];\n\t\t\t/* note: S_index won't be at the end row for any src\n\t\t\t * col! */\n\t\t\tif (indexInSrc != RF_EO_MATRIX_DIM - 1)\n\t\t\t\tdestShortBuf[j] = (srcShortBuf2[j]) ^ temp1;\n\t\t\t/* if indexInSrc is at the end row, ie.\n\t\t\t * RF_EO_MATRIX_DIM -1, then all elements are zero! */\n\t\t\telse\n\t\t\t\tdestShortBuf[j] = temp1;\n\t\t}\n\n#elif RF_EO_MATRIX_DIM == 17\n\t\tdestLongBuf = (long *) (destSecbuf + indexInDest * bytesPerEU);\n\t\tsrcLongBuf2 = (long *) (srcSecbuf + indexInSrc * bytesPerEU);\n\t\tfor (j = 0; j < longsPerEU; j++) {\n\t\t\ttemp1 = destLongBuf[j] ^ srcLongBuf1[j];\n\t\t\tif (indexInSrc != RF_EO_MATRIX_DIM - 1)\n\t\t\t\tdestLongBuf[j] = (srcLongBuf2[j]) ^ temp1;\n\t\t\telse\n\t\t\t\tdestLongBuf[j] = temp1;\n\t\t}\n#endif\n\t}\n}"
  },
  {
    "function_name": "rf_Degraded_100_EOFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_evenodd_dagfuncs.c",
    "lines": "280-290",
    "snippet": "int \nrf_Degraded_100_EOFunc(node)\n\tRF_DagNode_t *node;\n{\n\trf_DegrESubroutine(node, node->results[1]);\n\trf_RecoveryXorFunc(node);\t/* does the wakeup here! */\n#if 1\n\treturn (0);\t\t/* XXX this was missing... SHould these be\n\t\t\t\t * void functions??? GO */\n#endif\n}",
    "includes": [
      "#include \"rf_evenodd_dagfuncs.h\"",
      "#include \"rf_evenodd.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_RecoveryXorFunc",
          "args": [
            "node"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "rf_RecoveryXorFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
          "lines": "545-574",
          "snippet": "int \nrf_RecoveryXorFunc(node)\n\tRF_DagNode_t *node;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tRF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & raidPtr->Layout;\n\tRF_PhysDiskAddr_t *failedPDA = (RF_PhysDiskAddr_t *) node->params[node->numParams - 2].p;\n\tint     i, retcode = 0;\n\tRF_PhysDiskAddr_t *pda;\n\tint     suoffset, failedSUOffset = rf_StripeUnitOffset(layoutPtr, failedPDA->startSector);\n\tchar   *srcbuf, *destbuf;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\n\tif (node->dagHdr->status == rf_enable) {\n\t\tRF_ETIMER_START(timer);\n\t\tfor (i = 0; i < node->numParams - 2; i += 2)\n\t\t\tif (node->params[i + 1].p != node->results[0]) {\n\t\t\t\tpda = (RF_PhysDiskAddr_t *) node->params[i].p;\n\t\t\t\tsrcbuf = (char *) node->params[i + 1].p;\n\t\t\t\tsuoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);\n\t\t\t\tdestbuf = ((char *) node->results[0]) + rf_RaidAddressToByte(raidPtr, suoffset - failedSUOffset);\n\t\t\t\tretcode = rf_bxor(srcbuf, destbuf, rf_RaidAddressToByte(raidPtr, pda->numSector), node->dagHdr->bp);\n\t\t\t}\n\t\tRF_ETIMER_STOP(timer);\n\t\tRF_ETIMER_EVAL(timer);\n\t\ttracerec->xor_us += RF_ETIMER_VAL_US(timer);\n\t}\n\treturn (rf_GenericWakeupFunc(node, retcode));\n}",
          "includes": [
            "#include \"rf_paritylog.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_RecoveryXorFunc(node)\n\tRF_DagNode_t *node;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tRF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & raidPtr->Layout;\n\tRF_PhysDiskAddr_t *failedPDA = (RF_PhysDiskAddr_t *) node->params[node->numParams - 2].p;\n\tint     i, retcode = 0;\n\tRF_PhysDiskAddr_t *pda;\n\tint     suoffset, failedSUOffset = rf_StripeUnitOffset(layoutPtr, failedPDA->startSector);\n\tchar   *srcbuf, *destbuf;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\n\tif (node->dagHdr->status == rf_enable) {\n\t\tRF_ETIMER_START(timer);\n\t\tfor (i = 0; i < node->numParams - 2; i += 2)\n\t\t\tif (node->params[i + 1].p != node->results[0]) {\n\t\t\t\tpda = (RF_PhysDiskAddr_t *) node->params[i].p;\n\t\t\t\tsrcbuf = (char *) node->params[i + 1].p;\n\t\t\t\tsuoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);\n\t\t\t\tdestbuf = ((char *) node->results[0]) + rf_RaidAddressToByte(raidPtr, suoffset - failedSUOffset);\n\t\t\t\tretcode = rf_bxor(srcbuf, destbuf, rf_RaidAddressToByte(raidPtr, pda->numSector), node->dagHdr->bp);\n\t\t\t}\n\t\tRF_ETIMER_STOP(timer);\n\t\tRF_ETIMER_EVAL(timer);\n\t\ttracerec->xor_us += RF_ETIMER_VAL_US(timer);\n\t}\n\treturn (rf_GenericWakeupFunc(node, retcode));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_DegrESubroutine",
          "args": [
            "node",
            "node->results[1]"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "rf_DegrESubroutine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_evenodd_dagfuncs.c",
          "lines": "242-271",
          "snippet": "void \nrf_DegrESubroutine(node, ebuf)\n\tRF_DagNode_t *node;\n\tchar   *ebuf;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tRF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & raidPtr->Layout;\n\tRF_PhysDiskAddr_t *failedPDA = (RF_PhysDiskAddr_t *) node->params[node->numParams - 2].p;\n\tRF_PhysDiskAddr_t *pda;\n\tint     i, suoffset, failedSUOffset = rf_StripeUnitOffset(layoutPtr, failedPDA->startSector);\n\tRF_RowCol_t scol;\n\tchar   *srcbuf, *destbuf;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\n\tRF_ETIMER_START(timer);\n\tfor (i = 0; i < node->numParams - 2; i += 2) {\n\t\tRF_ASSERT(node->params[i + 1].p != ebuf);\n\t\tpda = (RF_PhysDiskAddr_t *) node->params[i].p;\n\t\tsuoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);\n\t\tscol = rf_EUCol(layoutPtr, pda->raidAddress);\n\t\tsrcbuf = (char *) node->params[i + 1].p;\n\t\tdestbuf = ebuf + rf_RaidAddressToByte(raidPtr, suoffset - failedSUOffset);\n\t\trf_e_encToBuf(raidPtr, scol, srcbuf, RF_EO_MATRIX_DIM - 2, destbuf, pda->numSector);\n\t}\n\n\tRF_ETIMER_STOP(timer);\n\tRF_ETIMER_EVAL(timer);\n\ttracerec->q_us += RF_ETIMER_VAL_US(timer);\n}",
          "includes": [
            "#include \"rf_evenodd_dagfuncs.h\"",
            "#include \"rf_evenodd.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dagdegwr.h\"",
            "#include \"rf_dagdegrd.h\"",
            "#include \"rf_dagffwr.h\"",
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_evenodd_dagfuncs.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_configure.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_DegrESubroutine(node, ebuf)\n\tRF_DagNode_t *node;\n\tchar   *ebuf;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tRF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & raidPtr->Layout;\n\tRF_PhysDiskAddr_t *failedPDA = (RF_PhysDiskAddr_t *) node->params[node->numParams - 2].p;\n\tRF_PhysDiskAddr_t *pda;\n\tint     i, suoffset, failedSUOffset = rf_StripeUnitOffset(layoutPtr, failedPDA->startSector);\n\tRF_RowCol_t scol;\n\tchar   *srcbuf, *destbuf;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\n\tRF_ETIMER_START(timer);\n\tfor (i = 0; i < node->numParams - 2; i += 2) {\n\t\tRF_ASSERT(node->params[i + 1].p != ebuf);\n\t\tpda = (RF_PhysDiskAddr_t *) node->params[i].p;\n\t\tsuoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);\n\t\tscol = rf_EUCol(layoutPtr, pda->raidAddress);\n\t\tsrcbuf = (char *) node->params[i + 1].p;\n\t\tdestbuf = ebuf + rf_RaidAddressToByte(raidPtr, suoffset - failedSUOffset);\n\t\trf_e_encToBuf(raidPtr, scol, srcbuf, RF_EO_MATRIX_DIM - 2, destbuf, pda->numSector);\n\t}\n\n\tRF_ETIMER_STOP(timer);\n\tRF_ETIMER_EVAL(timer);\n\ttracerec->q_us += RF_ETIMER_VAL_US(timer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_evenodd_dagfuncs.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_configure.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nint \nrf_Degraded_100_EOFunc(node)\n\tRF_DagNode_t *node;\n{\n\trf_DegrESubroutine(node, node->results[1]);\n\trf_RecoveryXorFunc(node);\t/* does the wakeup here! */\n#if 1\n\treturn (0);\t\t/* XXX this was missing... SHould these be\n\t\t\t\t * void functions??? GO */\n#endif\n}"
  },
  {
    "function_name": "rf_DegrESubroutine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_evenodd_dagfuncs.c",
    "lines": "242-271",
    "snippet": "void \nrf_DegrESubroutine(node, ebuf)\n\tRF_DagNode_t *node;\n\tchar   *ebuf;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tRF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & raidPtr->Layout;\n\tRF_PhysDiskAddr_t *failedPDA = (RF_PhysDiskAddr_t *) node->params[node->numParams - 2].p;\n\tRF_PhysDiskAddr_t *pda;\n\tint     i, suoffset, failedSUOffset = rf_StripeUnitOffset(layoutPtr, failedPDA->startSector);\n\tRF_RowCol_t scol;\n\tchar   *srcbuf, *destbuf;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\n\tRF_ETIMER_START(timer);\n\tfor (i = 0; i < node->numParams - 2; i += 2) {\n\t\tRF_ASSERT(node->params[i + 1].p != ebuf);\n\t\tpda = (RF_PhysDiskAddr_t *) node->params[i].p;\n\t\tsuoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);\n\t\tscol = rf_EUCol(layoutPtr, pda->raidAddress);\n\t\tsrcbuf = (char *) node->params[i + 1].p;\n\t\tdestbuf = ebuf + rf_RaidAddressToByte(raidPtr, suoffset - failedSUOffset);\n\t\trf_e_encToBuf(raidPtr, scol, srcbuf, RF_EO_MATRIX_DIM - 2, destbuf, pda->numSector);\n\t}\n\n\tRF_ETIMER_STOP(timer);\n\tRF_ETIMER_EVAL(timer);\n\ttracerec->q_us += RF_ETIMER_VAL_US(timer);\n}",
    "includes": [
      "#include \"rf_evenodd_dagfuncs.h\"",
      "#include \"rf_evenodd.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_ETIMER_VAL_US",
          "args": [
            "timer"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_EVAL",
          "args": [
            "timer"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_STOP",
          "args": [
            "timer"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_e_encToBuf",
          "args": [
            "raidPtr",
            "scol",
            "srcbuf",
            "RF_EO_MATRIX_DIM - 2",
            "destbuf",
            "pda->numSector"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "rf_e_encToBuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_evenodd_dagfuncs.c",
          "lines": "371-387",
          "snippet": "void \nrf_e_encToBuf(\n    RF_Raid_t * raidPtr,\n    RF_RowCol_t srcLogicCol,\n    char *srcbuf,\n    RF_RowCol_t destLogicCol,\n    char *destbuf,\n    int numSector)\n{\n\tint     i, bytesPerSector = rf_RaidAddressToByte(raidPtr, 1);\n\n\tfor (i = 0; i < numSector; i++) {\n\t\trf_e_EncOneSect(srcLogicCol, srcbuf, destLogicCol, destbuf, bytesPerSector);\n\t\tsrcbuf += bytesPerSector;\n\t\tdestbuf += bytesPerSector;\n\t}\n}",
          "includes": [
            "#include \"rf_evenodd_dagfuncs.h\"",
            "#include \"rf_evenodd.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dagdegwr.h\"",
            "#include \"rf_dagdegrd.h\"",
            "#include \"rf_dagffwr.h\"",
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_evenodd_dagfuncs.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_configure.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_e_encToBuf(\n    RF_Raid_t * raidPtr,\n    RF_RowCol_t srcLogicCol,\n    char *srcbuf,\n    RF_RowCol_t destLogicCol,\n    char *destbuf,\n    int numSector)\n{\n\tint     i, bytesPerSector = rf_RaidAddressToByte(raidPtr, 1);\n\n\tfor (i = 0; i < numSector; i++) {\n\t\trf_e_EncOneSect(srcLogicCol, srcbuf, destLogicCol, destbuf, bytesPerSector);\n\t\tsrcbuf += bytesPerSector;\n\t\tdestbuf += bytesPerSector;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "suoffset - failedSUOffset"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_EUCol",
          "args": [
            "layoutPtr",
            "pda->raidAddress"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_StripeUnitOffset",
          "args": [
            "layoutPtr",
            "pda->startSector"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "node->params[i + 1].p != ebuf"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_START",
          "args": [
            "timer"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_StripeUnitOffset",
          "args": [
            "layoutPtr",
            "failedPDA->startSector"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_evenodd_dagfuncs.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_configure.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_DegrESubroutine(node, ebuf)\n\tRF_DagNode_t *node;\n\tchar   *ebuf;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tRF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & raidPtr->Layout;\n\tRF_PhysDiskAddr_t *failedPDA = (RF_PhysDiskAddr_t *) node->params[node->numParams - 2].p;\n\tRF_PhysDiskAddr_t *pda;\n\tint     i, suoffset, failedSUOffset = rf_StripeUnitOffset(layoutPtr, failedPDA->startSector);\n\tRF_RowCol_t scol;\n\tchar   *srcbuf, *destbuf;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\n\tRF_ETIMER_START(timer);\n\tfor (i = 0; i < node->numParams - 2; i += 2) {\n\t\tRF_ASSERT(node->params[i + 1].p != ebuf);\n\t\tpda = (RF_PhysDiskAddr_t *) node->params[i].p;\n\t\tsuoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);\n\t\tscol = rf_EUCol(layoutPtr, pda->raidAddress);\n\t\tsrcbuf = (char *) node->params[i + 1].p;\n\t\tdestbuf = ebuf + rf_RaidAddressToByte(raidPtr, suoffset - failedSUOffset);\n\t\trf_e_encToBuf(raidPtr, scol, srcbuf, RF_EO_MATRIX_DIM - 2, destbuf, pda->numSector);\n\t}\n\n\tRF_ETIMER_STOP(timer);\n\tRF_ETIMER_EVAL(timer);\n\ttracerec->q_us += RF_ETIMER_VAL_US(timer);\n}"
  },
  {
    "function_name": "rf_RegularEFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_evenodd_dagfuncs.c",
    "lines": "219-228",
    "snippet": "int \nrf_RegularEFunc(node)\n\tRF_DagNode_t *node;\n{\n\trf_RegularESubroutine(node, node->results[0]);\n\trf_GenericWakeupFunc(node, 0);\n#if 1\n\treturn (0);\t\t/* XXX this was missing?.. GO */\n#endif\n}",
    "includes": [
      "#include \"rf_evenodd_dagfuncs.h\"",
      "#include \"rf_evenodd.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_GenericWakeupFunc",
          "args": [
            "node",
            "0"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "rf_GenericWakeupFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
          "lines": "425-460",
          "snippet": "int \nrf_GenericWakeupFunc(node, status)\n\tRF_DagNode_t *node;\n\tint     status;\n{\n\tswitch (node->status) {\n\tcase rf_bwd1:\n\t\tnode->status = rf_bwd2;\n\t\tif (node->dagFuncData)\n\t\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\t\treturn (rf_DiskWriteFuncForThreads(node));\n\t\tbreak;\n\tcase rf_fired:\n\t\tif (status)\n\t\t\tnode->status = rf_bad;\n\t\telse\n\t\t\tnode->status = rf_good;\n\t\tbreak;\n\tcase rf_recover:\n\t\t/* probably should never reach this case */\n\t\tif (status)\n\t\t\tnode->status = rf_panic;\n\t\telse\n\t\t\tnode->status = rf_undone;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"rf_GenericWakeupFunc:\");\n\t\tprintf(\"node->status is %d,\", node->status);\n\t\tprintf(\"status is %d \\n\", status);\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\tif (node->dagFuncData)\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\treturn (rf_FinishNode(node, RF_INTR_CONTEXT));\n}",
          "includes": [
            "#include \"rf_paritylog.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_GenericWakeupFunc(node, status)\n\tRF_DagNode_t *node;\n\tint     status;\n{\n\tswitch (node->status) {\n\tcase rf_bwd1:\n\t\tnode->status = rf_bwd2;\n\t\tif (node->dagFuncData)\n\t\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\t\treturn (rf_DiskWriteFuncForThreads(node));\n\t\tbreak;\n\tcase rf_fired:\n\t\tif (status)\n\t\t\tnode->status = rf_bad;\n\t\telse\n\t\t\tnode->status = rf_good;\n\t\tbreak;\n\tcase rf_recover:\n\t\t/* probably should never reach this case */\n\t\tif (status)\n\t\t\tnode->status = rf_panic;\n\t\telse\n\t\t\tnode->status = rf_undone;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"rf_GenericWakeupFunc:\");\n\t\tprintf(\"node->status is %d,\", node->status);\n\t\tprintf(\"status is %d \\n\", status);\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\tif (node->dagFuncData)\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\treturn (rf_FinishNode(node, RF_INTR_CONTEXT));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_RegularESubroutine",
          "args": [
            "node",
            "node->results[0]"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "rf_RegularESubroutine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_evenodd_dagfuncs.c",
          "lines": "186-213",
          "snippet": "void \nrf_RegularESubroutine(node, ebuf)\n\tRF_DagNode_t *node;\n\tchar   *ebuf;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tRF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & raidPtr->Layout;\n\tRF_PhysDiskAddr_t *pda;\n\tint     i, suoffset;\n\tRF_RowCol_t scol;\n\tchar   *srcbuf, *destbuf;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\n\tRF_ETIMER_START(timer);\n\tfor (i = 0; i < node->numParams - 2; i += 2) {\n\t\tRF_ASSERT(node->params[i + 1].p != ebuf);\n\t\tpda = (RF_PhysDiskAddr_t *) node->params[i].p;\n\t\tsuoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);\n\t\tscol = rf_EUCol(layoutPtr, pda->raidAddress);\n\t\tsrcbuf = (char *) node->params[i + 1].p;\n\t\tdestbuf = ebuf + rf_RaidAddressToByte(raidPtr, suoffset);\n\t\trf_e_encToBuf(raidPtr, scol, srcbuf, RF_EO_MATRIX_DIM - 2, destbuf, pda->numSector);\n\t}\n\tRF_ETIMER_STOP(timer);\n\tRF_ETIMER_EVAL(timer);\n\ttracerec->xor_us += RF_ETIMER_VAL_US(timer);\n}",
          "includes": [
            "#include \"rf_evenodd_dagfuncs.h\"",
            "#include \"rf_evenodd.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dagdegwr.h\"",
            "#include \"rf_dagdegrd.h\"",
            "#include \"rf_dagffwr.h\"",
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_evenodd_dagfuncs.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_configure.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_RegularESubroutine(node, ebuf)\n\tRF_DagNode_t *node;\n\tchar   *ebuf;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tRF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & raidPtr->Layout;\n\tRF_PhysDiskAddr_t *pda;\n\tint     i, suoffset;\n\tRF_RowCol_t scol;\n\tchar   *srcbuf, *destbuf;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\n\tRF_ETIMER_START(timer);\n\tfor (i = 0; i < node->numParams - 2; i += 2) {\n\t\tRF_ASSERT(node->params[i + 1].p != ebuf);\n\t\tpda = (RF_PhysDiskAddr_t *) node->params[i].p;\n\t\tsuoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);\n\t\tscol = rf_EUCol(layoutPtr, pda->raidAddress);\n\t\tsrcbuf = (char *) node->params[i + 1].p;\n\t\tdestbuf = ebuf + rf_RaidAddressToByte(raidPtr, suoffset);\n\t\trf_e_encToBuf(raidPtr, scol, srcbuf, RF_EO_MATRIX_DIM - 2, destbuf, pda->numSector);\n\t}\n\tRF_ETIMER_STOP(timer);\n\tRF_ETIMER_EVAL(timer);\n\ttracerec->xor_us += RF_ETIMER_VAL_US(timer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_evenodd_dagfuncs.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_configure.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nint \nrf_RegularEFunc(node)\n\tRF_DagNode_t *node;\n{\n\trf_RegularESubroutine(node, node->results[0]);\n\trf_GenericWakeupFunc(node, 0);\n#if 1\n\treturn (0);\t\t/* XXX this was missing?.. GO */\n#endif\n}"
  },
  {
    "function_name": "rf_RegularESubroutine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_evenodd_dagfuncs.c",
    "lines": "186-213",
    "snippet": "void \nrf_RegularESubroutine(node, ebuf)\n\tRF_DagNode_t *node;\n\tchar   *ebuf;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tRF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & raidPtr->Layout;\n\tRF_PhysDiskAddr_t *pda;\n\tint     i, suoffset;\n\tRF_RowCol_t scol;\n\tchar   *srcbuf, *destbuf;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\n\tRF_ETIMER_START(timer);\n\tfor (i = 0; i < node->numParams - 2; i += 2) {\n\t\tRF_ASSERT(node->params[i + 1].p != ebuf);\n\t\tpda = (RF_PhysDiskAddr_t *) node->params[i].p;\n\t\tsuoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);\n\t\tscol = rf_EUCol(layoutPtr, pda->raidAddress);\n\t\tsrcbuf = (char *) node->params[i + 1].p;\n\t\tdestbuf = ebuf + rf_RaidAddressToByte(raidPtr, suoffset);\n\t\trf_e_encToBuf(raidPtr, scol, srcbuf, RF_EO_MATRIX_DIM - 2, destbuf, pda->numSector);\n\t}\n\tRF_ETIMER_STOP(timer);\n\tRF_ETIMER_EVAL(timer);\n\ttracerec->xor_us += RF_ETIMER_VAL_US(timer);\n}",
    "includes": [
      "#include \"rf_evenodd_dagfuncs.h\"",
      "#include \"rf_evenodd.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_ETIMER_VAL_US",
          "args": [
            "timer"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_EVAL",
          "args": [
            "timer"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_STOP",
          "args": [
            "timer"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_e_encToBuf",
          "args": [
            "raidPtr",
            "scol",
            "srcbuf",
            "RF_EO_MATRIX_DIM - 2",
            "destbuf",
            "pda->numSector"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "rf_e_encToBuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_evenodd_dagfuncs.c",
          "lines": "371-387",
          "snippet": "void \nrf_e_encToBuf(\n    RF_Raid_t * raidPtr,\n    RF_RowCol_t srcLogicCol,\n    char *srcbuf,\n    RF_RowCol_t destLogicCol,\n    char *destbuf,\n    int numSector)\n{\n\tint     i, bytesPerSector = rf_RaidAddressToByte(raidPtr, 1);\n\n\tfor (i = 0; i < numSector; i++) {\n\t\trf_e_EncOneSect(srcLogicCol, srcbuf, destLogicCol, destbuf, bytesPerSector);\n\t\tsrcbuf += bytesPerSector;\n\t\tdestbuf += bytesPerSector;\n\t}\n}",
          "includes": [
            "#include \"rf_evenodd_dagfuncs.h\"",
            "#include \"rf_evenodd.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dagdegwr.h\"",
            "#include \"rf_dagdegrd.h\"",
            "#include \"rf_dagffwr.h\"",
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_evenodd_dagfuncs.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_configure.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_e_encToBuf(\n    RF_Raid_t * raidPtr,\n    RF_RowCol_t srcLogicCol,\n    char *srcbuf,\n    RF_RowCol_t destLogicCol,\n    char *destbuf,\n    int numSector)\n{\n\tint     i, bytesPerSector = rf_RaidAddressToByte(raidPtr, 1);\n\n\tfor (i = 0; i < numSector; i++) {\n\t\trf_e_EncOneSect(srcLogicCol, srcbuf, destLogicCol, destbuf, bytesPerSector);\n\t\tsrcbuf += bytesPerSector;\n\t\tdestbuf += bytesPerSector;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "suoffset"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_EUCol",
          "args": [
            "layoutPtr",
            "pda->raidAddress"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_StripeUnitOffset",
          "args": [
            "layoutPtr",
            "pda->startSector"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "node->params[i + 1].p != ebuf"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_START",
          "args": [
            "timer"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_evenodd_dagfuncs.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_configure.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_RegularESubroutine(node, ebuf)\n\tRF_DagNode_t *node;\n\tchar   *ebuf;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tRF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & raidPtr->Layout;\n\tRF_PhysDiskAddr_t *pda;\n\tint     i, suoffset;\n\tRF_RowCol_t scol;\n\tchar   *srcbuf, *destbuf;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\n\tRF_ETIMER_START(timer);\n\tfor (i = 0; i < node->numParams - 2; i += 2) {\n\t\tRF_ASSERT(node->params[i + 1].p != ebuf);\n\t\tpda = (RF_PhysDiskAddr_t *) node->params[i].p;\n\t\tsuoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);\n\t\tscol = rf_EUCol(layoutPtr, pda->raidAddress);\n\t\tsrcbuf = (char *) node->params[i + 1].p;\n\t\tdestbuf = ebuf + rf_RaidAddressToByte(raidPtr, suoffset);\n\t\trf_e_encToBuf(raidPtr, scol, srcbuf, RF_EO_MATRIX_DIM - 2, destbuf, pda->numSector);\n\t}\n\tRF_ETIMER_STOP(timer);\n\tRF_ETIMER_EVAL(timer);\n\ttracerec->xor_us += RF_ETIMER_VAL_US(timer);\n}"
  },
  {
    "function_name": "rf_SimpleONEFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_evenodd_dagfuncs.c",
    "lines": "145-182",
    "snippet": "int \nrf_SimpleONEFunc(node)\n\tRF_DagNode_t *node;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tRF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & raidPtr->Layout;\n\tRF_PhysDiskAddr_t *pda = (RF_PhysDiskAddr_t *) node->params[0].p;\n\tint     retcode = 0;\n\tchar   *srcbuf, *destbuf;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tint     length;\n\tRF_RowCol_t scol;\n\tRF_Etimer_t timer;\n\n\tRF_ASSERT(((RF_PhysDiskAddr_t *) node->params[2].p)->type == RF_PDA_TYPE_Q);\n\tif (node->dagHdr->status == rf_enable) {\n\t\tRF_ETIMER_START(timer);\n\t\tlength = rf_RaidAddressToByte(raidPtr, ((RF_PhysDiskAddr_t *) node->params[4].p)->numSector);\t/* this is a pda of\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t * writeDataNodes */\n\t\t/* bxor to buffer of readDataNodes */\n\t\tretcode = rf_bxor(node->params[5].p, node->params[1].p, length, node->dagHdr->bp);\n\t\t/* find out the corresponding colume in encoding matrix for\n\t\t * write colume to be encoded into redundant disk 'E' */\n\t\tscol = rf_EUCol(layoutPtr, pda->raidAddress);\n\t\tsrcbuf = node->params[1].p;\n\t\tdestbuf = node->params[3].p;\n\t\t/* Start encoding process */\n\t\trf_e_encToBuf(raidPtr, scol, srcbuf, RF_EO_MATRIX_DIM - 2, destbuf, pda->numSector);\n\t\trf_bxor(node->params[5].p, node->params[1].p, length, node->dagHdr->bp);\n\t\tRF_ETIMER_STOP(timer);\n\t\tRF_ETIMER_EVAL(timer);\n\t\ttracerec->q_us += RF_ETIMER_VAL_US(timer);\n\n\t}\n\treturn (rf_GenericWakeupFunc(node, retcode));\t/* call wake func\n\t\t\t\t\t\t\t * explicitly since no\n\t\t\t\t\t\t\t * I/O in this node */\n}",
    "includes": [
      "#include \"rf_evenodd_dagfuncs.h\"",
      "#include \"rf_evenodd.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_GenericWakeupFunc",
          "args": [
            "node",
            "retcode"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "rf_GenericWakeupFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
          "lines": "425-460",
          "snippet": "int \nrf_GenericWakeupFunc(node, status)\n\tRF_DagNode_t *node;\n\tint     status;\n{\n\tswitch (node->status) {\n\tcase rf_bwd1:\n\t\tnode->status = rf_bwd2;\n\t\tif (node->dagFuncData)\n\t\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\t\treturn (rf_DiskWriteFuncForThreads(node));\n\t\tbreak;\n\tcase rf_fired:\n\t\tif (status)\n\t\t\tnode->status = rf_bad;\n\t\telse\n\t\t\tnode->status = rf_good;\n\t\tbreak;\n\tcase rf_recover:\n\t\t/* probably should never reach this case */\n\t\tif (status)\n\t\t\tnode->status = rf_panic;\n\t\telse\n\t\t\tnode->status = rf_undone;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"rf_GenericWakeupFunc:\");\n\t\tprintf(\"node->status is %d,\", node->status);\n\t\tprintf(\"status is %d \\n\", status);\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\tif (node->dagFuncData)\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\treturn (rf_FinishNode(node, RF_INTR_CONTEXT));\n}",
          "includes": [
            "#include \"rf_paritylog.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_GenericWakeupFunc(node, status)\n\tRF_DagNode_t *node;\n\tint     status;\n{\n\tswitch (node->status) {\n\tcase rf_bwd1:\n\t\tnode->status = rf_bwd2;\n\t\tif (node->dagFuncData)\n\t\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\t\treturn (rf_DiskWriteFuncForThreads(node));\n\t\tbreak;\n\tcase rf_fired:\n\t\tif (status)\n\t\t\tnode->status = rf_bad;\n\t\telse\n\t\t\tnode->status = rf_good;\n\t\tbreak;\n\tcase rf_recover:\n\t\t/* probably should never reach this case */\n\t\tif (status)\n\t\t\tnode->status = rf_panic;\n\t\telse\n\t\t\tnode->status = rf_undone;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"rf_GenericWakeupFunc:\");\n\t\tprintf(\"node->status is %d,\", node->status);\n\t\tprintf(\"status is %d \\n\", status);\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\tif (node->dagFuncData)\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\treturn (rf_FinishNode(node, RF_INTR_CONTEXT));\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_VAL_US",
          "args": [
            "timer"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_EVAL",
          "args": [
            "timer"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_STOP",
          "args": [
            "timer"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_bxor",
          "args": [
            "node->params[5].p",
            "node->params[1].p",
            "length",
            "node->dagHdr->bp"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "rf_bxor3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
          "lines": "880-893",
          "snippet": "int \nrf_bxor3(dst, a, b, c, len, bp)\n\tregister unsigned char *dst;\n\tregister unsigned char *a;\n\tregister unsigned char *b;\n\tregister unsigned char *c;\n\tunsigned long len;\n\tvoid   *bp;\n{\n\tRF_ASSERT(((RF_UL(dst) | RF_UL(a) | RF_UL(b) | RF_UL(c) | len) & 0x7) == 0);\n\n\treturn (rf_longword_bxor3((unsigned long *) dst, (unsigned long *) a,\n\t\t(unsigned long *) b, (unsigned long *) c, len >> RF_LONGSHIFT, bp));\n}",
          "includes": [
            "#include \"rf_paritylog.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint \nrf_bxor3(dst, a, b, c, len, bp)\n\tregister unsigned char *dst;\n\tregister unsigned char *a;\n\tregister unsigned char *b;\n\tregister unsigned char *c;\n\tunsigned long len;\n\tvoid   *bp;\n{\n\tRF_ASSERT(((RF_UL(dst) | RF_UL(a) | RF_UL(b) | RF_UL(c) | len) & 0x7) == 0);\n\n\treturn (rf_longword_bxor3((unsigned long *) dst, (unsigned long *) a,\n\t\t(unsigned long *) b, (unsigned long *) c, len >> RF_LONGSHIFT, bp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_e_encToBuf",
          "args": [
            "raidPtr",
            "scol",
            "srcbuf",
            "RF_EO_MATRIX_DIM - 2",
            "destbuf",
            "pda->numSector"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "rf_e_encToBuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_evenodd_dagfuncs.c",
          "lines": "371-387",
          "snippet": "void \nrf_e_encToBuf(\n    RF_Raid_t * raidPtr,\n    RF_RowCol_t srcLogicCol,\n    char *srcbuf,\n    RF_RowCol_t destLogicCol,\n    char *destbuf,\n    int numSector)\n{\n\tint     i, bytesPerSector = rf_RaidAddressToByte(raidPtr, 1);\n\n\tfor (i = 0; i < numSector; i++) {\n\t\trf_e_EncOneSect(srcLogicCol, srcbuf, destLogicCol, destbuf, bytesPerSector);\n\t\tsrcbuf += bytesPerSector;\n\t\tdestbuf += bytesPerSector;\n\t}\n}",
          "includes": [
            "#include \"rf_evenodd_dagfuncs.h\"",
            "#include \"rf_evenodd.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dagdegwr.h\"",
            "#include \"rf_dagdegrd.h\"",
            "#include \"rf_dagffwr.h\"",
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_evenodd_dagfuncs.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_configure.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_e_encToBuf(\n    RF_Raid_t * raidPtr,\n    RF_RowCol_t srcLogicCol,\n    char *srcbuf,\n    RF_RowCol_t destLogicCol,\n    char *destbuf,\n    int numSector)\n{\n\tint     i, bytesPerSector = rf_RaidAddressToByte(raidPtr, 1);\n\n\tfor (i = 0; i < numSector; i++) {\n\t\trf_e_EncOneSect(srcLogicCol, srcbuf, destLogicCol, destbuf, bytesPerSector);\n\t\tsrcbuf += bytesPerSector;\n\t\tdestbuf += bytesPerSector;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_EUCol",
          "args": [
            "layoutPtr",
            "pda->raidAddress"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "((RF_PhysDiskAddr_t *) node->params[4].p)->numSector"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_START",
          "args": [
            "timer"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "((RF_PhysDiskAddr_t *) node->params[2].p)->type == RF_PDA_TYPE_Q"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_evenodd_dagfuncs.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_configure.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nint \nrf_SimpleONEFunc(node)\n\tRF_DagNode_t *node;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tRF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & raidPtr->Layout;\n\tRF_PhysDiskAddr_t *pda = (RF_PhysDiskAddr_t *) node->params[0].p;\n\tint     retcode = 0;\n\tchar   *srcbuf, *destbuf;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tint     length;\n\tRF_RowCol_t scol;\n\tRF_Etimer_t timer;\n\n\tRF_ASSERT(((RF_PhysDiskAddr_t *) node->params[2].p)->type == RF_PDA_TYPE_Q);\n\tif (node->dagHdr->status == rf_enable) {\n\t\tRF_ETIMER_START(timer);\n\t\tlength = rf_RaidAddressToByte(raidPtr, ((RF_PhysDiskAddr_t *) node->params[4].p)->numSector);\t/* this is a pda of\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t * writeDataNodes */\n\t\t/* bxor to buffer of readDataNodes */\n\t\tretcode = rf_bxor(node->params[5].p, node->params[1].p, length, node->dagHdr->bp);\n\t\t/* find out the corresponding colume in encoding matrix for\n\t\t * write colume to be encoded into redundant disk 'E' */\n\t\tscol = rf_EUCol(layoutPtr, pda->raidAddress);\n\t\tsrcbuf = node->params[1].p;\n\t\tdestbuf = node->params[3].p;\n\t\t/* Start encoding process */\n\t\trf_e_encToBuf(raidPtr, scol, srcbuf, RF_EO_MATRIX_DIM - 2, destbuf, pda->numSector);\n\t\trf_bxor(node->params[5].p, node->params[1].p, length, node->dagHdr->bp);\n\t\tRF_ETIMER_STOP(timer);\n\t\tRF_ETIMER_EVAL(timer);\n\t\ttracerec->q_us += RF_ETIMER_VAL_US(timer);\n\n\t}\n\treturn (rf_GenericWakeupFunc(node, retcode));\t/* call wake func\n\t\t\t\t\t\t\t * explicitly since no\n\t\t\t\t\t\t\t * I/O in this node */\n}"
  },
  {
    "function_name": "rf_RegularONEFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_evenodd_dagfuncs.c",
    "lines": "89-143",
    "snippet": "int \nrf_RegularONEFunc(node)\n\tRF_DagNode_t *node;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tRF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & raidPtr->Layout;\n\tint     EpdaIndex = (node->numParams - 1) / 2 - 1;\t/* the parameter of node\n\t\t\t\t\t\t\t\t * where you can find\n\t\t\t\t\t\t\t\t * e-pda */\n\tint     i, k, retcode = 0;\n\tint     suoffset, length;\n\tRF_RowCol_t scol;\n\tchar   *srcbuf, *destbuf;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\tRF_PhysDiskAddr_t *pda, *EPDA = (RF_PhysDiskAddr_t *) node->params[EpdaIndex].p;\n\tint     ESUOffset = rf_StripeUnitOffset(layoutPtr, EPDA->startSector);\t/* generally zero  */\n\n\tRF_ASSERT(EPDA->type == RF_PDA_TYPE_Q);\n\tRF_ASSERT(ESUOffset == 0);\n\n\tRF_ETIMER_START(timer);\n\n\t/* Xor the Wnd buffer into Rod buffer, the difference of old data and\n\t * new data is stored in Rod buffer */\n\tfor (k = 0; k < EpdaIndex; k += 2) {\n\t\tlength = rf_RaidAddressToByte(raidPtr, ((RF_PhysDiskAddr_t *) node->params[k].p)->numSector);\n\t\tretcode = rf_bxor(node->params[k + EpdaIndex + 3].p, node->params[k + 1].p, length, node->dagHdr->bp);\n\t}\n\t/* Start to encoding the buffer storing the difference of old data and\n\t * new data into 'E' buffer  */\n\tfor (i = 0; i < EpdaIndex; i += 2)\n\t\tif (node->params[i + 1].p != node->results[0]) {\t/* results[0] is buf ptr\n\t\t\t\t\t\t\t\t\t * of E */\n\t\t\tpda = (RF_PhysDiskAddr_t *) node->params[i].p;\n\t\t\tsrcbuf = (char *) node->params[i + 1].p;\n\t\t\tscol = rf_EUCol(layoutPtr, pda->raidAddress);\n\t\t\tsuoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);\n\t\t\tdestbuf = ((char *) node->results[0]) + rf_RaidAddressToByte(raidPtr, suoffset);\n\t\t\trf_e_encToBuf(raidPtr, scol, srcbuf, RF_EO_MATRIX_DIM - 2, destbuf, pda->numSector);\n\t\t}\n\t/* Recover the original old data to be used by parity encoding\n\t * function in XorNode */\n\tfor (k = 0; k < EpdaIndex; k += 2) {\n\t\tlength = rf_RaidAddressToByte(raidPtr, ((RF_PhysDiskAddr_t *) node->params[k].p)->numSector);\n\t\tretcode = rf_bxor(node->params[k + EpdaIndex + 3].p, node->params[k + 1].p, length, node->dagHdr->bp);\n\t}\n\tRF_ETIMER_STOP(timer);\n\tRF_ETIMER_EVAL(timer);\n\ttracerec->q_us += RF_ETIMER_VAL_US(timer);\n\trf_GenericWakeupFunc(node, 0);\n#if 1\n\treturn (0);\t\t/* XXX this was missing.. GO */\n#endif\n}",
    "includes": [
      "#include \"rf_evenodd_dagfuncs.h\"",
      "#include \"rf_evenodd.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_GenericWakeupFunc",
          "args": [
            "node",
            "0"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "rf_GenericWakeupFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
          "lines": "425-460",
          "snippet": "int \nrf_GenericWakeupFunc(node, status)\n\tRF_DagNode_t *node;\n\tint     status;\n{\n\tswitch (node->status) {\n\tcase rf_bwd1:\n\t\tnode->status = rf_bwd2;\n\t\tif (node->dagFuncData)\n\t\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\t\treturn (rf_DiskWriteFuncForThreads(node));\n\t\tbreak;\n\tcase rf_fired:\n\t\tif (status)\n\t\t\tnode->status = rf_bad;\n\t\telse\n\t\t\tnode->status = rf_good;\n\t\tbreak;\n\tcase rf_recover:\n\t\t/* probably should never reach this case */\n\t\tif (status)\n\t\t\tnode->status = rf_panic;\n\t\telse\n\t\t\tnode->status = rf_undone;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"rf_GenericWakeupFunc:\");\n\t\tprintf(\"node->status is %d,\", node->status);\n\t\tprintf(\"status is %d \\n\", status);\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\tif (node->dagFuncData)\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\treturn (rf_FinishNode(node, RF_INTR_CONTEXT));\n}",
          "includes": [
            "#include \"rf_paritylog.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_GenericWakeupFunc(node, status)\n\tRF_DagNode_t *node;\n\tint     status;\n{\n\tswitch (node->status) {\n\tcase rf_bwd1:\n\t\tnode->status = rf_bwd2;\n\t\tif (node->dagFuncData)\n\t\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\t\treturn (rf_DiskWriteFuncForThreads(node));\n\t\tbreak;\n\tcase rf_fired:\n\t\tif (status)\n\t\t\tnode->status = rf_bad;\n\t\telse\n\t\t\tnode->status = rf_good;\n\t\tbreak;\n\tcase rf_recover:\n\t\t/* probably should never reach this case */\n\t\tif (status)\n\t\t\tnode->status = rf_panic;\n\t\telse\n\t\t\tnode->status = rf_undone;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"rf_GenericWakeupFunc:\");\n\t\tprintf(\"node->status is %d,\", node->status);\n\t\tprintf(\"status is %d \\n\", status);\n\t\tRF_PANIC();\n\t\tbreak;\n\t}\n\tif (node->dagFuncData)\n\t\trf_FreeDiskQueueData((RF_DiskQueueData_t *) node->dagFuncData);\n\treturn (rf_FinishNode(node, RF_INTR_CONTEXT));\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_VAL_US",
          "args": [
            "timer"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_EVAL",
          "args": [
            "timer"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_STOP",
          "args": [
            "timer"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_bxor",
          "args": [
            "node->params[k + EpdaIndex + 3].p",
            "node->params[k + 1].p",
            "length",
            "node->dagHdr->bp"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "rf_bxor3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
          "lines": "880-893",
          "snippet": "int \nrf_bxor3(dst, a, b, c, len, bp)\n\tregister unsigned char *dst;\n\tregister unsigned char *a;\n\tregister unsigned char *b;\n\tregister unsigned char *c;\n\tunsigned long len;\n\tvoid   *bp;\n{\n\tRF_ASSERT(((RF_UL(dst) | RF_UL(a) | RF_UL(b) | RF_UL(c) | len) & 0x7) == 0);\n\n\treturn (rf_longword_bxor3((unsigned long *) dst, (unsigned long *) a,\n\t\t(unsigned long *) b, (unsigned long *) c, len >> RF_LONGSHIFT, bp));\n}",
          "includes": [
            "#include \"rf_paritylog.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint \nrf_bxor3(dst, a, b, c, len, bp)\n\tregister unsigned char *dst;\n\tregister unsigned char *a;\n\tregister unsigned char *b;\n\tregister unsigned char *c;\n\tunsigned long len;\n\tvoid   *bp;\n{\n\tRF_ASSERT(((RF_UL(dst) | RF_UL(a) | RF_UL(b) | RF_UL(c) | len) & 0x7) == 0);\n\n\treturn (rf_longword_bxor3((unsigned long *) dst, (unsigned long *) a,\n\t\t(unsigned long *) b, (unsigned long *) c, len >> RF_LONGSHIFT, bp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "((RF_PhysDiskAddr_t *) node->params[k].p)->numSector"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_e_encToBuf",
          "args": [
            "raidPtr",
            "scol",
            "srcbuf",
            "RF_EO_MATRIX_DIM - 2",
            "destbuf",
            "pda->numSector"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "rf_e_encToBuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_evenodd_dagfuncs.c",
          "lines": "371-387",
          "snippet": "void \nrf_e_encToBuf(\n    RF_Raid_t * raidPtr,\n    RF_RowCol_t srcLogicCol,\n    char *srcbuf,\n    RF_RowCol_t destLogicCol,\n    char *destbuf,\n    int numSector)\n{\n\tint     i, bytesPerSector = rf_RaidAddressToByte(raidPtr, 1);\n\n\tfor (i = 0; i < numSector; i++) {\n\t\trf_e_EncOneSect(srcLogicCol, srcbuf, destLogicCol, destbuf, bytesPerSector);\n\t\tsrcbuf += bytesPerSector;\n\t\tdestbuf += bytesPerSector;\n\t}\n}",
          "includes": [
            "#include \"rf_evenodd_dagfuncs.h\"",
            "#include \"rf_evenodd.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dagdegwr.h\"",
            "#include \"rf_dagdegrd.h\"",
            "#include \"rf_dagffwr.h\"",
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_evenodd_dagfuncs.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_configure.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_e_encToBuf(\n    RF_Raid_t * raidPtr,\n    RF_RowCol_t srcLogicCol,\n    char *srcbuf,\n    RF_RowCol_t destLogicCol,\n    char *destbuf,\n    int numSector)\n{\n\tint     i, bytesPerSector = rf_RaidAddressToByte(raidPtr, 1);\n\n\tfor (i = 0; i < numSector; i++) {\n\t\trf_e_EncOneSect(srcLogicCol, srcbuf, destLogicCol, destbuf, bytesPerSector);\n\t\tsrcbuf += bytesPerSector;\n\t\tdestbuf += bytesPerSector;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "suoffset"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_StripeUnitOffset",
          "args": [
            "layoutPtr",
            "pda->startSector"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_EUCol",
          "args": [
            "layoutPtr",
            "pda->raidAddress"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "((RF_PhysDiskAddr_t *) node->params[k].p)->numSector"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ETIMER_START",
          "args": [
            "timer"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "ESUOffset == 0"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "EPDA->type == RF_PDA_TYPE_Q"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_StripeUnitOffset",
          "args": [
            "layoutPtr",
            "EPDA->startSector"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_evenodd_dagfuncs.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_configure.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nint \nrf_RegularONEFunc(node)\n\tRF_DagNode_t *node;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tRF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & raidPtr->Layout;\n\tint     EpdaIndex = (node->numParams - 1) / 2 - 1;\t/* the parameter of node\n\t\t\t\t\t\t\t\t * where you can find\n\t\t\t\t\t\t\t\t * e-pda */\n\tint     i, k, retcode = 0;\n\tint     suoffset, length;\n\tRF_RowCol_t scol;\n\tchar   *srcbuf, *destbuf;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\tRF_PhysDiskAddr_t *pda, *EPDA = (RF_PhysDiskAddr_t *) node->params[EpdaIndex].p;\n\tint     ESUOffset = rf_StripeUnitOffset(layoutPtr, EPDA->startSector);\t/* generally zero  */\n\n\tRF_ASSERT(EPDA->type == RF_PDA_TYPE_Q);\n\tRF_ASSERT(ESUOffset == 0);\n\n\tRF_ETIMER_START(timer);\n\n\t/* Xor the Wnd buffer into Rod buffer, the difference of old data and\n\t * new data is stored in Rod buffer */\n\tfor (k = 0; k < EpdaIndex; k += 2) {\n\t\tlength = rf_RaidAddressToByte(raidPtr, ((RF_PhysDiskAddr_t *) node->params[k].p)->numSector);\n\t\tretcode = rf_bxor(node->params[k + EpdaIndex + 3].p, node->params[k + 1].p, length, node->dagHdr->bp);\n\t}\n\t/* Start to encoding the buffer storing the difference of old data and\n\t * new data into 'E' buffer  */\n\tfor (i = 0; i < EpdaIndex; i += 2)\n\t\tif (node->params[i + 1].p != node->results[0]) {\t/* results[0] is buf ptr\n\t\t\t\t\t\t\t\t\t * of E */\n\t\t\tpda = (RF_PhysDiskAddr_t *) node->params[i].p;\n\t\t\tsrcbuf = (char *) node->params[i + 1].p;\n\t\t\tscol = rf_EUCol(layoutPtr, pda->raidAddress);\n\t\t\tsuoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);\n\t\t\tdestbuf = ((char *) node->results[0]) + rf_RaidAddressToByte(raidPtr, suoffset);\n\t\t\trf_e_encToBuf(raidPtr, scol, srcbuf, RF_EO_MATRIX_DIM - 2, destbuf, pda->numSector);\n\t\t}\n\t/* Recover the original old data to be used by parity encoding\n\t * function in XorNode */\n\tfor (k = 0; k < EpdaIndex; k += 2) {\n\t\tlength = rf_RaidAddressToByte(raidPtr, ((RF_PhysDiskAddr_t *) node->params[k].p)->numSector);\n\t\tretcode = rf_bxor(node->params[k + EpdaIndex + 3].p, node->params[k + 1].p, length, node->dagHdr->bp);\n\t}\n\tRF_ETIMER_STOP(timer);\n\tRF_ETIMER_EVAL(timer);\n\ttracerec->q_us += RF_ETIMER_VAL_US(timer);\n\trf_GenericWakeupFunc(node, 0);\n#if 1\n\treturn (0);\t\t/* XXX this was missing.. GO */\n#endif\n}"
  },
  {
    "function_name": "rf_RegularPEFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_evenodd_dagfuncs.c",
    "lines": "59-68",
    "snippet": "int \nrf_RegularPEFunc(node)\n\tRF_DagNode_t *node;\n{\n\trf_RegularESubroutine(node, node->results[1]);\n\trf_RegularXorFunc(node);/* does the wakeup here! */\n#if 1\n\treturn (0);\t\t/* XXX This was missing... GO */\n#endif\n}",
    "includes": [
      "#include \"rf_evenodd_dagfuncs.h\"",
      "#include \"rf_evenodd.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_RegularXorFunc",
          "args": [
            "node"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "rf_RegularXorFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
          "lines": "485-510",
          "snippet": "int \nrf_RegularXorFunc(node)\n\tRF_DagNode_t *node;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\tint     i, retcode;\n\n\tretcode = 0;\n\tif (node->dagHdr->status == rf_enable) {\n\t\t/* don't do the XOR if the input is the same as the output */\n\t\tRF_ETIMER_START(timer);\n\t\tfor (i = 0; i < node->numParams - 1; i += 2)\n\t\t\tif (node->params[i + 1].p != node->results[0]) {\n\t\t\t\tretcode = rf_XorIntoBuffer(raidPtr, (RF_PhysDiskAddr_t *) node->params[i].p,\n\t\t\t\t    (char *) node->params[i + 1].p, (char *) node->results[0], node->dagHdr->bp);\n\t\t\t}\n\t\tRF_ETIMER_STOP(timer);\n\t\tRF_ETIMER_EVAL(timer);\n\t\ttracerec->xor_us += RF_ETIMER_VAL_US(timer);\n\t}\n\treturn (rf_GenericWakeupFunc(node, retcode));\t/* call wake func\n\t\t\t\t\t\t\t * explicitly since no\n\t\t\t\t\t\t\t * I/O in this node */\n}",
          "includes": [
            "#include \"rf_paritylog.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int     (*rf_DiskReadFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockFunc) (RF_DagNode_t *);",
            "int     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);",
            "int     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint     (*rf_DiskReadFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteFunc) (RF_DagNode_t *);\nint     (*rf_DiskReadUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskWriteUndoFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockFunc) (RF_DagNode_t *);\nint     (*rf_DiskUnlockUndoFunc) (RF_DagNode_t *);\nint     (*rf_RegularXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_SimpleXorUndoFunc) (RF_DagNode_t *);\nint     (*rf_RecoveryXorUndoFunc) (RF_DagNode_t *);\n\nint \nrf_RegularXorFunc(node)\n\tRF_DagNode_t *node;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\tint     i, retcode;\n\n\tretcode = 0;\n\tif (node->dagHdr->status == rf_enable) {\n\t\t/* don't do the XOR if the input is the same as the output */\n\t\tRF_ETIMER_START(timer);\n\t\tfor (i = 0; i < node->numParams - 1; i += 2)\n\t\t\tif (node->params[i + 1].p != node->results[0]) {\n\t\t\t\tretcode = rf_XorIntoBuffer(raidPtr, (RF_PhysDiskAddr_t *) node->params[i].p,\n\t\t\t\t    (char *) node->params[i + 1].p, (char *) node->results[0], node->dagHdr->bp);\n\t\t\t}\n\t\tRF_ETIMER_STOP(timer);\n\t\tRF_ETIMER_EVAL(timer);\n\t\ttracerec->xor_us += RF_ETIMER_VAL_US(timer);\n\t}\n\treturn (rf_GenericWakeupFunc(node, retcode));\t/* call wake func\n\t\t\t\t\t\t\t * explicitly since no\n\t\t\t\t\t\t\t * I/O in this node */\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_RegularESubroutine",
          "args": [
            "node",
            "node->results[1]"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "rf_RegularESubroutine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_evenodd_dagfuncs.c",
          "lines": "186-213",
          "snippet": "void \nrf_RegularESubroutine(node, ebuf)\n\tRF_DagNode_t *node;\n\tchar   *ebuf;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tRF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & raidPtr->Layout;\n\tRF_PhysDiskAddr_t *pda;\n\tint     i, suoffset;\n\tRF_RowCol_t scol;\n\tchar   *srcbuf, *destbuf;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\n\tRF_ETIMER_START(timer);\n\tfor (i = 0; i < node->numParams - 2; i += 2) {\n\t\tRF_ASSERT(node->params[i + 1].p != ebuf);\n\t\tpda = (RF_PhysDiskAddr_t *) node->params[i].p;\n\t\tsuoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);\n\t\tscol = rf_EUCol(layoutPtr, pda->raidAddress);\n\t\tsrcbuf = (char *) node->params[i + 1].p;\n\t\tdestbuf = ebuf + rf_RaidAddressToByte(raidPtr, suoffset);\n\t\trf_e_encToBuf(raidPtr, scol, srcbuf, RF_EO_MATRIX_DIM - 2, destbuf, pda->numSector);\n\t}\n\tRF_ETIMER_STOP(timer);\n\tRF_ETIMER_EVAL(timer);\n\ttracerec->xor_us += RF_ETIMER_VAL_US(timer);\n}",
          "includes": [
            "#include \"rf_evenodd_dagfuncs.h\"",
            "#include \"rf_evenodd.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dagdegwr.h\"",
            "#include \"rf_dagdegrd.h\"",
            "#include \"rf_dagffwr.h\"",
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_evenodd_dagfuncs.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_configure.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_RegularESubroutine(node, ebuf)\n\tRF_DagNode_t *node;\n\tchar   *ebuf;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) node->params[node->numParams - 1].p;\n\tRF_RaidLayout_t *layoutPtr = (RF_RaidLayout_t *) & raidPtr->Layout;\n\tRF_PhysDiskAddr_t *pda;\n\tint     i, suoffset;\n\tRF_RowCol_t scol;\n\tchar   *srcbuf, *destbuf;\n\tRF_AccTraceEntry_t *tracerec = node->dagHdr->tracerec;\n\tRF_Etimer_t timer;\n\n\tRF_ETIMER_START(timer);\n\tfor (i = 0; i < node->numParams - 2; i += 2) {\n\t\tRF_ASSERT(node->params[i + 1].p != ebuf);\n\t\tpda = (RF_PhysDiskAddr_t *) node->params[i].p;\n\t\tsuoffset = rf_StripeUnitOffset(layoutPtr, pda->startSector);\n\t\tscol = rf_EUCol(layoutPtr, pda->raidAddress);\n\t\tsrcbuf = (char *) node->params[i + 1].p;\n\t\tdestbuf = ebuf + rf_RaidAddressToByte(raidPtr, suoffset);\n\t\trf_e_encToBuf(raidPtr, scol, srcbuf, RF_EO_MATRIX_DIM - 2, destbuf, pda->numSector);\n\t}\n\tRF_ETIMER_STOP(timer);\n\tRF_ETIMER_EVAL(timer);\n\ttracerec->xor_us += RF_ETIMER_VAL_US(timer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_evenodd_dagfuncs.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_configure.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nint \nrf_RegularPEFunc(node)\n\tRF_DagNode_t *node;\n{\n\trf_RegularESubroutine(node, node->results[1]);\n\trf_RegularXorFunc(node);/* does the wakeup here! */\n#if 1\n\treturn (0);\t\t/* XXX This was missing... GO */\n#endif\n}"
  }
]