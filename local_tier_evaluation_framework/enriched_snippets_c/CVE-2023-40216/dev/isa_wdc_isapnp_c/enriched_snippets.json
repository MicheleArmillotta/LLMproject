[
  {
    "function_name": "wdc_isapnp_dma_finish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wdc_isapnp.c",
    "lines": "182-189",
    "snippet": "static void\nwdc_isapnp_dma_finish(scv)\n\tvoid *scv;\n{\n\tstruct wdc_isapnp_softc *sc = scv;\n\n\tisa_dmadone(sc->sc_ic, sc->sc_drq);\n}",
    "includes": [
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isa_dmadone",
          "args": [
            "sc->sc_ic",
            "sc->sc_drq"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "isa_dmadone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/isadma.c",
          "lines": "513-540",
          "snippet": "void\nisa_dmadone(isadev, chan)\n\tstruct device *isadev;\n\tint chan;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tbus_dmamap_t dmam;\n\n\tif (chan < 0 || chan > 7) {\n\t\tpanic(\"isa_dmadone: %s: bogus drq %d\", sc->sc_dev.dv_xname,\n\t\t    chan);\n\t}\n\n\tdmam = sc->sc_dmamaps[chan];\n\n\tisa_dmamask(sc, chan);\n\n\tif (isa_dmafinished(isadev, chan) == 0)\n\t\tprintf(\"%s: isa_dmadone: channel %d not finished\\n\",\n\t\t    sc->sc_dev.dv_xname, chan);\n\n\tbus_dmamap_sync(sc->sc_dmat, dmam,\n\t    (sc->sc_dmareads & (1 << chan)) ? BUS_DMASYNC_POSTREAD :\n\t    BUS_DMASYNC_POSTWRITE);\n\n\tbus_dmamap_unload(sc->sc_dmat, dmam);\n\tsc->sc_dmareads &= ~(1 << chan);\n}",
          "includes": [
            "#include <sys/malloc.h>",
            "#include <dev/isa/isadmareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void isa_dmamask",
            "void *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;",
            "int chan;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/malloc.h>\n#include <dev/isa/isadmareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic inline void isa_dmamask;\nvoid *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;\nint chan;\n\nvoid\nisa_dmadone(isadev, chan)\n\tstruct device *isadev;\n\tint chan;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tbus_dmamap_t dmam;\n\n\tif (chan < 0 || chan > 7) {\n\t\tpanic(\"isa_dmadone: %s: bogus drq %d\", sc->sc_dev.dv_xname,\n\t\t    chan);\n\t}\n\n\tdmam = sc->sc_dmamaps[chan];\n\n\tisa_dmamask(sc, chan);\n\n\tif (isa_dmafinished(isadev, chan) == 0)\n\t\tprintf(\"%s: isa_dmadone: channel %d not finished\\n\",\n\t\t    sc->sc_dev.dv_xname, chan);\n\n\tbus_dmamap_sync(sc->sc_dmat, dmam,\n\t    (sc->sc_dmareads & (1 << chan)) ? BUS_DMASYNC_POSTREAD :\n\t    BUS_DMASYNC_POSTWRITE);\n\n\tbus_dmamap_unload(sc->sc_dmat, dmam);\n\tsc->sc_dmareads &= ~(1 << chan);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void\nwdc_isapnp_dma_finish(scv)\n\tvoid *scv;\n{\n\tstruct wdc_isapnp_softc *sc = scv;\n\n\tisa_dmadone(sc->sc_ic, sc->sc_drq);\n}"
  },
  {
    "function_name": "wdc_isapnp_dma_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wdc_isapnp.c",
    "lines": "169-180",
    "snippet": "static void\nwdc_isapnp_dma_start(scv, buf, size, read)\n\tvoid *scv, *buf;\n\tsize_t size;\n\tint read;\n{\n\tstruct wdc_isapnp_softc *sc = scv;\n\n\tisa_dmastart(sc->sc_ic, sc->sc_drq, buf, size, NULL,\n\t    (read ? DMAMODE_READ : DMAMODE_WRITE) | DMAMODE_DEMAND,\n\t    BUS_DMA_NOWAIT);\n}",
    "includes": [
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isa_dmastart",
          "args": [
            "sc->sc_ic",
            "sc->sc_drq",
            "buf",
            "size",
            "NULL",
            "(read ? DMAMODE_READ : DMAMODE_WRITE) | DMAMODE_DEMAND",
            "BUS_DMA_NOWAIT"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "isa_dmastart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/isadma.c",
          "lines": "288-422",
          "snippet": "int\nisa_dmastart(isadev, chan, addr, nbytes, p, flags, busdmaflags)\n\tstruct device *isadev;\n\tint chan;\n\tvoid *addr;\n\tbus_size_t nbytes;\n\tstruct proc *p;\n\tint flags;\n\tint busdmaflags;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tbus_dmamap_t dmam;\n\tbus_addr_t dmaaddr;\n\tint waport;\n\tint ochan = chan & 3;\n\tint error;\n#ifdef __ISADMA_COMPAT\n\tint compat = busdmaflags & BUS_DMA_BUS1;\n\n\tbusdmaflags &= ~BUS_DMA_BUS1;\n#endif /* __ISADMA_COMPAT */\n\n\tif (chan < 0 || chan > 7) {\n\t\tprintf(\"%s: bogus drq %d\\n\", sc->sc_dev.dv_xname, chan);\n\t\tgoto lose;\n\t}\n\n#ifdef ISADMA_DEBUG\n\tprintf(\"isa_dmastart: drq %d, addr %p, nbytes 0x%lx, p %p, \"\n\t    \"flags 0x%x, dmaflags 0x%x\\n\",\n\t    chan, addr, nbytes, p, flags, busdmaflags);\n#endif\n\n\tif (chan & 4) {\n\t\tif (nbytes > (1 << 17) || nbytes & 1 || (u_long)addr & 1) {\n\t\t\tprintf(\"%s: drq %d, nbytes 0x%lx, addr %p\\n\",\n\t\t\t    sc->sc_dev.dv_xname, chan, nbytes, addr);\n\t\t\tgoto lose;\n\t\t}\n\t} else {\n\t\tif (nbytes > (1 << 16)) {\n\t\t\tprintf(\"%s: drq %d, nbytes 0x%lx\\n\",\n\t\t\t    sc->sc_dev.dv_xname, chan, nbytes);\n\t\t\tgoto lose;\n\t\t}\n\t}\n\n\tdmam = sc->sc_dmamaps[chan];\n\tif (dmam == NULL) {\n#ifdef __ISADMA_COMPAT\n\t\tif (compat)\n\t\t\tdmam = sc->sc_dmamaps[chan] = isadma_dmam[chan];\n\t\telse\n#endif /* __ISADMA_COMPAT */\n\t\tpanic(\"isa_dmastart: no DMA map for chan %d\", chan);\n\t}\n\n\terror = bus_dmamap_load(sc->sc_dmat, dmam, addr, nbytes, p,\n\t    busdmaflags);\n\tif (error)\n\t\treturn (error);\n\n#ifdef ISADMA_DEBUG\n\t__asm(\".globl isa_dmastart_afterload ; isa_dmastart_afterload:\");\n#endif\n\n\tif (flags & DMAMODE_READ) {\n\t\tbus_dmamap_sync(sc->sc_dmat, dmam, BUS_DMASYNC_PREREAD);\n\t\tsc->sc_dmareads |= (1 << chan);\n\t} else {\n\t\tbus_dmamap_sync(sc->sc_dmat, dmam, BUS_DMASYNC_PREWRITE);\n\t\tsc->sc_dmareads &= ~(1 << chan);\n\t}\n\n\tdmaaddr = dmam->dm_segs[0].ds_addr;\n\n#ifdef ISADMA_DEBUG\n\tprintf(\"     dmaaddr 0x%lx\\n\", dmaaddr);\n\n\t__asm(\".globl isa_dmastart_aftersync ; isa_dmastart_aftersync:\");\n#endif\n\n\tsc->sc_dmalength[chan] = nbytes;\n\n\tisa_dmamask(sc, chan);\n\tsc->sc_dmafinished &= ~(1 << chan);\n\n\tif ((chan & 4) == 0) {\n\t\t/* set dma channel mode */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, DMA1_MODE,\n\t\t    ochan | dmamode[flags]);\n\n\t\t/* send start address */\n\t\twaport = DMA1_CHN(ochan);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dmapgh,\n\t\t    dmapageport[0][ochan], (dmaaddr >> 16) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport,\n\t\t    dmaaddr & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport,\n\t\t    (dmaaddr >> 8) & 0xff);\n\n\t\t/* send count */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport + 1,\n\t\t    (--nbytes) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport + 1,\n\t\t    (nbytes >> 8) & 0xff);\n\t} else {\n\t\t/* set dma channel mode */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, DMA2_MODE,\n\t\t    ochan | dmamode[flags]);\n\n\t\t/* send start address */\n\t\twaport = DMA2_CHN(ochan);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dmapgh,\n\t\t    dmapageport[1][ochan], (dmaaddr >> 16) & 0xff);\n\t\tdmaaddr >>= 1;\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport,\n\t\t    dmaaddr & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport,\n\t\t    (dmaaddr >> 8) & 0xff);\n\n\t\t/* send count */\n\t\tnbytes >>= 1;\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport + 2,\n\t\t    (--nbytes) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport + 2,\n\t\t    (nbytes >> 8) & 0xff);\n\t}\n\n\tisa_dmaunmask(sc, chan);\n\treturn (0);\n\n lose:\n\tpanic(\"isa_dmastart\");\n}",
          "includes": [
            "#include <sys/malloc.h>",
            "#include <dev/isa/isadmareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dmapageport[2][4] = {\n\t{0x7, 0x3, 0x1, 0x2},\n\t{0xf, 0xb, 0x9, 0xa}\n};",
            "static u_int8_t dmamode[4] = {\n\tDMA37MD_READ | DMA37MD_SINGLE,\n\tDMA37MD_WRITE | DMA37MD_SINGLE,\n\tDMA37MD_READ | DMA37MD_SINGLE | DMA37MD_LOOP,\n\tDMA37MD_WRITE | DMA37MD_SINGLE | DMA37MD_LOOP\n};",
            "static inline void isa_dmaunmask",
            "static inline void isa_dmamask",
            "void *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;",
            "int chan;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/malloc.h>\n#include <dev/isa/isadmareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int dmapageport[2][4] = {\n\t{0x7, 0x3, 0x1, 0x2},\n\t{0xf, 0xb, 0x9, 0xa}\n};\nstatic u_int8_t dmamode[4] = {\n\tDMA37MD_READ | DMA37MD_SINGLE,\n\tDMA37MD_WRITE | DMA37MD_SINGLE,\n\tDMA37MD_READ | DMA37MD_SINGLE | DMA37MD_LOOP,\n\tDMA37MD_WRITE | DMA37MD_SINGLE | DMA37MD_LOOP\n};\nstatic inline void isa_dmaunmask;\nstatic inline void isa_dmamask;\nvoid *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;\nint chan;\nint flags;\n\nint\nisa_dmastart(isadev, chan, addr, nbytes, p, flags, busdmaflags)\n\tstruct device *isadev;\n\tint chan;\n\tvoid *addr;\n\tbus_size_t nbytes;\n\tstruct proc *p;\n\tint flags;\n\tint busdmaflags;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tbus_dmamap_t dmam;\n\tbus_addr_t dmaaddr;\n\tint waport;\n\tint ochan = chan & 3;\n\tint error;\n#ifdef __ISADMA_COMPAT\n\tint compat = busdmaflags & BUS_DMA_BUS1;\n\n\tbusdmaflags &= ~BUS_DMA_BUS1;\n#endif /* __ISADMA_COMPAT */\n\n\tif (chan < 0 || chan > 7) {\n\t\tprintf(\"%s: bogus drq %d\\n\", sc->sc_dev.dv_xname, chan);\n\t\tgoto lose;\n\t}\n\n#ifdef ISADMA_DEBUG\n\tprintf(\"isa_dmastart: drq %d, addr %p, nbytes 0x%lx, p %p, \"\n\t    \"flags 0x%x, dmaflags 0x%x\\n\",\n\t    chan, addr, nbytes, p, flags, busdmaflags);\n#endif\n\n\tif (chan & 4) {\n\t\tif (nbytes > (1 << 17) || nbytes & 1 || (u_long)addr & 1) {\n\t\t\tprintf(\"%s: drq %d, nbytes 0x%lx, addr %p\\n\",\n\t\t\t    sc->sc_dev.dv_xname, chan, nbytes, addr);\n\t\t\tgoto lose;\n\t\t}\n\t} else {\n\t\tif (nbytes > (1 << 16)) {\n\t\t\tprintf(\"%s: drq %d, nbytes 0x%lx\\n\",\n\t\t\t    sc->sc_dev.dv_xname, chan, nbytes);\n\t\t\tgoto lose;\n\t\t}\n\t}\n\n\tdmam = sc->sc_dmamaps[chan];\n\tif (dmam == NULL) {\n#ifdef __ISADMA_COMPAT\n\t\tif (compat)\n\t\t\tdmam = sc->sc_dmamaps[chan] = isadma_dmam[chan];\n\t\telse\n#endif /* __ISADMA_COMPAT */\n\t\tpanic(\"isa_dmastart: no DMA map for chan %d\", chan);\n\t}\n\n\terror = bus_dmamap_load(sc->sc_dmat, dmam, addr, nbytes, p,\n\t    busdmaflags);\n\tif (error)\n\t\treturn (error);\n\n#ifdef ISADMA_DEBUG\n\t__asm(\".globl isa_dmastart_afterload ; isa_dmastart_afterload:\");\n#endif\n\n\tif (flags & DMAMODE_READ) {\n\t\tbus_dmamap_sync(sc->sc_dmat, dmam, BUS_DMASYNC_PREREAD);\n\t\tsc->sc_dmareads |= (1 << chan);\n\t} else {\n\t\tbus_dmamap_sync(sc->sc_dmat, dmam, BUS_DMASYNC_PREWRITE);\n\t\tsc->sc_dmareads &= ~(1 << chan);\n\t}\n\n\tdmaaddr = dmam->dm_segs[0].ds_addr;\n\n#ifdef ISADMA_DEBUG\n\tprintf(\"     dmaaddr 0x%lx\\n\", dmaaddr);\n\n\t__asm(\".globl isa_dmastart_aftersync ; isa_dmastart_aftersync:\");\n#endif\n\n\tsc->sc_dmalength[chan] = nbytes;\n\n\tisa_dmamask(sc, chan);\n\tsc->sc_dmafinished &= ~(1 << chan);\n\n\tif ((chan & 4) == 0) {\n\t\t/* set dma channel mode */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, DMA1_MODE,\n\t\t    ochan | dmamode[flags]);\n\n\t\t/* send start address */\n\t\twaport = DMA1_CHN(ochan);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dmapgh,\n\t\t    dmapageport[0][ochan], (dmaaddr >> 16) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport,\n\t\t    dmaaddr & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport,\n\t\t    (dmaaddr >> 8) & 0xff);\n\n\t\t/* send count */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport + 1,\n\t\t    (--nbytes) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport + 1,\n\t\t    (nbytes >> 8) & 0xff);\n\t} else {\n\t\t/* set dma channel mode */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, DMA2_MODE,\n\t\t    ochan | dmamode[flags]);\n\n\t\t/* send start address */\n\t\twaport = DMA2_CHN(ochan);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dmapgh,\n\t\t    dmapageport[1][ochan], (dmaaddr >> 16) & 0xff);\n\t\tdmaaddr >>= 1;\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport,\n\t\t    dmaaddr & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport,\n\t\t    (dmaaddr >> 8) & 0xff);\n\n\t\t/* send count */\n\t\tnbytes >>= 1;\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport + 2,\n\t\t    (--nbytes) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport + 2,\n\t\t    (nbytes >> 8) & 0xff);\n\t}\n\n\tisa_dmaunmask(sc, chan);\n\treturn (0);\n\n lose:\n\tpanic(\"isa_dmastart\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void\nwdc_isapnp_dma_start(scv, buf, size, read)\n\tvoid *scv, *buf;\n\tsize_t size;\n\tint read;\n{\n\tstruct wdc_isapnp_softc *sc = scv;\n\n\tisa_dmastart(sc->sc_ic, sc->sc_drq, buf, size, NULL,\n\t    (read ? DMAMODE_READ : DMAMODE_WRITE) | DMAMODE_DEMAND,\n\t    BUS_DMA_NOWAIT);\n}"
  },
  {
    "function_name": "wdc_isapnp_dma_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wdc_isapnp.c",
    "lines": "156-167",
    "snippet": "static void\nwdc_isapnp_dma_setup(sc)\n\tstruct wdc_isapnp_softc *sc;\n{\n\n\tif (isa_dmamap_create(sc->sc_ic, sc->sc_drq,\n\t    MAXPHYS, BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\tprintf(\"%s: can't create map for drq %d\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, sc->sc_drq);\n\t\tsc->sc_wdcdev.cap &= ~WDC_CAPABILITY_DMA;\n\t}\n}",
    "includes": [
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: can't create map for drq %d\\n\"",
            "sc->sc_wdcdev.sc_dev.dv_xname",
            "sc->sc_drq"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "isa_dmamap_create",
          "args": [
            "sc->sc_ic",
            "sc->sc_drq",
            "MAXPHYS",
            "BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "isa_dmamap_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/isadma.c",
          "lines": "220-255",
          "snippet": "int\nisa_dmamap_create(isadev, chan, size, flags)\n\tstruct device *isadev;\n\tint chan;\n\tbus_size_t size;\n\tint flags;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tbus_size_t maxsize;\n\n\tif (chan < 0 || chan > 7) {\n\t\tprintf(\"%s: bogus drq %d\\n\", sc->sc_dev.dv_xname, chan);\n\t\tgoto lose;\n\t}\n\n\tif (chan & 4)\n\t\tmaxsize = (1 << 17);\n\telse\n\t\tmaxsize = (1 << 16);\n\n\tif (size > maxsize)\n\t\treturn (EINVAL);\n\n\tif (ISA_DRQ_ISFREE(sc, chan) == 0) {\n\t\tprintf(\"%s: drq %d is not free\\n\", sc->sc_dev.dv_xname, chan);\n\t\tgoto lose;\n\t}\n\n\tISA_DRQ_ALLOC(sc, chan);\n\n\treturn (bus_dmamap_create(sc->sc_dmat, size, 1, size, maxsize,\n\t    flags, &sc->sc_dmamaps[chan]));\n\n lose:\n\tpanic(\"isa_dmamap_create\");\n}",
          "includes": [
            "#include <sys/malloc.h>",
            "#include <dev/isa/isadmareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;",
            "int chan;",
            "size_t size;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/malloc.h>\n#include <dev/isa/isadmareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;\nint chan;\nsize_t size;\nint flags;\n\nint\nisa_dmamap_create(isadev, chan, size, flags)\n\tstruct device *isadev;\n\tint chan;\n\tbus_size_t size;\n\tint flags;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tbus_size_t maxsize;\n\n\tif (chan < 0 || chan > 7) {\n\t\tprintf(\"%s: bogus drq %d\\n\", sc->sc_dev.dv_xname, chan);\n\t\tgoto lose;\n\t}\n\n\tif (chan & 4)\n\t\tmaxsize = (1 << 17);\n\telse\n\t\tmaxsize = (1 << 16);\n\n\tif (size > maxsize)\n\t\treturn (EINVAL);\n\n\tif (ISA_DRQ_ISFREE(sc, chan) == 0) {\n\t\tprintf(\"%s: drq %d is not free\\n\", sc->sc_dev.dv_xname, chan);\n\t\tgoto lose;\n\t}\n\n\tISA_DRQ_ALLOC(sc, chan);\n\n\treturn (bus_dmamap_create(sc->sc_dmat, size, 1, size, maxsize,\n\t    flags, &sc->sc_dmamaps[chan]));\n\n lose:\n\tpanic(\"isa_dmamap_create\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void\nwdc_isapnp_dma_setup(sc)\n\tstruct wdc_isapnp_softc *sc;\n{\n\n\tif (isa_dmamap_create(sc->sc_ic, sc->sc_drq,\n\t    MAXPHYS, BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\tprintf(\"%s: can't create map for drq %d\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, sc->sc_drq);\n\t\tsc->sc_wdcdev.cap &= ~WDC_CAPABILITY_DMA;\n\t}\n}"
  },
  {
    "function_name": "wdc_isapnp_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wdc_isapnp.c",
    "lines": "95-153",
    "snippet": "void\nwdc_isapnp_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct wdc_isapnp_softc *sc = (void *)self;\n\tstruct isa_attach_args *ipa = aux;\n\n\n\tsc->wdc_channel.cmd_iot = ipa->ia_iot;\n\tsc->wdc_channel.ctl_iot = ipa->ia_iot;\n\n\t/*\n\t * An IDE controller can feed us the regions in any order. Pass\n\t * them along with the 8-byte region in sc_ad.ioh, and the other\n\t * (2 byte) region in auxioh.\n\t */\n\tif (ipa->ipa_io[0].length == 8) {\n\t\tsc->wdc_channel.cmd_ioh = ipa->ipa_io[0].h;\n\t\tsc->wdc_channel.ctl_ioh = ipa->ipa_io[1].h;\n\t} else {\n\t\tsc->wdc_channel.cmd_ioh = ipa->ipa_io[1].h;\n\t\tsc->wdc_channel.ctl_ioh = ipa->ipa_io[0].h;\n\t}\n\tsc->wdc_channel.data32iot = sc->wdc_channel.cmd_iot;\n\tsc->wdc_channel.data32ioh = sc->wdc_channel.cmd_ioh;\n\n\tsc->sc_ic = ipa->ia_ic;\n\tsc->sc_ih = isa_intr_establish(ipa->ia_ic, ipa->ipa_irq[0].num,\n\t    ipa->ipa_irq[0].type, IPL_BIO, wdcintr, &sc->wdc_channel,\n\t    sc->sc_wdcdev.sc_dev.dv_xname);\n\n#ifdef notyet\n\tif (ipa->ipa_ndrq > 0) {\n\t\tsc->sc_drq = ipa->ipa_drq[0].num;\n\n\t\tsc->sc_ad.cap |= WDC_CAPABILITY_DMA;\n\t\tsc->sc_ad.dma_start = &wdc_isapnp_dma_start;\n\t\tsc->sc_ad.dma_finish = &wdc_isapnp_dma_finish;\n\t\twdc_isapnp_dma_setup(sc);\n\t}\n#endif\n\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32;\n\tsc->sc_wdcdev.PIO_cap = 0;\n\tsc->wdc_chanptr = &sc->wdc_channel;\n\tsc->sc_wdcdev.channels = &sc->wdc_chanptr;\n\tsc->sc_wdcdev.nchannels = 1;\n\tsc->wdc_channel.channel = 0;\n\tsc->wdc_channel.wdc = &sc->sc_wdcdev;\n\tsc->wdc_channel.ch_queue = malloc(sizeof(struct channel_queue),\n\t    M_DEVBUF, M_NOWAIT);\n\tif (sc->wdc_channel.ch_queue == NULL) {\n\t\tprintf(\": can't allocate memory for command queue\\n\");\n\t\treturn;\n\t}\n\n\tprintf(\"\\n\");\n\twdcattach(&sc->wdc_channel);\n}",
    "includes": [
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\twdc_isapnp_attach"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wdcattach",
          "args": [
            "&sc->wdc_channel"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "wdcattach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "469-657",
          "snippet": "void\nwdcattach(chp)\n\tstruct channel_softc *chp;\n{\n\tint channel_flags, ctrl_flags, i;\n#ifndef __OpenBSD__\n\tint error;\n#endif\n\tstruct ata_atapi_attach aa_link;\n\tstruct ataparams params;\n\tstatic int inited = 0;\n\textern int cold;\n\n\tif (!cold)\n\t\tat_poll = AT_WAIT;\n\n#ifndef __OpenBSD__\n\tif ((error = wdc_addref(chp)) != 0) {\n\t\tprintf(\"%s: unable to enable controller\\n\",\n\t\t    chp->wdc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n#endif\n\tif (!chp->_vtbl)\n\t\tchp->_vtbl = &wdc_default_vtbl;\n\n\tif (wdcprobe(chp) == 0) {\n\t\t/* If no drives, abort attach here. */\n#ifndef __OpenBSD__\n\t\twdc_delref(chp);\n#endif\n\t\treturn;\n\t}\n\n\t/* init list only once */\n\tif (inited == 0) {\n\t\tLIST_INIT(&xfer_free_list);\n\t\tinited++;\n\t}\n\tTAILQ_INIT(&chp->ch_queue->sc_xfer);\n\t\n\tfor (i = 0; i < 2; i++) {\n\t\tchp->ch_drive[i].chnl_softc = chp;\n\t\tchp->ch_drive[i].drive = i;\n\t\t/* If controller can't do 16bit flag the drives as 32bit */\n\t\tif ((chp->wdc->cap &\n\t\t    (WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32)) ==\n\t\t    WDC_CAPABILITY_DATA32)\n\t\t\tchp->ch_drive[i].drive_flags |= DRIVE_CAP32;\n\t\tif ((chp->ch_drive[i].drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\n\t\tif (i == 1 && ((chp->ch_drive[0].drive_flags & DRIVE) == 0))\n\t\t\tchp->ch_flags |= WDCF_ONESLAVE;\n\n\t\t/* Issue a IDENTIFY command, to try to detect slave ghost */\n\t\tif (ata_get_params(&chp->ch_drive[i], at_poll, &params) ==\n\t\t    CMD_OK) {\n\t\t\t/* If IDENTIFY succeded, this is not an OLD ctrl */\n\t\t\tchp->ch_drive[0].drive_flags &= ~DRIVE_OLD;\n\t\t\tchp->ch_drive[1].drive_flags &= ~DRIVE_OLD;\n\t\t} else {\n\t\t\tchp->ch_drive[i].drive_flags &=\n\t\t\t    ~(DRIVE_ATA | DRIVE_ATAPI);\n\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: IDENTIFY failed\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\tif ((chp->ch_drive[i].drive_flags & DRIVE_OLD) == 0)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Pre-ATA drive ?\n\t\t\t * Test registers writability (Error register not\n\t\t\t * writable, but cyllo is), then try an ATA command.\n\t\t\t */\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (i << 4));\n\t\t\tdelay(10);\n\t\t\tCHP_WRITE_REG(chp, wdr_features, 0x58);\n\t\t\tCHP_WRITE_REG(chp, wdr_cyl_lo, 0xa5);\n\t\t\tif ((CHP_READ_REG(chp, wdr_error) == 0x58) ||\n\t\t\t    (CHP_READ_REG(chp, wdr_cyl_lo) != 0xa5)) {\n\t\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: register \"\n\t\t\t\t    \"writability failed\\n\",\n\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\t\t    chp->ch_drive[i].drive_flags &= ~DRIVE_OLD;\n\t\t\t}\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (i << 4));\n\t\t\tdelay(100);\n\t\t\tif (wait_for_ready(chp, 10000) != 0) {\n\t\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: not ready\\n\",\n\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\t\tchp->ch_drive[i].drive_flags &= ~DRIVE_OLD;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tCHP_WRITE_REG(chp, wdr_command, WDCC_RECAL);\n\t\t\tif (wait_for_ready(chp, 10000) != 0) {\n\t\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: WDCC_RECAL failed\\n\",\n\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\t\tchp->ch_drive[i].drive_flags &= ~DRIVE_OLD;\n\t\t\t}\n\t\t}\n\t}\n\tctrl_flags = chp->wdc->sc_dev.dv_cfdata->cf_flags;\n\tchannel_flags = (ctrl_flags >> (NBBY * chp->channel)) & 0xff;\n\n\tWDCDEBUG_PRINT((\"wdcattach: ch_drive_flags 0x%x 0x%x\\n\",\n\t    chp->ch_drive[0].drive_flags, chp->ch_drive[1].drive_flags),\n\t    DEBUG_PROBE);\n\n\t/* If no drives, abort here */\n\tif ((chp->ch_drive[0].drive_flags & DRIVE) == 0 &&\n\t    (chp->ch_drive[1].drive_flags & DRIVE) == 0)\n\t\treturn;\n\n\t/*\n\t * Attach an ATAPI bus, if needed.\n\t */\n\tif ((chp->ch_drive[0].drive_flags & DRIVE_ATAPI) ||\n\t    (chp->ch_drive[1].drive_flags & DRIVE_ATAPI)) {\n#if NATAPISCSI > 0\n\t\twdc_atapibus_attach(chp);\n#else\n\t\t/*\n\t\t * Fills in a fake aa_link and call config_found, so that\n\t\t * the config machinery will print\n\t\t * \"atapibus at xxx not configured\"\n\t\t */\n\t\tbzero(&aa_link, sizeof(struct ata_atapi_attach));\n\t\taa_link.aa_type = T_ATAPI;\n\t\taa_link.aa_channel = chp->channel;\n\t\taa_link.aa_openings = 1;\n\t\taa_link.aa_drv_data = 0;\n\t\taa_link.aa_bus_private = NULL;\n\t\t(void)config_found(&chp->wdc->sc_dev, (void *)&aa_link,\n\t\t    atapi_print);\n#endif\n\t}\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif ((chp->ch_drive[i].drive_flags &\n\t\t    (DRIVE_ATA | DRIVE_OLD)) == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tbzero(&aa_link, sizeof(struct ata_atapi_attach));\n\t\taa_link.aa_type = T_ATA;\n\t\taa_link.aa_channel = chp->channel;\n\t\taa_link.aa_openings = 1;\n\t\taa_link.aa_drv_data = &chp->ch_drive[i];\n\t\tconfig_found(&chp->wdc->sc_dev, (void *)&aa_link, wdprint);\n\t}\n\n\t/*\n\t * reset drive_flags for unnatached devices, reset state for attached\n\t *  ones\n\t */\n\tfor (i = 0; i < 2; i++) {\n\t\tif (chp->ch_drive[i].drive_name[0] == 0)\n\t\t\tchp->ch_drive[i].drive_flags = 0;\n\t\telse\n\t\t\tchp->ch_drive[i].state = 0;\n\t}\n\n\t/*\n\t * Reset channel. The probe, with some combinations of ATA/ATAPI\n\t * devices keep it in a mostly working, but strange state (with busy\n\t * led on)\n\t */\n\tif ((chp->wdc->cap & WDC_CAPABILITY_NO_EXTRA_RESETS) == 0) {\n\t\twdcreset(chp, VERBOSE);\n\t\t/*\n\t\t * Read status registers to avoid spurious interrupts.\n\t\t */\n\t\tfor (i = 1; i >= 0; i--) {\n\t\t\tif (chp->ch_drive[i].drive_flags & DRIVE) {\n\t\t\t\tCHP_WRITE_REG(chp,\n\t\t\t\t    wdr_sdh, WDSD_IBM | (i << 4));\n\t\t\t\tif (wait_for_unbusy(chp, 10000) < 0)\n\t\t\t\t\tprintf(\"%s:%d:%d: device busy\\n\",\n\t\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t\t    chp->channel, i);\n\t\t\t}\n\t\t}\n\t}\n#ifndef __OpenBSD__\n\twdc_delref(chp);\n#endif\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_PROBE  0x10"
          ],
          "globals_used": [
            "int   wdprint",
            "int at_poll = AT_POLL;",
            "struct channel_softc_vtbl wdc_default_vtbl = {\n\twdc_default_read_reg,\n\twdc_default_write_reg,\n\twdc_default_read_raw_multi_2,\n\twdc_default_write_raw_multi_2,\n\twdc_default_read_raw_multi_4,\n\twdc_default_write_raw_multi_4\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_PROBE  0x10\n\nint   wdprint;\nint at_poll = AT_POLL;\nstruct channel_softc_vtbl wdc_default_vtbl = {\n\twdc_default_read_reg,\n\twdc_default_write_reg,\n\twdc_default_read_raw_multi_2,\n\twdc_default_write_raw_multi_2,\n\twdc_default_read_raw_multi_4,\n\twdc_default_write_raw_multi_4\n};\n\nvoid\nwdcattach(chp)\n\tstruct channel_softc *chp;\n{\n\tint channel_flags, ctrl_flags, i;\n#ifndef __OpenBSD__\n\tint error;\n#endif\n\tstruct ata_atapi_attach aa_link;\n\tstruct ataparams params;\n\tstatic int inited = 0;\n\textern int cold;\n\n\tif (!cold)\n\t\tat_poll = AT_WAIT;\n\n#ifndef __OpenBSD__\n\tif ((error = wdc_addref(chp)) != 0) {\n\t\tprintf(\"%s: unable to enable controller\\n\",\n\t\t    chp->wdc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n#endif\n\tif (!chp->_vtbl)\n\t\tchp->_vtbl = &wdc_default_vtbl;\n\n\tif (wdcprobe(chp) == 0) {\n\t\t/* If no drives, abort attach here. */\n#ifndef __OpenBSD__\n\t\twdc_delref(chp);\n#endif\n\t\treturn;\n\t}\n\n\t/* init list only once */\n\tif (inited == 0) {\n\t\tLIST_INIT(&xfer_free_list);\n\t\tinited++;\n\t}\n\tTAILQ_INIT(&chp->ch_queue->sc_xfer);\n\t\n\tfor (i = 0; i < 2; i++) {\n\t\tchp->ch_drive[i].chnl_softc = chp;\n\t\tchp->ch_drive[i].drive = i;\n\t\t/* If controller can't do 16bit flag the drives as 32bit */\n\t\tif ((chp->wdc->cap &\n\t\t    (WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32)) ==\n\t\t    WDC_CAPABILITY_DATA32)\n\t\t\tchp->ch_drive[i].drive_flags |= DRIVE_CAP32;\n\t\tif ((chp->ch_drive[i].drive_flags & DRIVE) == 0)\n\t\t\tcontinue;\n\n\t\tif (i == 1 && ((chp->ch_drive[0].drive_flags & DRIVE) == 0))\n\t\t\tchp->ch_flags |= WDCF_ONESLAVE;\n\n\t\t/* Issue a IDENTIFY command, to try to detect slave ghost */\n\t\tif (ata_get_params(&chp->ch_drive[i], at_poll, &params) ==\n\t\t    CMD_OK) {\n\t\t\t/* If IDENTIFY succeded, this is not an OLD ctrl */\n\t\t\tchp->ch_drive[0].drive_flags &= ~DRIVE_OLD;\n\t\t\tchp->ch_drive[1].drive_flags &= ~DRIVE_OLD;\n\t\t} else {\n\t\t\tchp->ch_drive[i].drive_flags &=\n\t\t\t    ~(DRIVE_ATA | DRIVE_ATAPI);\n\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: IDENTIFY failed\\n\",\n\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\tif ((chp->ch_drive[i].drive_flags & DRIVE_OLD) == 0)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Pre-ATA drive ?\n\t\t\t * Test registers writability (Error register not\n\t\t\t * writable, but cyllo is), then try an ATA command.\n\t\t\t */\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (i << 4));\n\t\t\tdelay(10);\n\t\t\tCHP_WRITE_REG(chp, wdr_features, 0x58);\n\t\t\tCHP_WRITE_REG(chp, wdr_cyl_lo, 0xa5);\n\t\t\tif ((CHP_READ_REG(chp, wdr_error) == 0x58) ||\n\t\t\t    (CHP_READ_REG(chp, wdr_cyl_lo) != 0xa5)) {\n\t\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: register \"\n\t\t\t\t    \"writability failed\\n\",\n\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\t\t    chp->ch_drive[i].drive_flags &= ~DRIVE_OLD;\n\t\t\t}\n\t\t\tCHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (i << 4));\n\t\t\tdelay(100);\n\t\t\tif (wait_for_ready(chp, 10000) != 0) {\n\t\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: not ready\\n\",\n\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\t\tchp->ch_drive[i].drive_flags &= ~DRIVE_OLD;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tCHP_WRITE_REG(chp, wdr_command, WDCC_RECAL);\n\t\t\tif (wait_for_ready(chp, 10000) != 0) {\n\t\t\t\tWDCDEBUG_PRINT((\"%s:%d:%d: WDCC_RECAL failed\\n\",\n\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t    chp->channel, i), DEBUG_PROBE);\n\t\t\t\tchp->ch_drive[i].drive_flags &= ~DRIVE_OLD;\n\t\t\t}\n\t\t}\n\t}\n\tctrl_flags = chp->wdc->sc_dev.dv_cfdata->cf_flags;\n\tchannel_flags = (ctrl_flags >> (NBBY * chp->channel)) & 0xff;\n\n\tWDCDEBUG_PRINT((\"wdcattach: ch_drive_flags 0x%x 0x%x\\n\",\n\t    chp->ch_drive[0].drive_flags, chp->ch_drive[1].drive_flags),\n\t    DEBUG_PROBE);\n\n\t/* If no drives, abort here */\n\tif ((chp->ch_drive[0].drive_flags & DRIVE) == 0 &&\n\t    (chp->ch_drive[1].drive_flags & DRIVE) == 0)\n\t\treturn;\n\n\t/*\n\t * Attach an ATAPI bus, if needed.\n\t */\n\tif ((chp->ch_drive[0].drive_flags & DRIVE_ATAPI) ||\n\t    (chp->ch_drive[1].drive_flags & DRIVE_ATAPI)) {\n#if NATAPISCSI > 0\n\t\twdc_atapibus_attach(chp);\n#else\n\t\t/*\n\t\t * Fills in a fake aa_link and call config_found, so that\n\t\t * the config machinery will print\n\t\t * \"atapibus at xxx not configured\"\n\t\t */\n\t\tbzero(&aa_link, sizeof(struct ata_atapi_attach));\n\t\taa_link.aa_type = T_ATAPI;\n\t\taa_link.aa_channel = chp->channel;\n\t\taa_link.aa_openings = 1;\n\t\taa_link.aa_drv_data = 0;\n\t\taa_link.aa_bus_private = NULL;\n\t\t(void)config_found(&chp->wdc->sc_dev, (void *)&aa_link,\n\t\t    atapi_print);\n#endif\n\t}\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif ((chp->ch_drive[i].drive_flags &\n\t\t    (DRIVE_ATA | DRIVE_OLD)) == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tbzero(&aa_link, sizeof(struct ata_atapi_attach));\n\t\taa_link.aa_type = T_ATA;\n\t\taa_link.aa_channel = chp->channel;\n\t\taa_link.aa_openings = 1;\n\t\taa_link.aa_drv_data = &chp->ch_drive[i];\n\t\tconfig_found(&chp->wdc->sc_dev, (void *)&aa_link, wdprint);\n\t}\n\n\t/*\n\t * reset drive_flags for unnatached devices, reset state for attached\n\t *  ones\n\t */\n\tfor (i = 0; i < 2; i++) {\n\t\tif (chp->ch_drive[i].drive_name[0] == 0)\n\t\t\tchp->ch_drive[i].drive_flags = 0;\n\t\telse\n\t\t\tchp->ch_drive[i].state = 0;\n\t}\n\n\t/*\n\t * Reset channel. The probe, with some combinations of ATA/ATAPI\n\t * devices keep it in a mostly working, but strange state (with busy\n\t * led on)\n\t */\n\tif ((chp->wdc->cap & WDC_CAPABILITY_NO_EXTRA_RESETS) == 0) {\n\t\twdcreset(chp, VERBOSE);\n\t\t/*\n\t\t * Read status registers to avoid spurious interrupts.\n\t\t */\n\t\tfor (i = 1; i >= 0; i--) {\n\t\t\tif (chp->ch_drive[i].drive_flags & DRIVE) {\n\t\t\t\tCHP_WRITE_REG(chp,\n\t\t\t\t    wdr_sdh, WDSD_IBM | (i << 4));\n\t\t\t\tif (wait_for_unbusy(chp, 10000) < 0)\n\t\t\t\t\tprintf(\"%s:%d:%d: device busy\\n\",\n\t\t\t\t\t    chp->wdc->sc_dev.dv_xname,\n\t\t\t\t\t    chp->channel, i);\n\t\t\t}\n\t\t}\n\t}\n#ifndef __OpenBSD__\n\twdc_delref(chp);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct channel_queue)",
            "M_DEVBUF",
            "M_NOWAIT"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wdc_isapnp_dma_setup",
          "args": [
            "sc"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_isapnp_dma_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wdc_isapnp.c",
          "lines": "156-167",
          "snippet": "static void\nwdc_isapnp_dma_setup(sc)\n\tstruct wdc_isapnp_softc *sc;\n{\n\n\tif (isa_dmamap_create(sc->sc_ic, sc->sc_drq,\n\t    MAXPHYS, BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\tprintf(\"%s: can't create map for drq %d\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, sc->sc_drq);\n\t\tsc->sc_wdcdev.cap &= ~WDC_CAPABILITY_DMA;\n\t}\n}",
          "includes": [
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void\nwdc_isapnp_dma_setup(sc)\n\tstruct wdc_isapnp_softc *sc;\n{\n\n\tif (isa_dmamap_create(sc->sc_ic, sc->sc_drq,\n\t    MAXPHYS, BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\tprintf(\"%s: can't create map for drq %d\\n\",\n\t\t    sc->sc_wdcdev.sc_dev.dv_xname, sc->sc_drq);\n\t\tsc->sc_wdcdev.cap &= ~WDC_CAPABILITY_DMA;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "isa_intr_establish",
          "args": [
            "ipa->ia_ic",
            "ipa->ipa_irq[0].num",
            "ipa->ipa_irq[0].type",
            "IPL_BIO",
            "wdcintr",
            "&sc->wdc_channel",
            "sc->sc_wdcdev.sc_dev.dv_xname"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\twdc_isapnp_attach;\n\nvoid\nwdc_isapnp_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct wdc_isapnp_softc *sc = (void *)self;\n\tstruct isa_attach_args *ipa = aux;\n\n\n\tsc->wdc_channel.cmd_iot = ipa->ia_iot;\n\tsc->wdc_channel.ctl_iot = ipa->ia_iot;\n\n\t/*\n\t * An IDE controller can feed us the regions in any order. Pass\n\t * them along with the 8-byte region in sc_ad.ioh, and the other\n\t * (2 byte) region in auxioh.\n\t */\n\tif (ipa->ipa_io[0].length == 8) {\n\t\tsc->wdc_channel.cmd_ioh = ipa->ipa_io[0].h;\n\t\tsc->wdc_channel.ctl_ioh = ipa->ipa_io[1].h;\n\t} else {\n\t\tsc->wdc_channel.cmd_ioh = ipa->ipa_io[1].h;\n\t\tsc->wdc_channel.ctl_ioh = ipa->ipa_io[0].h;\n\t}\n\tsc->wdc_channel.data32iot = sc->wdc_channel.cmd_iot;\n\tsc->wdc_channel.data32ioh = sc->wdc_channel.cmd_ioh;\n\n\tsc->sc_ic = ipa->ia_ic;\n\tsc->sc_ih = isa_intr_establish(ipa->ia_ic, ipa->ipa_irq[0].num,\n\t    ipa->ipa_irq[0].type, IPL_BIO, wdcintr, &sc->wdc_channel,\n\t    sc->sc_wdcdev.sc_dev.dv_xname);\n\n#ifdef notyet\n\tif (ipa->ipa_ndrq > 0) {\n\t\tsc->sc_drq = ipa->ipa_drq[0].num;\n\n\t\tsc->sc_ad.cap |= WDC_CAPABILITY_DMA;\n\t\tsc->sc_ad.dma_start = &wdc_isapnp_dma_start;\n\t\tsc->sc_ad.dma_finish = &wdc_isapnp_dma_finish;\n\t\twdc_isapnp_dma_setup(sc);\n\t}\n#endif\n\tsc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32;\n\tsc->sc_wdcdev.PIO_cap = 0;\n\tsc->wdc_chanptr = &sc->wdc_channel;\n\tsc->sc_wdcdev.channels = &sc->wdc_chanptr;\n\tsc->sc_wdcdev.nchannels = 1;\n\tsc->wdc_channel.channel = 0;\n\tsc->wdc_channel.wdc = &sc->sc_wdcdev;\n\tsc->wdc_channel.ch_queue = malloc(sizeof(struct channel_queue),\n\t    M_DEVBUF, M_NOWAIT);\n\tif (sc->wdc_channel.ch_queue == NULL) {\n\t\tprintf(\": can't allocate memory for command queue\\n\");\n\t\treturn;\n\t}\n\n\tprintf(\"\\n\");\n\twdcattach(&sc->wdc_channel);\n}"
  },
  {
    "function_name": "wdc_isapnp_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/wdc_isapnp.c",
    "lines": "77-93",
    "snippet": "int\nwdc_isapnp_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match;\n\tvoid *aux;\n{\n\tstruct isa_attach_args *ipa = aux;\n\n\tif (ipa->ipa_nio != 2 ||\n\t    ipa->ipa_nmem != 0 ||\n\t    ipa->ipa_nmem32 != 0 ||\n\t    ipa->ipa_nirq != 1 ||\n\t    ipa->ipa_ndrq > 1)\n\t\treturn 0;\n\n\treturn (1);\n}",
    "includes": [
      "#include <dev/ic/wdcvar.h>",
      "#include <dev/ic/wdcreg.h>",
      "#include <dev/ata/atavar.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/malloc.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\twdc_isapnp_match"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atavar.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\twdc_isapnp_match;\n\nint\nwdc_isapnp_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match;\n\tvoid *aux;\n{\n\tstruct isa_attach_args *ipa = aux;\n\n\tif (ipa->ipa_nio != 2 ||\n\t    ipa->ipa_nmem != 0 ||\n\t    ipa->ipa_nmem32 != 0 ||\n\t    ipa->ipa_nirq != 1 ||\n\t    ipa->ipa_ndrq > 1)\n\t\treturn 0;\n\n\treturn (1);\n}"
  }
]