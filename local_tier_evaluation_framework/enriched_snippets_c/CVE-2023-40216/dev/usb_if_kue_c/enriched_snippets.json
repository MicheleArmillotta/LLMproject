[
  {
    "function_name": "kue_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
    "lines": "1525-1534",
    "snippet": "Static void\nkue_shutdown(dev)\n\tdevice_t\t\tdev;\n{\n\tstruct kue_softc\t*sc;\n\n\tsc = device_get_softc(dev);\n\n\tkue_stop(sc);\n}",
    "includes": [
      "#include <dev/usb/kue_fw.h>",
      "#include <dev/usb/if_kuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "kue_tx_list_init\t__P((struct kue_softc *));",
      "Static int",
      "kue_rx_list_init\t__P((struct kue_softc *));",
      "Static int",
      "Static int",
      "Static int",
      "kue_open_pipes\t__P((struct kue_softc *));",
      "Static void",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "kue_stop\t\t__P((struct kue_softc *));",
      "Static void",
      "Static void",
      "kue_setmulti\t__P((struct kue_softc *));",
      "Static void",
      "kue_reset\t\t__P((struct kue_softc *));",
      "Static int",
      "kue_is_warm\t\t__P((struct kue_softc *));",
      "Static int",
      "kue_load_fw\t\t__P((struct kue_softc *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kue_stop",
          "args": [
            "sc"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "kue_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
          "lines": "1437-1518",
          "snippet": "Static void\nkue_stop(sc)\n\tstruct kue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\tifp = GET_IFP(sc);\n\tifp->if_timer = 0;\n\n\t/* Stop transfers. */\n\tif (sc->kue_ep[KUE_ENDPT_RX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->kue_ep[KUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort rx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->kue_ep[KUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close rx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->kue_ep[KUE_ENDPT_RX] = NULL;\n\t}\n\n\tif (sc->kue_ep[KUE_ENDPT_TX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->kue_ep[KUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->kue_ep[KUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->kue_ep[KUE_ENDPT_TX] = NULL;\n\t}\n\n\tif (sc->kue_ep[KUE_ENDPT_INTR] != NULL) {\n\t\terr = usbd_abort_pipe(sc->kue_ep[KUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->kue_ep[KUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->kue_ep[KUE_ENDPT_INTR] = NULL;\n\t}\n\n\t/* Free RX resources. */\n\tfor (i = 0; i < KUE_RX_LIST_CNT; i++) {\n\t\tif (sc->kue_cdata.kue_rx_chain[i].kue_mbuf != NULL) {\n\t\t\tm_freem(sc->kue_cdata.kue_rx_chain[i].kue_mbuf);\n\t\t\tsc->kue_cdata.kue_rx_chain[i].kue_mbuf = NULL;\n\t\t}\n\t\tif (sc->kue_cdata.kue_rx_chain[i].kue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->kue_cdata.kue_rx_chain[i].kue_xfer);\n\t\t\tsc->kue_cdata.kue_rx_chain[i].kue_xfer = NULL;\n\t\t}\n\t}\n\n\t/* Free TX resources. */\n\tfor (i = 0; i < KUE_TX_LIST_CNT; i++) {\n\t\tif (sc->kue_cdata.kue_tx_chain[i].kue_mbuf != NULL) {\n\t\t\tm_freem(sc->kue_cdata.kue_tx_chain[i].kue_mbuf);\n\t\t\tsc->kue_cdata.kue_tx_chain[i].kue_mbuf = NULL;\n\t\t}\n\t\tif (sc->kue_cdata.kue_tx_chain[i].kue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->kue_cdata.kue_tx_chain[i].kue_xfer);\n\t\t\tsc->kue_cdata.kue_tx_chain[i].kue_xfer = NULL;\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n}",
          "includes": [
            "#include <dev/usb/kue_fw.h>",
            "#include <dev/usb/if_kuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "kue_tx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "kue_rx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "Static int",
            "Static int",
            "kue_open_pipes\t__P((struct kue_softc *));",
            "Static void",
            "kue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "kue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "kue_start\t\t__P((struct ifnet *));",
            "Static int",
            "Static void",
            "Static void",
            "kue_stop\t\t__P((struct kue_softc *));",
            "Static void",
            "kue_watchdog\t\t__P((struct ifnet *));",
            "Static void",
            "kue_setmulti\t__P((struct kue_softc *));",
            "Static void",
            "kue_reset\t\t__P((struct kue_softc *));",
            "Static usbd_status",
            "Static usbd_status",
            "Static int",
            "kue_is_warm\t\t__P((struct kue_softc *));",
            "Static int",
            "kue_load_fw\t\t__P((struct kue_softc *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nStatic int;\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nkue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nkue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nkue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nkue_watchdog\t\t__P((struct ifnet *));\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic usbd_status;\nStatic usbd_status;\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic void\nkue_stop(sc)\n\tstruct kue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\tifp = GET_IFP(sc);\n\tifp->if_timer = 0;\n\n\t/* Stop transfers. */\n\tif (sc->kue_ep[KUE_ENDPT_RX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->kue_ep[KUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort rx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->kue_ep[KUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close rx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->kue_ep[KUE_ENDPT_RX] = NULL;\n\t}\n\n\tif (sc->kue_ep[KUE_ENDPT_TX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->kue_ep[KUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->kue_ep[KUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->kue_ep[KUE_ENDPT_TX] = NULL;\n\t}\n\n\tif (sc->kue_ep[KUE_ENDPT_INTR] != NULL) {\n\t\terr = usbd_abort_pipe(sc->kue_ep[KUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->kue_ep[KUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->kue_ep[KUE_ENDPT_INTR] = NULL;\n\t}\n\n\t/* Free RX resources. */\n\tfor (i = 0; i < KUE_RX_LIST_CNT; i++) {\n\t\tif (sc->kue_cdata.kue_rx_chain[i].kue_mbuf != NULL) {\n\t\t\tm_freem(sc->kue_cdata.kue_rx_chain[i].kue_mbuf);\n\t\t\tsc->kue_cdata.kue_rx_chain[i].kue_mbuf = NULL;\n\t\t}\n\t\tif (sc->kue_cdata.kue_rx_chain[i].kue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->kue_cdata.kue_rx_chain[i].kue_xfer);\n\t\t\tsc->kue_cdata.kue_rx_chain[i].kue_xfer = NULL;\n\t\t}\n\t}\n\n\t/* Free TX resources. */\n\tfor (i = 0; i < KUE_TX_LIST_CNT; i++) {\n\t\tif (sc->kue_cdata.kue_tx_chain[i].kue_mbuf != NULL) {\n\t\t\tm_freem(sc->kue_cdata.kue_tx_chain[i].kue_mbuf);\n\t\t\tsc->kue_cdata.kue_tx_chain[i].kue_mbuf = NULL;\n\t\t}\n\t\tif (sc->kue_cdata.kue_tx_chain[i].kue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->kue_cdata.kue_tx_chain[i].kue_xfer);\n\t\t\tsc->kue_cdata.kue_tx_chain[i].kue_xfer = NULL;\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "device_get_softc",
          "args": [
            "dev"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nStatic int;\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic void\nkue_shutdown(dev)\n\tdevice_t\t\tdev;\n{\n\tstruct kue_softc\t*sc;\n\n\tsc = device_get_softc(dev);\n\n\tkue_stop(sc);\n}"
  },
  {
    "function_name": "kue_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
    "lines": "1437-1518",
    "snippet": "Static void\nkue_stop(sc)\n\tstruct kue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\tifp = GET_IFP(sc);\n\tifp->if_timer = 0;\n\n\t/* Stop transfers. */\n\tif (sc->kue_ep[KUE_ENDPT_RX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->kue_ep[KUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort rx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->kue_ep[KUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close rx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->kue_ep[KUE_ENDPT_RX] = NULL;\n\t}\n\n\tif (sc->kue_ep[KUE_ENDPT_TX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->kue_ep[KUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->kue_ep[KUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->kue_ep[KUE_ENDPT_TX] = NULL;\n\t}\n\n\tif (sc->kue_ep[KUE_ENDPT_INTR] != NULL) {\n\t\terr = usbd_abort_pipe(sc->kue_ep[KUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->kue_ep[KUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->kue_ep[KUE_ENDPT_INTR] = NULL;\n\t}\n\n\t/* Free RX resources. */\n\tfor (i = 0; i < KUE_RX_LIST_CNT; i++) {\n\t\tif (sc->kue_cdata.kue_rx_chain[i].kue_mbuf != NULL) {\n\t\t\tm_freem(sc->kue_cdata.kue_rx_chain[i].kue_mbuf);\n\t\t\tsc->kue_cdata.kue_rx_chain[i].kue_mbuf = NULL;\n\t\t}\n\t\tif (sc->kue_cdata.kue_rx_chain[i].kue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->kue_cdata.kue_rx_chain[i].kue_xfer);\n\t\t\tsc->kue_cdata.kue_rx_chain[i].kue_xfer = NULL;\n\t\t}\n\t}\n\n\t/* Free TX resources. */\n\tfor (i = 0; i < KUE_TX_LIST_CNT; i++) {\n\t\tif (sc->kue_cdata.kue_tx_chain[i].kue_mbuf != NULL) {\n\t\t\tm_freem(sc->kue_cdata.kue_tx_chain[i].kue_mbuf);\n\t\t\tsc->kue_cdata.kue_tx_chain[i].kue_mbuf = NULL;\n\t\t}\n\t\tif (sc->kue_cdata.kue_tx_chain[i].kue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->kue_cdata.kue_tx_chain[i].kue_xfer);\n\t\t\tsc->kue_cdata.kue_tx_chain[i].kue_xfer = NULL;\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n}",
    "includes": [
      "#include <dev/usb/kue_fw.h>",
      "#include <dev/usb/if_kuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "kue_tx_list_init\t__P((struct kue_softc *));",
      "Static int",
      "kue_rx_list_init\t__P((struct kue_softc *));",
      "Static int",
      "Static int",
      "Static int",
      "kue_open_pipes\t__P((struct kue_softc *));",
      "Static void",
      "kue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "kue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "kue_start\t\t__P((struct ifnet *));",
      "Static int",
      "Static void",
      "Static void",
      "kue_stop\t\t__P((struct kue_softc *));",
      "Static void",
      "kue_watchdog\t\t__P((struct ifnet *));",
      "Static void",
      "kue_setmulti\t__P((struct kue_softc *));",
      "Static void",
      "kue_reset\t\t__P((struct kue_softc *));",
      "Static usbd_status",
      "Static usbd_status",
      "Static int",
      "kue_is_warm\t\t__P((struct kue_softc *));",
      "Static int",
      "kue_load_fw\t\t__P((struct kue_softc *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_free_xfer",
          "args": [
            "sc->kue_cdata.kue_tx_chain[i].kue_xfer"
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_free_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "403-418",
          "snippet": "usbd_status \nusbd_free_xfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(5,(\"usbd_free_xfer: %p\\n\", xfer));\n\tif (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))\n\t\tusbd_free_buffer(xfer);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&xfer->timeout_handle)) {\n\t\tcallout_stop(&xfer->timeout_handle);\n\t\tprintf(\"usbd_free_xfer: timout_handle pending\");\n\t}\n#endif\n\txfer->device->bus->methods->freex(xfer->device->bus, xfer);\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\n\nusbd_status \nusbd_free_xfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(5,(\"usbd_free_xfer: %p\\n\", xfer));\n\tif (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))\n\t\tusbd_free_buffer(xfer);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&xfer->timeout_handle)) {\n\t\tcallout_stop(&xfer->timeout_handle);\n\t\tprintf(\"usbd_free_xfer: timout_handle pending\");\n\t}\n#endif\n\txfer->device->bus->methods->freex(xfer->device->bus, xfer);\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "sc->kue_cdata.kue_tx_chain[i].kue_mbuf"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "sc->kue_cdata.kue_rx_chain[i].kue_mbuf"
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: close intr pipe failed: %s\\n\"",
            "USBDEVNAME(sc->kue_dev)",
            "usbd_errstr(err)"
          ],
          "line": 1487
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_close_pipe",
          "args": [
            "sc->kue_ep[KUE_ENDPT_INTR]"
          ],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_close_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "224-252",
          "snippet": "usbd_status\nusbd_close_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\n\tif (--pipe->refcnt != 0)\n\t\treturn (USBD_NORMAL_COMPLETION);\n\tif (SIMPLEQ_FIRST(&pipe->queue) != 0)\n\t\treturn (USBD_PENDING_REQUESTS);\n\tLIST_REMOVE(pipe, next);\n\tpipe->endpoint->refcnt--;\n\tpipe->methods->close(pipe);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&pipe->abort_handle)) {\n\t\tcallout_stop(&pipe->abort_handle);\n\t\tprintf(\"usbd_close_pipe: abort_handle pending\");\n\t}\n#endif\n\tif (pipe->intrxfer != NULL)\n\t\tusbd_free_xfer(pipe->intrxfer);\n\tfree(pipe, M_USB);\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusbd_close_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\n\tif (--pipe->refcnt != 0)\n\t\treturn (USBD_NORMAL_COMPLETION);\n\tif (SIMPLEQ_FIRST(&pipe->queue) != 0)\n\t\treturn (USBD_PENDING_REQUESTS);\n\tLIST_REMOVE(pipe, next);\n\tpipe->endpoint->refcnt--;\n\tpipe->methods->close(pipe);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&pipe->abort_handle)) {\n\t\tcallout_stop(&pipe->abort_handle);\n\t\tprintf(\"usbd_close_pipe: abort_handle pending\");\n\t}\n#endif\n\tif (pipe->intrxfer != NULL)\n\t\tusbd_free_xfer(pipe->intrxfer);\n\tfree(pipe, M_USB);\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_abort_pipe",
          "args": [
            "sc->kue_ep[KUE_ENDPT_INTR]"
          ],
          "line": 1480
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_abort_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "560-577",
          "snippet": "usbd_status \nusbd_abort_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_status err;\n\tint s;\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\ts = splusb();\n\terr = usbd_ar_pipe(pipe);\n\tsplx(s);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status \nusbd_abort_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_status err;\n\tint s;\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\ts = splusb();\n\terr = usbd_ar_pipe(pipe);\n\tsplx(s);\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_IFP",
          "args": [
            "sc"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__)"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nStatic int;\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nkue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nkue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nkue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nkue_watchdog\t\t__P((struct ifnet *));\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic usbd_status;\nStatic usbd_status;\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic void\nkue_stop(sc)\n\tstruct kue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\tifp = GET_IFP(sc);\n\tifp->if_timer = 0;\n\n\t/* Stop transfers. */\n\tif (sc->kue_ep[KUE_ENDPT_RX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->kue_ep[KUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort rx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->kue_ep[KUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close rx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->kue_ep[KUE_ENDPT_RX] = NULL;\n\t}\n\n\tif (sc->kue_ep[KUE_ENDPT_TX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->kue_ep[KUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->kue_ep[KUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->kue_ep[KUE_ENDPT_TX] = NULL;\n\t}\n\n\tif (sc->kue_ep[KUE_ENDPT_INTR] != NULL) {\n\t\terr = usbd_abort_pipe(sc->kue_ep[KUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->kue_ep[KUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->kue_ep[KUE_ENDPT_INTR] = NULL;\n\t}\n\n\t/* Free RX resources. */\n\tfor (i = 0; i < KUE_RX_LIST_CNT; i++) {\n\t\tif (sc->kue_cdata.kue_rx_chain[i].kue_mbuf != NULL) {\n\t\t\tm_freem(sc->kue_cdata.kue_rx_chain[i].kue_mbuf);\n\t\t\tsc->kue_cdata.kue_rx_chain[i].kue_mbuf = NULL;\n\t\t}\n\t\tif (sc->kue_cdata.kue_rx_chain[i].kue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->kue_cdata.kue_rx_chain[i].kue_xfer);\n\t\t\tsc->kue_cdata.kue_rx_chain[i].kue_xfer = NULL;\n\t\t}\n\t}\n\n\t/* Free TX resources. */\n\tfor (i = 0; i < KUE_TX_LIST_CNT; i++) {\n\t\tif (sc->kue_cdata.kue_tx_chain[i].kue_mbuf != NULL) {\n\t\t\tm_freem(sc->kue_cdata.kue_tx_chain[i].kue_mbuf);\n\t\t\tsc->kue_cdata.kue_tx_chain[i].kue_mbuf = NULL;\n\t\t}\n\t\tif (sc->kue_cdata.kue_tx_chain[i].kue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->kue_cdata.kue_tx_chain[i].kue_xfer);\n\t\t\tsc->kue_cdata.kue_tx_chain[i].kue_xfer = NULL;\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n}"
  },
  {
    "function_name": "kue_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
    "lines": "1404-1431",
    "snippet": "Static void\nkue_watchdog(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct kue_softc\t*sc = ifp->if_softc;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\tif (sc->kue_dying)\n\t\treturn;\n\n\tifp->if_oerrors++;\n\tprintf(\"%s: watchdog timeout\\n\", USBDEVNAME(sc->kue_dev));\n\n\t/*\n\t * The polling business is a kludge to avoid allowing the\n\t * USB code to call tsleep() in usbd_delay_ms(), which will\n\t * kill us since the watchdog routine is invoked from\n\t * interrupt context.\n\t */\n\tusbd_set_polling(sc->kue_udev, 1);\n\tkue_stop(sc);\n\tkue_init(sc);\n\tusbd_set_polling(sc->kue_udev, 0);\n\n\tif (ifp->if_snd.ifq_head != NULL)\n\t\tkue_start(ifp);\n}",
    "includes": [
      "#include <dev/usb/kue_fw.h>",
      "#include <dev/usb/if_kuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "kue_tx_list_init\t__P((struct kue_softc *));",
      "Static int",
      "kue_rx_list_init\t__P((struct kue_softc *));",
      "Static int",
      "Static int",
      "Static int",
      "kue_open_pipes\t__P((struct kue_softc *));",
      "Static void",
      "Static void",
      "Static void",
      "kue_start\t\t__P((struct ifnet *));",
      "Static int",
      "Static void",
      "Static void",
      "kue_stop\t\t__P((struct kue_softc *));",
      "Static void",
      "kue_watchdog\t\t__P((struct ifnet *));",
      "Static void",
      "kue_setmulti\t__P((struct kue_softc *));",
      "Static void",
      "kue_reset\t\t__P((struct kue_softc *));",
      "Static int",
      "kue_is_warm\t\t__P((struct kue_softc *));",
      "Static int",
      "kue_load_fw\t\t__P((struct kue_softc *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kue_start",
          "args": [
            "ifp"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "kue_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
          "lines": "1141-1181",
          "snippet": "Static void\nkue_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct kue_softc\t*sc = ifp->if_softc;\n\tstruct mbuf\t\t*m_head = NULL;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\tif (sc->kue_dying)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\tif (m_head == NULL)\n\t\treturn;\n\n\tif (kue_send(sc, m_head, 0)) {\n\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\n#if NBPFILTER > 0\n\t/*\n\t * If there's a BPF listener, bounce a copy of this frame\n\t * to him.\n\t */\n\tif (ifp->if_bpf)\n\t\tBPF_MTAP(ifp, m_head);\n#endif\n\n\tifp->if_flags |= IFF_OACTIVE;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n}",
          "includes": [
            "#include <dev/usb/kue_fw.h>",
            "#include <dev/usb/if_kuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "kue_tx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "kue_rx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "kue_newbuf\t\t__P((struct kue_softc *, struct kue_chain *,\n\t\t\t\t    struct mbuf *));",
            "Static int",
            "kue_send\t\t__P((struct kue_softc *, struct mbuf *, int));",
            "Static int",
            "kue_open_pipes\t__P((struct kue_softc *));",
            "Static void",
            "Static void",
            "Static void",
            "kue_start\t\t__P((struct ifnet *));",
            "Static int",
            "Static void",
            "Static void",
            "kue_stop\t\t__P((struct kue_softc *));",
            "Static void",
            "kue_watchdog\t\t__P((struct ifnet *));",
            "Static void",
            "kue_setmulti\t__P((struct kue_softc *));",
            "Static void",
            "kue_reset\t\t__P((struct kue_softc *));",
            "Static int",
            "kue_is_warm\t\t__P((struct kue_softc *));",
            "Static int",
            "kue_load_fw\t\t__P((struct kue_softc *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_newbuf\t\t__P((struct kue_softc *, struct kue_chain *,\n\t\t\t\t    struct mbuf *));\nStatic int;\nkue_send\t\t__P((struct kue_softc *, struct mbuf *, int));\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nStatic void;\nkue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nkue_watchdog\t\t__P((struct ifnet *));\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic void\nkue_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct kue_softc\t*sc = ifp->if_softc;\n\tstruct mbuf\t\t*m_head = NULL;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\tif (sc->kue_dying)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\tif (m_head == NULL)\n\t\treturn;\n\n\tif (kue_send(sc, m_head, 0)) {\n\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\n#if NBPFILTER > 0\n\t/*\n\t * If there's a BPF listener, bounce a copy of this frame\n\t * to him.\n\t */\n\tif (ifp->if_bpf)\n\t\tBPF_MTAP(ifp, m_head);\n#endif\n\n\tifp->if_flags |= IFF_OACTIVE;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_set_polling",
          "args": [
            "sc->kue_udev",
            "0"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_set_polling",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "1100-1109",
          "snippet": "void\nusbd_set_polling(dev, on)\n\tusbd_device_handle dev;\n\tint on;\n{\n\tif (on)\n\t\tdev->bus->use_polling++;\n\telse\n\t\tdev->bus->use_polling--;\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nvoid\nusbd_set_polling(dev, on)\n\tusbd_device_handle dev;\n\tint on;\n{\n\tif (on)\n\t\tdev->bus->use_polling++;\n\telse\n\t\tdev->bus->use_polling--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kue_init",
          "args": [
            "sc"
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "kue_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
          "lines": "1183-1253",
          "snippet": "Static void\nkue_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct kue_softc\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = GET_IFP(sc);\n\tint\t\t\ts;\n\tu_char\t\t\t*eaddr;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\treturn;\n\n\ts = splimp();\n\n#if defined(__FreeBSD__) || defined(__OpenBSD__)\n\teaddr = sc->arpcom.ac_enaddr;\n#elif defined(__NetBSD__)\n\teaddr = LLADDR(ifp->if_sadl);\n#endif /* defined(__NetBSD__) */\n\t/* Set MAC address */\n\tkue_ctl(sc, KUE_CTL_WRITE, KUE_CMD_SET_MAC, 0, eaddr, ETHER_ADDR_LEN);\n\n\tsc->kue_rxfilt = KUE_RXFILT_UNICAST | KUE_RXFILT_BROADCAST;\n\n\t /* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tsc->kue_rxfilt |= KUE_RXFILT_PROMISC;\n\n\tkue_setword(sc, KUE_CMD_SET_PKT_FILTER, sc->kue_rxfilt);\n\n\t/* I'm not sure how to tune these. */\n#if 0\n\t/*\n\t * Leave this one alone for now; setting it\n\t * wrong causes lockups on some machines/controllers.\n\t */\n\tkue_setword(sc, KUE_CMD_SET_SOFS, 1);\n#endif\n\tkue_setword(sc, KUE_CMD_SET_URB_SIZE, 64);\n\n\t/* Init TX ring. */\n\tif (kue_tx_list_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: tx list init failed\\n\", USBDEVNAME(sc->kue_dev));\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Init RX ring. */\n\tif (kue_rx_list_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: rx list init failed\\n\", USBDEVNAME(sc->kue_dev));\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Load the multicast filter. */\n\tkue_setmulti(sc);\n\n\tif (sc->kue_ep[KUE_ENDPT_RX] == NULL) {\n\t\tif (kue_open_pipes(sc)) {\n\t\t\tsplx(s);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/usb/kue_fw.h>",
            "#include <dev/usb/if_kuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "kue_tx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "kue_rx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "Static int",
            "Static int",
            "kue_open_pipes\t__P((struct kue_softc *));",
            "Static void",
            "Static void",
            "Static void",
            "kue_start\t\t__P((struct ifnet *));",
            "Static int",
            "Static void",
            "Static void",
            "kue_stop\t\t__P((struct kue_softc *));",
            "Static void",
            "kue_watchdog\t\t__P((struct ifnet *));",
            "Static void",
            "kue_setmulti\t__P((struct kue_softc *));",
            "Static void",
            "kue_reset\t\t__P((struct kue_softc *));",
            "Static int",
            "kue_is_warm\t\t__P((struct kue_softc *));",
            "Static int",
            "kue_load_fw\t\t__P((struct kue_softc *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nStatic int;\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nStatic void;\nkue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nkue_watchdog\t\t__P((struct ifnet *));\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic void\nkue_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct kue_softc\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = GET_IFP(sc);\n\tint\t\t\ts;\n\tu_char\t\t\t*eaddr;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\treturn;\n\n\ts = splimp();\n\n#if defined(__FreeBSD__) || defined(__OpenBSD__)\n\teaddr = sc->arpcom.ac_enaddr;\n#elif defined(__NetBSD__)\n\teaddr = LLADDR(ifp->if_sadl);\n#endif /* defined(__NetBSD__) */\n\t/* Set MAC address */\n\tkue_ctl(sc, KUE_CTL_WRITE, KUE_CMD_SET_MAC, 0, eaddr, ETHER_ADDR_LEN);\n\n\tsc->kue_rxfilt = KUE_RXFILT_UNICAST | KUE_RXFILT_BROADCAST;\n\n\t /* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tsc->kue_rxfilt |= KUE_RXFILT_PROMISC;\n\n\tkue_setword(sc, KUE_CMD_SET_PKT_FILTER, sc->kue_rxfilt);\n\n\t/* I'm not sure how to tune these. */\n#if 0\n\t/*\n\t * Leave this one alone for now; setting it\n\t * wrong causes lockups on some machines/controllers.\n\t */\n\tkue_setword(sc, KUE_CMD_SET_SOFS, 1);\n#endif\n\tkue_setword(sc, KUE_CMD_SET_URB_SIZE, 64);\n\n\t/* Init TX ring. */\n\tif (kue_tx_list_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: tx list init failed\\n\", USBDEVNAME(sc->kue_dev));\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Init RX ring. */\n\tif (kue_rx_list_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: rx list init failed\\n\", USBDEVNAME(sc->kue_dev));\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Load the multicast filter. */\n\tkue_setmulti(sc);\n\n\tif (sc->kue_ep[KUE_ENDPT_RX] == NULL) {\n\t\tif (kue_open_pipes(sc)) {\n\t\t\tsplx(s);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kue_stop",
          "args": [
            "sc"
          ],
          "line": 1425
        },
        "resolved": true,
        "details": {
          "function_name": "kue_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
          "lines": "1437-1518",
          "snippet": "Static void\nkue_stop(sc)\n\tstruct kue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\tifp = GET_IFP(sc);\n\tifp->if_timer = 0;\n\n\t/* Stop transfers. */\n\tif (sc->kue_ep[KUE_ENDPT_RX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->kue_ep[KUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort rx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->kue_ep[KUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close rx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->kue_ep[KUE_ENDPT_RX] = NULL;\n\t}\n\n\tif (sc->kue_ep[KUE_ENDPT_TX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->kue_ep[KUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->kue_ep[KUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->kue_ep[KUE_ENDPT_TX] = NULL;\n\t}\n\n\tif (sc->kue_ep[KUE_ENDPT_INTR] != NULL) {\n\t\terr = usbd_abort_pipe(sc->kue_ep[KUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->kue_ep[KUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->kue_ep[KUE_ENDPT_INTR] = NULL;\n\t}\n\n\t/* Free RX resources. */\n\tfor (i = 0; i < KUE_RX_LIST_CNT; i++) {\n\t\tif (sc->kue_cdata.kue_rx_chain[i].kue_mbuf != NULL) {\n\t\t\tm_freem(sc->kue_cdata.kue_rx_chain[i].kue_mbuf);\n\t\t\tsc->kue_cdata.kue_rx_chain[i].kue_mbuf = NULL;\n\t\t}\n\t\tif (sc->kue_cdata.kue_rx_chain[i].kue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->kue_cdata.kue_rx_chain[i].kue_xfer);\n\t\t\tsc->kue_cdata.kue_rx_chain[i].kue_xfer = NULL;\n\t\t}\n\t}\n\n\t/* Free TX resources. */\n\tfor (i = 0; i < KUE_TX_LIST_CNT; i++) {\n\t\tif (sc->kue_cdata.kue_tx_chain[i].kue_mbuf != NULL) {\n\t\t\tm_freem(sc->kue_cdata.kue_tx_chain[i].kue_mbuf);\n\t\t\tsc->kue_cdata.kue_tx_chain[i].kue_mbuf = NULL;\n\t\t}\n\t\tif (sc->kue_cdata.kue_tx_chain[i].kue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->kue_cdata.kue_tx_chain[i].kue_xfer);\n\t\t\tsc->kue_cdata.kue_tx_chain[i].kue_xfer = NULL;\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n}",
          "includes": [
            "#include <dev/usb/kue_fw.h>",
            "#include <dev/usb/if_kuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "kue_tx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "kue_rx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "Static int",
            "Static int",
            "kue_open_pipes\t__P((struct kue_softc *));",
            "Static void",
            "kue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "kue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "kue_start\t\t__P((struct ifnet *));",
            "Static int",
            "Static void",
            "Static void",
            "kue_stop\t\t__P((struct kue_softc *));",
            "Static void",
            "kue_watchdog\t\t__P((struct ifnet *));",
            "Static void",
            "kue_setmulti\t__P((struct kue_softc *));",
            "Static void",
            "kue_reset\t\t__P((struct kue_softc *));",
            "Static usbd_status",
            "Static usbd_status",
            "Static int",
            "kue_is_warm\t\t__P((struct kue_softc *));",
            "Static int",
            "kue_load_fw\t\t__P((struct kue_softc *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nStatic int;\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nkue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nkue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nkue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nkue_watchdog\t\t__P((struct ifnet *));\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic usbd_status;\nStatic usbd_status;\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic void\nkue_stop(sc)\n\tstruct kue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\tifp = GET_IFP(sc);\n\tifp->if_timer = 0;\n\n\t/* Stop transfers. */\n\tif (sc->kue_ep[KUE_ENDPT_RX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->kue_ep[KUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort rx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->kue_ep[KUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close rx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->kue_ep[KUE_ENDPT_RX] = NULL;\n\t}\n\n\tif (sc->kue_ep[KUE_ENDPT_TX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->kue_ep[KUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->kue_ep[KUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->kue_ep[KUE_ENDPT_TX] = NULL;\n\t}\n\n\tif (sc->kue_ep[KUE_ENDPT_INTR] != NULL) {\n\t\terr = usbd_abort_pipe(sc->kue_ep[KUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->kue_ep[KUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->kue_ep[KUE_ENDPT_INTR] = NULL;\n\t}\n\n\t/* Free RX resources. */\n\tfor (i = 0; i < KUE_RX_LIST_CNT; i++) {\n\t\tif (sc->kue_cdata.kue_rx_chain[i].kue_mbuf != NULL) {\n\t\t\tm_freem(sc->kue_cdata.kue_rx_chain[i].kue_mbuf);\n\t\t\tsc->kue_cdata.kue_rx_chain[i].kue_mbuf = NULL;\n\t\t}\n\t\tif (sc->kue_cdata.kue_rx_chain[i].kue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->kue_cdata.kue_rx_chain[i].kue_xfer);\n\t\t\tsc->kue_cdata.kue_rx_chain[i].kue_xfer = NULL;\n\t\t}\n\t}\n\n\t/* Free TX resources. */\n\tfor (i = 0; i < KUE_TX_LIST_CNT; i++) {\n\t\tif (sc->kue_cdata.kue_tx_chain[i].kue_mbuf != NULL) {\n\t\t\tm_freem(sc->kue_cdata.kue_tx_chain[i].kue_mbuf);\n\t\t\tsc->kue_cdata.kue_tx_chain[i].kue_mbuf = NULL;\n\t\t}\n\t\tif (sc->kue_cdata.kue_tx_chain[i].kue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->kue_cdata.kue_tx_chain[i].kue_xfer);\n\t\t\tsc->kue_cdata.kue_tx_chain[i].kue_xfer = NULL;\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: watchdog timeout\\n\"",
            "USBDEVNAME(sc->kue_dev)"
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__)"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nStatic int;\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nStatic void;\nkue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nkue_watchdog\t\t__P((struct ifnet *));\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic void\nkue_watchdog(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct kue_softc\t*sc = ifp->if_softc;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\tif (sc->kue_dying)\n\t\treturn;\n\n\tifp->if_oerrors++;\n\tprintf(\"%s: watchdog timeout\\n\", USBDEVNAME(sc->kue_dev));\n\n\t/*\n\t * The polling business is a kludge to avoid allowing the\n\t * USB code to call tsleep() in usbd_delay_ms(), which will\n\t * kill us since the watchdog routine is invoked from\n\t * interrupt context.\n\t */\n\tusbd_set_polling(sc->kue_udev, 1);\n\tkue_stop(sc);\n\tkue_init(sc);\n\tusbd_set_polling(sc->kue_udev, 0);\n\n\tif (ifp->if_snd.ifq_head != NULL)\n\t\tkue_start(ifp);\n}"
  },
  {
    "function_name": "kue_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
    "lines": "1297-1402",
    "snippet": "Static int\nkue_ioctl(ifp, command, data)\n\tstruct ifnet\t\t*ifp;\n\tu_long\t\t\tcommand;\n\tcaddr_t\t\t\tdata;\n{\n\tstruct kue_softc\t*sc = ifp->if_softc;\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\tstruct ifaddr \t\t*ifa = (struct ifaddr *)data;\n\tstruct ifreq\t\t*ifr = (struct ifreq *)data;\n#endif\n\tint\t\t\ts, error = 0;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\tif (sc->kue_dying)\n\t\treturn (EIO);\n\n\ts = splimp();\n\n\tswitch(command) {\n#if defined(__FreeBSD__)\n\tcase SIOCSIFADDR:\n\tcase SIOCGIFADDR:\n\tcase SIOCSIFMTU:\n\t\terror = ether_ioctl(ifp, command, data);\n\t\tbreak;\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\tkue_init(sc);\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n#if defined(__NetBSD__)\n\t\t\tarp_ifinit(ifp, ifa);\n#else\n\t\t\tarp_ifinit(&sc->arpcom, ifa);\n#endif\n\t\t\tbreak;\n#endif /* INET */\n#ifdef NS\n\t\tcase AF_NS:\n\t\t    {\n\t\t\tstruct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\n\t\t\tif (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t\tLLADDR(ifp->if_sadl);\n\t\t\telse\n\t\t\t\tmemcpy(LLADDR(ifp->if_sadl),\n\t\t\t\t       ina->x_host.c_host,\n\t\t\t\t       ifp->if_addrlen);\n\t\t\tbreak;\n\t\t    }\n#endif /* NS */\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFMTU:\n\t\tif (ifr->ifr_mtu > ETHERMTU)\n\t\t\terror = EINVAL;\n\t\telse\n\t\t\tifp->if_mtu = ifr->ifr_mtu;\n\t\tbreak;\n\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\n\tcase SIOCSIFFLAGS:\n\t\tif (ifp->if_flags & IFF_UP) {\n\t\t\tif (ifp->if_flags & IFF_RUNNING &&\n\t\t\t    ifp->if_flags & IFF_PROMISC &&\n\t\t\t    !(sc->kue_if_flags & IFF_PROMISC)) {\n\t\t\t\tsc->kue_rxfilt |= KUE_RXFILT_PROMISC;\n\t\t\t\tkue_setword(sc, KUE_CMD_SET_PKT_FILTER,\n\t\t\t\t    sc->kue_rxfilt);\n\t\t\t} else if (ifp->if_flags & IFF_RUNNING &&\n\t\t\t    !(ifp->if_flags & IFF_PROMISC) &&\n\t\t\t    sc->kue_if_flags & IFF_PROMISC) {\n\t\t\t\tsc->kue_rxfilt &= ~KUE_RXFILT_PROMISC;\n\t\t\t\tkue_setword(sc, KUE_CMD_SET_PKT_FILTER,\n\t\t\t\t    sc->kue_rxfilt);\n\t\t\t} else if (!(ifp->if_flags & IFF_RUNNING))\n\t\t\t\tkue_init(sc);\n\t\t} else {\n\t\t\tif (ifp->if_flags & IFF_RUNNING)\n\t\t\t\tkue_stop(sc);\n\t\t}\n\t\tsc->kue_if_flags = ifp->if_flags;\n\t\terror = 0;\n\t\tbreak;\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\tkue_setmulti(sc);\n\t\terror = 0;\n\t\tbreak;\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\tsplx(s);\n\n\treturn (error);\n}",
    "includes": [
      "#include <dev/usb/kue_fw.h>",
      "#include <dev/usb/if_kuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "kue_tx_list_init\t__P((struct kue_softc *));",
      "Static int",
      "kue_rx_list_init\t__P((struct kue_softc *));",
      "Static int",
      "Static int",
      "Static int",
      "kue_open_pipes\t__P((struct kue_softc *));",
      "Static void",
      "Static void",
      "Static void",
      "kue_start\t\t__P((struct ifnet *));",
      "Static int",
      "kue_ioctl\t\t__P((struct ifnet *, u_long, caddr_t));",
      "Static void",
      "Static void",
      "kue_stop\t\t__P((struct kue_softc *));",
      "Static void",
      "kue_watchdog\t\t__P((struct ifnet *));",
      "Static void",
      "kue_setmulti\t__P((struct kue_softc *));",
      "Static void",
      "kue_reset\t\t__P((struct kue_softc *));",
      "Static int",
      "kue_is_warm\t\t__P((struct kue_softc *));",
      "Static int",
      "kue_load_fw\t\t__P((struct kue_softc *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kue_setmulti",
          "args": [
            "sc"
          ],
          "line": 1391
        },
        "resolved": true,
        "details": {
          "function_name": "kue_setmulti",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
          "lines": "416-488",
          "snippet": "Static void\nkue_setmulti(sc)\n\tstruct kue_softc\t*sc;\n{\n\tstruct ifnet\t\t*ifp = GET_IFP(sc);\n#if defined(__FreeBSD__)\n\tstruct ifmultiaddr\t*ifma;\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n#endif\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev), __FUNCTION__));\n\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\tsc->kue_rxfilt |= KUE_RXFILT_ALLMULTI;\n\t\tsc->kue_rxfilt &= ~KUE_RXFILT_MULTICAST;\n\t\tkue_setword(sc, KUE_CMD_SET_PKT_FILTER, sc->kue_rxfilt);\n\t\treturn;\n\t}\n\n\tsc->kue_rxfilt &= ~KUE_RXFILT_ALLMULTI;\n\n\ti = 0;\n#if defined(__FreeBSD__)\n\tfor (ifma = ifp->if_multiaddrs.lh_first; ifma != NULL;\n\t    ifma = ifma->ifma_link.le_next) {\n\t\tif (ifma->ifma_addr->sa_family != AF_LINK)\n\t\t\tcontinue;\n\t\t/*\n\t\t * If there are too many addresses for the\n\t\t * internal filter, switch over to allmulti mode.\n\t\t */\n\t\tif (i == KUE_MCFILTCNT(sc))\n\t\t\tbreak;\n\t\tbcopy(LLADDR((struct sockaddr_dl *)ifma->ifma_addr),\n\t\t    KUE_MCFILT(sc, i), ETHER_ADDR_LEN);\n\t\ti++;\n\t}\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n#if defined (__NetBSD__)\n\tETHER_FIRST_MULTI(step, &sc->kue_ec, enm);\n#else\n\tETHER_FIRST_MULTI(step, &sc->arpcom, enm);\n#endif\n\twhile (enm != NULL) {\n\t\tif (i == KUE_MCFILTCNT(sc))\n\t\t\tbreak;\n#if 0\n\t\tif (memcmp(enm->enm_addrlo,\n\t\t\t   enm->enm_addrhi, ETHER_ADDR_LEN) != 0) {\n\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\t/* XXX what now? */\n\t\t\treturn;\n\t\t}\n#endif\n\t\tmemcpy(KUE_MCFILT(sc, i), enm->enm_addrlo, ETHER_ADDR_LEN);\n\t\tETHER_NEXT_MULTI(step, enm);\n\t\ti++;\n\t}\n#endif\n\n\tif (i == KUE_MCFILTCNT(sc))\n\t\tsc->kue_rxfilt |= KUE_RXFILT_ALLMULTI;\n\telse {\n\t\tsc->kue_rxfilt |= KUE_RXFILT_MULTICAST;\n\t\tkue_ctl(sc, KUE_CTL_WRITE, KUE_CMD_SET_MCAST_FILTERS,\n\t\t    i, sc->kue_mcfilters, i * ETHER_ADDR_LEN);\n\t}\n\n\tkue_setword(sc, KUE_CMD_SET_PKT_FILTER, sc->kue_rxfilt);\n}",
          "includes": [
            "#include <dev/usb/kue_fw.h>",
            "#include <dev/usb/if_kuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "kue_tx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "kue_rx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "Static int",
            "Static int",
            "kue_open_pipes\t__P((struct kue_softc *));",
            "Static void",
            "Static void",
            "Static void",
            "kue_start\t\t__P((struct ifnet *));",
            "Static int",
            "Static void",
            "Static void",
            "kue_stop\t\t__P((struct kue_softc *));",
            "Static void",
            "kue_watchdog\t\t__P((struct ifnet *));",
            "Static void",
            "kue_setmulti\t__P((struct kue_softc *));",
            "Static void",
            "kue_reset\t\t__P((struct kue_softc *));",
            "Static int",
            "kue_is_warm\t\t__P((struct kue_softc *));",
            "Static int",
            "kue_load_fw\t\t__P((struct kue_softc *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nStatic int;\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nStatic void;\nkue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nkue_watchdog\t\t__P((struct ifnet *));\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic void\nkue_setmulti(sc)\n\tstruct kue_softc\t*sc;\n{\n\tstruct ifnet\t\t*ifp = GET_IFP(sc);\n#if defined(__FreeBSD__)\n\tstruct ifmultiaddr\t*ifma;\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n#endif\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev), __FUNCTION__));\n\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\tsc->kue_rxfilt |= KUE_RXFILT_ALLMULTI;\n\t\tsc->kue_rxfilt &= ~KUE_RXFILT_MULTICAST;\n\t\tkue_setword(sc, KUE_CMD_SET_PKT_FILTER, sc->kue_rxfilt);\n\t\treturn;\n\t}\n\n\tsc->kue_rxfilt &= ~KUE_RXFILT_ALLMULTI;\n\n\ti = 0;\n#if defined(__FreeBSD__)\n\tfor (ifma = ifp->if_multiaddrs.lh_first; ifma != NULL;\n\t    ifma = ifma->ifma_link.le_next) {\n\t\tif (ifma->ifma_addr->sa_family != AF_LINK)\n\t\t\tcontinue;\n\t\t/*\n\t\t * If there are too many addresses for the\n\t\t * internal filter, switch over to allmulti mode.\n\t\t */\n\t\tif (i == KUE_MCFILTCNT(sc))\n\t\t\tbreak;\n\t\tbcopy(LLADDR((struct sockaddr_dl *)ifma->ifma_addr),\n\t\t    KUE_MCFILT(sc, i), ETHER_ADDR_LEN);\n\t\ti++;\n\t}\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n#if defined (__NetBSD__)\n\tETHER_FIRST_MULTI(step, &sc->kue_ec, enm);\n#else\n\tETHER_FIRST_MULTI(step, &sc->arpcom, enm);\n#endif\n\twhile (enm != NULL) {\n\t\tif (i == KUE_MCFILTCNT(sc))\n\t\t\tbreak;\n#if 0\n\t\tif (memcmp(enm->enm_addrlo,\n\t\t\t   enm->enm_addrhi, ETHER_ADDR_LEN) != 0) {\n\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\t/* XXX what now? */\n\t\t\treturn;\n\t\t}\n#endif\n\t\tmemcpy(KUE_MCFILT(sc, i), enm->enm_addrlo, ETHER_ADDR_LEN);\n\t\tETHER_NEXT_MULTI(step, enm);\n\t\ti++;\n\t}\n#endif\n\n\tif (i == KUE_MCFILTCNT(sc))\n\t\tsc->kue_rxfilt |= KUE_RXFILT_ALLMULTI;\n\telse {\n\t\tsc->kue_rxfilt |= KUE_RXFILT_MULTICAST;\n\t\tkue_ctl(sc, KUE_CTL_WRITE, KUE_CMD_SET_MCAST_FILTERS,\n\t\t    i, sc->kue_mcfilters, i * ETHER_ADDR_LEN);\n\t}\n\n\tkue_setword(sc, KUE_CMD_SET_PKT_FILTER, sc->kue_rxfilt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kue_stop",
          "args": [
            "sc"
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "kue_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
          "lines": "1437-1518",
          "snippet": "Static void\nkue_stop(sc)\n\tstruct kue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\tifp = GET_IFP(sc);\n\tifp->if_timer = 0;\n\n\t/* Stop transfers. */\n\tif (sc->kue_ep[KUE_ENDPT_RX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->kue_ep[KUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort rx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->kue_ep[KUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close rx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->kue_ep[KUE_ENDPT_RX] = NULL;\n\t}\n\n\tif (sc->kue_ep[KUE_ENDPT_TX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->kue_ep[KUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->kue_ep[KUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->kue_ep[KUE_ENDPT_TX] = NULL;\n\t}\n\n\tif (sc->kue_ep[KUE_ENDPT_INTR] != NULL) {\n\t\terr = usbd_abort_pipe(sc->kue_ep[KUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->kue_ep[KUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->kue_ep[KUE_ENDPT_INTR] = NULL;\n\t}\n\n\t/* Free RX resources. */\n\tfor (i = 0; i < KUE_RX_LIST_CNT; i++) {\n\t\tif (sc->kue_cdata.kue_rx_chain[i].kue_mbuf != NULL) {\n\t\t\tm_freem(sc->kue_cdata.kue_rx_chain[i].kue_mbuf);\n\t\t\tsc->kue_cdata.kue_rx_chain[i].kue_mbuf = NULL;\n\t\t}\n\t\tif (sc->kue_cdata.kue_rx_chain[i].kue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->kue_cdata.kue_rx_chain[i].kue_xfer);\n\t\t\tsc->kue_cdata.kue_rx_chain[i].kue_xfer = NULL;\n\t\t}\n\t}\n\n\t/* Free TX resources. */\n\tfor (i = 0; i < KUE_TX_LIST_CNT; i++) {\n\t\tif (sc->kue_cdata.kue_tx_chain[i].kue_mbuf != NULL) {\n\t\t\tm_freem(sc->kue_cdata.kue_tx_chain[i].kue_mbuf);\n\t\t\tsc->kue_cdata.kue_tx_chain[i].kue_mbuf = NULL;\n\t\t}\n\t\tif (sc->kue_cdata.kue_tx_chain[i].kue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->kue_cdata.kue_tx_chain[i].kue_xfer);\n\t\t\tsc->kue_cdata.kue_tx_chain[i].kue_xfer = NULL;\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n}",
          "includes": [
            "#include <dev/usb/kue_fw.h>",
            "#include <dev/usb/if_kuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "kue_tx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "kue_rx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "Static int",
            "Static int",
            "kue_open_pipes\t__P((struct kue_softc *));",
            "Static void",
            "kue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "kue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "kue_start\t\t__P((struct ifnet *));",
            "Static int",
            "Static void",
            "Static void",
            "kue_stop\t\t__P((struct kue_softc *));",
            "Static void",
            "kue_watchdog\t\t__P((struct ifnet *));",
            "Static void",
            "kue_setmulti\t__P((struct kue_softc *));",
            "Static void",
            "kue_reset\t\t__P((struct kue_softc *));",
            "Static usbd_status",
            "Static usbd_status",
            "Static int",
            "kue_is_warm\t\t__P((struct kue_softc *));",
            "Static int",
            "kue_load_fw\t\t__P((struct kue_softc *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nStatic int;\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nkue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nkue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nkue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nkue_watchdog\t\t__P((struct ifnet *));\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic usbd_status;\nStatic usbd_status;\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic void\nkue_stop(sc)\n\tstruct kue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\tifp = GET_IFP(sc);\n\tifp->if_timer = 0;\n\n\t/* Stop transfers. */\n\tif (sc->kue_ep[KUE_ENDPT_RX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->kue_ep[KUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort rx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->kue_ep[KUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close rx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->kue_ep[KUE_ENDPT_RX] = NULL;\n\t}\n\n\tif (sc->kue_ep[KUE_ENDPT_TX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->kue_ep[KUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->kue_ep[KUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->kue_ep[KUE_ENDPT_TX] = NULL;\n\t}\n\n\tif (sc->kue_ep[KUE_ENDPT_INTR] != NULL) {\n\t\terr = usbd_abort_pipe(sc->kue_ep[KUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->kue_ep[KUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->kue_ep[KUE_ENDPT_INTR] = NULL;\n\t}\n\n\t/* Free RX resources. */\n\tfor (i = 0; i < KUE_RX_LIST_CNT; i++) {\n\t\tif (sc->kue_cdata.kue_rx_chain[i].kue_mbuf != NULL) {\n\t\t\tm_freem(sc->kue_cdata.kue_rx_chain[i].kue_mbuf);\n\t\t\tsc->kue_cdata.kue_rx_chain[i].kue_mbuf = NULL;\n\t\t}\n\t\tif (sc->kue_cdata.kue_rx_chain[i].kue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->kue_cdata.kue_rx_chain[i].kue_xfer);\n\t\t\tsc->kue_cdata.kue_rx_chain[i].kue_xfer = NULL;\n\t\t}\n\t}\n\n\t/* Free TX resources. */\n\tfor (i = 0; i < KUE_TX_LIST_CNT; i++) {\n\t\tif (sc->kue_cdata.kue_tx_chain[i].kue_mbuf != NULL) {\n\t\t\tm_freem(sc->kue_cdata.kue_tx_chain[i].kue_mbuf);\n\t\t\tsc->kue_cdata.kue_tx_chain[i].kue_mbuf = NULL;\n\t\t}\n\t\tif (sc->kue_cdata.kue_tx_chain[i].kue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->kue_cdata.kue_tx_chain[i].kue_xfer);\n\t\t\tsc->kue_cdata.kue_tx_chain[i].kue_xfer = NULL;\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kue_init",
          "args": [
            "sc"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "kue_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
          "lines": "1183-1253",
          "snippet": "Static void\nkue_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct kue_softc\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = GET_IFP(sc);\n\tint\t\t\ts;\n\tu_char\t\t\t*eaddr;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\treturn;\n\n\ts = splimp();\n\n#if defined(__FreeBSD__) || defined(__OpenBSD__)\n\teaddr = sc->arpcom.ac_enaddr;\n#elif defined(__NetBSD__)\n\teaddr = LLADDR(ifp->if_sadl);\n#endif /* defined(__NetBSD__) */\n\t/* Set MAC address */\n\tkue_ctl(sc, KUE_CTL_WRITE, KUE_CMD_SET_MAC, 0, eaddr, ETHER_ADDR_LEN);\n\n\tsc->kue_rxfilt = KUE_RXFILT_UNICAST | KUE_RXFILT_BROADCAST;\n\n\t /* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tsc->kue_rxfilt |= KUE_RXFILT_PROMISC;\n\n\tkue_setword(sc, KUE_CMD_SET_PKT_FILTER, sc->kue_rxfilt);\n\n\t/* I'm not sure how to tune these. */\n#if 0\n\t/*\n\t * Leave this one alone for now; setting it\n\t * wrong causes lockups on some machines/controllers.\n\t */\n\tkue_setword(sc, KUE_CMD_SET_SOFS, 1);\n#endif\n\tkue_setword(sc, KUE_CMD_SET_URB_SIZE, 64);\n\n\t/* Init TX ring. */\n\tif (kue_tx_list_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: tx list init failed\\n\", USBDEVNAME(sc->kue_dev));\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Init RX ring. */\n\tif (kue_rx_list_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: rx list init failed\\n\", USBDEVNAME(sc->kue_dev));\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Load the multicast filter. */\n\tkue_setmulti(sc);\n\n\tif (sc->kue_ep[KUE_ENDPT_RX] == NULL) {\n\t\tif (kue_open_pipes(sc)) {\n\t\t\tsplx(s);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/usb/kue_fw.h>",
            "#include <dev/usb/if_kuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "kue_tx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "kue_rx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "Static int",
            "Static int",
            "kue_open_pipes\t__P((struct kue_softc *));",
            "Static void",
            "Static void",
            "Static void",
            "kue_start\t\t__P((struct ifnet *));",
            "Static int",
            "Static void",
            "Static void",
            "kue_stop\t\t__P((struct kue_softc *));",
            "Static void",
            "kue_watchdog\t\t__P((struct ifnet *));",
            "Static void",
            "kue_setmulti\t__P((struct kue_softc *));",
            "Static void",
            "kue_reset\t\t__P((struct kue_softc *));",
            "Static int",
            "kue_is_warm\t\t__P((struct kue_softc *));",
            "Static int",
            "kue_load_fw\t\t__P((struct kue_softc *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nStatic int;\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nStatic void;\nkue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nkue_watchdog\t\t__P((struct ifnet *));\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic void\nkue_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct kue_softc\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = GET_IFP(sc);\n\tint\t\t\ts;\n\tu_char\t\t\t*eaddr;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\treturn;\n\n\ts = splimp();\n\n#if defined(__FreeBSD__) || defined(__OpenBSD__)\n\teaddr = sc->arpcom.ac_enaddr;\n#elif defined(__NetBSD__)\n\teaddr = LLADDR(ifp->if_sadl);\n#endif /* defined(__NetBSD__) */\n\t/* Set MAC address */\n\tkue_ctl(sc, KUE_CTL_WRITE, KUE_CMD_SET_MAC, 0, eaddr, ETHER_ADDR_LEN);\n\n\tsc->kue_rxfilt = KUE_RXFILT_UNICAST | KUE_RXFILT_BROADCAST;\n\n\t /* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tsc->kue_rxfilt |= KUE_RXFILT_PROMISC;\n\n\tkue_setword(sc, KUE_CMD_SET_PKT_FILTER, sc->kue_rxfilt);\n\n\t/* I'm not sure how to tune these. */\n#if 0\n\t/*\n\t * Leave this one alone for now; setting it\n\t * wrong causes lockups on some machines/controllers.\n\t */\n\tkue_setword(sc, KUE_CMD_SET_SOFS, 1);\n#endif\n\tkue_setword(sc, KUE_CMD_SET_URB_SIZE, 64);\n\n\t/* Init TX ring. */\n\tif (kue_tx_list_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: tx list init failed\\n\", USBDEVNAME(sc->kue_dev));\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Init RX ring. */\n\tif (kue_rx_list_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: rx list init failed\\n\", USBDEVNAME(sc->kue_dev));\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Load the multicast filter. */\n\tkue_setmulti(sc);\n\n\tif (sc->kue_ep[KUE_ENDPT_RX] == NULL) {\n\t\tif (kue_open_pipes(sc)) {\n\t\t\tsplx(s);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kue_setword",
          "args": [
            "sc",
            "KUE_CMD_SET_PKT_FILTER",
            "sc->kue_rxfilt"
          ],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "kue_setword",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
          "lines": "257-280",
          "snippet": "Static usbd_status\nkue_setword(sc, breq, word)\n\tstruct kue_softc\t*sc;\n\tu_int8_t\t\tbreq;\n\tu_int16_t\t\tword;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = breq;\n\tUSETW(req.wValue, word);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, 0);\n\n\ts = splusb();\n\terr = KUE_DO_REQUEST(sc->kue_udev, &req, NULL);\n\tsplx(s);\n\n\treturn (err);\n}",
          "includes": [
            "#include <dev/usb/kue_fw.h>",
            "#include <dev/usb/if_kuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "kue_tx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "kue_rx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "Static int",
            "Static int",
            "kue_open_pipes\t__P((struct kue_softc *));",
            "Static void",
            "kue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "kue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "kue_stop\t\t__P((struct kue_softc *));",
            "Static void",
            "Static void",
            "kue_setmulti\t__P((struct kue_softc *));",
            "Static void",
            "kue_reset\t\t__P((struct kue_softc *));",
            "Static usbd_status",
            "Static usbd_status",
            "kue_setword\t__P((struct kue_softc *, u_int8_t, u_int16_t));",
            "Static int",
            "kue_is_warm\t\t__P((struct kue_softc *));",
            "Static int",
            "kue_load_fw\t\t__P((struct kue_softc *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nStatic int;\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nkue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nkue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic usbd_status;\nStatic usbd_status;\nkue_setword\t__P((struct kue_softc *, u_int8_t, u_int16_t));\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic usbd_status\nkue_setword(sc, breq, word)\n\tstruct kue_softc\t*sc;\n\tu_int8_t\t\tbreq;\n\tu_int16_t\t\tword;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = breq;\n\tUSETW(req.wValue, word);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, 0);\n\n\ts = splusb();\n\terr = KUE_DO_REQUEST(sc->kue_udev, &req, NULL);\n\tsplx(s);\n\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "LLADDR(ifp->if_sadl)",
            "ina->x_host.c_host",
            "ifp->if_addrlen"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LLADDR",
          "args": [
            "ifp->if_sadl"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LLADDR",
          "args": [
            "ifp->if_sadl"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_nullhost",
          "args": [
            "*ina"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IA_SNS",
          "args": [
            "ifa"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arp_ifinit",
          "args": [
            "&sc->arpcom",
            "ifa"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "arp_ifinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_devar.h",
          "lines": "929-936",
          "snippet": "static void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}",
          "includes": [
            "#include <sys/devconf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/devconf.h>\n\nstatic void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_ioctl",
          "args": [
            "ifp",
            "command",
            "data"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "wx_ether_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "303-356",
          "snippet": "static int\nwx_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tIOCTL_CMD_TYPE cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tint error = 0;\n\twx_softc_t *sc = SOFTC_IFP(ifp);\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\terror = wx_init(sc);\n\t\tif (error) {\n\t\t\tifp->if_flags &= ~IFF_UP;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n#ifdef __OpenBSD__\n\t\t\tarp_ifinit(&sc->w.arpcom, ifa);\n#else\n\t\t\tarp_ifinit(ifp, ifa);\n#endif\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t{\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t break;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int wx_init",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic int wx_init;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic int\nwx_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tIOCTL_CMD_TYPE cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tint error = 0;\n\twx_softc_t *sc = SOFTC_IFP(ifp);\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\terror = wx_init(sc);\n\t\tif (error) {\n\t\t\tifp->if_flags &= ~IFF_UP;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n#ifdef __OpenBSD__\n\t\t\tarp_ifinit(&sc->w.arpcom, ifa);\n#else\n\t\t\tarp_ifinit(ifp, ifa);\n#endif\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t{\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t break;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__)"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nStatic int;\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nStatic void;\nkue_start\t\t__P((struct ifnet *));\nStatic int;\nkue_ioctl\t\t__P((struct ifnet *, u_long, caddr_t));\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nkue_watchdog\t\t__P((struct ifnet *));\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic int\nkue_ioctl(ifp, command, data)\n\tstruct ifnet\t\t*ifp;\n\tu_long\t\t\tcommand;\n\tcaddr_t\t\t\tdata;\n{\n\tstruct kue_softc\t*sc = ifp->if_softc;\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\tstruct ifaddr \t\t*ifa = (struct ifaddr *)data;\n\tstruct ifreq\t\t*ifr = (struct ifreq *)data;\n#endif\n\tint\t\t\ts, error = 0;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\tif (sc->kue_dying)\n\t\treturn (EIO);\n\n\ts = splimp();\n\n\tswitch(command) {\n#if defined(__FreeBSD__)\n\tcase SIOCSIFADDR:\n\tcase SIOCGIFADDR:\n\tcase SIOCSIFMTU:\n\t\terror = ether_ioctl(ifp, command, data);\n\t\tbreak;\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\tkue_init(sc);\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n#if defined(__NetBSD__)\n\t\t\tarp_ifinit(ifp, ifa);\n#else\n\t\t\tarp_ifinit(&sc->arpcom, ifa);\n#endif\n\t\t\tbreak;\n#endif /* INET */\n#ifdef NS\n\t\tcase AF_NS:\n\t\t    {\n\t\t\tstruct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\n\t\t\tif (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t\tLLADDR(ifp->if_sadl);\n\t\t\telse\n\t\t\t\tmemcpy(LLADDR(ifp->if_sadl),\n\t\t\t\t       ina->x_host.c_host,\n\t\t\t\t       ifp->if_addrlen);\n\t\t\tbreak;\n\t\t    }\n#endif /* NS */\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFMTU:\n\t\tif (ifr->ifr_mtu > ETHERMTU)\n\t\t\terror = EINVAL;\n\t\telse\n\t\t\tifp->if_mtu = ifr->ifr_mtu;\n\t\tbreak;\n\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\n\tcase SIOCSIFFLAGS:\n\t\tif (ifp->if_flags & IFF_UP) {\n\t\t\tif (ifp->if_flags & IFF_RUNNING &&\n\t\t\t    ifp->if_flags & IFF_PROMISC &&\n\t\t\t    !(sc->kue_if_flags & IFF_PROMISC)) {\n\t\t\t\tsc->kue_rxfilt |= KUE_RXFILT_PROMISC;\n\t\t\t\tkue_setword(sc, KUE_CMD_SET_PKT_FILTER,\n\t\t\t\t    sc->kue_rxfilt);\n\t\t\t} else if (ifp->if_flags & IFF_RUNNING &&\n\t\t\t    !(ifp->if_flags & IFF_PROMISC) &&\n\t\t\t    sc->kue_if_flags & IFF_PROMISC) {\n\t\t\t\tsc->kue_rxfilt &= ~KUE_RXFILT_PROMISC;\n\t\t\t\tkue_setword(sc, KUE_CMD_SET_PKT_FILTER,\n\t\t\t\t    sc->kue_rxfilt);\n\t\t\t} else if (!(ifp->if_flags & IFF_RUNNING))\n\t\t\t\tkue_init(sc);\n\t\t} else {\n\t\t\tif (ifp->if_flags & IFF_RUNNING)\n\t\t\t\tkue_stop(sc);\n\t\t}\n\t\tsc->kue_if_flags = ifp->if_flags;\n\t\terror = 0;\n\t\tbreak;\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\tkue_setmulti(sc);\n\t\terror = 0;\n\t\tbreak;\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\tsplx(s);\n\n\treturn (error);\n}"
  },
  {
    "function_name": "kue_open_pipes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
    "lines": "1255-1295",
    "snippet": "Static int\nkue_open_pipes(sc)\n\tstruct kue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\tstruct kue_chain\t*c;\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\t/* Open RX and TX pipes. */\n\terr = usbd_open_pipe(sc->kue_iface, sc->kue_ed[KUE_ENDPT_RX],\n\t    USBD_EXCLUSIVE_USE, &sc->kue_ep[KUE_ENDPT_RX]);\n\tif (err) {\n\t\tprintf(\"%s: open rx pipe failed: %s\\n\",\n\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\treturn (EIO);\n\t}\n\n\terr = usbd_open_pipe(sc->kue_iface, sc->kue_ed[KUE_ENDPT_TX],\n\t    USBD_EXCLUSIVE_USE, &sc->kue_ep[KUE_ENDPT_TX]);\n\tif (err) {\n\t\tprintf(\"%s: open tx pipe failed: %s\\n\",\n\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\treturn (EIO);\n\t}\n\n\t/* Start up the receive pipe. */\n\tfor (i = 0; i < KUE_RX_LIST_CNT; i++) {\n\t\tc = &sc->kue_cdata.kue_rx_chain[i];\n\t\tusbd_setup_xfer(c->kue_xfer, sc->kue_ep[KUE_ENDPT_RX],\n\t\t    c, c->kue_buf, KUE_BUFSZ,\n\t\t    USBD_SHORT_XFER_OK | USBD_NO_COPY, USBD_NO_TIMEOUT,\n\t\t    kue_rxeof);\n\t\tDPRINTFN(5,(\"%s: %s: start read\\n\", USBDEVNAME(sc->kue_dev),\n\t\t\t    __FUNCTION__));\n\t\tusbd_transfer(c->kue_xfer);\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/kue_fw.h>",
      "#include <dev/usb/if_kuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "kue_tx_list_init\t__P((struct kue_softc *));",
      "Static int",
      "kue_rx_list_init\t__P((struct kue_softc *));",
      "Static int",
      "Static int",
      "Static int",
      "kue_open_pipes\t__P((struct kue_softc *));",
      "Static void",
      "kue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "kue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "kue_stop\t\t__P((struct kue_softc *));",
      "Static void",
      "Static void",
      "kue_setmulti\t__P((struct kue_softc *));",
      "Static void",
      "kue_reset\t\t__P((struct kue_softc *));",
      "Static usbd_status",
      "Static usbd_status",
      "Static int",
      "kue_is_warm\t\t__P((struct kue_softc *));",
      "Static int",
      "kue_load_fw\t\t__P((struct kue_softc *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_transfer",
          "args": [
            "c->kue_xfer"
          ],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "254-339",
          "snippet": "usbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "u_int32_t size;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nu_int32_t size;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"%s: %s: start read\\n\", USBDEVNAME(sc->kue_dev),\n\t\t\t    __FUNCTION__)"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_setup_xfer",
          "args": [
            "c->kue_xfer",
            "sc->kue_ep[KUE_ENDPT_RX]",
            "c",
            "c->kue_buf",
            "KUE_BUFSZ",
            "USBD_SHORT_XFER_OK | USBD_NO_COPY",
            "USBD_NO_TIMEOUT",
            "kue_rxeof"
          ],
          "line": 1285
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_setup_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "420-444",
          "snippet": "void\nusbd_setup_xfer(xfer, pipe, priv, buffer, length, flags, timeout, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t length;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid (*callback) __P((usbd_xfer_handle,\n\t\t\t      usbd_private_handle,\n\t\t\t      usbd_status));\n{\n\txfer->pipe = pipe;\n\txfer->priv = priv;\n\txfer->buffer = buffer;\n\txfer->length = length;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = timeout;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->rqflags &= ~URQ_REQUEST;\n\txfer->nframes = 0;\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nvoid\nusbd_setup_xfer(xfer, pipe, priv, buffer, length, flags, timeout, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t length;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid (*callback) __P((usbd_xfer_handle,\n\t\t\t      usbd_private_handle,\n\t\t\t      usbd_status));\n{\n\txfer->pipe = pipe;\n\txfer->priv = priv;\n\txfer->buffer = buffer;\n\txfer->length = length;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = timeout;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->rqflags &= ~URQ_REQUEST;\n\txfer->nframes = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: open tx pipe failed: %s\\n\"",
            "USBDEVNAME(sc->kue_dev)",
            "usbd_errstr(err)"
          ],
          "line": 1277
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_open_pipe",
          "args": [
            "sc->kue_iface",
            "sc->kue_ed[KUE_ENDPT_TX]",
            "USBD_EXCLUSIVE_USE",
            "&sc->kue_ep[KUE_ENDPT_TX]"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_open_pipe_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "177-222",
          "snippet": "usbd_status \nusbd_open_pipe_intr(iface, address, flags, pipe, priv, buffer, len, cb, ival)\n\tusbd_interface_handle iface;\n\tu_int8_t address;\n\tu_int8_t flags;\n\tusbd_pipe_handle *pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t len;\n\tusbd_callback cb;\n\tint ival;\n{\n\tusbd_status err;\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle ipipe;\n\n\tDPRINTFN(3,(\"usbd_open_pipe_intr: address=0x%x flags=0x%x len=%d\\n\",\n\t\t    address, flags, len));\n\n\terr = usbd_open_pipe_ival(iface, address, USBD_EXCLUSIVE_USE, \n\t\t\t\t  &ipipe, ival);\n\tif (err)\n\t\treturn (err);\n\txfer = usbd_alloc_xfer(iface->device);\n\tif (xfer == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad1;\n\t}\n\tusbd_setup_xfer(xfer, ipipe, priv, buffer, len, flags,\n\t    USBD_NO_TIMEOUT, cb);\n\tipipe->intrxfer = xfer;\n\tipipe->repeat = 1;\n\terr = usbd_transfer(xfer);\n\t*pipe = ipipe;\n\tif (err != USBD_IN_PROGRESS)\n\t\tgoto bad2;\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad2:\n\tipipe->intrxfer = NULL;\n\tipipe->repeat = 0;\n\tusbd_free_xfer(xfer);\n bad1:\n\tusbd_close_pipe(ipipe);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
            "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;",
            "u_int8_t address;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\nu_int8_t address;\n\nusbd_status \nusbd_open_pipe_intr(iface, address, flags, pipe, priv, buffer, len, cb, ival)\n\tusbd_interface_handle iface;\n\tu_int8_t address;\n\tu_int8_t flags;\n\tusbd_pipe_handle *pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t len;\n\tusbd_callback cb;\n\tint ival;\n{\n\tusbd_status err;\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle ipipe;\n\n\tDPRINTFN(3,(\"usbd_open_pipe_intr: address=0x%x flags=0x%x len=%d\\n\",\n\t\t    address, flags, len));\n\n\terr = usbd_open_pipe_ival(iface, address, USBD_EXCLUSIVE_USE, \n\t\t\t\t  &ipipe, ival);\n\tif (err)\n\t\treturn (err);\n\txfer = usbd_alloc_xfer(iface->device);\n\tif (xfer == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad1;\n\t}\n\tusbd_setup_xfer(xfer, ipipe, priv, buffer, len, flags,\n\t    USBD_NO_TIMEOUT, cb);\n\tipipe->intrxfer = xfer;\n\tipipe->repeat = 1;\n\terr = usbd_transfer(xfer);\n\t*pipe = ipipe;\n\tif (err != USBD_IN_PROGRESS)\n\t\tgoto bad2;\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad2:\n\tipipe->intrxfer = NULL;\n\tipipe->repeat = 0;\n\tusbd_free_xfer(xfer);\n bad1:\n\tusbd_close_pipe(ipipe);\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__)"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nStatic int;\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nkue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nkue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic usbd_status;\nStatic usbd_status;\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic int\nkue_open_pipes(sc)\n\tstruct kue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\tstruct kue_chain\t*c;\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\t/* Open RX and TX pipes. */\n\terr = usbd_open_pipe(sc->kue_iface, sc->kue_ed[KUE_ENDPT_RX],\n\t    USBD_EXCLUSIVE_USE, &sc->kue_ep[KUE_ENDPT_RX]);\n\tif (err) {\n\t\tprintf(\"%s: open rx pipe failed: %s\\n\",\n\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\treturn (EIO);\n\t}\n\n\terr = usbd_open_pipe(sc->kue_iface, sc->kue_ed[KUE_ENDPT_TX],\n\t    USBD_EXCLUSIVE_USE, &sc->kue_ep[KUE_ENDPT_TX]);\n\tif (err) {\n\t\tprintf(\"%s: open tx pipe failed: %s\\n\",\n\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\treturn (EIO);\n\t}\n\n\t/* Start up the receive pipe. */\n\tfor (i = 0; i < KUE_RX_LIST_CNT; i++) {\n\t\tc = &sc->kue_cdata.kue_rx_chain[i];\n\t\tusbd_setup_xfer(c->kue_xfer, sc->kue_ep[KUE_ENDPT_RX],\n\t\t    c, c->kue_buf, KUE_BUFSZ,\n\t\t    USBD_SHORT_XFER_OK | USBD_NO_COPY, USBD_NO_TIMEOUT,\n\t\t    kue_rxeof);\n\t\tDPRINTFN(5,(\"%s: %s: start read\\n\", USBDEVNAME(sc->kue_dev),\n\t\t\t    __FUNCTION__));\n\t\tusbd_transfer(c->kue_xfer);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "kue_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
    "lines": "1183-1253",
    "snippet": "Static void\nkue_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct kue_softc\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = GET_IFP(sc);\n\tint\t\t\ts;\n\tu_char\t\t\t*eaddr;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\treturn;\n\n\ts = splimp();\n\n#if defined(__FreeBSD__) || defined(__OpenBSD__)\n\teaddr = sc->arpcom.ac_enaddr;\n#elif defined(__NetBSD__)\n\teaddr = LLADDR(ifp->if_sadl);\n#endif /* defined(__NetBSD__) */\n\t/* Set MAC address */\n\tkue_ctl(sc, KUE_CTL_WRITE, KUE_CMD_SET_MAC, 0, eaddr, ETHER_ADDR_LEN);\n\n\tsc->kue_rxfilt = KUE_RXFILT_UNICAST | KUE_RXFILT_BROADCAST;\n\n\t /* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tsc->kue_rxfilt |= KUE_RXFILT_PROMISC;\n\n\tkue_setword(sc, KUE_CMD_SET_PKT_FILTER, sc->kue_rxfilt);\n\n\t/* I'm not sure how to tune these. */\n#if 0\n\t/*\n\t * Leave this one alone for now; setting it\n\t * wrong causes lockups on some machines/controllers.\n\t */\n\tkue_setword(sc, KUE_CMD_SET_SOFS, 1);\n#endif\n\tkue_setword(sc, KUE_CMD_SET_URB_SIZE, 64);\n\n\t/* Init TX ring. */\n\tif (kue_tx_list_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: tx list init failed\\n\", USBDEVNAME(sc->kue_dev));\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Init RX ring. */\n\tif (kue_rx_list_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: rx list init failed\\n\", USBDEVNAME(sc->kue_dev));\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Load the multicast filter. */\n\tkue_setmulti(sc);\n\n\tif (sc->kue_ep[KUE_ENDPT_RX] == NULL) {\n\t\tif (kue_open_pipes(sc)) {\n\t\t\tsplx(s);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/usb/kue_fw.h>",
      "#include <dev/usb/if_kuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "kue_tx_list_init\t__P((struct kue_softc *));",
      "Static int",
      "kue_rx_list_init\t__P((struct kue_softc *));",
      "Static int",
      "Static int",
      "Static int",
      "kue_open_pipes\t__P((struct kue_softc *));",
      "Static void",
      "Static void",
      "Static void",
      "kue_start\t\t__P((struct ifnet *));",
      "Static int",
      "Static void",
      "Static void",
      "kue_stop\t\t__P((struct kue_softc *));",
      "Static void",
      "kue_watchdog\t\t__P((struct ifnet *));",
      "Static void",
      "kue_setmulti\t__P((struct kue_softc *));",
      "Static void",
      "kue_reset\t\t__P((struct kue_softc *));",
      "Static int",
      "kue_is_warm\t\t__P((struct kue_softc *));",
      "Static int",
      "kue_load_fw\t\t__P((struct kue_softc *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kue_open_pipes",
          "args": [
            "sc"
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "kue_open_pipes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
          "lines": "1255-1295",
          "snippet": "Static int\nkue_open_pipes(sc)\n\tstruct kue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\tstruct kue_chain\t*c;\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\t/* Open RX and TX pipes. */\n\terr = usbd_open_pipe(sc->kue_iface, sc->kue_ed[KUE_ENDPT_RX],\n\t    USBD_EXCLUSIVE_USE, &sc->kue_ep[KUE_ENDPT_RX]);\n\tif (err) {\n\t\tprintf(\"%s: open rx pipe failed: %s\\n\",\n\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\treturn (EIO);\n\t}\n\n\terr = usbd_open_pipe(sc->kue_iface, sc->kue_ed[KUE_ENDPT_TX],\n\t    USBD_EXCLUSIVE_USE, &sc->kue_ep[KUE_ENDPT_TX]);\n\tif (err) {\n\t\tprintf(\"%s: open tx pipe failed: %s\\n\",\n\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\treturn (EIO);\n\t}\n\n\t/* Start up the receive pipe. */\n\tfor (i = 0; i < KUE_RX_LIST_CNT; i++) {\n\t\tc = &sc->kue_cdata.kue_rx_chain[i];\n\t\tusbd_setup_xfer(c->kue_xfer, sc->kue_ep[KUE_ENDPT_RX],\n\t\t    c, c->kue_buf, KUE_BUFSZ,\n\t\t    USBD_SHORT_XFER_OK | USBD_NO_COPY, USBD_NO_TIMEOUT,\n\t\t    kue_rxeof);\n\t\tDPRINTFN(5,(\"%s: %s: start read\\n\", USBDEVNAME(sc->kue_dev),\n\t\t\t    __FUNCTION__));\n\t\tusbd_transfer(c->kue_xfer);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/usb/kue_fw.h>",
            "#include <dev/usb/if_kuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "kue_tx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "kue_rx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "Static int",
            "Static int",
            "kue_open_pipes\t__P((struct kue_softc *));",
            "Static void",
            "kue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "kue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "kue_stop\t\t__P((struct kue_softc *));",
            "Static void",
            "Static void",
            "kue_setmulti\t__P((struct kue_softc *));",
            "Static void",
            "kue_reset\t\t__P((struct kue_softc *));",
            "Static usbd_status",
            "Static usbd_status",
            "Static int",
            "kue_is_warm\t\t__P((struct kue_softc *));",
            "Static int",
            "kue_load_fw\t\t__P((struct kue_softc *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nStatic int;\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nkue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nkue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic usbd_status;\nStatic usbd_status;\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic int\nkue_open_pipes(sc)\n\tstruct kue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\tstruct kue_chain\t*c;\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\t/* Open RX and TX pipes. */\n\terr = usbd_open_pipe(sc->kue_iface, sc->kue_ed[KUE_ENDPT_RX],\n\t    USBD_EXCLUSIVE_USE, &sc->kue_ep[KUE_ENDPT_RX]);\n\tif (err) {\n\t\tprintf(\"%s: open rx pipe failed: %s\\n\",\n\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\treturn (EIO);\n\t}\n\n\terr = usbd_open_pipe(sc->kue_iface, sc->kue_ed[KUE_ENDPT_TX],\n\t    USBD_EXCLUSIVE_USE, &sc->kue_ep[KUE_ENDPT_TX]);\n\tif (err) {\n\t\tprintf(\"%s: open tx pipe failed: %s\\n\",\n\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\treturn (EIO);\n\t}\n\n\t/* Start up the receive pipe. */\n\tfor (i = 0; i < KUE_RX_LIST_CNT; i++) {\n\t\tc = &sc->kue_cdata.kue_rx_chain[i];\n\t\tusbd_setup_xfer(c->kue_xfer, sc->kue_ep[KUE_ENDPT_RX],\n\t\t    c, c->kue_buf, KUE_BUFSZ,\n\t\t    USBD_SHORT_XFER_OK | USBD_NO_COPY, USBD_NO_TIMEOUT,\n\t\t    kue_rxeof);\n\t\tDPRINTFN(5,(\"%s: %s: start read\\n\", USBDEVNAME(sc->kue_dev),\n\t\t\t    __FUNCTION__));\n\t\tusbd_transfer(c->kue_xfer);\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kue_setmulti",
          "args": [
            "sc"
          ],
          "line": 1240
        },
        "resolved": true,
        "details": {
          "function_name": "kue_setmulti",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
          "lines": "416-488",
          "snippet": "Static void\nkue_setmulti(sc)\n\tstruct kue_softc\t*sc;\n{\n\tstruct ifnet\t\t*ifp = GET_IFP(sc);\n#if defined(__FreeBSD__)\n\tstruct ifmultiaddr\t*ifma;\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n#endif\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev), __FUNCTION__));\n\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\tsc->kue_rxfilt |= KUE_RXFILT_ALLMULTI;\n\t\tsc->kue_rxfilt &= ~KUE_RXFILT_MULTICAST;\n\t\tkue_setword(sc, KUE_CMD_SET_PKT_FILTER, sc->kue_rxfilt);\n\t\treturn;\n\t}\n\n\tsc->kue_rxfilt &= ~KUE_RXFILT_ALLMULTI;\n\n\ti = 0;\n#if defined(__FreeBSD__)\n\tfor (ifma = ifp->if_multiaddrs.lh_first; ifma != NULL;\n\t    ifma = ifma->ifma_link.le_next) {\n\t\tif (ifma->ifma_addr->sa_family != AF_LINK)\n\t\t\tcontinue;\n\t\t/*\n\t\t * If there are too many addresses for the\n\t\t * internal filter, switch over to allmulti mode.\n\t\t */\n\t\tif (i == KUE_MCFILTCNT(sc))\n\t\t\tbreak;\n\t\tbcopy(LLADDR((struct sockaddr_dl *)ifma->ifma_addr),\n\t\t    KUE_MCFILT(sc, i), ETHER_ADDR_LEN);\n\t\ti++;\n\t}\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n#if defined (__NetBSD__)\n\tETHER_FIRST_MULTI(step, &sc->kue_ec, enm);\n#else\n\tETHER_FIRST_MULTI(step, &sc->arpcom, enm);\n#endif\n\twhile (enm != NULL) {\n\t\tif (i == KUE_MCFILTCNT(sc))\n\t\t\tbreak;\n#if 0\n\t\tif (memcmp(enm->enm_addrlo,\n\t\t\t   enm->enm_addrhi, ETHER_ADDR_LEN) != 0) {\n\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\t/* XXX what now? */\n\t\t\treturn;\n\t\t}\n#endif\n\t\tmemcpy(KUE_MCFILT(sc, i), enm->enm_addrlo, ETHER_ADDR_LEN);\n\t\tETHER_NEXT_MULTI(step, enm);\n\t\ti++;\n\t}\n#endif\n\n\tif (i == KUE_MCFILTCNT(sc))\n\t\tsc->kue_rxfilt |= KUE_RXFILT_ALLMULTI;\n\telse {\n\t\tsc->kue_rxfilt |= KUE_RXFILT_MULTICAST;\n\t\tkue_ctl(sc, KUE_CTL_WRITE, KUE_CMD_SET_MCAST_FILTERS,\n\t\t    i, sc->kue_mcfilters, i * ETHER_ADDR_LEN);\n\t}\n\n\tkue_setword(sc, KUE_CMD_SET_PKT_FILTER, sc->kue_rxfilt);\n}",
          "includes": [
            "#include <dev/usb/kue_fw.h>",
            "#include <dev/usb/if_kuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "kue_tx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "kue_rx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "Static int",
            "Static int",
            "kue_open_pipes\t__P((struct kue_softc *));",
            "Static void",
            "Static void",
            "Static void",
            "kue_start\t\t__P((struct ifnet *));",
            "Static int",
            "Static void",
            "Static void",
            "kue_stop\t\t__P((struct kue_softc *));",
            "Static void",
            "kue_watchdog\t\t__P((struct ifnet *));",
            "Static void",
            "kue_setmulti\t__P((struct kue_softc *));",
            "Static void",
            "kue_reset\t\t__P((struct kue_softc *));",
            "Static int",
            "kue_is_warm\t\t__P((struct kue_softc *));",
            "Static int",
            "kue_load_fw\t\t__P((struct kue_softc *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nStatic int;\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nStatic void;\nkue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nkue_watchdog\t\t__P((struct ifnet *));\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic void\nkue_setmulti(sc)\n\tstruct kue_softc\t*sc;\n{\n\tstruct ifnet\t\t*ifp = GET_IFP(sc);\n#if defined(__FreeBSD__)\n\tstruct ifmultiaddr\t*ifma;\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n#endif\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev), __FUNCTION__));\n\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\tsc->kue_rxfilt |= KUE_RXFILT_ALLMULTI;\n\t\tsc->kue_rxfilt &= ~KUE_RXFILT_MULTICAST;\n\t\tkue_setword(sc, KUE_CMD_SET_PKT_FILTER, sc->kue_rxfilt);\n\t\treturn;\n\t}\n\n\tsc->kue_rxfilt &= ~KUE_RXFILT_ALLMULTI;\n\n\ti = 0;\n#if defined(__FreeBSD__)\n\tfor (ifma = ifp->if_multiaddrs.lh_first; ifma != NULL;\n\t    ifma = ifma->ifma_link.le_next) {\n\t\tif (ifma->ifma_addr->sa_family != AF_LINK)\n\t\t\tcontinue;\n\t\t/*\n\t\t * If there are too many addresses for the\n\t\t * internal filter, switch over to allmulti mode.\n\t\t */\n\t\tif (i == KUE_MCFILTCNT(sc))\n\t\t\tbreak;\n\t\tbcopy(LLADDR((struct sockaddr_dl *)ifma->ifma_addr),\n\t\t    KUE_MCFILT(sc, i), ETHER_ADDR_LEN);\n\t\ti++;\n\t}\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n#if defined (__NetBSD__)\n\tETHER_FIRST_MULTI(step, &sc->kue_ec, enm);\n#else\n\tETHER_FIRST_MULTI(step, &sc->arpcom, enm);\n#endif\n\twhile (enm != NULL) {\n\t\tif (i == KUE_MCFILTCNT(sc))\n\t\t\tbreak;\n#if 0\n\t\tif (memcmp(enm->enm_addrlo,\n\t\t\t   enm->enm_addrhi, ETHER_ADDR_LEN) != 0) {\n\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\t/* XXX what now? */\n\t\t\treturn;\n\t\t}\n#endif\n\t\tmemcpy(KUE_MCFILT(sc, i), enm->enm_addrlo, ETHER_ADDR_LEN);\n\t\tETHER_NEXT_MULTI(step, enm);\n\t\ti++;\n\t}\n#endif\n\n\tif (i == KUE_MCFILTCNT(sc))\n\t\tsc->kue_rxfilt |= KUE_RXFILT_ALLMULTI;\n\telse {\n\t\tsc->kue_rxfilt |= KUE_RXFILT_MULTICAST;\n\t\tkue_ctl(sc, KUE_CTL_WRITE, KUE_CMD_SET_MCAST_FILTERS,\n\t\t    i, sc->kue_mcfilters, i * ETHER_ADDR_LEN);\n\t}\n\n\tkue_setword(sc, KUE_CMD_SET_PKT_FILTER, sc->kue_rxfilt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: rx list init failed\\n\"",
            "USBDEVNAME(sc->kue_dev)"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kue_rx_list_init",
          "args": [
            "sc"
          ],
          "line": 1233
        },
        "resolved": true,
        "details": {
          "function_name": "kue_rx_list_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
          "lines": "825-853",
          "snippet": "Static int\nkue_rx_list_init(sc)\n\tstruct kue_softc\t*sc;\n{\n\tstruct kue_cdata\t*cd;\n\tstruct kue_chain\t*c;\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev), __FUNCTION__));\n\n\tcd = &sc->kue_cdata;\n\tfor (i = 0; i < KUE_RX_LIST_CNT; i++) {\n\t\tc = &cd->kue_rx_chain[i];\n\t\tc->kue_sc = sc;\n\t\tc->kue_idx = i;\n\t\tif (kue_newbuf(sc, c, NULL) == ENOBUFS)\n\t\t\treturn (ENOBUFS);\n\t\tif (c->kue_xfer == NULL) {\n\t\t\tc->kue_xfer = usbd_alloc_xfer(sc->kue_udev);\n\t\t\tif (c->kue_xfer == NULL)\n\t\t\t\treturn (ENOBUFS);\n\t\t\tc->kue_buf = usbd_alloc_buffer(c->kue_xfer, KUE_BUFSZ);\n\t\t\tif (c->kue_buf == NULL)\n\t\t\t\treturn (ENOBUFS); /* XXX free xfer */\n\t\t}\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/usb/kue_fw.h>",
            "#include <dev/usb/if_kuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "kue_tx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "kue_rx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "Static int",
            "Static int",
            "kue_open_pipes\t__P((struct kue_softc *));",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "kue_stop\t\t__P((struct kue_softc *));",
            "Static void",
            "Static void",
            "kue_setmulti\t__P((struct kue_softc *));",
            "Static void",
            "kue_reset\t\t__P((struct kue_softc *));",
            "Static int",
            "kue_is_warm\t\t__P((struct kue_softc *));",
            "Static int",
            "kue_load_fw\t\t__P((struct kue_softc *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nStatic int;\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic int\nkue_rx_list_init(sc)\n\tstruct kue_softc\t*sc;\n{\n\tstruct kue_cdata\t*cd;\n\tstruct kue_chain\t*c;\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev), __FUNCTION__));\n\n\tcd = &sc->kue_cdata;\n\tfor (i = 0; i < KUE_RX_LIST_CNT; i++) {\n\t\tc = &cd->kue_rx_chain[i];\n\t\tc->kue_sc = sc;\n\t\tc->kue_idx = i;\n\t\tif (kue_newbuf(sc, c, NULL) == ENOBUFS)\n\t\t\treturn (ENOBUFS);\n\t\tif (c->kue_xfer == NULL) {\n\t\t\tc->kue_xfer = usbd_alloc_xfer(sc->kue_udev);\n\t\t\tif (c->kue_xfer == NULL)\n\t\t\t\treturn (ENOBUFS);\n\t\t\tc->kue_buf = usbd_alloc_buffer(c->kue_xfer, KUE_BUFSZ);\n\t\t\tif (c->kue_buf == NULL)\n\t\t\t\treturn (ENOBUFS); /* XXX free xfer */\n\t\t}\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kue_tx_list_init",
          "args": [
            "sc"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "kue_tx_list_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
          "lines": "855-882",
          "snippet": "Static int\nkue_tx_list_init(sc)\n\tstruct kue_softc\t*sc;\n{\n\tstruct kue_cdata\t*cd;\n\tstruct kue_chain\t*c;\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev), __FUNCTION__));\n\n\tcd = &sc->kue_cdata;\n\tfor (i = 0; i < KUE_TX_LIST_CNT; i++) {\n\t\tc = &cd->kue_tx_chain[i];\n\t\tc->kue_sc = sc;\n\t\tc->kue_idx = i;\n\t\tc->kue_mbuf = NULL;\n\t\tif (c->kue_xfer == NULL) {\n\t\t\tc->kue_xfer = usbd_alloc_xfer(sc->kue_udev);\n\t\t\tif (c->kue_xfer == NULL)\n\t\t\t\treturn (ENOBUFS);\n\t\t\tc->kue_buf = usbd_alloc_buffer(c->kue_xfer, KUE_BUFSZ);\n\t\t\tif (c->kue_buf == NULL)\n\t\t\t\treturn (ENOBUFS);\n\t\t}\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/usb/kue_fw.h>",
            "#include <dev/usb/if_kuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "kue_tx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "kue_rx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "Static int",
            "Static int",
            "kue_open_pipes\t__P((struct kue_softc *));",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "kue_stop\t\t__P((struct kue_softc *));",
            "Static void",
            "Static void",
            "kue_setmulti\t__P((struct kue_softc *));",
            "Static void",
            "kue_reset\t\t__P((struct kue_softc *));",
            "Static int",
            "kue_is_warm\t\t__P((struct kue_softc *));",
            "Static int",
            "kue_load_fw\t\t__P((struct kue_softc *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nStatic int;\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic int\nkue_tx_list_init(sc)\n\tstruct kue_softc\t*sc;\n{\n\tstruct kue_cdata\t*cd;\n\tstruct kue_chain\t*c;\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev), __FUNCTION__));\n\n\tcd = &sc->kue_cdata;\n\tfor (i = 0; i < KUE_TX_LIST_CNT; i++) {\n\t\tc = &cd->kue_tx_chain[i];\n\t\tc->kue_sc = sc;\n\t\tc->kue_idx = i;\n\t\tc->kue_mbuf = NULL;\n\t\tif (c->kue_xfer == NULL) {\n\t\t\tc->kue_xfer = usbd_alloc_xfer(sc->kue_udev);\n\t\t\tif (c->kue_xfer == NULL)\n\t\t\t\treturn (ENOBUFS);\n\t\t\tc->kue_buf = usbd_alloc_buffer(c->kue_xfer, KUE_BUFSZ);\n\t\t\tif (c->kue_buf == NULL)\n\t\t\t\treturn (ENOBUFS);\n\t\t}\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kue_setword",
          "args": [
            "sc",
            "KUE_CMD_SET_URB_SIZE",
            "64"
          ],
          "line": 1223
        },
        "resolved": true,
        "details": {
          "function_name": "kue_setword",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
          "lines": "257-280",
          "snippet": "Static usbd_status\nkue_setword(sc, breq, word)\n\tstruct kue_softc\t*sc;\n\tu_int8_t\t\tbreq;\n\tu_int16_t\t\tword;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = breq;\n\tUSETW(req.wValue, word);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, 0);\n\n\ts = splusb();\n\terr = KUE_DO_REQUEST(sc->kue_udev, &req, NULL);\n\tsplx(s);\n\n\treturn (err);\n}",
          "includes": [
            "#include <dev/usb/kue_fw.h>",
            "#include <dev/usb/if_kuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "kue_tx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "kue_rx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "Static int",
            "Static int",
            "kue_open_pipes\t__P((struct kue_softc *));",
            "Static void",
            "kue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "kue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "kue_stop\t\t__P((struct kue_softc *));",
            "Static void",
            "Static void",
            "kue_setmulti\t__P((struct kue_softc *));",
            "Static void",
            "kue_reset\t\t__P((struct kue_softc *));",
            "Static usbd_status",
            "Static usbd_status",
            "kue_setword\t__P((struct kue_softc *, u_int8_t, u_int16_t));",
            "Static int",
            "kue_is_warm\t\t__P((struct kue_softc *));",
            "Static int",
            "kue_load_fw\t\t__P((struct kue_softc *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nStatic int;\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nkue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nkue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic usbd_status;\nStatic usbd_status;\nkue_setword\t__P((struct kue_softc *, u_int8_t, u_int16_t));\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic usbd_status\nkue_setword(sc, breq, word)\n\tstruct kue_softc\t*sc;\n\tu_int8_t\t\tbreq;\n\tu_int16_t\t\tword;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = breq;\n\tUSETW(req.wValue, word);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, 0);\n\n\ts = splusb();\n\terr = KUE_DO_REQUEST(sc->kue_udev, &req, NULL);\n\tsplx(s);\n\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kue_ctl",
          "args": [
            "sc",
            "KUE_CTL_WRITE",
            "KUE_CMD_SET_MAC",
            "0",
            "eaddr",
            "ETHER_ADDR_LEN"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "kue_ctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
          "lines": "282-313",
          "snippet": "Static usbd_status\nkue_ctl(sc, rw, breq, val, data, len)\n\tstruct kue_softc\t*sc;\n\tint\t\t\trw;\n\tu_int8_t\t\tbreq;\n\tu_int16_t\t\tval;\n\tvoid\t\t\t*data;\n\tu_int32_t\t\tlen;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\n\tDPRINTFN(10,(\"%s: %s: enter, len=%d\\n\", USBDEVNAME(sc->kue_dev),\n\t\t     __FUNCTION__, len));\n\n\tif (rw == KUE_CTL_WRITE)\n\t\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\telse\n\t\treq.bmRequestType = UT_READ_VENDOR_DEVICE;\n\n\treq.bRequest = breq;\n\tUSETW(req.wValue, val);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, len);\n\n\ts = splusb();\n\terr = KUE_DO_REQUEST(sc->kue_udev, &req, data);\n\tsplx(s);\n\n\treturn (err);\n}",
          "includes": [
            "#include <dev/usb/kue_fw.h>",
            "#include <dev/usb/if_kuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "kue_tx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "kue_rx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "Static int",
            "Static int",
            "kue_open_pipes\t__P((struct kue_softc *));",
            "Static void",
            "kue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "kue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "kue_stop\t\t__P((struct kue_softc *));",
            "Static void",
            "Static void",
            "kue_setmulti\t__P((struct kue_softc *));",
            "Static void",
            "kue_reset\t\t__P((struct kue_softc *));",
            "Static usbd_status",
            "kue_ctl\t__P((struct kue_softc *, int, u_int8_t,\n\t\t\t\t    u_int16_t, void *, u_int32_t));",
            "Static usbd_status",
            "kue_setword\t__P((struct kue_softc *, u_int8_t, u_int16_t));",
            "Static int",
            "kue_is_warm\t\t__P((struct kue_softc *));",
            "Static int",
            "kue_load_fw\t\t__P((struct kue_softc *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nStatic int;\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nkue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nkue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic usbd_status;\nkue_ctl\t__P((struct kue_softc *, int, u_int8_t,\n\t\t\t\t    u_int16_t, void *, u_int32_t));\nStatic usbd_status;\nkue_setword\t__P((struct kue_softc *, u_int8_t, u_int16_t));\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic usbd_status\nkue_ctl(sc, rw, breq, val, data, len)\n\tstruct kue_softc\t*sc;\n\tint\t\t\trw;\n\tu_int8_t\t\tbreq;\n\tu_int16_t\t\tval;\n\tvoid\t\t\t*data;\n\tu_int32_t\t\tlen;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\n\tDPRINTFN(10,(\"%s: %s: enter, len=%d\\n\", USBDEVNAME(sc->kue_dev),\n\t\t     __FUNCTION__, len));\n\n\tif (rw == KUE_CTL_WRITE)\n\t\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\telse\n\t\treq.bmRequestType = UT_READ_VENDOR_DEVICE;\n\n\treq.bRequest = breq;\n\tUSETW(req.wValue, val);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, len);\n\n\ts = splusb();\n\terr = KUE_DO_REQUEST(sc->kue_udev, &req, data);\n\tsplx(s);\n\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LLADDR",
          "args": [
            "ifp->if_sadl"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__)"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_IFP",
          "args": [
            "sc"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nStatic int;\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nStatic void;\nkue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nkue_watchdog\t\t__P((struct ifnet *));\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic void\nkue_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct kue_softc\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = GET_IFP(sc);\n\tint\t\t\ts;\n\tu_char\t\t\t*eaddr;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\treturn;\n\n\ts = splimp();\n\n#if defined(__FreeBSD__) || defined(__OpenBSD__)\n\teaddr = sc->arpcom.ac_enaddr;\n#elif defined(__NetBSD__)\n\teaddr = LLADDR(ifp->if_sadl);\n#endif /* defined(__NetBSD__) */\n\t/* Set MAC address */\n\tkue_ctl(sc, KUE_CTL_WRITE, KUE_CMD_SET_MAC, 0, eaddr, ETHER_ADDR_LEN);\n\n\tsc->kue_rxfilt = KUE_RXFILT_UNICAST | KUE_RXFILT_BROADCAST;\n\n\t /* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tsc->kue_rxfilt |= KUE_RXFILT_PROMISC;\n\n\tkue_setword(sc, KUE_CMD_SET_PKT_FILTER, sc->kue_rxfilt);\n\n\t/* I'm not sure how to tune these. */\n#if 0\n\t/*\n\t * Leave this one alone for now; setting it\n\t * wrong causes lockups on some machines/controllers.\n\t */\n\tkue_setword(sc, KUE_CMD_SET_SOFS, 1);\n#endif\n\tkue_setword(sc, KUE_CMD_SET_URB_SIZE, 64);\n\n\t/* Init TX ring. */\n\tif (kue_tx_list_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: tx list init failed\\n\", USBDEVNAME(sc->kue_dev));\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Init RX ring. */\n\tif (kue_rx_list_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: rx list init failed\\n\", USBDEVNAME(sc->kue_dev));\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Load the multicast filter. */\n\tkue_setmulti(sc);\n\n\tif (sc->kue_ep[KUE_ENDPT_RX] == NULL) {\n\t\tif (kue_open_pipes(sc)) {\n\t\t\tsplx(s);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "kue_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
    "lines": "1141-1181",
    "snippet": "Static void\nkue_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct kue_softc\t*sc = ifp->if_softc;\n\tstruct mbuf\t\t*m_head = NULL;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\tif (sc->kue_dying)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\tif (m_head == NULL)\n\t\treturn;\n\n\tif (kue_send(sc, m_head, 0)) {\n\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\n#if NBPFILTER > 0\n\t/*\n\t * If there's a BPF listener, bounce a copy of this frame\n\t * to him.\n\t */\n\tif (ifp->if_bpf)\n\t\tBPF_MTAP(ifp, m_head);\n#endif\n\n\tifp->if_flags |= IFF_OACTIVE;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n}",
    "includes": [
      "#include <dev/usb/kue_fw.h>",
      "#include <dev/usb/if_kuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "kue_tx_list_init\t__P((struct kue_softc *));",
      "Static int",
      "kue_rx_list_init\t__P((struct kue_softc *));",
      "Static int",
      "kue_newbuf\t\t__P((struct kue_softc *, struct kue_chain *,\n\t\t\t\t    struct mbuf *));",
      "Static int",
      "kue_send\t\t__P((struct kue_softc *, struct mbuf *, int));",
      "Static int",
      "kue_open_pipes\t__P((struct kue_softc *));",
      "Static void",
      "Static void",
      "Static void",
      "kue_start\t\t__P((struct ifnet *));",
      "Static int",
      "Static void",
      "Static void",
      "kue_stop\t\t__P((struct kue_softc *));",
      "Static void",
      "kue_watchdog\t\t__P((struct ifnet *));",
      "Static void",
      "kue_setmulti\t__P((struct kue_softc *));",
      "Static void",
      "kue_reset\t\t__P((struct kue_softc *));",
      "Static int",
      "kue_is_warm\t\t__P((struct kue_softc *));",
      "Static int",
      "kue_load_fw\t\t__P((struct kue_softc *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BPF_MTAP",
          "args": [
            "ifp",
            "m_head"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_PREPEND",
          "args": [
            "&ifp->if_snd",
            "m_head"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kue_send",
          "args": [
            "sc",
            "m_head",
            "0"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "kue_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
          "lines": "1095-1139",
          "snippet": "Static int\nkue_send(sc, m, idx)\n\tstruct kue_softc\t*sc;\n\tstruct mbuf\t\t*m;\n\tint\t\t\tidx;\n{\n\tint\t\t\ttotal_len;\n\tstruct kue_chain\t*c;\n\tusbd_status\t\terr;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\tc = &sc->kue_cdata.kue_tx_chain[idx];\n\n\t/*\n\t * Copy the mbuf data into a contiguous buffer, leaving two\n\t * bytes at the beginning to hold the frame length.\n\t */\n\tm_copydata(m, 0, m->m_pkthdr.len, c->kue_buf + 2);\n\tc->kue_mbuf = m;\n\n\ttotal_len = m->m_pkthdr.len + 2;\n\t/* XXX what's this? */\n\ttotal_len += 64 - (total_len % 64);\n\n\t/* Frame length is specified in the first 2 bytes of the buffer. */\n\tc->kue_buf[0] = (u_int8_t)m->m_pkthdr.len;\n\tc->kue_buf[1] = (u_int8_t)(m->m_pkthdr.len >> 8);\n\n\tusbd_setup_xfer(c->kue_xfer, sc->kue_ep[KUE_ENDPT_TX],\n\t    c, c->kue_buf, total_len, USBD_NO_COPY, USBD_DEFAULT_TIMEOUT, kue_txeof);\n\n\t/* Transmit */\n\terr = usbd_transfer(c->kue_xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tprintf(\"%s: kue_send error=%s\\n\", USBDEVNAME(sc->kue_dev),\n\t\t       usbd_errstr(err));\n\t\tkue_stop(sc);\n\t\treturn (EIO);\n\t}\n\n\tsc->kue_cdata.kue_tx_cnt++;\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/usb/kue_fw.h>",
            "#include <dev/usb/if_kuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "kue_tx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "kue_rx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "kue_newbuf\t\t__P((struct kue_softc *, struct kue_chain *,\n\t\t\t\t    struct mbuf *));",
            "Static int",
            "kue_send\t\t__P((struct kue_softc *, struct mbuf *, int));",
            "Static int",
            "kue_open_pipes\t__P((struct kue_softc *));",
            "Static void",
            "kue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "kue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "kue_stop\t\t__P((struct kue_softc *));",
            "Static void",
            "Static void",
            "kue_setmulti\t__P((struct kue_softc *));",
            "Static void",
            "kue_reset\t\t__P((struct kue_softc *));",
            "Static usbd_status",
            "Static usbd_status",
            "Static int",
            "kue_is_warm\t\t__P((struct kue_softc *));",
            "Static int",
            "kue_load_fw\t\t__P((struct kue_softc *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_newbuf\t\t__P((struct kue_softc *, struct kue_chain *,\n\t\t\t\t    struct mbuf *));\nStatic int;\nkue_send\t\t__P((struct kue_softc *, struct mbuf *, int));\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nkue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nkue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic usbd_status;\nStatic usbd_status;\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic int\nkue_send(sc, m, idx)\n\tstruct kue_softc\t*sc;\n\tstruct mbuf\t\t*m;\n\tint\t\t\tidx;\n{\n\tint\t\t\ttotal_len;\n\tstruct kue_chain\t*c;\n\tusbd_status\t\terr;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\tc = &sc->kue_cdata.kue_tx_chain[idx];\n\n\t/*\n\t * Copy the mbuf data into a contiguous buffer, leaving two\n\t * bytes at the beginning to hold the frame length.\n\t */\n\tm_copydata(m, 0, m->m_pkthdr.len, c->kue_buf + 2);\n\tc->kue_mbuf = m;\n\n\ttotal_len = m->m_pkthdr.len + 2;\n\t/* XXX what's this? */\n\ttotal_len += 64 - (total_len % 64);\n\n\t/* Frame length is specified in the first 2 bytes of the buffer. */\n\tc->kue_buf[0] = (u_int8_t)m->m_pkthdr.len;\n\tc->kue_buf[1] = (u_int8_t)(m->m_pkthdr.len >> 8);\n\n\tusbd_setup_xfer(c->kue_xfer, sc->kue_ep[KUE_ENDPT_TX],\n\t    c, c->kue_buf, total_len, USBD_NO_COPY, USBD_DEFAULT_TIMEOUT, kue_txeof);\n\n\t/* Transmit */\n\terr = usbd_transfer(c->kue_xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tprintf(\"%s: kue_send error=%s\\n\", USBDEVNAME(sc->kue_dev),\n\t\t       usbd_errstr(err));\n\t\tkue_stop(sc);\n\t\treturn (EIO);\n\t}\n\n\tsc->kue_cdata.kue_tx_cnt++;\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "m_head"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__)"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_newbuf\t\t__P((struct kue_softc *, struct kue_chain *,\n\t\t\t\t    struct mbuf *));\nStatic int;\nkue_send\t\t__P((struct kue_softc *, struct mbuf *, int));\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nStatic void;\nkue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nkue_watchdog\t\t__P((struct ifnet *));\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic void\nkue_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct kue_softc\t*sc = ifp->if_softc;\n\tstruct mbuf\t\t*m_head = NULL;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\tif (sc->kue_dying)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\tif (m_head == NULL)\n\t\treturn;\n\n\tif (kue_send(sc, m_head, 0)) {\n\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\n#if NBPFILTER > 0\n\t/*\n\t * If there's a BPF listener, bounce a copy of this frame\n\t * to him.\n\t */\n\tif (ifp->if_bpf)\n\t\tBPF_MTAP(ifp, m_head);\n#endif\n\n\tifp->if_flags |= IFF_OACTIVE;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n}"
  },
  {
    "function_name": "kue_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
    "lines": "1095-1139",
    "snippet": "Static int\nkue_send(sc, m, idx)\n\tstruct kue_softc\t*sc;\n\tstruct mbuf\t\t*m;\n\tint\t\t\tidx;\n{\n\tint\t\t\ttotal_len;\n\tstruct kue_chain\t*c;\n\tusbd_status\t\terr;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\tc = &sc->kue_cdata.kue_tx_chain[idx];\n\n\t/*\n\t * Copy the mbuf data into a contiguous buffer, leaving two\n\t * bytes at the beginning to hold the frame length.\n\t */\n\tm_copydata(m, 0, m->m_pkthdr.len, c->kue_buf + 2);\n\tc->kue_mbuf = m;\n\n\ttotal_len = m->m_pkthdr.len + 2;\n\t/* XXX what's this? */\n\ttotal_len += 64 - (total_len % 64);\n\n\t/* Frame length is specified in the first 2 bytes of the buffer. */\n\tc->kue_buf[0] = (u_int8_t)m->m_pkthdr.len;\n\tc->kue_buf[1] = (u_int8_t)(m->m_pkthdr.len >> 8);\n\n\tusbd_setup_xfer(c->kue_xfer, sc->kue_ep[KUE_ENDPT_TX],\n\t    c, c->kue_buf, total_len, USBD_NO_COPY, USBD_DEFAULT_TIMEOUT, kue_txeof);\n\n\t/* Transmit */\n\terr = usbd_transfer(c->kue_xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tprintf(\"%s: kue_send error=%s\\n\", USBDEVNAME(sc->kue_dev),\n\t\t       usbd_errstr(err));\n\t\tkue_stop(sc);\n\t\treturn (EIO);\n\t}\n\n\tsc->kue_cdata.kue_tx_cnt++;\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/kue_fw.h>",
      "#include <dev/usb/if_kuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "kue_tx_list_init\t__P((struct kue_softc *));",
      "Static int",
      "kue_rx_list_init\t__P((struct kue_softc *));",
      "Static int",
      "kue_newbuf\t\t__P((struct kue_softc *, struct kue_chain *,\n\t\t\t\t    struct mbuf *));",
      "Static int",
      "kue_send\t\t__P((struct kue_softc *, struct mbuf *, int));",
      "Static int",
      "kue_open_pipes\t__P((struct kue_softc *));",
      "Static void",
      "kue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "kue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "kue_stop\t\t__P((struct kue_softc *));",
      "Static void",
      "Static void",
      "kue_setmulti\t__P((struct kue_softc *));",
      "Static void",
      "kue_reset\t\t__P((struct kue_softc *));",
      "Static usbd_status",
      "Static usbd_status",
      "Static int",
      "kue_is_warm\t\t__P((struct kue_softc *));",
      "Static int",
      "kue_load_fw\t\t__P((struct kue_softc *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kue_stop",
          "args": [
            "sc"
          ],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "kue_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
          "lines": "1437-1518",
          "snippet": "Static void\nkue_stop(sc)\n\tstruct kue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\tifp = GET_IFP(sc);\n\tifp->if_timer = 0;\n\n\t/* Stop transfers. */\n\tif (sc->kue_ep[KUE_ENDPT_RX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->kue_ep[KUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort rx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->kue_ep[KUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close rx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->kue_ep[KUE_ENDPT_RX] = NULL;\n\t}\n\n\tif (sc->kue_ep[KUE_ENDPT_TX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->kue_ep[KUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->kue_ep[KUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->kue_ep[KUE_ENDPT_TX] = NULL;\n\t}\n\n\tif (sc->kue_ep[KUE_ENDPT_INTR] != NULL) {\n\t\terr = usbd_abort_pipe(sc->kue_ep[KUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->kue_ep[KUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->kue_ep[KUE_ENDPT_INTR] = NULL;\n\t}\n\n\t/* Free RX resources. */\n\tfor (i = 0; i < KUE_RX_LIST_CNT; i++) {\n\t\tif (sc->kue_cdata.kue_rx_chain[i].kue_mbuf != NULL) {\n\t\t\tm_freem(sc->kue_cdata.kue_rx_chain[i].kue_mbuf);\n\t\t\tsc->kue_cdata.kue_rx_chain[i].kue_mbuf = NULL;\n\t\t}\n\t\tif (sc->kue_cdata.kue_rx_chain[i].kue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->kue_cdata.kue_rx_chain[i].kue_xfer);\n\t\t\tsc->kue_cdata.kue_rx_chain[i].kue_xfer = NULL;\n\t\t}\n\t}\n\n\t/* Free TX resources. */\n\tfor (i = 0; i < KUE_TX_LIST_CNT; i++) {\n\t\tif (sc->kue_cdata.kue_tx_chain[i].kue_mbuf != NULL) {\n\t\t\tm_freem(sc->kue_cdata.kue_tx_chain[i].kue_mbuf);\n\t\t\tsc->kue_cdata.kue_tx_chain[i].kue_mbuf = NULL;\n\t\t}\n\t\tif (sc->kue_cdata.kue_tx_chain[i].kue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->kue_cdata.kue_tx_chain[i].kue_xfer);\n\t\t\tsc->kue_cdata.kue_tx_chain[i].kue_xfer = NULL;\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n}",
          "includes": [
            "#include <dev/usb/kue_fw.h>",
            "#include <dev/usb/if_kuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "kue_tx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "kue_rx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "Static int",
            "Static int",
            "kue_open_pipes\t__P((struct kue_softc *));",
            "Static void",
            "kue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "kue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "kue_start\t\t__P((struct ifnet *));",
            "Static int",
            "Static void",
            "Static void",
            "kue_stop\t\t__P((struct kue_softc *));",
            "Static void",
            "kue_watchdog\t\t__P((struct ifnet *));",
            "Static void",
            "kue_setmulti\t__P((struct kue_softc *));",
            "Static void",
            "kue_reset\t\t__P((struct kue_softc *));",
            "Static usbd_status",
            "Static usbd_status",
            "Static int",
            "kue_is_warm\t\t__P((struct kue_softc *));",
            "Static int",
            "kue_load_fw\t\t__P((struct kue_softc *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nStatic int;\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nkue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nkue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nkue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nkue_watchdog\t\t__P((struct ifnet *));\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic usbd_status;\nStatic usbd_status;\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic void\nkue_stop(sc)\n\tstruct kue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\tifp = GET_IFP(sc);\n\tifp->if_timer = 0;\n\n\t/* Stop transfers. */\n\tif (sc->kue_ep[KUE_ENDPT_RX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->kue_ep[KUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort rx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->kue_ep[KUE_ENDPT_RX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close rx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->kue_ep[KUE_ENDPT_RX] = NULL;\n\t}\n\n\tif (sc->kue_ep[KUE_ENDPT_TX] != NULL) {\n\t\terr = usbd_abort_pipe(sc->kue_ep[KUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->kue_ep[KUE_ENDPT_TX]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close tx pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->kue_ep[KUE_ENDPT_TX] = NULL;\n\t}\n\n\tif (sc->kue_ep[KUE_ENDPT_INTR] != NULL) {\n\t\terr = usbd_abort_pipe(sc->kue_ep[KUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: abort intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\terr = usbd_close_pipe(sc->kue_ep[KUE_ENDPT_INTR]);\n\t\tif (err) {\n\t\t\tprintf(\"%s: close intr pipe failed: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t}\n\t\tsc->kue_ep[KUE_ENDPT_INTR] = NULL;\n\t}\n\n\t/* Free RX resources. */\n\tfor (i = 0; i < KUE_RX_LIST_CNT; i++) {\n\t\tif (sc->kue_cdata.kue_rx_chain[i].kue_mbuf != NULL) {\n\t\t\tm_freem(sc->kue_cdata.kue_rx_chain[i].kue_mbuf);\n\t\t\tsc->kue_cdata.kue_rx_chain[i].kue_mbuf = NULL;\n\t\t}\n\t\tif (sc->kue_cdata.kue_rx_chain[i].kue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->kue_cdata.kue_rx_chain[i].kue_xfer);\n\t\t\tsc->kue_cdata.kue_rx_chain[i].kue_xfer = NULL;\n\t\t}\n\t}\n\n\t/* Free TX resources. */\n\tfor (i = 0; i < KUE_TX_LIST_CNT; i++) {\n\t\tif (sc->kue_cdata.kue_tx_chain[i].kue_mbuf != NULL) {\n\t\t\tm_freem(sc->kue_cdata.kue_tx_chain[i].kue_mbuf);\n\t\t\tsc->kue_cdata.kue_tx_chain[i].kue_mbuf = NULL;\n\t\t}\n\t\tif (sc->kue_cdata.kue_tx_chain[i].kue_xfer != NULL) {\n\t\t\tusbd_free_xfer(sc->kue_cdata.kue_tx_chain[i].kue_xfer);\n\t\t\tsc->kue_cdata.kue_tx_chain[i].kue_xfer = NULL;\n\t\t}\n\t}\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: kue_send error=%s\\n\"",
            "USBDEVNAME(sc->kue_dev)",
            "usbd_errstr(err)"
          ],
          "line": 1130
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_transfer",
          "args": [
            "c->kue_xfer"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "254-339",
          "snippet": "usbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "u_int32_t size;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nu_int32_t size;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_setup_xfer",
          "args": [
            "c->kue_xfer",
            "sc->kue_ep[KUE_ENDPT_TX]",
            "c",
            "c->kue_buf",
            "total_len",
            "USBD_NO_COPY",
            "USBD_DEFAULT_TIMEOUT",
            "kue_txeof"
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_setup_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "420-444",
          "snippet": "void\nusbd_setup_xfer(xfer, pipe, priv, buffer, length, flags, timeout, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t length;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid (*callback) __P((usbd_xfer_handle,\n\t\t\t      usbd_private_handle,\n\t\t\t      usbd_status));\n{\n\txfer->pipe = pipe;\n\txfer->priv = priv;\n\txfer->buffer = buffer;\n\txfer->length = length;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = timeout;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->rqflags &= ~URQ_REQUEST;\n\txfer->nframes = 0;\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nvoid\nusbd_setup_xfer(xfer, pipe, priv, buffer, length, flags, timeout, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t length;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid (*callback) __P((usbd_xfer_handle,\n\t\t\t      usbd_private_handle,\n\t\t\t      usbd_status));\n{\n\txfer->pipe = pipe;\n\txfer->priv = priv;\n\txfer->buffer = buffer;\n\txfer->length = length;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = timeout;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->rqflags &= ~URQ_REQUEST;\n\txfer->nframes = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "m->m_pkthdr.len >> 8"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_copydata",
          "args": [
            "m",
            "0",
            "m->m_pkthdr.len",
            "c->kue_buf + 2"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__)"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_newbuf\t\t__P((struct kue_softc *, struct kue_chain *,\n\t\t\t\t    struct mbuf *));\nStatic int;\nkue_send\t\t__P((struct kue_softc *, struct mbuf *, int));\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nkue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nkue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic usbd_status;\nStatic usbd_status;\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic int\nkue_send(sc, m, idx)\n\tstruct kue_softc\t*sc;\n\tstruct mbuf\t\t*m;\n\tint\t\t\tidx;\n{\n\tint\t\t\ttotal_len;\n\tstruct kue_chain\t*c;\n\tusbd_status\t\terr;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\tc = &sc->kue_cdata.kue_tx_chain[idx];\n\n\t/*\n\t * Copy the mbuf data into a contiguous buffer, leaving two\n\t * bytes at the beginning to hold the frame length.\n\t */\n\tm_copydata(m, 0, m->m_pkthdr.len, c->kue_buf + 2);\n\tc->kue_mbuf = m;\n\n\ttotal_len = m->m_pkthdr.len + 2;\n\t/* XXX what's this? */\n\ttotal_len += 64 - (total_len % 64);\n\n\t/* Frame length is specified in the first 2 bytes of the buffer. */\n\tc->kue_buf[0] = (u_int8_t)m->m_pkthdr.len;\n\tc->kue_buf[1] = (u_int8_t)(m->m_pkthdr.len >> 8);\n\n\tusbd_setup_xfer(c->kue_xfer, sc->kue_ep[KUE_ENDPT_TX],\n\t    c, c->kue_buf, total_len, USBD_NO_COPY, USBD_DEFAULT_TIMEOUT, kue_txeof);\n\n\t/* Transmit */\n\terr = usbd_transfer(c->kue_xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tprintf(\"%s: kue_send error=%s\\n\", USBDEVNAME(sc->kue_dev),\n\t\t       usbd_errstr(err));\n\t\tkue_stop(sc);\n\t\treturn (EIO);\n\t}\n\n\tsc->kue_cdata.kue_tx_cnt++;\n\n\treturn (0);\n}"
  },
  {
    "function_name": "kue_txeof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
    "lines": "1042-1093",
    "snippet": "Static void\nkue_txeof(xfer, priv, status)\n\tusbd_xfer_handle\txfer;\n\tusbd_private_handle\tpriv;\n\tusbd_status\t\tstatus;\n{\n\tstruct kue_chain\t*c = priv;\n\tstruct kue_softc\t*sc = c->kue_sc;\n\tstruct ifnet\t\t*ifp = GET_IFP(sc);\n\tint\t\t\ts;\n\n\tif (sc->kue_dying)\n\t\treturn;\n\n\ts = splimp();\n\n\tDPRINTFN(10,(\"%s: %s: enter status=%d\\n\", USBDEVNAME(sc->kue_dev),\n\t\t    __FUNCTION__, status));\n\n\tifp->if_timer = 0;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tif (status != USBD_NORMAL_COMPLETION) {\n\t\tif (status == USBD_NOT_STARTED || status == USBD_CANCELLED) {\n\t\t\tsplx(s);\n\t\t\treturn;\n\t\t}\n\t\tifp->if_oerrors++;\n\t\tprintf(\"%s: usb error on tx: %s\\n\", USBDEVNAME(sc->kue_dev),\n\t\t    usbd_errstr(status));\n\t\tif (status == USBD_STALLED)\n\t\t\tusbd_clear_endpoint_stall(sc->kue_ep[KUE_ENDPT_TX]);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\tifp->if_opackets++;\n\n#if defined(__FreeBSD__)\n\tc->kue_mbuf->m_pkthdr.rcvif = ifp;\n\tusb_tx_done(c->kue_mbuf);\n\tc->kue_mbuf = NULL;\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n\tm_freem(c->kue_mbuf);\n\tc->kue_mbuf = NULL;\n\n\tif (ifp->if_snd.ifq_head != NULL)\n\t\tkue_start(ifp);\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/usb/kue_fw.h>",
      "#include <dev/usb/if_kuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "kue_tx_list_init\t__P((struct kue_softc *));",
      "Static int",
      "kue_rx_list_init\t__P((struct kue_softc *));",
      "Static int",
      "Static int",
      "Static int",
      "kue_open_pipes\t__P((struct kue_softc *));",
      "Static void",
      "kue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "kue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "kue_start\t\t__P((struct ifnet *));",
      "Static int",
      "Static void",
      "Static void",
      "kue_stop\t\t__P((struct kue_softc *));",
      "Static void",
      "kue_watchdog\t\t__P((struct ifnet *));",
      "Static void",
      "kue_setmulti\t__P((struct kue_softc *));",
      "Static void",
      "kue_reset\t\t__P((struct kue_softc *));",
      "Static usbd_status",
      "Static usbd_status",
      "Static int",
      "kue_is_warm\t\t__P((struct kue_softc *));",
      "Static int",
      "kue_load_fw\t\t__P((struct kue_softc *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kue_start",
          "args": [
            "ifp"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "kue_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
          "lines": "1141-1181",
          "snippet": "Static void\nkue_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct kue_softc\t*sc = ifp->if_softc;\n\tstruct mbuf\t\t*m_head = NULL;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\tif (sc->kue_dying)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\tif (m_head == NULL)\n\t\treturn;\n\n\tif (kue_send(sc, m_head, 0)) {\n\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\n#if NBPFILTER > 0\n\t/*\n\t * If there's a BPF listener, bounce a copy of this frame\n\t * to him.\n\t */\n\tif (ifp->if_bpf)\n\t\tBPF_MTAP(ifp, m_head);\n#endif\n\n\tifp->if_flags |= IFF_OACTIVE;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n}",
          "includes": [
            "#include <dev/usb/kue_fw.h>",
            "#include <dev/usb/if_kuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "kue_tx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "kue_rx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "kue_newbuf\t\t__P((struct kue_softc *, struct kue_chain *,\n\t\t\t\t    struct mbuf *));",
            "Static int",
            "kue_send\t\t__P((struct kue_softc *, struct mbuf *, int));",
            "Static int",
            "kue_open_pipes\t__P((struct kue_softc *));",
            "Static void",
            "Static void",
            "Static void",
            "kue_start\t\t__P((struct ifnet *));",
            "Static int",
            "Static void",
            "Static void",
            "kue_stop\t\t__P((struct kue_softc *));",
            "Static void",
            "kue_watchdog\t\t__P((struct ifnet *));",
            "Static void",
            "kue_setmulti\t__P((struct kue_softc *));",
            "Static void",
            "kue_reset\t\t__P((struct kue_softc *));",
            "Static int",
            "kue_is_warm\t\t__P((struct kue_softc *));",
            "Static int",
            "kue_load_fw\t\t__P((struct kue_softc *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_newbuf\t\t__P((struct kue_softc *, struct kue_chain *,\n\t\t\t\t    struct mbuf *));\nStatic int;\nkue_send\t\t__P((struct kue_softc *, struct mbuf *, int));\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nStatic void;\nkue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nkue_watchdog\t\t__P((struct ifnet *));\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic void\nkue_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct kue_softc\t*sc = ifp->if_softc;\n\tstruct mbuf\t\t*m_head = NULL;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\tif (sc->kue_dying)\n\t\treturn;\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\tif (m_head == NULL)\n\t\treturn;\n\n\tif (kue_send(sc, m_head, 0)) {\n\t\tIF_PREPEND(&ifp->if_snd, m_head);\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\n#if NBPFILTER > 0\n\t/*\n\t * If there's a BPF listener, bounce a copy of this frame\n\t * to him.\n\t */\n\tif (ifp->if_bpf)\n\t\tBPF_MTAP(ifp, m_head);\n#endif\n\n\tifp->if_flags |= IFF_OACTIVE;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "c->kue_mbuf"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_tx_done",
          "args": [
            "c->kue_mbuf"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_clear_endpoint_stall",
          "args": [
            "sc->kue_ep[KUE_ENDPT_TX]"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_clear_endpoint_stall_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "611-628",
          "snippet": "usbd_status \nusbd_clear_endpoint_stall_async(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_device_handle dev = pipe->device;\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\tpipe->methods->cleartoggle(pipe);\n\n\treq.bmRequestType = UT_WRITE_ENDPOINT;\n\treq.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(req.wValue, UF_ENDPOINT_HALT);\n\tUSETW(req.wIndex, pipe->endpoint->edesc->bEndpointAddress);\n\tUSETW(req.wLength, 0);\n\terr = usbd_do_request_async(dev, &req, 0);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_status \nusbd_clear_endpoint_stall_async(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_device_handle dev = pipe->device;\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\tpipe->methods->cleartoggle(pipe);\n\n\treq.bmRequestType = UT_WRITE_ENDPOINT;\n\treq.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(req.wValue, UF_ENDPOINT_HALT);\n\tUSETW(req.wIndex, pipe->endpoint->edesc->bEndpointAddress);\n\tUSETW(req.wLength, 0);\n\terr = usbd_do_request_async(dev, &req, 0);\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: usb error on tx: %s\\n\"",
            "USBDEVNAME(sc->kue_dev)",
            "usbd_errstr(status)"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "status"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"%s: %s: enter status=%d\\n\", USBDEVNAME(sc->kue_dev),\n\t\t    __FUNCTION__, status)"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_IFP",
          "args": [
            "sc"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nStatic int;\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nkue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nkue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nkue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nkue_watchdog\t\t__P((struct ifnet *));\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic usbd_status;\nStatic usbd_status;\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic void\nkue_txeof(xfer, priv, status)\n\tusbd_xfer_handle\txfer;\n\tusbd_private_handle\tpriv;\n\tusbd_status\t\tstatus;\n{\n\tstruct kue_chain\t*c = priv;\n\tstruct kue_softc\t*sc = c->kue_sc;\n\tstruct ifnet\t\t*ifp = GET_IFP(sc);\n\tint\t\t\ts;\n\n\tif (sc->kue_dying)\n\t\treturn;\n\n\ts = splimp();\n\n\tDPRINTFN(10,(\"%s: %s: enter status=%d\\n\", USBDEVNAME(sc->kue_dev),\n\t\t    __FUNCTION__, status));\n\n\tifp->if_timer = 0;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tif (status != USBD_NORMAL_COMPLETION) {\n\t\tif (status == USBD_NOT_STARTED || status == USBD_CANCELLED) {\n\t\t\tsplx(s);\n\t\t\treturn;\n\t\t}\n\t\tifp->if_oerrors++;\n\t\tprintf(\"%s: usb error on tx: %s\\n\", USBDEVNAME(sc->kue_dev),\n\t\t    usbd_errstr(status));\n\t\tif (status == USBD_STALLED)\n\t\t\tusbd_clear_endpoint_stall(sc->kue_ep[KUE_ENDPT_TX]);\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\tifp->if_opackets++;\n\n#if defined(__FreeBSD__)\n\tc->kue_mbuf->m_pkthdr.rcvif = ifp;\n\tusb_tx_done(c->kue_mbuf);\n\tc->kue_mbuf = NULL;\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n\tm_freem(c->kue_mbuf);\n\tc->kue_mbuf = NULL;\n\n\tif (ifp->if_snd.ifq_head != NULL)\n\t\tkue_start(ifp);\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "kue_rxeof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
    "lines": "912-1035",
    "snippet": "Static void\nkue_rxeof(xfer, priv, status)\n\tusbd_xfer_handle\txfer;\n\tusbd_private_handle\tpriv;\n\tusbd_status\t\tstatus;\n{\n\tstruct kue_chain\t*c = priv;\n\tstruct kue_softc\t*sc = c->kue_sc;\n\tstruct ifnet\t\t*ifp = GET_IFP(sc);\n\tstruct mbuf\t\t*m;\n\tint\t\t\ttotal_len = 0;\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\tint\t\t\ts;\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\n\tDPRINTFN(10,(\"%s: %s: enter status=%d\\n\", USBDEVNAME(sc->kue_dev),\n\t\t     __FUNCTION__, status));\n\n\tif (sc->kue_dying)\n\t\treturn;\n\n\tif (!(ifp->if_flags & IFF_RUNNING))\n\t\treturn;\n\n\tif (status != USBD_NORMAL_COMPLETION) {\n\t\tif (status == USBD_NOT_STARTED || status == USBD_CANCELLED)\n\t\t\treturn;\n\t\tsc->kue_rx_errs++;\n\t\tif (usbd_ratecheck(&sc->kue_rx_notice)) {\n\t\t\tprintf(\"%s: %u usb errors on rx: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), sc->kue_rx_errs,\n\t\t\t    usbd_errstr(status));\n\t\t\tsc->kue_rx_errs = 0;\n\t\t}\n\t\tif (status == USBD_STALLED)\n\t\t\tusbd_clear_endpoint_stall(sc->kue_ep[KUE_ENDPT_RX]);\n\t\tgoto done;\n\t}\n\n\tusbd_get_xfer_status(xfer, NULL, NULL, &total_len, NULL);\n\n\tDPRINTFN(10,(\"%s: %s: total_len=%d len=%d\\n\", USBDEVNAME(sc->kue_dev),\n\t\t     __FUNCTION__, total_len, \n\t\t     UGETW(mtod(c->kue_mbuf, u_int8_t *))));\n\n\tif (total_len <= 1)\n\t\tgoto done;\n\n\tm = c->kue_mbuf;\n\t/* copy data to mbuf */\n\tmemcpy(mtod(m, char*), c->kue_buf, total_len);\n\n\t/* No errors; receive the packet. */\n\ttotal_len = UGETW(mtod(m, u_int8_t *));\n\tm_adj(m, sizeof(u_int16_t));\n\n\tif (total_len < sizeof(struct ether_header)) {\n\t\tifp->if_ierrors++;\n\t\tgoto done;\n\t}\n\n\tifp->if_ipackets++;\n\tm->m_pkthdr.len = m->m_len = total_len;\n\n#if defined(__FreeBSD__)\n\tm->m_pkthdr.rcvif = (struct ifnet *)&kue_qdat;\n\t/* Put the packet on the special USB input queue. */\n\tusb_ether_input(m);\n\n\treturn;\n\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n\tm->m_pkthdr.rcvif = ifp;\n\n\ts = splimp();\n\n\t/* XXX ugly */\n\tif (kue_newbuf(sc, c, NULL) == ENOBUFS) {\n\t\tifp->if_ierrors++;\n\t\tgoto done1;\n\t}\n\n#if NBPFILTER > 0\n\t/*\n\t * Handle BPF listeners. Let the BPF user see the packet, but\n\t * don't pass it up to the ether_input() layer unless it's\n\t * a broadcast packet, multicast packet, matches our ethernet\n\t * address or the interface is in promiscuous mode.\n\t */\n\tif (ifp->if_bpf) {\n#if defined(__NetBSD__)\n\t\tstruct ether_header *eh = mtod(m, struct ether_header *);\n\t\tBPF_MTAP(ifp, m);\n\t\tif ((ifp->if_flags & IFF_PROMISC) &&\n\t\t    memcmp(eh->ether_dhost, LLADDR(ifp->if_sadl),\n\t\t\t   ETHER_ADDR_LEN) &&\n\t\t    !(eh->ether_dhost[0] & 1)) {\n\t\t\tm_freem(m);\n\t\t\tgoto done1;\n\t\t}\n#else\n\t\tBPF_MTAP(ifp, m);\n#endif\n\t}\n#endif\n\n\tDPRINTFN(10,(\"%s: %s: deliver %d\\n\", USBDEVNAME(sc->kue_dev),\n\t\t    __FUNCTION__, m->m_len));\n\tIF_INPUT(ifp, m);\n done1:\n\tsplx(s);\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\n done:\n\n\t/* Setup new transfer. */\n\tusbd_setup_xfer(c->kue_xfer, sc->kue_ep[KUE_ENDPT_RX],\n\t    c, c->kue_buf, KUE_BUFSZ, USBD_SHORT_XFER_OK | USBD_NO_COPY,\n\t    USBD_NO_TIMEOUT, kue_rxeof);\n\tusbd_transfer(c->kue_xfer);\n\n\tDPRINTFN(10,(\"%s: %s: start rx\\n\", USBDEVNAME(sc->kue_dev),\n\t\t    __FUNCTION__));\n}",
    "includes": [
      "#include <dev/usb/kue_fw.h>",
      "#include <dev/usb/if_kuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "kue_tx_list_init\t__P((struct kue_softc *));",
      "Static int",
      "kue_rx_list_init\t__P((struct kue_softc *));",
      "Static int",
      "kue_newbuf\t\t__P((struct kue_softc *, struct kue_chain *,\n\t\t\t\t    struct mbuf *));",
      "Static int",
      "kue_send\t\t__P((struct kue_softc *, struct mbuf *, int));",
      "Static int",
      "kue_open_pipes\t__P((struct kue_softc *));",
      "Static void",
      "kue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "kue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "kue_start\t\t__P((struct ifnet *));",
      "Static int",
      "Static void",
      "Static void",
      "kue_stop\t\t__P((struct kue_softc *));",
      "Static void",
      "kue_watchdog\t\t__P((struct ifnet *));",
      "Static void",
      "kue_setmulti\t__P((struct kue_softc *));",
      "Static void",
      "kue_reset\t\t__P((struct kue_softc *));",
      "Static usbd_status",
      "Static usbd_status",
      "kue_setword\t__P((struct kue_softc *, u_int8_t, u_int16_t));",
      "Static int",
      "kue_is_warm\t\t__P((struct kue_softc *));",
      "Static int",
      "kue_load_fw\t\t__P((struct kue_softc *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"%s: %s: start rx\\n\", USBDEVNAME(sc->kue_dev),\n\t\t    __FUNCTION__)"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_transfer",
          "args": [
            "c->kue_xfer"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "254-339",
          "snippet": "usbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "u_int32_t size;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nu_int32_t size;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_setup_xfer",
          "args": [
            "c->kue_xfer",
            "sc->kue_ep[KUE_ENDPT_RX]",
            "c",
            "c->kue_buf",
            "KUE_BUFSZ",
            "USBD_SHORT_XFER_OK | USBD_NO_COPY",
            "USBD_NO_TIMEOUT",
            "kue_rxeof"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_setup_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "420-444",
          "snippet": "void\nusbd_setup_xfer(xfer, pipe, priv, buffer, length, flags, timeout, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t length;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid (*callback) __P((usbd_xfer_handle,\n\t\t\t      usbd_private_handle,\n\t\t\t      usbd_status));\n{\n\txfer->pipe = pipe;\n\txfer->priv = priv;\n\txfer->buffer = buffer;\n\txfer->length = length;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = timeout;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->rqflags &= ~URQ_REQUEST;\n\txfer->nframes = 0;\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nvoid\nusbd_setup_xfer(xfer, pipe, priv, buffer, length, flags, timeout, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t length;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid (*callback) __P((usbd_xfer_handle,\n\t\t\t      usbd_private_handle,\n\t\t\t      usbd_status));\n{\n\txfer->pipe = pipe;\n\txfer->priv = priv;\n\txfer->buffer = buffer;\n\txfer->length = length;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = timeout;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->rqflags &= ~URQ_REQUEST;\n\txfer->nframes = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_INPUT",
          "args": [
            "ifp",
            "m"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"%s: %s: deliver %d\\n\", USBDEVNAME(sc->kue_dev),\n\t\t    __FUNCTION__, m->m_len)"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_MTAP",
          "args": [
            "ifp",
            "m"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "eh->ether_dhost",
            "LLADDR(ifp->if_sadl)",
            "ETHER_ADDR_LEN"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LLADDR",
          "args": [
            "ifp->if_sadl"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_MTAP",
          "args": [
            "ifp",
            "m"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "structether_header*"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kue_newbuf",
          "args": [
            "sc",
            "c",
            "NULL"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "kue_newbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
          "lines": "788-823",
          "snippet": "Static int\nkue_newbuf(sc, c, m)\n\tstruct kue_softc\t*sc;\n\tstruct kue_chain\t*c;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->kue_dev));\n\t\t\treturn (ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->kue_dev));\n\t\t\tm_freem(m_new);\n\t\t\treturn (ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tc->kue_mbuf = m_new;\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/usb/kue_fw.h>",
            "#include <dev/usb/if_kuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "kue_tx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "kue_rx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "kue_newbuf\t\t__P((struct kue_softc *, struct kue_chain *,\n\t\t\t\t    struct mbuf *));",
            "Static int",
            "kue_send\t\t__P((struct kue_softc *, struct mbuf *, int));",
            "Static int",
            "kue_open_pipes\t__P((struct kue_softc *));",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "kue_stop\t\t__P((struct kue_softc *));",
            "Static void",
            "Static void",
            "kue_setmulti\t__P((struct kue_softc *));",
            "Static void",
            "kue_reset\t\t__P((struct kue_softc *));",
            "Static int",
            "kue_is_warm\t\t__P((struct kue_softc *));",
            "Static int",
            "kue_load_fw\t\t__P((struct kue_softc *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_newbuf\t\t__P((struct kue_softc *, struct kue_chain *,\n\t\t\t\t    struct mbuf *));\nStatic int;\nkue_send\t\t__P((struct kue_softc *, struct mbuf *, int));\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic int\nkue_newbuf(sc, c, m)\n\tstruct kue_softc\t*sc;\n\tstruct kue_chain\t*c;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->kue_dev));\n\t\t\treturn (ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->kue_dev));\n\t\t\tm_freem(m_new);\n\t\t\treturn (ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tc->kue_mbuf = m_new;\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_ether_input",
          "args": [
            "m"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_adj",
          "args": [
            "m",
            "sizeof(u_int16_t)"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "mtod(m, u_int8_t *)"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "u_int8_t*"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"%s: %s: total_len=%d len=%d\\n\", USBDEVNAME(sc->kue_dev),\n\t\t     __FUNCTION__, total_len, \n\t\t     UGETW(mtod(c->kue_mbuf, u_int8_t *)))"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UGETW",
          "args": [
            "mtod(c->kue_mbuf, u_int8_t *)"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "c->kue_mbuf",
            "u_int8_t*"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_get_xfer_status",
          "args": [
            "xfer",
            "NULL",
            "NULL",
            "&total_len",
            "NULL"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_get_xfer_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "499-515",
          "snippet": "void\nusbd_get_xfer_status(xfer, priv, buffer, count, status)\n\tusbd_xfer_handle xfer;\n\tusbd_private_handle *priv;\n\tvoid **buffer;\n\tu_int32_t *count;\n\tusbd_status *status;\n{\n\tif (priv != NULL)\n\t\t*priv = xfer->priv;\n\tif (buffer != NULL)\n\t\t*buffer = xfer->buffer;\n\tif (count != NULL)\n\t\t*count = xfer->actlen;\n\tif (status != NULL)\n\t\t*status = xfer->status;\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\n\nvoid\nusbd_get_xfer_status(xfer, priv, buffer, count, status)\n\tusbd_xfer_handle xfer;\n\tusbd_private_handle *priv;\n\tvoid **buffer;\n\tu_int32_t *count;\n\tusbd_status *status;\n{\n\tif (priv != NULL)\n\t\t*priv = xfer->priv;\n\tif (buffer != NULL)\n\t\t*buffer = xfer->buffer;\n\tif (count != NULL)\n\t\t*count = xfer->actlen;\n\tif (status != NULL)\n\t\t*status = xfer->status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_clear_endpoint_stall",
          "args": [
            "sc->kue_ep[KUE_ENDPT_RX]"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_clear_endpoint_stall_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "611-628",
          "snippet": "usbd_status \nusbd_clear_endpoint_stall_async(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_device_handle dev = pipe->device;\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\tpipe->methods->cleartoggle(pipe);\n\n\treq.bmRequestType = UT_WRITE_ENDPOINT;\n\treq.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(req.wValue, UF_ENDPOINT_HALT);\n\tUSETW(req.wIndex, pipe->endpoint->edesc->bEndpointAddress);\n\tUSETW(req.wLength, 0);\n\terr = usbd_do_request_async(dev, &req, 0);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_status \nusbd_clear_endpoint_stall_async(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_device_handle dev = pipe->device;\n\tusb_device_request_t req;\n\tusbd_status err;\n\n\tpipe->methods->cleartoggle(pipe);\n\n\treq.bmRequestType = UT_WRITE_ENDPOINT;\n\treq.bRequest = UR_CLEAR_FEATURE;\n\tUSETW(req.wValue, UF_ENDPOINT_HALT);\n\tUSETW(req.wIndex, pipe->endpoint->edesc->bEndpointAddress);\n\tUSETW(req.wLength, 0);\n\terr = usbd_do_request_async(dev, &req, 0);\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: %u usb errors on rx: %s\\n\"",
            "USBDEVNAME(sc->kue_dev)",
            "sc->kue_rx_errs",
            "usbd_errstr(status)"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "status"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_ratecheck",
          "args": [
            "&sc->kue_rx_notice"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_ratecheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "1134-1141",
          "snippet": "int\nusbd_ratecheck(last)\n\tstruct timeval *last;\n{\n\tstatic struct timeval errinterval = { 0, 250000 }; /* 0.25 s*/\n\n\treturn (ratecheck(last, &errinterval));\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nusbd_ratecheck(last)\n\tstruct timeval *last;\n{\n\tstatic struct timeval errinterval = { 0, 250000 }; /* 0.25 s*/\n\n\treturn (ratecheck(last, &errinterval));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"%s: %s: enter status=%d\\n\", USBDEVNAME(sc->kue_dev),\n\t\t     __FUNCTION__, status)"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_IFP",
          "args": [
            "sc"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_newbuf\t\t__P((struct kue_softc *, struct kue_chain *,\n\t\t\t\t    struct mbuf *));\nStatic int;\nkue_send\t\t__P((struct kue_softc *, struct mbuf *, int));\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nkue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nkue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nkue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nkue_watchdog\t\t__P((struct ifnet *));\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic usbd_status;\nStatic usbd_status;\nkue_setword\t__P((struct kue_softc *, u_int8_t, u_int16_t));\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic void\nkue_rxeof(xfer, priv, status)\n\tusbd_xfer_handle\txfer;\n\tusbd_private_handle\tpriv;\n\tusbd_status\t\tstatus;\n{\n\tstruct kue_chain\t*c = priv;\n\tstruct kue_softc\t*sc = c->kue_sc;\n\tstruct ifnet\t\t*ifp = GET_IFP(sc);\n\tstruct mbuf\t\t*m;\n\tint\t\t\ttotal_len = 0;\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\tint\t\t\ts;\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\n\tDPRINTFN(10,(\"%s: %s: enter status=%d\\n\", USBDEVNAME(sc->kue_dev),\n\t\t     __FUNCTION__, status));\n\n\tif (sc->kue_dying)\n\t\treturn;\n\n\tif (!(ifp->if_flags & IFF_RUNNING))\n\t\treturn;\n\n\tif (status != USBD_NORMAL_COMPLETION) {\n\t\tif (status == USBD_NOT_STARTED || status == USBD_CANCELLED)\n\t\t\treturn;\n\t\tsc->kue_rx_errs++;\n\t\tif (usbd_ratecheck(&sc->kue_rx_notice)) {\n\t\t\tprintf(\"%s: %u usb errors on rx: %s\\n\",\n\t\t\t    USBDEVNAME(sc->kue_dev), sc->kue_rx_errs,\n\t\t\t    usbd_errstr(status));\n\t\t\tsc->kue_rx_errs = 0;\n\t\t}\n\t\tif (status == USBD_STALLED)\n\t\t\tusbd_clear_endpoint_stall(sc->kue_ep[KUE_ENDPT_RX]);\n\t\tgoto done;\n\t}\n\n\tusbd_get_xfer_status(xfer, NULL, NULL, &total_len, NULL);\n\n\tDPRINTFN(10,(\"%s: %s: total_len=%d len=%d\\n\", USBDEVNAME(sc->kue_dev),\n\t\t     __FUNCTION__, total_len, \n\t\t     UGETW(mtod(c->kue_mbuf, u_int8_t *))));\n\n\tif (total_len <= 1)\n\t\tgoto done;\n\n\tm = c->kue_mbuf;\n\t/* copy data to mbuf */\n\tmemcpy(mtod(m, char*), c->kue_buf, total_len);\n\n\t/* No errors; receive the packet. */\n\ttotal_len = UGETW(mtod(m, u_int8_t *));\n\tm_adj(m, sizeof(u_int16_t));\n\n\tif (total_len < sizeof(struct ether_header)) {\n\t\tifp->if_ierrors++;\n\t\tgoto done;\n\t}\n\n\tifp->if_ipackets++;\n\tm->m_pkthdr.len = m->m_len = total_len;\n\n#if defined(__FreeBSD__)\n\tm->m_pkthdr.rcvif = (struct ifnet *)&kue_qdat;\n\t/* Put the packet on the special USB input queue. */\n\tusb_ether_input(m);\n\n\treturn;\n\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n\tm->m_pkthdr.rcvif = ifp;\n\n\ts = splimp();\n\n\t/* XXX ugly */\n\tif (kue_newbuf(sc, c, NULL) == ENOBUFS) {\n\t\tifp->if_ierrors++;\n\t\tgoto done1;\n\t}\n\n#if NBPFILTER > 0\n\t/*\n\t * Handle BPF listeners. Let the BPF user see the packet, but\n\t * don't pass it up to the ether_input() layer unless it's\n\t * a broadcast packet, multicast packet, matches our ethernet\n\t * address or the interface is in promiscuous mode.\n\t */\n\tif (ifp->if_bpf) {\n#if defined(__NetBSD__)\n\t\tstruct ether_header *eh = mtod(m, struct ether_header *);\n\t\tBPF_MTAP(ifp, m);\n\t\tif ((ifp->if_flags & IFF_PROMISC) &&\n\t\t    memcmp(eh->ether_dhost, LLADDR(ifp->if_sadl),\n\t\t\t   ETHER_ADDR_LEN) &&\n\t\t    !(eh->ether_dhost[0] & 1)) {\n\t\t\tm_freem(m);\n\t\t\tgoto done1;\n\t\t}\n#else\n\t\tBPF_MTAP(ifp, m);\n#endif\n\t}\n#endif\n\n\tDPRINTFN(10,(\"%s: %s: deliver %d\\n\", USBDEVNAME(sc->kue_dev),\n\t\t    __FUNCTION__, m->m_len));\n\tIF_INPUT(ifp, m);\n done1:\n\tsplx(s);\n#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */\n\n done:\n\n\t/* Setup new transfer. */\n\tusbd_setup_xfer(c->kue_xfer, sc->kue_ep[KUE_ENDPT_RX],\n\t    c, c->kue_buf, KUE_BUFSZ, USBD_SHORT_XFER_OK | USBD_NO_COPY,\n\t    USBD_NO_TIMEOUT, kue_rxeof);\n\tusbd_transfer(c->kue_xfer);\n\n\tDPRINTFN(10,(\"%s: %s: start rx\\n\", USBDEVNAME(sc->kue_dev),\n\t\t    __FUNCTION__));\n}"
  },
  {
    "function_name": "kue_rxstart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
    "lines": "885-905",
    "snippet": "Static void\nkue_rxstart(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct kue_softc\t*sc;\n\tstruct kue_chain\t*c;\n\n\tsc = ifp->if_softc;\n\tc = &sc->kue_cdata.kue_rx_chain[sc->kue_cdata.kue_rx_prod];\n\n\tif (kue_newbuf(sc, c, NULL) == ENOBUFS) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\t/* Setup new transfer. */\n\tusbd_setup_xfer(c->kue_xfer, sc->kue_ep[KUE_ENDPT_RX],\n\t    c, c->kue_buf, KUE_BUFSZ, USBD_SHORT_XFER_OK | USBD_NO_COPY,\n\t    USBD_NO_TIMEOUT, kue_rxeof);\n\tusbd_transfer(c->kue_xfer);\n}",
    "includes": [
      "#include <dev/usb/kue_fw.h>",
      "#include <dev/usb/if_kuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "kue_tx_list_init\t__P((struct kue_softc *));",
      "Static int",
      "kue_rx_list_init\t__P((struct kue_softc *));",
      "Static int",
      "Static int",
      "Static int",
      "kue_open_pipes\t__P((struct kue_softc *));",
      "Static void",
      "Static void",
      "Static void",
      "kue_start\t\t__P((struct ifnet *));",
      "Static int",
      "Static void",
      "Static void",
      "kue_stop\t\t__P((struct kue_softc *));",
      "Static void",
      "kue_watchdog\t\t__P((struct ifnet *));",
      "Static void",
      "kue_setmulti\t__P((struct kue_softc *));",
      "Static void",
      "kue_reset\t\t__P((struct kue_softc *));",
      "Static int",
      "kue_is_warm\t\t__P((struct kue_softc *));",
      "Static int",
      "kue_load_fw\t\t__P((struct kue_softc *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_transfer",
          "args": [
            "c->kue_xfer"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "254-339",
          "snippet": "usbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "u_int32_t size;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nu_int32_t size;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusbd_transfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tusbd_pipe_handle pipe = xfer->pipe;\n\tusb_dma_t *dmap = &xfer->dmabuf;\n\tusbd_status err;\n\tu_int size;\n\tint s;\n\n\tDPRINTFN(5,(\"usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\\n\",\n\t\t    xfer, xfer->flags, pipe, pipe->running));\n#ifdef USB_DEBUG\n\tif (usbdebug > 5)\n\t\tusbd_dump_queue(pipe);\n#endif\n\txfer->done = 0;\n\n\tif (pipe->aborting)\n\t\treturn (USBD_CANCELLED);\n\n\tsize = xfer->length;\n\t/* If there is no buffer, allocate one. */\n\tif (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {\n\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n#ifdef DIAGNOSTIC\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF)\n\t\t\tprintf(\"usbd_transfer: has old buffer!\\n\");\n#endif\n\t\terr = bus->methods->allocm(bus, dmap, size);\n\t\tif (err)\n\t\t\treturn (err);\n\t\txfer->rqflags |= URQ_AUTO_DMABUF;\n\t}\n\n\t/* Copy data if going out. */\n\tif (!(xfer->flags & USBD_NO_COPY) && size != 0 && \n\t    !usbd_xfer_isread(xfer))\n\t\tmemcpy(KERNADDR(dmap), xfer->buffer, size);\n\n\terr = pipe->methods->transfer(xfer);\n\n\tif (err != USBD_IN_PROGRESS && err) {\n\t\t/* The transfer has not been queued, so free buffer. */\n\t\tif (xfer->rqflags & URQ_AUTO_DMABUF) {\n\t\t\tstruct usbd_bus *bus = pipe->device->bus;\n\n\t\t\tbus->methods->freem(bus, &xfer->dmabuf);\n\t\t\txfer->rqflags &= ~URQ_AUTO_DMABUF;\n\t\t}\n\t}\n\n\tif (!(xfer->flags & USBD_SYNCHRONOUS))\n\t\treturn (err);\n\n\t/* Sync transfer, wait for completion. */\n\tif (err != USBD_IN_PROGRESS)\n\t\treturn (err);\n\ts = splusb();\n\tif (!xfer->done) {\n\t\tif (pipe->device->bus->use_polling)\n\t\t\tpanic(\"usbd_transfer: not done\\n\");\n\t\t/* XXX Temporary hack XXX */\n\t\tif (xfer->flags & USBD_NO_TSLEEP) {\n\t\t\tint i;\n\t\t\tusbd_bus_handle bus = pipe->device->bus;\n\t\t\tint to = xfer->timeout * 1000;\n\t\t\tfor (i = 0; i < to; i += 10) {\n\t\t\t\tdelay(10);\n\t\t\t\tbus->methods->do_poll(bus);\n\t\t\t\tif (xfer->done)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* XXX Is this right, what about the HC timeout? */\n\t\t\tif (!xfer->done) {\n\t\t\t\tpipe->methods->abort(xfer);\n\t\t\t\txfer->status = USBD_TIMEOUT;\n\t\t\t}\n\t\t} else\n\t\t/* XXX End hack XXX */\n\t\t\ttsleep(xfer, PRIBIO, \"usbsyn\", 0);\n\t}\n\tsplx(s);\n\treturn (xfer->status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_setup_xfer",
          "args": [
            "c->kue_xfer",
            "sc->kue_ep[KUE_ENDPT_RX]",
            "c",
            "c->kue_buf",
            "KUE_BUFSZ",
            "USBD_SHORT_XFER_OK | USBD_NO_COPY",
            "USBD_NO_TIMEOUT",
            "kue_rxeof"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_setup_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "420-444",
          "snippet": "void\nusbd_setup_xfer(xfer, pipe, priv, buffer, length, flags, timeout, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t length;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid (*callback) __P((usbd_xfer_handle,\n\t\t\t      usbd_private_handle,\n\t\t\t      usbd_status));\n{\n\txfer->pipe = pipe;\n\txfer->priv = priv;\n\txfer->buffer = buffer;\n\txfer->length = length;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = timeout;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->rqflags &= ~URQ_REQUEST;\n\txfer->nframes = 0;\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nvoid\nusbd_setup_xfer(xfer, pipe, priv, buffer, length, flags, timeout, callback)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t length;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid (*callback) __P((usbd_xfer_handle,\n\t\t\t      usbd_private_handle,\n\t\t\t      usbd_status));\n{\n\txfer->pipe = pipe;\n\txfer->priv = priv;\n\txfer->buffer = buffer;\n\txfer->length = length;\n\txfer->actlen = 0;\n\txfer->flags = flags;\n\txfer->timeout = timeout;\n\txfer->status = USBD_NOT_STARTED;\n\txfer->callback = callback;\n\txfer->rqflags &= ~URQ_REQUEST;\n\txfer->nframes = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kue_newbuf",
          "args": [
            "sc",
            "c",
            "NULL"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "kue_newbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
          "lines": "788-823",
          "snippet": "Static int\nkue_newbuf(sc, c, m)\n\tstruct kue_softc\t*sc;\n\tstruct kue_chain\t*c;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->kue_dev));\n\t\t\treturn (ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->kue_dev));\n\t\t\tm_freem(m_new);\n\t\t\treturn (ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tc->kue_mbuf = m_new;\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/usb/kue_fw.h>",
            "#include <dev/usb/if_kuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "kue_tx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "kue_rx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "kue_newbuf\t\t__P((struct kue_softc *, struct kue_chain *,\n\t\t\t\t    struct mbuf *));",
            "Static int",
            "kue_send\t\t__P((struct kue_softc *, struct mbuf *, int));",
            "Static int",
            "kue_open_pipes\t__P((struct kue_softc *));",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "kue_stop\t\t__P((struct kue_softc *));",
            "Static void",
            "Static void",
            "kue_setmulti\t__P((struct kue_softc *));",
            "Static void",
            "kue_reset\t\t__P((struct kue_softc *));",
            "Static int",
            "kue_is_warm\t\t__P((struct kue_softc *));",
            "Static int",
            "kue_load_fw\t\t__P((struct kue_softc *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_newbuf\t\t__P((struct kue_softc *, struct kue_chain *,\n\t\t\t\t    struct mbuf *));\nStatic int;\nkue_send\t\t__P((struct kue_softc *, struct mbuf *, int));\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic int\nkue_newbuf(sc, c, m)\n\tstruct kue_softc\t*sc;\n\tstruct kue_chain\t*c;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->kue_dev));\n\t\t\treturn (ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->kue_dev));\n\t\t\tm_freem(m_new);\n\t\t\treturn (ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tc->kue_mbuf = m_new;\n\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nStatic int;\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nStatic void;\nkue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nkue_watchdog\t\t__P((struct ifnet *));\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic void\nkue_rxstart(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct kue_softc\t*sc;\n\tstruct kue_chain\t*c;\n\n\tsc = ifp->if_softc;\n\tc = &sc->kue_cdata.kue_rx_chain[sc->kue_cdata.kue_rx_prod];\n\n\tif (kue_newbuf(sc, c, NULL) == ENOBUFS) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\t/* Setup new transfer. */\n\tusbd_setup_xfer(c->kue_xfer, sc->kue_ep[KUE_ENDPT_RX],\n\t    c, c->kue_buf, KUE_BUFSZ, USBD_SHORT_XFER_OK | USBD_NO_COPY,\n\t    USBD_NO_TIMEOUT, kue_rxeof);\n\tusbd_transfer(c->kue_xfer);\n}"
  },
  {
    "function_name": "kue_tx_list_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
    "lines": "855-882",
    "snippet": "Static int\nkue_tx_list_init(sc)\n\tstruct kue_softc\t*sc;\n{\n\tstruct kue_cdata\t*cd;\n\tstruct kue_chain\t*c;\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev), __FUNCTION__));\n\n\tcd = &sc->kue_cdata;\n\tfor (i = 0; i < KUE_TX_LIST_CNT; i++) {\n\t\tc = &cd->kue_tx_chain[i];\n\t\tc->kue_sc = sc;\n\t\tc->kue_idx = i;\n\t\tc->kue_mbuf = NULL;\n\t\tif (c->kue_xfer == NULL) {\n\t\t\tc->kue_xfer = usbd_alloc_xfer(sc->kue_udev);\n\t\t\tif (c->kue_xfer == NULL)\n\t\t\t\treturn (ENOBUFS);\n\t\t\tc->kue_buf = usbd_alloc_buffer(c->kue_xfer, KUE_BUFSZ);\n\t\t\tif (c->kue_buf == NULL)\n\t\t\t\treturn (ENOBUFS);\n\t\t}\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/kue_fw.h>",
      "#include <dev/usb/if_kuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "kue_tx_list_init\t__P((struct kue_softc *));",
      "Static int",
      "kue_rx_list_init\t__P((struct kue_softc *));",
      "Static int",
      "Static int",
      "Static int",
      "kue_open_pipes\t__P((struct kue_softc *));",
      "Static void",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "kue_stop\t\t__P((struct kue_softc *));",
      "Static void",
      "Static void",
      "kue_setmulti\t__P((struct kue_softc *));",
      "Static void",
      "kue_reset\t\t__P((struct kue_softc *));",
      "Static int",
      "kue_is_warm\t\t__P((struct kue_softc *));",
      "Static int",
      "kue_load_fw\t\t__P((struct kue_softc *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_alloc_buffer",
          "args": [
            "c->kue_xfer",
            "KUE_BUFSZ"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_alloc_xfer",
          "args": [
            "sc->kue_udev"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_alloc_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "388-401",
          "snippet": "usbd_xfer_handle \nusbd_alloc_xfer(dev)\n\tusbd_device_handle dev;\n{\n\tusbd_xfer_handle xfer;\n\n\txfer = dev->bus->methods->allocx(dev->bus);\n\tif (xfer == NULL)\n\t\treturn (NULL);\n\txfer->device = dev;\n\tusb_callout_init(xfer->timeout_handle);\n\tDPRINTFN(5,(\"usbd_alloc_xfer() = %p\\n\", xfer));\n\treturn (xfer);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_xfer_handle \nusbd_alloc_xfer(dev)\n\tusbd_device_handle dev;\n{\n\tusbd_xfer_handle xfer;\n\n\txfer = dev->bus->methods->allocx(dev->bus);\n\tif (xfer == NULL)\n\t\treturn (NULL);\n\txfer->device = dev;\n\tusb_callout_init(xfer->timeout_handle);\n\tDPRINTFN(5,(\"usbd_alloc_xfer() = %p\\n\", xfer));\n\treturn (xfer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev), __FUNCTION__)"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nStatic int;\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic int\nkue_tx_list_init(sc)\n\tstruct kue_softc\t*sc;\n{\n\tstruct kue_cdata\t*cd;\n\tstruct kue_chain\t*c;\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev), __FUNCTION__));\n\n\tcd = &sc->kue_cdata;\n\tfor (i = 0; i < KUE_TX_LIST_CNT; i++) {\n\t\tc = &cd->kue_tx_chain[i];\n\t\tc->kue_sc = sc;\n\t\tc->kue_idx = i;\n\t\tc->kue_mbuf = NULL;\n\t\tif (c->kue_xfer == NULL) {\n\t\t\tc->kue_xfer = usbd_alloc_xfer(sc->kue_udev);\n\t\t\tif (c->kue_xfer == NULL)\n\t\t\t\treturn (ENOBUFS);\n\t\t\tc->kue_buf = usbd_alloc_buffer(c->kue_xfer, KUE_BUFSZ);\n\t\t\tif (c->kue_buf == NULL)\n\t\t\t\treturn (ENOBUFS);\n\t\t}\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "kue_rx_list_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
    "lines": "825-853",
    "snippet": "Static int\nkue_rx_list_init(sc)\n\tstruct kue_softc\t*sc;\n{\n\tstruct kue_cdata\t*cd;\n\tstruct kue_chain\t*c;\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev), __FUNCTION__));\n\n\tcd = &sc->kue_cdata;\n\tfor (i = 0; i < KUE_RX_LIST_CNT; i++) {\n\t\tc = &cd->kue_rx_chain[i];\n\t\tc->kue_sc = sc;\n\t\tc->kue_idx = i;\n\t\tif (kue_newbuf(sc, c, NULL) == ENOBUFS)\n\t\t\treturn (ENOBUFS);\n\t\tif (c->kue_xfer == NULL) {\n\t\t\tc->kue_xfer = usbd_alloc_xfer(sc->kue_udev);\n\t\t\tif (c->kue_xfer == NULL)\n\t\t\t\treturn (ENOBUFS);\n\t\t\tc->kue_buf = usbd_alloc_buffer(c->kue_xfer, KUE_BUFSZ);\n\t\t\tif (c->kue_buf == NULL)\n\t\t\t\treturn (ENOBUFS); /* XXX free xfer */\n\t\t}\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/kue_fw.h>",
      "#include <dev/usb/if_kuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "kue_tx_list_init\t__P((struct kue_softc *));",
      "Static int",
      "kue_rx_list_init\t__P((struct kue_softc *));",
      "Static int",
      "Static int",
      "Static int",
      "kue_open_pipes\t__P((struct kue_softc *));",
      "Static void",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "kue_stop\t\t__P((struct kue_softc *));",
      "Static void",
      "Static void",
      "kue_setmulti\t__P((struct kue_softc *));",
      "Static void",
      "kue_reset\t\t__P((struct kue_softc *));",
      "Static int",
      "kue_is_warm\t\t__P((struct kue_softc *));",
      "Static int",
      "kue_load_fw\t\t__P((struct kue_softc *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_alloc_buffer",
          "args": [
            "c->kue_xfer",
            "KUE_BUFSZ"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_alloc_xfer",
          "args": [
            "sc->kue_udev"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_alloc_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "388-401",
          "snippet": "usbd_xfer_handle \nusbd_alloc_xfer(dev)\n\tusbd_device_handle dev;\n{\n\tusbd_xfer_handle xfer;\n\n\txfer = dev->bus->methods->allocx(dev->bus);\n\tif (xfer == NULL)\n\t\treturn (NULL);\n\txfer->device = dev;\n\tusb_callout_init(xfer->timeout_handle);\n\tDPRINTFN(5,(\"usbd_alloc_xfer() = %p\\n\", xfer));\n\treturn (xfer);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_xfer_handle \nusbd_alloc_xfer(dev)\n\tusbd_device_handle dev;\n{\n\tusbd_xfer_handle xfer;\n\n\txfer = dev->bus->methods->allocx(dev->bus);\n\tif (xfer == NULL)\n\t\treturn (NULL);\n\txfer->device = dev;\n\tusb_callout_init(xfer->timeout_handle);\n\tDPRINTFN(5,(\"usbd_alloc_xfer() = %p\\n\", xfer));\n\treturn (xfer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kue_newbuf",
          "args": [
            "sc",
            "c",
            "NULL"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "kue_newbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
          "lines": "788-823",
          "snippet": "Static int\nkue_newbuf(sc, c, m)\n\tstruct kue_softc\t*sc;\n\tstruct kue_chain\t*c;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->kue_dev));\n\t\t\treturn (ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->kue_dev));\n\t\t\tm_freem(m_new);\n\t\t\treturn (ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tc->kue_mbuf = m_new;\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/usb/kue_fw.h>",
            "#include <dev/usb/if_kuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "kue_tx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "kue_rx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "kue_newbuf\t\t__P((struct kue_softc *, struct kue_chain *,\n\t\t\t\t    struct mbuf *));",
            "Static int",
            "kue_send\t\t__P((struct kue_softc *, struct mbuf *, int));",
            "Static int",
            "kue_open_pipes\t__P((struct kue_softc *));",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "kue_stop\t\t__P((struct kue_softc *));",
            "Static void",
            "Static void",
            "kue_setmulti\t__P((struct kue_softc *));",
            "Static void",
            "kue_reset\t\t__P((struct kue_softc *));",
            "Static int",
            "kue_is_warm\t\t__P((struct kue_softc *));",
            "Static int",
            "kue_load_fw\t\t__P((struct kue_softc *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_newbuf\t\t__P((struct kue_softc *, struct kue_chain *,\n\t\t\t\t    struct mbuf *));\nStatic int;\nkue_send\t\t__P((struct kue_softc *, struct mbuf *, int));\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic int\nkue_newbuf(sc, c, m)\n\tstruct kue_softc\t*sc;\n\tstruct kue_chain\t*c;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->kue_dev));\n\t\t\treturn (ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->kue_dev));\n\t\t\tm_freem(m_new);\n\t\t\treturn (ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tc->kue_mbuf = m_new;\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev), __FUNCTION__)"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nStatic int;\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic int\nkue_rx_list_init(sc)\n\tstruct kue_softc\t*sc;\n{\n\tstruct kue_cdata\t*cd;\n\tstruct kue_chain\t*c;\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev), __FUNCTION__));\n\n\tcd = &sc->kue_cdata;\n\tfor (i = 0; i < KUE_RX_LIST_CNT; i++) {\n\t\tc = &cd->kue_rx_chain[i];\n\t\tc->kue_sc = sc;\n\t\tc->kue_idx = i;\n\t\tif (kue_newbuf(sc, c, NULL) == ENOBUFS)\n\t\t\treturn (ENOBUFS);\n\t\tif (c->kue_xfer == NULL) {\n\t\t\tc->kue_xfer = usbd_alloc_xfer(sc->kue_udev);\n\t\t\tif (c->kue_xfer == NULL)\n\t\t\t\treturn (ENOBUFS);\n\t\t\tc->kue_buf = usbd_alloc_buffer(c->kue_xfer, KUE_BUFSZ);\n\t\t\tif (c->kue_buf == NULL)\n\t\t\t\treturn (ENOBUFS); /* XXX free xfer */\n\t\t}\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "kue_newbuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
    "lines": "788-823",
    "snippet": "Static int\nkue_newbuf(sc, c, m)\n\tstruct kue_softc\t*sc;\n\tstruct kue_chain\t*c;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->kue_dev));\n\t\t\treturn (ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->kue_dev));\n\t\t\tm_freem(m_new);\n\t\t\treturn (ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tc->kue_mbuf = m_new;\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/kue_fw.h>",
      "#include <dev/usb/if_kuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "kue_tx_list_init\t__P((struct kue_softc *));",
      "Static int",
      "kue_rx_list_init\t__P((struct kue_softc *));",
      "Static int",
      "kue_newbuf\t\t__P((struct kue_softc *, struct kue_chain *,\n\t\t\t\t    struct mbuf *));",
      "Static int",
      "kue_send\t\t__P((struct kue_softc *, struct mbuf *, int));",
      "Static int",
      "kue_open_pipes\t__P((struct kue_softc *));",
      "Static void",
      "Static void",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "kue_stop\t\t__P((struct kue_softc *));",
      "Static void",
      "Static void",
      "kue_setmulti\t__P((struct kue_softc *));",
      "Static void",
      "kue_reset\t\t__P((struct kue_softc *));",
      "Static int",
      "kue_is_warm\t\t__P((struct kue_softc *));",
      "Static int",
      "kue_load_fw\t\t__P((struct kue_softc *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m_new"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\"",
            "USBDEVNAME(sc->kue_dev)"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCLGET",
          "args": [
            "m_new",
            "M_DONTWAIT"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGETHDR",
          "args": [
            "m_new",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__)"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_newbuf\t\t__P((struct kue_softc *, struct kue_chain *,\n\t\t\t\t    struct mbuf *));\nStatic int;\nkue_send\t\t__P((struct kue_softc *, struct mbuf *, int));\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic int\nkue_newbuf(sc, c, m)\n\tstruct kue_softc\t*sc;\n\tstruct kue_chain\t*c;\n\tstruct mbuf\t\t*m;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\tif (m == NULL) {\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->kue_dev));\n\t\t\treturn (ENOBUFS);\n\t\t}\n\n\t\tMCLGET(m_new, M_DONTWAIT);\n\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\tprintf(\"%s: no memory for rx list \"\n\t\t\t    \"-- packet dropped!\\n\", USBDEVNAME(sc->kue_dev));\n\t\t\tm_freem(m_new);\n\t\t\treturn (ENOBUFS);\n\t\t}\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t} else {\n\t\tm_new = m;\n\t\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\t\tm_new->m_data = m_new->m_ext.ext_buf;\n\t}\n\n\tc->kue_mbuf = m_new;\n\n\treturn (0);\n}"
  },
  {
    "function_name": "kue_activate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
    "lines": "759-782",
    "snippet": "int\nkue_activate(self, act)\n\tdevice_ptr_t self;\n\tenum devact act;\n{\n\tstruct kue_softc *sc = (struct kue_softc *)self;\n\n\tDPRINTFN(2,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev), __FUNCTION__));\n\n\tswitch (act) {\n\tcase DVACT_ACTIVATE:\n\t\treturn (EOPNOTSUPP);\n\t\tbreak;\n\n\tcase DVACT_DEACTIVATE:\n#if defined(__NetBSD__)\n\t\t/* Deactivate the interface. */\n\t\tif_deactivate(&sc->kue_ec.ec_if);\n#endif\n\t\tsc->kue_dying = 1;\n\t\tbreak;\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/kue_fw.h>",
      "#include <dev/usb/if_kuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "kue_tx_list_init\t__P((struct kue_softc *));",
      "kue_rx_list_init\t__P((struct kue_softc *));",
      "kue_open_pipes\t__P((struct kue_softc *));",
      "kue_stop\t\t__P((struct kue_softc *));",
      "kue_setmulti\t__P((struct kue_softc *));",
      "kue_reset\t\t__P((struct kue_softc *));",
      "kue_is_warm\t\t__P((struct kue_softc *));",
      "kue_load_fw\t\t__P((struct kue_softc *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "if_deactivate",
          "args": [
            "&sc->kue_ec.ec_if"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev), __FUNCTION__)"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nkue_tx_list_init\t__P((struct kue_softc *));\nkue_rx_list_init\t__P((struct kue_softc *));\nkue_open_pipes\t__P((struct kue_softc *));\nkue_stop\t\t__P((struct kue_softc *));\nkue_setmulti\t__P((struct kue_softc *));\nkue_reset\t\t__P((struct kue_softc *));\nkue_is_warm\t\t__P((struct kue_softc *));\nkue_load_fw\t\t__P((struct kue_softc *));\n\nint\nkue_activate(self, act)\n\tdevice_ptr_t self;\n\tenum devact act;\n{\n\tstruct kue_softc *sc = (struct kue_softc *)self;\n\n\tDPRINTFN(2,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev), __FUNCTION__));\n\n\tswitch (act) {\n\tcase DVACT_ACTIVATE:\n\t\treturn (EOPNOTSUPP);\n\t\tbreak;\n\n\tcase DVACT_DEACTIVATE:\n#if defined(__NetBSD__)\n\t\t/* Deactivate the interface. */\n\t\tif_deactivate(&sc->kue_ec.ec_if);\n#endif\n\t\tsc->kue_dying = 1;\n\t\tbreak;\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "kue_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
    "lines": "495-509",
    "snippet": "Static void\nkue_reset(sc)\n\tstruct kue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev), __FUNCTION__));\n\n\terr = usbd_set_config_no(sc->kue_udev, KUE_CONFIG_NO, 0);\n\tif (err)\n\t\tprintf(\"%s: reset failed\\n\", USBDEVNAME(sc->kue_dev));\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tusbd_delay_ms(sc->kue_udev, 10);\n}",
    "includes": [
      "#include <dev/usb/kue_fw.h>",
      "#include <dev/usb/if_kuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "kue_tx_list_init\t__P((struct kue_softc *));",
      "Static int",
      "kue_rx_list_init\t__P((struct kue_softc *));",
      "Static int",
      "Static int",
      "Static int",
      "kue_open_pipes\t__P((struct kue_softc *));",
      "Static void",
      "kue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "kue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "kue_stop\t\t__P((struct kue_softc *));",
      "Static void",
      "Static void",
      "kue_setmulti\t__P((struct kue_softc *));",
      "Static void",
      "kue_reset\t\t__P((struct kue_softc *));",
      "Static usbd_status",
      "Static usbd_status",
      "Static int",
      "kue_is_warm\t\t__P((struct kue_softc *));",
      "Static int",
      "kue_load_fw\t\t__P((struct kue_softc *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_delay_ms",
          "args": [
            "sc->kue_udev",
            "10"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_delay_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "316-322",
          "snippet": "void\nusbd_delay_ms(dev, ms)\n\tusbd_device_handle dev;\n\tu_int ms;\n{\n\tusb_delay_ms(dev->bus, ms);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_set_config __P((usbd_device_handle, int));",
            "usbd_getnewaddr __P((usbd_bus_handle bus));",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nusbd_getnewaddr __P((usbd_bus_handle bus));\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusbd_delay_ms(dev, ms)\n\tusbd_device_handle dev;\n\tu_int ms;\n{\n\tusb_delay_ms(dev->bus, ms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: reset failed\\n\"",
            "USBDEVNAME(sc->kue_dev)"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_set_config_no",
          "args": [
            "sc->kue_udev",
            "KUE_CONFIG_NO",
            "0"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_set_config_no",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "532-552",
          "snippet": "usbd_status\nusbd_set_config_no(dev, no, msg)\n\tusbd_device_handle dev;\n\tint no;\n\tint msg;\n{\n\tint index;\n\tusb_config_descriptor_t cd;\n\tusbd_status err;\n\n\tDPRINTFN(5,(\"usbd_set_config_no: %d\\n\", no));\n\t/* Figure out what config index to use. */\n\tfor (index = 0; index < dev->ddesc.bNumConfigurations; index++) {\n\t\terr = usbd_get_config_desc(dev, index, &cd);\n\t\tif (err)\n\t\t\treturn (err);\n\t\tif (cd.bConfigurationValue == no)\n\t\t\treturn (usbd_set_config_index(dev, index, msg));\n\t}\n\treturn (USBD_INVAL);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_set_config __P((usbd_device_handle, int));",
            "Static usbd_status",
            "const char *\nusbd_errstr(err)\n\tusbd_status err;",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;",
            "usb_interface_descriptor_t *\nusbd_find_idesc(cd, ifaceidx, altidx)\n\tusb_config_descriptor_t *cd;",
            "usb_endpoint_descriptor_t *\nusbd_find_edesc(cd, ifaceidx, altidx, endptidx)\n\tusb_config_descriptor_t *cd;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_set_config __P((usbd_device_handle, int));\nStatic usbd_status;\nconst char *\nusbd_errstr(err)\n\tusbd_status err;\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\nusb_interface_descriptor_t *\nusbd_find_idesc(cd, ifaceidx, altidx)\n\tusb_config_descriptor_t *cd;\nusb_endpoint_descriptor_t *\nusbd_find_edesc(cd, ifaceidx, altidx, endptidx)\n\tusb_config_descriptor_t *cd;\n\nusbd_status\nusbd_set_config_no(dev, no, msg)\n\tusbd_device_handle dev;\n\tint no;\n\tint msg;\n{\n\tint index;\n\tusb_config_descriptor_t cd;\n\tusbd_status err;\n\n\tDPRINTFN(5,(\"usbd_set_config_no: %d\\n\", no));\n\t/* Figure out what config index to use. */\n\tfor (index = 0; index < dev->ddesc.bNumConfigurations; index++) {\n\t\terr = usbd_get_config_desc(dev, index, &cd);\n\t\tif (err)\n\t\t\treturn (err);\n\t\tif (cd.bConfigurationValue == no)\n\t\t\treturn (usbd_set_config_index(dev, index, msg));\n\t}\n\treturn (USBD_INVAL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev), __FUNCTION__)"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nStatic int;\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nkue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nkue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic usbd_status;\nStatic usbd_status;\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic void\nkue_reset(sc)\n\tstruct kue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev), __FUNCTION__));\n\n\terr = usbd_set_config_no(sc->kue_udev, KUE_CONFIG_NO, 0);\n\tif (err)\n\t\tprintf(\"%s: reset failed\\n\", USBDEVNAME(sc->kue_dev));\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tusbd_delay_ms(sc->kue_udev, 10);\n}"
  },
  {
    "function_name": "kue_setmulti",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
    "lines": "416-488",
    "snippet": "Static void\nkue_setmulti(sc)\n\tstruct kue_softc\t*sc;\n{\n\tstruct ifnet\t\t*ifp = GET_IFP(sc);\n#if defined(__FreeBSD__)\n\tstruct ifmultiaddr\t*ifma;\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n#endif\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev), __FUNCTION__));\n\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\tsc->kue_rxfilt |= KUE_RXFILT_ALLMULTI;\n\t\tsc->kue_rxfilt &= ~KUE_RXFILT_MULTICAST;\n\t\tkue_setword(sc, KUE_CMD_SET_PKT_FILTER, sc->kue_rxfilt);\n\t\treturn;\n\t}\n\n\tsc->kue_rxfilt &= ~KUE_RXFILT_ALLMULTI;\n\n\ti = 0;\n#if defined(__FreeBSD__)\n\tfor (ifma = ifp->if_multiaddrs.lh_first; ifma != NULL;\n\t    ifma = ifma->ifma_link.le_next) {\n\t\tif (ifma->ifma_addr->sa_family != AF_LINK)\n\t\t\tcontinue;\n\t\t/*\n\t\t * If there are too many addresses for the\n\t\t * internal filter, switch over to allmulti mode.\n\t\t */\n\t\tif (i == KUE_MCFILTCNT(sc))\n\t\t\tbreak;\n\t\tbcopy(LLADDR((struct sockaddr_dl *)ifma->ifma_addr),\n\t\t    KUE_MCFILT(sc, i), ETHER_ADDR_LEN);\n\t\ti++;\n\t}\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n#if defined (__NetBSD__)\n\tETHER_FIRST_MULTI(step, &sc->kue_ec, enm);\n#else\n\tETHER_FIRST_MULTI(step, &sc->arpcom, enm);\n#endif\n\twhile (enm != NULL) {\n\t\tif (i == KUE_MCFILTCNT(sc))\n\t\t\tbreak;\n#if 0\n\t\tif (memcmp(enm->enm_addrlo,\n\t\t\t   enm->enm_addrhi, ETHER_ADDR_LEN) != 0) {\n\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\t/* XXX what now? */\n\t\t\treturn;\n\t\t}\n#endif\n\t\tmemcpy(KUE_MCFILT(sc, i), enm->enm_addrlo, ETHER_ADDR_LEN);\n\t\tETHER_NEXT_MULTI(step, enm);\n\t\ti++;\n\t}\n#endif\n\n\tif (i == KUE_MCFILTCNT(sc))\n\t\tsc->kue_rxfilt |= KUE_RXFILT_ALLMULTI;\n\telse {\n\t\tsc->kue_rxfilt |= KUE_RXFILT_MULTICAST;\n\t\tkue_ctl(sc, KUE_CTL_WRITE, KUE_CMD_SET_MCAST_FILTERS,\n\t\t    i, sc->kue_mcfilters, i * ETHER_ADDR_LEN);\n\t}\n\n\tkue_setword(sc, KUE_CMD_SET_PKT_FILTER, sc->kue_rxfilt);\n}",
    "includes": [
      "#include <dev/usb/kue_fw.h>",
      "#include <dev/usb/if_kuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "kue_tx_list_init\t__P((struct kue_softc *));",
      "Static int",
      "kue_rx_list_init\t__P((struct kue_softc *));",
      "Static int",
      "Static int",
      "Static int",
      "kue_open_pipes\t__P((struct kue_softc *));",
      "Static void",
      "Static void",
      "Static void",
      "kue_start\t\t__P((struct ifnet *));",
      "Static int",
      "Static void",
      "Static void",
      "kue_stop\t\t__P((struct kue_softc *));",
      "Static void",
      "kue_watchdog\t\t__P((struct ifnet *));",
      "Static void",
      "kue_setmulti\t__P((struct kue_softc *));",
      "Static void",
      "kue_reset\t\t__P((struct kue_softc *));",
      "Static int",
      "kue_is_warm\t\t__P((struct kue_softc *));",
      "Static int",
      "kue_load_fw\t\t__P((struct kue_softc *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kue_setword",
          "args": [
            "sc",
            "KUE_CMD_SET_PKT_FILTER",
            "sc->kue_rxfilt"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "kue_setword",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
          "lines": "257-280",
          "snippet": "Static usbd_status\nkue_setword(sc, breq, word)\n\tstruct kue_softc\t*sc;\n\tu_int8_t\t\tbreq;\n\tu_int16_t\t\tword;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = breq;\n\tUSETW(req.wValue, word);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, 0);\n\n\ts = splusb();\n\terr = KUE_DO_REQUEST(sc->kue_udev, &req, NULL);\n\tsplx(s);\n\n\treturn (err);\n}",
          "includes": [
            "#include <dev/usb/kue_fw.h>",
            "#include <dev/usb/if_kuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "kue_tx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "kue_rx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "Static int",
            "Static int",
            "kue_open_pipes\t__P((struct kue_softc *));",
            "Static void",
            "kue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "kue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "kue_stop\t\t__P((struct kue_softc *));",
            "Static void",
            "Static void",
            "kue_setmulti\t__P((struct kue_softc *));",
            "Static void",
            "kue_reset\t\t__P((struct kue_softc *));",
            "Static usbd_status",
            "Static usbd_status",
            "kue_setword\t__P((struct kue_softc *, u_int8_t, u_int16_t));",
            "Static int",
            "kue_is_warm\t\t__P((struct kue_softc *));",
            "Static int",
            "kue_load_fw\t\t__P((struct kue_softc *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nStatic int;\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nkue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nkue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic usbd_status;\nStatic usbd_status;\nkue_setword\t__P((struct kue_softc *, u_int8_t, u_int16_t));\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic usbd_status\nkue_setword(sc, breq, word)\n\tstruct kue_softc\t*sc;\n\tu_int8_t\t\tbreq;\n\tu_int16_t\t\tword;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = breq;\n\tUSETW(req.wValue, word);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, 0);\n\n\ts = splusb();\n\terr = KUE_DO_REQUEST(sc->kue_udev, &req, NULL);\n\tsplx(s);\n\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kue_ctl",
          "args": [
            "sc",
            "KUE_CTL_WRITE",
            "KUE_CMD_SET_MCAST_FILTERS",
            "i",
            "sc->kue_mcfilters",
            "i * ETHER_ADDR_LEN"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "kue_ctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
          "lines": "282-313",
          "snippet": "Static usbd_status\nkue_ctl(sc, rw, breq, val, data, len)\n\tstruct kue_softc\t*sc;\n\tint\t\t\trw;\n\tu_int8_t\t\tbreq;\n\tu_int16_t\t\tval;\n\tvoid\t\t\t*data;\n\tu_int32_t\t\tlen;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\n\tDPRINTFN(10,(\"%s: %s: enter, len=%d\\n\", USBDEVNAME(sc->kue_dev),\n\t\t     __FUNCTION__, len));\n\n\tif (rw == KUE_CTL_WRITE)\n\t\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\telse\n\t\treq.bmRequestType = UT_READ_VENDOR_DEVICE;\n\n\treq.bRequest = breq;\n\tUSETW(req.wValue, val);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, len);\n\n\ts = splusb();\n\terr = KUE_DO_REQUEST(sc->kue_udev, &req, data);\n\tsplx(s);\n\n\treturn (err);\n}",
          "includes": [
            "#include <dev/usb/kue_fw.h>",
            "#include <dev/usb/if_kuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "kue_tx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "kue_rx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "Static int",
            "Static int",
            "kue_open_pipes\t__P((struct kue_softc *));",
            "Static void",
            "kue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "kue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "kue_stop\t\t__P((struct kue_softc *));",
            "Static void",
            "Static void",
            "kue_setmulti\t__P((struct kue_softc *));",
            "Static void",
            "kue_reset\t\t__P((struct kue_softc *));",
            "Static usbd_status",
            "kue_ctl\t__P((struct kue_softc *, int, u_int8_t,\n\t\t\t\t    u_int16_t, void *, u_int32_t));",
            "Static usbd_status",
            "kue_setword\t__P((struct kue_softc *, u_int8_t, u_int16_t));",
            "Static int",
            "kue_is_warm\t\t__P((struct kue_softc *));",
            "Static int",
            "kue_load_fw\t\t__P((struct kue_softc *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nStatic int;\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nkue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nkue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic usbd_status;\nkue_ctl\t__P((struct kue_softc *, int, u_int8_t,\n\t\t\t\t    u_int16_t, void *, u_int32_t));\nStatic usbd_status;\nkue_setword\t__P((struct kue_softc *, u_int8_t, u_int16_t));\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic usbd_status\nkue_ctl(sc, rw, breq, val, data, len)\n\tstruct kue_softc\t*sc;\n\tint\t\t\trw;\n\tu_int8_t\t\tbreq;\n\tu_int16_t\t\tval;\n\tvoid\t\t\t*data;\n\tu_int32_t\t\tlen;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\n\tDPRINTFN(10,(\"%s: %s: enter, len=%d\\n\", USBDEVNAME(sc->kue_dev),\n\t\t     __FUNCTION__, len));\n\n\tif (rw == KUE_CTL_WRITE)\n\t\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\telse\n\t\treq.bmRequestType = UT_READ_VENDOR_DEVICE;\n\n\treq.bRequest = breq;\n\tUSETW(req.wValue, val);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, len);\n\n\ts = splusb();\n\terr = KUE_DO_REQUEST(sc->kue_udev, &req, data);\n\tsplx(s);\n\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KUE_MCFILTCNT",
          "args": [
            "sc"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ETHER_NEXT_MULTI",
          "args": [
            "step",
            "enm"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "KUE_MCFILT(sc, i)",
            "enm->enm_addrlo",
            "ETHER_ADDR_LEN"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KUE_MCFILT",
          "args": [
            "sc",
            "i"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "enm->enm_addrlo",
            "enm->enm_addrhi",
            "ETHER_ADDR_LEN"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KUE_MCFILTCNT",
          "args": [
            "sc"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ETHER_FIRST_MULTI",
          "args": [
            "step",
            "&sc->arpcom",
            "enm"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ETHER_FIRST_MULTI",
          "args": [
            "step",
            "&sc->kue_ec",
            "enm"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "LLADDR((struct sockaddr_dl *)ifma->ifma_addr)",
            "KUE_MCFILT(sc, i)",
            "ETHER_ADDR_LEN"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "KUE_MCFILT",
          "args": [
            "sc",
            "i"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LLADDR",
          "args": [
            "(struct sockaddr_dl *)ifma->ifma_addr"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KUE_MCFILTCNT",
          "args": [
            "sc"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev), __FUNCTION__)"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_IFP",
          "args": [
            "sc"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nStatic int;\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nStatic void;\nkue_start\t\t__P((struct ifnet *));\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nkue_watchdog\t\t__P((struct ifnet *));\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic void\nkue_setmulti(sc)\n\tstruct kue_softc\t*sc;\n{\n\tstruct ifnet\t\t*ifp = GET_IFP(sc);\n#if defined(__FreeBSD__)\n\tstruct ifmultiaddr\t*ifma;\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n\tstruct ether_multi\t*enm;\n\tstruct ether_multistep\tstep;\n#endif\n\tint\t\t\ti;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev), __FUNCTION__));\n\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\tsc->kue_rxfilt |= KUE_RXFILT_ALLMULTI;\n\t\tsc->kue_rxfilt &= ~KUE_RXFILT_MULTICAST;\n\t\tkue_setword(sc, KUE_CMD_SET_PKT_FILTER, sc->kue_rxfilt);\n\t\treturn;\n\t}\n\n\tsc->kue_rxfilt &= ~KUE_RXFILT_ALLMULTI;\n\n\ti = 0;\n#if defined(__FreeBSD__)\n\tfor (ifma = ifp->if_multiaddrs.lh_first; ifma != NULL;\n\t    ifma = ifma->ifma_link.le_next) {\n\t\tif (ifma->ifma_addr->sa_family != AF_LINK)\n\t\t\tcontinue;\n\t\t/*\n\t\t * If there are too many addresses for the\n\t\t * internal filter, switch over to allmulti mode.\n\t\t */\n\t\tif (i == KUE_MCFILTCNT(sc))\n\t\t\tbreak;\n\t\tbcopy(LLADDR((struct sockaddr_dl *)ifma->ifma_addr),\n\t\t    KUE_MCFILT(sc, i), ETHER_ADDR_LEN);\n\t\ti++;\n\t}\n#elif defined(__NetBSD__) || defined(__OpenBSD__)\n#if defined (__NetBSD__)\n\tETHER_FIRST_MULTI(step, &sc->kue_ec, enm);\n#else\n\tETHER_FIRST_MULTI(step, &sc->arpcom, enm);\n#endif\n\twhile (enm != NULL) {\n\t\tif (i == KUE_MCFILTCNT(sc))\n\t\t\tbreak;\n#if 0\n\t\tif (memcmp(enm->enm_addrlo,\n\t\t\t   enm->enm_addrhi, ETHER_ADDR_LEN) != 0) {\n\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\t/* XXX what now? */\n\t\t\treturn;\n\t\t}\n#endif\n\t\tmemcpy(KUE_MCFILT(sc, i), enm->enm_addrlo, ETHER_ADDR_LEN);\n\t\tETHER_NEXT_MULTI(step, enm);\n\t\ti++;\n\t}\n#endif\n\n\tif (i == KUE_MCFILTCNT(sc))\n\t\tsc->kue_rxfilt |= KUE_RXFILT_ALLMULTI;\n\telse {\n\t\tsc->kue_rxfilt |= KUE_RXFILT_MULTICAST;\n\t\tkue_ctl(sc, KUE_CTL_WRITE, KUE_CMD_SET_MCAST_FILTERS,\n\t\t    i, sc->kue_mcfilters, i * ETHER_ADDR_LEN);\n\t}\n\n\tkue_setword(sc, KUE_CMD_SET_PKT_FILTER, sc->kue_rxfilt);\n}"
  },
  {
    "function_name": "kue_load_fw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
    "lines": "334-414",
    "snippet": "Static int\nkue_load_fw(sc)\n\tstruct kue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\n\tDPRINTFN(1,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev), __FUNCTION__));\n\n\t/*\n\t * First, check if we even need to load the firmware.\n\t * If the device was still attached when the system was\n\t * rebooted, it may already have firmware loaded in it.\n\t * If this is the case, we don't need to do it again.\n\t * And in fact, if we try to load it again, we'll hang,\n\t * so we have to avoid this condition if we don't want\n\t * to look stupid.\n\t *\n\t * We can test this quickly by issuing a request that\n\t * is only valid after firmware download.\n\t */\n\tif (kue_is_warm(sc)) {\n\t\tprintf(\"%s: warm boot, no firmware download\\n\",\n\t\t       USBDEVNAME(sc->kue_dev));\n\t\treturn (0);\n\t}\n\n\tprintf(\"%s: cold boot, downloading firmware\\n\",\n\t       USBDEVNAME(sc->kue_dev));\n\n\t/* Load code segment */\n\tDPRINTFN(1,(\"%s: kue_load_fw: download code_seg\\n\", \n\t\t    USBDEVNAME(sc->kue_dev)));\n\terr = kue_ctl(sc, KUE_CTL_WRITE, KUE_CMD_SEND_SCAN,\n\t    0, kue_code_seg, sizeof(kue_code_seg));\n\tif (err) {\n\t\tprintf(\"%s: failed to load code segment: %s\\n\",\n\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t\treturn (EIO);\n\t}\n\n\t/* Load fixup segment */\n\tDPRINTFN(1,(\"%s: kue_load_fw: download fix_seg\\n\", \n\t\t    USBDEVNAME(sc->kue_dev)));\n\terr = kue_ctl(sc, KUE_CTL_WRITE, KUE_CMD_SEND_SCAN,\n\t    0, kue_fix_seg, sizeof(kue_fix_seg));\n\tif (err) {\n\t\tprintf(\"%s: failed to load fixup segment: %s\\n\",\n\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t\treturn (EIO);\n\t}\n\n\t/* Send trigger command. */\n\tDPRINTFN(1,(\"%s: kue_load_fw: download trig_seg\\n\", \n\t\t    USBDEVNAME(sc->kue_dev)));\n\terr = kue_ctl(sc, KUE_CTL_WRITE, KUE_CMD_SEND_SCAN,\n\t    0, kue_trig_seg, sizeof(kue_trig_seg));\n\tif (err) {\n\t\tprintf(\"%s: failed to load trigger segment: %s\\n\",\n\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t\treturn (EIO);\n\t}\n\n\tusbd_delay_ms(sc->kue_udev, 10);\n\n\t/*\n\t * Reload device descriptor.\n\t * Why? The chip without the firmware loaded returns\n\t * one revision code. The chip with the firmware\n\t * loaded and running returns a *different* revision\n\t * code. This confuses the quirk mechanism, which is\n\t * dependent on the revision data.\n\t */\n\t(void)usbd_reload_device_desc(sc->kue_udev);\n\n\tDPRINTFN(1,(\"%s: %s: done\\n\", USBDEVNAME(sc->kue_dev), __FUNCTION__));\n\n\t/* Reset the adapter. */\n\tkue_reset(sc);\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/kue_fw.h>",
      "#include <dev/usb/if_kuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "kue_tx_list_init\t__P((struct kue_softc *));",
      "Static int",
      "kue_rx_list_init\t__P((struct kue_softc *));",
      "Static int",
      "Static int",
      "Static int",
      "kue_open_pipes\t__P((struct kue_softc *));",
      "Static void",
      "kue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "kue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "kue_stop\t\t__P((struct kue_softc *));",
      "Static void",
      "Static void",
      "kue_setmulti\t__P((struct kue_softc *));",
      "Static void",
      "kue_reset\t\t__P((struct kue_softc *));",
      "Static usbd_status",
      "Static usbd_status",
      "Static int",
      "kue_is_warm\t\t__P((struct kue_softc *));",
      "Static int",
      "kue_load_fw\t\t__P((struct kue_softc *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kue_reset",
          "args": [
            "sc"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "kue_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
          "lines": "495-509",
          "snippet": "Static void\nkue_reset(sc)\n\tstruct kue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev), __FUNCTION__));\n\n\terr = usbd_set_config_no(sc->kue_udev, KUE_CONFIG_NO, 0);\n\tif (err)\n\t\tprintf(\"%s: reset failed\\n\", USBDEVNAME(sc->kue_dev));\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tusbd_delay_ms(sc->kue_udev, 10);\n}",
          "includes": [
            "#include <dev/usb/kue_fw.h>",
            "#include <dev/usb/if_kuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "kue_tx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "kue_rx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "Static int",
            "Static int",
            "kue_open_pipes\t__P((struct kue_softc *));",
            "Static void",
            "kue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "kue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "kue_stop\t\t__P((struct kue_softc *));",
            "Static void",
            "Static void",
            "kue_setmulti\t__P((struct kue_softc *));",
            "Static void",
            "kue_reset\t\t__P((struct kue_softc *));",
            "Static usbd_status",
            "Static usbd_status",
            "Static int",
            "kue_is_warm\t\t__P((struct kue_softc *));",
            "Static int",
            "kue_load_fw\t\t__P((struct kue_softc *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nStatic int;\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nkue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nkue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic usbd_status;\nStatic usbd_status;\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic void\nkue_reset(sc)\n\tstruct kue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\n\tDPRINTFN(5,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev), __FUNCTION__));\n\n\terr = usbd_set_config_no(sc->kue_udev, KUE_CONFIG_NO, 0);\n\tif (err)\n\t\tprintf(\"%s: reset failed\\n\", USBDEVNAME(sc->kue_dev));\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tusbd_delay_ms(sc->kue_udev, 10);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"%s: %s: done\\n\", USBDEVNAME(sc->kue_dev), __FUNCTION__)"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_reload_device_desc",
          "args": [
            "sc->kue_udev"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_reload_device_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "1048-1063",
          "snippet": "usbd_status\nusbd_reload_device_desc(dev)\n\tusbd_device_handle dev;\n{\n\tusbd_status err;\n\n\t/* Get the full device descriptor. */\n\terr = usbd_get_device_desc(dev, &dev->ddesc);\n\tif (err)\n\t\treturn (err);\n\n\t/* Figure out what's wrong with this device. */\n\tdev->quirks = usbd_find_quirk(&dev->ddesc);\n\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_set_config __P((usbd_device_handle, int));",
            "Static usbd_status",
            "const char *\nusbd_errstr(err)\n\tusbd_status err;",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_set_config __P((usbd_device_handle, int));\nStatic usbd_status;\nconst char *\nusbd_errstr(err)\n\tusbd_status err;\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nusbd_status\nusbd_reload_device_desc(dev)\n\tusbd_device_handle dev;\n{\n\tusbd_status err;\n\n\t/* Get the full device descriptor. */\n\terr = usbd_get_device_desc(dev, &dev->ddesc);\n\tif (err)\n\t\treturn (err);\n\n\t/* Figure out what's wrong with this device. */\n\tdev->quirks = usbd_find_quirk(&dev->ddesc);\n\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_delay_ms",
          "args": [
            "sc->kue_udev",
            "10"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_delay_ms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_subr.c",
          "lines": "316-322",
          "snippet": "void\nusbd_delay_ms(dev, ms)\n\tusbd_device_handle dev;\n\tu_int ms;\n{\n\tusb_delay_ms(dev->bus, ms);\n}",
          "includes": [
            "#include <dev/usb/usbdevs_data.h>",
            "#include <machine/clock.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_set_config __P((usbd_device_handle, int));",
            "usbd_getnewaddr __P((usbd_bus_handle bus));",
            "char *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdevs_data.h>\n#include <machine/clock.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_set_config __P((usbd_device_handle, int));\nusbd_getnewaddr __P((usbd_bus_handle bus));\nchar *\nusbd_get_string(dev, si, buf)\n\tusbd_device_handle dev;\n\nvoid\nusbd_delay_ms(dev, ms)\n\tusbd_device_handle dev;\n\tu_int ms;\n{\n\tusb_delay_ms(dev->bus, ms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: failed to load trigger segment: %s\\n\"",
            "USBDEVNAME(sc->kue_dev)",
            "usbd_errstr(err)"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kue_ctl",
          "args": [
            "sc",
            "KUE_CTL_WRITE",
            "KUE_CMD_SEND_SCAN",
            "0",
            "kue_trig_seg",
            "sizeof(kue_trig_seg)"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "kue_ctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
          "lines": "282-313",
          "snippet": "Static usbd_status\nkue_ctl(sc, rw, breq, val, data, len)\n\tstruct kue_softc\t*sc;\n\tint\t\t\trw;\n\tu_int8_t\t\tbreq;\n\tu_int16_t\t\tval;\n\tvoid\t\t\t*data;\n\tu_int32_t\t\tlen;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\n\tDPRINTFN(10,(\"%s: %s: enter, len=%d\\n\", USBDEVNAME(sc->kue_dev),\n\t\t     __FUNCTION__, len));\n\n\tif (rw == KUE_CTL_WRITE)\n\t\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\telse\n\t\treq.bmRequestType = UT_READ_VENDOR_DEVICE;\n\n\treq.bRequest = breq;\n\tUSETW(req.wValue, val);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, len);\n\n\ts = splusb();\n\terr = KUE_DO_REQUEST(sc->kue_udev, &req, data);\n\tsplx(s);\n\n\treturn (err);\n}",
          "includes": [
            "#include <dev/usb/kue_fw.h>",
            "#include <dev/usb/if_kuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "kue_tx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "kue_rx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "Static int",
            "Static int",
            "kue_open_pipes\t__P((struct kue_softc *));",
            "Static void",
            "kue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "kue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "kue_stop\t\t__P((struct kue_softc *));",
            "Static void",
            "Static void",
            "kue_setmulti\t__P((struct kue_softc *));",
            "Static void",
            "kue_reset\t\t__P((struct kue_softc *));",
            "Static usbd_status",
            "kue_ctl\t__P((struct kue_softc *, int, u_int8_t,\n\t\t\t\t    u_int16_t, void *, u_int32_t));",
            "Static usbd_status",
            "kue_setword\t__P((struct kue_softc *, u_int8_t, u_int16_t));",
            "Static int",
            "kue_is_warm\t\t__P((struct kue_softc *));",
            "Static int",
            "kue_load_fw\t\t__P((struct kue_softc *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nStatic int;\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nkue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nkue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic usbd_status;\nkue_ctl\t__P((struct kue_softc *, int, u_int8_t,\n\t\t\t\t    u_int16_t, void *, u_int32_t));\nStatic usbd_status;\nkue_setword\t__P((struct kue_softc *, u_int8_t, u_int16_t));\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic usbd_status\nkue_ctl(sc, rw, breq, val, data, len)\n\tstruct kue_softc\t*sc;\n\tint\t\t\trw;\n\tu_int8_t\t\tbreq;\n\tu_int16_t\t\tval;\n\tvoid\t\t\t*data;\n\tu_int32_t\t\tlen;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\n\tDPRINTFN(10,(\"%s: %s: enter, len=%d\\n\", USBDEVNAME(sc->kue_dev),\n\t\t     __FUNCTION__, len));\n\n\tif (rw == KUE_CTL_WRITE)\n\t\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\telse\n\t\treq.bmRequestType = UT_READ_VENDOR_DEVICE;\n\n\treq.bRequest = breq;\n\tUSETW(req.wValue, val);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, len);\n\n\ts = splusb();\n\terr = KUE_DO_REQUEST(sc->kue_udev, &req, data);\n\tsplx(s);\n\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"%s: kue_load_fw: download trig_seg\\n\", \n\t\t    USBDEVNAME(sc->kue_dev))"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"%s: kue_load_fw: download fix_seg\\n\", \n\t\t    USBDEVNAME(sc->kue_dev))"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_errstr",
          "args": [
            "err"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"%s: kue_load_fw: download code_seg\\n\", \n\t\t    USBDEVNAME(sc->kue_dev))"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kue_is_warm",
          "args": [
            "sc"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "kue_is_warm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
          "lines": "315-332",
          "snippet": "Static int\nkue_is_warm(sc)\n\tstruct kue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\tusb_device_request_t\treq;\n\n\t/* Just issue some random command. */\n\treq.bmRequestType = UT_READ_VENDOR_DEVICE;\n\treq.bRequest = KUE_CMD_GET_ETHER_DESCRIPTOR;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, sizeof(sc->kue_desc));\n\n\terr = usbd_do_request(sc->kue_udev, &req, &sc->kue_desc);\n\n\treturn (!err);\n}",
          "includes": [
            "#include <dev/usb/kue_fw.h>",
            "#include <dev/usb/if_kuereg.h>",
            "#include <dev/usb/usb_ethersubr.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/bpf.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_arp.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include <sys/device.h>",
            "#include <sys/bus.h>",
            "#include <machine/clock.h>\t/* for DELAY */",
            "#include <net/ethernet.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"rnd.h\"",
            "#include \"bpfilter.h\"",
            "#include \"opt_ns.h\"",
            "#include \"opt_inet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "Static struct",
            "Static int",
            "kue_tx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "kue_rx_list_init\t__P((struct kue_softc *));",
            "Static int",
            "Static int",
            "Static int",
            "kue_open_pipes\t__P((struct kue_softc *));",
            "Static void",
            "kue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "kue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "kue_stop\t\t__P((struct kue_softc *));",
            "Static void",
            "Static void",
            "kue_setmulti\t__P((struct kue_softc *));",
            "Static void",
            "kue_reset\t\t__P((struct kue_softc *));",
            "Static usbd_status",
            "Static usbd_status",
            "Static int",
            "kue_is_warm\t\t__P((struct kue_softc *));",
            "Static int",
            "kue_load_fw\t\t__P((struct kue_softc *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nStatic int;\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nkue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nkue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic usbd_status;\nStatic usbd_status;\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic int\nkue_is_warm(sc)\n\tstruct kue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\tusb_device_request_t\treq;\n\n\t/* Just issue some random command. */\n\treq.bmRequestType = UT_READ_VENDOR_DEVICE;\n\treq.bRequest = KUE_CMD_GET_ETHER_DESCRIPTOR;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, sizeof(sc->kue_desc));\n\n\terr = usbd_do_request(sc->kue_udev, &req, &sc->kue_desc);\n\n\treturn (!err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev), __FUNCTION__)"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nStatic int;\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nkue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nkue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic usbd_status;\nStatic usbd_status;\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic int\nkue_load_fw(sc)\n\tstruct kue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\n\tDPRINTFN(1,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev), __FUNCTION__));\n\n\t/*\n\t * First, check if we even need to load the firmware.\n\t * If the device was still attached when the system was\n\t * rebooted, it may already have firmware loaded in it.\n\t * If this is the case, we don't need to do it again.\n\t * And in fact, if we try to load it again, we'll hang,\n\t * so we have to avoid this condition if we don't want\n\t * to look stupid.\n\t *\n\t * We can test this quickly by issuing a request that\n\t * is only valid after firmware download.\n\t */\n\tif (kue_is_warm(sc)) {\n\t\tprintf(\"%s: warm boot, no firmware download\\n\",\n\t\t       USBDEVNAME(sc->kue_dev));\n\t\treturn (0);\n\t}\n\n\tprintf(\"%s: cold boot, downloading firmware\\n\",\n\t       USBDEVNAME(sc->kue_dev));\n\n\t/* Load code segment */\n\tDPRINTFN(1,(\"%s: kue_load_fw: download code_seg\\n\", \n\t\t    USBDEVNAME(sc->kue_dev)));\n\terr = kue_ctl(sc, KUE_CTL_WRITE, KUE_CMD_SEND_SCAN,\n\t    0, kue_code_seg, sizeof(kue_code_seg));\n\tif (err) {\n\t\tprintf(\"%s: failed to load code segment: %s\\n\",\n\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t\treturn (EIO);\n\t}\n\n\t/* Load fixup segment */\n\tDPRINTFN(1,(\"%s: kue_load_fw: download fix_seg\\n\", \n\t\t    USBDEVNAME(sc->kue_dev)));\n\terr = kue_ctl(sc, KUE_CTL_WRITE, KUE_CMD_SEND_SCAN,\n\t    0, kue_fix_seg, sizeof(kue_fix_seg));\n\tif (err) {\n\t\tprintf(\"%s: failed to load fixup segment: %s\\n\",\n\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t\treturn (EIO);\n\t}\n\n\t/* Send trigger command. */\n\tDPRINTFN(1,(\"%s: kue_load_fw: download trig_seg\\n\", \n\t\t    USBDEVNAME(sc->kue_dev)));\n\terr = kue_ctl(sc, KUE_CTL_WRITE, KUE_CMD_SEND_SCAN,\n\t    0, kue_trig_seg, sizeof(kue_trig_seg));\n\tif (err) {\n\t\tprintf(\"%s: failed to load trigger segment: %s\\n\",\n\t\t    USBDEVNAME(sc->kue_dev), usbd_errstr(err));\n\t\t\treturn (EIO);\n\t}\n\n\tusbd_delay_ms(sc->kue_udev, 10);\n\n\t/*\n\t * Reload device descriptor.\n\t * Why? The chip without the firmware loaded returns\n\t * one revision code. The chip with the firmware\n\t * loaded and running returns a *different* revision\n\t * code. This confuses the quirk mechanism, which is\n\t * dependent on the revision data.\n\t */\n\t(void)usbd_reload_device_desc(sc->kue_udev);\n\n\tDPRINTFN(1,(\"%s: %s: done\\n\", USBDEVNAME(sc->kue_dev), __FUNCTION__));\n\n\t/* Reset the adapter. */\n\tkue_reset(sc);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "kue_is_warm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
    "lines": "315-332",
    "snippet": "Static int\nkue_is_warm(sc)\n\tstruct kue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\tusb_device_request_t\treq;\n\n\t/* Just issue some random command. */\n\treq.bmRequestType = UT_READ_VENDOR_DEVICE;\n\treq.bRequest = KUE_CMD_GET_ETHER_DESCRIPTOR;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, sizeof(sc->kue_desc));\n\n\terr = usbd_do_request(sc->kue_udev, &req, &sc->kue_desc);\n\n\treturn (!err);\n}",
    "includes": [
      "#include <dev/usb/kue_fw.h>",
      "#include <dev/usb/if_kuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "kue_tx_list_init\t__P((struct kue_softc *));",
      "Static int",
      "kue_rx_list_init\t__P((struct kue_softc *));",
      "Static int",
      "Static int",
      "Static int",
      "kue_open_pipes\t__P((struct kue_softc *));",
      "Static void",
      "kue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "kue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "kue_stop\t\t__P((struct kue_softc *));",
      "Static void",
      "Static void",
      "kue_setmulti\t__P((struct kue_softc *));",
      "Static void",
      "kue_reset\t\t__P((struct kue_softc *));",
      "Static usbd_status",
      "Static usbd_status",
      "Static int",
      "kue_is_warm\t\t__P((struct kue_softc *));",
      "Static int",
      "kue_load_fw\t\t__P((struct kue_softc *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_do_request",
          "args": [
            "sc->kue_udev",
            "&req",
            "&sc->kue_desc"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_do_request_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "1059-1079",
          "snippet": "usbd_status\nusbd_do_request_async(dev, req, data)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\txfer = usbd_alloc_xfer(dev);\n\tif (xfer == NULL)\n\t\treturn (USBD_NOMEM);\n\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,\n\t    data, UGETW(req->wLength), 0, usbd_do_request_async_cb);\n\terr = usbd_transfer(xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tusbd_free_xfer(xfer);\n\t\treturn (err);\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_status\nusbd_do_request_async(dev, req, data)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\txfer = usbd_alloc_xfer(dev);\n\tif (xfer == NULL)\n\t\treturn (USBD_NOMEM);\n\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,\n\t    data, UGETW(req->wLength), 0, usbd_do_request_async_cb);\n\terr = usbd_transfer(xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tusbd_free_xfer(xfer);\n\t\treturn (err);\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wLength",
            "sizeof(sc->kue_desc)"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wIndex",
            "0"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wValue",
            "0"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nStatic int;\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nkue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nkue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic usbd_status;\nStatic usbd_status;\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic int\nkue_is_warm(sc)\n\tstruct kue_softc\t*sc;\n{\n\tusbd_status\t\terr;\n\tusb_device_request_t\treq;\n\n\t/* Just issue some random command. */\n\treq.bmRequestType = UT_READ_VENDOR_DEVICE;\n\treq.bRequest = KUE_CMD_GET_ETHER_DESCRIPTOR;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, sizeof(sc->kue_desc));\n\n\terr = usbd_do_request(sc->kue_udev, &req, &sc->kue_desc);\n\n\treturn (!err);\n}"
  },
  {
    "function_name": "kue_ctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
    "lines": "282-313",
    "snippet": "Static usbd_status\nkue_ctl(sc, rw, breq, val, data, len)\n\tstruct kue_softc\t*sc;\n\tint\t\t\trw;\n\tu_int8_t\t\tbreq;\n\tu_int16_t\t\tval;\n\tvoid\t\t\t*data;\n\tu_int32_t\t\tlen;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\n\tDPRINTFN(10,(\"%s: %s: enter, len=%d\\n\", USBDEVNAME(sc->kue_dev),\n\t\t     __FUNCTION__, len));\n\n\tif (rw == KUE_CTL_WRITE)\n\t\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\telse\n\t\treq.bmRequestType = UT_READ_VENDOR_DEVICE;\n\n\treq.bRequest = breq;\n\tUSETW(req.wValue, val);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, len);\n\n\ts = splusb();\n\terr = KUE_DO_REQUEST(sc->kue_udev, &req, data);\n\tsplx(s);\n\n\treturn (err);\n}",
    "includes": [
      "#include <dev/usb/kue_fw.h>",
      "#include <dev/usb/if_kuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "kue_tx_list_init\t__P((struct kue_softc *));",
      "Static int",
      "kue_rx_list_init\t__P((struct kue_softc *));",
      "Static int",
      "Static int",
      "Static int",
      "kue_open_pipes\t__P((struct kue_softc *));",
      "Static void",
      "kue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "kue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "kue_stop\t\t__P((struct kue_softc *));",
      "Static void",
      "Static void",
      "kue_setmulti\t__P((struct kue_softc *));",
      "Static void",
      "kue_reset\t\t__P((struct kue_softc *));",
      "Static usbd_status",
      "kue_ctl\t__P((struct kue_softc *, int, u_int8_t,\n\t\t\t\t    u_int16_t, void *, u_int32_t));",
      "Static usbd_status",
      "kue_setword\t__P((struct kue_softc *, u_int8_t, u_int16_t));",
      "Static int",
      "kue_is_warm\t\t__P((struct kue_softc *));",
      "Static int",
      "kue_load_fw\t\t__P((struct kue_softc *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KUE_DO_REQUEST",
          "args": [
            "sc->kue_udev",
            "&req",
            "data"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wLength",
            "len"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wIndex",
            "0"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wValue",
            "val"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"%s: %s: enter, len=%d\\n\", USBDEVNAME(sc->kue_dev),\n\t\t     __FUNCTION__, len)"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nStatic int;\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nkue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nkue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic usbd_status;\nkue_ctl\t__P((struct kue_softc *, int, u_int8_t,\n\t\t\t\t    u_int16_t, void *, u_int32_t));\nStatic usbd_status;\nkue_setword\t__P((struct kue_softc *, u_int8_t, u_int16_t));\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic usbd_status\nkue_ctl(sc, rw, breq, val, data, len)\n\tstruct kue_softc\t*sc;\n\tint\t\t\trw;\n\tu_int8_t\t\tbreq;\n\tu_int16_t\t\tval;\n\tvoid\t\t\t*data;\n\tu_int32_t\t\tlen;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\n\tDPRINTFN(10,(\"%s: %s: enter, len=%d\\n\", USBDEVNAME(sc->kue_dev),\n\t\t     __FUNCTION__, len));\n\n\tif (rw == KUE_CTL_WRITE)\n\t\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\telse\n\t\treq.bmRequestType = UT_READ_VENDOR_DEVICE;\n\n\treq.bRequest = breq;\n\tUSETW(req.wValue, val);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, len);\n\n\ts = splusb();\n\terr = KUE_DO_REQUEST(sc->kue_udev, &req, data);\n\tsplx(s);\n\n\treturn (err);\n}"
  },
  {
    "function_name": "kue_setword",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/if_kue.c",
    "lines": "257-280",
    "snippet": "Static usbd_status\nkue_setword(sc, breq, word)\n\tstruct kue_softc\t*sc;\n\tu_int8_t\t\tbreq;\n\tu_int16_t\t\tword;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = breq;\n\tUSETW(req.wValue, word);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, 0);\n\n\ts = splusb();\n\terr = KUE_DO_REQUEST(sc->kue_udev, &req, NULL);\n\tsplx(s);\n\n\treturn (err);\n}",
    "includes": [
      "#include <dev/usb/kue_fw.h>",
      "#include <dev/usb/if_kuereg.h>",
      "#include <dev/usb/usb_ethersubr.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/bpf.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_arp.h>",
      "#include <net/if.h>",
      "#include <sys/rnd.h>",
      "#include <sys/device.h>",
      "#include <sys/bus.h>",
      "#include <machine/clock.h>\t/* for DELAY */",
      "#include <net/ethernet.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"rnd.h\"",
      "#include \"bpfilter.h\"",
      "#include \"opt_ns.h\"",
      "#include \"opt_inet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "Static struct",
      "Static int",
      "kue_tx_list_init\t__P((struct kue_softc *));",
      "Static int",
      "kue_rx_list_init\t__P((struct kue_softc *));",
      "Static int",
      "Static int",
      "Static int",
      "kue_open_pipes\t__P((struct kue_softc *));",
      "Static void",
      "kue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "kue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));",
      "Static void",
      "Static int",
      "Static void",
      "Static void",
      "kue_stop\t\t__P((struct kue_softc *));",
      "Static void",
      "Static void",
      "kue_setmulti\t__P((struct kue_softc *));",
      "Static void",
      "kue_reset\t\t__P((struct kue_softc *));",
      "Static usbd_status",
      "Static usbd_status",
      "kue_setword\t__P((struct kue_softc *, u_int8_t, u_int16_t));",
      "Static int",
      "kue_is_warm\t\t__P((struct kue_softc *));",
      "Static int",
      "kue_load_fw\t\t__P((struct kue_softc *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KUE_DO_REQUEST",
          "args": [
            "sc->kue_udev",
            "&req",
            "NULL"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wLength",
            "0"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wIndex",
            "0"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wValue",
            "word"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__)"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->kue_dev"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/kue_fw.h>\n#include <dev/usb/if_kuereg.h>\n#include <dev/usb/usb_ethersubr.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <netinet/if_inarp.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/bpf.h>\n#include <net/if_dl.h>\n#include <net/if_arp.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include <sys/device.h>\n#include <sys/bus.h>\n#include <machine/clock.h>\t/* for DELAY */\n#include <net/ethernet.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"rnd.h\"\n#include \"bpfilter.h\"\n#include \"opt_ns.h\"\n#include \"opt_inet.h\"\n\nStatic struct;\nStatic int;\nkue_tx_list_init\t__P((struct kue_softc *));\nStatic int;\nkue_rx_list_init\t__P((struct kue_softc *));\nStatic int;\nStatic int;\nStatic int;\nkue_open_pipes\t__P((struct kue_softc *));\nStatic void;\nkue_rxeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nkue_txeof\t\t__P((usbd_xfer_handle,\n\t\t\t\t    usbd_private_handle, usbd_status));\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nkue_stop\t\t__P((struct kue_softc *));\nStatic void;\nStatic void;\nkue_setmulti\t__P((struct kue_softc *));\nStatic void;\nkue_reset\t\t__P((struct kue_softc *));\nStatic usbd_status;\nStatic usbd_status;\nkue_setword\t__P((struct kue_softc *, u_int8_t, u_int16_t));\nStatic int;\nkue_is_warm\t\t__P((struct kue_softc *));\nStatic int;\nkue_load_fw\t\t__P((struct kue_softc *));\n\nStatic usbd_status\nkue_setword(sc, breq, word)\n\tstruct kue_softc\t*sc;\n\tu_int8_t\t\tbreq;\n\tu_int16_t\t\tword;\n{\n\tusb_device_request_t\treq;\n\tusbd_status\t\terr;\n\tint\t\t\ts;\n\n\tDPRINTFN(10,(\"%s: %s: enter\\n\", USBDEVNAME(sc->kue_dev),__FUNCTION__));\n\n\treq.bmRequestType = UT_WRITE_VENDOR_DEVICE;\n\treq.bRequest = breq;\n\tUSETW(req.wValue, word);\n\tUSETW(req.wIndex, 0);\n\tUSETW(req.wLength, 0);\n\n\ts = splusb();\n\terr = KUE_DO_REQUEST(sc->kue_udev, &req, NULL);\n\tsplx(s);\n\n\treturn (err);\n}"
  }
]