[
  {
    "function_name": "xl_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
    "lines": "2593-2601",
    "snippet": "void\nxl_shutdown(v)\n\tvoid *v;\n{\n\tstruct xl_softc\t*sc = (struct xl_softc *)v;\n\n\txl_reset(sc, 1);\n\txl_stop(sc);\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void xl_stop",
      "void xl_shutdown",
      "void xl_reset"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xl_stop",
          "args": [
            "sc"
          ],
          "line": 2600
        },
        "resolved": true,
        "details": {
          "function_name": "xl_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "2290-2351",
          "snippet": "void xl_stop(sc)\n\tstruct xl_softc *sc;\n{\n\tint i;\n\tstruct ifnet *ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_timer = 0;\n\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_DISABLE);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STATS_DISABLE);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ENB);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_DISCARD);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_DISABLE);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_STOP);\n\tDELAY(800);\n\n#ifdef foo\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_RESET);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\txl_wait(sc);\n#endif\n\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ACK|XL_STAT_INTLATCH);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STAT_ENB|0);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ENB|0);\n\n\tif (sc->xl_bustype == XL_BUS_CARDBUS)\n\t\tbus_space_write_4(sc->xl_funct, sc->xl_funch, 4, 0x8000);\n\n\t/* Stop the stats updater. */\n\tuntimeout(xl_stats_update, sc);\n\n\t/*\n\t * Free data in the RX lists.\n\t */\n\tfor (i = 0; i < XL_RX_LIST_CNT; i++) {\n\t\tif (sc->xl_cdata.xl_rx_chain[i].xl_mbuf != NULL) {\n\t\t\tm_freem(sc->xl_cdata.xl_rx_chain[i].xl_mbuf);\n\t\t\tsc->xl_cdata.xl_rx_chain[i].xl_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->xl_ldata->xl_rx_list,\n\t\tsizeof(sc->xl_ldata->xl_rx_list));\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < XL_TX_LIST_CNT; i++) {\n\t\tif (sc->xl_cdata.xl_tx_chain[i].xl_mbuf != NULL) {\n\t\t\tm_freem(sc->xl_cdata.xl_tx_chain[i].xl_mbuf);\n\t\t\tsc->xl_cdata.xl_tx_chain[i].xl_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->xl_ldata->xl_tx_list,\n\t\tsizeof(sc->xl_ldata->xl_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void xl_stats_update",
            "void xl_stop",
            "void xl_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_stats_update;\nvoid xl_stop;\nvoid xl_wait;\n\nvoid xl_stop(sc)\n\tstruct xl_softc *sc;\n{\n\tint i;\n\tstruct ifnet *ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_timer = 0;\n\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_DISABLE);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STATS_DISABLE);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ENB);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_DISCARD);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_DISABLE);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_STOP);\n\tDELAY(800);\n\n#ifdef foo\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_RESET);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\txl_wait(sc);\n#endif\n\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ACK|XL_STAT_INTLATCH);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STAT_ENB|0);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ENB|0);\n\n\tif (sc->xl_bustype == XL_BUS_CARDBUS)\n\t\tbus_space_write_4(sc->xl_funct, sc->xl_funch, 4, 0x8000);\n\n\t/* Stop the stats updater. */\n\tuntimeout(xl_stats_update, sc);\n\n\t/*\n\t * Free data in the RX lists.\n\t */\n\tfor (i = 0; i < XL_RX_LIST_CNT; i++) {\n\t\tif (sc->xl_cdata.xl_rx_chain[i].xl_mbuf != NULL) {\n\t\t\tm_freem(sc->xl_cdata.xl_rx_chain[i].xl_mbuf);\n\t\t\tsc->xl_cdata.xl_rx_chain[i].xl_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->xl_ldata->xl_rx_list,\n\t\tsizeof(sc->xl_ldata->xl_rx_list));\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < XL_TX_LIST_CNT; i++) {\n\t\tif (sc->xl_cdata.xl_tx_chain[i].xl_mbuf != NULL) {\n\t\t\tm_freem(sc->xl_cdata.xl_tx_chain[i].xl_mbuf);\n\t\t\tsc->xl_cdata.xl_tx_chain[i].xl_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->xl_ldata->xl_tx_list,\n\t\tsizeof(sc->xl_ldata->xl_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xl_reset",
          "args": [
            "sc",
            "1"
          ],
          "line": 2599
        },
        "resolved": true,
        "details": {
          "function_name": "xl_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "831-860",
          "snippet": "void xl_reset(sc, hard)\n\tstruct xl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tXL_SEL_WIN(0);\n\tif (hard)\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RESET);\n\telse\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RESET | 0x0010);\n\txl_wait(sc);\n\n\tfor (i = 0; i < XL_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(CSR_READ_2(sc, XL_STATUS) & XL_STAT_CMDBUSY))\n\t\t\tbreak;\n\t}\n\n\tDELAY(100000);\n\n\t/* Reset TX and RX. */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_RESET);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\txl_wait(sc);\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tDELAY(100000);\n        return;\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void xl_reset",
            "void xl_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_reset;\nvoid xl_wait;\n\nvoid xl_reset(sc, hard)\n\tstruct xl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tXL_SEL_WIN(0);\n\tif (hard)\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RESET);\n\telse\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RESET | 0x0010);\n\txl_wait(sc);\n\n\tfor (i = 0; i < XL_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(CSR_READ_2(sc, XL_STATUS) & XL_STAT_CMDBUSY))\n\t\t\tbreak;\n\t}\n\n\tDELAY(100000);\n\n\t/* Reset TX and RX. */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_RESET);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\txl_wait(sc);\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tDELAY(100000);\n        return;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_stop;\nvoid xl_shutdown;\nvoid xl_reset;\n\nvoid\nxl_shutdown(v)\n\tvoid *v;\n{\n\tstruct xl_softc\t*sc = (struct xl_softc *)v;\n\n\txl_reset(sc, 1);\n\txl_stop(sc);\n}"
  },
  {
    "function_name": "xl_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
    "lines": "2353-2591",
    "snippet": "void\nxl_attach(sc)\n\tstruct xl_softc *sc;\n{\n\tu_int8_t enaddr[ETHER_ADDR_LEN];\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tcaddr_t roundptr;\n\tu_int round;\n\tint i, media = IFM_ETHER|IFM_100_TX|IFM_FDX;\n\tstruct ifmedia *ifm;\n\n\tsc->xl_unit = sc->sc_dev.dv_unit;\n\txl_reset(sc, 1);\n\n\t/*\n\t * Get station address from the EEPROM.\n\t */\n\tif (xl_read_eeprom(sc, (caddr_t)&enaddr, XL_EE_OEM_ADR0, 3, 1)) {\n\t\tprintf(\"\\n%s: failed to read station address\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\tbcopy(enaddr, (char *)&sc->arpcom.ac_enaddr, ETHER_ADDR_LEN);\n\n\tprintf(\" address %s\\n\", ether_sprintf(sc->arpcom.ac_enaddr));\n\n\tif (sc->xl_bustype == XL_BUS_CARDBUS) {\n\t\tu_int16_t devid;\n\t\tu_int16_t n;\n\n\t\tXL_SEL_WIN(2);\n\t\tn = CSR_READ_2(sc, 12);\n\t\txl_read_eeprom(sc, (caddr_t)&devid, XL_EE_PRODID, 1, 0);\n\n\t\tif (devid != 0x5257)\n\t\t\tn |= 0x0010;\n\t\tif (devid == 0x5257 || devid == 0x6560 || devid == 0x6562)\n\t\t\tn |= 0x4000;\n\n\t\tCSR_WRITE_2(sc, 12, n);\n\t}\n\n\tsc->xl_ldata_ptr = malloc(sizeof(struct xl_list_data) + 8,\n\t    M_DEVBUF, M_NOWAIT);\n\tif (sc->xl_ldata_ptr == NULL) {\n\t\tprintf(\"%s: no memory for list buffers\\n\",sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\tsc->xl_ldata = (struct xl_list_data *)sc->xl_ldata_ptr;\n#ifdef __alpha__\n\tround = (u_int64_t)sc->xl_ldata_ptr & 0xf;\n#else\n\tround = (u_int32_t)sc->xl_ldata_ptr & 0xf;\n#endif\n\troundptr = sc->xl_ldata_ptr;\n\tfor (i = 0; i < 8; i++) {\n\t\tif (round % 8) {\n\t\t\tround++;\n\t\t\troundptr++;\n\t\t} else\n\t\t\tbreak;\n\t}\n\tsc->xl_ldata = (struct xl_list_data *)roundptr;\n\tbzero(sc->xl_ldata, sizeof(struct xl_list_data));\n\n\t/*\n\t * Figure out the card type. 3c905B adapters have the\n\t * 'supportsNoTxLength' bit set in the capabilities\n\t * word in the EEPROM.\n\t */\n\txl_read_eeprom(sc, (caddr_t)&sc->xl_caps, XL_EE_CAPS, 1, 0);\n\tif (sc->xl_caps & XL_CAPS_NO_TXLENGTH)\n\t\tsc->xl_type = XL_TYPE_905B;\n\telse\n\t\tsc->xl_type = XL_TYPE_90X;\n\n\tifp->if_softc = sc;\n\tifp->if_mtu = ETHERMTU;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;\n\tifp->if_ioctl = xl_ioctl;\n\tifp->if_output = ether_output;\n\tif (sc->xl_type == XL_TYPE_905B)\n\t\tifp->if_start = xl_start_90xB;\n\telse\n\t\tifp->if_start = xl_start;\n\tifp->if_watchdog = xl_watchdog;\n\tifp->if_baudrate = 10000000;\n\tifp->if_snd.ifq_maxlen = XL_TX_LIST_CNT - 1;\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\n\tXL_SEL_WIN(3);\n\tsc->xl_media = CSR_READ_2(sc, XL_W3_MEDIA_OPT);\n\n\txl_read_eeprom(sc, (char *)&sc->xl_xcvr, XL_EE_ICFG_0, 2, 0);\n\tsc->xl_xcvr &= XL_ICFG_CONNECTOR_MASK;\n\tsc->xl_xcvr >>= XL_ICFG_CONNECTOR_BITS;\n\n\tif (sc->xl_bustype == XL_BUS_CARDBUS) {\n\t\tXL_SEL_WIN(2);\n\t\tCSR_WRITE_2(sc, 12, 0x4000 | CSR_READ_2(sc, 12));\n\t}\n\tDELAY(100000);\n\n\txl_mediacheck(sc);\n\n\tif (sc->xl_bustype == XL_BUS_CARDBUS) {\n\t\tXL_SEL_WIN(2);\n\t\tCSR_WRITE_2(sc, 12, 0x4000 | CSR_READ_2(sc, 12));\n\t}\n\tDELAY(100000);\n\n\tif (sc->xl_media & XL_MEDIAOPT_MII || sc->xl_media & XL_MEDIAOPT_BTX\n\t    || sc->xl_media & XL_MEDIAOPT_BT4) {\n\t\tifmedia_init(&sc->sc_mii.mii_media, 0,\n\t\t    xl_ifmedia_upd, xl_ifmedia_sts);\n\t\tsc->xl_hasmii = 1;\n\t\tsc->sc_mii.mii_ifp = ifp;\n\t\tsc->sc_mii.mii_readreg = xl_miibus_readreg;\n\t\tsc->sc_mii.mii_writereg = xl_miibus_writereg;\n\t\tsc->sc_mii.mii_statchg = xl_miibus_statchg;\n\t\txl_setcfg(sc);\n\t\tmii_phy_probe((struct device *)sc, &sc->sc_mii, 0xffffffff);\n\n\t\tif (LIST_FIRST(&sc->sc_mii.mii_phys) == NULL) {\n\t\t\tifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE,\n\t\t\t    0, NULL);\n\t\t\tifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE);\n\t\t}\n\t\telse {\n\t\t\tifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO);\n\t\t}\n\t\tifm = &sc->sc_mii.mii_media;\n\t}\n\telse {\n\t\tifmedia_init(&sc->ifmedia, 0, xl_ifmedia_upd, xl_ifmedia_sts);\n\t\tsc->xl_hasmii = 0;\n\t\tifm = &sc->ifmedia;\n\t}\n\n\t/*\n\t * Sanity check. If the user has selected \"auto\" and this isn't\n\t * a 10/100 card of some kind, we need to force the transceiver\n\t * type to something sane.\n\t */\n\tif (sc->xl_xcvr == XL_XCVR_AUTO) {\n\t\txl_choose_xcvr(sc, 0);\n\t\txl_reset(sc, 0);\n\t}\n\n\tif (sc->xl_media & XL_MEDIAOPT_BT) {\n\t\tifmedia_add(ifm, IFM_ETHER|IFM_10_T, 0, NULL);\n\t\tifmedia_add(ifm, IFM_ETHER|IFM_10_T|IFM_HDX, 0, NULL);\n\t\tif (sc->xl_caps & XL_CAPS_FULL_DUPLEX)\n\t\t\tifmedia_add(&sc->ifmedia,\n\t\t\t    IFM_ETHER|IFM_10_T|IFM_FDX, 0, NULL);\n\t}\n\n\tif (sc->xl_media & (XL_MEDIAOPT_AUI|XL_MEDIAOPT_10FL)) {\n\t\t/*\n\t\t * Check for a 10baseFL board in disguise.\n\t\t */\n\t\tif (sc->xl_type == XL_TYPE_905B &&\n\t\t    sc->xl_media == XL_MEDIAOPT_10FL) {\n\t\t\tifmedia_add(ifm, IFM_ETHER|IFM_10_FL, 0, NULL);\n\t\t\tifmedia_add(ifm, IFM_ETHER|IFM_10_FL|IFM_HDX,\n\t\t\t    0, NULL);\n\t\t\tif (sc->xl_caps & XL_CAPS_FULL_DUPLEX)\n\t\t\t\tifmedia_add(ifm,\n\t\t\t\t    IFM_ETHER|IFM_10_FL|IFM_FDX, 0, NULL);\n\t\t} else {\n\t\t\tifmedia_add(ifm, IFM_ETHER|IFM_10_5, 0, NULL);\n\t\t}\n\t}\n\n\tif (sc->xl_media & XL_MEDIAOPT_BNC) {\n\t\tifmedia_add(ifm, IFM_ETHER|IFM_10_2, 0, NULL);\n\t}\n\n\tif (sc->xl_media & XL_MEDIAOPT_BFX) {\n\t\tifp->if_baudrate = 100000000;\n\t\tifmedia_add(ifm, IFM_ETHER|IFM_100_FX, 0, NULL);\n\t}\n\n\t/* Choose a default media. */\n\tswitch(sc->xl_xcvr) {\n\tcase XL_XCVR_10BT:\n\t\tmedia = IFM_ETHER|IFM_10_T;\n\t\txl_setmode(sc, media);\n\t\tbreak;\n\tcase XL_XCVR_AUI:\n\t\tif (sc->xl_type == XL_TYPE_905B &&\n\t\t    sc->xl_media == XL_MEDIAOPT_10FL) {\n\t\t\tmedia = IFM_ETHER|IFM_10_FL;\n\t\t\txl_setmode(sc, media);\n\t\t} else {\n\t\t\tmedia = IFM_ETHER|IFM_10_5;\n\t\t\txl_setmode(sc, media);\n\t\t}\n\t\tbreak;\n\tcase XL_XCVR_COAX:\n\t\tmedia = IFM_ETHER|IFM_10_2;\n\t\txl_setmode(sc, media);\n\t\tbreak;\n\tcase XL_XCVR_AUTO:\n\tcase XL_XCVR_100BTX:\n\tcase XL_XCVR_MII:\n\t\t/* Chosen by miibus */\n\t\tbreak;\n\tcase XL_XCVR_100BFX:\n\t\tmedia = IFM_ETHER|IFM_100_FX;\n\t\txl_setmode(sc, media);\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"xl%d: unknown XCVR type: %d\\n\", sc->xl_unit,\n\t\t\t\t\t\t\tsc->xl_xcvr);\n\t\t/*\n\t\t * This will probably be wrong, but it prevents\n\t\t * the ifmedia code from panicking.\n\t\t */\n\t\tmedia = IFM_ETHER | IFM_10_T;\n\t\tbreak;\n\t}\n\n\tif (sc->xl_hasmii == 0)\n\t\tifmedia_set(&sc->ifmedia, media);\n\n\t/*\n\t * Call MI attach routines.\n\t */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n#if NBPFILTER > 0\n\tbpfattach(&sc->arpcom.ac_if.if_bpf, ifp,\n\t    DLT_EN10MB, sizeof(struct ether_header));\n#endif\n\tshutdownhook_establish(xl_shutdown, sc);\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void xl_start",
      "void xl_start_90xB",
      "int xl_ioctl",
      "void xl_watchdog",
      "void xl_shutdown",
      "int xl_ifmedia_upd",
      "void xl_ifmedia_sts",
      "int xl_read_eeprom",
      "void xl_setcfg",
      "void xl_setmode",
      "void xl_reset",
      "void xl_mediacheck",
      "void xl_choose_xcvr",
      "int xl_miibus_readreg",
      "void xl_miibus_writereg",
      "void xl_miibus_statchg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "shutdownhook_establish",
          "args": [
            "xl_shutdown",
            "sc"
          ],
          "line": 2590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpfattach",
          "args": [
            "&sc->arpcom.ac_if.if_bpf",
            "ifp",
            "DLT_EN10MB",
            "sizeof(struct ether_header)"
          ],
          "line": 2587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ifattach",
          "args": [
            "ifp"
          ],
          "line": 2584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_attach",
          "args": [
            "ifp"
          ],
          "line": 2583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_set",
          "args": [
            "&sc->ifmedia",
            "media"
          ],
          "line": 2578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"xl%d: unknown XCVR type: %d\\n\"",
            "sc->xl_unit",
            "sc->xl_xcvr"
          ],
          "line": 2567
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xl_setmode",
          "args": [
            "sc",
            "media"
          ],
          "line": 2564
        },
        "resolved": true,
        "details": {
          "function_name": "xl_setmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "738-829",
          "snippet": "void xl_setmode(sc, media)\n\tstruct xl_softc *sc;\n\tint media;\n{\n\tu_int32_t icfg;\n\tu_int16_t mediastat;\n\n\tprintf(\"xl%d: selecting \", sc->xl_unit);\n\n\tXL_SEL_WIN(4);\n\tmediastat = CSR_READ_2(sc, XL_W4_MEDIA_STATUS);\n\tXL_SEL_WIN(3);\n\ticfg = CSR_READ_4(sc, XL_W3_INTERNAL_CFG);\n\n\tif (sc->xl_media & XL_MEDIAOPT_BT) {\n\t\tif (IFM_SUBTYPE(media) == IFM_10_T) {\n\t\t\tprintf(\"10baseT transceiver, \");\n\t\t\tsc->xl_xcvr = XL_XCVR_10BT;\n\t\t\ticfg &= ~XL_ICFG_CONNECTOR_MASK;\n\t\t\ticfg |= (XL_XCVR_10BT << XL_ICFG_CONNECTOR_BITS);\n\t\t\tmediastat |= XL_MEDIASTAT_LINKBEAT|\n\t\t\t\t\tXL_MEDIASTAT_JABGUARD;\n\t\t\tmediastat &= ~XL_MEDIASTAT_SQEENB;\n\t\t}\n\t}\n\n\tif (sc->xl_media & XL_MEDIAOPT_BFX) {\n\t\tif (IFM_SUBTYPE(media) == IFM_100_FX) {\n\t\t\tprintf(\"100baseFX port, \");\n\t\t\tsc->xl_xcvr = XL_XCVR_100BFX;\n\t\t\ticfg &= ~XL_ICFG_CONNECTOR_MASK;\n\t\t\ticfg |= (XL_XCVR_100BFX << XL_ICFG_CONNECTOR_BITS);\n\t\t\tmediastat |= XL_MEDIASTAT_LINKBEAT;\n\t\t\tmediastat &= ~XL_MEDIASTAT_SQEENB;\n\t\t}\n\t}\n\n\tif (sc->xl_media & (XL_MEDIAOPT_AUI|XL_MEDIAOPT_10FL)) {\n\t\tif (IFM_SUBTYPE(media) == IFM_10_5) {\n\t\t\tprintf(\"AUI port, \");\n\t\t\tsc->xl_xcvr = XL_XCVR_AUI;\n\t\t\ticfg &= ~XL_ICFG_CONNECTOR_MASK;\n\t\t\ticfg |= (XL_XCVR_AUI << XL_ICFG_CONNECTOR_BITS);\n\t\t\tmediastat &= ~(XL_MEDIASTAT_LINKBEAT|\n\t\t\t\t\tXL_MEDIASTAT_JABGUARD);\n\t\t\tmediastat |= ~XL_MEDIASTAT_SQEENB;\n\t\t}\n\t\tif (IFM_SUBTYPE(media) == IFM_10_FL) {\n\t\t\tprintf(\"10baseFL transceiver, \");\n\t\t\tsc->xl_xcvr = XL_XCVR_AUI;\n\t\t\ticfg &= ~XL_ICFG_CONNECTOR_MASK;\n\t\t\ticfg |= (XL_XCVR_AUI << XL_ICFG_CONNECTOR_BITS);\n\t\t\tmediastat &= ~(XL_MEDIASTAT_LINKBEAT|\n\t\t\t\t\tXL_MEDIASTAT_JABGUARD);\n\t\t\tmediastat |= ~XL_MEDIASTAT_SQEENB;\n\t\t}\n\t}\n\n\tif (sc->xl_media & XL_MEDIAOPT_BNC) {\n\t\tif (IFM_SUBTYPE(media) == IFM_10_2) {\n\t\t\tprintf(\"BNC port, \");\n\t\t\tsc->xl_xcvr = XL_XCVR_COAX;\n\t\t\ticfg &= ~XL_ICFG_CONNECTOR_MASK;\n\t\t\ticfg |= (XL_XCVR_COAX << XL_ICFG_CONNECTOR_BITS);\n\t\t\tmediastat &= ~(XL_MEDIASTAT_LINKBEAT|\n\t\t\t\t\tXL_MEDIASTAT_JABGUARD|\n\t\t\t\t\tXL_MEDIASTAT_SQEENB);\n\t\t}\n\t}\n\n\tif ((media & IFM_GMASK) == IFM_FDX ||\n\t\t\tIFM_SUBTYPE(media) == IFM_100_FX) {\n\t\tprintf(\"full duplex\\n\");\n\t\tXL_SEL_WIN(3);\n\t\tCSR_WRITE_1(sc, XL_W3_MAC_CTRL, XL_MACCTRL_DUPLEX);\n\t} else {\n\t\tprintf(\"half duplex\\n\");\n\t\tXL_SEL_WIN(3);\n\t\tCSR_WRITE_1(sc, XL_W3_MAC_CTRL,\n\t\t\t(CSR_READ_1(sc, XL_W3_MAC_CTRL) & ~XL_MACCTRL_DUPLEX));\n\t}\n\n\tif (IFM_SUBTYPE(media) == IFM_10_2)\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_START);\n\telse\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_STOP);\n\tCSR_WRITE_4(sc, XL_W3_INTERNAL_CFG, icfg);\n\tXL_SEL_WIN(4);\n\tCSR_WRITE_2(sc, XL_W4_MEDIA_STATUS, mediastat);\n\tDELAY(800);\n\tXL_SEL_WIN(7);\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void xl_setmode"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_setmode;\n\nvoid xl_setmode(sc, media)\n\tstruct xl_softc *sc;\n\tint media;\n{\n\tu_int32_t icfg;\n\tu_int16_t mediastat;\n\n\tprintf(\"xl%d: selecting \", sc->xl_unit);\n\n\tXL_SEL_WIN(4);\n\tmediastat = CSR_READ_2(sc, XL_W4_MEDIA_STATUS);\n\tXL_SEL_WIN(3);\n\ticfg = CSR_READ_4(sc, XL_W3_INTERNAL_CFG);\n\n\tif (sc->xl_media & XL_MEDIAOPT_BT) {\n\t\tif (IFM_SUBTYPE(media) == IFM_10_T) {\n\t\t\tprintf(\"10baseT transceiver, \");\n\t\t\tsc->xl_xcvr = XL_XCVR_10BT;\n\t\t\ticfg &= ~XL_ICFG_CONNECTOR_MASK;\n\t\t\ticfg |= (XL_XCVR_10BT << XL_ICFG_CONNECTOR_BITS);\n\t\t\tmediastat |= XL_MEDIASTAT_LINKBEAT|\n\t\t\t\t\tXL_MEDIASTAT_JABGUARD;\n\t\t\tmediastat &= ~XL_MEDIASTAT_SQEENB;\n\t\t}\n\t}\n\n\tif (sc->xl_media & XL_MEDIAOPT_BFX) {\n\t\tif (IFM_SUBTYPE(media) == IFM_100_FX) {\n\t\t\tprintf(\"100baseFX port, \");\n\t\t\tsc->xl_xcvr = XL_XCVR_100BFX;\n\t\t\ticfg &= ~XL_ICFG_CONNECTOR_MASK;\n\t\t\ticfg |= (XL_XCVR_100BFX << XL_ICFG_CONNECTOR_BITS);\n\t\t\tmediastat |= XL_MEDIASTAT_LINKBEAT;\n\t\t\tmediastat &= ~XL_MEDIASTAT_SQEENB;\n\t\t}\n\t}\n\n\tif (sc->xl_media & (XL_MEDIAOPT_AUI|XL_MEDIAOPT_10FL)) {\n\t\tif (IFM_SUBTYPE(media) == IFM_10_5) {\n\t\t\tprintf(\"AUI port, \");\n\t\t\tsc->xl_xcvr = XL_XCVR_AUI;\n\t\t\ticfg &= ~XL_ICFG_CONNECTOR_MASK;\n\t\t\ticfg |= (XL_XCVR_AUI << XL_ICFG_CONNECTOR_BITS);\n\t\t\tmediastat &= ~(XL_MEDIASTAT_LINKBEAT|\n\t\t\t\t\tXL_MEDIASTAT_JABGUARD);\n\t\t\tmediastat |= ~XL_MEDIASTAT_SQEENB;\n\t\t}\n\t\tif (IFM_SUBTYPE(media) == IFM_10_FL) {\n\t\t\tprintf(\"10baseFL transceiver, \");\n\t\t\tsc->xl_xcvr = XL_XCVR_AUI;\n\t\t\ticfg &= ~XL_ICFG_CONNECTOR_MASK;\n\t\t\ticfg |= (XL_XCVR_AUI << XL_ICFG_CONNECTOR_BITS);\n\t\t\tmediastat &= ~(XL_MEDIASTAT_LINKBEAT|\n\t\t\t\t\tXL_MEDIASTAT_JABGUARD);\n\t\t\tmediastat |= ~XL_MEDIASTAT_SQEENB;\n\t\t}\n\t}\n\n\tif (sc->xl_media & XL_MEDIAOPT_BNC) {\n\t\tif (IFM_SUBTYPE(media) == IFM_10_2) {\n\t\t\tprintf(\"BNC port, \");\n\t\t\tsc->xl_xcvr = XL_XCVR_COAX;\n\t\t\ticfg &= ~XL_ICFG_CONNECTOR_MASK;\n\t\t\ticfg |= (XL_XCVR_COAX << XL_ICFG_CONNECTOR_BITS);\n\t\t\tmediastat &= ~(XL_MEDIASTAT_LINKBEAT|\n\t\t\t\t\tXL_MEDIASTAT_JABGUARD|\n\t\t\t\t\tXL_MEDIASTAT_SQEENB);\n\t\t}\n\t}\n\n\tif ((media & IFM_GMASK) == IFM_FDX ||\n\t\t\tIFM_SUBTYPE(media) == IFM_100_FX) {\n\t\tprintf(\"full duplex\\n\");\n\t\tXL_SEL_WIN(3);\n\t\tCSR_WRITE_1(sc, XL_W3_MAC_CTRL, XL_MACCTRL_DUPLEX);\n\t} else {\n\t\tprintf(\"half duplex\\n\");\n\t\tXL_SEL_WIN(3);\n\t\tCSR_WRITE_1(sc, XL_W3_MAC_CTRL,\n\t\t\t(CSR_READ_1(sc, XL_W3_MAC_CTRL) & ~XL_MACCTRL_DUPLEX));\n\t}\n\n\tif (IFM_SUBTYPE(media) == IFM_10_2)\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_START);\n\telse\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_STOP);\n\tCSR_WRITE_4(sc, XL_W3_INTERNAL_CFG, icfg);\n\tXL_SEL_WIN(4);\n\tCSR_WRITE_2(sc, XL_W4_MEDIA_STATUS, mediastat);\n\tDELAY(800);\n\tXL_SEL_WIN(7);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "ifm",
            "IFM_ETHER|IFM_100_FX",
            "0",
            "NULL"
          ],
          "line": 2534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "ifm",
            "IFM_ETHER|IFM_10_2",
            "0",
            "NULL"
          ],
          "line": 2529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "ifm",
            "IFM_ETHER|IFM_10_5",
            "0",
            "NULL"
          ],
          "line": 2524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "ifm",
            "IFM_ETHER|IFM_10_FL|IFM_FDX",
            "0",
            "NULL"
          ],
          "line": 2521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "ifm",
            "IFM_ETHER|IFM_10_FL|IFM_HDX",
            "0",
            "NULL"
          ],
          "line": 2518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "ifm",
            "IFM_ETHER|IFM_10_FL",
            "0",
            "NULL"
          ],
          "line": 2517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->ifmedia",
            "IFM_ETHER|IFM_10_T|IFM_FDX",
            "0",
            "NULL"
          ],
          "line": 2507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "ifm",
            "IFM_ETHER|IFM_10_T|IFM_HDX",
            "0",
            "NULL"
          ],
          "line": 2505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "ifm",
            "IFM_ETHER|IFM_10_T",
            "0",
            "NULL"
          ],
          "line": 2504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xl_reset",
          "args": [
            "sc",
            "0"
          ],
          "line": 2500
        },
        "resolved": true,
        "details": {
          "function_name": "xl_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "831-860",
          "snippet": "void xl_reset(sc, hard)\n\tstruct xl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tXL_SEL_WIN(0);\n\tif (hard)\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RESET);\n\telse\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RESET | 0x0010);\n\txl_wait(sc);\n\n\tfor (i = 0; i < XL_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(CSR_READ_2(sc, XL_STATUS) & XL_STAT_CMDBUSY))\n\t\t\tbreak;\n\t}\n\n\tDELAY(100000);\n\n\t/* Reset TX and RX. */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_RESET);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\txl_wait(sc);\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tDELAY(100000);\n        return;\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void xl_reset",
            "void xl_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_reset;\nvoid xl_wait;\n\nvoid xl_reset(sc, hard)\n\tstruct xl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tXL_SEL_WIN(0);\n\tif (hard)\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RESET);\n\telse\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RESET | 0x0010);\n\txl_wait(sc);\n\n\tfor (i = 0; i < XL_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(CSR_READ_2(sc, XL_STATUS) & XL_STAT_CMDBUSY))\n\t\t\tbreak;\n\t}\n\n\tDELAY(100000);\n\n\t/* Reset TX and RX. */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_RESET);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\txl_wait(sc);\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tDELAY(100000);\n        return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xl_choose_xcvr",
          "args": [
            "sc",
            "0"
          ],
          "line": 2499
        },
        "resolved": true,
        "details": {
          "function_name": "xl_choose_xcvr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "911-999",
          "snippet": "void xl_choose_xcvr(sc, verbose)\n\tstruct xl_softc *sc;\n\tint verbose;\n{\n\tu_int16_t devid;\n\n\t/*\n\t * Read the device ID from the EEPROM.\n\t * This is what's loaded into the PCI device ID register, so it has\n\t * to be correct otherwise we wouldn't have gotten this far.\n\t */\n\txl_read_eeprom(sc, (caddr_t)&devid, XL_EE_PRODID, 1, 0);\n\n\tswitch(devid) {\n\tcase TC_DEVICEID_BOOMERANG_10BT:\t/* 3c900-TPO */\n\tcase TC_DEVICEID_KRAKATOA_10BT:\t\t/* 3c900B-TPO */\n\t\tsc->xl_media = XL_MEDIAOPT_BT;\n\t\tsc->xl_xcvr = XL_XCVR_10BT;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing 10BaseT transceiver\\n\",\n\t\t\t    sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_BOOMERANG_10BT_COMBO:\t/* 3c900-COMBO */\n\tcase TC_DEVICEID_KRAKATOA_10BT_COMBO:\t/* 3c900B-COMBO */\n\t\tsc->xl_media = XL_MEDIAOPT_BT|XL_MEDIAOPT_BNC|XL_MEDIAOPT_AUI;\n\t\tsc->xl_xcvr = XL_XCVR_10BT;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing COMBO (AUI/BNC/TP)\\n\",\n\t\t\t    sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_KRAKATOA_10BT_TPC:\t/* 3c900B-TPC */\n\t\tsc->xl_media = XL_MEDIAOPT_BT|XL_MEDIAOPT_BNC;\n\t\tsc->xl_xcvr = XL_XCVR_10BT;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing TPC (BNC/TP)\\n\", sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_CYCLONE_10FL:\t\t/* 3c900B-FL */\n\t\tsc->xl_media = XL_MEDIAOPT_10FL;\n\t\tsc->xl_xcvr = XL_XCVR_AUI;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing 10baseFL\\n\", sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_BOOMERANG_10_100BT:\t/* 3c905-TX */\n\t\tsc->xl_media = XL_MEDIAOPT_MII;\n\t\tsc->xl_xcvr = XL_XCVR_MII;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing MII\\n\", sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_BOOMERANG_100BT4:\t/* 3c905-T4 */\n\tcase TC_DEVICEID_CYCLONE_10_100BT4:\t/* 3c905B-T4 */\n\t\tsc->xl_media = XL_MEDIAOPT_BT4;\n\t\tsc->xl_xcvr = XL_XCVR_MII;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing 100BaseT4/MII\\n\", sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_HURRICANE_10_100BT:\t/* 3c905B-TX */\n\tcase TC_DEVICEID_HURRICANE_10_100BT_SERV:/* 3c980-TX */\n\tcase TC_DEVICEID_TORNADO_10_100BT_SERV:\t/* 3c980C-TX */\n\tcase TC_DEVICEID_HURRICANE_SOHO100TX:\t/* 3cSOHO100-TX */\n\tcase TC_DEVICEID_TORNADO_10_100BT:\t/* 3c905C-TX */\n\tcase TC_DEVICEID_TORNADO_HOMECONNECT:\t/* 3c450-TX */\n\t\tsc->xl_media = XL_MEDIAOPT_BTX;\n\t\tsc->xl_xcvr = XL_XCVR_AUTO;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing 10/100 internal\\n\",\n\t\t\t    sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_CYCLONE_10_100_COMBO:\t/* 3c905B-COMBO */\n\t\tsc->xl_media = XL_MEDIAOPT_BTX|XL_MEDIAOPT_BNC|XL_MEDIAOPT_AUI;\n\t\tsc->xl_xcvr = XL_XCVR_AUTO;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing 10/100 plus BNC/AUI\\n\",\n\t\t\t    sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_3CCFE575_CARDBUS:\n\tcase TC_DEVICEID_3CCFE575BT_CARDBUS:\n\tcase TC_DEVICEID_3CCFE575CT_CARDBUS:\n\t\tsc->xl_media = XL_MEDIAOPT_MII;\n\t\tsc->xl_xcvr = XL_XCVR_MII;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"xl%d: unknown device ID: %x -- \"\n\t\t\t\"defaulting to 10baseT\\n\", sc->xl_unit, devid);\n\t\tsc->xl_media = XL_MEDIAOPT_BT;\n\t\tbreak;\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xl_read_eeprom",
            "void xl_choose_xcvr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint xl_read_eeprom;\nvoid xl_choose_xcvr;\n\nvoid xl_choose_xcvr(sc, verbose)\n\tstruct xl_softc *sc;\n\tint verbose;\n{\n\tu_int16_t devid;\n\n\t/*\n\t * Read the device ID from the EEPROM.\n\t * This is what's loaded into the PCI device ID register, so it has\n\t * to be correct otherwise we wouldn't have gotten this far.\n\t */\n\txl_read_eeprom(sc, (caddr_t)&devid, XL_EE_PRODID, 1, 0);\n\n\tswitch(devid) {\n\tcase TC_DEVICEID_BOOMERANG_10BT:\t/* 3c900-TPO */\n\tcase TC_DEVICEID_KRAKATOA_10BT:\t\t/* 3c900B-TPO */\n\t\tsc->xl_media = XL_MEDIAOPT_BT;\n\t\tsc->xl_xcvr = XL_XCVR_10BT;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing 10BaseT transceiver\\n\",\n\t\t\t    sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_BOOMERANG_10BT_COMBO:\t/* 3c900-COMBO */\n\tcase TC_DEVICEID_KRAKATOA_10BT_COMBO:\t/* 3c900B-COMBO */\n\t\tsc->xl_media = XL_MEDIAOPT_BT|XL_MEDIAOPT_BNC|XL_MEDIAOPT_AUI;\n\t\tsc->xl_xcvr = XL_XCVR_10BT;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing COMBO (AUI/BNC/TP)\\n\",\n\t\t\t    sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_KRAKATOA_10BT_TPC:\t/* 3c900B-TPC */\n\t\tsc->xl_media = XL_MEDIAOPT_BT|XL_MEDIAOPT_BNC;\n\t\tsc->xl_xcvr = XL_XCVR_10BT;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing TPC (BNC/TP)\\n\", sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_CYCLONE_10FL:\t\t/* 3c900B-FL */\n\t\tsc->xl_media = XL_MEDIAOPT_10FL;\n\t\tsc->xl_xcvr = XL_XCVR_AUI;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing 10baseFL\\n\", sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_BOOMERANG_10_100BT:\t/* 3c905-TX */\n\t\tsc->xl_media = XL_MEDIAOPT_MII;\n\t\tsc->xl_xcvr = XL_XCVR_MII;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing MII\\n\", sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_BOOMERANG_100BT4:\t/* 3c905-T4 */\n\tcase TC_DEVICEID_CYCLONE_10_100BT4:\t/* 3c905B-T4 */\n\t\tsc->xl_media = XL_MEDIAOPT_BT4;\n\t\tsc->xl_xcvr = XL_XCVR_MII;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing 100BaseT4/MII\\n\", sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_HURRICANE_10_100BT:\t/* 3c905B-TX */\n\tcase TC_DEVICEID_HURRICANE_10_100BT_SERV:/* 3c980-TX */\n\tcase TC_DEVICEID_TORNADO_10_100BT_SERV:\t/* 3c980C-TX */\n\tcase TC_DEVICEID_HURRICANE_SOHO100TX:\t/* 3cSOHO100-TX */\n\tcase TC_DEVICEID_TORNADO_10_100BT:\t/* 3c905C-TX */\n\tcase TC_DEVICEID_TORNADO_HOMECONNECT:\t/* 3c450-TX */\n\t\tsc->xl_media = XL_MEDIAOPT_BTX;\n\t\tsc->xl_xcvr = XL_XCVR_AUTO;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing 10/100 internal\\n\",\n\t\t\t    sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_CYCLONE_10_100_COMBO:\t/* 3c905B-COMBO */\n\t\tsc->xl_media = XL_MEDIAOPT_BTX|XL_MEDIAOPT_BNC|XL_MEDIAOPT_AUI;\n\t\tsc->xl_xcvr = XL_XCVR_AUTO;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing 10/100 plus BNC/AUI\\n\",\n\t\t\t    sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_3CCFE575_CARDBUS:\n\tcase TC_DEVICEID_3CCFE575BT_CARDBUS:\n\tcase TC_DEVICEID_3CCFE575CT_CARDBUS:\n\t\tsc->xl_media = XL_MEDIAOPT_MII;\n\t\tsc->xl_xcvr = XL_XCVR_MII;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"xl%d: unknown device ID: %x -- \"\n\t\t\t\"defaulting to 10baseT\\n\", sc->xl_unit, devid);\n\t\tsc->xl_media = XL_MEDIAOPT_BT;\n\t\tbreak;\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ifmedia_init",
          "args": [
            "&sc->ifmedia",
            "0",
            "xl_ifmedia_upd",
            "xl_ifmedia_sts"
          ],
          "line": 2488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_set",
          "args": [
            "&sc->sc_mii.mii_media",
            "IFM_ETHER|IFM_AUTO"
          ],
          "line": 2483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_set",
          "args": [
            "&sc->sc_mii.mii_media",
            "IFM_ETHER|IFM_NONE"
          ],
          "line": 2480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->sc_mii.mii_media",
            "IFM_ETHER|IFM_NONE",
            "0",
            "NULL"
          ],
          "line": 2478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_FIRST",
          "args": [
            "&sc->sc_mii.mii_phys"
          ],
          "line": 2477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mii_phy_probe",
          "args": [
            "(struct device *)sc",
            "&sc->sc_mii",
            "0xffffffff"
          ],
          "line": 2475
        },
        "resolved": true,
        "details": {
          "function_name": "mii_phy_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/mii.c",
          "lines": "68-122",
          "snippet": "void\nmii_phy_probe(parent, mii, capmask)\n\tstruct device *parent;\n\tstruct mii_data *mii;\n\tint capmask;\n{\n\tstruct mii_attach_args ma;\n\tstruct mii_softc *child;\n\n\tLIST_INIT(&mii->mii_phys);\n\n\tfor (ma.mii_phyno = 0; ma.mii_phyno < MII_NPHY; ma.mii_phyno++) {\n\t\t/*\n\t\t * Check to see if there is a PHY at this address.  If\n\t\t * the register contains garbage, assume no.\n\t\t */\n\t\tma.mii_id1 = (*mii->mii_readreg)(parent, ma.mii_phyno,\n\t\t    MII_PHYIDR1);\n\t\tma.mii_id2 = (*mii->mii_readreg)(parent, ma.mii_phyno,\n\t\t    MII_PHYIDR2);\n\t\tif ((ma.mii_id1 == 0 || ma.mii_id1 == 0xffff) &&\n\t\t    (ma.mii_id2 == 0 || ma.mii_id2 == 0xffff)) {\n\t\t\t/*\n\t\t\t * ARGH!!  3Com internal PHYs report 0/0 in their\n\t\t\t * ID registers!  If we spot this, check to see\n\t\t\t * if the BMSR has reasonable data in it.\n\t\t\t * And if that wasn't enough there are PHYs\n\t\t\t * reporting 0xffff/0xffff too.\n\t\t\t */\n\t\t\tif ((MII_OUI(ma.mii_id1, ma.mii_id2) == 0 &&\n\t\t\t    MII_MODEL(ma.mii_id2) == 0) ||\n\t\t\t    (MII_OUI(ma.mii_id1, ma.mii_id2) == 0x3fffff &&\n\t\t\t    MII_MODEL(ma.mii_id2) == 0x3f)) {\n\t\t\t\tint bmsr = (*mii->mii_readreg)(parent,\n\t\t\t\t    ma.mii_phyno, MII_BMSR);\n\t\t\t\tif (bmsr == 0 || bmsr == 0xffff ||\n\t\t\t\t    (bmsr & BMSR_MEDIAMASK) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tma.mii_data = mii;\n\t\tma.mii_capmask = capmask;\n\n\t\tif ((child = (struct mii_softc *)config_found_sm(parent, &ma,\n\t\t    mii_print, mii_submatch)) != NULL) {\n\t\t\t/*\n\t\t\t * Link it up in the parent's MII data.\n\t\t\t */\n\t\t\tLIST_INSERT_HEAD(&mii->mii_phys, child, mii_list);\n\t\t\tmii->mii_instance++;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tmii_print",
            "int\tmii_submatch"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nint\tmii_print;\nint\tmii_submatch;\n\nvoid\nmii_phy_probe(parent, mii, capmask)\n\tstruct device *parent;\n\tstruct mii_data *mii;\n\tint capmask;\n{\n\tstruct mii_attach_args ma;\n\tstruct mii_softc *child;\n\n\tLIST_INIT(&mii->mii_phys);\n\n\tfor (ma.mii_phyno = 0; ma.mii_phyno < MII_NPHY; ma.mii_phyno++) {\n\t\t/*\n\t\t * Check to see if there is a PHY at this address.  If\n\t\t * the register contains garbage, assume no.\n\t\t */\n\t\tma.mii_id1 = (*mii->mii_readreg)(parent, ma.mii_phyno,\n\t\t    MII_PHYIDR1);\n\t\tma.mii_id2 = (*mii->mii_readreg)(parent, ma.mii_phyno,\n\t\t    MII_PHYIDR2);\n\t\tif ((ma.mii_id1 == 0 || ma.mii_id1 == 0xffff) &&\n\t\t    (ma.mii_id2 == 0 || ma.mii_id2 == 0xffff)) {\n\t\t\t/*\n\t\t\t * ARGH!!  3Com internal PHYs report 0/0 in their\n\t\t\t * ID registers!  If we spot this, check to see\n\t\t\t * if the BMSR has reasonable data in it.\n\t\t\t * And if that wasn't enough there are PHYs\n\t\t\t * reporting 0xffff/0xffff too.\n\t\t\t */\n\t\t\tif ((MII_OUI(ma.mii_id1, ma.mii_id2) == 0 &&\n\t\t\t    MII_MODEL(ma.mii_id2) == 0) ||\n\t\t\t    (MII_OUI(ma.mii_id1, ma.mii_id2) == 0x3fffff &&\n\t\t\t    MII_MODEL(ma.mii_id2) == 0x3f)) {\n\t\t\t\tint bmsr = (*mii->mii_readreg)(parent,\n\t\t\t\t    ma.mii_phyno, MII_BMSR);\n\t\t\t\tif (bmsr == 0 || bmsr == 0xffff ||\n\t\t\t\t    (bmsr & BMSR_MEDIAMASK) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tma.mii_data = mii;\n\t\tma.mii_capmask = capmask;\n\n\t\tif ((child = (struct mii_softc *)config_found_sm(parent, &ma,\n\t\t    mii_print, mii_submatch)) != NULL) {\n\t\t\t/*\n\t\t\t * Link it up in the parent's MII data.\n\t\t\t */\n\t\t\tLIST_INSERT_HEAD(&mii->mii_phys, child, mii_list);\n\t\t\tmii->mii_instance++;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xl_setcfg",
          "args": [
            "sc"
          ],
          "line": 2474
        },
        "resolved": true,
        "details": {
          "function_name": "xl_setcfg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "720-736",
          "snippet": "void xl_setcfg(sc)\n\tstruct xl_softc *sc;\n{\n\tu_int32_t icfg;\n\n\tXL_SEL_WIN(3);\n\ticfg = CSR_READ_4(sc, XL_W3_INTERNAL_CFG);\n\ticfg &= ~XL_ICFG_CONNECTOR_MASK;\n\tif (sc->xl_media & XL_MEDIAOPT_MII ||\n\t    sc->xl_media & XL_MEDIAOPT_BT4)\n\t\ticfg |= (XL_XCVR_MII << XL_ICFG_CONNECTOR_BITS);\n\tif (sc->xl_media & XL_MEDIAOPT_BTX)\n\t\ticfg |= (XL_XCVR_AUTO << XL_ICFG_CONNECTOR_BITS);\n\n\tCSR_WRITE_4(sc, XL_W3_INTERNAL_CFG, icfg);\n\tCSR_WRITE_4(sc, XL_COMMAND, XL_CMD_COAX_STOP);\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void xl_setcfg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_setcfg;\n\nvoid xl_setcfg(sc)\n\tstruct xl_softc *sc;\n{\n\tu_int32_t icfg;\n\n\tXL_SEL_WIN(3);\n\ticfg = CSR_READ_4(sc, XL_W3_INTERNAL_CFG);\n\ticfg &= ~XL_ICFG_CONNECTOR_MASK;\n\tif (sc->xl_media & XL_MEDIAOPT_MII ||\n\t    sc->xl_media & XL_MEDIAOPT_BT4)\n\t\ticfg |= (XL_XCVR_MII << XL_ICFG_CONNECTOR_BITS);\n\tif (sc->xl_media & XL_MEDIAOPT_BTX)\n\t\ticfg |= (XL_XCVR_AUTO << XL_ICFG_CONNECTOR_BITS);\n\n\tCSR_WRITE_4(sc, XL_W3_INTERNAL_CFG, icfg);\n\tCSR_WRITE_4(sc, XL_COMMAND, XL_CMD_COAX_STOP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ifmedia_init",
          "args": [
            "&sc->sc_mii.mii_media",
            "0",
            "xl_ifmedia_upd",
            "xl_ifmedia_sts"
          ],
          "line": 2467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "100000"
          ],
          "line": 2463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "12",
            "0x4000 | CSR_READ_2(sc, 12)"
          ],
          "line": 2461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "12"
          ],
          "line": 2461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XL_SEL_WIN",
          "args": [
            "2"
          ],
          "line": 2460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xl_mediacheck",
          "args": [
            "sc"
          ],
          "line": 2457
        },
        "resolved": true,
        "details": {
          "function_name": "xl_mediacheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "874-909",
          "snippet": "void xl_mediacheck(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\t/*\n\t * If some of the media options bits are set, assume they are\n\t * correct. If not, try to figure it out down below.\n\t * XXX I should check for 10baseFL, but I don't have an adapter\n\t * to test with.\n\t */\n\tif (sc->xl_media & (XL_MEDIAOPT_MASK & ~XL_MEDIAOPT_VCO)) {\n\t\t/*\n\t \t * Check the XCVR value. If it's not in the normal range\n\t \t * of values, we need to fake it up here.\n\t \t */\n\t\tif (sc->xl_xcvr <= XL_XCVR_AUTO)\n\t\t\treturn;\n\t\telse {\n\t\t\tprintf(\"xl%d: bogus xcvr value \"\n\t\t\t\"in EEPROM (%x)\\n\", sc->xl_unit, sc->xl_xcvr);\n\t\t\tprintf(\"xl%d: choosing new default based \"\n\t\t\t\t\"on card type\\n\", sc->xl_unit);\n\t\t}\n\t} else {\n\t\tif (sc->xl_type == XL_TYPE_905B &&\n\t\t    sc->xl_media & XL_MEDIAOPT_10FL)\n\t\t\treturn;\n\t\tprintf(\"xl%d: WARNING: no media options bits set in \"\n\t\t\t\"the media options register!!\\n\", sc->xl_unit);\n\t\tprintf(\"xl%d: this could be a manufacturing defect in \"\n\t\t\t\"your adapter or system\\n\", sc->xl_unit);\n\t\tprintf(\"xl%d: attempting to guess media type; you \"\n\t\t\t\"should probably consult your vendor\\n\", sc->xl_unit);\n\t}\n\n\txl_choose_xcvr(sc, 1);\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void xl_mediacheck",
            "void xl_choose_xcvr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_mediacheck;\nvoid xl_choose_xcvr;\n\nvoid xl_mediacheck(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\t/*\n\t * If some of the media options bits are set, assume they are\n\t * correct. If not, try to figure it out down below.\n\t * XXX I should check for 10baseFL, but I don't have an adapter\n\t * to test with.\n\t */\n\tif (sc->xl_media & (XL_MEDIAOPT_MASK & ~XL_MEDIAOPT_VCO)) {\n\t\t/*\n\t \t * Check the XCVR value. If it's not in the normal range\n\t \t * of values, we need to fake it up here.\n\t \t */\n\t\tif (sc->xl_xcvr <= XL_XCVR_AUTO)\n\t\t\treturn;\n\t\telse {\n\t\t\tprintf(\"xl%d: bogus xcvr value \"\n\t\t\t\"in EEPROM (%x)\\n\", sc->xl_unit, sc->xl_xcvr);\n\t\t\tprintf(\"xl%d: choosing new default based \"\n\t\t\t\t\"on card type\\n\", sc->xl_unit);\n\t\t}\n\t} else {\n\t\tif (sc->xl_type == XL_TYPE_905B &&\n\t\t    sc->xl_media & XL_MEDIAOPT_10FL)\n\t\t\treturn;\n\t\tprintf(\"xl%d: WARNING: no media options bits set in \"\n\t\t\t\"the media options register!!\\n\", sc->xl_unit);\n\t\tprintf(\"xl%d: this could be a manufacturing defect in \"\n\t\t\t\"your adapter or system\\n\", sc->xl_unit);\n\t\tprintf(\"xl%d: attempting to guess media type; you \"\n\t\t\t\"should probably consult your vendor\\n\", sc->xl_unit);\n\t}\n\n\txl_choose_xcvr(sc, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "100000"
          ],
          "line": 2455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "12",
            "0x4000 | CSR_READ_2(sc, 12)"
          ],
          "line": 2453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "12"
          ],
          "line": 2453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XL_SEL_WIN",
          "args": [
            "2"
          ],
          "line": 2452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xl_read_eeprom",
          "args": [
            "sc",
            "(char *)&sc->xl_xcvr",
            "XL_EE_ICFG_0",
            "2",
            "0"
          ],
          "line": 2447
        },
        "resolved": true,
        "details": {
          "function_name": "xl_read_eeprom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "518-554",
          "snippet": "int xl_read_eeprom(sc, dest, off, cnt, swap)\n\tstruct xl_softc\t\t*sc;\n\tcaddr_t\t\t\tdest;\n\tint\t\t\toff;\n\tint\t\t\tcnt;\n\tint\t\t\tswap;\n{\n\tint\t\t\terr = 0, i;\n\tu_int16_t\t\tword = 0, *ptr;\n\n\tXL_SEL_WIN(0);\n\n\tif (xl_eeprom_wait(sc))\n\t\treturn(1);\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tswitch (sc->xl_bustype) {\n\t\tcase XL_BUS_PCI:\n\t\t\tCSR_WRITE_2(sc, XL_W0_EE_CMD, XL_EE_READ | (off + i));\n\t\t\tbreak;\n\t\tcase XL_BUS_CARDBUS:\n\t\t\tCSR_WRITE_2(sc, XL_W0_EE_CMD, 0x230 + (off + i));\n\t\t\tbreak;\n\t\t}\n\t\terr = xl_eeprom_wait(sc);\n\t\tif (err)\n\t\t\tbreak;\n\t\tword = CSR_READ_2(sc, XL_W0_EE_DATA);\n\t\tptr = (u_int16_t *)(dest + (i * 2));\n\t\tif (swap)\n\t\t\t*ptr = ntohs(word);\n\t\telse\n\t\t\t*ptr = word;\t\n\t}\n\n\treturn(err ? 1 : 0);\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xl_eeprom_wait",
            "int xl_read_eeprom"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint xl_eeprom_wait;\nint xl_read_eeprom;\n\nint xl_read_eeprom(sc, dest, off, cnt, swap)\n\tstruct xl_softc\t\t*sc;\n\tcaddr_t\t\t\tdest;\n\tint\t\t\toff;\n\tint\t\t\tcnt;\n\tint\t\t\tswap;\n{\n\tint\t\t\terr = 0, i;\n\tu_int16_t\t\tword = 0, *ptr;\n\n\tXL_SEL_WIN(0);\n\n\tif (xl_eeprom_wait(sc))\n\t\treturn(1);\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tswitch (sc->xl_bustype) {\n\t\tcase XL_BUS_PCI:\n\t\t\tCSR_WRITE_2(sc, XL_W0_EE_CMD, XL_EE_READ | (off + i));\n\t\t\tbreak;\n\t\tcase XL_BUS_CARDBUS:\n\t\t\tCSR_WRITE_2(sc, XL_W0_EE_CMD, 0x230 + (off + i));\n\t\t\tbreak;\n\t\t}\n\t\terr = xl_eeprom_wait(sc);\n\t\tif (err)\n\t\t\tbreak;\n\t\tword = CSR_READ_2(sc, XL_W0_EE_DATA);\n\t\tptr = (u_int16_t *)(dest + (i * 2));\n\t\tif (swap)\n\t\t\t*ptr = ntohs(word);\n\t\telse\n\t\t\t*ptr = word;\t\n\t}\n\n\treturn(err ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "XL_W3_MEDIA_OPT"
          ],
          "line": 2445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XL_SEL_WIN",
          "args": [
            "3"
          ],
          "line": 2444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "sc->sc_dev.dv_xname",
            "ifp->if_xname",
            "IFNAMSIZ"
          ],
          "line": 2442
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "sc->xl_ldata",
            "sizeof(struct xl_list_data)"
          ],
          "line": 2417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct xl_list_data) + 8",
            "M_DEVBUF",
            "M_NOWAIT"
          ],
          "line": 2395
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "12",
            "n"
          ],
          "line": 2392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "12"
          ],
          "line": 2384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XL_SEL_WIN",
          "args": [
            "2"
          ],
          "line": 2383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_sprintf",
          "args": [
            "sc->arpcom.ac_enaddr"
          ],
          "line": 2377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_start;\nvoid xl_start_90xB;\nint xl_ioctl;\nvoid xl_watchdog;\nvoid xl_shutdown;\nint xl_ifmedia_upd;\nvoid xl_ifmedia_sts;\nint xl_read_eeprom;\nvoid xl_setcfg;\nvoid xl_setmode;\nvoid xl_reset;\nvoid xl_mediacheck;\nvoid xl_choose_xcvr;\nint xl_miibus_readreg;\nvoid xl_miibus_writereg;\nvoid xl_miibus_statchg;\n\nvoid\nxl_attach(sc)\n\tstruct xl_softc *sc;\n{\n\tu_int8_t enaddr[ETHER_ADDR_LEN];\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tcaddr_t roundptr;\n\tu_int round;\n\tint i, media = IFM_ETHER|IFM_100_TX|IFM_FDX;\n\tstruct ifmedia *ifm;\n\n\tsc->xl_unit = sc->sc_dev.dv_unit;\n\txl_reset(sc, 1);\n\n\t/*\n\t * Get station address from the EEPROM.\n\t */\n\tif (xl_read_eeprom(sc, (caddr_t)&enaddr, XL_EE_OEM_ADR0, 3, 1)) {\n\t\tprintf(\"\\n%s: failed to read station address\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\tbcopy(enaddr, (char *)&sc->arpcom.ac_enaddr, ETHER_ADDR_LEN);\n\n\tprintf(\" address %s\\n\", ether_sprintf(sc->arpcom.ac_enaddr));\n\n\tif (sc->xl_bustype == XL_BUS_CARDBUS) {\n\t\tu_int16_t devid;\n\t\tu_int16_t n;\n\n\t\tXL_SEL_WIN(2);\n\t\tn = CSR_READ_2(sc, 12);\n\t\txl_read_eeprom(sc, (caddr_t)&devid, XL_EE_PRODID, 1, 0);\n\n\t\tif (devid != 0x5257)\n\t\t\tn |= 0x0010;\n\t\tif (devid == 0x5257 || devid == 0x6560 || devid == 0x6562)\n\t\t\tn |= 0x4000;\n\n\t\tCSR_WRITE_2(sc, 12, n);\n\t}\n\n\tsc->xl_ldata_ptr = malloc(sizeof(struct xl_list_data) + 8,\n\t    M_DEVBUF, M_NOWAIT);\n\tif (sc->xl_ldata_ptr == NULL) {\n\t\tprintf(\"%s: no memory for list buffers\\n\",sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\tsc->xl_ldata = (struct xl_list_data *)sc->xl_ldata_ptr;\n#ifdef __alpha__\n\tround = (u_int64_t)sc->xl_ldata_ptr & 0xf;\n#else\n\tround = (u_int32_t)sc->xl_ldata_ptr & 0xf;\n#endif\n\troundptr = sc->xl_ldata_ptr;\n\tfor (i = 0; i < 8; i++) {\n\t\tif (round % 8) {\n\t\t\tround++;\n\t\t\troundptr++;\n\t\t} else\n\t\t\tbreak;\n\t}\n\tsc->xl_ldata = (struct xl_list_data *)roundptr;\n\tbzero(sc->xl_ldata, sizeof(struct xl_list_data));\n\n\t/*\n\t * Figure out the card type. 3c905B adapters have the\n\t * 'supportsNoTxLength' bit set in the capabilities\n\t * word in the EEPROM.\n\t */\n\txl_read_eeprom(sc, (caddr_t)&sc->xl_caps, XL_EE_CAPS, 1, 0);\n\tif (sc->xl_caps & XL_CAPS_NO_TXLENGTH)\n\t\tsc->xl_type = XL_TYPE_905B;\n\telse\n\t\tsc->xl_type = XL_TYPE_90X;\n\n\tifp->if_softc = sc;\n\tifp->if_mtu = ETHERMTU;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;\n\tifp->if_ioctl = xl_ioctl;\n\tifp->if_output = ether_output;\n\tif (sc->xl_type == XL_TYPE_905B)\n\t\tifp->if_start = xl_start_90xB;\n\telse\n\t\tifp->if_start = xl_start;\n\tifp->if_watchdog = xl_watchdog;\n\tifp->if_baudrate = 10000000;\n\tifp->if_snd.ifq_maxlen = XL_TX_LIST_CNT - 1;\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\n\tXL_SEL_WIN(3);\n\tsc->xl_media = CSR_READ_2(sc, XL_W3_MEDIA_OPT);\n\n\txl_read_eeprom(sc, (char *)&sc->xl_xcvr, XL_EE_ICFG_0, 2, 0);\n\tsc->xl_xcvr &= XL_ICFG_CONNECTOR_MASK;\n\tsc->xl_xcvr >>= XL_ICFG_CONNECTOR_BITS;\n\n\tif (sc->xl_bustype == XL_BUS_CARDBUS) {\n\t\tXL_SEL_WIN(2);\n\t\tCSR_WRITE_2(sc, 12, 0x4000 | CSR_READ_2(sc, 12));\n\t}\n\tDELAY(100000);\n\n\txl_mediacheck(sc);\n\n\tif (sc->xl_bustype == XL_BUS_CARDBUS) {\n\t\tXL_SEL_WIN(2);\n\t\tCSR_WRITE_2(sc, 12, 0x4000 | CSR_READ_2(sc, 12));\n\t}\n\tDELAY(100000);\n\n\tif (sc->xl_media & XL_MEDIAOPT_MII || sc->xl_media & XL_MEDIAOPT_BTX\n\t    || sc->xl_media & XL_MEDIAOPT_BT4) {\n\t\tifmedia_init(&sc->sc_mii.mii_media, 0,\n\t\t    xl_ifmedia_upd, xl_ifmedia_sts);\n\t\tsc->xl_hasmii = 1;\n\t\tsc->sc_mii.mii_ifp = ifp;\n\t\tsc->sc_mii.mii_readreg = xl_miibus_readreg;\n\t\tsc->sc_mii.mii_writereg = xl_miibus_writereg;\n\t\tsc->sc_mii.mii_statchg = xl_miibus_statchg;\n\t\txl_setcfg(sc);\n\t\tmii_phy_probe((struct device *)sc, &sc->sc_mii, 0xffffffff);\n\n\t\tif (LIST_FIRST(&sc->sc_mii.mii_phys) == NULL) {\n\t\t\tifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE,\n\t\t\t    0, NULL);\n\t\t\tifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE);\n\t\t}\n\t\telse {\n\t\t\tifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO);\n\t\t}\n\t\tifm = &sc->sc_mii.mii_media;\n\t}\n\telse {\n\t\tifmedia_init(&sc->ifmedia, 0, xl_ifmedia_upd, xl_ifmedia_sts);\n\t\tsc->xl_hasmii = 0;\n\t\tifm = &sc->ifmedia;\n\t}\n\n\t/*\n\t * Sanity check. If the user has selected \"auto\" and this isn't\n\t * a 10/100 card of some kind, we need to force the transceiver\n\t * type to something sane.\n\t */\n\tif (sc->xl_xcvr == XL_XCVR_AUTO) {\n\t\txl_choose_xcvr(sc, 0);\n\t\txl_reset(sc, 0);\n\t}\n\n\tif (sc->xl_media & XL_MEDIAOPT_BT) {\n\t\tifmedia_add(ifm, IFM_ETHER|IFM_10_T, 0, NULL);\n\t\tifmedia_add(ifm, IFM_ETHER|IFM_10_T|IFM_HDX, 0, NULL);\n\t\tif (sc->xl_caps & XL_CAPS_FULL_DUPLEX)\n\t\t\tifmedia_add(&sc->ifmedia,\n\t\t\t    IFM_ETHER|IFM_10_T|IFM_FDX, 0, NULL);\n\t}\n\n\tif (sc->xl_media & (XL_MEDIAOPT_AUI|XL_MEDIAOPT_10FL)) {\n\t\t/*\n\t\t * Check for a 10baseFL board in disguise.\n\t\t */\n\t\tif (sc->xl_type == XL_TYPE_905B &&\n\t\t    sc->xl_media == XL_MEDIAOPT_10FL) {\n\t\t\tifmedia_add(ifm, IFM_ETHER|IFM_10_FL, 0, NULL);\n\t\t\tifmedia_add(ifm, IFM_ETHER|IFM_10_FL|IFM_HDX,\n\t\t\t    0, NULL);\n\t\t\tif (sc->xl_caps & XL_CAPS_FULL_DUPLEX)\n\t\t\t\tifmedia_add(ifm,\n\t\t\t\t    IFM_ETHER|IFM_10_FL|IFM_FDX, 0, NULL);\n\t\t} else {\n\t\t\tifmedia_add(ifm, IFM_ETHER|IFM_10_5, 0, NULL);\n\t\t}\n\t}\n\n\tif (sc->xl_media & XL_MEDIAOPT_BNC) {\n\t\tifmedia_add(ifm, IFM_ETHER|IFM_10_2, 0, NULL);\n\t}\n\n\tif (sc->xl_media & XL_MEDIAOPT_BFX) {\n\t\tifp->if_baudrate = 100000000;\n\t\tifmedia_add(ifm, IFM_ETHER|IFM_100_FX, 0, NULL);\n\t}\n\n\t/* Choose a default media. */\n\tswitch(sc->xl_xcvr) {\n\tcase XL_XCVR_10BT:\n\t\tmedia = IFM_ETHER|IFM_10_T;\n\t\txl_setmode(sc, media);\n\t\tbreak;\n\tcase XL_XCVR_AUI:\n\t\tif (sc->xl_type == XL_TYPE_905B &&\n\t\t    sc->xl_media == XL_MEDIAOPT_10FL) {\n\t\t\tmedia = IFM_ETHER|IFM_10_FL;\n\t\t\txl_setmode(sc, media);\n\t\t} else {\n\t\t\tmedia = IFM_ETHER|IFM_10_5;\n\t\t\txl_setmode(sc, media);\n\t\t}\n\t\tbreak;\n\tcase XL_XCVR_COAX:\n\t\tmedia = IFM_ETHER|IFM_10_2;\n\t\txl_setmode(sc, media);\n\t\tbreak;\n\tcase XL_XCVR_AUTO:\n\tcase XL_XCVR_100BTX:\n\tcase XL_XCVR_MII:\n\t\t/* Chosen by miibus */\n\t\tbreak;\n\tcase XL_XCVR_100BFX:\n\t\tmedia = IFM_ETHER|IFM_100_FX;\n\t\txl_setmode(sc, media);\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"xl%d: unknown XCVR type: %d\\n\", sc->xl_unit,\n\t\t\t\t\t\t\tsc->xl_xcvr);\n\t\t/*\n\t\t * This will probably be wrong, but it prevents\n\t\t * the ifmedia code from panicking.\n\t\t */\n\t\tmedia = IFM_ETHER | IFM_10_T;\n\t\tbreak;\n\t}\n\n\tif (sc->xl_hasmii == 0)\n\t\tifmedia_set(&sc->ifmedia, media);\n\n\t/*\n\t * Call MI attach routines.\n\t */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n#if NBPFILTER > 0\n\tbpfattach(&sc->arpcom.ac_if.if_bpf, ifp,\n\t    DLT_EN10MB, sizeof(struct ether_header));\n#endif\n\tshutdownhook_establish(xl_shutdown, sc);\n}"
  },
  {
    "function_name": "xl_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
    "lines": "2290-2351",
    "snippet": "void xl_stop(sc)\n\tstruct xl_softc *sc;\n{\n\tint i;\n\tstruct ifnet *ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_timer = 0;\n\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_DISABLE);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STATS_DISABLE);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ENB);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_DISCARD);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_DISABLE);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_STOP);\n\tDELAY(800);\n\n#ifdef foo\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_RESET);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\txl_wait(sc);\n#endif\n\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ACK|XL_STAT_INTLATCH);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STAT_ENB|0);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ENB|0);\n\n\tif (sc->xl_bustype == XL_BUS_CARDBUS)\n\t\tbus_space_write_4(sc->xl_funct, sc->xl_funch, 4, 0x8000);\n\n\t/* Stop the stats updater. */\n\tuntimeout(xl_stats_update, sc);\n\n\t/*\n\t * Free data in the RX lists.\n\t */\n\tfor (i = 0; i < XL_RX_LIST_CNT; i++) {\n\t\tif (sc->xl_cdata.xl_rx_chain[i].xl_mbuf != NULL) {\n\t\t\tm_freem(sc->xl_cdata.xl_rx_chain[i].xl_mbuf);\n\t\t\tsc->xl_cdata.xl_rx_chain[i].xl_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->xl_ldata->xl_rx_list,\n\t\tsizeof(sc->xl_ldata->xl_rx_list));\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < XL_TX_LIST_CNT; i++) {\n\t\tif (sc->xl_cdata.xl_tx_chain[i].xl_mbuf != NULL) {\n\t\t\tm_freem(sc->xl_cdata.xl_tx_chain[i].xl_mbuf);\n\t\t\tsc->xl_cdata.xl_tx_chain[i].xl_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->xl_ldata->xl_tx_list,\n\t\tsizeof(sc->xl_ldata->xl_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void xl_stats_update",
      "void xl_stop",
      "void xl_wait"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)&sc->xl_ldata->xl_tx_list",
            "sizeof(sc->xl_ldata->xl_tx_list)"
          ],
          "line": 2345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "sc->xl_cdata.xl_tx_chain[i].xl_mbuf"
          ],
          "line": 2341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)&sc->xl_ldata->xl_rx_list",
            "sizeof(sc->xl_ldata->xl_rx_list)"
          ],
          "line": 2334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "sc->xl_cdata.xl_rx_chain[i].xl_mbuf"
          ],
          "line": 2330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "xl_stats_update",
            "sc"
          ],
          "line": 2323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_4",
          "args": [
            "sc->xl_funct",
            "sc->xl_funch",
            "4",
            "0x8000"
          ],
          "line": 2320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_INTR_ENB|0"
          ],
          "line": 2317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_STAT_ENB|0"
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_INTR_ACK|XL_STAT_INTLATCH"
          ],
          "line": 2315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xl_wait",
          "args": [
            "sc"
          ],
          "line": 2312
        },
        "resolved": true,
        "details": {
          "function_name": "xl_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "200-216",
          "snippet": "void xl_wait(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tfor (i = 0; i < XL_TIMEOUT; i++) {\n\t\tif (!(CSR_READ_2(sc, XL_STATUS) & XL_STAT_CMDBUSY))\n\t\t\tbreak;\n\t}\n\n#ifdef DIAGNOSTIC\n\tif (i == XL_TIMEOUT)\n\t\tprintf(\"xl%d: command never completed!\\n\", sc->xl_unit);\n#endif\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void xl_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_wait;\n\nvoid xl_wait(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tfor (i = 0; i < XL_TIMEOUT; i++) {\n\t\tif (!(CSR_READ_2(sc, XL_STATUS) & XL_STAT_CMDBUSY))\n\t\t\tbreak;\n\t}\n\n#ifdef DIAGNOSTIC\n\tif (i == XL_TIMEOUT)\n\t\tprintf(\"xl%d: command never completed!\\n\", sc->xl_unit);\n#endif\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_TX_RESET"
          ],
          "line": 2311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_RX_RESET"
          ],
          "line": 2309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "800"
          ],
          "line": 2306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_COAX_STOP"
          ],
          "line": 2305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_TX_DISABLE"
          ],
          "line": 2304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_RX_DISCARD"
          ],
          "line": 2302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_INTR_ENB"
          ],
          "line": 2301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_STATS_DISABLE"
          ],
          "line": 2300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_RX_DISABLE"
          ],
          "line": 2299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_stats_update;\nvoid xl_stop;\nvoid xl_wait;\n\nvoid xl_stop(sc)\n\tstruct xl_softc *sc;\n{\n\tint i;\n\tstruct ifnet *ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_timer = 0;\n\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_DISABLE);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STATS_DISABLE);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ENB);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_DISCARD);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_DISABLE);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_STOP);\n\tDELAY(800);\n\n#ifdef foo\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_RESET);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\txl_wait(sc);\n#endif\n\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ACK|XL_STAT_INTLATCH);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STAT_ENB|0);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ENB|0);\n\n\tif (sc->xl_bustype == XL_BUS_CARDBUS)\n\t\tbus_space_write_4(sc->xl_funct, sc->xl_funch, 4, 0x8000);\n\n\t/* Stop the stats updater. */\n\tuntimeout(xl_stats_update, sc);\n\n\t/*\n\t * Free data in the RX lists.\n\t */\n\tfor (i = 0; i < XL_RX_LIST_CNT; i++) {\n\t\tif (sc->xl_cdata.xl_rx_chain[i].xl_mbuf != NULL) {\n\t\t\tm_freem(sc->xl_cdata.xl_rx_chain[i].xl_mbuf);\n\t\t\tsc->xl_cdata.xl_rx_chain[i].xl_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->xl_ldata->xl_rx_list,\n\t\tsizeof(sc->xl_ldata->xl_rx_list));\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < XL_TX_LIST_CNT; i++) {\n\t\tif (sc->xl_cdata.xl_tx_chain[i].xl_mbuf != NULL) {\n\t\t\tm_freem(sc->xl_cdata.xl_tx_chain[i].xl_mbuf);\n\t\t\tsc->xl_cdata.xl_tx_chain[i].xl_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->xl_ldata->xl_tx_list,\n\t\tsizeof(sc->xl_ldata->xl_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}"
  },
  {
    "function_name": "xl_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
    "lines": "2258-2284",
    "snippet": "void xl_watchdog(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct xl_softc\t\t*sc;\n\tu_int16_t\t\tstatus = 0;\n\n\tsc = ifp->if_softc;\n\n\tifp->if_oerrors++;\n\tXL_SEL_WIN(4);\n\tstatus = CSR_READ_2(sc, XL_W4_MEDIA_STATUS);\n\tprintf(\"xl%d: watchdog timeout\\n\", sc->xl_unit);\n\n\tif (status & XL_MEDIASTAT_CARRIER)\n\t\tprintf(\"xl%d: no carrier - transceiver cable problem?\\n\",\n\t\t\t\t\t\t\t\tsc->xl_unit);\n\txl_txeoc(sc);\n\txl_txeof(sc);\n\txl_rxeof(sc);\n\txl_reset(sc, 0);\n\txl_init(sc);\n\n\tif (ifp->if_snd.ifq_head != NULL)\n\t\t(*ifp->if_start)(ifp);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void xl_rxeof",
      "void xl_txeof",
      "void xl_txeoc",
      "void xl_init",
      "void xl_watchdog",
      "void xl_reset"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "ifp"
          ],
          "line": 2281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xl_init",
          "args": [
            "sc"
          ],
          "line": 2278
        },
        "resolved": true,
        "details": {
          "function_name": "xl_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "1844-2047",
          "snippet": "void xl_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct xl_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts, i;\n\tu_int16_t\t\trxfilt = 0;\n\tstruct mii_data\t\t*mii = NULL;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\txl_stop(sc);\n\n\tif (sc->xl_hasmii)\n\t\tmii = &sc->sc_mii;\n\n\tif (mii == NULL) {\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_RESET);\n\t\txl_wait(sc);\n\t}\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\txl_wait(sc);\n\tDELAY(10000);\n\n\n\t/* Init our MAC address */\n\tXL_SEL_WIN(2);\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++) {\n\t\tCSR_WRITE_1(sc, XL_W2_STATION_ADDR_LO + i,\n\t\t\t\tsc->arpcom.ac_enaddr[i]);\n\t}\n\n\t/* Clear the station mask. */\n\tfor (i = 0; i < 3; i++)\n\t\tCSR_WRITE_2(sc, XL_W2_STATION_MASK_LO + (i * 2), 0);\n#ifdef notdef\n\t/* Reset TX and RX. */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_RESET);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\txl_wait(sc);\n#endif\n\t/* Init circular RX list. */\n\tif (xl_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"xl%d: initialization failed: no \"\n\t\t\t\"memory for rx buffers\\n\", sc->xl_unit);\n\t\txl_stop(sc);\n\t\treturn;\n\t}\n\n\t/* Init TX descriptors. */\n\tif (sc->xl_type == XL_TYPE_905B)\n\t\txl_list_tx_init_90xB(sc);\n\telse\n\t\txl_list_tx_init(sc);\n\n\t/*\n\t * Set the TX freethresh value.\n\t * Note that this has no effect on 3c905B \"cyclone\"\n\t * cards but is required for 3c900/3c905 \"boomerang\"\n\t * cards in order to enable the download engine.\n\t */\n\tCSR_WRITE_1(sc, XL_TX_FREETHRESH, XL_PACKET_SIZE >> 8);\n\n\t/* Set the TX start threshold for best performance. */\n\tsc->xl_tx_thresh = XL_MIN_FRAMELEN;\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_SET_START|sc->xl_tx_thresh);\n\n\t/*\n\t * If this is a 3c905B, also set the tx reclaim threshold.\n\t * This helps cut down on the number of tx reclaim errors\n\t * that could happen on a busy network. The chip multiplies\n\t * the register value by 16 to obtain the actual threshold\n\t * in bytes, so we divide by 16 when setting the value here.\n\t * The existing threshold value can be examined by reading\n\t * the register at offset 9 in window 5.\n\t */\n\tif (sc->xl_type == XL_TYPE_905B) {\n\t\tCSR_WRITE_2(sc, XL_COMMAND,\n\t\t    XL_CMD_SET_TX_RECLAIM|(XL_PACKET_SIZE >> 4));\n\t}\n\n\t/* Set RX filter bits. */\n\tXL_SEL_WIN(5);\n\trxfilt = CSR_READ_1(sc, XL_W5_RX_FILTER);\n\n\t/* Set the individual bit to receive frames for this host only. */\n\trxfilt |= XL_RXFILTER_INDIVIDUAL;\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\trxfilt |= XL_RXFILTER_ALLFRAMES;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t} else {\n\t\trxfilt &= ~XL_RXFILTER_ALLFRAMES;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t}\n\n\t/*\n\t * Set capture broadcast bit to capture broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\trxfilt |= XL_RXFILTER_BROADCAST;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t} else {\n\t\trxfilt &= ~XL_RXFILTER_BROADCAST;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t}\n\n\t/*\n\t * Program the multicast filter, if necessary.\n\t */\n\tif (sc->xl_type == XL_TYPE_905B)\n\t\txl_setmulti_hash(sc);\n\telse\n\t\txl_setmulti(sc);\n\n\t/*\n\t * Load the address of the RX list. We have to\n\t * stall the upload engine before we can manipulate\n\t * the uplist pointer register, then unstall it when\n\t * we're finished. We also have to wait for the\n\t * stall command to complete before proceeding.\n\t * Note that we have to do this after any RX resets\n\t * have completed since the uplist register is cleared\n\t * by a reset.\n\t */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_UP_STALL);\n\txl_wait(sc);\n\tCSR_WRITE_4(sc, XL_UPLIST_PTR, vtophys(&sc->xl_ldata->xl_rx_list[0]));\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_UP_UNSTALL);\n\txl_wait(sc);\n\n\tif (sc->xl_type == XL_TYPE_905B) {\n\t\t/* Set polling interval */\n\t\tCSR_WRITE_1(sc, XL_DOWN_POLL, 64);\n\t\t/* Load the address of the TX list */\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_STALL);\n\t\txl_wait(sc);\n\t\tCSR_WRITE_4(sc, XL_DOWNLIST_PTR,\n\t\t    vtophys(&sc->xl_ldata->xl_tx_list[0]));\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_UNSTALL);\n\t\txl_wait(sc);\n\t}\n\n\t/*\n\t * If the coax transceiver is on, make sure to enable\n\t * the DC-DC converter.\n \t */\n\tXL_SEL_WIN(3);\n\tif (sc->xl_xcvr == XL_XCVR_COAX)\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_START);\n\telse\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_STOP);\n\n\t/* Clear out the stats counters. */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STATS_DISABLE);\n\tsc->xl_stats_no_timeout = 1;\n\txl_stats_update(sc);\n\tsc->xl_stats_no_timeout = 0;\n\tXL_SEL_WIN(4);\n\tCSR_WRITE_2(sc, XL_W4_NET_DIAG, XL_NETDIAG_UPPER_BYTES_ENABLE);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STATS_ENABLE);\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ACK|0xFF);\n\n\tif (sc->xl_bustype == XL_BUS_CARDBUS)\n\t\tbus_space_write_4(sc->xl_funct, sc->xl_funch, 4, 0x8000);\n\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STAT_ENB|XL_INTRS);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ENB|XL_INTRS);\n\n\t/* Set the RX early threshold */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_THRESH|(XL_PACKET_SIZE >>2));\n\tCSR_WRITE_2(sc, XL_DMACTL, XL_DMACTL_UP_RX_EARLY);\n\n\t/* Enable receiver and transmitter. */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_ENABLE);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_ENABLE);\n\txl_wait(sc);\n\n\t/* Restore state of BMCR */\n\tif (mii != NULL)\n\t\tmii_mediachg(mii);\n\n\t/* Select window 7 for normal operations. */\n\tXL_SEL_WIN(7);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\ttimeout(xl_stats_update, sc, hz);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void xl_stats_update",
            "void xl_init",
            "void xl_stop",
            "void xl_setmulti",
            "void xl_setmulti_hash",
            "int xl_list_rx_init",
            "int xl_list_tx_init",
            "int xl_list_tx_init_90xB",
            "void xl_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_stats_update;\nvoid xl_init;\nvoid xl_stop;\nvoid xl_setmulti;\nvoid xl_setmulti_hash;\nint xl_list_rx_init;\nint xl_list_tx_init;\nint xl_list_tx_init_90xB;\nvoid xl_wait;\n\nvoid xl_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct xl_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts, i;\n\tu_int16_t\t\trxfilt = 0;\n\tstruct mii_data\t\t*mii = NULL;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\txl_stop(sc);\n\n\tif (sc->xl_hasmii)\n\t\tmii = &sc->sc_mii;\n\n\tif (mii == NULL) {\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_RESET);\n\t\txl_wait(sc);\n\t}\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\txl_wait(sc);\n\tDELAY(10000);\n\n\n\t/* Init our MAC address */\n\tXL_SEL_WIN(2);\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++) {\n\t\tCSR_WRITE_1(sc, XL_W2_STATION_ADDR_LO + i,\n\t\t\t\tsc->arpcom.ac_enaddr[i]);\n\t}\n\n\t/* Clear the station mask. */\n\tfor (i = 0; i < 3; i++)\n\t\tCSR_WRITE_2(sc, XL_W2_STATION_MASK_LO + (i * 2), 0);\n#ifdef notdef\n\t/* Reset TX and RX. */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_RESET);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\txl_wait(sc);\n#endif\n\t/* Init circular RX list. */\n\tif (xl_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"xl%d: initialization failed: no \"\n\t\t\t\"memory for rx buffers\\n\", sc->xl_unit);\n\t\txl_stop(sc);\n\t\treturn;\n\t}\n\n\t/* Init TX descriptors. */\n\tif (sc->xl_type == XL_TYPE_905B)\n\t\txl_list_tx_init_90xB(sc);\n\telse\n\t\txl_list_tx_init(sc);\n\n\t/*\n\t * Set the TX freethresh value.\n\t * Note that this has no effect on 3c905B \"cyclone\"\n\t * cards but is required for 3c900/3c905 \"boomerang\"\n\t * cards in order to enable the download engine.\n\t */\n\tCSR_WRITE_1(sc, XL_TX_FREETHRESH, XL_PACKET_SIZE >> 8);\n\n\t/* Set the TX start threshold for best performance. */\n\tsc->xl_tx_thresh = XL_MIN_FRAMELEN;\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_SET_START|sc->xl_tx_thresh);\n\n\t/*\n\t * If this is a 3c905B, also set the tx reclaim threshold.\n\t * This helps cut down on the number of tx reclaim errors\n\t * that could happen on a busy network. The chip multiplies\n\t * the register value by 16 to obtain the actual threshold\n\t * in bytes, so we divide by 16 when setting the value here.\n\t * The existing threshold value can be examined by reading\n\t * the register at offset 9 in window 5.\n\t */\n\tif (sc->xl_type == XL_TYPE_905B) {\n\t\tCSR_WRITE_2(sc, XL_COMMAND,\n\t\t    XL_CMD_SET_TX_RECLAIM|(XL_PACKET_SIZE >> 4));\n\t}\n\n\t/* Set RX filter bits. */\n\tXL_SEL_WIN(5);\n\trxfilt = CSR_READ_1(sc, XL_W5_RX_FILTER);\n\n\t/* Set the individual bit to receive frames for this host only. */\n\trxfilt |= XL_RXFILTER_INDIVIDUAL;\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\trxfilt |= XL_RXFILTER_ALLFRAMES;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t} else {\n\t\trxfilt &= ~XL_RXFILTER_ALLFRAMES;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t}\n\n\t/*\n\t * Set capture broadcast bit to capture broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\trxfilt |= XL_RXFILTER_BROADCAST;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t} else {\n\t\trxfilt &= ~XL_RXFILTER_BROADCAST;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t}\n\n\t/*\n\t * Program the multicast filter, if necessary.\n\t */\n\tif (sc->xl_type == XL_TYPE_905B)\n\t\txl_setmulti_hash(sc);\n\telse\n\t\txl_setmulti(sc);\n\n\t/*\n\t * Load the address of the RX list. We have to\n\t * stall the upload engine before we can manipulate\n\t * the uplist pointer register, then unstall it when\n\t * we're finished. We also have to wait for the\n\t * stall command to complete before proceeding.\n\t * Note that we have to do this after any RX resets\n\t * have completed since the uplist register is cleared\n\t * by a reset.\n\t */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_UP_STALL);\n\txl_wait(sc);\n\tCSR_WRITE_4(sc, XL_UPLIST_PTR, vtophys(&sc->xl_ldata->xl_rx_list[0]));\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_UP_UNSTALL);\n\txl_wait(sc);\n\n\tif (sc->xl_type == XL_TYPE_905B) {\n\t\t/* Set polling interval */\n\t\tCSR_WRITE_1(sc, XL_DOWN_POLL, 64);\n\t\t/* Load the address of the TX list */\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_STALL);\n\t\txl_wait(sc);\n\t\tCSR_WRITE_4(sc, XL_DOWNLIST_PTR,\n\t\t    vtophys(&sc->xl_ldata->xl_tx_list[0]));\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_UNSTALL);\n\t\txl_wait(sc);\n\t}\n\n\t/*\n\t * If the coax transceiver is on, make sure to enable\n\t * the DC-DC converter.\n \t */\n\tXL_SEL_WIN(3);\n\tif (sc->xl_xcvr == XL_XCVR_COAX)\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_START);\n\telse\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_STOP);\n\n\t/* Clear out the stats counters. */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STATS_DISABLE);\n\tsc->xl_stats_no_timeout = 1;\n\txl_stats_update(sc);\n\tsc->xl_stats_no_timeout = 0;\n\tXL_SEL_WIN(4);\n\tCSR_WRITE_2(sc, XL_W4_NET_DIAG, XL_NETDIAG_UPPER_BYTES_ENABLE);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STATS_ENABLE);\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ACK|0xFF);\n\n\tif (sc->xl_bustype == XL_BUS_CARDBUS)\n\t\tbus_space_write_4(sc->xl_funct, sc->xl_funch, 4, 0x8000);\n\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STAT_ENB|XL_INTRS);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ENB|XL_INTRS);\n\n\t/* Set the RX early threshold */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_THRESH|(XL_PACKET_SIZE >>2));\n\tCSR_WRITE_2(sc, XL_DMACTL, XL_DMACTL_UP_RX_EARLY);\n\n\t/* Enable receiver and transmitter. */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_ENABLE);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_ENABLE);\n\txl_wait(sc);\n\n\t/* Restore state of BMCR */\n\tif (mii != NULL)\n\t\tmii_mediachg(mii);\n\n\t/* Select window 7 for normal operations. */\n\tXL_SEL_WIN(7);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\ttimeout(xl_stats_update, sc, hz);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xl_reset",
          "args": [
            "sc",
            "0"
          ],
          "line": 2277
        },
        "resolved": true,
        "details": {
          "function_name": "xl_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "831-860",
          "snippet": "void xl_reset(sc, hard)\n\tstruct xl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tXL_SEL_WIN(0);\n\tif (hard)\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RESET);\n\telse\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RESET | 0x0010);\n\txl_wait(sc);\n\n\tfor (i = 0; i < XL_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(CSR_READ_2(sc, XL_STATUS) & XL_STAT_CMDBUSY))\n\t\t\tbreak;\n\t}\n\n\tDELAY(100000);\n\n\t/* Reset TX and RX. */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_RESET);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\txl_wait(sc);\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tDELAY(100000);\n        return;\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void xl_reset",
            "void xl_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_reset;\nvoid xl_wait;\n\nvoid xl_reset(sc, hard)\n\tstruct xl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tXL_SEL_WIN(0);\n\tif (hard)\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RESET);\n\telse\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RESET | 0x0010);\n\txl_wait(sc);\n\n\tfor (i = 0; i < XL_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(CSR_READ_2(sc, XL_STATUS) & XL_STAT_CMDBUSY))\n\t\t\tbreak;\n\t}\n\n\tDELAY(100000);\n\n\t/* Reset TX and RX. */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_RESET);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\txl_wait(sc);\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tDELAY(100000);\n        return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xl_rxeof",
          "args": [
            "sc"
          ],
          "line": 2276
        },
        "resolved": true,
        "details": {
          "function_name": "xl_rxeof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "1159-1262",
          "snippet": "void xl_rxeof(sc)\n\tstruct xl_softc\t\t*sc;\n{\n        struct ether_header\t*eh;\n        struct mbuf\t\t*m;\n        struct ifnet\t\t*ifp;\n\tstruct xl_chain_onefrag\t*cur_rx;\n\tint\t\t\ttotal_len = 0;\n\tu_int16_t\t\trxstat;\n\n\tifp = &sc->arpcom.ac_if;\n\nagain:\n\n\twhile((rxstat = sc->xl_cdata.xl_rx_head->xl_ptr->xl_status)) {\n\t\tcur_rx = sc->xl_cdata.xl_rx_head;\n\t\tsc->xl_cdata.xl_rx_head = cur_rx->xl_next;\n\n\t\t/*\n\t\t * If an error occurs, update stats, clear the\n\t\t * status word and leave the mbuf cluster in place:\n\t\t * it should simply get re-used next time this descriptor\n\t \t * comes up in the ring.\n\t\t */\n\t\tif (rxstat & XL_RXSTAT_UP_ERROR) {\n\t\t\tifp->if_ierrors++;\n\t\t\tcur_rx->xl_ptr->xl_status = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If there error bit was not set, the upload complete\n\t\t * bit should be set which means we have a valid packet.\n\t\t * If not, something truly strange has happened.\n\t\t */\n\t\tif (!(rxstat & XL_RXSTAT_UP_CMPLT)) {\n\t\t\tprintf(\"xl%d: bad receive status -- \"\n\t\t\t    \"packet dropped\", sc->xl_unit);\n\t\t\tifp->if_ierrors++;\n\t\t\tcur_rx->xl_ptr->xl_status = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* No errors; receive the packet. */\t\n\t\tm = cur_rx->xl_mbuf;\n\t\ttotal_len = cur_rx->xl_ptr->xl_status & XL_RXSTAT_LENMASK;\n\n\t\t/*\n\t\t * Try to conjure up a new mbuf cluster. If that\n\t\t * fails, it means we have an out of memory condition and\n\t\t * should leave the buffer in place and continue. This will\n\t\t * result in a lost packet, but there's little else we\n\t\t * can do in this situation.\n\t\t */\n\t\tif (xl_newbuf(sc, cur_rx) == ENOBUFS) {\n\t\t\tifp->if_ierrors++;\n\t\t\tcur_rx->xl_ptr->xl_status = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tifp->if_ipackets++;\n\t\teh = mtod(m, struct ether_header *);\n\t\tm->m_pkthdr.rcvif = ifp;\n#if NBPFILTER > 0\n\t\t/*\n\t\t * Handle BPF listeners. Let the BPF user see the packet.\n\t\t */\n\t\tif (ifp->if_bpf) {\n\t\t\tm->m_pkthdr.len = m->m_len = total_len;\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n\t\t}\n#endif\n\t\t/* Remove header from mbuf and pass it on. */\n\t\tm->m_pkthdr.len = m->m_len =\n\t\t\t\ttotal_len - sizeof(struct ether_header);\n\t\tm->m_data += sizeof(struct ether_header);\n\t\tether_input(ifp, eh, m);\n\t}\n\n\t/*\n\t * Handle the 'end of channel' condition. When the upload\n\t * engine hits the end of the RX ring, it will stall. This\n\t * is our cue to flush the RX ring, reload the uplist pointer\n\t * register and unstall the engine.\n\t * XXX This is actually a little goofy. With the ThunderLAN\n\t * chip, you get an interrupt when the receiver hits the end\n\t * of the receive ring, which tells you exactly when you\n\t * you need to reload the ring pointer. Here we have to\n\t * fake it. I'm mad at myself for not being clever enough\n\t * to avoid the use of a goto here.\n\t */\n\tif (CSR_READ_4(sc, XL_UPLIST_PTR) == 0 ||\n\t\tCSR_READ_4(sc, XL_UPLIST_STATUS) & XL_PKTSTAT_UP_STALLED) {\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_UP_STALL);\n\t\txl_wait(sc);\n\t\tCSR_WRITE_4(sc, XL_UPLIST_PTR,\n\t\t\tvtophys(&sc->xl_ldata->xl_rx_list[0]));\n\t\tsc->xl_cdata.xl_rx_head = &sc->xl_cdata.xl_rx_chain[0];\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_UP_UNSTALL);\n\t\tgoto again;\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xl_newbuf",
            "void xl_rxeof",
            "void xl_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint xl_newbuf;\nvoid xl_rxeof;\nvoid xl_wait;\n\nvoid xl_rxeof(sc)\n\tstruct xl_softc\t\t*sc;\n{\n        struct ether_header\t*eh;\n        struct mbuf\t\t*m;\n        struct ifnet\t\t*ifp;\n\tstruct xl_chain_onefrag\t*cur_rx;\n\tint\t\t\ttotal_len = 0;\n\tu_int16_t\t\trxstat;\n\n\tifp = &sc->arpcom.ac_if;\n\nagain:\n\n\twhile((rxstat = sc->xl_cdata.xl_rx_head->xl_ptr->xl_status)) {\n\t\tcur_rx = sc->xl_cdata.xl_rx_head;\n\t\tsc->xl_cdata.xl_rx_head = cur_rx->xl_next;\n\n\t\t/*\n\t\t * If an error occurs, update stats, clear the\n\t\t * status word and leave the mbuf cluster in place:\n\t\t * it should simply get re-used next time this descriptor\n\t \t * comes up in the ring.\n\t\t */\n\t\tif (rxstat & XL_RXSTAT_UP_ERROR) {\n\t\t\tifp->if_ierrors++;\n\t\t\tcur_rx->xl_ptr->xl_status = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If there error bit was not set, the upload complete\n\t\t * bit should be set which means we have a valid packet.\n\t\t * If not, something truly strange has happened.\n\t\t */\n\t\tif (!(rxstat & XL_RXSTAT_UP_CMPLT)) {\n\t\t\tprintf(\"xl%d: bad receive status -- \"\n\t\t\t    \"packet dropped\", sc->xl_unit);\n\t\t\tifp->if_ierrors++;\n\t\t\tcur_rx->xl_ptr->xl_status = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* No errors; receive the packet. */\t\n\t\tm = cur_rx->xl_mbuf;\n\t\ttotal_len = cur_rx->xl_ptr->xl_status & XL_RXSTAT_LENMASK;\n\n\t\t/*\n\t\t * Try to conjure up a new mbuf cluster. If that\n\t\t * fails, it means we have an out of memory condition and\n\t\t * should leave the buffer in place and continue. This will\n\t\t * result in a lost packet, but there's little else we\n\t\t * can do in this situation.\n\t\t */\n\t\tif (xl_newbuf(sc, cur_rx) == ENOBUFS) {\n\t\t\tifp->if_ierrors++;\n\t\t\tcur_rx->xl_ptr->xl_status = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tifp->if_ipackets++;\n\t\teh = mtod(m, struct ether_header *);\n\t\tm->m_pkthdr.rcvif = ifp;\n#if NBPFILTER > 0\n\t\t/*\n\t\t * Handle BPF listeners. Let the BPF user see the packet.\n\t\t */\n\t\tif (ifp->if_bpf) {\n\t\t\tm->m_pkthdr.len = m->m_len = total_len;\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n\t\t}\n#endif\n\t\t/* Remove header from mbuf and pass it on. */\n\t\tm->m_pkthdr.len = m->m_len =\n\t\t\t\ttotal_len - sizeof(struct ether_header);\n\t\tm->m_data += sizeof(struct ether_header);\n\t\tether_input(ifp, eh, m);\n\t}\n\n\t/*\n\t * Handle the 'end of channel' condition. When the upload\n\t * engine hits the end of the RX ring, it will stall. This\n\t * is our cue to flush the RX ring, reload the uplist pointer\n\t * register and unstall the engine.\n\t * XXX This is actually a little goofy. With the ThunderLAN\n\t * chip, you get an interrupt when the receiver hits the end\n\t * of the receive ring, which tells you exactly when you\n\t * you need to reload the ring pointer. Here we have to\n\t * fake it. I'm mad at myself for not being clever enough\n\t * to avoid the use of a goto here.\n\t */\n\tif (CSR_READ_4(sc, XL_UPLIST_PTR) == 0 ||\n\t\tCSR_READ_4(sc, XL_UPLIST_STATUS) & XL_PKTSTAT_UP_STALLED) {\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_UP_STALL);\n\t\txl_wait(sc);\n\t\tCSR_WRITE_4(sc, XL_UPLIST_PTR,\n\t\t\tvtophys(&sc->xl_ldata->xl_rx_list[0]));\n\t\tsc->xl_cdata.xl_rx_head = &sc->xl_cdata.xl_rx_chain[0];\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_UP_UNSTALL);\n\t\tgoto again;\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xl_txeof",
          "args": [
            "sc"
          ],
          "line": 2275
        },
        "resolved": true,
        "details": {
          "function_name": "xl_txeof_90xB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "1318-1352",
          "snippet": "void\nxl_txeof_90xB(sc)\n\tstruct xl_softc *sc;\n{\n\tstruct xl_chain *cur_tx = NULL;\n\tstruct ifnet *ifp;\n\tint idx;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tidx = sc->xl_cdata.xl_tx_cons;\n\twhile(idx != sc->xl_cdata.xl_tx_prod) {\n\n\t\tcur_tx = &sc->xl_cdata.xl_tx_chain[idx];\n\n\t\tif (!(cur_tx->xl_ptr->xl_status & XL_TXSTAT_DL_COMPLETE))\n\t\t\tbreak;\n\n\t\tif (cur_tx->xl_mbuf != NULL) {\n\t\t\tm_freem(cur_tx->xl_mbuf);\n\t\t\tcur_tx->xl_mbuf = NULL;\n\t\t}\n\n\t\tifp->if_opackets++;\n\n\t\tsc->xl_cdata.xl_tx_cnt--;\n\t\tXL_INC(idx, XL_TX_LIST_CNT);\n\t\tifp->if_timer = 0;\n\t}\n\n\tsc->xl_cdata.xl_tx_cons = idx;\n\n\tif (cur_tx != NULL)\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void xl_txeof_90xB"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_txeof_90xB;\n\nvoid\nxl_txeof_90xB(sc)\n\tstruct xl_softc *sc;\n{\n\tstruct xl_chain *cur_tx = NULL;\n\tstruct ifnet *ifp;\n\tint idx;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tidx = sc->xl_cdata.xl_tx_cons;\n\twhile(idx != sc->xl_cdata.xl_tx_prod) {\n\n\t\tcur_tx = &sc->xl_cdata.xl_tx_chain[idx];\n\n\t\tif (!(cur_tx->xl_ptr->xl_status & XL_TXSTAT_DL_COMPLETE))\n\t\t\tbreak;\n\n\t\tif (cur_tx->xl_mbuf != NULL) {\n\t\t\tm_freem(cur_tx->xl_mbuf);\n\t\t\tcur_tx->xl_mbuf = NULL;\n\t\t}\n\n\t\tifp->if_opackets++;\n\n\t\tsc->xl_cdata.xl_tx_cnt--;\n\t\tXL_INC(idx, XL_TX_LIST_CNT);\n\t\tifp->if_timer = 0;\n\t}\n\n\tsc->xl_cdata.xl_tx_cons = idx;\n\n\tif (cur_tx != NULL)\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xl_txeoc",
          "args": [
            "sc"
          ],
          "line": 2274
        },
        "resolved": true,
        "details": {
          "function_name": "xl_txeoc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "1359-1416",
          "snippet": "void xl_txeoc(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tu_int8_t\t\ttxstat;\n\n\twhile((txstat = CSR_READ_1(sc, XL_TX_STATUS))) {\n\t\tif (txstat & XL_TXSTATUS_UNDERRUN ||\n\t\t\ttxstat & XL_TXSTATUS_JABBER ||\n\t\t\ttxstat & XL_TXSTATUS_RECLAIM) {\n\t\t\tprintf(\"xl%d: transmission error: %x\\n\",\n\t\t\t\t\t\tsc->xl_unit, txstat);\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\t\t\txl_wait(sc);\n\t\t\tif (sc->xl_type == XL_TYPE_905B) {\n\t\t\t\tint i;\n\t\t\t\tstruct xl_chain *c;\n\t\t\t\ti = sc->xl_cdata.xl_tx_cons;\n\t\t\t\tc = &sc->xl_cdata.xl_tx_chain[i];\n\t\t\t\tCSR_WRITE_4(sc, XL_DOWNLIST_PTR, c->xl_phys);\n\t\t\t\tCSR_WRITE_1(sc, XL_DOWN_POLL, 64);\n\t\t\t} else {\n\t\t\t\tif (sc->xl_cdata.xl_tx_head != NULL)\n\t\t\t\t\tCSR_WRITE_4(sc, XL_DOWNLIST_PTR,\n\t\t\t\t\t    vtophys(sc->xl_cdata.xl_tx_head->xl_ptr));\n\t\t\t}\n\t\t\t/*\n\t\t\t * Remember to set this for the\n\t\t\t * first generation 3c90X chips.\n\t\t\t */\n\t\t\tCSR_WRITE_1(sc, XL_TX_FREETHRESH, XL_PACKET_SIZE >> 8);\n\t\t\tif (txstat & XL_TXSTATUS_UNDERRUN &&\n\t\t\t    sc->xl_tx_thresh < XL_PACKET_SIZE) {\n\t\t\t\tsc->xl_tx_thresh += XL_MIN_FRAMELEN;\n\t\t\t\tprintf(\"xl%d: tx underrun, increasing tx start\"\n\t\t\t\t    \" threshold to %d\\n\", sc->xl_unit,\n\t\t\t\t    sc->xl_tx_thresh);\n\t\t\t}\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND,\n\t\t\t    XL_CMD_TX_SET_START|sc->xl_tx_thresh);\n\t\t\tif (sc->xl_type == XL_TYPE_905B) {\n\t\t\t\tCSR_WRITE_2(sc, XL_COMMAND,\n\t\t\t\tXL_CMD_SET_TX_RECLAIM|(XL_PACKET_SIZE >> 4));\n\t\t\t}\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_ENABLE);\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_UNSTALL);\n\t\t} else {\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_ENABLE);\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_UNSTALL);\n\t\t}\n\t\t/*\n\t\t * Write an arbitrary byte to the TX_STATUS register\n\t \t * to clear this interrupt/error and advance to the next.\n\t\t */\n\t\tCSR_WRITE_1(sc, XL_TX_STATUS, 0x01);\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void xl_txeoc",
            "void xl_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_txeoc;\nvoid xl_wait;\n\nvoid xl_txeoc(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tu_int8_t\t\ttxstat;\n\n\twhile((txstat = CSR_READ_1(sc, XL_TX_STATUS))) {\n\t\tif (txstat & XL_TXSTATUS_UNDERRUN ||\n\t\t\ttxstat & XL_TXSTATUS_JABBER ||\n\t\t\ttxstat & XL_TXSTATUS_RECLAIM) {\n\t\t\tprintf(\"xl%d: transmission error: %x\\n\",\n\t\t\t\t\t\tsc->xl_unit, txstat);\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\t\t\txl_wait(sc);\n\t\t\tif (sc->xl_type == XL_TYPE_905B) {\n\t\t\t\tint i;\n\t\t\t\tstruct xl_chain *c;\n\t\t\t\ti = sc->xl_cdata.xl_tx_cons;\n\t\t\t\tc = &sc->xl_cdata.xl_tx_chain[i];\n\t\t\t\tCSR_WRITE_4(sc, XL_DOWNLIST_PTR, c->xl_phys);\n\t\t\t\tCSR_WRITE_1(sc, XL_DOWN_POLL, 64);\n\t\t\t} else {\n\t\t\t\tif (sc->xl_cdata.xl_tx_head != NULL)\n\t\t\t\t\tCSR_WRITE_4(sc, XL_DOWNLIST_PTR,\n\t\t\t\t\t    vtophys(sc->xl_cdata.xl_tx_head->xl_ptr));\n\t\t\t}\n\t\t\t/*\n\t\t\t * Remember to set this for the\n\t\t\t * first generation 3c90X chips.\n\t\t\t */\n\t\t\tCSR_WRITE_1(sc, XL_TX_FREETHRESH, XL_PACKET_SIZE >> 8);\n\t\t\tif (txstat & XL_TXSTATUS_UNDERRUN &&\n\t\t\t    sc->xl_tx_thresh < XL_PACKET_SIZE) {\n\t\t\t\tsc->xl_tx_thresh += XL_MIN_FRAMELEN;\n\t\t\t\tprintf(\"xl%d: tx underrun, increasing tx start\"\n\t\t\t\t    \" threshold to %d\\n\", sc->xl_unit,\n\t\t\t\t    sc->xl_tx_thresh);\n\t\t\t}\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND,\n\t\t\t    XL_CMD_TX_SET_START|sc->xl_tx_thresh);\n\t\t\tif (sc->xl_type == XL_TYPE_905B) {\n\t\t\t\tCSR_WRITE_2(sc, XL_COMMAND,\n\t\t\t\tXL_CMD_SET_TX_RECLAIM|(XL_PACKET_SIZE >> 4));\n\t\t\t}\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_ENABLE);\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_UNSTALL);\n\t\t} else {\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_ENABLE);\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_UNSTALL);\n\t\t}\n\t\t/*\n\t\t * Write an arbitrary byte to the TX_STATUS register\n\t \t * to clear this interrupt/error and advance to the next.\n\t\t */\n\t\tCSR_WRITE_1(sc, XL_TX_STATUS, 0x01);\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"xl%d: no carrier - transceiver cable problem?\\n\"",
            "sc->xl_unit"
          ],
          "line": 2272
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "XL_W4_MEDIA_STATUS"
          ],
          "line": 2268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XL_SEL_WIN",
          "args": [
            "4"
          ],
          "line": 2267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_rxeof;\nvoid xl_txeof;\nvoid xl_txeoc;\nvoid xl_init;\nvoid xl_watchdog;\nvoid xl_reset;\n\nvoid xl_watchdog(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct xl_softc\t\t*sc;\n\tu_int16_t\t\tstatus = 0;\n\n\tsc = ifp->if_softc;\n\n\tifp->if_oerrors++;\n\tXL_SEL_WIN(4);\n\tstatus = CSR_READ_2(sc, XL_W4_MEDIA_STATUS);\n\tprintf(\"xl%d: watchdog timeout\\n\", sc->xl_unit);\n\n\tif (status & XL_MEDIASTAT_CARRIER)\n\t\tprintf(\"xl%d: no carrier - transceiver cable problem?\\n\",\n\t\t\t\t\t\t\t\tsc->xl_unit);\n\txl_txeoc(sc);\n\txl_txeof(sc);\n\txl_rxeof(sc);\n\txl_reset(sc, 0);\n\txl_init(sc);\n\n\tif (ifp->if_snd.ifq_head != NULL)\n\t\t(*ifp->if_start)(ifp);\n\n\treturn;\n}"
  },
  {
    "function_name": "xl_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
    "lines": "2157-2256",
    "snippet": "int\nxl_ioctl(ifp, command, data)\n\tstruct ifnet *ifp;\n\tu_long command;\n\tcaddr_t data;\n{\n\tstruct xl_softc *sc = ifp->if_softc;\n\tstruct ifreq *ifr = (struct ifreq *)data;\n\tstruct ifaddr *ifa = (struct ifaddr *)data;\n\tint s, error = 0;\n\tstruct mii_data *mii = NULL;\n\tu_int8_t rxfilt;\n\n\ts = splimp();\n\n\tif ((error = ether_ioctl(ifp, &sc->arpcom, command, data)) > 0) {\n\t\tsplx(s);\n\t\treturn error;\n\t}\n\n\tswitch(command) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\txl_init(sc);\n\t\t\tarp_ifinit(&sc->arpcom, ifa);\n\t\t\tbreak;\n#endif /* INET */\n\t\tdefault:\n\t\t\txl_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SIOCSIFFLAGS:\n\t\tXL_SEL_WIN(5);\n\t\trxfilt = CSR_READ_1(sc, XL_W5_RX_FILTER);\n\t\tif (ifp->if_flags & IFF_UP) {\n\t\t\tif (ifp->if_flags & IFF_RUNNING &&\n\t\t\t    ifp->if_flags & IFF_PROMISC &&\n\t\t\t    !(sc->xl_if_flags & IFF_PROMISC)) {\n\t\t\t\trxfilt |= XL_RXFILTER_ALLFRAMES;\n\t\t\t\tCSR_WRITE_2(sc, XL_COMMAND,\n\t\t\t\t    XL_CMD_RX_SET_FILT|rxfilt);\n\t\t\t\tXL_SEL_WIN(7);\n\t\t\t} else if (ifp->if_flags & IFF_RUNNING &&\n\t\t\t    !(ifp->if_flags & IFF_PROMISC) &&\n\t\t\t    sc->xl_if_flags & IFF_PROMISC) {\n\t\t\t\trxfilt &= ~XL_RXFILTER_ALLFRAMES;\n\t\t\t\tCSR_WRITE_2(sc, XL_COMMAND,\n\t\t\t\t    XL_CMD_RX_SET_FILT|rxfilt);\n\t\t\t\tXL_SEL_WIN(7);\n\t\t\t} else\n\t\t\t\txl_init(sc);\n\t\t} else {\n\t\t\tif (ifp->if_flags & IFF_RUNNING)\n\t\t\t\txl_stop(sc);\n\t\t}\n\t\tsc->xl_if_flags = ifp->if_flags;\n\t\terror = 0;\n\t\tbreak;\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\terror = (command == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->arpcom) :\n\t\t    ether_delmulti(ifr, &sc->arpcom);\n\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware\n\t\t\t * filter accordingly.\n\t\t\t */\n\t\t\tif (sc->xl_type == XL_TYPE_905B)\n\t\t\t\txl_setmulti_hash(sc);\n\t\t\telse\n\t\t\t\txl_setmulti(sc);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\tcase SIOCGIFMEDIA:\n\tcase SIOCSIFMEDIA:\n\t\tif (sc->xl_hasmii != 0)\n\t\t\tmii = &sc->sc_mii;\n\t\tif (mii == NULL)\n\t\t\terror = ifmedia_ioctl(ifp, ifr,\n\t\t\t    &sc->ifmedia, command);\n\t\telse\n\t\t\terror = ifmedia_ioctl(ifp, ifr,\n\t\t\t    &mii->mii_media, command);\n\t\tbreak;\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\t(void)splx(s);\n\n\treturn(error);\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int xl_ioctl",
      "void xl_init",
      "void xl_stop",
      "void xl_setmulti",
      "void xl_setmulti_hash"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_ioctl",
          "args": [
            "ifp",
            "ifr",
            "&mii->mii_media",
            "command"
          ],
          "line": 2245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_ioctl",
          "args": [
            "ifp",
            "ifr",
            "&sc->ifmedia",
            "command"
          ],
          "line": 2242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xl_setmulti",
          "args": [
            "sc"
          ],
          "line": 2233
        },
        "resolved": true,
        "details": {
          "function_name": "xl_setmulti_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "639-688",
          "snippet": "void xl_setmulti_hash(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\th = 0, i;\n\tstruct arpcom *ac = &sc->arpcom;\n\tstruct ether_multi *enm;\n\tstruct ether_multistep step;\n\tu_int8_t\t\trxfilt;\n\tint\t\t\tmcnt = 0;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tXL_SEL_WIN(5);\n\trxfilt = CSR_READ_1(sc, XL_W5_RX_FILTER);\n\n\tif (ifp->if_flags & IFF_ALLMULTI) {\nallmulti:\n\t\trxfilt |= XL_RXFILTER_ALLMULTI;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t\treturn;\n\t} else\n\t\trxfilt &= ~XL_RXFILTER_ALLMULTI;\n\n\n\t/* first, zot all the existing hash bits */\n\tfor (i = 0; i < XL_HASHFILT_SIZE; i++)\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_HASH|i);\n\n\t/* now program new ones */\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {\n\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\tgoto allmulti;\n\t\t}\n\t\th = xl_calchash(enm->enm_addrlo);\n\t\tmcnt++;\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\n\tif (mcnt)\n\t\trxfilt |= XL_RXFILTER_MULTIHASH;\n\telse\n\t\trxfilt &= ~XL_RXFILTER_MULTIHASH;\n\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int8_t xl_calchash",
            "void xl_setmulti_hash"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int8_t xl_calchash;\nvoid xl_setmulti_hash;\n\nvoid xl_setmulti_hash(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\th = 0, i;\n\tstruct arpcom *ac = &sc->arpcom;\n\tstruct ether_multi *enm;\n\tstruct ether_multistep step;\n\tu_int8_t\t\trxfilt;\n\tint\t\t\tmcnt = 0;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tXL_SEL_WIN(5);\n\trxfilt = CSR_READ_1(sc, XL_W5_RX_FILTER);\n\n\tif (ifp->if_flags & IFF_ALLMULTI) {\nallmulti:\n\t\trxfilt |= XL_RXFILTER_ALLMULTI;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t\treturn;\n\t} else\n\t\trxfilt &= ~XL_RXFILTER_ALLMULTI;\n\n\n\t/* first, zot all the existing hash bits */\n\tfor (i = 0; i < XL_HASHFILT_SIZE; i++)\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_HASH|i);\n\n\t/* now program new ones */\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {\n\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\tgoto allmulti;\n\t\t}\n\t\th = xl_calchash(enm->enm_addrlo);\n\t\tmcnt++;\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\n\tif (mcnt)\n\t\trxfilt |= XL_RXFILTER_MULTIHASH;\n\telse\n\t\trxfilt &= ~XL_RXFILTER_MULTIHASH;\n\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_delmulti",
          "args": [
            "ifr",
            "&sc->arpcom"
          ],
          "line": 2223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_addmulti",
          "args": [
            "ifr",
            "&sc->arpcom"
          ],
          "line": 2222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xl_stop",
          "args": [
            "sc"
          ],
          "line": 2214
        },
        "resolved": true,
        "details": {
          "function_name": "xl_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "2290-2351",
          "snippet": "void xl_stop(sc)\n\tstruct xl_softc *sc;\n{\n\tint i;\n\tstruct ifnet *ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_timer = 0;\n\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_DISABLE);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STATS_DISABLE);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ENB);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_DISCARD);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_DISABLE);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_STOP);\n\tDELAY(800);\n\n#ifdef foo\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_RESET);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\txl_wait(sc);\n#endif\n\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ACK|XL_STAT_INTLATCH);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STAT_ENB|0);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ENB|0);\n\n\tif (sc->xl_bustype == XL_BUS_CARDBUS)\n\t\tbus_space_write_4(sc->xl_funct, sc->xl_funch, 4, 0x8000);\n\n\t/* Stop the stats updater. */\n\tuntimeout(xl_stats_update, sc);\n\n\t/*\n\t * Free data in the RX lists.\n\t */\n\tfor (i = 0; i < XL_RX_LIST_CNT; i++) {\n\t\tif (sc->xl_cdata.xl_rx_chain[i].xl_mbuf != NULL) {\n\t\t\tm_freem(sc->xl_cdata.xl_rx_chain[i].xl_mbuf);\n\t\t\tsc->xl_cdata.xl_rx_chain[i].xl_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->xl_ldata->xl_rx_list,\n\t\tsizeof(sc->xl_ldata->xl_rx_list));\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < XL_TX_LIST_CNT; i++) {\n\t\tif (sc->xl_cdata.xl_tx_chain[i].xl_mbuf != NULL) {\n\t\t\tm_freem(sc->xl_cdata.xl_tx_chain[i].xl_mbuf);\n\t\t\tsc->xl_cdata.xl_tx_chain[i].xl_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->xl_ldata->xl_tx_list,\n\t\tsizeof(sc->xl_ldata->xl_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void xl_stats_update",
            "void xl_stop",
            "void xl_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_stats_update;\nvoid xl_stop;\nvoid xl_wait;\n\nvoid xl_stop(sc)\n\tstruct xl_softc *sc;\n{\n\tint i;\n\tstruct ifnet *ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_timer = 0;\n\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_DISABLE);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STATS_DISABLE);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ENB);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_DISCARD);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_DISABLE);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_STOP);\n\tDELAY(800);\n\n#ifdef foo\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_RESET);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\txl_wait(sc);\n#endif\n\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ACK|XL_STAT_INTLATCH);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STAT_ENB|0);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ENB|0);\n\n\tif (sc->xl_bustype == XL_BUS_CARDBUS)\n\t\tbus_space_write_4(sc->xl_funct, sc->xl_funch, 4, 0x8000);\n\n\t/* Stop the stats updater. */\n\tuntimeout(xl_stats_update, sc);\n\n\t/*\n\t * Free data in the RX lists.\n\t */\n\tfor (i = 0; i < XL_RX_LIST_CNT; i++) {\n\t\tif (sc->xl_cdata.xl_rx_chain[i].xl_mbuf != NULL) {\n\t\t\tm_freem(sc->xl_cdata.xl_rx_chain[i].xl_mbuf);\n\t\t\tsc->xl_cdata.xl_rx_chain[i].xl_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->xl_ldata->xl_rx_list,\n\t\tsizeof(sc->xl_ldata->xl_rx_list));\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < XL_TX_LIST_CNT; i++) {\n\t\tif (sc->xl_cdata.xl_tx_chain[i].xl_mbuf != NULL) {\n\t\t\tm_freem(sc->xl_cdata.xl_tx_chain[i].xl_mbuf);\n\t\t\tsc->xl_cdata.xl_tx_chain[i].xl_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->xl_ldata->xl_tx_list,\n\t\tsizeof(sc->xl_ldata->xl_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xl_init",
          "args": [
            "sc"
          ],
          "line": 2211
        },
        "resolved": true,
        "details": {
          "function_name": "xl_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "1844-2047",
          "snippet": "void xl_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct xl_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts, i;\n\tu_int16_t\t\trxfilt = 0;\n\tstruct mii_data\t\t*mii = NULL;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\txl_stop(sc);\n\n\tif (sc->xl_hasmii)\n\t\tmii = &sc->sc_mii;\n\n\tif (mii == NULL) {\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_RESET);\n\t\txl_wait(sc);\n\t}\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\txl_wait(sc);\n\tDELAY(10000);\n\n\n\t/* Init our MAC address */\n\tXL_SEL_WIN(2);\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++) {\n\t\tCSR_WRITE_1(sc, XL_W2_STATION_ADDR_LO + i,\n\t\t\t\tsc->arpcom.ac_enaddr[i]);\n\t}\n\n\t/* Clear the station mask. */\n\tfor (i = 0; i < 3; i++)\n\t\tCSR_WRITE_2(sc, XL_W2_STATION_MASK_LO + (i * 2), 0);\n#ifdef notdef\n\t/* Reset TX and RX. */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_RESET);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\txl_wait(sc);\n#endif\n\t/* Init circular RX list. */\n\tif (xl_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"xl%d: initialization failed: no \"\n\t\t\t\"memory for rx buffers\\n\", sc->xl_unit);\n\t\txl_stop(sc);\n\t\treturn;\n\t}\n\n\t/* Init TX descriptors. */\n\tif (sc->xl_type == XL_TYPE_905B)\n\t\txl_list_tx_init_90xB(sc);\n\telse\n\t\txl_list_tx_init(sc);\n\n\t/*\n\t * Set the TX freethresh value.\n\t * Note that this has no effect on 3c905B \"cyclone\"\n\t * cards but is required for 3c900/3c905 \"boomerang\"\n\t * cards in order to enable the download engine.\n\t */\n\tCSR_WRITE_1(sc, XL_TX_FREETHRESH, XL_PACKET_SIZE >> 8);\n\n\t/* Set the TX start threshold for best performance. */\n\tsc->xl_tx_thresh = XL_MIN_FRAMELEN;\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_SET_START|sc->xl_tx_thresh);\n\n\t/*\n\t * If this is a 3c905B, also set the tx reclaim threshold.\n\t * This helps cut down on the number of tx reclaim errors\n\t * that could happen on a busy network. The chip multiplies\n\t * the register value by 16 to obtain the actual threshold\n\t * in bytes, so we divide by 16 when setting the value here.\n\t * The existing threshold value can be examined by reading\n\t * the register at offset 9 in window 5.\n\t */\n\tif (sc->xl_type == XL_TYPE_905B) {\n\t\tCSR_WRITE_2(sc, XL_COMMAND,\n\t\t    XL_CMD_SET_TX_RECLAIM|(XL_PACKET_SIZE >> 4));\n\t}\n\n\t/* Set RX filter bits. */\n\tXL_SEL_WIN(5);\n\trxfilt = CSR_READ_1(sc, XL_W5_RX_FILTER);\n\n\t/* Set the individual bit to receive frames for this host only. */\n\trxfilt |= XL_RXFILTER_INDIVIDUAL;\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\trxfilt |= XL_RXFILTER_ALLFRAMES;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t} else {\n\t\trxfilt &= ~XL_RXFILTER_ALLFRAMES;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t}\n\n\t/*\n\t * Set capture broadcast bit to capture broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\trxfilt |= XL_RXFILTER_BROADCAST;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t} else {\n\t\trxfilt &= ~XL_RXFILTER_BROADCAST;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t}\n\n\t/*\n\t * Program the multicast filter, if necessary.\n\t */\n\tif (sc->xl_type == XL_TYPE_905B)\n\t\txl_setmulti_hash(sc);\n\telse\n\t\txl_setmulti(sc);\n\n\t/*\n\t * Load the address of the RX list. We have to\n\t * stall the upload engine before we can manipulate\n\t * the uplist pointer register, then unstall it when\n\t * we're finished. We also have to wait for the\n\t * stall command to complete before proceeding.\n\t * Note that we have to do this after any RX resets\n\t * have completed since the uplist register is cleared\n\t * by a reset.\n\t */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_UP_STALL);\n\txl_wait(sc);\n\tCSR_WRITE_4(sc, XL_UPLIST_PTR, vtophys(&sc->xl_ldata->xl_rx_list[0]));\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_UP_UNSTALL);\n\txl_wait(sc);\n\n\tif (sc->xl_type == XL_TYPE_905B) {\n\t\t/* Set polling interval */\n\t\tCSR_WRITE_1(sc, XL_DOWN_POLL, 64);\n\t\t/* Load the address of the TX list */\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_STALL);\n\t\txl_wait(sc);\n\t\tCSR_WRITE_4(sc, XL_DOWNLIST_PTR,\n\t\t    vtophys(&sc->xl_ldata->xl_tx_list[0]));\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_UNSTALL);\n\t\txl_wait(sc);\n\t}\n\n\t/*\n\t * If the coax transceiver is on, make sure to enable\n\t * the DC-DC converter.\n \t */\n\tXL_SEL_WIN(3);\n\tif (sc->xl_xcvr == XL_XCVR_COAX)\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_START);\n\telse\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_STOP);\n\n\t/* Clear out the stats counters. */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STATS_DISABLE);\n\tsc->xl_stats_no_timeout = 1;\n\txl_stats_update(sc);\n\tsc->xl_stats_no_timeout = 0;\n\tXL_SEL_WIN(4);\n\tCSR_WRITE_2(sc, XL_W4_NET_DIAG, XL_NETDIAG_UPPER_BYTES_ENABLE);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STATS_ENABLE);\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ACK|0xFF);\n\n\tif (sc->xl_bustype == XL_BUS_CARDBUS)\n\t\tbus_space_write_4(sc->xl_funct, sc->xl_funch, 4, 0x8000);\n\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STAT_ENB|XL_INTRS);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ENB|XL_INTRS);\n\n\t/* Set the RX early threshold */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_THRESH|(XL_PACKET_SIZE >>2));\n\tCSR_WRITE_2(sc, XL_DMACTL, XL_DMACTL_UP_RX_EARLY);\n\n\t/* Enable receiver and transmitter. */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_ENABLE);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_ENABLE);\n\txl_wait(sc);\n\n\t/* Restore state of BMCR */\n\tif (mii != NULL)\n\t\tmii_mediachg(mii);\n\n\t/* Select window 7 for normal operations. */\n\tXL_SEL_WIN(7);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\ttimeout(xl_stats_update, sc, hz);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void xl_stats_update",
            "void xl_init",
            "void xl_stop",
            "void xl_setmulti",
            "void xl_setmulti_hash",
            "int xl_list_rx_init",
            "int xl_list_tx_init",
            "int xl_list_tx_init_90xB",
            "void xl_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_stats_update;\nvoid xl_init;\nvoid xl_stop;\nvoid xl_setmulti;\nvoid xl_setmulti_hash;\nint xl_list_rx_init;\nint xl_list_tx_init;\nint xl_list_tx_init_90xB;\nvoid xl_wait;\n\nvoid xl_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct xl_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts, i;\n\tu_int16_t\t\trxfilt = 0;\n\tstruct mii_data\t\t*mii = NULL;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\txl_stop(sc);\n\n\tif (sc->xl_hasmii)\n\t\tmii = &sc->sc_mii;\n\n\tif (mii == NULL) {\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_RESET);\n\t\txl_wait(sc);\n\t}\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\txl_wait(sc);\n\tDELAY(10000);\n\n\n\t/* Init our MAC address */\n\tXL_SEL_WIN(2);\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++) {\n\t\tCSR_WRITE_1(sc, XL_W2_STATION_ADDR_LO + i,\n\t\t\t\tsc->arpcom.ac_enaddr[i]);\n\t}\n\n\t/* Clear the station mask. */\n\tfor (i = 0; i < 3; i++)\n\t\tCSR_WRITE_2(sc, XL_W2_STATION_MASK_LO + (i * 2), 0);\n#ifdef notdef\n\t/* Reset TX and RX. */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_RESET);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\txl_wait(sc);\n#endif\n\t/* Init circular RX list. */\n\tif (xl_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"xl%d: initialization failed: no \"\n\t\t\t\"memory for rx buffers\\n\", sc->xl_unit);\n\t\txl_stop(sc);\n\t\treturn;\n\t}\n\n\t/* Init TX descriptors. */\n\tif (sc->xl_type == XL_TYPE_905B)\n\t\txl_list_tx_init_90xB(sc);\n\telse\n\t\txl_list_tx_init(sc);\n\n\t/*\n\t * Set the TX freethresh value.\n\t * Note that this has no effect on 3c905B \"cyclone\"\n\t * cards but is required for 3c900/3c905 \"boomerang\"\n\t * cards in order to enable the download engine.\n\t */\n\tCSR_WRITE_1(sc, XL_TX_FREETHRESH, XL_PACKET_SIZE >> 8);\n\n\t/* Set the TX start threshold for best performance. */\n\tsc->xl_tx_thresh = XL_MIN_FRAMELEN;\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_SET_START|sc->xl_tx_thresh);\n\n\t/*\n\t * If this is a 3c905B, also set the tx reclaim threshold.\n\t * This helps cut down on the number of tx reclaim errors\n\t * that could happen on a busy network. The chip multiplies\n\t * the register value by 16 to obtain the actual threshold\n\t * in bytes, so we divide by 16 when setting the value here.\n\t * The existing threshold value can be examined by reading\n\t * the register at offset 9 in window 5.\n\t */\n\tif (sc->xl_type == XL_TYPE_905B) {\n\t\tCSR_WRITE_2(sc, XL_COMMAND,\n\t\t    XL_CMD_SET_TX_RECLAIM|(XL_PACKET_SIZE >> 4));\n\t}\n\n\t/* Set RX filter bits. */\n\tXL_SEL_WIN(5);\n\trxfilt = CSR_READ_1(sc, XL_W5_RX_FILTER);\n\n\t/* Set the individual bit to receive frames for this host only. */\n\trxfilt |= XL_RXFILTER_INDIVIDUAL;\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\trxfilt |= XL_RXFILTER_ALLFRAMES;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t} else {\n\t\trxfilt &= ~XL_RXFILTER_ALLFRAMES;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t}\n\n\t/*\n\t * Set capture broadcast bit to capture broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\trxfilt |= XL_RXFILTER_BROADCAST;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t} else {\n\t\trxfilt &= ~XL_RXFILTER_BROADCAST;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t}\n\n\t/*\n\t * Program the multicast filter, if necessary.\n\t */\n\tif (sc->xl_type == XL_TYPE_905B)\n\t\txl_setmulti_hash(sc);\n\telse\n\t\txl_setmulti(sc);\n\n\t/*\n\t * Load the address of the RX list. We have to\n\t * stall the upload engine before we can manipulate\n\t * the uplist pointer register, then unstall it when\n\t * we're finished. We also have to wait for the\n\t * stall command to complete before proceeding.\n\t * Note that we have to do this after any RX resets\n\t * have completed since the uplist register is cleared\n\t * by a reset.\n\t */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_UP_STALL);\n\txl_wait(sc);\n\tCSR_WRITE_4(sc, XL_UPLIST_PTR, vtophys(&sc->xl_ldata->xl_rx_list[0]));\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_UP_UNSTALL);\n\txl_wait(sc);\n\n\tif (sc->xl_type == XL_TYPE_905B) {\n\t\t/* Set polling interval */\n\t\tCSR_WRITE_1(sc, XL_DOWN_POLL, 64);\n\t\t/* Load the address of the TX list */\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_STALL);\n\t\txl_wait(sc);\n\t\tCSR_WRITE_4(sc, XL_DOWNLIST_PTR,\n\t\t    vtophys(&sc->xl_ldata->xl_tx_list[0]));\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_UNSTALL);\n\t\txl_wait(sc);\n\t}\n\n\t/*\n\t * If the coax transceiver is on, make sure to enable\n\t * the DC-DC converter.\n \t */\n\tXL_SEL_WIN(3);\n\tif (sc->xl_xcvr == XL_XCVR_COAX)\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_START);\n\telse\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_STOP);\n\n\t/* Clear out the stats counters. */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STATS_DISABLE);\n\tsc->xl_stats_no_timeout = 1;\n\txl_stats_update(sc);\n\tsc->xl_stats_no_timeout = 0;\n\tXL_SEL_WIN(4);\n\tCSR_WRITE_2(sc, XL_W4_NET_DIAG, XL_NETDIAG_UPPER_BYTES_ENABLE);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STATS_ENABLE);\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ACK|0xFF);\n\n\tif (sc->xl_bustype == XL_BUS_CARDBUS)\n\t\tbus_space_write_4(sc->xl_funct, sc->xl_funch, 4, 0x8000);\n\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STAT_ENB|XL_INTRS);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ENB|XL_INTRS);\n\n\t/* Set the RX early threshold */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_THRESH|(XL_PACKET_SIZE >>2));\n\tCSR_WRITE_2(sc, XL_DMACTL, XL_DMACTL_UP_RX_EARLY);\n\n\t/* Enable receiver and transmitter. */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_ENABLE);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_ENABLE);\n\txl_wait(sc);\n\n\t/* Restore state of BMCR */\n\tif (mii != NULL)\n\t\tmii_mediachg(mii);\n\n\t/* Select window 7 for normal operations. */\n\tXL_SEL_WIN(7);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\ttimeout(xl_stats_update, sc, hz);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XL_SEL_WIN",
          "args": [
            "7"
          ],
          "line": 2209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_RX_SET_FILT|rxfilt"
          ],
          "line": 2207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XL_SEL_WIN",
          "args": [
            "7"
          ],
          "line": 2202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_RX_SET_FILT|rxfilt"
          ],
          "line": 2200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_1",
          "args": [
            "sc",
            "XL_W5_RX_FILTER"
          ],
          "line": 2194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XL_SEL_WIN",
          "args": [
            "5"
          ],
          "line": 2193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arp_ifinit",
          "args": [
            "&sc->arpcom",
            "ifa"
          ],
          "line": 2184
        },
        "resolved": true,
        "details": {
          "function_name": "arp_ifinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_devar.h",
          "lines": "929-936",
          "snippet": "static void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}",
          "includes": [
            "#include <sys/devconf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/devconf.h>\n\nstatic void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ioctl",
          "args": [
            "ifp",
            "&sc->arpcom",
            "command",
            "data"
          ],
          "line": 2172
        },
        "resolved": true,
        "details": {
          "function_name": "fxp_ether_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
          "lines": "301-348",
          "snippet": "int\nfxp_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tstruct fxp_softc *sc = ifp->if_softc;\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tfxp_init(sc);\n\t\t\tarp_ifinit(&sc->arpcom, ifa);\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t    {\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t /* Set new address. */\n\t\t\t fxp_init(sc);\n\t\t\t break;\n\t\t    }\n#endif\n\t\tdefault:\n\t\t\tfxp_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/ic/fxpvar.h>",
            "#include <dev/ic/fxpreg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void fxp_init",
            "int\tfxp_ether_ioctl"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid fxp_init;\nint\tfxp_ether_ioctl;\n\nint\nfxp_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tstruct fxp_softc *sc = ifp->if_softc;\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tfxp_init(sc);\n\t\t\tarp_ifinit(&sc->arpcom, ifa);\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t    {\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t /* Set new address. */\n\t\t\t fxp_init(sc);\n\t\t\t break;\n\t\t    }\n#endif\n\t\tdefault:\n\t\t\tfxp_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 2170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint xl_ioctl;\nvoid xl_init;\nvoid xl_stop;\nvoid xl_setmulti;\nvoid xl_setmulti_hash;\n\nint\nxl_ioctl(ifp, command, data)\n\tstruct ifnet *ifp;\n\tu_long command;\n\tcaddr_t data;\n{\n\tstruct xl_softc *sc = ifp->if_softc;\n\tstruct ifreq *ifr = (struct ifreq *)data;\n\tstruct ifaddr *ifa = (struct ifaddr *)data;\n\tint s, error = 0;\n\tstruct mii_data *mii = NULL;\n\tu_int8_t rxfilt;\n\n\ts = splimp();\n\n\tif ((error = ether_ioctl(ifp, &sc->arpcom, command, data)) > 0) {\n\t\tsplx(s);\n\t\treturn error;\n\t}\n\n\tswitch(command) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\txl_init(sc);\n\t\t\tarp_ifinit(&sc->arpcom, ifa);\n\t\t\tbreak;\n#endif /* INET */\n\t\tdefault:\n\t\t\txl_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SIOCSIFFLAGS:\n\t\tXL_SEL_WIN(5);\n\t\trxfilt = CSR_READ_1(sc, XL_W5_RX_FILTER);\n\t\tif (ifp->if_flags & IFF_UP) {\n\t\t\tif (ifp->if_flags & IFF_RUNNING &&\n\t\t\t    ifp->if_flags & IFF_PROMISC &&\n\t\t\t    !(sc->xl_if_flags & IFF_PROMISC)) {\n\t\t\t\trxfilt |= XL_RXFILTER_ALLFRAMES;\n\t\t\t\tCSR_WRITE_2(sc, XL_COMMAND,\n\t\t\t\t    XL_CMD_RX_SET_FILT|rxfilt);\n\t\t\t\tXL_SEL_WIN(7);\n\t\t\t} else if (ifp->if_flags & IFF_RUNNING &&\n\t\t\t    !(ifp->if_flags & IFF_PROMISC) &&\n\t\t\t    sc->xl_if_flags & IFF_PROMISC) {\n\t\t\t\trxfilt &= ~XL_RXFILTER_ALLFRAMES;\n\t\t\t\tCSR_WRITE_2(sc, XL_COMMAND,\n\t\t\t\t    XL_CMD_RX_SET_FILT|rxfilt);\n\t\t\t\tXL_SEL_WIN(7);\n\t\t\t} else\n\t\t\t\txl_init(sc);\n\t\t} else {\n\t\t\tif (ifp->if_flags & IFF_RUNNING)\n\t\t\t\txl_stop(sc);\n\t\t}\n\t\tsc->xl_if_flags = ifp->if_flags;\n\t\terror = 0;\n\t\tbreak;\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\terror = (command == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->arpcom) :\n\t\t    ether_delmulti(ifr, &sc->arpcom);\n\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware\n\t\t\t * filter accordingly.\n\t\t\t */\n\t\t\tif (sc->xl_type == XL_TYPE_905B)\n\t\t\t\txl_setmulti_hash(sc);\n\t\t\telse\n\t\t\t\txl_setmulti(sc);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\tcase SIOCGIFMEDIA:\n\tcase SIOCSIFMEDIA:\n\t\tif (sc->xl_hasmii != 0)\n\t\t\tmii = &sc->sc_mii;\n\t\tif (mii == NULL)\n\t\t\terror = ifmedia_ioctl(ifp, ifr,\n\t\t\t    &sc->ifmedia, command);\n\t\telse\n\t\t\terror = ifmedia_ioctl(ifp, ifr,\n\t\t\t    &mii->mii_media, command);\n\t\tbreak;\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\t(void)splx(s);\n\n\treturn(error);\n}"
  },
  {
    "function_name": "xl_ifmedia_sts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
    "lines": "2093-2155",
    "snippet": "void xl_ifmedia_sts(ifp, ifmr)\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmediareq\t*ifmr;\n{\n\tstruct xl_softc\t\t*sc;\n\tu_int32_t\t\ticfg;\n\tstruct mii_data\t\t*mii = NULL;\n\n\tsc = ifp->if_softc;\n\tif (sc->xl_hasmii != 0)\n\t\tmii = &sc->sc_mii;\n\n\tXL_SEL_WIN(3);\n\ticfg = CSR_READ_4(sc, XL_W3_INTERNAL_CFG) & XL_ICFG_CONNECTOR_MASK;\n\ticfg >>= XL_ICFG_CONNECTOR_BITS;\n\n\tifmr->ifm_active = IFM_ETHER;\n\n\tswitch(icfg) {\n\tcase XL_XCVR_10BT:\n\t\tifmr->ifm_active = IFM_ETHER|IFM_10_T;\n\t\tif (CSR_READ_1(sc, XL_W3_MAC_CTRL) & XL_MACCTRL_DUPLEX)\n\t\t\tifmr->ifm_active |= IFM_FDX;\n\t\telse\n\t\t\tifmr->ifm_active |= IFM_HDX;\n\t\tbreak;\n\tcase XL_XCVR_AUI:\n\t\tif (sc->xl_type == XL_TYPE_905B &&\n\t\t    sc->xl_media == XL_MEDIAOPT_10FL) {\n\t\t\tifmr->ifm_active = IFM_ETHER|IFM_10_FL;\n\t\t\tif (CSR_READ_1(sc, XL_W3_MAC_CTRL) & XL_MACCTRL_DUPLEX)\n\t\t\t\tifmr->ifm_active |= IFM_FDX;\n\t\t\telse\n\t\t\t\tifmr->ifm_active |= IFM_FDX;\n\t\t} else\n\t\t\tifmr->ifm_active = IFM_ETHER|IFM_10_5;\n\t\tbreak;\n\tcase XL_XCVR_COAX:\n\t\tifmr->ifm_active = IFM_ETHER|IFM_10_2;\n\t\tbreak;\n\t/*\n\t * XXX MII and BTX/AUTO should be separate cases.\n\t */\n\n\tcase XL_XCVR_100BTX:\n\tcase XL_XCVR_AUTO:\n\tcase XL_XCVR_MII:\n\t\tif (mii != NULL) {\n\t\t\tmii_pollstat(mii);\n\t\t\tifmr->ifm_active = mii->mii_media_active;\n\t\t\tifmr->ifm_status = mii->mii_media_status;\n\t\t}\n\t\tbreak;\n\tcase XL_XCVR_100BFX:\n\t\tifmr->ifm_active = IFM_ETHER|IFM_100_FX;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"xl%d: unknown XCVR type: %d\\n\", sc->xl_unit, icfg);\n\t\tbreak;\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void xl_ifmedia_sts"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"xl%d: unknown XCVR type: %d\\n\"",
            "sc->xl_unit",
            "icfg"
          ],
          "line": 2150
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mii_pollstat",
          "args": [
            "mii"
          ],
          "line": 2141
        },
        "resolved": true,
        "details": {
          "function_name": "mii_pollstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/mii.c",
          "lines": "206-218",
          "snippet": "void\nmii_pollstat(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\n\tmii->mii_media_status = 0;\n\tmii->mii_media_active = IFM_NONE;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list))\n\t\t(void) (*child->mii_service)(child, mii, MII_POLLSTAT);\n}",
          "includes": [
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nvoid\nmii_pollstat(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\n\tmii->mii_media_status = 0;\n\tmii->mii_media_active = IFM_NONE;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list))\n\t\t(void) (*child->mii_service)(child, mii, MII_POLLSTAT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_READ_1",
          "args": [
            "sc",
            "XL_W3_MAC_CTRL"
          ],
          "line": 2123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_1",
          "args": [
            "sc",
            "XL_W3_MAC_CTRL"
          ],
          "line": 2114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "XL_W3_INTERNAL_CFG"
          ],
          "line": 2106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XL_SEL_WIN",
          "args": [
            "3"
          ],
          "line": 2105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_ifmedia_sts;\n\nvoid xl_ifmedia_sts(ifp, ifmr)\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmediareq\t*ifmr;\n{\n\tstruct xl_softc\t\t*sc;\n\tu_int32_t\t\ticfg;\n\tstruct mii_data\t\t*mii = NULL;\n\n\tsc = ifp->if_softc;\n\tif (sc->xl_hasmii != 0)\n\t\tmii = &sc->sc_mii;\n\n\tXL_SEL_WIN(3);\n\ticfg = CSR_READ_4(sc, XL_W3_INTERNAL_CFG) & XL_ICFG_CONNECTOR_MASK;\n\ticfg >>= XL_ICFG_CONNECTOR_BITS;\n\n\tifmr->ifm_active = IFM_ETHER;\n\n\tswitch(icfg) {\n\tcase XL_XCVR_10BT:\n\t\tifmr->ifm_active = IFM_ETHER|IFM_10_T;\n\t\tif (CSR_READ_1(sc, XL_W3_MAC_CTRL) & XL_MACCTRL_DUPLEX)\n\t\t\tifmr->ifm_active |= IFM_FDX;\n\t\telse\n\t\t\tifmr->ifm_active |= IFM_HDX;\n\t\tbreak;\n\tcase XL_XCVR_AUI:\n\t\tif (sc->xl_type == XL_TYPE_905B &&\n\t\t    sc->xl_media == XL_MEDIAOPT_10FL) {\n\t\t\tifmr->ifm_active = IFM_ETHER|IFM_10_FL;\n\t\t\tif (CSR_READ_1(sc, XL_W3_MAC_CTRL) & XL_MACCTRL_DUPLEX)\n\t\t\t\tifmr->ifm_active |= IFM_FDX;\n\t\t\telse\n\t\t\t\tifmr->ifm_active |= IFM_FDX;\n\t\t} else\n\t\t\tifmr->ifm_active = IFM_ETHER|IFM_10_5;\n\t\tbreak;\n\tcase XL_XCVR_COAX:\n\t\tifmr->ifm_active = IFM_ETHER|IFM_10_2;\n\t\tbreak;\n\t/*\n\t * XXX MII and BTX/AUTO should be separate cases.\n\t */\n\n\tcase XL_XCVR_100BTX:\n\tcase XL_XCVR_AUTO:\n\tcase XL_XCVR_MII:\n\t\tif (mii != NULL) {\n\t\t\tmii_pollstat(mii);\n\t\t\tifmr->ifm_active = mii->mii_media_active;\n\t\t\tifmr->ifm_status = mii->mii_media_status;\n\t\t}\n\t\tbreak;\n\tcase XL_XCVR_100BFX:\n\t\tifmr->ifm_active = IFM_ETHER|IFM_100_FX;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"xl%d: unknown XCVR type: %d\\n\", sc->xl_unit, icfg);\n\t\tbreak;\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "xl_ifmedia_upd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
    "lines": "2052-2088",
    "snippet": "int xl_ifmedia_upd(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct xl_softc\t\t*sc;\n\tstruct ifmedia\t\t*ifm = NULL;\n\tstruct mii_data\t\t*mii = NULL;\n\n\tsc = ifp->if_softc;\n\n\tif (sc->xl_hasmii)\n\t\tmii = &sc->sc_mii;\n\tif (mii == NULL)\n\t\tifm = &sc->ifmedia;\n\telse\n\t\tifm = &mii->mii_media;\n\n\tswitch(IFM_SUBTYPE(ifm->ifm_media)) {\n\tcase IFM_100_FX:\n\tcase IFM_10_FL:\n\tcase IFM_10_2:\n\tcase IFM_10_5:\n\t\txl_setmode(sc, ifm->ifm_media);\n\t\treturn (0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (sc->xl_media & XL_MEDIAOPT_MII || sc->xl_media & XL_MEDIAOPT_BTX\n\t\t|| sc->xl_media & XL_MEDIAOPT_BT4) {\n\t\txl_init(sc);\n\t} else {\n\t\txl_setmode(sc, ifm->ifm_media);\n\t}\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void xl_init",
      "int xl_ifmedia_upd",
      "void xl_setmode"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xl_setmode",
          "args": [
            "sc",
            "ifm->ifm_media"
          ],
          "line": 2084
        },
        "resolved": true,
        "details": {
          "function_name": "xl_setmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "738-829",
          "snippet": "void xl_setmode(sc, media)\n\tstruct xl_softc *sc;\n\tint media;\n{\n\tu_int32_t icfg;\n\tu_int16_t mediastat;\n\n\tprintf(\"xl%d: selecting \", sc->xl_unit);\n\n\tXL_SEL_WIN(4);\n\tmediastat = CSR_READ_2(sc, XL_W4_MEDIA_STATUS);\n\tXL_SEL_WIN(3);\n\ticfg = CSR_READ_4(sc, XL_W3_INTERNAL_CFG);\n\n\tif (sc->xl_media & XL_MEDIAOPT_BT) {\n\t\tif (IFM_SUBTYPE(media) == IFM_10_T) {\n\t\t\tprintf(\"10baseT transceiver, \");\n\t\t\tsc->xl_xcvr = XL_XCVR_10BT;\n\t\t\ticfg &= ~XL_ICFG_CONNECTOR_MASK;\n\t\t\ticfg |= (XL_XCVR_10BT << XL_ICFG_CONNECTOR_BITS);\n\t\t\tmediastat |= XL_MEDIASTAT_LINKBEAT|\n\t\t\t\t\tXL_MEDIASTAT_JABGUARD;\n\t\t\tmediastat &= ~XL_MEDIASTAT_SQEENB;\n\t\t}\n\t}\n\n\tif (sc->xl_media & XL_MEDIAOPT_BFX) {\n\t\tif (IFM_SUBTYPE(media) == IFM_100_FX) {\n\t\t\tprintf(\"100baseFX port, \");\n\t\t\tsc->xl_xcvr = XL_XCVR_100BFX;\n\t\t\ticfg &= ~XL_ICFG_CONNECTOR_MASK;\n\t\t\ticfg |= (XL_XCVR_100BFX << XL_ICFG_CONNECTOR_BITS);\n\t\t\tmediastat |= XL_MEDIASTAT_LINKBEAT;\n\t\t\tmediastat &= ~XL_MEDIASTAT_SQEENB;\n\t\t}\n\t}\n\n\tif (sc->xl_media & (XL_MEDIAOPT_AUI|XL_MEDIAOPT_10FL)) {\n\t\tif (IFM_SUBTYPE(media) == IFM_10_5) {\n\t\t\tprintf(\"AUI port, \");\n\t\t\tsc->xl_xcvr = XL_XCVR_AUI;\n\t\t\ticfg &= ~XL_ICFG_CONNECTOR_MASK;\n\t\t\ticfg |= (XL_XCVR_AUI << XL_ICFG_CONNECTOR_BITS);\n\t\t\tmediastat &= ~(XL_MEDIASTAT_LINKBEAT|\n\t\t\t\t\tXL_MEDIASTAT_JABGUARD);\n\t\t\tmediastat |= ~XL_MEDIASTAT_SQEENB;\n\t\t}\n\t\tif (IFM_SUBTYPE(media) == IFM_10_FL) {\n\t\t\tprintf(\"10baseFL transceiver, \");\n\t\t\tsc->xl_xcvr = XL_XCVR_AUI;\n\t\t\ticfg &= ~XL_ICFG_CONNECTOR_MASK;\n\t\t\ticfg |= (XL_XCVR_AUI << XL_ICFG_CONNECTOR_BITS);\n\t\t\tmediastat &= ~(XL_MEDIASTAT_LINKBEAT|\n\t\t\t\t\tXL_MEDIASTAT_JABGUARD);\n\t\t\tmediastat |= ~XL_MEDIASTAT_SQEENB;\n\t\t}\n\t}\n\n\tif (sc->xl_media & XL_MEDIAOPT_BNC) {\n\t\tif (IFM_SUBTYPE(media) == IFM_10_2) {\n\t\t\tprintf(\"BNC port, \");\n\t\t\tsc->xl_xcvr = XL_XCVR_COAX;\n\t\t\ticfg &= ~XL_ICFG_CONNECTOR_MASK;\n\t\t\ticfg |= (XL_XCVR_COAX << XL_ICFG_CONNECTOR_BITS);\n\t\t\tmediastat &= ~(XL_MEDIASTAT_LINKBEAT|\n\t\t\t\t\tXL_MEDIASTAT_JABGUARD|\n\t\t\t\t\tXL_MEDIASTAT_SQEENB);\n\t\t}\n\t}\n\n\tif ((media & IFM_GMASK) == IFM_FDX ||\n\t\t\tIFM_SUBTYPE(media) == IFM_100_FX) {\n\t\tprintf(\"full duplex\\n\");\n\t\tXL_SEL_WIN(3);\n\t\tCSR_WRITE_1(sc, XL_W3_MAC_CTRL, XL_MACCTRL_DUPLEX);\n\t} else {\n\t\tprintf(\"half duplex\\n\");\n\t\tXL_SEL_WIN(3);\n\t\tCSR_WRITE_1(sc, XL_W3_MAC_CTRL,\n\t\t\t(CSR_READ_1(sc, XL_W3_MAC_CTRL) & ~XL_MACCTRL_DUPLEX));\n\t}\n\n\tif (IFM_SUBTYPE(media) == IFM_10_2)\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_START);\n\telse\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_STOP);\n\tCSR_WRITE_4(sc, XL_W3_INTERNAL_CFG, icfg);\n\tXL_SEL_WIN(4);\n\tCSR_WRITE_2(sc, XL_W4_MEDIA_STATUS, mediastat);\n\tDELAY(800);\n\tXL_SEL_WIN(7);\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void xl_setmode"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_setmode;\n\nvoid xl_setmode(sc, media)\n\tstruct xl_softc *sc;\n\tint media;\n{\n\tu_int32_t icfg;\n\tu_int16_t mediastat;\n\n\tprintf(\"xl%d: selecting \", sc->xl_unit);\n\n\tXL_SEL_WIN(4);\n\tmediastat = CSR_READ_2(sc, XL_W4_MEDIA_STATUS);\n\tXL_SEL_WIN(3);\n\ticfg = CSR_READ_4(sc, XL_W3_INTERNAL_CFG);\n\n\tif (sc->xl_media & XL_MEDIAOPT_BT) {\n\t\tif (IFM_SUBTYPE(media) == IFM_10_T) {\n\t\t\tprintf(\"10baseT transceiver, \");\n\t\t\tsc->xl_xcvr = XL_XCVR_10BT;\n\t\t\ticfg &= ~XL_ICFG_CONNECTOR_MASK;\n\t\t\ticfg |= (XL_XCVR_10BT << XL_ICFG_CONNECTOR_BITS);\n\t\t\tmediastat |= XL_MEDIASTAT_LINKBEAT|\n\t\t\t\t\tXL_MEDIASTAT_JABGUARD;\n\t\t\tmediastat &= ~XL_MEDIASTAT_SQEENB;\n\t\t}\n\t}\n\n\tif (sc->xl_media & XL_MEDIAOPT_BFX) {\n\t\tif (IFM_SUBTYPE(media) == IFM_100_FX) {\n\t\t\tprintf(\"100baseFX port, \");\n\t\t\tsc->xl_xcvr = XL_XCVR_100BFX;\n\t\t\ticfg &= ~XL_ICFG_CONNECTOR_MASK;\n\t\t\ticfg |= (XL_XCVR_100BFX << XL_ICFG_CONNECTOR_BITS);\n\t\t\tmediastat |= XL_MEDIASTAT_LINKBEAT;\n\t\t\tmediastat &= ~XL_MEDIASTAT_SQEENB;\n\t\t}\n\t}\n\n\tif (sc->xl_media & (XL_MEDIAOPT_AUI|XL_MEDIAOPT_10FL)) {\n\t\tif (IFM_SUBTYPE(media) == IFM_10_5) {\n\t\t\tprintf(\"AUI port, \");\n\t\t\tsc->xl_xcvr = XL_XCVR_AUI;\n\t\t\ticfg &= ~XL_ICFG_CONNECTOR_MASK;\n\t\t\ticfg |= (XL_XCVR_AUI << XL_ICFG_CONNECTOR_BITS);\n\t\t\tmediastat &= ~(XL_MEDIASTAT_LINKBEAT|\n\t\t\t\t\tXL_MEDIASTAT_JABGUARD);\n\t\t\tmediastat |= ~XL_MEDIASTAT_SQEENB;\n\t\t}\n\t\tif (IFM_SUBTYPE(media) == IFM_10_FL) {\n\t\t\tprintf(\"10baseFL transceiver, \");\n\t\t\tsc->xl_xcvr = XL_XCVR_AUI;\n\t\t\ticfg &= ~XL_ICFG_CONNECTOR_MASK;\n\t\t\ticfg |= (XL_XCVR_AUI << XL_ICFG_CONNECTOR_BITS);\n\t\t\tmediastat &= ~(XL_MEDIASTAT_LINKBEAT|\n\t\t\t\t\tXL_MEDIASTAT_JABGUARD);\n\t\t\tmediastat |= ~XL_MEDIASTAT_SQEENB;\n\t\t}\n\t}\n\n\tif (sc->xl_media & XL_MEDIAOPT_BNC) {\n\t\tif (IFM_SUBTYPE(media) == IFM_10_2) {\n\t\t\tprintf(\"BNC port, \");\n\t\t\tsc->xl_xcvr = XL_XCVR_COAX;\n\t\t\ticfg &= ~XL_ICFG_CONNECTOR_MASK;\n\t\t\ticfg |= (XL_XCVR_COAX << XL_ICFG_CONNECTOR_BITS);\n\t\t\tmediastat &= ~(XL_MEDIASTAT_LINKBEAT|\n\t\t\t\t\tXL_MEDIASTAT_JABGUARD|\n\t\t\t\t\tXL_MEDIASTAT_SQEENB);\n\t\t}\n\t}\n\n\tif ((media & IFM_GMASK) == IFM_FDX ||\n\t\t\tIFM_SUBTYPE(media) == IFM_100_FX) {\n\t\tprintf(\"full duplex\\n\");\n\t\tXL_SEL_WIN(3);\n\t\tCSR_WRITE_1(sc, XL_W3_MAC_CTRL, XL_MACCTRL_DUPLEX);\n\t} else {\n\t\tprintf(\"half duplex\\n\");\n\t\tXL_SEL_WIN(3);\n\t\tCSR_WRITE_1(sc, XL_W3_MAC_CTRL,\n\t\t\t(CSR_READ_1(sc, XL_W3_MAC_CTRL) & ~XL_MACCTRL_DUPLEX));\n\t}\n\n\tif (IFM_SUBTYPE(media) == IFM_10_2)\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_START);\n\telse\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_STOP);\n\tCSR_WRITE_4(sc, XL_W3_INTERNAL_CFG, icfg);\n\tXL_SEL_WIN(4);\n\tCSR_WRITE_2(sc, XL_W4_MEDIA_STATUS, mediastat);\n\tDELAY(800);\n\tXL_SEL_WIN(7);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xl_init",
          "args": [
            "sc"
          ],
          "line": 2082
        },
        "resolved": true,
        "details": {
          "function_name": "xl_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "1844-2047",
          "snippet": "void xl_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct xl_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts, i;\n\tu_int16_t\t\trxfilt = 0;\n\tstruct mii_data\t\t*mii = NULL;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\txl_stop(sc);\n\n\tif (sc->xl_hasmii)\n\t\tmii = &sc->sc_mii;\n\n\tif (mii == NULL) {\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_RESET);\n\t\txl_wait(sc);\n\t}\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\txl_wait(sc);\n\tDELAY(10000);\n\n\n\t/* Init our MAC address */\n\tXL_SEL_WIN(2);\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++) {\n\t\tCSR_WRITE_1(sc, XL_W2_STATION_ADDR_LO + i,\n\t\t\t\tsc->arpcom.ac_enaddr[i]);\n\t}\n\n\t/* Clear the station mask. */\n\tfor (i = 0; i < 3; i++)\n\t\tCSR_WRITE_2(sc, XL_W2_STATION_MASK_LO + (i * 2), 0);\n#ifdef notdef\n\t/* Reset TX and RX. */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_RESET);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\txl_wait(sc);\n#endif\n\t/* Init circular RX list. */\n\tif (xl_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"xl%d: initialization failed: no \"\n\t\t\t\"memory for rx buffers\\n\", sc->xl_unit);\n\t\txl_stop(sc);\n\t\treturn;\n\t}\n\n\t/* Init TX descriptors. */\n\tif (sc->xl_type == XL_TYPE_905B)\n\t\txl_list_tx_init_90xB(sc);\n\telse\n\t\txl_list_tx_init(sc);\n\n\t/*\n\t * Set the TX freethresh value.\n\t * Note that this has no effect on 3c905B \"cyclone\"\n\t * cards but is required for 3c900/3c905 \"boomerang\"\n\t * cards in order to enable the download engine.\n\t */\n\tCSR_WRITE_1(sc, XL_TX_FREETHRESH, XL_PACKET_SIZE >> 8);\n\n\t/* Set the TX start threshold for best performance. */\n\tsc->xl_tx_thresh = XL_MIN_FRAMELEN;\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_SET_START|sc->xl_tx_thresh);\n\n\t/*\n\t * If this is a 3c905B, also set the tx reclaim threshold.\n\t * This helps cut down on the number of tx reclaim errors\n\t * that could happen on a busy network. The chip multiplies\n\t * the register value by 16 to obtain the actual threshold\n\t * in bytes, so we divide by 16 when setting the value here.\n\t * The existing threshold value can be examined by reading\n\t * the register at offset 9 in window 5.\n\t */\n\tif (sc->xl_type == XL_TYPE_905B) {\n\t\tCSR_WRITE_2(sc, XL_COMMAND,\n\t\t    XL_CMD_SET_TX_RECLAIM|(XL_PACKET_SIZE >> 4));\n\t}\n\n\t/* Set RX filter bits. */\n\tXL_SEL_WIN(5);\n\trxfilt = CSR_READ_1(sc, XL_W5_RX_FILTER);\n\n\t/* Set the individual bit to receive frames for this host only. */\n\trxfilt |= XL_RXFILTER_INDIVIDUAL;\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\trxfilt |= XL_RXFILTER_ALLFRAMES;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t} else {\n\t\trxfilt &= ~XL_RXFILTER_ALLFRAMES;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t}\n\n\t/*\n\t * Set capture broadcast bit to capture broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\trxfilt |= XL_RXFILTER_BROADCAST;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t} else {\n\t\trxfilt &= ~XL_RXFILTER_BROADCAST;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t}\n\n\t/*\n\t * Program the multicast filter, if necessary.\n\t */\n\tif (sc->xl_type == XL_TYPE_905B)\n\t\txl_setmulti_hash(sc);\n\telse\n\t\txl_setmulti(sc);\n\n\t/*\n\t * Load the address of the RX list. We have to\n\t * stall the upload engine before we can manipulate\n\t * the uplist pointer register, then unstall it when\n\t * we're finished. We also have to wait for the\n\t * stall command to complete before proceeding.\n\t * Note that we have to do this after any RX resets\n\t * have completed since the uplist register is cleared\n\t * by a reset.\n\t */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_UP_STALL);\n\txl_wait(sc);\n\tCSR_WRITE_4(sc, XL_UPLIST_PTR, vtophys(&sc->xl_ldata->xl_rx_list[0]));\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_UP_UNSTALL);\n\txl_wait(sc);\n\n\tif (sc->xl_type == XL_TYPE_905B) {\n\t\t/* Set polling interval */\n\t\tCSR_WRITE_1(sc, XL_DOWN_POLL, 64);\n\t\t/* Load the address of the TX list */\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_STALL);\n\t\txl_wait(sc);\n\t\tCSR_WRITE_4(sc, XL_DOWNLIST_PTR,\n\t\t    vtophys(&sc->xl_ldata->xl_tx_list[0]));\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_UNSTALL);\n\t\txl_wait(sc);\n\t}\n\n\t/*\n\t * If the coax transceiver is on, make sure to enable\n\t * the DC-DC converter.\n \t */\n\tXL_SEL_WIN(3);\n\tif (sc->xl_xcvr == XL_XCVR_COAX)\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_START);\n\telse\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_STOP);\n\n\t/* Clear out the stats counters. */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STATS_DISABLE);\n\tsc->xl_stats_no_timeout = 1;\n\txl_stats_update(sc);\n\tsc->xl_stats_no_timeout = 0;\n\tXL_SEL_WIN(4);\n\tCSR_WRITE_2(sc, XL_W4_NET_DIAG, XL_NETDIAG_UPPER_BYTES_ENABLE);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STATS_ENABLE);\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ACK|0xFF);\n\n\tif (sc->xl_bustype == XL_BUS_CARDBUS)\n\t\tbus_space_write_4(sc->xl_funct, sc->xl_funch, 4, 0x8000);\n\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STAT_ENB|XL_INTRS);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ENB|XL_INTRS);\n\n\t/* Set the RX early threshold */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_THRESH|(XL_PACKET_SIZE >>2));\n\tCSR_WRITE_2(sc, XL_DMACTL, XL_DMACTL_UP_RX_EARLY);\n\n\t/* Enable receiver and transmitter. */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_ENABLE);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_ENABLE);\n\txl_wait(sc);\n\n\t/* Restore state of BMCR */\n\tif (mii != NULL)\n\t\tmii_mediachg(mii);\n\n\t/* Select window 7 for normal operations. */\n\tXL_SEL_WIN(7);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\ttimeout(xl_stats_update, sc, hz);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void xl_stats_update",
            "void xl_init",
            "void xl_stop",
            "void xl_setmulti",
            "void xl_setmulti_hash",
            "int xl_list_rx_init",
            "int xl_list_tx_init",
            "int xl_list_tx_init_90xB",
            "void xl_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_stats_update;\nvoid xl_init;\nvoid xl_stop;\nvoid xl_setmulti;\nvoid xl_setmulti_hash;\nint xl_list_rx_init;\nint xl_list_tx_init;\nint xl_list_tx_init_90xB;\nvoid xl_wait;\n\nvoid xl_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct xl_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts, i;\n\tu_int16_t\t\trxfilt = 0;\n\tstruct mii_data\t\t*mii = NULL;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\txl_stop(sc);\n\n\tif (sc->xl_hasmii)\n\t\tmii = &sc->sc_mii;\n\n\tif (mii == NULL) {\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_RESET);\n\t\txl_wait(sc);\n\t}\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\txl_wait(sc);\n\tDELAY(10000);\n\n\n\t/* Init our MAC address */\n\tXL_SEL_WIN(2);\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++) {\n\t\tCSR_WRITE_1(sc, XL_W2_STATION_ADDR_LO + i,\n\t\t\t\tsc->arpcom.ac_enaddr[i]);\n\t}\n\n\t/* Clear the station mask. */\n\tfor (i = 0; i < 3; i++)\n\t\tCSR_WRITE_2(sc, XL_W2_STATION_MASK_LO + (i * 2), 0);\n#ifdef notdef\n\t/* Reset TX and RX. */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_RESET);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\txl_wait(sc);\n#endif\n\t/* Init circular RX list. */\n\tif (xl_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"xl%d: initialization failed: no \"\n\t\t\t\"memory for rx buffers\\n\", sc->xl_unit);\n\t\txl_stop(sc);\n\t\treturn;\n\t}\n\n\t/* Init TX descriptors. */\n\tif (sc->xl_type == XL_TYPE_905B)\n\t\txl_list_tx_init_90xB(sc);\n\telse\n\t\txl_list_tx_init(sc);\n\n\t/*\n\t * Set the TX freethresh value.\n\t * Note that this has no effect on 3c905B \"cyclone\"\n\t * cards but is required for 3c900/3c905 \"boomerang\"\n\t * cards in order to enable the download engine.\n\t */\n\tCSR_WRITE_1(sc, XL_TX_FREETHRESH, XL_PACKET_SIZE >> 8);\n\n\t/* Set the TX start threshold for best performance. */\n\tsc->xl_tx_thresh = XL_MIN_FRAMELEN;\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_SET_START|sc->xl_tx_thresh);\n\n\t/*\n\t * If this is a 3c905B, also set the tx reclaim threshold.\n\t * This helps cut down on the number of tx reclaim errors\n\t * that could happen on a busy network. The chip multiplies\n\t * the register value by 16 to obtain the actual threshold\n\t * in bytes, so we divide by 16 when setting the value here.\n\t * The existing threshold value can be examined by reading\n\t * the register at offset 9 in window 5.\n\t */\n\tif (sc->xl_type == XL_TYPE_905B) {\n\t\tCSR_WRITE_2(sc, XL_COMMAND,\n\t\t    XL_CMD_SET_TX_RECLAIM|(XL_PACKET_SIZE >> 4));\n\t}\n\n\t/* Set RX filter bits. */\n\tXL_SEL_WIN(5);\n\trxfilt = CSR_READ_1(sc, XL_W5_RX_FILTER);\n\n\t/* Set the individual bit to receive frames for this host only. */\n\trxfilt |= XL_RXFILTER_INDIVIDUAL;\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\trxfilt |= XL_RXFILTER_ALLFRAMES;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t} else {\n\t\trxfilt &= ~XL_RXFILTER_ALLFRAMES;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t}\n\n\t/*\n\t * Set capture broadcast bit to capture broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\trxfilt |= XL_RXFILTER_BROADCAST;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t} else {\n\t\trxfilt &= ~XL_RXFILTER_BROADCAST;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t}\n\n\t/*\n\t * Program the multicast filter, if necessary.\n\t */\n\tif (sc->xl_type == XL_TYPE_905B)\n\t\txl_setmulti_hash(sc);\n\telse\n\t\txl_setmulti(sc);\n\n\t/*\n\t * Load the address of the RX list. We have to\n\t * stall the upload engine before we can manipulate\n\t * the uplist pointer register, then unstall it when\n\t * we're finished. We also have to wait for the\n\t * stall command to complete before proceeding.\n\t * Note that we have to do this after any RX resets\n\t * have completed since the uplist register is cleared\n\t * by a reset.\n\t */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_UP_STALL);\n\txl_wait(sc);\n\tCSR_WRITE_4(sc, XL_UPLIST_PTR, vtophys(&sc->xl_ldata->xl_rx_list[0]));\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_UP_UNSTALL);\n\txl_wait(sc);\n\n\tif (sc->xl_type == XL_TYPE_905B) {\n\t\t/* Set polling interval */\n\t\tCSR_WRITE_1(sc, XL_DOWN_POLL, 64);\n\t\t/* Load the address of the TX list */\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_STALL);\n\t\txl_wait(sc);\n\t\tCSR_WRITE_4(sc, XL_DOWNLIST_PTR,\n\t\t    vtophys(&sc->xl_ldata->xl_tx_list[0]));\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_UNSTALL);\n\t\txl_wait(sc);\n\t}\n\n\t/*\n\t * If the coax transceiver is on, make sure to enable\n\t * the DC-DC converter.\n \t */\n\tXL_SEL_WIN(3);\n\tif (sc->xl_xcvr == XL_XCVR_COAX)\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_START);\n\telse\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_STOP);\n\n\t/* Clear out the stats counters. */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STATS_DISABLE);\n\tsc->xl_stats_no_timeout = 1;\n\txl_stats_update(sc);\n\tsc->xl_stats_no_timeout = 0;\n\tXL_SEL_WIN(4);\n\tCSR_WRITE_2(sc, XL_W4_NET_DIAG, XL_NETDIAG_UPPER_BYTES_ENABLE);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STATS_ENABLE);\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ACK|0xFF);\n\n\tif (sc->xl_bustype == XL_BUS_CARDBUS)\n\t\tbus_space_write_4(sc->xl_funct, sc->xl_funch, 4, 0x8000);\n\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STAT_ENB|XL_INTRS);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ENB|XL_INTRS);\n\n\t/* Set the RX early threshold */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_THRESH|(XL_PACKET_SIZE >>2));\n\tCSR_WRITE_2(sc, XL_DMACTL, XL_DMACTL_UP_RX_EARLY);\n\n\t/* Enable receiver and transmitter. */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_ENABLE);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_ENABLE);\n\txl_wait(sc);\n\n\t/* Restore state of BMCR */\n\tif (mii != NULL)\n\t\tmii_mediachg(mii);\n\n\t/* Select window 7 for normal operations. */\n\tXL_SEL_WIN(7);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\ttimeout(xl_stats_update, sc, hz);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "ifm->ifm_media"
          ],
          "line": 2068
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_init;\nint xl_ifmedia_upd;\nvoid xl_setmode;\n\nint xl_ifmedia_upd(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct xl_softc\t\t*sc;\n\tstruct ifmedia\t\t*ifm = NULL;\n\tstruct mii_data\t\t*mii = NULL;\n\n\tsc = ifp->if_softc;\n\n\tif (sc->xl_hasmii)\n\t\tmii = &sc->sc_mii;\n\tif (mii == NULL)\n\t\tifm = &sc->ifmedia;\n\telse\n\t\tifm = &mii->mii_media;\n\n\tswitch(IFM_SUBTYPE(ifm->ifm_media)) {\n\tcase IFM_100_FX:\n\tcase IFM_10_FL:\n\tcase IFM_10_2:\n\tcase IFM_10_5:\n\t\txl_setmode(sc, ifm->ifm_media);\n\t\treturn (0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (sc->xl_media & XL_MEDIAOPT_MII || sc->xl_media & XL_MEDIAOPT_BTX\n\t\t|| sc->xl_media & XL_MEDIAOPT_BT4) {\n\t\txl_init(sc);\n\t} else {\n\t\txl_setmode(sc, ifm->ifm_media);\n\t}\n\n\treturn(0);\n}"
  },
  {
    "function_name": "xl_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
    "lines": "1844-2047",
    "snippet": "void xl_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct xl_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts, i;\n\tu_int16_t\t\trxfilt = 0;\n\tstruct mii_data\t\t*mii = NULL;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\txl_stop(sc);\n\n\tif (sc->xl_hasmii)\n\t\tmii = &sc->sc_mii;\n\n\tif (mii == NULL) {\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_RESET);\n\t\txl_wait(sc);\n\t}\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\txl_wait(sc);\n\tDELAY(10000);\n\n\n\t/* Init our MAC address */\n\tXL_SEL_WIN(2);\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++) {\n\t\tCSR_WRITE_1(sc, XL_W2_STATION_ADDR_LO + i,\n\t\t\t\tsc->arpcom.ac_enaddr[i]);\n\t}\n\n\t/* Clear the station mask. */\n\tfor (i = 0; i < 3; i++)\n\t\tCSR_WRITE_2(sc, XL_W2_STATION_MASK_LO + (i * 2), 0);\n#ifdef notdef\n\t/* Reset TX and RX. */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_RESET);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\txl_wait(sc);\n#endif\n\t/* Init circular RX list. */\n\tif (xl_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"xl%d: initialization failed: no \"\n\t\t\t\"memory for rx buffers\\n\", sc->xl_unit);\n\t\txl_stop(sc);\n\t\treturn;\n\t}\n\n\t/* Init TX descriptors. */\n\tif (sc->xl_type == XL_TYPE_905B)\n\t\txl_list_tx_init_90xB(sc);\n\telse\n\t\txl_list_tx_init(sc);\n\n\t/*\n\t * Set the TX freethresh value.\n\t * Note that this has no effect on 3c905B \"cyclone\"\n\t * cards but is required for 3c900/3c905 \"boomerang\"\n\t * cards in order to enable the download engine.\n\t */\n\tCSR_WRITE_1(sc, XL_TX_FREETHRESH, XL_PACKET_SIZE >> 8);\n\n\t/* Set the TX start threshold for best performance. */\n\tsc->xl_tx_thresh = XL_MIN_FRAMELEN;\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_SET_START|sc->xl_tx_thresh);\n\n\t/*\n\t * If this is a 3c905B, also set the tx reclaim threshold.\n\t * This helps cut down on the number of tx reclaim errors\n\t * that could happen on a busy network. The chip multiplies\n\t * the register value by 16 to obtain the actual threshold\n\t * in bytes, so we divide by 16 when setting the value here.\n\t * The existing threshold value can be examined by reading\n\t * the register at offset 9 in window 5.\n\t */\n\tif (sc->xl_type == XL_TYPE_905B) {\n\t\tCSR_WRITE_2(sc, XL_COMMAND,\n\t\t    XL_CMD_SET_TX_RECLAIM|(XL_PACKET_SIZE >> 4));\n\t}\n\n\t/* Set RX filter bits. */\n\tXL_SEL_WIN(5);\n\trxfilt = CSR_READ_1(sc, XL_W5_RX_FILTER);\n\n\t/* Set the individual bit to receive frames for this host only. */\n\trxfilt |= XL_RXFILTER_INDIVIDUAL;\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\trxfilt |= XL_RXFILTER_ALLFRAMES;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t} else {\n\t\trxfilt &= ~XL_RXFILTER_ALLFRAMES;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t}\n\n\t/*\n\t * Set capture broadcast bit to capture broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\trxfilt |= XL_RXFILTER_BROADCAST;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t} else {\n\t\trxfilt &= ~XL_RXFILTER_BROADCAST;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t}\n\n\t/*\n\t * Program the multicast filter, if necessary.\n\t */\n\tif (sc->xl_type == XL_TYPE_905B)\n\t\txl_setmulti_hash(sc);\n\telse\n\t\txl_setmulti(sc);\n\n\t/*\n\t * Load the address of the RX list. We have to\n\t * stall the upload engine before we can manipulate\n\t * the uplist pointer register, then unstall it when\n\t * we're finished. We also have to wait for the\n\t * stall command to complete before proceeding.\n\t * Note that we have to do this after any RX resets\n\t * have completed since the uplist register is cleared\n\t * by a reset.\n\t */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_UP_STALL);\n\txl_wait(sc);\n\tCSR_WRITE_4(sc, XL_UPLIST_PTR, vtophys(&sc->xl_ldata->xl_rx_list[0]));\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_UP_UNSTALL);\n\txl_wait(sc);\n\n\tif (sc->xl_type == XL_TYPE_905B) {\n\t\t/* Set polling interval */\n\t\tCSR_WRITE_1(sc, XL_DOWN_POLL, 64);\n\t\t/* Load the address of the TX list */\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_STALL);\n\t\txl_wait(sc);\n\t\tCSR_WRITE_4(sc, XL_DOWNLIST_PTR,\n\t\t    vtophys(&sc->xl_ldata->xl_tx_list[0]));\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_UNSTALL);\n\t\txl_wait(sc);\n\t}\n\n\t/*\n\t * If the coax transceiver is on, make sure to enable\n\t * the DC-DC converter.\n \t */\n\tXL_SEL_WIN(3);\n\tif (sc->xl_xcvr == XL_XCVR_COAX)\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_START);\n\telse\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_STOP);\n\n\t/* Clear out the stats counters. */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STATS_DISABLE);\n\tsc->xl_stats_no_timeout = 1;\n\txl_stats_update(sc);\n\tsc->xl_stats_no_timeout = 0;\n\tXL_SEL_WIN(4);\n\tCSR_WRITE_2(sc, XL_W4_NET_DIAG, XL_NETDIAG_UPPER_BYTES_ENABLE);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STATS_ENABLE);\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ACK|0xFF);\n\n\tif (sc->xl_bustype == XL_BUS_CARDBUS)\n\t\tbus_space_write_4(sc->xl_funct, sc->xl_funch, 4, 0x8000);\n\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STAT_ENB|XL_INTRS);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ENB|XL_INTRS);\n\n\t/* Set the RX early threshold */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_THRESH|(XL_PACKET_SIZE >>2));\n\tCSR_WRITE_2(sc, XL_DMACTL, XL_DMACTL_UP_RX_EARLY);\n\n\t/* Enable receiver and transmitter. */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_ENABLE);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_ENABLE);\n\txl_wait(sc);\n\n\t/* Restore state of BMCR */\n\tif (mii != NULL)\n\t\tmii_mediachg(mii);\n\n\t/* Select window 7 for normal operations. */\n\tXL_SEL_WIN(7);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\ttimeout(xl_stats_update, sc, hz);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void xl_stats_update",
      "void xl_init",
      "void xl_stop",
      "void xl_setmulti",
      "void xl_setmulti_hash",
      "int xl_list_rx_init",
      "int xl_list_tx_init",
      "int xl_list_tx_init_90xB",
      "void xl_wait"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "xl_stats_update",
            "sc",
            "hz"
          ],
          "line": 2044
        },
        "resolved": true,
        "details": {
          "function_name": "wdctimeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "952-980",
          "snippet": "void\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [
            "static void  __wdcerror"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nstatic void  __wdcerror;\n\nvoid\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XL_SEL_WIN",
          "args": [
            "7"
          ],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mii_mediachg",
          "args": [
            "mii"
          ],
          "line": 2034
        },
        "resolved": true,
        "details": {
          "function_name": "mii_mediachg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/mii.c",
          "lines": "170-187",
          "snippet": "int\nmii_mediachg(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\tint rv;\n\n\tmii->mii_media_status = 0;\n\tmii->mii_media_active = IFM_NONE;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list)) {\n\t\trv = (*child->mii_service)(child, mii, MII_MEDIACHG);\n\t\tif (rv)\n\t\t\treturn (rv);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nint\nmii_mediachg(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\tint rv;\n\n\tmii->mii_media_status = 0;\n\tmii->mii_media_active = IFM_NONE;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list)) {\n\t\trv = (*child->mii_service)(child, mii, MII_MEDIACHG);\n\t\tif (rv)\n\t\t\treturn (rv);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xl_wait",
          "args": [
            "sc"
          ],
          "line": 2030
        },
        "resolved": true,
        "details": {
          "function_name": "xl_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "200-216",
          "snippet": "void xl_wait(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tfor (i = 0; i < XL_TIMEOUT; i++) {\n\t\tif (!(CSR_READ_2(sc, XL_STATUS) & XL_STAT_CMDBUSY))\n\t\t\tbreak;\n\t}\n\n#ifdef DIAGNOSTIC\n\tif (i == XL_TIMEOUT)\n\t\tprintf(\"xl%d: command never completed!\\n\", sc->xl_unit);\n#endif\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void xl_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_wait;\n\nvoid xl_wait(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tfor (i = 0; i < XL_TIMEOUT; i++) {\n\t\tif (!(CSR_READ_2(sc, XL_STATUS) & XL_STAT_CMDBUSY))\n\t\t\tbreak;\n\t}\n\n#ifdef DIAGNOSTIC\n\tif (i == XL_TIMEOUT)\n\t\tprintf(\"xl%d: command never completed!\\n\", sc->xl_unit);\n#endif\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_RX_ENABLE"
          ],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_TX_ENABLE"
          ],
          "line": 2027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_DMACTL",
            "XL_DMACTL_UP_RX_EARLY"
          ],
          "line": 2024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_RX_SET_THRESH|(XL_PACKET_SIZE >>2)"
          ],
          "line": 2023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_INTR_ENB|XL_INTRS"
          ],
          "line": 2020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_STAT_ENB|XL_INTRS"
          ],
          "line": 2019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_4",
          "args": [
            "sc->xl_funct",
            "sc->xl_funch",
            "4",
            "0x8000"
          ],
          "line": 2017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_INTR_ACK|0xFF"
          ],
          "line": 2014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_STATS_ENABLE"
          ],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_W4_NET_DIAG",
            "XL_NETDIAG_UPPER_BYTES_ENABLE"
          ],
          "line": 2008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XL_SEL_WIN",
          "args": [
            "4"
          ],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xl_stats_update",
          "args": [
            "sc"
          ],
          "line": 2005
        },
        "resolved": true,
        "details": {
          "function_name": "xl_stats_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "1480-1529",
          "snippet": "void xl_stats_update(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct xl_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tstruct xl_stats\t\txl_stats;\n\tu_int8_t\t\t*p;\n\tint\t\t\ti;\n\tstruct mii_data\t\t*mii = NULL;\n\n\tbzero((char *)&xl_stats, sizeof(struct xl_stats));\n\n\tsc = xsc;\n\tifp = &sc->arpcom.ac_if;\n\tif (sc->xl_hasmii)\n\t\tmii = &sc->sc_mii;\n\n\tp = (u_int8_t *)&xl_stats;\n\n\t/* Read all the stats registers. */\n\tXL_SEL_WIN(6);\n\n\tfor (i = 0; i < 16; i++)\n\t\t*p++ = CSR_READ_1(sc, XL_W6_CARRIER_LOST + i);\n\n\tifp->if_ierrors += xl_stats.xl_rx_overrun;\n\n\tifp->if_collisions += xl_stats.xl_tx_multi_collision +\n\t\t\t\txl_stats.xl_tx_single_collision +\n\t\t\t\txl_stats.xl_tx_late_collision;\n\n\t/*\n\t * Boomerang and cyclone chips have an extra stats counter\n\t * in window 4 (BadSSD). We have to read this too in order\n\t * to clear out all the stats registers and avoid a statsoflow\n\t * interrupt.\n\t */\n\tXL_SEL_WIN(4);\n\tCSR_READ_1(sc, XL_W4_BADSSD);\n\n\tif (mii != NULL)\n\t\tmii_tick(mii);\n\n\tXL_SEL_WIN(7);\n\n\tif (!sc->xl_stats_no_timeout)\n\t\ttimeout(xl_stats_update, sc, hz);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void xl_stats_update"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_stats_update;\n\nvoid xl_stats_update(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct xl_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tstruct xl_stats\t\txl_stats;\n\tu_int8_t\t\t*p;\n\tint\t\t\ti;\n\tstruct mii_data\t\t*mii = NULL;\n\n\tbzero((char *)&xl_stats, sizeof(struct xl_stats));\n\n\tsc = xsc;\n\tifp = &sc->arpcom.ac_if;\n\tif (sc->xl_hasmii)\n\t\tmii = &sc->sc_mii;\n\n\tp = (u_int8_t *)&xl_stats;\n\n\t/* Read all the stats registers. */\n\tXL_SEL_WIN(6);\n\n\tfor (i = 0; i < 16; i++)\n\t\t*p++ = CSR_READ_1(sc, XL_W6_CARRIER_LOST + i);\n\n\tifp->if_ierrors += xl_stats.xl_rx_overrun;\n\n\tifp->if_collisions += xl_stats.xl_tx_multi_collision +\n\t\t\t\txl_stats.xl_tx_single_collision +\n\t\t\t\txl_stats.xl_tx_late_collision;\n\n\t/*\n\t * Boomerang and cyclone chips have an extra stats counter\n\t * in window 4 (BadSSD). We have to read this too in order\n\t * to clear out all the stats registers and avoid a statsoflow\n\t * interrupt.\n\t */\n\tXL_SEL_WIN(4);\n\tCSR_READ_1(sc, XL_W4_BADSSD);\n\n\tif (mii != NULL)\n\t\tmii_tick(mii);\n\n\tXL_SEL_WIN(7);\n\n\tif (!sc->xl_stats_no_timeout)\n\t\ttimeout(xl_stats_update, sc, hz);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_STATS_DISABLE"
          ],
          "line": 2003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_COAX_STOP"
          ],
          "line": 2000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_COAX_START"
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XL_SEL_WIN",
          "args": [
            "3"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_DOWN_UNSTALL"
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "XL_DOWNLIST_PTR",
            "vtophys(&sc->xl_ldata->xl_tx_list[0])"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&sc->xl_ldata->xl_tx_list[0]"
          ],
          "line": 1987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_DOWN_STALL"
          ],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_1",
          "args": [
            "sc",
            "XL_DOWN_POLL",
            "64"
          ],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_UP_UNSTALL"
          ],
          "line": 1977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "XL_UPLIST_PTR",
            "vtophys(&sc->xl_ldata->xl_rx_list[0])"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&sc->xl_ldata->xl_rx_list[0]"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_UP_STALL"
          ],
          "line": 1974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xl_setmulti",
          "args": [
            "sc"
          ],
          "line": 1962
        },
        "resolved": true,
        "details": {
          "function_name": "xl_setmulti_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "639-688",
          "snippet": "void xl_setmulti_hash(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\th = 0, i;\n\tstruct arpcom *ac = &sc->arpcom;\n\tstruct ether_multi *enm;\n\tstruct ether_multistep step;\n\tu_int8_t\t\trxfilt;\n\tint\t\t\tmcnt = 0;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tXL_SEL_WIN(5);\n\trxfilt = CSR_READ_1(sc, XL_W5_RX_FILTER);\n\n\tif (ifp->if_flags & IFF_ALLMULTI) {\nallmulti:\n\t\trxfilt |= XL_RXFILTER_ALLMULTI;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t\treturn;\n\t} else\n\t\trxfilt &= ~XL_RXFILTER_ALLMULTI;\n\n\n\t/* first, zot all the existing hash bits */\n\tfor (i = 0; i < XL_HASHFILT_SIZE; i++)\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_HASH|i);\n\n\t/* now program new ones */\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {\n\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\tgoto allmulti;\n\t\t}\n\t\th = xl_calchash(enm->enm_addrlo);\n\t\tmcnt++;\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\n\tif (mcnt)\n\t\trxfilt |= XL_RXFILTER_MULTIHASH;\n\telse\n\t\trxfilt &= ~XL_RXFILTER_MULTIHASH;\n\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int8_t xl_calchash",
            "void xl_setmulti_hash"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int8_t xl_calchash;\nvoid xl_setmulti_hash;\n\nvoid xl_setmulti_hash(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\th = 0, i;\n\tstruct arpcom *ac = &sc->arpcom;\n\tstruct ether_multi *enm;\n\tstruct ether_multistep step;\n\tu_int8_t\t\trxfilt;\n\tint\t\t\tmcnt = 0;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tXL_SEL_WIN(5);\n\trxfilt = CSR_READ_1(sc, XL_W5_RX_FILTER);\n\n\tif (ifp->if_flags & IFF_ALLMULTI) {\nallmulti:\n\t\trxfilt |= XL_RXFILTER_ALLMULTI;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t\treturn;\n\t} else\n\t\trxfilt &= ~XL_RXFILTER_ALLMULTI;\n\n\n\t/* first, zot all the existing hash bits */\n\tfor (i = 0; i < XL_HASHFILT_SIZE; i++)\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_HASH|i);\n\n\t/* now program new ones */\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {\n\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\tgoto allmulti;\n\t\t}\n\t\th = xl_calchash(enm->enm_addrlo);\n\t\tmcnt++;\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\n\tif (mcnt)\n\t\trxfilt |= XL_RXFILTER_MULTIHASH;\n\telse\n\t\trxfilt &= ~XL_RXFILTER_MULTIHASH;\n\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_RX_SET_FILT|rxfilt"
          ],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_RX_SET_FILT|rxfilt"
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_RX_SET_FILT|rxfilt"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_RX_SET_FILT|rxfilt"
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_1",
          "args": [
            "sc",
            "XL_W5_RX_FILTER"
          ],
          "line": 1931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XL_SEL_WIN",
          "args": [
            "5"
          ],
          "line": 1930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_SET_TX_RECLAIM|(XL_PACKET_SIZE >> 4)"
          ],
          "line": 1925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_TX_SET_START|sc->xl_tx_thresh"
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_1",
          "args": [
            "sc",
            "XL_TX_FREETHRESH",
            "XL_PACKET_SIZE >> 8"
          ],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xl_list_tx_init",
          "args": [
            "sc"
          ],
          "line": 1901
        },
        "resolved": true,
        "details": {
          "function_name": "xl_list_tx_init_90xB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "1030-1063",
          "snippet": "int\nxl_list_tx_init_90xB(sc)\n\tstruct xl_softc *sc;\n{\n\tstruct xl_chain_data *cd;\n\tstruct xl_list_data *ld;\n\tint i;\n\n\tcd = &sc->xl_cdata;\n\tld = sc->xl_ldata;\n\tfor (i = 0; i < XL_TX_LIST_CNT; i++) {\n\t\tcd->xl_tx_chain[i].xl_ptr = &ld->xl_tx_list[i];\n\t\tcd->xl_tx_chain[i].xl_phys = vtophys(&ld->xl_tx_list[i]);\n\t\tif (i == (XL_TX_LIST_CNT - 1))\n\t\t\tcd->xl_tx_chain[i].xl_next = &cd->xl_tx_chain[0];\n\t\telse\n\t\t\tcd->xl_tx_chain[i].xl_next = &cd->xl_tx_chain[i + 1];\n\t\tif (i == 0)\n\t\t\tcd->xl_tx_chain[i].xl_prev =\n\t\t\t    &cd->xl_tx_chain[XL_TX_LIST_CNT - 1];\n\t\telse\n\t\t\tcd->xl_tx_chain[i].xl_prev =\n\t\t\t    &cd->xl_tx_chain[i - 1];\n\t}\n\n\tbzero((char *)ld->xl_tx_list, sizeof(struct xl_list) * XL_TX_LIST_CNT);\n\tld->xl_tx_list[0].xl_status = XL_TXSTAT_EMPTY;\n\n\tcd->xl_tx_prod = 1;\n\tcd->xl_tx_cons = 1;\n\tcd->xl_tx_cnt = 0;\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xl_list_tx_init_90xB"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint xl_list_tx_init_90xB;\n\nint\nxl_list_tx_init_90xB(sc)\n\tstruct xl_softc *sc;\n{\n\tstruct xl_chain_data *cd;\n\tstruct xl_list_data *ld;\n\tint i;\n\n\tcd = &sc->xl_cdata;\n\tld = sc->xl_ldata;\n\tfor (i = 0; i < XL_TX_LIST_CNT; i++) {\n\t\tcd->xl_tx_chain[i].xl_ptr = &ld->xl_tx_list[i];\n\t\tcd->xl_tx_chain[i].xl_phys = vtophys(&ld->xl_tx_list[i]);\n\t\tif (i == (XL_TX_LIST_CNT - 1))\n\t\t\tcd->xl_tx_chain[i].xl_next = &cd->xl_tx_chain[0];\n\t\telse\n\t\t\tcd->xl_tx_chain[i].xl_next = &cd->xl_tx_chain[i + 1];\n\t\tif (i == 0)\n\t\t\tcd->xl_tx_chain[i].xl_prev =\n\t\t\t    &cd->xl_tx_chain[XL_TX_LIST_CNT - 1];\n\t\telse\n\t\t\tcd->xl_tx_chain[i].xl_prev =\n\t\t\t    &cd->xl_tx_chain[i - 1];\n\t}\n\n\tbzero((char *)ld->xl_tx_list, sizeof(struct xl_list) * XL_TX_LIST_CNT);\n\tld->xl_tx_list[0].xl_status = XL_TXSTAT_EMPTY;\n\n\tcd->xl_tx_prod = 1;\n\tcd->xl_tx_cons = 1;\n\tcd->xl_tx_cnt = 0;\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xl_stop",
          "args": [
            "sc"
          ],
          "line": 1893
        },
        "resolved": true,
        "details": {
          "function_name": "xl_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "2290-2351",
          "snippet": "void xl_stop(sc)\n\tstruct xl_softc *sc;\n{\n\tint i;\n\tstruct ifnet *ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_timer = 0;\n\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_DISABLE);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STATS_DISABLE);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ENB);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_DISCARD);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_DISABLE);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_STOP);\n\tDELAY(800);\n\n#ifdef foo\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_RESET);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\txl_wait(sc);\n#endif\n\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ACK|XL_STAT_INTLATCH);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STAT_ENB|0);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ENB|0);\n\n\tif (sc->xl_bustype == XL_BUS_CARDBUS)\n\t\tbus_space_write_4(sc->xl_funct, sc->xl_funch, 4, 0x8000);\n\n\t/* Stop the stats updater. */\n\tuntimeout(xl_stats_update, sc);\n\n\t/*\n\t * Free data in the RX lists.\n\t */\n\tfor (i = 0; i < XL_RX_LIST_CNT; i++) {\n\t\tif (sc->xl_cdata.xl_rx_chain[i].xl_mbuf != NULL) {\n\t\t\tm_freem(sc->xl_cdata.xl_rx_chain[i].xl_mbuf);\n\t\t\tsc->xl_cdata.xl_rx_chain[i].xl_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->xl_ldata->xl_rx_list,\n\t\tsizeof(sc->xl_ldata->xl_rx_list));\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < XL_TX_LIST_CNT; i++) {\n\t\tif (sc->xl_cdata.xl_tx_chain[i].xl_mbuf != NULL) {\n\t\t\tm_freem(sc->xl_cdata.xl_tx_chain[i].xl_mbuf);\n\t\t\tsc->xl_cdata.xl_tx_chain[i].xl_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->xl_ldata->xl_tx_list,\n\t\tsizeof(sc->xl_ldata->xl_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void xl_stats_update",
            "void xl_stop",
            "void xl_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_stats_update;\nvoid xl_stop;\nvoid xl_wait;\n\nvoid xl_stop(sc)\n\tstruct xl_softc *sc;\n{\n\tint i;\n\tstruct ifnet *ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_timer = 0;\n\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_DISABLE);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STATS_DISABLE);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ENB);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_DISCARD);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_DISABLE);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_STOP);\n\tDELAY(800);\n\n#ifdef foo\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_RESET);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\txl_wait(sc);\n#endif\n\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ACK|XL_STAT_INTLATCH);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STAT_ENB|0);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ENB|0);\n\n\tif (sc->xl_bustype == XL_BUS_CARDBUS)\n\t\tbus_space_write_4(sc->xl_funct, sc->xl_funch, 4, 0x8000);\n\n\t/* Stop the stats updater. */\n\tuntimeout(xl_stats_update, sc);\n\n\t/*\n\t * Free data in the RX lists.\n\t */\n\tfor (i = 0; i < XL_RX_LIST_CNT; i++) {\n\t\tif (sc->xl_cdata.xl_rx_chain[i].xl_mbuf != NULL) {\n\t\t\tm_freem(sc->xl_cdata.xl_rx_chain[i].xl_mbuf);\n\t\t\tsc->xl_cdata.xl_rx_chain[i].xl_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->xl_ldata->xl_rx_list,\n\t\tsizeof(sc->xl_ldata->xl_rx_list));\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < XL_TX_LIST_CNT; i++) {\n\t\tif (sc->xl_cdata.xl_tx_chain[i].xl_mbuf != NULL) {\n\t\t\tm_freem(sc->xl_cdata.xl_tx_chain[i].xl_mbuf);\n\t\t\tsc->xl_cdata.xl_tx_chain[i].xl_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->xl_ldata->xl_tx_list,\n\t\tsizeof(sc->xl_ldata->xl_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"xl%d: initialization failed: no \"\n\t\t\t\"memory for rx buffers\\n\"",
            "sc->xl_unit"
          ],
          "line": 1891
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xl_list_rx_init",
          "args": [
            "sc"
          ],
          "line": 1890
        },
        "resolved": true,
        "details": {
          "function_name": "xl_list_rx_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "1070-1099",
          "snippet": "int xl_list_rx_init(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tstruct xl_chain_data\t*cd;\n\tstruct xl_list_data\t*ld;\n\tint\t\t\ti;\n\n\tcd = &sc->xl_cdata;\n\tld = sc->xl_ldata;\n\n\tfor (i = 0; i < XL_RX_LIST_CNT; i++) {\n\t\tcd->xl_rx_chain[i].xl_ptr =\n\t\t\t(struct xl_list_onefrag *)&ld->xl_rx_list[i];\n\t\tif (xl_newbuf(sc, &cd->xl_rx_chain[i]) == ENOBUFS)\n\t\t\treturn(ENOBUFS);\n\t\tif (i == (XL_RX_LIST_CNT - 1)) {\n\t\t\tcd->xl_rx_chain[i].xl_next = &cd->xl_rx_chain[0];\n\t\t\tld->xl_rx_list[i].xl_next =\n\t\t\t    vtophys(&ld->xl_rx_list[0]);\n\t\t} else {\n\t\t\tcd->xl_rx_chain[i].xl_next = &cd->xl_rx_chain[i + 1];\n\t\t\tld->xl_rx_list[i].xl_next =\n\t\t\t    vtophys(&ld->xl_rx_list[i + 1]);\n\t\t}\n\t}\n\n\tcd->xl_rx_head = &cd->xl_rx_chain[0];\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xl_newbuf",
            "int xl_list_rx_init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint xl_newbuf;\nint xl_list_rx_init;\n\nint xl_list_rx_init(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tstruct xl_chain_data\t*cd;\n\tstruct xl_list_data\t*ld;\n\tint\t\t\ti;\n\n\tcd = &sc->xl_cdata;\n\tld = sc->xl_ldata;\n\n\tfor (i = 0; i < XL_RX_LIST_CNT; i++) {\n\t\tcd->xl_rx_chain[i].xl_ptr =\n\t\t\t(struct xl_list_onefrag *)&ld->xl_rx_list[i];\n\t\tif (xl_newbuf(sc, &cd->xl_rx_chain[i]) == ENOBUFS)\n\t\t\treturn(ENOBUFS);\n\t\tif (i == (XL_RX_LIST_CNT - 1)) {\n\t\t\tcd->xl_rx_chain[i].xl_next = &cd->xl_rx_chain[0];\n\t\t\tld->xl_rx_list[i].xl_next =\n\t\t\t    vtophys(&ld->xl_rx_list[0]);\n\t\t} else {\n\t\t\tcd->xl_rx_chain[i].xl_next = &cd->xl_rx_chain[i + 1];\n\t\t\tld->xl_rx_list[i].xl_next =\n\t\t\t    vtophys(&ld->xl_rx_list[i + 1]);\n\t\t}\n\t}\n\n\tcd->xl_rx_head = &cd->xl_rx_chain[0];\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_TX_RESET"
          ],
          "line": 1886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_RX_RESET"
          ],
          "line": 1884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_W2_STATION_MASK_LO + (i * 2)",
            "0"
          ],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_1",
          "args": [
            "sc",
            "XL_W2_STATION_ADDR_LO + i",
            "sc->arpcom.ac_enaddr[i]"
          ],
          "line": 1875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XL_SEL_WIN",
          "args": [
            "2"
          ],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10000"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_TX_RESET"
          ],
          "line": 1867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_RX_RESET"
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 1853
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_stats_update;\nvoid xl_init;\nvoid xl_stop;\nvoid xl_setmulti;\nvoid xl_setmulti_hash;\nint xl_list_rx_init;\nint xl_list_tx_init;\nint xl_list_tx_init_90xB;\nvoid xl_wait;\n\nvoid xl_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct xl_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts, i;\n\tu_int16_t\t\trxfilt = 0;\n\tstruct mii_data\t\t*mii = NULL;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\txl_stop(sc);\n\n\tif (sc->xl_hasmii)\n\t\tmii = &sc->sc_mii;\n\n\tif (mii == NULL) {\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_RESET);\n\t\txl_wait(sc);\n\t}\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\txl_wait(sc);\n\tDELAY(10000);\n\n\n\t/* Init our MAC address */\n\tXL_SEL_WIN(2);\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++) {\n\t\tCSR_WRITE_1(sc, XL_W2_STATION_ADDR_LO + i,\n\t\t\t\tsc->arpcom.ac_enaddr[i]);\n\t}\n\n\t/* Clear the station mask. */\n\tfor (i = 0; i < 3; i++)\n\t\tCSR_WRITE_2(sc, XL_W2_STATION_MASK_LO + (i * 2), 0);\n#ifdef notdef\n\t/* Reset TX and RX. */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_RESET);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\txl_wait(sc);\n#endif\n\t/* Init circular RX list. */\n\tif (xl_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"xl%d: initialization failed: no \"\n\t\t\t\"memory for rx buffers\\n\", sc->xl_unit);\n\t\txl_stop(sc);\n\t\treturn;\n\t}\n\n\t/* Init TX descriptors. */\n\tif (sc->xl_type == XL_TYPE_905B)\n\t\txl_list_tx_init_90xB(sc);\n\telse\n\t\txl_list_tx_init(sc);\n\n\t/*\n\t * Set the TX freethresh value.\n\t * Note that this has no effect on 3c905B \"cyclone\"\n\t * cards but is required for 3c900/3c905 \"boomerang\"\n\t * cards in order to enable the download engine.\n\t */\n\tCSR_WRITE_1(sc, XL_TX_FREETHRESH, XL_PACKET_SIZE >> 8);\n\n\t/* Set the TX start threshold for best performance. */\n\tsc->xl_tx_thresh = XL_MIN_FRAMELEN;\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_SET_START|sc->xl_tx_thresh);\n\n\t/*\n\t * If this is a 3c905B, also set the tx reclaim threshold.\n\t * This helps cut down on the number of tx reclaim errors\n\t * that could happen on a busy network. The chip multiplies\n\t * the register value by 16 to obtain the actual threshold\n\t * in bytes, so we divide by 16 when setting the value here.\n\t * The existing threshold value can be examined by reading\n\t * the register at offset 9 in window 5.\n\t */\n\tif (sc->xl_type == XL_TYPE_905B) {\n\t\tCSR_WRITE_2(sc, XL_COMMAND,\n\t\t    XL_CMD_SET_TX_RECLAIM|(XL_PACKET_SIZE >> 4));\n\t}\n\n\t/* Set RX filter bits. */\n\tXL_SEL_WIN(5);\n\trxfilt = CSR_READ_1(sc, XL_W5_RX_FILTER);\n\n\t/* Set the individual bit to receive frames for this host only. */\n\trxfilt |= XL_RXFILTER_INDIVIDUAL;\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\trxfilt |= XL_RXFILTER_ALLFRAMES;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t} else {\n\t\trxfilt &= ~XL_RXFILTER_ALLFRAMES;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t}\n\n\t/*\n\t * Set capture broadcast bit to capture broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\trxfilt |= XL_RXFILTER_BROADCAST;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t} else {\n\t\trxfilt &= ~XL_RXFILTER_BROADCAST;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t}\n\n\t/*\n\t * Program the multicast filter, if necessary.\n\t */\n\tif (sc->xl_type == XL_TYPE_905B)\n\t\txl_setmulti_hash(sc);\n\telse\n\t\txl_setmulti(sc);\n\n\t/*\n\t * Load the address of the RX list. We have to\n\t * stall the upload engine before we can manipulate\n\t * the uplist pointer register, then unstall it when\n\t * we're finished. We also have to wait for the\n\t * stall command to complete before proceeding.\n\t * Note that we have to do this after any RX resets\n\t * have completed since the uplist register is cleared\n\t * by a reset.\n\t */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_UP_STALL);\n\txl_wait(sc);\n\tCSR_WRITE_4(sc, XL_UPLIST_PTR, vtophys(&sc->xl_ldata->xl_rx_list[0]));\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_UP_UNSTALL);\n\txl_wait(sc);\n\n\tif (sc->xl_type == XL_TYPE_905B) {\n\t\t/* Set polling interval */\n\t\tCSR_WRITE_1(sc, XL_DOWN_POLL, 64);\n\t\t/* Load the address of the TX list */\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_STALL);\n\t\txl_wait(sc);\n\t\tCSR_WRITE_4(sc, XL_DOWNLIST_PTR,\n\t\t    vtophys(&sc->xl_ldata->xl_tx_list[0]));\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_UNSTALL);\n\t\txl_wait(sc);\n\t}\n\n\t/*\n\t * If the coax transceiver is on, make sure to enable\n\t * the DC-DC converter.\n \t */\n\tXL_SEL_WIN(3);\n\tif (sc->xl_xcvr == XL_XCVR_COAX)\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_START);\n\telse\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_STOP);\n\n\t/* Clear out the stats counters. */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STATS_DISABLE);\n\tsc->xl_stats_no_timeout = 1;\n\txl_stats_update(sc);\n\tsc->xl_stats_no_timeout = 0;\n\tXL_SEL_WIN(4);\n\tCSR_WRITE_2(sc, XL_W4_NET_DIAG, XL_NETDIAG_UPPER_BYTES_ENABLE);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STATS_ENABLE);\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ACK|0xFF);\n\n\tif (sc->xl_bustype == XL_BUS_CARDBUS)\n\t\tbus_space_write_4(sc->xl_funct, sc->xl_funch, 4, 0x8000);\n\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STAT_ENB|XL_INTRS);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ENB|XL_INTRS);\n\n\t/* Set the RX early threshold */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_THRESH|(XL_PACKET_SIZE >>2));\n\tCSR_WRITE_2(sc, XL_DMACTL, XL_DMACTL_UP_RX_EARLY);\n\n\t/* Enable receiver and transmitter. */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_ENABLE);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_ENABLE);\n\txl_wait(sc);\n\n\t/* Restore state of BMCR */\n\tif (mii != NULL)\n\t\tmii_mediachg(mii);\n\n\t/* Select window 7 for normal operations. */\n\tXL_SEL_WIN(7);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\ttimeout(xl_stats_update, sc, hz);\n\n\treturn;\n}"
  },
  {
    "function_name": "xl_start_90xB",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
    "lines": "1768-1842",
    "snippet": "void\nxl_start_90xB(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct xl_softc *sc;\n\tstruct mbuf *m_head = NULL;\n\tstruct xl_chain *prev = NULL, *cur_tx = NULL, *start_tx;\n\tint idx;\n\n\tsc = ifp->if_softc;\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\tidx = sc->xl_cdata.xl_tx_prod;\n\tstart_tx = &sc->xl_cdata.xl_tx_chain[idx];\n\n\twhile (sc->xl_cdata.xl_tx_chain[idx].xl_mbuf == NULL) {\n\n\t\tif ((XL_TX_LIST_CNT - sc->xl_cdata.xl_tx_cnt) < 3) {\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tbreak;\n\t\t}\n\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\tcur_tx = &sc->xl_cdata.xl_tx_chain[idx];\n\n\t\t/* Pack the data into the descriptor. */\n\t\txl_encap_90xB(sc, cur_tx, m_head);\n\n\t\t/* Chain it together. */\n\t\tif (prev != NULL)\n\t\t\tprev->xl_ptr->xl_next = cur_tx->xl_phys;\n\t\tprev = cur_tx;\n\n#if NBPFILTER > 0\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, cur_tx->xl_mbuf);\n#endif\n\n\t\tXL_INC(idx, XL_TX_LIST_CNT);\n\t\tsc->xl_cdata.xl_tx_cnt++;\n\t}\n\n\t/*\n\t * If there are no packets queued, bail.\n\t */\n\tif (cur_tx == NULL)\n\t\treturn;\n\n\t/*\n\t * Place the request for the upload interrupt\n\t * in the last descriptor in the chain. This way, if\n\t * we're chaining several packets at once, we'll only\n\t * get an interupt once for the whole chain rather than\n\t * once for each packet.\n\t */\n\tcur_tx->xl_ptr->xl_status |= XL_TXSTAT_DL_INTR;\n\n\t/* Start transmission */\n\tsc->xl_cdata.xl_tx_prod = idx;\n\tstart_tx->xl_prev->xl_ptr->xl_next = start_tx->xl_phys;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int xl_encap_90xB",
      "void xl_start_90xB"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XL_INC",
          "args": [
            "idx",
            "XL_TX_LIST_CNT"
          ],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "cur_tx->xl_mbuf"
          ],
          "line": 1812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xl_encap_90xB",
          "args": [
            "sc",
            "cur_tx",
            "m_head"
          ],
          "line": 1799
        },
        "resolved": true,
        "details": {
          "function_name": "xl_encap_90xB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "1731-1766",
          "snippet": "int xl_encap_90xB(sc, c, m_head)\n\tstruct xl_softc *sc;\n\tstruct xl_chain *c;\n\tstruct mbuf *m_head;\n{\n\tint frag = 0;\n\tstruct xl_frag *f = NULL;\n\tstruct mbuf *m;\n\tstruct xl_list *d;\n\n\t/*\n\t * Start packing the mbufs in this chain into\n\t * the fragment pointers. Stop when we run out\n\t * of fragments or hit the end of the mbuf chain.\n\t */\n\td = c->xl_ptr;\n\td->xl_status = 0;\n\td->xl_next = 0;\n\n\tfor (m = m_head, frag = 0; m != NULL; m = m->m_next) {\n\t\tif (m->m_len != 0) {\n\t\t\tif (frag == XL_MAXFRAGS)\n\t\t\t\tbreak;\n\t\t\tf = &d->xl_frag[frag];\n\t\t\tf->xl_addr = vtophys(mtod(m, vm_offset_t));\n\t\t\tf->xl_len = m->m_len;\n\t\t\tfrag++;\n\t\t}\n\t}\n\n\tc->xl_mbuf = m_head;\n\tc->xl_ptr->xl_frag[frag - 1].xl_len |= XL_LAST_FRAG;\n\tc->xl_ptr->xl_status = XL_TXSTAT_RND_DEFEAT;\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xl_encap_90xB"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint xl_encap_90xB;\n\nint xl_encap_90xB(sc, c, m_head)\n\tstruct xl_softc *sc;\n\tstruct xl_chain *c;\n\tstruct mbuf *m_head;\n{\n\tint frag = 0;\n\tstruct xl_frag *f = NULL;\n\tstruct mbuf *m;\n\tstruct xl_list *d;\n\n\t/*\n\t * Start packing the mbufs in this chain into\n\t * the fragment pointers. Stop when we run out\n\t * of fragments or hit the end of the mbuf chain.\n\t */\n\td = c->xl_ptr;\n\td->xl_status = 0;\n\td->xl_next = 0;\n\n\tfor (m = m_head, frag = 0; m != NULL; m = m->m_next) {\n\t\tif (m->m_len != 0) {\n\t\t\tif (frag == XL_MAXFRAGS)\n\t\t\t\tbreak;\n\t\t\tf = &d->xl_frag[frag];\n\t\t\tf->xl_addr = vtophys(mtod(m, vm_offset_t));\n\t\t\tf->xl_len = m->m_len;\n\t\t\tfrag++;\n\t\t}\n\t}\n\n\tc->xl_mbuf = m_head;\n\tc->xl_ptr->xl_frag[frag - 1].xl_len |= XL_LAST_FRAG;\n\tc->xl_ptr->xl_status = XL_TXSTAT_RND_DEFEAT;\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "m_head"
          ],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint xl_encap_90xB;\nvoid xl_start_90xB;\n\nvoid\nxl_start_90xB(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct xl_softc *sc;\n\tstruct mbuf *m_head = NULL;\n\tstruct xl_chain *prev = NULL, *cur_tx = NULL, *start_tx;\n\tint idx;\n\n\tsc = ifp->if_softc;\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\tidx = sc->xl_cdata.xl_tx_prod;\n\tstart_tx = &sc->xl_cdata.xl_tx_chain[idx];\n\n\twhile (sc->xl_cdata.xl_tx_chain[idx].xl_mbuf == NULL) {\n\n\t\tif ((XL_TX_LIST_CNT - sc->xl_cdata.xl_tx_cnt) < 3) {\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tbreak;\n\t\t}\n\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\tcur_tx = &sc->xl_cdata.xl_tx_chain[idx];\n\n\t\t/* Pack the data into the descriptor. */\n\t\txl_encap_90xB(sc, cur_tx, m_head);\n\n\t\t/* Chain it together. */\n\t\tif (prev != NULL)\n\t\t\tprev->xl_ptr->xl_next = cur_tx->xl_phys;\n\t\tprev = cur_tx;\n\n#if NBPFILTER > 0\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, cur_tx->xl_mbuf);\n#endif\n\n\t\tXL_INC(idx, XL_TX_LIST_CNT);\n\t\tsc->xl_cdata.xl_tx_cnt++;\n\t}\n\n\t/*\n\t * If there are no packets queued, bail.\n\t */\n\tif (cur_tx == NULL)\n\t\treturn;\n\n\t/*\n\t * Place the request for the upload interrupt\n\t * in the last descriptor in the chain. This way, if\n\t * we're chaining several packets at once, we'll only\n\t * get an interupt once for the whole chain rather than\n\t * once for each packet.\n\t */\n\tcur_tx->xl_ptr->xl_status |= XL_TXSTAT_DL_INTR;\n\n\t/* Start transmission */\n\tsc->xl_cdata.xl_tx_prod = idx;\n\tstart_tx->xl_prev->xl_ptr->xl_next = start_tx->xl_phys;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n}"
  },
  {
    "function_name": "xl_encap_90xB",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
    "lines": "1731-1766",
    "snippet": "int xl_encap_90xB(sc, c, m_head)\n\tstruct xl_softc *sc;\n\tstruct xl_chain *c;\n\tstruct mbuf *m_head;\n{\n\tint frag = 0;\n\tstruct xl_frag *f = NULL;\n\tstruct mbuf *m;\n\tstruct xl_list *d;\n\n\t/*\n\t * Start packing the mbufs in this chain into\n\t * the fragment pointers. Stop when we run out\n\t * of fragments or hit the end of the mbuf chain.\n\t */\n\td = c->xl_ptr;\n\td->xl_status = 0;\n\td->xl_next = 0;\n\n\tfor (m = m_head, frag = 0; m != NULL; m = m->m_next) {\n\t\tif (m->m_len != 0) {\n\t\t\tif (frag == XL_MAXFRAGS)\n\t\t\t\tbreak;\n\t\t\tf = &d->xl_frag[frag];\n\t\t\tf->xl_addr = vtophys(mtod(m, vm_offset_t));\n\t\t\tf->xl_len = m->m_len;\n\t\t\tfrag++;\n\t\t}\n\t}\n\n\tc->xl_mbuf = m_head;\n\tc->xl_ptr->xl_frag[frag - 1].xl_len |= XL_LAST_FRAG;\n\tc->xl_ptr->xl_status = XL_TXSTAT_RND_DEFEAT;\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int xl_encap_90xB"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "mtod(m, vm_offset_t)"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "vm_offset_t"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint xl_encap_90xB;\n\nint xl_encap_90xB(sc, c, m_head)\n\tstruct xl_softc *sc;\n\tstruct xl_chain *c;\n\tstruct mbuf *m_head;\n{\n\tint frag = 0;\n\tstruct xl_frag *f = NULL;\n\tstruct mbuf *m;\n\tstruct xl_list *d;\n\n\t/*\n\t * Start packing the mbufs in this chain into\n\t * the fragment pointers. Stop when we run out\n\t * of fragments or hit the end of the mbuf chain.\n\t */\n\td = c->xl_ptr;\n\td->xl_status = 0;\n\td->xl_next = 0;\n\n\tfor (m = m_head, frag = 0; m != NULL; m = m->m_next) {\n\t\tif (m->m_len != 0) {\n\t\t\tif (frag == XL_MAXFRAGS)\n\t\t\t\tbreak;\n\t\t\tf = &d->xl_frag[frag];\n\t\t\tf->xl_addr = vtophys(mtod(m, vm_offset_t));\n\t\t\tf->xl_len = m->m_len;\n\t\t\tfrag++;\n\t\t}\n\t}\n\n\tc->xl_mbuf = m_head;\n\tc->xl_ptr->xl_frag[frag - 1].xl_len |= XL_LAST_FRAG;\n\tc->xl_ptr->xl_status = XL_TXSTAT_RND_DEFEAT;\n\n\treturn(0);\n}"
  },
  {
    "function_name": "xl_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
    "lines": "1611-1729",
    "snippet": "void xl_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct xl_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head = NULL;\n\tstruct xl_chain\t\t*prev = NULL, *cur_tx = NULL, *start_tx;\n\n\tsc = ifp->if_softc;\n\n\t/*\n\t * Check for an available queue slot. If there are none,\n\t * punt.\n\t */\n\tif (sc->xl_cdata.xl_tx_free == NULL) {\n\t\txl_txeoc(sc);\n\t\txl_txeof(sc);\n\t\tif (sc->xl_cdata.xl_tx_free == NULL) {\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tstart_tx = sc->xl_cdata.xl_tx_free;\n\n\twhile(sc->xl_cdata.xl_tx_free != NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\t/* Pick a descriptor off the free list. */\n\t\tcur_tx = sc->xl_cdata.xl_tx_free;\n\t\tsc->xl_cdata.xl_tx_free = cur_tx->xl_next;\n\n\t\tcur_tx->xl_next = NULL;\n\n\t\t/* Pack the data into the descriptor. */\n\t\txl_encap(sc, cur_tx, m_head);\n\n\t\t/* Chain it together. */\n\t\tif (prev != NULL) {\n\t\t\tprev->xl_next = cur_tx;\n\t\t\tprev->xl_ptr->xl_next = vtophys(cur_tx->xl_ptr);\n\t\t}\n\t\tprev = cur_tx;\n\n#if NBPFILTER > 0\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, cur_tx->xl_mbuf);\n#endif\n\t}\n\n\t/*\n\t * If there are no packets queued, bail.\n\t */\n\tif (cur_tx == NULL)\n\t\treturn;\n\n\t/*\n\t * Place the request for the upload interrupt\n\t * in the last descriptor in the chain. This way, if\n\t * we're chaining several packets at once, we'll only\n\t * get an interupt once for the whole chain rather than\n\t * once for each packet.\n\t */\n\tcur_tx->xl_ptr->xl_status |= XL_TXSTAT_DL_INTR;\n\n\t/*\n\t * Queue the packets. If the TX channel is clear, update\n\t * the downlist pointer register.\n\t */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_STALL);\n\txl_wait(sc);\n\n\tif (sc->xl_cdata.xl_tx_head != NULL) {\n\t\tsc->xl_cdata.xl_tx_tail->xl_next = start_tx;\n\t\tsc->xl_cdata.xl_tx_tail->xl_ptr->xl_next =\n\t\t\t\t\tvtophys(start_tx->xl_ptr);\n\t\tsc->xl_cdata.xl_tx_tail->xl_ptr->xl_status &=\n\t\t\t\t\t~XL_TXSTAT_DL_INTR;\n\t\tsc->xl_cdata.xl_tx_tail = cur_tx;\n\t} else {\n\t\tsc->xl_cdata.xl_tx_head = start_tx;\n\t\tsc->xl_cdata.xl_tx_tail = cur_tx;\n\t}\n\tif (!CSR_READ_4(sc, XL_DOWNLIST_PTR))\n\t\tCSR_WRITE_4(sc, XL_DOWNLIST_PTR, vtophys(start_tx->xl_ptr));\n\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_UNSTALL);\n\n\tXL_SEL_WIN(7);\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n\n\t/*\n\t * XXX Under certain conditions, usually on slower machines\n\t * where interrupts may be dropped, it's possible for the\n\t * adapter to chew up all the buffers in the receive ring\n\t * and stall, without us being able to do anything about it.\n\t * To guard against this, we need to make a pass over the\n\t * RX queue to make sure there aren't any packets pending.\n\t * Doing it here means we can flush the receive ring at the\n\t * same time the chip is DMAing the transmit descriptors we\n\t * just gave it.\n \t *\n\t * 3Com goes to some lengths to emphasize the Parallel Tasking (tm)\n\t * nature of their chips in all their marketing literature;\n\t * we may as well take advantage of it. :)\n\t */\n\txl_rxeof(sc);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int xl_encap",
      "void xl_rxeof",
      "void xl_txeof",
      "void xl_txeoc",
      "void xl_start",
      "void xl_wait"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xl_rxeof",
          "args": [
            "sc"
          ],
          "line": 1726
        },
        "resolved": true,
        "details": {
          "function_name": "xl_rxeof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "1159-1262",
          "snippet": "void xl_rxeof(sc)\n\tstruct xl_softc\t\t*sc;\n{\n        struct ether_header\t*eh;\n        struct mbuf\t\t*m;\n        struct ifnet\t\t*ifp;\n\tstruct xl_chain_onefrag\t*cur_rx;\n\tint\t\t\ttotal_len = 0;\n\tu_int16_t\t\trxstat;\n\n\tifp = &sc->arpcom.ac_if;\n\nagain:\n\n\twhile((rxstat = sc->xl_cdata.xl_rx_head->xl_ptr->xl_status)) {\n\t\tcur_rx = sc->xl_cdata.xl_rx_head;\n\t\tsc->xl_cdata.xl_rx_head = cur_rx->xl_next;\n\n\t\t/*\n\t\t * If an error occurs, update stats, clear the\n\t\t * status word and leave the mbuf cluster in place:\n\t\t * it should simply get re-used next time this descriptor\n\t \t * comes up in the ring.\n\t\t */\n\t\tif (rxstat & XL_RXSTAT_UP_ERROR) {\n\t\t\tifp->if_ierrors++;\n\t\t\tcur_rx->xl_ptr->xl_status = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If there error bit was not set, the upload complete\n\t\t * bit should be set which means we have a valid packet.\n\t\t * If not, something truly strange has happened.\n\t\t */\n\t\tif (!(rxstat & XL_RXSTAT_UP_CMPLT)) {\n\t\t\tprintf(\"xl%d: bad receive status -- \"\n\t\t\t    \"packet dropped\", sc->xl_unit);\n\t\t\tifp->if_ierrors++;\n\t\t\tcur_rx->xl_ptr->xl_status = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* No errors; receive the packet. */\t\n\t\tm = cur_rx->xl_mbuf;\n\t\ttotal_len = cur_rx->xl_ptr->xl_status & XL_RXSTAT_LENMASK;\n\n\t\t/*\n\t\t * Try to conjure up a new mbuf cluster. If that\n\t\t * fails, it means we have an out of memory condition and\n\t\t * should leave the buffer in place and continue. This will\n\t\t * result in a lost packet, but there's little else we\n\t\t * can do in this situation.\n\t\t */\n\t\tif (xl_newbuf(sc, cur_rx) == ENOBUFS) {\n\t\t\tifp->if_ierrors++;\n\t\t\tcur_rx->xl_ptr->xl_status = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tifp->if_ipackets++;\n\t\teh = mtod(m, struct ether_header *);\n\t\tm->m_pkthdr.rcvif = ifp;\n#if NBPFILTER > 0\n\t\t/*\n\t\t * Handle BPF listeners. Let the BPF user see the packet.\n\t\t */\n\t\tif (ifp->if_bpf) {\n\t\t\tm->m_pkthdr.len = m->m_len = total_len;\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n\t\t}\n#endif\n\t\t/* Remove header from mbuf and pass it on. */\n\t\tm->m_pkthdr.len = m->m_len =\n\t\t\t\ttotal_len - sizeof(struct ether_header);\n\t\tm->m_data += sizeof(struct ether_header);\n\t\tether_input(ifp, eh, m);\n\t}\n\n\t/*\n\t * Handle the 'end of channel' condition. When the upload\n\t * engine hits the end of the RX ring, it will stall. This\n\t * is our cue to flush the RX ring, reload the uplist pointer\n\t * register and unstall the engine.\n\t * XXX This is actually a little goofy. With the ThunderLAN\n\t * chip, you get an interrupt when the receiver hits the end\n\t * of the receive ring, which tells you exactly when you\n\t * you need to reload the ring pointer. Here we have to\n\t * fake it. I'm mad at myself for not being clever enough\n\t * to avoid the use of a goto here.\n\t */\n\tif (CSR_READ_4(sc, XL_UPLIST_PTR) == 0 ||\n\t\tCSR_READ_4(sc, XL_UPLIST_STATUS) & XL_PKTSTAT_UP_STALLED) {\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_UP_STALL);\n\t\txl_wait(sc);\n\t\tCSR_WRITE_4(sc, XL_UPLIST_PTR,\n\t\t\tvtophys(&sc->xl_ldata->xl_rx_list[0]));\n\t\tsc->xl_cdata.xl_rx_head = &sc->xl_cdata.xl_rx_chain[0];\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_UP_UNSTALL);\n\t\tgoto again;\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xl_newbuf",
            "void xl_rxeof",
            "void xl_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint xl_newbuf;\nvoid xl_rxeof;\nvoid xl_wait;\n\nvoid xl_rxeof(sc)\n\tstruct xl_softc\t\t*sc;\n{\n        struct ether_header\t*eh;\n        struct mbuf\t\t*m;\n        struct ifnet\t\t*ifp;\n\tstruct xl_chain_onefrag\t*cur_rx;\n\tint\t\t\ttotal_len = 0;\n\tu_int16_t\t\trxstat;\n\n\tifp = &sc->arpcom.ac_if;\n\nagain:\n\n\twhile((rxstat = sc->xl_cdata.xl_rx_head->xl_ptr->xl_status)) {\n\t\tcur_rx = sc->xl_cdata.xl_rx_head;\n\t\tsc->xl_cdata.xl_rx_head = cur_rx->xl_next;\n\n\t\t/*\n\t\t * If an error occurs, update stats, clear the\n\t\t * status word and leave the mbuf cluster in place:\n\t\t * it should simply get re-used next time this descriptor\n\t \t * comes up in the ring.\n\t\t */\n\t\tif (rxstat & XL_RXSTAT_UP_ERROR) {\n\t\t\tifp->if_ierrors++;\n\t\t\tcur_rx->xl_ptr->xl_status = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If there error bit was not set, the upload complete\n\t\t * bit should be set which means we have a valid packet.\n\t\t * If not, something truly strange has happened.\n\t\t */\n\t\tif (!(rxstat & XL_RXSTAT_UP_CMPLT)) {\n\t\t\tprintf(\"xl%d: bad receive status -- \"\n\t\t\t    \"packet dropped\", sc->xl_unit);\n\t\t\tifp->if_ierrors++;\n\t\t\tcur_rx->xl_ptr->xl_status = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* No errors; receive the packet. */\t\n\t\tm = cur_rx->xl_mbuf;\n\t\ttotal_len = cur_rx->xl_ptr->xl_status & XL_RXSTAT_LENMASK;\n\n\t\t/*\n\t\t * Try to conjure up a new mbuf cluster. If that\n\t\t * fails, it means we have an out of memory condition and\n\t\t * should leave the buffer in place and continue. This will\n\t\t * result in a lost packet, but there's little else we\n\t\t * can do in this situation.\n\t\t */\n\t\tif (xl_newbuf(sc, cur_rx) == ENOBUFS) {\n\t\t\tifp->if_ierrors++;\n\t\t\tcur_rx->xl_ptr->xl_status = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tifp->if_ipackets++;\n\t\teh = mtod(m, struct ether_header *);\n\t\tm->m_pkthdr.rcvif = ifp;\n#if NBPFILTER > 0\n\t\t/*\n\t\t * Handle BPF listeners. Let the BPF user see the packet.\n\t\t */\n\t\tif (ifp->if_bpf) {\n\t\t\tm->m_pkthdr.len = m->m_len = total_len;\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n\t\t}\n#endif\n\t\t/* Remove header from mbuf and pass it on. */\n\t\tm->m_pkthdr.len = m->m_len =\n\t\t\t\ttotal_len - sizeof(struct ether_header);\n\t\tm->m_data += sizeof(struct ether_header);\n\t\tether_input(ifp, eh, m);\n\t}\n\n\t/*\n\t * Handle the 'end of channel' condition. When the upload\n\t * engine hits the end of the RX ring, it will stall. This\n\t * is our cue to flush the RX ring, reload the uplist pointer\n\t * register and unstall the engine.\n\t * XXX This is actually a little goofy. With the ThunderLAN\n\t * chip, you get an interrupt when the receiver hits the end\n\t * of the receive ring, which tells you exactly when you\n\t * you need to reload the ring pointer. Here we have to\n\t * fake it. I'm mad at myself for not being clever enough\n\t * to avoid the use of a goto here.\n\t */\n\tif (CSR_READ_4(sc, XL_UPLIST_PTR) == 0 ||\n\t\tCSR_READ_4(sc, XL_UPLIST_STATUS) & XL_PKTSTAT_UP_STALLED) {\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_UP_STALL);\n\t\txl_wait(sc);\n\t\tCSR_WRITE_4(sc, XL_UPLIST_PTR,\n\t\t\tvtophys(&sc->xl_ldata->xl_rx_list[0]));\n\t\tsc->xl_cdata.xl_rx_head = &sc->xl_cdata.xl_rx_chain[0];\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_UP_UNSTALL);\n\t\tgoto again;\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XL_SEL_WIN",
          "args": [
            "7"
          ],
          "line": 1704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_DOWN_UNSTALL"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "XL_DOWNLIST_PTR",
            "vtophys(start_tx->xl_ptr)"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "start_tx->xl_ptr"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "XL_DOWNLIST_PTR"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "start_tx->xl_ptr"
          ],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xl_wait",
          "args": [
            "sc"
          ],
          "line": 1686
        },
        "resolved": true,
        "details": {
          "function_name": "xl_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "200-216",
          "snippet": "void xl_wait(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tfor (i = 0; i < XL_TIMEOUT; i++) {\n\t\tif (!(CSR_READ_2(sc, XL_STATUS) & XL_STAT_CMDBUSY))\n\t\t\tbreak;\n\t}\n\n#ifdef DIAGNOSTIC\n\tif (i == XL_TIMEOUT)\n\t\tprintf(\"xl%d: command never completed!\\n\", sc->xl_unit);\n#endif\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void xl_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_wait;\n\nvoid xl_wait(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tfor (i = 0; i < XL_TIMEOUT; i++) {\n\t\tif (!(CSR_READ_2(sc, XL_STATUS) & XL_STAT_CMDBUSY))\n\t\t\tbreak;\n\t}\n\n#ifdef DIAGNOSTIC\n\tif (i == XL_TIMEOUT)\n\t\tprintf(\"xl%d: command never completed!\\n\", sc->xl_unit);\n#endif\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_DOWN_STALL"
          ],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "cur_tx->xl_mbuf"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "cur_tx->xl_ptr"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xl_encap",
          "args": [
            "sc",
            "cur_tx",
            "m_head"
          ],
          "line": 1647
        },
        "resolved": true,
        "details": {
          "function_name": "xl_encap_90xB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "1731-1766",
          "snippet": "int xl_encap_90xB(sc, c, m_head)\n\tstruct xl_softc *sc;\n\tstruct xl_chain *c;\n\tstruct mbuf *m_head;\n{\n\tint frag = 0;\n\tstruct xl_frag *f = NULL;\n\tstruct mbuf *m;\n\tstruct xl_list *d;\n\n\t/*\n\t * Start packing the mbufs in this chain into\n\t * the fragment pointers. Stop when we run out\n\t * of fragments or hit the end of the mbuf chain.\n\t */\n\td = c->xl_ptr;\n\td->xl_status = 0;\n\td->xl_next = 0;\n\n\tfor (m = m_head, frag = 0; m != NULL; m = m->m_next) {\n\t\tif (m->m_len != 0) {\n\t\t\tif (frag == XL_MAXFRAGS)\n\t\t\t\tbreak;\n\t\t\tf = &d->xl_frag[frag];\n\t\t\tf->xl_addr = vtophys(mtod(m, vm_offset_t));\n\t\t\tf->xl_len = m->m_len;\n\t\t\tfrag++;\n\t\t}\n\t}\n\n\tc->xl_mbuf = m_head;\n\tc->xl_ptr->xl_frag[frag - 1].xl_len |= XL_LAST_FRAG;\n\tc->xl_ptr->xl_status = XL_TXSTAT_RND_DEFEAT;\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xl_encap_90xB"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint xl_encap_90xB;\n\nint xl_encap_90xB(sc, c, m_head)\n\tstruct xl_softc *sc;\n\tstruct xl_chain *c;\n\tstruct mbuf *m_head;\n{\n\tint frag = 0;\n\tstruct xl_frag *f = NULL;\n\tstruct mbuf *m;\n\tstruct xl_list *d;\n\n\t/*\n\t * Start packing the mbufs in this chain into\n\t * the fragment pointers. Stop when we run out\n\t * of fragments or hit the end of the mbuf chain.\n\t */\n\td = c->xl_ptr;\n\td->xl_status = 0;\n\td->xl_next = 0;\n\n\tfor (m = m_head, frag = 0; m != NULL; m = m->m_next) {\n\t\tif (m->m_len != 0) {\n\t\t\tif (frag == XL_MAXFRAGS)\n\t\t\t\tbreak;\n\t\t\tf = &d->xl_frag[frag];\n\t\t\tf->xl_addr = vtophys(mtod(m, vm_offset_t));\n\t\t\tf->xl_len = m->m_len;\n\t\t\tfrag++;\n\t\t}\n\t}\n\n\tc->xl_mbuf = m_head;\n\tc->xl_ptr->xl_frag[frag - 1].xl_len |= XL_LAST_FRAG;\n\tc->xl_ptr->xl_status = XL_TXSTAT_RND_DEFEAT;\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "m_head"
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xl_txeof",
          "args": [
            "sc"
          ],
          "line": 1626
        },
        "resolved": true,
        "details": {
          "function_name": "xl_txeof_90xB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "1318-1352",
          "snippet": "void\nxl_txeof_90xB(sc)\n\tstruct xl_softc *sc;\n{\n\tstruct xl_chain *cur_tx = NULL;\n\tstruct ifnet *ifp;\n\tint idx;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tidx = sc->xl_cdata.xl_tx_cons;\n\twhile(idx != sc->xl_cdata.xl_tx_prod) {\n\n\t\tcur_tx = &sc->xl_cdata.xl_tx_chain[idx];\n\n\t\tif (!(cur_tx->xl_ptr->xl_status & XL_TXSTAT_DL_COMPLETE))\n\t\t\tbreak;\n\n\t\tif (cur_tx->xl_mbuf != NULL) {\n\t\t\tm_freem(cur_tx->xl_mbuf);\n\t\t\tcur_tx->xl_mbuf = NULL;\n\t\t}\n\n\t\tifp->if_opackets++;\n\n\t\tsc->xl_cdata.xl_tx_cnt--;\n\t\tXL_INC(idx, XL_TX_LIST_CNT);\n\t\tifp->if_timer = 0;\n\t}\n\n\tsc->xl_cdata.xl_tx_cons = idx;\n\n\tif (cur_tx != NULL)\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void xl_txeof_90xB"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_txeof_90xB;\n\nvoid\nxl_txeof_90xB(sc)\n\tstruct xl_softc *sc;\n{\n\tstruct xl_chain *cur_tx = NULL;\n\tstruct ifnet *ifp;\n\tint idx;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tidx = sc->xl_cdata.xl_tx_cons;\n\twhile(idx != sc->xl_cdata.xl_tx_prod) {\n\n\t\tcur_tx = &sc->xl_cdata.xl_tx_chain[idx];\n\n\t\tif (!(cur_tx->xl_ptr->xl_status & XL_TXSTAT_DL_COMPLETE))\n\t\t\tbreak;\n\n\t\tif (cur_tx->xl_mbuf != NULL) {\n\t\t\tm_freem(cur_tx->xl_mbuf);\n\t\t\tcur_tx->xl_mbuf = NULL;\n\t\t}\n\n\t\tifp->if_opackets++;\n\n\t\tsc->xl_cdata.xl_tx_cnt--;\n\t\tXL_INC(idx, XL_TX_LIST_CNT);\n\t\tifp->if_timer = 0;\n\t}\n\n\tsc->xl_cdata.xl_tx_cons = idx;\n\n\tif (cur_tx != NULL)\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xl_txeoc",
          "args": [
            "sc"
          ],
          "line": 1625
        },
        "resolved": true,
        "details": {
          "function_name": "xl_txeoc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "1359-1416",
          "snippet": "void xl_txeoc(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tu_int8_t\t\ttxstat;\n\n\twhile((txstat = CSR_READ_1(sc, XL_TX_STATUS))) {\n\t\tif (txstat & XL_TXSTATUS_UNDERRUN ||\n\t\t\ttxstat & XL_TXSTATUS_JABBER ||\n\t\t\ttxstat & XL_TXSTATUS_RECLAIM) {\n\t\t\tprintf(\"xl%d: transmission error: %x\\n\",\n\t\t\t\t\t\tsc->xl_unit, txstat);\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\t\t\txl_wait(sc);\n\t\t\tif (sc->xl_type == XL_TYPE_905B) {\n\t\t\t\tint i;\n\t\t\t\tstruct xl_chain *c;\n\t\t\t\ti = sc->xl_cdata.xl_tx_cons;\n\t\t\t\tc = &sc->xl_cdata.xl_tx_chain[i];\n\t\t\t\tCSR_WRITE_4(sc, XL_DOWNLIST_PTR, c->xl_phys);\n\t\t\t\tCSR_WRITE_1(sc, XL_DOWN_POLL, 64);\n\t\t\t} else {\n\t\t\t\tif (sc->xl_cdata.xl_tx_head != NULL)\n\t\t\t\t\tCSR_WRITE_4(sc, XL_DOWNLIST_PTR,\n\t\t\t\t\t    vtophys(sc->xl_cdata.xl_tx_head->xl_ptr));\n\t\t\t}\n\t\t\t/*\n\t\t\t * Remember to set this for the\n\t\t\t * first generation 3c90X chips.\n\t\t\t */\n\t\t\tCSR_WRITE_1(sc, XL_TX_FREETHRESH, XL_PACKET_SIZE >> 8);\n\t\t\tif (txstat & XL_TXSTATUS_UNDERRUN &&\n\t\t\t    sc->xl_tx_thresh < XL_PACKET_SIZE) {\n\t\t\t\tsc->xl_tx_thresh += XL_MIN_FRAMELEN;\n\t\t\t\tprintf(\"xl%d: tx underrun, increasing tx start\"\n\t\t\t\t    \" threshold to %d\\n\", sc->xl_unit,\n\t\t\t\t    sc->xl_tx_thresh);\n\t\t\t}\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND,\n\t\t\t    XL_CMD_TX_SET_START|sc->xl_tx_thresh);\n\t\t\tif (sc->xl_type == XL_TYPE_905B) {\n\t\t\t\tCSR_WRITE_2(sc, XL_COMMAND,\n\t\t\t\tXL_CMD_SET_TX_RECLAIM|(XL_PACKET_SIZE >> 4));\n\t\t\t}\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_ENABLE);\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_UNSTALL);\n\t\t} else {\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_ENABLE);\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_UNSTALL);\n\t\t}\n\t\t/*\n\t\t * Write an arbitrary byte to the TX_STATUS register\n\t \t * to clear this interrupt/error and advance to the next.\n\t\t */\n\t\tCSR_WRITE_1(sc, XL_TX_STATUS, 0x01);\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void xl_txeoc",
            "void xl_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_txeoc;\nvoid xl_wait;\n\nvoid xl_txeoc(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tu_int8_t\t\ttxstat;\n\n\twhile((txstat = CSR_READ_1(sc, XL_TX_STATUS))) {\n\t\tif (txstat & XL_TXSTATUS_UNDERRUN ||\n\t\t\ttxstat & XL_TXSTATUS_JABBER ||\n\t\t\ttxstat & XL_TXSTATUS_RECLAIM) {\n\t\t\tprintf(\"xl%d: transmission error: %x\\n\",\n\t\t\t\t\t\tsc->xl_unit, txstat);\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\t\t\txl_wait(sc);\n\t\t\tif (sc->xl_type == XL_TYPE_905B) {\n\t\t\t\tint i;\n\t\t\t\tstruct xl_chain *c;\n\t\t\t\ti = sc->xl_cdata.xl_tx_cons;\n\t\t\t\tc = &sc->xl_cdata.xl_tx_chain[i];\n\t\t\t\tCSR_WRITE_4(sc, XL_DOWNLIST_PTR, c->xl_phys);\n\t\t\t\tCSR_WRITE_1(sc, XL_DOWN_POLL, 64);\n\t\t\t} else {\n\t\t\t\tif (sc->xl_cdata.xl_tx_head != NULL)\n\t\t\t\t\tCSR_WRITE_4(sc, XL_DOWNLIST_PTR,\n\t\t\t\t\t    vtophys(sc->xl_cdata.xl_tx_head->xl_ptr));\n\t\t\t}\n\t\t\t/*\n\t\t\t * Remember to set this for the\n\t\t\t * first generation 3c90X chips.\n\t\t\t */\n\t\t\tCSR_WRITE_1(sc, XL_TX_FREETHRESH, XL_PACKET_SIZE >> 8);\n\t\t\tif (txstat & XL_TXSTATUS_UNDERRUN &&\n\t\t\t    sc->xl_tx_thresh < XL_PACKET_SIZE) {\n\t\t\t\tsc->xl_tx_thresh += XL_MIN_FRAMELEN;\n\t\t\t\tprintf(\"xl%d: tx underrun, increasing tx start\"\n\t\t\t\t    \" threshold to %d\\n\", sc->xl_unit,\n\t\t\t\t    sc->xl_tx_thresh);\n\t\t\t}\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND,\n\t\t\t    XL_CMD_TX_SET_START|sc->xl_tx_thresh);\n\t\t\tif (sc->xl_type == XL_TYPE_905B) {\n\t\t\t\tCSR_WRITE_2(sc, XL_COMMAND,\n\t\t\t\tXL_CMD_SET_TX_RECLAIM|(XL_PACKET_SIZE >> 4));\n\t\t\t}\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_ENABLE);\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_UNSTALL);\n\t\t} else {\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_ENABLE);\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_UNSTALL);\n\t\t}\n\t\t/*\n\t\t * Write an arbitrary byte to the TX_STATUS register\n\t \t * to clear this interrupt/error and advance to the next.\n\t\t */\n\t\tCSR_WRITE_1(sc, XL_TX_STATUS, 0x01);\n\t}\n\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint xl_encap;\nvoid xl_rxeof;\nvoid xl_txeof;\nvoid xl_txeoc;\nvoid xl_start;\nvoid xl_wait;\n\nvoid xl_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct xl_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head = NULL;\n\tstruct xl_chain\t\t*prev = NULL, *cur_tx = NULL, *start_tx;\n\n\tsc = ifp->if_softc;\n\n\t/*\n\t * Check for an available queue slot. If there are none,\n\t * punt.\n\t */\n\tif (sc->xl_cdata.xl_tx_free == NULL) {\n\t\txl_txeoc(sc);\n\t\txl_txeof(sc);\n\t\tif (sc->xl_cdata.xl_tx_free == NULL) {\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tstart_tx = sc->xl_cdata.xl_tx_free;\n\n\twhile(sc->xl_cdata.xl_tx_free != NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\t/* Pick a descriptor off the free list. */\n\t\tcur_tx = sc->xl_cdata.xl_tx_free;\n\t\tsc->xl_cdata.xl_tx_free = cur_tx->xl_next;\n\n\t\tcur_tx->xl_next = NULL;\n\n\t\t/* Pack the data into the descriptor. */\n\t\txl_encap(sc, cur_tx, m_head);\n\n\t\t/* Chain it together. */\n\t\tif (prev != NULL) {\n\t\t\tprev->xl_next = cur_tx;\n\t\t\tprev->xl_ptr->xl_next = vtophys(cur_tx->xl_ptr);\n\t\t}\n\t\tprev = cur_tx;\n\n#if NBPFILTER > 0\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, cur_tx->xl_mbuf);\n#endif\n\t}\n\n\t/*\n\t * If there are no packets queued, bail.\n\t */\n\tif (cur_tx == NULL)\n\t\treturn;\n\n\t/*\n\t * Place the request for the upload interrupt\n\t * in the last descriptor in the chain. This way, if\n\t * we're chaining several packets at once, we'll only\n\t * get an interupt once for the whole chain rather than\n\t * once for each packet.\n\t */\n\tcur_tx->xl_ptr->xl_status |= XL_TXSTAT_DL_INTR;\n\n\t/*\n\t * Queue the packets. If the TX channel is clear, update\n\t * the downlist pointer register.\n\t */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_STALL);\n\txl_wait(sc);\n\n\tif (sc->xl_cdata.xl_tx_head != NULL) {\n\t\tsc->xl_cdata.xl_tx_tail->xl_next = start_tx;\n\t\tsc->xl_cdata.xl_tx_tail->xl_ptr->xl_next =\n\t\t\t\t\tvtophys(start_tx->xl_ptr);\n\t\tsc->xl_cdata.xl_tx_tail->xl_ptr->xl_status &=\n\t\t\t\t\t~XL_TXSTAT_DL_INTR;\n\t\tsc->xl_cdata.xl_tx_tail = cur_tx;\n\t} else {\n\t\tsc->xl_cdata.xl_tx_head = start_tx;\n\t\tsc->xl_cdata.xl_tx_tail = cur_tx;\n\t}\n\tif (!CSR_READ_4(sc, XL_DOWNLIST_PTR))\n\t\tCSR_WRITE_4(sc, XL_DOWNLIST_PTR, vtophys(start_tx->xl_ptr));\n\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_UNSTALL);\n\n\tXL_SEL_WIN(7);\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n\n\t/*\n\t * XXX Under certain conditions, usually on slower machines\n\t * where interrupts may be dropped, it's possible for the\n\t * adapter to chew up all the buffers in the receive ring\n\t * and stall, without us being able to do anything about it.\n\t * To guard against this, we need to make a pass over the\n\t * RX queue to make sure there aren't any packets pending.\n\t * Doing it here means we can flush the receive ring at the\n\t * same time the chip is DMAing the transmit descriptors we\n\t * just gave it.\n \t *\n\t * 3Com goes to some lengths to emphasize the Parallel Tasking (tm)\n\t * nature of their chips in all their marketing literature;\n\t * we may as well take advantage of it. :)\n\t */\n\txl_rxeof(sc);\n\n\treturn;\n}"
  },
  {
    "function_name": "xl_encap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
    "lines": "1535-1603",
    "snippet": "int xl_encap(sc, c, m_head)\n\tstruct xl_softc\t\t*sc;\n\tstruct xl_chain\t\t*c;\n\tstruct mbuf\t\t*m_head;\n{\n\tint\t\t\tfrag = 0;\n\tstruct xl_frag\t\t*f = NULL;\n\tint\t\t\ttotal_len;\n\tstruct mbuf\t\t*m;\n\n\t/*\n \t * Start packing the mbufs in this chain into\n\t * the fragment pointers. Stop when we run out\n \t * of fragments or hit the end of the mbuf chain.\n\t */\n\tm = m_head;\n\ttotal_len = 0;\n\n\tfor (m = m_head, frag = 0; m != NULL; m = m->m_next) {\n\t\tif (m->m_len != 0) {\n\t\t\tif (frag == XL_MAXFRAGS)\n\t\t\t\tbreak;\n\t\t\ttotal_len+= m->m_len;\n\t\t\tc->xl_ptr->xl_frag[frag].xl_addr =\n\t\t\t\t\tvtophys(mtod(m, vm_offset_t));\n\t\t\tc->xl_ptr->xl_frag[frag].xl_len = m->m_len;\n\t\t\tfrag++;\n\t\t}\n\t}\n\n\t/*\n\t * Handle special case: we used up all 63 fragments,\n\t * but we have more mbufs left in the chain. Copy the\n\t * data into an mbuf cluster. Note that we don't\n\t * bother clearing the values in the other fragment\n\t * pointers/counters; it wouldn't gain us anything,\n\t * and would waste cycles.\n\t */\n\tif (m != NULL) {\n\t\tstruct mbuf\t\t*m_new = NULL;\n\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL)\n\t\t\treturn(1);\n\t\tif (m_head->m_pkthdr.len > MHLEN) {\n\t\t\tMCLGET(m_new, M_DONTWAIT);\n\t\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\t\tm_freem(m_new);\n\t\t\t\treturn(1);\n\t\t\t}\n\t\t}\n\t\tm_copydata(m_head, 0, m_head->m_pkthdr.len,\t\n\t\t\t\t\tmtod(m_new, caddr_t));\n\t\tm_new->m_pkthdr.len = m_new->m_len = m_head->m_pkthdr.len;\n\t\tm_freem(m_head);\n\t\tm_head = m_new;\n\t\tf = &c->xl_ptr->xl_frag[0];\n\t\tf->xl_addr = vtophys(mtod(m_new, caddr_t));\n\t\tf->xl_len = total_len = m_new->m_len;\n\t\tfrag = 1;\n\t}\n\n\tc->xl_mbuf = m_head;\n\tc->xl_ptr->xl_frag[frag - 1].xl_len |=  XL_LAST_FRAG;\n\tc->xl_ptr->xl_status = total_len;\n\tc->xl_ptr->xl_next = 0;\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int xl_encap"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "mtod(m_new, caddr_t)"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m_new",
            "caddr_t"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m_head"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_copydata",
          "args": [
            "m_head",
            "0",
            "m_head->m_pkthdr.len",
            "mtod(m_new, caddr_t)"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m_new",
            "caddr_t"
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m_new"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCLGET",
          "args": [
            "m_new",
            "M_DONTWAIT"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGETHDR",
          "args": [
            "m_new",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "mtod(m, vm_offset_t)"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "vm_offset_t"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint xl_encap;\n\nint xl_encap(sc, c, m_head)\n\tstruct xl_softc\t\t*sc;\n\tstruct xl_chain\t\t*c;\n\tstruct mbuf\t\t*m_head;\n{\n\tint\t\t\tfrag = 0;\n\tstruct xl_frag\t\t*f = NULL;\n\tint\t\t\ttotal_len;\n\tstruct mbuf\t\t*m;\n\n\t/*\n \t * Start packing the mbufs in this chain into\n\t * the fragment pointers. Stop when we run out\n \t * of fragments or hit the end of the mbuf chain.\n\t */\n\tm = m_head;\n\ttotal_len = 0;\n\n\tfor (m = m_head, frag = 0; m != NULL; m = m->m_next) {\n\t\tif (m->m_len != 0) {\n\t\t\tif (frag == XL_MAXFRAGS)\n\t\t\t\tbreak;\n\t\t\ttotal_len+= m->m_len;\n\t\t\tc->xl_ptr->xl_frag[frag].xl_addr =\n\t\t\t\t\tvtophys(mtod(m, vm_offset_t));\n\t\t\tc->xl_ptr->xl_frag[frag].xl_len = m->m_len;\n\t\t\tfrag++;\n\t\t}\n\t}\n\n\t/*\n\t * Handle special case: we used up all 63 fragments,\n\t * but we have more mbufs left in the chain. Copy the\n\t * data into an mbuf cluster. Note that we don't\n\t * bother clearing the values in the other fragment\n\t * pointers/counters; it wouldn't gain us anything,\n\t * and would waste cycles.\n\t */\n\tif (m != NULL) {\n\t\tstruct mbuf\t\t*m_new = NULL;\n\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL)\n\t\t\treturn(1);\n\t\tif (m_head->m_pkthdr.len > MHLEN) {\n\t\t\tMCLGET(m_new, M_DONTWAIT);\n\t\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\t\tm_freem(m_new);\n\t\t\t\treturn(1);\n\t\t\t}\n\t\t}\n\t\tm_copydata(m_head, 0, m_head->m_pkthdr.len,\t\n\t\t\t\t\tmtod(m_new, caddr_t));\n\t\tm_new->m_pkthdr.len = m_new->m_len = m_head->m_pkthdr.len;\n\t\tm_freem(m_head);\n\t\tm_head = m_new;\n\t\tf = &c->xl_ptr->xl_frag[0];\n\t\tf->xl_addr = vtophys(mtod(m_new, caddr_t));\n\t\tf->xl_len = total_len = m_new->m_len;\n\t\tfrag = 1;\n\t}\n\n\tc->xl_mbuf = m_head;\n\tc->xl_ptr->xl_frag[frag - 1].xl_len |=  XL_LAST_FRAG;\n\tc->xl_ptr->xl_status = total_len;\n\tc->xl_ptr->xl_next = 0;\n\n\treturn(0);\n}"
  },
  {
    "function_name": "xl_stats_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
    "lines": "1480-1529",
    "snippet": "void xl_stats_update(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct xl_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tstruct xl_stats\t\txl_stats;\n\tu_int8_t\t\t*p;\n\tint\t\t\ti;\n\tstruct mii_data\t\t*mii = NULL;\n\n\tbzero((char *)&xl_stats, sizeof(struct xl_stats));\n\n\tsc = xsc;\n\tifp = &sc->arpcom.ac_if;\n\tif (sc->xl_hasmii)\n\t\tmii = &sc->sc_mii;\n\n\tp = (u_int8_t *)&xl_stats;\n\n\t/* Read all the stats registers. */\n\tXL_SEL_WIN(6);\n\n\tfor (i = 0; i < 16; i++)\n\t\t*p++ = CSR_READ_1(sc, XL_W6_CARRIER_LOST + i);\n\n\tifp->if_ierrors += xl_stats.xl_rx_overrun;\n\n\tifp->if_collisions += xl_stats.xl_tx_multi_collision +\n\t\t\t\txl_stats.xl_tx_single_collision +\n\t\t\t\txl_stats.xl_tx_late_collision;\n\n\t/*\n\t * Boomerang and cyclone chips have an extra stats counter\n\t * in window 4 (BadSSD). We have to read this too in order\n\t * to clear out all the stats registers and avoid a statsoflow\n\t * interrupt.\n\t */\n\tXL_SEL_WIN(4);\n\tCSR_READ_1(sc, XL_W4_BADSSD);\n\n\tif (mii != NULL)\n\t\tmii_tick(mii);\n\n\tXL_SEL_WIN(7);\n\n\tif (!sc->xl_stats_no_timeout)\n\t\ttimeout(xl_stats_update, sc, hz);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void xl_stats_update"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "xl_stats_update",
            "sc",
            "hz"
          ],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "wdctimeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "952-980",
          "snippet": "void\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [
            "static void  __wdcerror"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nstatic void  __wdcerror;\n\nvoid\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XL_SEL_WIN",
          "args": [
            "7"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mii_tick",
          "args": [
            "mii"
          ],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "mii_tick",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/mii.c",
          "lines": "192-201",
          "snippet": "void\nmii_tick(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list))\n\t\t(void) (*child->mii_service)(child, mii, MII_TICK);\n}",
          "includes": [
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nvoid\nmii_tick(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list))\n\t\t(void) (*child->mii_service)(child, mii, MII_TICK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_READ_1",
          "args": [
            "sc",
            "XL_W4_BADSSD"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XL_SEL_WIN",
          "args": [
            "4"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_1",
          "args": [
            "sc",
            "XL_W6_CARRIER_LOST + i"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XL_SEL_WIN",
          "args": [
            "6"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)&xl_stats",
            "sizeof(struct xl_stats)"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_stats_update;\n\nvoid xl_stats_update(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct xl_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tstruct xl_stats\t\txl_stats;\n\tu_int8_t\t\t*p;\n\tint\t\t\ti;\n\tstruct mii_data\t\t*mii = NULL;\n\n\tbzero((char *)&xl_stats, sizeof(struct xl_stats));\n\n\tsc = xsc;\n\tifp = &sc->arpcom.ac_if;\n\tif (sc->xl_hasmii)\n\t\tmii = &sc->sc_mii;\n\n\tp = (u_int8_t *)&xl_stats;\n\n\t/* Read all the stats registers. */\n\tXL_SEL_WIN(6);\n\n\tfor (i = 0; i < 16; i++)\n\t\t*p++ = CSR_READ_1(sc, XL_W6_CARRIER_LOST + i);\n\n\tifp->if_ierrors += xl_stats.xl_rx_overrun;\n\n\tifp->if_collisions += xl_stats.xl_tx_multi_collision +\n\t\t\t\txl_stats.xl_tx_single_collision +\n\t\t\t\txl_stats.xl_tx_late_collision;\n\n\t/*\n\t * Boomerang and cyclone chips have an extra stats counter\n\t * in window 4 (BadSSD). We have to read this too in order\n\t * to clear out all the stats registers and avoid a statsoflow\n\t * interrupt.\n\t */\n\tXL_SEL_WIN(4);\n\tCSR_READ_1(sc, XL_W4_BADSSD);\n\n\tif (mii != NULL)\n\t\tmii_tick(mii);\n\n\tXL_SEL_WIN(7);\n\n\tif (!sc->xl_stats_no_timeout)\n\t\ttimeout(xl_stats_update, sc, hz);\n\n\treturn;\n}"
  },
  {
    "function_name": "xl_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
    "lines": "1418-1478",
    "snippet": "int xl_intr(arg)\n\tvoid\t\t\t*arg;\n{\n\tstruct xl_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tu_int16_t\t\tstatus;\n\tint claimed = 0;\n\n\tsc = arg;\n\tifp = &sc->arpcom.ac_if;\n\n\twhile ((status = CSR_READ_2(sc, XL_STATUS)) & XL_INTRS) {\n\n\t\tclaimed = 1;\n\n\t\tCSR_WRITE_2(sc, XL_COMMAND,\n\t\t    XL_CMD_INTR_ACK|(status & XL_INTRS));\n\n\t\tif (sc->xl_bustype == XL_BUS_CARDBUS)\n\t\t\tbus_space_write_4(sc->xl_funct,sc->xl_funch, 4, 0x8000);\n\n\t\tif (status & XL_STAT_UP_COMPLETE) {\n\t\t\tint curpkts;\n\n\t\t\tcurpkts = ifp->if_ipackets;\n\t\t\txl_rxeof(sc);\n\t\t\tif (curpkts == ifp->if_ipackets) {\n\t\t\t\twhile (xl_rx_resync(sc))\n\t\t\t\t\txl_rxeof(sc);\n\t\t\t}\n\t\t}\n\n\t\tif (status & XL_STAT_DOWN_COMPLETE) {\n\t\t\tif (sc->xl_type == XL_TYPE_905B)\n\t\t\t\txl_txeof_90xB(sc);\n\t\t\telse\n\t\t\t\txl_txeof(sc);\n\t\t}\n\n\t\tif (status & XL_STAT_TX_COMPLETE) {\n\t\t\tifp->if_oerrors++;\n\t\t\txl_txeoc(sc);\n\t\t}\n\n\t\tif (status & XL_STAT_ADFAIL) {\n\t\t\txl_reset(sc, 0);\n\t\t\txl_init(sc);\n\t\t}\n\n\t\tif (status & XL_STAT_STATSOFLOW) {\n\t\t\tsc->xl_stats_no_timeout = 1;\n\t\t\txl_stats_update(sc);\n\t\t\tsc->xl_stats_no_timeout = 0;\n\t\t}\n\t}\n\n\tif (ifp->if_snd.ifq_head != NULL)\n\t\t(*ifp->if_start)(ifp);\n\n\treturn (claimed);\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void xl_stats_update",
      "void xl_rxeof",
      "int xl_rx_resync",
      "void xl_txeof",
      "void xl_txeof_90xB",
      "void xl_txeoc",
      "int xl_intr",
      "void xl_init",
      "void xl_reset"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "ifp"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xl_stats_update",
          "args": [
            "sc"
          ],
          "line": 1469
        },
        "resolved": true,
        "details": {
          "function_name": "xl_stats_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "1480-1529",
          "snippet": "void xl_stats_update(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct xl_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tstruct xl_stats\t\txl_stats;\n\tu_int8_t\t\t*p;\n\tint\t\t\ti;\n\tstruct mii_data\t\t*mii = NULL;\n\n\tbzero((char *)&xl_stats, sizeof(struct xl_stats));\n\n\tsc = xsc;\n\tifp = &sc->arpcom.ac_if;\n\tif (sc->xl_hasmii)\n\t\tmii = &sc->sc_mii;\n\n\tp = (u_int8_t *)&xl_stats;\n\n\t/* Read all the stats registers. */\n\tXL_SEL_WIN(6);\n\n\tfor (i = 0; i < 16; i++)\n\t\t*p++ = CSR_READ_1(sc, XL_W6_CARRIER_LOST + i);\n\n\tifp->if_ierrors += xl_stats.xl_rx_overrun;\n\n\tifp->if_collisions += xl_stats.xl_tx_multi_collision +\n\t\t\t\txl_stats.xl_tx_single_collision +\n\t\t\t\txl_stats.xl_tx_late_collision;\n\n\t/*\n\t * Boomerang and cyclone chips have an extra stats counter\n\t * in window 4 (BadSSD). We have to read this too in order\n\t * to clear out all the stats registers and avoid a statsoflow\n\t * interrupt.\n\t */\n\tXL_SEL_WIN(4);\n\tCSR_READ_1(sc, XL_W4_BADSSD);\n\n\tif (mii != NULL)\n\t\tmii_tick(mii);\n\n\tXL_SEL_WIN(7);\n\n\tif (!sc->xl_stats_no_timeout)\n\t\ttimeout(xl_stats_update, sc, hz);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void xl_stats_update"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_stats_update;\n\nvoid xl_stats_update(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct xl_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tstruct xl_stats\t\txl_stats;\n\tu_int8_t\t\t*p;\n\tint\t\t\ti;\n\tstruct mii_data\t\t*mii = NULL;\n\n\tbzero((char *)&xl_stats, sizeof(struct xl_stats));\n\n\tsc = xsc;\n\tifp = &sc->arpcom.ac_if;\n\tif (sc->xl_hasmii)\n\t\tmii = &sc->sc_mii;\n\n\tp = (u_int8_t *)&xl_stats;\n\n\t/* Read all the stats registers. */\n\tXL_SEL_WIN(6);\n\n\tfor (i = 0; i < 16; i++)\n\t\t*p++ = CSR_READ_1(sc, XL_W6_CARRIER_LOST + i);\n\n\tifp->if_ierrors += xl_stats.xl_rx_overrun;\n\n\tifp->if_collisions += xl_stats.xl_tx_multi_collision +\n\t\t\t\txl_stats.xl_tx_single_collision +\n\t\t\t\txl_stats.xl_tx_late_collision;\n\n\t/*\n\t * Boomerang and cyclone chips have an extra stats counter\n\t * in window 4 (BadSSD). We have to read this too in order\n\t * to clear out all the stats registers and avoid a statsoflow\n\t * interrupt.\n\t */\n\tXL_SEL_WIN(4);\n\tCSR_READ_1(sc, XL_W4_BADSSD);\n\n\tif (mii != NULL)\n\t\tmii_tick(mii);\n\n\tXL_SEL_WIN(7);\n\n\tif (!sc->xl_stats_no_timeout)\n\t\ttimeout(xl_stats_update, sc, hz);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xl_init",
          "args": [
            "sc"
          ],
          "line": 1464
        },
        "resolved": true,
        "details": {
          "function_name": "xl_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "1844-2047",
          "snippet": "void xl_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct xl_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts, i;\n\tu_int16_t\t\trxfilt = 0;\n\tstruct mii_data\t\t*mii = NULL;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\txl_stop(sc);\n\n\tif (sc->xl_hasmii)\n\t\tmii = &sc->sc_mii;\n\n\tif (mii == NULL) {\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_RESET);\n\t\txl_wait(sc);\n\t}\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\txl_wait(sc);\n\tDELAY(10000);\n\n\n\t/* Init our MAC address */\n\tXL_SEL_WIN(2);\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++) {\n\t\tCSR_WRITE_1(sc, XL_W2_STATION_ADDR_LO + i,\n\t\t\t\tsc->arpcom.ac_enaddr[i]);\n\t}\n\n\t/* Clear the station mask. */\n\tfor (i = 0; i < 3; i++)\n\t\tCSR_WRITE_2(sc, XL_W2_STATION_MASK_LO + (i * 2), 0);\n#ifdef notdef\n\t/* Reset TX and RX. */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_RESET);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\txl_wait(sc);\n#endif\n\t/* Init circular RX list. */\n\tif (xl_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"xl%d: initialization failed: no \"\n\t\t\t\"memory for rx buffers\\n\", sc->xl_unit);\n\t\txl_stop(sc);\n\t\treturn;\n\t}\n\n\t/* Init TX descriptors. */\n\tif (sc->xl_type == XL_TYPE_905B)\n\t\txl_list_tx_init_90xB(sc);\n\telse\n\t\txl_list_tx_init(sc);\n\n\t/*\n\t * Set the TX freethresh value.\n\t * Note that this has no effect on 3c905B \"cyclone\"\n\t * cards but is required for 3c900/3c905 \"boomerang\"\n\t * cards in order to enable the download engine.\n\t */\n\tCSR_WRITE_1(sc, XL_TX_FREETHRESH, XL_PACKET_SIZE >> 8);\n\n\t/* Set the TX start threshold for best performance. */\n\tsc->xl_tx_thresh = XL_MIN_FRAMELEN;\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_SET_START|sc->xl_tx_thresh);\n\n\t/*\n\t * If this is a 3c905B, also set the tx reclaim threshold.\n\t * This helps cut down on the number of tx reclaim errors\n\t * that could happen on a busy network. The chip multiplies\n\t * the register value by 16 to obtain the actual threshold\n\t * in bytes, so we divide by 16 when setting the value here.\n\t * The existing threshold value can be examined by reading\n\t * the register at offset 9 in window 5.\n\t */\n\tif (sc->xl_type == XL_TYPE_905B) {\n\t\tCSR_WRITE_2(sc, XL_COMMAND,\n\t\t    XL_CMD_SET_TX_RECLAIM|(XL_PACKET_SIZE >> 4));\n\t}\n\n\t/* Set RX filter bits. */\n\tXL_SEL_WIN(5);\n\trxfilt = CSR_READ_1(sc, XL_W5_RX_FILTER);\n\n\t/* Set the individual bit to receive frames for this host only. */\n\trxfilt |= XL_RXFILTER_INDIVIDUAL;\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\trxfilt |= XL_RXFILTER_ALLFRAMES;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t} else {\n\t\trxfilt &= ~XL_RXFILTER_ALLFRAMES;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t}\n\n\t/*\n\t * Set capture broadcast bit to capture broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\trxfilt |= XL_RXFILTER_BROADCAST;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t} else {\n\t\trxfilt &= ~XL_RXFILTER_BROADCAST;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t}\n\n\t/*\n\t * Program the multicast filter, if necessary.\n\t */\n\tif (sc->xl_type == XL_TYPE_905B)\n\t\txl_setmulti_hash(sc);\n\telse\n\t\txl_setmulti(sc);\n\n\t/*\n\t * Load the address of the RX list. We have to\n\t * stall the upload engine before we can manipulate\n\t * the uplist pointer register, then unstall it when\n\t * we're finished. We also have to wait for the\n\t * stall command to complete before proceeding.\n\t * Note that we have to do this after any RX resets\n\t * have completed since the uplist register is cleared\n\t * by a reset.\n\t */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_UP_STALL);\n\txl_wait(sc);\n\tCSR_WRITE_4(sc, XL_UPLIST_PTR, vtophys(&sc->xl_ldata->xl_rx_list[0]));\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_UP_UNSTALL);\n\txl_wait(sc);\n\n\tif (sc->xl_type == XL_TYPE_905B) {\n\t\t/* Set polling interval */\n\t\tCSR_WRITE_1(sc, XL_DOWN_POLL, 64);\n\t\t/* Load the address of the TX list */\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_STALL);\n\t\txl_wait(sc);\n\t\tCSR_WRITE_4(sc, XL_DOWNLIST_PTR,\n\t\t    vtophys(&sc->xl_ldata->xl_tx_list[0]));\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_UNSTALL);\n\t\txl_wait(sc);\n\t}\n\n\t/*\n\t * If the coax transceiver is on, make sure to enable\n\t * the DC-DC converter.\n \t */\n\tXL_SEL_WIN(3);\n\tif (sc->xl_xcvr == XL_XCVR_COAX)\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_START);\n\telse\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_STOP);\n\n\t/* Clear out the stats counters. */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STATS_DISABLE);\n\tsc->xl_stats_no_timeout = 1;\n\txl_stats_update(sc);\n\tsc->xl_stats_no_timeout = 0;\n\tXL_SEL_WIN(4);\n\tCSR_WRITE_2(sc, XL_W4_NET_DIAG, XL_NETDIAG_UPPER_BYTES_ENABLE);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STATS_ENABLE);\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ACK|0xFF);\n\n\tif (sc->xl_bustype == XL_BUS_CARDBUS)\n\t\tbus_space_write_4(sc->xl_funct, sc->xl_funch, 4, 0x8000);\n\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STAT_ENB|XL_INTRS);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ENB|XL_INTRS);\n\n\t/* Set the RX early threshold */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_THRESH|(XL_PACKET_SIZE >>2));\n\tCSR_WRITE_2(sc, XL_DMACTL, XL_DMACTL_UP_RX_EARLY);\n\n\t/* Enable receiver and transmitter. */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_ENABLE);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_ENABLE);\n\txl_wait(sc);\n\n\t/* Restore state of BMCR */\n\tif (mii != NULL)\n\t\tmii_mediachg(mii);\n\n\t/* Select window 7 for normal operations. */\n\tXL_SEL_WIN(7);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\ttimeout(xl_stats_update, sc, hz);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void xl_stats_update",
            "void xl_init",
            "void xl_stop",
            "void xl_setmulti",
            "void xl_setmulti_hash",
            "int xl_list_rx_init",
            "int xl_list_tx_init",
            "int xl_list_tx_init_90xB",
            "void xl_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_stats_update;\nvoid xl_init;\nvoid xl_stop;\nvoid xl_setmulti;\nvoid xl_setmulti_hash;\nint xl_list_rx_init;\nint xl_list_tx_init;\nint xl_list_tx_init_90xB;\nvoid xl_wait;\n\nvoid xl_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct xl_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tint\t\t\ts, i;\n\tu_int16_t\t\trxfilt = 0;\n\tstruct mii_data\t\t*mii = NULL;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\txl_stop(sc);\n\n\tif (sc->xl_hasmii)\n\t\tmii = &sc->sc_mii;\n\n\tif (mii == NULL) {\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_RESET);\n\t\txl_wait(sc);\n\t}\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\txl_wait(sc);\n\tDELAY(10000);\n\n\n\t/* Init our MAC address */\n\tXL_SEL_WIN(2);\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++) {\n\t\tCSR_WRITE_1(sc, XL_W2_STATION_ADDR_LO + i,\n\t\t\t\tsc->arpcom.ac_enaddr[i]);\n\t}\n\n\t/* Clear the station mask. */\n\tfor (i = 0; i < 3; i++)\n\t\tCSR_WRITE_2(sc, XL_W2_STATION_MASK_LO + (i * 2), 0);\n#ifdef notdef\n\t/* Reset TX and RX. */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_RESET);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\txl_wait(sc);\n#endif\n\t/* Init circular RX list. */\n\tif (xl_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"xl%d: initialization failed: no \"\n\t\t\t\"memory for rx buffers\\n\", sc->xl_unit);\n\t\txl_stop(sc);\n\t\treturn;\n\t}\n\n\t/* Init TX descriptors. */\n\tif (sc->xl_type == XL_TYPE_905B)\n\t\txl_list_tx_init_90xB(sc);\n\telse\n\t\txl_list_tx_init(sc);\n\n\t/*\n\t * Set the TX freethresh value.\n\t * Note that this has no effect on 3c905B \"cyclone\"\n\t * cards but is required for 3c900/3c905 \"boomerang\"\n\t * cards in order to enable the download engine.\n\t */\n\tCSR_WRITE_1(sc, XL_TX_FREETHRESH, XL_PACKET_SIZE >> 8);\n\n\t/* Set the TX start threshold for best performance. */\n\tsc->xl_tx_thresh = XL_MIN_FRAMELEN;\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_SET_START|sc->xl_tx_thresh);\n\n\t/*\n\t * If this is a 3c905B, also set the tx reclaim threshold.\n\t * This helps cut down on the number of tx reclaim errors\n\t * that could happen on a busy network. The chip multiplies\n\t * the register value by 16 to obtain the actual threshold\n\t * in bytes, so we divide by 16 when setting the value here.\n\t * The existing threshold value can be examined by reading\n\t * the register at offset 9 in window 5.\n\t */\n\tif (sc->xl_type == XL_TYPE_905B) {\n\t\tCSR_WRITE_2(sc, XL_COMMAND,\n\t\t    XL_CMD_SET_TX_RECLAIM|(XL_PACKET_SIZE >> 4));\n\t}\n\n\t/* Set RX filter bits. */\n\tXL_SEL_WIN(5);\n\trxfilt = CSR_READ_1(sc, XL_W5_RX_FILTER);\n\n\t/* Set the individual bit to receive frames for this host only. */\n\trxfilt |= XL_RXFILTER_INDIVIDUAL;\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\trxfilt |= XL_RXFILTER_ALLFRAMES;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t} else {\n\t\trxfilt &= ~XL_RXFILTER_ALLFRAMES;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t}\n\n\t/*\n\t * Set capture broadcast bit to capture broadcast frames.\n\t */\n\tif (ifp->if_flags & IFF_BROADCAST) {\n\t\trxfilt |= XL_RXFILTER_BROADCAST;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t} else {\n\t\trxfilt &= ~XL_RXFILTER_BROADCAST;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t}\n\n\t/*\n\t * Program the multicast filter, if necessary.\n\t */\n\tif (sc->xl_type == XL_TYPE_905B)\n\t\txl_setmulti_hash(sc);\n\telse\n\t\txl_setmulti(sc);\n\n\t/*\n\t * Load the address of the RX list. We have to\n\t * stall the upload engine before we can manipulate\n\t * the uplist pointer register, then unstall it when\n\t * we're finished. We also have to wait for the\n\t * stall command to complete before proceeding.\n\t * Note that we have to do this after any RX resets\n\t * have completed since the uplist register is cleared\n\t * by a reset.\n\t */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_UP_STALL);\n\txl_wait(sc);\n\tCSR_WRITE_4(sc, XL_UPLIST_PTR, vtophys(&sc->xl_ldata->xl_rx_list[0]));\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_UP_UNSTALL);\n\txl_wait(sc);\n\n\tif (sc->xl_type == XL_TYPE_905B) {\n\t\t/* Set polling interval */\n\t\tCSR_WRITE_1(sc, XL_DOWN_POLL, 64);\n\t\t/* Load the address of the TX list */\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_STALL);\n\t\txl_wait(sc);\n\t\tCSR_WRITE_4(sc, XL_DOWNLIST_PTR,\n\t\t    vtophys(&sc->xl_ldata->xl_tx_list[0]));\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_UNSTALL);\n\t\txl_wait(sc);\n\t}\n\n\t/*\n\t * If the coax transceiver is on, make sure to enable\n\t * the DC-DC converter.\n \t */\n\tXL_SEL_WIN(3);\n\tif (sc->xl_xcvr == XL_XCVR_COAX)\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_START);\n\telse\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_STOP);\n\n\t/* Clear out the stats counters. */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STATS_DISABLE);\n\tsc->xl_stats_no_timeout = 1;\n\txl_stats_update(sc);\n\tsc->xl_stats_no_timeout = 0;\n\tXL_SEL_WIN(4);\n\tCSR_WRITE_2(sc, XL_W4_NET_DIAG, XL_NETDIAG_UPPER_BYTES_ENABLE);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STATS_ENABLE);\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ACK|0xFF);\n\n\tif (sc->xl_bustype == XL_BUS_CARDBUS)\n\t\tbus_space_write_4(sc->xl_funct, sc->xl_funch, 4, 0x8000);\n\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_STAT_ENB|XL_INTRS);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_INTR_ENB|XL_INTRS);\n\n\t/* Set the RX early threshold */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_THRESH|(XL_PACKET_SIZE >>2));\n\tCSR_WRITE_2(sc, XL_DMACTL, XL_DMACTL_UP_RX_EARLY);\n\n\t/* Enable receiver and transmitter. */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_ENABLE);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_ENABLE);\n\txl_wait(sc);\n\n\t/* Restore state of BMCR */\n\tif (mii != NULL)\n\t\tmii_mediachg(mii);\n\n\t/* Select window 7 for normal operations. */\n\tXL_SEL_WIN(7);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\ttimeout(xl_stats_update, sc, hz);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xl_reset",
          "args": [
            "sc",
            "0"
          ],
          "line": 1463
        },
        "resolved": true,
        "details": {
          "function_name": "xl_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "831-860",
          "snippet": "void xl_reset(sc, hard)\n\tstruct xl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tXL_SEL_WIN(0);\n\tif (hard)\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RESET);\n\telse\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RESET | 0x0010);\n\txl_wait(sc);\n\n\tfor (i = 0; i < XL_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(CSR_READ_2(sc, XL_STATUS) & XL_STAT_CMDBUSY))\n\t\t\tbreak;\n\t}\n\n\tDELAY(100000);\n\n\t/* Reset TX and RX. */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_RESET);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\txl_wait(sc);\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tDELAY(100000);\n        return;\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void xl_reset",
            "void xl_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_reset;\nvoid xl_wait;\n\nvoid xl_reset(sc, hard)\n\tstruct xl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tXL_SEL_WIN(0);\n\tif (hard)\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RESET);\n\telse\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RESET | 0x0010);\n\txl_wait(sc);\n\n\tfor (i = 0; i < XL_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(CSR_READ_2(sc, XL_STATUS) & XL_STAT_CMDBUSY))\n\t\t\tbreak;\n\t}\n\n\tDELAY(100000);\n\n\t/* Reset TX and RX. */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_RESET);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\txl_wait(sc);\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tDELAY(100000);\n        return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xl_txeoc",
          "args": [
            "sc"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "xl_txeoc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "1359-1416",
          "snippet": "void xl_txeoc(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tu_int8_t\t\ttxstat;\n\n\twhile((txstat = CSR_READ_1(sc, XL_TX_STATUS))) {\n\t\tif (txstat & XL_TXSTATUS_UNDERRUN ||\n\t\t\ttxstat & XL_TXSTATUS_JABBER ||\n\t\t\ttxstat & XL_TXSTATUS_RECLAIM) {\n\t\t\tprintf(\"xl%d: transmission error: %x\\n\",\n\t\t\t\t\t\tsc->xl_unit, txstat);\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\t\t\txl_wait(sc);\n\t\t\tif (sc->xl_type == XL_TYPE_905B) {\n\t\t\t\tint i;\n\t\t\t\tstruct xl_chain *c;\n\t\t\t\ti = sc->xl_cdata.xl_tx_cons;\n\t\t\t\tc = &sc->xl_cdata.xl_tx_chain[i];\n\t\t\t\tCSR_WRITE_4(sc, XL_DOWNLIST_PTR, c->xl_phys);\n\t\t\t\tCSR_WRITE_1(sc, XL_DOWN_POLL, 64);\n\t\t\t} else {\n\t\t\t\tif (sc->xl_cdata.xl_tx_head != NULL)\n\t\t\t\t\tCSR_WRITE_4(sc, XL_DOWNLIST_PTR,\n\t\t\t\t\t    vtophys(sc->xl_cdata.xl_tx_head->xl_ptr));\n\t\t\t}\n\t\t\t/*\n\t\t\t * Remember to set this for the\n\t\t\t * first generation 3c90X chips.\n\t\t\t */\n\t\t\tCSR_WRITE_1(sc, XL_TX_FREETHRESH, XL_PACKET_SIZE >> 8);\n\t\t\tif (txstat & XL_TXSTATUS_UNDERRUN &&\n\t\t\t    sc->xl_tx_thresh < XL_PACKET_SIZE) {\n\t\t\t\tsc->xl_tx_thresh += XL_MIN_FRAMELEN;\n\t\t\t\tprintf(\"xl%d: tx underrun, increasing tx start\"\n\t\t\t\t    \" threshold to %d\\n\", sc->xl_unit,\n\t\t\t\t    sc->xl_tx_thresh);\n\t\t\t}\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND,\n\t\t\t    XL_CMD_TX_SET_START|sc->xl_tx_thresh);\n\t\t\tif (sc->xl_type == XL_TYPE_905B) {\n\t\t\t\tCSR_WRITE_2(sc, XL_COMMAND,\n\t\t\t\tXL_CMD_SET_TX_RECLAIM|(XL_PACKET_SIZE >> 4));\n\t\t\t}\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_ENABLE);\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_UNSTALL);\n\t\t} else {\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_ENABLE);\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_UNSTALL);\n\t\t}\n\t\t/*\n\t\t * Write an arbitrary byte to the TX_STATUS register\n\t \t * to clear this interrupt/error and advance to the next.\n\t\t */\n\t\tCSR_WRITE_1(sc, XL_TX_STATUS, 0x01);\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void xl_txeoc",
            "void xl_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_txeoc;\nvoid xl_wait;\n\nvoid xl_txeoc(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tu_int8_t\t\ttxstat;\n\n\twhile((txstat = CSR_READ_1(sc, XL_TX_STATUS))) {\n\t\tif (txstat & XL_TXSTATUS_UNDERRUN ||\n\t\t\ttxstat & XL_TXSTATUS_JABBER ||\n\t\t\ttxstat & XL_TXSTATUS_RECLAIM) {\n\t\t\tprintf(\"xl%d: transmission error: %x\\n\",\n\t\t\t\t\t\tsc->xl_unit, txstat);\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\t\t\txl_wait(sc);\n\t\t\tif (sc->xl_type == XL_TYPE_905B) {\n\t\t\t\tint i;\n\t\t\t\tstruct xl_chain *c;\n\t\t\t\ti = sc->xl_cdata.xl_tx_cons;\n\t\t\t\tc = &sc->xl_cdata.xl_tx_chain[i];\n\t\t\t\tCSR_WRITE_4(sc, XL_DOWNLIST_PTR, c->xl_phys);\n\t\t\t\tCSR_WRITE_1(sc, XL_DOWN_POLL, 64);\n\t\t\t} else {\n\t\t\t\tif (sc->xl_cdata.xl_tx_head != NULL)\n\t\t\t\t\tCSR_WRITE_4(sc, XL_DOWNLIST_PTR,\n\t\t\t\t\t    vtophys(sc->xl_cdata.xl_tx_head->xl_ptr));\n\t\t\t}\n\t\t\t/*\n\t\t\t * Remember to set this for the\n\t\t\t * first generation 3c90X chips.\n\t\t\t */\n\t\t\tCSR_WRITE_1(sc, XL_TX_FREETHRESH, XL_PACKET_SIZE >> 8);\n\t\t\tif (txstat & XL_TXSTATUS_UNDERRUN &&\n\t\t\t    sc->xl_tx_thresh < XL_PACKET_SIZE) {\n\t\t\t\tsc->xl_tx_thresh += XL_MIN_FRAMELEN;\n\t\t\t\tprintf(\"xl%d: tx underrun, increasing tx start\"\n\t\t\t\t    \" threshold to %d\\n\", sc->xl_unit,\n\t\t\t\t    sc->xl_tx_thresh);\n\t\t\t}\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND,\n\t\t\t    XL_CMD_TX_SET_START|sc->xl_tx_thresh);\n\t\t\tif (sc->xl_type == XL_TYPE_905B) {\n\t\t\t\tCSR_WRITE_2(sc, XL_COMMAND,\n\t\t\t\tXL_CMD_SET_TX_RECLAIM|(XL_PACKET_SIZE >> 4));\n\t\t\t}\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_ENABLE);\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_UNSTALL);\n\t\t} else {\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_ENABLE);\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_UNSTALL);\n\t\t}\n\t\t/*\n\t\t * Write an arbitrary byte to the TX_STATUS register\n\t \t * to clear this interrupt/error and advance to the next.\n\t\t */\n\t\tCSR_WRITE_1(sc, XL_TX_STATUS, 0x01);\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xl_txeof",
          "args": [
            "sc"
          ],
          "line": 1454
        },
        "resolved": true,
        "details": {
          "function_name": "xl_txeof_90xB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "1318-1352",
          "snippet": "void\nxl_txeof_90xB(sc)\n\tstruct xl_softc *sc;\n{\n\tstruct xl_chain *cur_tx = NULL;\n\tstruct ifnet *ifp;\n\tint idx;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tidx = sc->xl_cdata.xl_tx_cons;\n\twhile(idx != sc->xl_cdata.xl_tx_prod) {\n\n\t\tcur_tx = &sc->xl_cdata.xl_tx_chain[idx];\n\n\t\tif (!(cur_tx->xl_ptr->xl_status & XL_TXSTAT_DL_COMPLETE))\n\t\t\tbreak;\n\n\t\tif (cur_tx->xl_mbuf != NULL) {\n\t\t\tm_freem(cur_tx->xl_mbuf);\n\t\t\tcur_tx->xl_mbuf = NULL;\n\t\t}\n\n\t\tifp->if_opackets++;\n\n\t\tsc->xl_cdata.xl_tx_cnt--;\n\t\tXL_INC(idx, XL_TX_LIST_CNT);\n\t\tifp->if_timer = 0;\n\t}\n\n\tsc->xl_cdata.xl_tx_cons = idx;\n\n\tif (cur_tx != NULL)\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void xl_txeof_90xB"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_txeof_90xB;\n\nvoid\nxl_txeof_90xB(sc)\n\tstruct xl_softc *sc;\n{\n\tstruct xl_chain *cur_tx = NULL;\n\tstruct ifnet *ifp;\n\tint idx;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tidx = sc->xl_cdata.xl_tx_cons;\n\twhile(idx != sc->xl_cdata.xl_tx_prod) {\n\n\t\tcur_tx = &sc->xl_cdata.xl_tx_chain[idx];\n\n\t\tif (!(cur_tx->xl_ptr->xl_status & XL_TXSTAT_DL_COMPLETE))\n\t\t\tbreak;\n\n\t\tif (cur_tx->xl_mbuf != NULL) {\n\t\t\tm_freem(cur_tx->xl_mbuf);\n\t\t\tcur_tx->xl_mbuf = NULL;\n\t\t}\n\n\t\tifp->if_opackets++;\n\n\t\tsc->xl_cdata.xl_tx_cnt--;\n\t\tXL_INC(idx, XL_TX_LIST_CNT);\n\t\tifp->if_timer = 0;\n\t}\n\n\tsc->xl_cdata.xl_tx_cons = idx;\n\n\tif (cur_tx != NULL)\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xl_rxeof",
          "args": [
            "sc"
          ],
          "line": 1446
        },
        "resolved": true,
        "details": {
          "function_name": "xl_rxeof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "1159-1262",
          "snippet": "void xl_rxeof(sc)\n\tstruct xl_softc\t\t*sc;\n{\n        struct ether_header\t*eh;\n        struct mbuf\t\t*m;\n        struct ifnet\t\t*ifp;\n\tstruct xl_chain_onefrag\t*cur_rx;\n\tint\t\t\ttotal_len = 0;\n\tu_int16_t\t\trxstat;\n\n\tifp = &sc->arpcom.ac_if;\n\nagain:\n\n\twhile((rxstat = sc->xl_cdata.xl_rx_head->xl_ptr->xl_status)) {\n\t\tcur_rx = sc->xl_cdata.xl_rx_head;\n\t\tsc->xl_cdata.xl_rx_head = cur_rx->xl_next;\n\n\t\t/*\n\t\t * If an error occurs, update stats, clear the\n\t\t * status word and leave the mbuf cluster in place:\n\t\t * it should simply get re-used next time this descriptor\n\t \t * comes up in the ring.\n\t\t */\n\t\tif (rxstat & XL_RXSTAT_UP_ERROR) {\n\t\t\tifp->if_ierrors++;\n\t\t\tcur_rx->xl_ptr->xl_status = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If there error bit was not set, the upload complete\n\t\t * bit should be set which means we have a valid packet.\n\t\t * If not, something truly strange has happened.\n\t\t */\n\t\tif (!(rxstat & XL_RXSTAT_UP_CMPLT)) {\n\t\t\tprintf(\"xl%d: bad receive status -- \"\n\t\t\t    \"packet dropped\", sc->xl_unit);\n\t\t\tifp->if_ierrors++;\n\t\t\tcur_rx->xl_ptr->xl_status = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* No errors; receive the packet. */\t\n\t\tm = cur_rx->xl_mbuf;\n\t\ttotal_len = cur_rx->xl_ptr->xl_status & XL_RXSTAT_LENMASK;\n\n\t\t/*\n\t\t * Try to conjure up a new mbuf cluster. If that\n\t\t * fails, it means we have an out of memory condition and\n\t\t * should leave the buffer in place and continue. This will\n\t\t * result in a lost packet, but there's little else we\n\t\t * can do in this situation.\n\t\t */\n\t\tif (xl_newbuf(sc, cur_rx) == ENOBUFS) {\n\t\t\tifp->if_ierrors++;\n\t\t\tcur_rx->xl_ptr->xl_status = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tifp->if_ipackets++;\n\t\teh = mtod(m, struct ether_header *);\n\t\tm->m_pkthdr.rcvif = ifp;\n#if NBPFILTER > 0\n\t\t/*\n\t\t * Handle BPF listeners. Let the BPF user see the packet.\n\t\t */\n\t\tif (ifp->if_bpf) {\n\t\t\tm->m_pkthdr.len = m->m_len = total_len;\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n\t\t}\n#endif\n\t\t/* Remove header from mbuf and pass it on. */\n\t\tm->m_pkthdr.len = m->m_len =\n\t\t\t\ttotal_len - sizeof(struct ether_header);\n\t\tm->m_data += sizeof(struct ether_header);\n\t\tether_input(ifp, eh, m);\n\t}\n\n\t/*\n\t * Handle the 'end of channel' condition. When the upload\n\t * engine hits the end of the RX ring, it will stall. This\n\t * is our cue to flush the RX ring, reload the uplist pointer\n\t * register and unstall the engine.\n\t * XXX This is actually a little goofy. With the ThunderLAN\n\t * chip, you get an interrupt when the receiver hits the end\n\t * of the receive ring, which tells you exactly when you\n\t * you need to reload the ring pointer. Here we have to\n\t * fake it. I'm mad at myself for not being clever enough\n\t * to avoid the use of a goto here.\n\t */\n\tif (CSR_READ_4(sc, XL_UPLIST_PTR) == 0 ||\n\t\tCSR_READ_4(sc, XL_UPLIST_STATUS) & XL_PKTSTAT_UP_STALLED) {\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_UP_STALL);\n\t\txl_wait(sc);\n\t\tCSR_WRITE_4(sc, XL_UPLIST_PTR,\n\t\t\tvtophys(&sc->xl_ldata->xl_rx_list[0]));\n\t\tsc->xl_cdata.xl_rx_head = &sc->xl_cdata.xl_rx_chain[0];\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_UP_UNSTALL);\n\t\tgoto again;\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xl_newbuf",
            "void xl_rxeof",
            "void xl_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint xl_newbuf;\nvoid xl_rxeof;\nvoid xl_wait;\n\nvoid xl_rxeof(sc)\n\tstruct xl_softc\t\t*sc;\n{\n        struct ether_header\t*eh;\n        struct mbuf\t\t*m;\n        struct ifnet\t\t*ifp;\n\tstruct xl_chain_onefrag\t*cur_rx;\n\tint\t\t\ttotal_len = 0;\n\tu_int16_t\t\trxstat;\n\n\tifp = &sc->arpcom.ac_if;\n\nagain:\n\n\twhile((rxstat = sc->xl_cdata.xl_rx_head->xl_ptr->xl_status)) {\n\t\tcur_rx = sc->xl_cdata.xl_rx_head;\n\t\tsc->xl_cdata.xl_rx_head = cur_rx->xl_next;\n\n\t\t/*\n\t\t * If an error occurs, update stats, clear the\n\t\t * status word and leave the mbuf cluster in place:\n\t\t * it should simply get re-used next time this descriptor\n\t \t * comes up in the ring.\n\t\t */\n\t\tif (rxstat & XL_RXSTAT_UP_ERROR) {\n\t\t\tifp->if_ierrors++;\n\t\t\tcur_rx->xl_ptr->xl_status = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If there error bit was not set, the upload complete\n\t\t * bit should be set which means we have a valid packet.\n\t\t * If not, something truly strange has happened.\n\t\t */\n\t\tif (!(rxstat & XL_RXSTAT_UP_CMPLT)) {\n\t\t\tprintf(\"xl%d: bad receive status -- \"\n\t\t\t    \"packet dropped\", sc->xl_unit);\n\t\t\tifp->if_ierrors++;\n\t\t\tcur_rx->xl_ptr->xl_status = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* No errors; receive the packet. */\t\n\t\tm = cur_rx->xl_mbuf;\n\t\ttotal_len = cur_rx->xl_ptr->xl_status & XL_RXSTAT_LENMASK;\n\n\t\t/*\n\t\t * Try to conjure up a new mbuf cluster. If that\n\t\t * fails, it means we have an out of memory condition and\n\t\t * should leave the buffer in place and continue. This will\n\t\t * result in a lost packet, but there's little else we\n\t\t * can do in this situation.\n\t\t */\n\t\tif (xl_newbuf(sc, cur_rx) == ENOBUFS) {\n\t\t\tifp->if_ierrors++;\n\t\t\tcur_rx->xl_ptr->xl_status = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tifp->if_ipackets++;\n\t\teh = mtod(m, struct ether_header *);\n\t\tm->m_pkthdr.rcvif = ifp;\n#if NBPFILTER > 0\n\t\t/*\n\t\t * Handle BPF listeners. Let the BPF user see the packet.\n\t\t */\n\t\tif (ifp->if_bpf) {\n\t\t\tm->m_pkthdr.len = m->m_len = total_len;\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n\t\t}\n#endif\n\t\t/* Remove header from mbuf and pass it on. */\n\t\tm->m_pkthdr.len = m->m_len =\n\t\t\t\ttotal_len - sizeof(struct ether_header);\n\t\tm->m_data += sizeof(struct ether_header);\n\t\tether_input(ifp, eh, m);\n\t}\n\n\t/*\n\t * Handle the 'end of channel' condition. When the upload\n\t * engine hits the end of the RX ring, it will stall. This\n\t * is our cue to flush the RX ring, reload the uplist pointer\n\t * register and unstall the engine.\n\t * XXX This is actually a little goofy. With the ThunderLAN\n\t * chip, you get an interrupt when the receiver hits the end\n\t * of the receive ring, which tells you exactly when you\n\t * you need to reload the ring pointer. Here we have to\n\t * fake it. I'm mad at myself for not being clever enough\n\t * to avoid the use of a goto here.\n\t */\n\tif (CSR_READ_4(sc, XL_UPLIST_PTR) == 0 ||\n\t\tCSR_READ_4(sc, XL_UPLIST_STATUS) & XL_PKTSTAT_UP_STALLED) {\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_UP_STALL);\n\t\txl_wait(sc);\n\t\tCSR_WRITE_4(sc, XL_UPLIST_PTR,\n\t\t\tvtophys(&sc->xl_ldata->xl_rx_list[0]));\n\t\tsc->xl_cdata.xl_rx_head = &sc->xl_cdata.xl_rx_chain[0];\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_UP_UNSTALL);\n\t\tgoto again;\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xl_rx_resync",
          "args": [
            "sc"
          ],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "xl_rx_resync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "1133-1153",
          "snippet": "int xl_rx_resync(sc)\n\tstruct xl_softc *sc;\n{\n\tstruct xl_chain_onefrag *pos;\n\tint i;\n\n\tpos = sc->xl_cdata.xl_rx_head;\n\n\tfor (i = 0; i < XL_RX_LIST_CNT; i++) {\n\t\tif (pos->xl_ptr->xl_status)\n\t\t\tbreak;\n\t\tpos = pos->xl_next;\n\t}\n\n\tif (i == XL_RX_LIST_CNT)\n\t\treturn (0);\n\n\tsc->xl_cdata.xl_rx_head = pos;\n\n\treturn (EAGAIN);\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xl_rx_resync"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint xl_rx_resync;\n\nint xl_rx_resync(sc)\n\tstruct xl_softc *sc;\n{\n\tstruct xl_chain_onefrag *pos;\n\tint i;\n\n\tpos = sc->xl_cdata.xl_rx_head;\n\n\tfor (i = 0; i < XL_RX_LIST_CNT; i++) {\n\t\tif (pos->xl_ptr->xl_status)\n\t\t\tbreak;\n\t\tpos = pos->xl_next;\n\t}\n\n\tif (i == XL_RX_LIST_CNT)\n\t\treturn (0);\n\n\tsc->xl_cdata.xl_rx_head = pos;\n\n\treturn (EAGAIN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_4",
          "args": [
            "sc->xl_funct",
            "sc->xl_funch",
            "4",
            "0x8000"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_INTR_ACK|(status & XL_INTRS)"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "XL_STATUS"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_stats_update;\nvoid xl_rxeof;\nint xl_rx_resync;\nvoid xl_txeof;\nvoid xl_txeof_90xB;\nvoid xl_txeoc;\nint xl_intr;\nvoid xl_init;\nvoid xl_reset;\n\nint xl_intr(arg)\n\tvoid\t\t\t*arg;\n{\n\tstruct xl_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tu_int16_t\t\tstatus;\n\tint claimed = 0;\n\n\tsc = arg;\n\tifp = &sc->arpcom.ac_if;\n\n\twhile ((status = CSR_READ_2(sc, XL_STATUS)) & XL_INTRS) {\n\n\t\tclaimed = 1;\n\n\t\tCSR_WRITE_2(sc, XL_COMMAND,\n\t\t    XL_CMD_INTR_ACK|(status & XL_INTRS));\n\n\t\tif (sc->xl_bustype == XL_BUS_CARDBUS)\n\t\t\tbus_space_write_4(sc->xl_funct,sc->xl_funch, 4, 0x8000);\n\n\t\tif (status & XL_STAT_UP_COMPLETE) {\n\t\t\tint curpkts;\n\n\t\t\tcurpkts = ifp->if_ipackets;\n\t\t\txl_rxeof(sc);\n\t\t\tif (curpkts == ifp->if_ipackets) {\n\t\t\t\twhile (xl_rx_resync(sc))\n\t\t\t\t\txl_rxeof(sc);\n\t\t\t}\n\t\t}\n\n\t\tif (status & XL_STAT_DOWN_COMPLETE) {\n\t\t\tif (sc->xl_type == XL_TYPE_905B)\n\t\t\t\txl_txeof_90xB(sc);\n\t\t\telse\n\t\t\t\txl_txeof(sc);\n\t\t}\n\n\t\tif (status & XL_STAT_TX_COMPLETE) {\n\t\t\tifp->if_oerrors++;\n\t\t\txl_txeoc(sc);\n\t\t}\n\n\t\tif (status & XL_STAT_ADFAIL) {\n\t\t\txl_reset(sc, 0);\n\t\t\txl_init(sc);\n\t\t}\n\n\t\tif (status & XL_STAT_STATSOFLOW) {\n\t\t\tsc->xl_stats_no_timeout = 1;\n\t\t\txl_stats_update(sc);\n\t\t\tsc->xl_stats_no_timeout = 0;\n\t\t}\n\t}\n\n\tif (ifp->if_snd.ifq_head != NULL)\n\t\t(*ifp->if_start)(ifp);\n\n\treturn (claimed);\n}"
  },
  {
    "function_name": "xl_txeoc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
    "lines": "1359-1416",
    "snippet": "void xl_txeoc(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tu_int8_t\t\ttxstat;\n\n\twhile((txstat = CSR_READ_1(sc, XL_TX_STATUS))) {\n\t\tif (txstat & XL_TXSTATUS_UNDERRUN ||\n\t\t\ttxstat & XL_TXSTATUS_JABBER ||\n\t\t\ttxstat & XL_TXSTATUS_RECLAIM) {\n\t\t\tprintf(\"xl%d: transmission error: %x\\n\",\n\t\t\t\t\t\tsc->xl_unit, txstat);\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\t\t\txl_wait(sc);\n\t\t\tif (sc->xl_type == XL_TYPE_905B) {\n\t\t\t\tint i;\n\t\t\t\tstruct xl_chain *c;\n\t\t\t\ti = sc->xl_cdata.xl_tx_cons;\n\t\t\t\tc = &sc->xl_cdata.xl_tx_chain[i];\n\t\t\t\tCSR_WRITE_4(sc, XL_DOWNLIST_PTR, c->xl_phys);\n\t\t\t\tCSR_WRITE_1(sc, XL_DOWN_POLL, 64);\n\t\t\t} else {\n\t\t\t\tif (sc->xl_cdata.xl_tx_head != NULL)\n\t\t\t\t\tCSR_WRITE_4(sc, XL_DOWNLIST_PTR,\n\t\t\t\t\t    vtophys(sc->xl_cdata.xl_tx_head->xl_ptr));\n\t\t\t}\n\t\t\t/*\n\t\t\t * Remember to set this for the\n\t\t\t * first generation 3c90X chips.\n\t\t\t */\n\t\t\tCSR_WRITE_1(sc, XL_TX_FREETHRESH, XL_PACKET_SIZE >> 8);\n\t\t\tif (txstat & XL_TXSTATUS_UNDERRUN &&\n\t\t\t    sc->xl_tx_thresh < XL_PACKET_SIZE) {\n\t\t\t\tsc->xl_tx_thresh += XL_MIN_FRAMELEN;\n\t\t\t\tprintf(\"xl%d: tx underrun, increasing tx start\"\n\t\t\t\t    \" threshold to %d\\n\", sc->xl_unit,\n\t\t\t\t    sc->xl_tx_thresh);\n\t\t\t}\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND,\n\t\t\t    XL_CMD_TX_SET_START|sc->xl_tx_thresh);\n\t\t\tif (sc->xl_type == XL_TYPE_905B) {\n\t\t\t\tCSR_WRITE_2(sc, XL_COMMAND,\n\t\t\t\tXL_CMD_SET_TX_RECLAIM|(XL_PACKET_SIZE >> 4));\n\t\t\t}\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_ENABLE);\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_UNSTALL);\n\t\t} else {\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_ENABLE);\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_UNSTALL);\n\t\t}\n\t\t/*\n\t\t * Write an arbitrary byte to the TX_STATUS register\n\t \t * to clear this interrupt/error and advance to the next.\n\t\t */\n\t\tCSR_WRITE_1(sc, XL_TX_STATUS, 0x01);\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void xl_txeoc",
      "void xl_wait"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_1",
          "args": [
            "sc",
            "XL_TX_STATUS",
            "0x01"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_DOWN_UNSTALL"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_TX_ENABLE"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_DOWN_UNSTALL"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_TX_ENABLE"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_SET_TX_RECLAIM|(XL_PACKET_SIZE >> 4)"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_TX_SET_START|sc->xl_tx_thresh"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"xl%d: tx underrun, increasing tx start\"\n\t\t\t\t    \" threshold to %d\\n\"",
            "sc->xl_unit",
            "sc->xl_tx_thresh"
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_1",
          "args": [
            "sc",
            "XL_TX_FREETHRESH",
            "XL_PACKET_SIZE >> 8"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "XL_DOWNLIST_PTR",
            "vtophys(sc->xl_cdata.xl_tx_head->xl_ptr)"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "sc->xl_cdata.xl_tx_head->xl_ptr"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_1",
          "args": [
            "sc",
            "XL_DOWN_POLL",
            "64"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "XL_DOWNLIST_PTR",
            "c->xl_phys"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xl_wait",
          "args": [
            "sc"
          ],
          "line": 1371
        },
        "resolved": true,
        "details": {
          "function_name": "xl_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "200-216",
          "snippet": "void xl_wait(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tfor (i = 0; i < XL_TIMEOUT; i++) {\n\t\tif (!(CSR_READ_2(sc, XL_STATUS) & XL_STAT_CMDBUSY))\n\t\t\tbreak;\n\t}\n\n#ifdef DIAGNOSTIC\n\tif (i == XL_TIMEOUT)\n\t\tprintf(\"xl%d: command never completed!\\n\", sc->xl_unit);\n#endif\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void xl_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_wait;\n\nvoid xl_wait(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tfor (i = 0; i < XL_TIMEOUT; i++) {\n\t\tif (!(CSR_READ_2(sc, XL_STATUS) & XL_STAT_CMDBUSY))\n\t\t\tbreak;\n\t}\n\n#ifdef DIAGNOSTIC\n\tif (i == XL_TIMEOUT)\n\t\tprintf(\"xl%d: command never completed!\\n\", sc->xl_unit);\n#endif\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_TX_RESET"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_1",
          "args": [
            "sc",
            "XL_TX_STATUS"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_txeoc;\nvoid xl_wait;\n\nvoid xl_txeoc(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tu_int8_t\t\ttxstat;\n\n\twhile((txstat = CSR_READ_1(sc, XL_TX_STATUS))) {\n\t\tif (txstat & XL_TXSTATUS_UNDERRUN ||\n\t\t\ttxstat & XL_TXSTATUS_JABBER ||\n\t\t\ttxstat & XL_TXSTATUS_RECLAIM) {\n\t\t\tprintf(\"xl%d: transmission error: %x\\n\",\n\t\t\t\t\t\tsc->xl_unit, txstat);\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\t\t\txl_wait(sc);\n\t\t\tif (sc->xl_type == XL_TYPE_905B) {\n\t\t\t\tint i;\n\t\t\t\tstruct xl_chain *c;\n\t\t\t\ti = sc->xl_cdata.xl_tx_cons;\n\t\t\t\tc = &sc->xl_cdata.xl_tx_chain[i];\n\t\t\t\tCSR_WRITE_4(sc, XL_DOWNLIST_PTR, c->xl_phys);\n\t\t\t\tCSR_WRITE_1(sc, XL_DOWN_POLL, 64);\n\t\t\t} else {\n\t\t\t\tif (sc->xl_cdata.xl_tx_head != NULL)\n\t\t\t\t\tCSR_WRITE_4(sc, XL_DOWNLIST_PTR,\n\t\t\t\t\t    vtophys(sc->xl_cdata.xl_tx_head->xl_ptr));\n\t\t\t}\n\t\t\t/*\n\t\t\t * Remember to set this for the\n\t\t\t * first generation 3c90X chips.\n\t\t\t */\n\t\t\tCSR_WRITE_1(sc, XL_TX_FREETHRESH, XL_PACKET_SIZE >> 8);\n\t\t\tif (txstat & XL_TXSTATUS_UNDERRUN &&\n\t\t\t    sc->xl_tx_thresh < XL_PACKET_SIZE) {\n\t\t\t\tsc->xl_tx_thresh += XL_MIN_FRAMELEN;\n\t\t\t\tprintf(\"xl%d: tx underrun, increasing tx start\"\n\t\t\t\t    \" threshold to %d\\n\", sc->xl_unit,\n\t\t\t\t    sc->xl_tx_thresh);\n\t\t\t}\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND,\n\t\t\t    XL_CMD_TX_SET_START|sc->xl_tx_thresh);\n\t\t\tif (sc->xl_type == XL_TYPE_905B) {\n\t\t\t\tCSR_WRITE_2(sc, XL_COMMAND,\n\t\t\t\tXL_CMD_SET_TX_RECLAIM|(XL_PACKET_SIZE >> 4));\n\t\t\t}\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_ENABLE);\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_UNSTALL);\n\t\t} else {\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_ENABLE);\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_UNSTALL);\n\t\t}\n\t\t/*\n\t\t * Write an arbitrary byte to the TX_STATUS register\n\t \t * to clear this interrupt/error and advance to the next.\n\t\t */\n\t\tCSR_WRITE_1(sc, XL_TX_STATUS, 0x01);\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "xl_txeof_90xB",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
    "lines": "1318-1352",
    "snippet": "void\nxl_txeof_90xB(sc)\n\tstruct xl_softc *sc;\n{\n\tstruct xl_chain *cur_tx = NULL;\n\tstruct ifnet *ifp;\n\tint idx;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tidx = sc->xl_cdata.xl_tx_cons;\n\twhile(idx != sc->xl_cdata.xl_tx_prod) {\n\n\t\tcur_tx = &sc->xl_cdata.xl_tx_chain[idx];\n\n\t\tif (!(cur_tx->xl_ptr->xl_status & XL_TXSTAT_DL_COMPLETE))\n\t\t\tbreak;\n\n\t\tif (cur_tx->xl_mbuf != NULL) {\n\t\t\tm_freem(cur_tx->xl_mbuf);\n\t\t\tcur_tx->xl_mbuf = NULL;\n\t\t}\n\n\t\tifp->if_opackets++;\n\n\t\tsc->xl_cdata.xl_tx_cnt--;\n\t\tXL_INC(idx, XL_TX_LIST_CNT);\n\t\tifp->if_timer = 0;\n\t}\n\n\tsc->xl_cdata.xl_tx_cons = idx;\n\n\tif (cur_tx != NULL)\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void xl_txeof_90xB"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XL_INC",
          "args": [
            "idx",
            "XL_TX_LIST_CNT"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "cur_tx->xl_mbuf"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_txeof_90xB;\n\nvoid\nxl_txeof_90xB(sc)\n\tstruct xl_softc *sc;\n{\n\tstruct xl_chain *cur_tx = NULL;\n\tstruct ifnet *ifp;\n\tint idx;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tidx = sc->xl_cdata.xl_tx_cons;\n\twhile(idx != sc->xl_cdata.xl_tx_prod) {\n\n\t\tcur_tx = &sc->xl_cdata.xl_tx_chain[idx];\n\n\t\tif (!(cur_tx->xl_ptr->xl_status & XL_TXSTAT_DL_COMPLETE))\n\t\t\tbreak;\n\n\t\tif (cur_tx->xl_mbuf != NULL) {\n\t\t\tm_freem(cur_tx->xl_mbuf);\n\t\t\tcur_tx->xl_mbuf = NULL;\n\t\t}\n\n\t\tifp->if_opackets++;\n\n\t\tsc->xl_cdata.xl_tx_cnt--;\n\t\tXL_INC(idx, XL_TX_LIST_CNT);\n\t\tifp->if_timer = 0;\n\t}\n\n\tsc->xl_cdata.xl_tx_cons = idx;\n\n\tif (cur_tx != NULL)\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n}"
  },
  {
    "function_name": "xl_txeof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
    "lines": "1268-1316",
    "snippet": "void xl_txeof(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tstruct xl_chain\t\t*cur_tx;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Clear the timeout timer. */\n\tifp->if_timer = 0;\n\n\t/*\n\t * Go through our tx list and free mbufs for those\n\t * frames that have been uploaded. Note: the 3c905B\n\t * sets a special bit in the status word to let us\n\t * know that a frame has been downloaded, but the\n\t * original 3c900/3c905 adapters don't do that.\n\t * Consequently, we have to use a different test if\n\t * xl_type != XL_TYPE_905B.\n\t */\n\twhile(sc->xl_cdata.xl_tx_head != NULL) {\n\t\tcur_tx = sc->xl_cdata.xl_tx_head;\n\n\t\tif (CSR_READ_4(sc, XL_DOWNLIST_PTR))\n\t\t\tbreak;\n\n\t\tsc->xl_cdata.xl_tx_head = cur_tx->xl_next;\n\t\tm_freem(cur_tx->xl_mbuf);\n\t\tcur_tx->xl_mbuf = NULL;\n\t\tifp->if_opackets++;\n\n\t\tcur_tx->xl_next = sc->xl_cdata.xl_tx_free;\n\t\tsc->xl_cdata.xl_tx_free = cur_tx;\n\t}\n\n\tif (sc->xl_cdata.xl_tx_head == NULL) {\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t\tsc->xl_cdata.xl_tx_tail = NULL;\n\t} else {\n\t\tif (CSR_READ_4(sc, XL_DMACTL) & XL_DMACTL_DOWN_STALLED ||\n\t\t\t!CSR_READ_4(sc, XL_DOWNLIST_PTR)) {\n\t\t\tCSR_WRITE_4(sc, XL_DOWNLIST_PTR,\n\t\t\t\tvtophys(sc->xl_cdata.xl_tx_head->xl_ptr));\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_UNSTALL);\n\t\t}\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void xl_txeof"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_DOWN_UNSTALL"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "XL_DOWNLIST_PTR",
            "vtophys(sc->xl_cdata.xl_tx_head->xl_ptr)"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "sc->xl_cdata.xl_tx_head->xl_ptr"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "XL_DOWNLIST_PTR"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "XL_DMACTL"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "cur_tx->xl_mbuf"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "XL_DOWNLIST_PTR"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_txeof;\n\nvoid xl_txeof(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tstruct xl_chain\t\t*cur_tx;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Clear the timeout timer. */\n\tifp->if_timer = 0;\n\n\t/*\n\t * Go through our tx list and free mbufs for those\n\t * frames that have been uploaded. Note: the 3c905B\n\t * sets a special bit in the status word to let us\n\t * know that a frame has been downloaded, but the\n\t * original 3c900/3c905 adapters don't do that.\n\t * Consequently, we have to use a different test if\n\t * xl_type != XL_TYPE_905B.\n\t */\n\twhile(sc->xl_cdata.xl_tx_head != NULL) {\n\t\tcur_tx = sc->xl_cdata.xl_tx_head;\n\n\t\tif (CSR_READ_4(sc, XL_DOWNLIST_PTR))\n\t\t\tbreak;\n\n\t\tsc->xl_cdata.xl_tx_head = cur_tx->xl_next;\n\t\tm_freem(cur_tx->xl_mbuf);\n\t\tcur_tx->xl_mbuf = NULL;\n\t\tifp->if_opackets++;\n\n\t\tcur_tx->xl_next = sc->xl_cdata.xl_tx_free;\n\t\tsc->xl_cdata.xl_tx_free = cur_tx;\n\t}\n\n\tif (sc->xl_cdata.xl_tx_head == NULL) {\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t\tsc->xl_cdata.xl_tx_tail = NULL;\n\t} else {\n\t\tif (CSR_READ_4(sc, XL_DMACTL) & XL_DMACTL_DOWN_STALLED ||\n\t\t\t!CSR_READ_4(sc, XL_DOWNLIST_PTR)) {\n\t\t\tCSR_WRITE_4(sc, XL_DOWNLIST_PTR,\n\t\t\t\tvtophys(sc->xl_cdata.xl_tx_head->xl_ptr));\n\t\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_DOWN_UNSTALL);\n\t\t}\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "xl_rxeof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
    "lines": "1159-1262",
    "snippet": "void xl_rxeof(sc)\n\tstruct xl_softc\t\t*sc;\n{\n        struct ether_header\t*eh;\n        struct mbuf\t\t*m;\n        struct ifnet\t\t*ifp;\n\tstruct xl_chain_onefrag\t*cur_rx;\n\tint\t\t\ttotal_len = 0;\n\tu_int16_t\t\trxstat;\n\n\tifp = &sc->arpcom.ac_if;\n\nagain:\n\n\twhile((rxstat = sc->xl_cdata.xl_rx_head->xl_ptr->xl_status)) {\n\t\tcur_rx = sc->xl_cdata.xl_rx_head;\n\t\tsc->xl_cdata.xl_rx_head = cur_rx->xl_next;\n\n\t\t/*\n\t\t * If an error occurs, update stats, clear the\n\t\t * status word and leave the mbuf cluster in place:\n\t\t * it should simply get re-used next time this descriptor\n\t \t * comes up in the ring.\n\t\t */\n\t\tif (rxstat & XL_RXSTAT_UP_ERROR) {\n\t\t\tifp->if_ierrors++;\n\t\t\tcur_rx->xl_ptr->xl_status = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If there error bit was not set, the upload complete\n\t\t * bit should be set which means we have a valid packet.\n\t\t * If not, something truly strange has happened.\n\t\t */\n\t\tif (!(rxstat & XL_RXSTAT_UP_CMPLT)) {\n\t\t\tprintf(\"xl%d: bad receive status -- \"\n\t\t\t    \"packet dropped\", sc->xl_unit);\n\t\t\tifp->if_ierrors++;\n\t\t\tcur_rx->xl_ptr->xl_status = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* No errors; receive the packet. */\t\n\t\tm = cur_rx->xl_mbuf;\n\t\ttotal_len = cur_rx->xl_ptr->xl_status & XL_RXSTAT_LENMASK;\n\n\t\t/*\n\t\t * Try to conjure up a new mbuf cluster. If that\n\t\t * fails, it means we have an out of memory condition and\n\t\t * should leave the buffer in place and continue. This will\n\t\t * result in a lost packet, but there's little else we\n\t\t * can do in this situation.\n\t\t */\n\t\tif (xl_newbuf(sc, cur_rx) == ENOBUFS) {\n\t\t\tifp->if_ierrors++;\n\t\t\tcur_rx->xl_ptr->xl_status = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tifp->if_ipackets++;\n\t\teh = mtod(m, struct ether_header *);\n\t\tm->m_pkthdr.rcvif = ifp;\n#if NBPFILTER > 0\n\t\t/*\n\t\t * Handle BPF listeners. Let the BPF user see the packet.\n\t\t */\n\t\tif (ifp->if_bpf) {\n\t\t\tm->m_pkthdr.len = m->m_len = total_len;\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n\t\t}\n#endif\n\t\t/* Remove header from mbuf and pass it on. */\n\t\tm->m_pkthdr.len = m->m_len =\n\t\t\t\ttotal_len - sizeof(struct ether_header);\n\t\tm->m_data += sizeof(struct ether_header);\n\t\tether_input(ifp, eh, m);\n\t}\n\n\t/*\n\t * Handle the 'end of channel' condition. When the upload\n\t * engine hits the end of the RX ring, it will stall. This\n\t * is our cue to flush the RX ring, reload the uplist pointer\n\t * register and unstall the engine.\n\t * XXX This is actually a little goofy. With the ThunderLAN\n\t * chip, you get an interrupt when the receiver hits the end\n\t * of the receive ring, which tells you exactly when you\n\t * you need to reload the ring pointer. Here we have to\n\t * fake it. I'm mad at myself for not being clever enough\n\t * to avoid the use of a goto here.\n\t */\n\tif (CSR_READ_4(sc, XL_UPLIST_PTR) == 0 ||\n\t\tCSR_READ_4(sc, XL_UPLIST_STATUS) & XL_PKTSTAT_UP_STALLED) {\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_UP_STALL);\n\t\txl_wait(sc);\n\t\tCSR_WRITE_4(sc, XL_UPLIST_PTR,\n\t\t\tvtophys(&sc->xl_ldata->xl_rx_list[0]));\n\t\tsc->xl_cdata.xl_rx_head = &sc->xl_cdata.xl_rx_chain[0];\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_UP_UNSTALL);\n\t\tgoto again;\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int xl_newbuf",
      "void xl_rxeof",
      "void xl_wait"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_UP_UNSTALL"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "XL_UPLIST_PTR",
            "vtophys(&sc->xl_ldata->xl_rx_list[0])"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&sc->xl_ldata->xl_rx_list[0]"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xl_wait",
          "args": [
            "sc"
          ],
          "line": 1253
        },
        "resolved": true,
        "details": {
          "function_name": "xl_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "200-216",
          "snippet": "void xl_wait(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tfor (i = 0; i < XL_TIMEOUT; i++) {\n\t\tif (!(CSR_READ_2(sc, XL_STATUS) & XL_STAT_CMDBUSY))\n\t\t\tbreak;\n\t}\n\n#ifdef DIAGNOSTIC\n\tif (i == XL_TIMEOUT)\n\t\tprintf(\"xl%d: command never completed!\\n\", sc->xl_unit);\n#endif\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void xl_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_wait;\n\nvoid xl_wait(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tfor (i = 0; i < XL_TIMEOUT; i++) {\n\t\tif (!(CSR_READ_2(sc, XL_STATUS) & XL_STAT_CMDBUSY))\n\t\t\tbreak;\n\t}\n\n#ifdef DIAGNOSTIC\n\tif (i == XL_TIMEOUT)\n\t\tprintf(\"xl%d: command never completed!\\n\", sc->xl_unit);\n#endif\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_UP_STALL"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "XL_UPLIST_STATUS"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "XL_UPLIST_PTR"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_input",
          "args": [
            "ifp",
            "eh",
            "m"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "m"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "structether_header*"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xl_newbuf",
          "args": [
            "sc",
            "cur_rx"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "xl_newbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "1104-1131",
          "snippet": "int xl_newbuf(sc, c)\n\tstruct xl_softc\t\t*sc;\n\tstruct xl_chain_onefrag\t*c;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\tif (m_new == NULL)\n\t\treturn(ENOBUFS);\n\n\tMCLGET(m_new, M_DONTWAIT);\n\tif (!(m_new->m_flags & M_EXT)) {\n\t\tm_freem(m_new);\n\t\treturn(ENOBUFS);\n\t}\n\n\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\n\t/* Force longword alignment for packet payload. */\n\tm_adj(m_new, ETHER_ALIGN);\n\n\tc->xl_mbuf = m_new;\n\tc->xl_ptr->xl_frag.xl_addr = vtophys(mtod(m_new, caddr_t));\n\tc->xl_ptr->xl_frag.xl_len = MCLBYTES | XL_LAST_FRAG;\n\tc->xl_ptr->xl_status = 0;\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xl_newbuf"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint xl_newbuf;\n\nint xl_newbuf(sc, c)\n\tstruct xl_softc\t\t*sc;\n\tstruct xl_chain_onefrag\t*c;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\tif (m_new == NULL)\n\t\treturn(ENOBUFS);\n\n\tMCLGET(m_new, M_DONTWAIT);\n\tif (!(m_new->m_flags & M_EXT)) {\n\t\tm_freem(m_new);\n\t\treturn(ENOBUFS);\n\t}\n\n\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\n\t/* Force longword alignment for packet payload. */\n\tm_adj(m_new, ETHER_ALIGN);\n\n\tc->xl_mbuf = m_new;\n\tc->xl_ptr->xl_frag.xl_addr = vtophys(mtod(m_new, caddr_t));\n\tc->xl_ptr->xl_frag.xl_len = MCLBYTES | XL_LAST_FRAG;\n\tc->xl_ptr->xl_status = 0;\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"xl%d: bad receive status -- \"\n\t\t\t    \"packet dropped\"",
            "sc->xl_unit"
          ],
          "line": 1195
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint xl_newbuf;\nvoid xl_rxeof;\nvoid xl_wait;\n\nvoid xl_rxeof(sc)\n\tstruct xl_softc\t\t*sc;\n{\n        struct ether_header\t*eh;\n        struct mbuf\t\t*m;\n        struct ifnet\t\t*ifp;\n\tstruct xl_chain_onefrag\t*cur_rx;\n\tint\t\t\ttotal_len = 0;\n\tu_int16_t\t\trxstat;\n\n\tifp = &sc->arpcom.ac_if;\n\nagain:\n\n\twhile((rxstat = sc->xl_cdata.xl_rx_head->xl_ptr->xl_status)) {\n\t\tcur_rx = sc->xl_cdata.xl_rx_head;\n\t\tsc->xl_cdata.xl_rx_head = cur_rx->xl_next;\n\n\t\t/*\n\t\t * If an error occurs, update stats, clear the\n\t\t * status word and leave the mbuf cluster in place:\n\t\t * it should simply get re-used next time this descriptor\n\t \t * comes up in the ring.\n\t\t */\n\t\tif (rxstat & XL_RXSTAT_UP_ERROR) {\n\t\t\tifp->if_ierrors++;\n\t\t\tcur_rx->xl_ptr->xl_status = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If there error bit was not set, the upload complete\n\t\t * bit should be set which means we have a valid packet.\n\t\t * If not, something truly strange has happened.\n\t\t */\n\t\tif (!(rxstat & XL_RXSTAT_UP_CMPLT)) {\n\t\t\tprintf(\"xl%d: bad receive status -- \"\n\t\t\t    \"packet dropped\", sc->xl_unit);\n\t\t\tifp->if_ierrors++;\n\t\t\tcur_rx->xl_ptr->xl_status = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* No errors; receive the packet. */\t\n\t\tm = cur_rx->xl_mbuf;\n\t\ttotal_len = cur_rx->xl_ptr->xl_status & XL_RXSTAT_LENMASK;\n\n\t\t/*\n\t\t * Try to conjure up a new mbuf cluster. If that\n\t\t * fails, it means we have an out of memory condition and\n\t\t * should leave the buffer in place and continue. This will\n\t\t * result in a lost packet, but there's little else we\n\t\t * can do in this situation.\n\t\t */\n\t\tif (xl_newbuf(sc, cur_rx) == ENOBUFS) {\n\t\t\tifp->if_ierrors++;\n\t\t\tcur_rx->xl_ptr->xl_status = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tifp->if_ipackets++;\n\t\teh = mtod(m, struct ether_header *);\n\t\tm->m_pkthdr.rcvif = ifp;\n#if NBPFILTER > 0\n\t\t/*\n\t\t * Handle BPF listeners. Let the BPF user see the packet.\n\t\t */\n\t\tif (ifp->if_bpf) {\n\t\t\tm->m_pkthdr.len = m->m_len = total_len;\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n\t\t}\n#endif\n\t\t/* Remove header from mbuf and pass it on. */\n\t\tm->m_pkthdr.len = m->m_len =\n\t\t\t\ttotal_len - sizeof(struct ether_header);\n\t\tm->m_data += sizeof(struct ether_header);\n\t\tether_input(ifp, eh, m);\n\t}\n\n\t/*\n\t * Handle the 'end of channel' condition. When the upload\n\t * engine hits the end of the RX ring, it will stall. This\n\t * is our cue to flush the RX ring, reload the uplist pointer\n\t * register and unstall the engine.\n\t * XXX This is actually a little goofy. With the ThunderLAN\n\t * chip, you get an interrupt when the receiver hits the end\n\t * of the receive ring, which tells you exactly when you\n\t * you need to reload the ring pointer. Here we have to\n\t * fake it. I'm mad at myself for not being clever enough\n\t * to avoid the use of a goto here.\n\t */\n\tif (CSR_READ_4(sc, XL_UPLIST_PTR) == 0 ||\n\t\tCSR_READ_4(sc, XL_UPLIST_STATUS) & XL_PKTSTAT_UP_STALLED) {\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_UP_STALL);\n\t\txl_wait(sc);\n\t\tCSR_WRITE_4(sc, XL_UPLIST_PTR,\n\t\t\tvtophys(&sc->xl_ldata->xl_rx_list[0]));\n\t\tsc->xl_cdata.xl_rx_head = &sc->xl_cdata.xl_rx_chain[0];\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_UP_UNSTALL);\n\t\tgoto again;\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "xl_rx_resync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
    "lines": "1133-1153",
    "snippet": "int xl_rx_resync(sc)\n\tstruct xl_softc *sc;\n{\n\tstruct xl_chain_onefrag *pos;\n\tint i;\n\n\tpos = sc->xl_cdata.xl_rx_head;\n\n\tfor (i = 0; i < XL_RX_LIST_CNT; i++) {\n\t\tif (pos->xl_ptr->xl_status)\n\t\t\tbreak;\n\t\tpos = pos->xl_next;\n\t}\n\n\tif (i == XL_RX_LIST_CNT)\n\t\treturn (0);\n\n\tsc->xl_cdata.xl_rx_head = pos;\n\n\treturn (EAGAIN);\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int xl_rx_resync"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint xl_rx_resync;\n\nint xl_rx_resync(sc)\n\tstruct xl_softc *sc;\n{\n\tstruct xl_chain_onefrag *pos;\n\tint i;\n\n\tpos = sc->xl_cdata.xl_rx_head;\n\n\tfor (i = 0; i < XL_RX_LIST_CNT; i++) {\n\t\tif (pos->xl_ptr->xl_status)\n\t\t\tbreak;\n\t\tpos = pos->xl_next;\n\t}\n\n\tif (i == XL_RX_LIST_CNT)\n\t\treturn (0);\n\n\tsc->xl_cdata.xl_rx_head = pos;\n\n\treturn (EAGAIN);\n}"
  },
  {
    "function_name": "xl_newbuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
    "lines": "1104-1131",
    "snippet": "int xl_newbuf(sc, c)\n\tstruct xl_softc\t\t*sc;\n\tstruct xl_chain_onefrag\t*c;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\tif (m_new == NULL)\n\t\treturn(ENOBUFS);\n\n\tMCLGET(m_new, M_DONTWAIT);\n\tif (!(m_new->m_flags & M_EXT)) {\n\t\tm_freem(m_new);\n\t\treturn(ENOBUFS);\n\t}\n\n\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\n\t/* Force longword alignment for packet payload. */\n\tm_adj(m_new, ETHER_ALIGN);\n\n\tc->xl_mbuf = m_new;\n\tc->xl_ptr->xl_frag.xl_addr = vtophys(mtod(m_new, caddr_t));\n\tc->xl_ptr->xl_frag.xl_len = MCLBYTES | XL_LAST_FRAG;\n\tc->xl_ptr->xl_status = 0;\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int xl_newbuf"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "mtod(m_new, caddr_t)"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m_new",
            "caddr_t"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_adj",
          "args": [
            "m_new",
            "ETHER_ALIGN"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m_new"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCLGET",
          "args": [
            "m_new",
            "M_DONTWAIT"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGETHDR",
          "args": [
            "m_new",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint xl_newbuf;\n\nint xl_newbuf(sc, c)\n\tstruct xl_softc\t\t*sc;\n\tstruct xl_chain_onefrag\t*c;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\tif (m_new == NULL)\n\t\treturn(ENOBUFS);\n\n\tMCLGET(m_new, M_DONTWAIT);\n\tif (!(m_new->m_flags & M_EXT)) {\n\t\tm_freem(m_new);\n\t\treturn(ENOBUFS);\n\t}\n\n\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\n\t/* Force longword alignment for packet payload. */\n\tm_adj(m_new, ETHER_ALIGN);\n\n\tc->xl_mbuf = m_new;\n\tc->xl_ptr->xl_frag.xl_addr = vtophys(mtod(m_new, caddr_t));\n\tc->xl_ptr->xl_frag.xl_len = MCLBYTES | XL_LAST_FRAG;\n\tc->xl_ptr->xl_status = 0;\n\n\treturn(0);\n}"
  },
  {
    "function_name": "xl_list_rx_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
    "lines": "1070-1099",
    "snippet": "int xl_list_rx_init(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tstruct xl_chain_data\t*cd;\n\tstruct xl_list_data\t*ld;\n\tint\t\t\ti;\n\n\tcd = &sc->xl_cdata;\n\tld = sc->xl_ldata;\n\n\tfor (i = 0; i < XL_RX_LIST_CNT; i++) {\n\t\tcd->xl_rx_chain[i].xl_ptr =\n\t\t\t(struct xl_list_onefrag *)&ld->xl_rx_list[i];\n\t\tif (xl_newbuf(sc, &cd->xl_rx_chain[i]) == ENOBUFS)\n\t\t\treturn(ENOBUFS);\n\t\tif (i == (XL_RX_LIST_CNT - 1)) {\n\t\t\tcd->xl_rx_chain[i].xl_next = &cd->xl_rx_chain[0];\n\t\t\tld->xl_rx_list[i].xl_next =\n\t\t\t    vtophys(&ld->xl_rx_list[0]);\n\t\t} else {\n\t\t\tcd->xl_rx_chain[i].xl_next = &cd->xl_rx_chain[i + 1];\n\t\t\tld->xl_rx_list[i].xl_next =\n\t\t\t    vtophys(&ld->xl_rx_list[i + 1]);\n\t\t}\n\t}\n\n\tcd->xl_rx_head = &cd->xl_rx_chain[0];\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int xl_newbuf",
      "int xl_list_rx_init"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&ld->xl_rx_list[i + 1]"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&ld->xl_rx_list[0]"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xl_newbuf",
          "args": [
            "sc",
            "&cd->xl_rx_chain[i]"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "xl_newbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "1104-1131",
          "snippet": "int xl_newbuf(sc, c)\n\tstruct xl_softc\t\t*sc;\n\tstruct xl_chain_onefrag\t*c;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\tif (m_new == NULL)\n\t\treturn(ENOBUFS);\n\n\tMCLGET(m_new, M_DONTWAIT);\n\tif (!(m_new->m_flags & M_EXT)) {\n\t\tm_freem(m_new);\n\t\treturn(ENOBUFS);\n\t}\n\n\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\n\t/* Force longword alignment for packet payload. */\n\tm_adj(m_new, ETHER_ALIGN);\n\n\tc->xl_mbuf = m_new;\n\tc->xl_ptr->xl_frag.xl_addr = vtophys(mtod(m_new, caddr_t));\n\tc->xl_ptr->xl_frag.xl_len = MCLBYTES | XL_LAST_FRAG;\n\tc->xl_ptr->xl_status = 0;\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xl_newbuf"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint xl_newbuf;\n\nint xl_newbuf(sc, c)\n\tstruct xl_softc\t\t*sc;\n\tstruct xl_chain_onefrag\t*c;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\tif (m_new == NULL)\n\t\treturn(ENOBUFS);\n\n\tMCLGET(m_new, M_DONTWAIT);\n\tif (!(m_new->m_flags & M_EXT)) {\n\t\tm_freem(m_new);\n\t\treturn(ENOBUFS);\n\t}\n\n\tm_new->m_len = m_new->m_pkthdr.len = MCLBYTES;\n\n\t/* Force longword alignment for packet payload. */\n\tm_adj(m_new, ETHER_ALIGN);\n\n\tc->xl_mbuf = m_new;\n\tc->xl_ptr->xl_frag.xl_addr = vtophys(mtod(m_new, caddr_t));\n\tc->xl_ptr->xl_frag.xl_len = MCLBYTES | XL_LAST_FRAG;\n\tc->xl_ptr->xl_status = 0;\n\n\treturn(0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint xl_newbuf;\nint xl_list_rx_init;\n\nint xl_list_rx_init(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tstruct xl_chain_data\t*cd;\n\tstruct xl_list_data\t*ld;\n\tint\t\t\ti;\n\n\tcd = &sc->xl_cdata;\n\tld = sc->xl_ldata;\n\n\tfor (i = 0; i < XL_RX_LIST_CNT; i++) {\n\t\tcd->xl_rx_chain[i].xl_ptr =\n\t\t\t(struct xl_list_onefrag *)&ld->xl_rx_list[i];\n\t\tif (xl_newbuf(sc, &cd->xl_rx_chain[i]) == ENOBUFS)\n\t\t\treturn(ENOBUFS);\n\t\tif (i == (XL_RX_LIST_CNT - 1)) {\n\t\t\tcd->xl_rx_chain[i].xl_next = &cd->xl_rx_chain[0];\n\t\t\tld->xl_rx_list[i].xl_next =\n\t\t\t    vtophys(&ld->xl_rx_list[0]);\n\t\t} else {\n\t\t\tcd->xl_rx_chain[i].xl_next = &cd->xl_rx_chain[i + 1];\n\t\t\tld->xl_rx_list[i].xl_next =\n\t\t\t    vtophys(&ld->xl_rx_list[i + 1]);\n\t\t}\n\t}\n\n\tcd->xl_rx_head = &cd->xl_rx_chain[0];\n\n\treturn(0);\n}"
  },
  {
    "function_name": "xl_list_tx_init_90xB",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
    "lines": "1030-1063",
    "snippet": "int\nxl_list_tx_init_90xB(sc)\n\tstruct xl_softc *sc;\n{\n\tstruct xl_chain_data *cd;\n\tstruct xl_list_data *ld;\n\tint i;\n\n\tcd = &sc->xl_cdata;\n\tld = sc->xl_ldata;\n\tfor (i = 0; i < XL_TX_LIST_CNT; i++) {\n\t\tcd->xl_tx_chain[i].xl_ptr = &ld->xl_tx_list[i];\n\t\tcd->xl_tx_chain[i].xl_phys = vtophys(&ld->xl_tx_list[i]);\n\t\tif (i == (XL_TX_LIST_CNT - 1))\n\t\t\tcd->xl_tx_chain[i].xl_next = &cd->xl_tx_chain[0];\n\t\telse\n\t\t\tcd->xl_tx_chain[i].xl_next = &cd->xl_tx_chain[i + 1];\n\t\tif (i == 0)\n\t\t\tcd->xl_tx_chain[i].xl_prev =\n\t\t\t    &cd->xl_tx_chain[XL_TX_LIST_CNT - 1];\n\t\telse\n\t\t\tcd->xl_tx_chain[i].xl_prev =\n\t\t\t    &cd->xl_tx_chain[i - 1];\n\t}\n\n\tbzero((char *)ld->xl_tx_list, sizeof(struct xl_list) * XL_TX_LIST_CNT);\n\tld->xl_tx_list[0].xl_status = XL_TXSTAT_EMPTY;\n\n\tcd->xl_tx_prod = 1;\n\tcd->xl_tx_cons = 1;\n\tcd->xl_tx_cnt = 0;\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int xl_list_tx_init_90xB"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)ld->xl_tx_list",
            "sizeof(struct xl_list) * XL_TX_LIST_CNT"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&ld->xl_tx_list[i]"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint xl_list_tx_init_90xB;\n\nint\nxl_list_tx_init_90xB(sc)\n\tstruct xl_softc *sc;\n{\n\tstruct xl_chain_data *cd;\n\tstruct xl_list_data *ld;\n\tint i;\n\n\tcd = &sc->xl_cdata;\n\tld = sc->xl_ldata;\n\tfor (i = 0; i < XL_TX_LIST_CNT; i++) {\n\t\tcd->xl_tx_chain[i].xl_ptr = &ld->xl_tx_list[i];\n\t\tcd->xl_tx_chain[i].xl_phys = vtophys(&ld->xl_tx_list[i]);\n\t\tif (i == (XL_TX_LIST_CNT - 1))\n\t\t\tcd->xl_tx_chain[i].xl_next = &cd->xl_tx_chain[0];\n\t\telse\n\t\t\tcd->xl_tx_chain[i].xl_next = &cd->xl_tx_chain[i + 1];\n\t\tif (i == 0)\n\t\t\tcd->xl_tx_chain[i].xl_prev =\n\t\t\t    &cd->xl_tx_chain[XL_TX_LIST_CNT - 1];\n\t\telse\n\t\t\tcd->xl_tx_chain[i].xl_prev =\n\t\t\t    &cd->xl_tx_chain[i - 1];\n\t}\n\n\tbzero((char *)ld->xl_tx_list, sizeof(struct xl_list) * XL_TX_LIST_CNT);\n\tld->xl_tx_list[0].xl_status = XL_TXSTAT_EMPTY;\n\n\tcd->xl_tx_prod = 1;\n\tcd->xl_tx_cons = 1;\n\tcd->xl_tx_cnt = 0;\n\n\treturn (0);\n}"
  },
  {
    "function_name": "xl_list_tx_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
    "lines": "1004-1025",
    "snippet": "int xl_list_tx_init(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tstruct xl_chain_data\t*cd;\n\tstruct xl_list_data\t*ld;\n\tint\t\t\ti;\n\n\tcd = &sc->xl_cdata;\n\tld = sc->xl_ldata;\n\tfor (i = 0; i < XL_TX_LIST_CNT; i++) {\n\t\tcd->xl_tx_chain[i].xl_ptr = &ld->xl_tx_list[i];\n\t\tif (i == (XL_TX_LIST_CNT - 1))\n\t\t\tcd->xl_tx_chain[i].xl_next = NULL;\n\t\telse\n\t\t\tcd->xl_tx_chain[i].xl_next = &cd->xl_tx_chain[i + 1];\n\t}\n\n\tcd->xl_tx_free = &cd->xl_tx_chain[0];\n\tcd->xl_tx_tail = cd->xl_tx_head = NULL;\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int xl_list_tx_init"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint xl_list_tx_init;\n\nint xl_list_tx_init(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tstruct xl_chain_data\t*cd;\n\tstruct xl_list_data\t*ld;\n\tint\t\t\ti;\n\n\tcd = &sc->xl_cdata;\n\tld = sc->xl_ldata;\n\tfor (i = 0; i < XL_TX_LIST_CNT; i++) {\n\t\tcd->xl_tx_chain[i].xl_ptr = &ld->xl_tx_list[i];\n\t\tif (i == (XL_TX_LIST_CNT - 1))\n\t\t\tcd->xl_tx_chain[i].xl_next = NULL;\n\t\telse\n\t\t\tcd->xl_tx_chain[i].xl_next = &cd->xl_tx_chain[i + 1];\n\t}\n\n\tcd->xl_tx_free = &cd->xl_tx_chain[0];\n\tcd->xl_tx_tail = cd->xl_tx_head = NULL;\n\n\treturn(0);\n}"
  },
  {
    "function_name": "xl_choose_xcvr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
    "lines": "911-999",
    "snippet": "void xl_choose_xcvr(sc, verbose)\n\tstruct xl_softc *sc;\n\tint verbose;\n{\n\tu_int16_t devid;\n\n\t/*\n\t * Read the device ID from the EEPROM.\n\t * This is what's loaded into the PCI device ID register, so it has\n\t * to be correct otherwise we wouldn't have gotten this far.\n\t */\n\txl_read_eeprom(sc, (caddr_t)&devid, XL_EE_PRODID, 1, 0);\n\n\tswitch(devid) {\n\tcase TC_DEVICEID_BOOMERANG_10BT:\t/* 3c900-TPO */\n\tcase TC_DEVICEID_KRAKATOA_10BT:\t\t/* 3c900B-TPO */\n\t\tsc->xl_media = XL_MEDIAOPT_BT;\n\t\tsc->xl_xcvr = XL_XCVR_10BT;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing 10BaseT transceiver\\n\",\n\t\t\t    sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_BOOMERANG_10BT_COMBO:\t/* 3c900-COMBO */\n\tcase TC_DEVICEID_KRAKATOA_10BT_COMBO:\t/* 3c900B-COMBO */\n\t\tsc->xl_media = XL_MEDIAOPT_BT|XL_MEDIAOPT_BNC|XL_MEDIAOPT_AUI;\n\t\tsc->xl_xcvr = XL_XCVR_10BT;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing COMBO (AUI/BNC/TP)\\n\",\n\t\t\t    sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_KRAKATOA_10BT_TPC:\t/* 3c900B-TPC */\n\t\tsc->xl_media = XL_MEDIAOPT_BT|XL_MEDIAOPT_BNC;\n\t\tsc->xl_xcvr = XL_XCVR_10BT;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing TPC (BNC/TP)\\n\", sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_CYCLONE_10FL:\t\t/* 3c900B-FL */\n\t\tsc->xl_media = XL_MEDIAOPT_10FL;\n\t\tsc->xl_xcvr = XL_XCVR_AUI;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing 10baseFL\\n\", sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_BOOMERANG_10_100BT:\t/* 3c905-TX */\n\t\tsc->xl_media = XL_MEDIAOPT_MII;\n\t\tsc->xl_xcvr = XL_XCVR_MII;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing MII\\n\", sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_BOOMERANG_100BT4:\t/* 3c905-T4 */\n\tcase TC_DEVICEID_CYCLONE_10_100BT4:\t/* 3c905B-T4 */\n\t\tsc->xl_media = XL_MEDIAOPT_BT4;\n\t\tsc->xl_xcvr = XL_XCVR_MII;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing 100BaseT4/MII\\n\", sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_HURRICANE_10_100BT:\t/* 3c905B-TX */\n\tcase TC_DEVICEID_HURRICANE_10_100BT_SERV:/* 3c980-TX */\n\tcase TC_DEVICEID_TORNADO_10_100BT_SERV:\t/* 3c980C-TX */\n\tcase TC_DEVICEID_HURRICANE_SOHO100TX:\t/* 3cSOHO100-TX */\n\tcase TC_DEVICEID_TORNADO_10_100BT:\t/* 3c905C-TX */\n\tcase TC_DEVICEID_TORNADO_HOMECONNECT:\t/* 3c450-TX */\n\t\tsc->xl_media = XL_MEDIAOPT_BTX;\n\t\tsc->xl_xcvr = XL_XCVR_AUTO;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing 10/100 internal\\n\",\n\t\t\t    sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_CYCLONE_10_100_COMBO:\t/* 3c905B-COMBO */\n\t\tsc->xl_media = XL_MEDIAOPT_BTX|XL_MEDIAOPT_BNC|XL_MEDIAOPT_AUI;\n\t\tsc->xl_xcvr = XL_XCVR_AUTO;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing 10/100 plus BNC/AUI\\n\",\n\t\t\t    sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_3CCFE575_CARDBUS:\n\tcase TC_DEVICEID_3CCFE575BT_CARDBUS:\n\tcase TC_DEVICEID_3CCFE575CT_CARDBUS:\n\t\tsc->xl_media = XL_MEDIAOPT_MII;\n\t\tsc->xl_xcvr = XL_XCVR_MII;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"xl%d: unknown device ID: %x -- \"\n\t\t\t\"defaulting to 10baseT\\n\", sc->xl_unit, devid);\n\t\tsc->xl_media = XL_MEDIAOPT_BT;\n\t\tbreak;\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int xl_read_eeprom",
      "void xl_choose_xcvr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"xl%d: unknown device ID: %x -- \"\n\t\t\t\"defaulting to 10baseT\\n\"",
            "sc->xl_unit",
            "devid"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xl_read_eeprom",
          "args": [
            "sc",
            "(caddr_t)&devid",
            "XL_EE_PRODID",
            "1",
            "0"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "xl_read_eeprom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "518-554",
          "snippet": "int xl_read_eeprom(sc, dest, off, cnt, swap)\n\tstruct xl_softc\t\t*sc;\n\tcaddr_t\t\t\tdest;\n\tint\t\t\toff;\n\tint\t\t\tcnt;\n\tint\t\t\tswap;\n{\n\tint\t\t\terr = 0, i;\n\tu_int16_t\t\tword = 0, *ptr;\n\n\tXL_SEL_WIN(0);\n\n\tif (xl_eeprom_wait(sc))\n\t\treturn(1);\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tswitch (sc->xl_bustype) {\n\t\tcase XL_BUS_PCI:\n\t\t\tCSR_WRITE_2(sc, XL_W0_EE_CMD, XL_EE_READ | (off + i));\n\t\t\tbreak;\n\t\tcase XL_BUS_CARDBUS:\n\t\t\tCSR_WRITE_2(sc, XL_W0_EE_CMD, 0x230 + (off + i));\n\t\t\tbreak;\n\t\t}\n\t\terr = xl_eeprom_wait(sc);\n\t\tif (err)\n\t\t\tbreak;\n\t\tword = CSR_READ_2(sc, XL_W0_EE_DATA);\n\t\tptr = (u_int16_t *)(dest + (i * 2));\n\t\tif (swap)\n\t\t\t*ptr = ntohs(word);\n\t\telse\n\t\t\t*ptr = word;\t\n\t}\n\n\treturn(err ? 1 : 0);\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xl_eeprom_wait",
            "int xl_read_eeprom"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint xl_eeprom_wait;\nint xl_read_eeprom;\n\nint xl_read_eeprom(sc, dest, off, cnt, swap)\n\tstruct xl_softc\t\t*sc;\n\tcaddr_t\t\t\tdest;\n\tint\t\t\toff;\n\tint\t\t\tcnt;\n\tint\t\t\tswap;\n{\n\tint\t\t\terr = 0, i;\n\tu_int16_t\t\tword = 0, *ptr;\n\n\tXL_SEL_WIN(0);\n\n\tif (xl_eeprom_wait(sc))\n\t\treturn(1);\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tswitch (sc->xl_bustype) {\n\t\tcase XL_BUS_PCI:\n\t\t\tCSR_WRITE_2(sc, XL_W0_EE_CMD, XL_EE_READ | (off + i));\n\t\t\tbreak;\n\t\tcase XL_BUS_CARDBUS:\n\t\t\tCSR_WRITE_2(sc, XL_W0_EE_CMD, 0x230 + (off + i));\n\t\t\tbreak;\n\t\t}\n\t\terr = xl_eeprom_wait(sc);\n\t\tif (err)\n\t\t\tbreak;\n\t\tword = CSR_READ_2(sc, XL_W0_EE_DATA);\n\t\tptr = (u_int16_t *)(dest + (i * 2));\n\t\tif (swap)\n\t\t\t*ptr = ntohs(word);\n\t\telse\n\t\t\t*ptr = word;\t\n\t}\n\n\treturn(err ? 1 : 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint xl_read_eeprom;\nvoid xl_choose_xcvr;\n\nvoid xl_choose_xcvr(sc, verbose)\n\tstruct xl_softc *sc;\n\tint verbose;\n{\n\tu_int16_t devid;\n\n\t/*\n\t * Read the device ID from the EEPROM.\n\t * This is what's loaded into the PCI device ID register, so it has\n\t * to be correct otherwise we wouldn't have gotten this far.\n\t */\n\txl_read_eeprom(sc, (caddr_t)&devid, XL_EE_PRODID, 1, 0);\n\n\tswitch(devid) {\n\tcase TC_DEVICEID_BOOMERANG_10BT:\t/* 3c900-TPO */\n\tcase TC_DEVICEID_KRAKATOA_10BT:\t\t/* 3c900B-TPO */\n\t\tsc->xl_media = XL_MEDIAOPT_BT;\n\t\tsc->xl_xcvr = XL_XCVR_10BT;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing 10BaseT transceiver\\n\",\n\t\t\t    sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_BOOMERANG_10BT_COMBO:\t/* 3c900-COMBO */\n\tcase TC_DEVICEID_KRAKATOA_10BT_COMBO:\t/* 3c900B-COMBO */\n\t\tsc->xl_media = XL_MEDIAOPT_BT|XL_MEDIAOPT_BNC|XL_MEDIAOPT_AUI;\n\t\tsc->xl_xcvr = XL_XCVR_10BT;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing COMBO (AUI/BNC/TP)\\n\",\n\t\t\t    sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_KRAKATOA_10BT_TPC:\t/* 3c900B-TPC */\n\t\tsc->xl_media = XL_MEDIAOPT_BT|XL_MEDIAOPT_BNC;\n\t\tsc->xl_xcvr = XL_XCVR_10BT;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing TPC (BNC/TP)\\n\", sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_CYCLONE_10FL:\t\t/* 3c900B-FL */\n\t\tsc->xl_media = XL_MEDIAOPT_10FL;\n\t\tsc->xl_xcvr = XL_XCVR_AUI;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing 10baseFL\\n\", sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_BOOMERANG_10_100BT:\t/* 3c905-TX */\n\t\tsc->xl_media = XL_MEDIAOPT_MII;\n\t\tsc->xl_xcvr = XL_XCVR_MII;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing MII\\n\", sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_BOOMERANG_100BT4:\t/* 3c905-T4 */\n\tcase TC_DEVICEID_CYCLONE_10_100BT4:\t/* 3c905B-T4 */\n\t\tsc->xl_media = XL_MEDIAOPT_BT4;\n\t\tsc->xl_xcvr = XL_XCVR_MII;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing 100BaseT4/MII\\n\", sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_HURRICANE_10_100BT:\t/* 3c905B-TX */\n\tcase TC_DEVICEID_HURRICANE_10_100BT_SERV:/* 3c980-TX */\n\tcase TC_DEVICEID_TORNADO_10_100BT_SERV:\t/* 3c980C-TX */\n\tcase TC_DEVICEID_HURRICANE_SOHO100TX:\t/* 3cSOHO100-TX */\n\tcase TC_DEVICEID_TORNADO_10_100BT:\t/* 3c905C-TX */\n\tcase TC_DEVICEID_TORNADO_HOMECONNECT:\t/* 3c450-TX */\n\t\tsc->xl_media = XL_MEDIAOPT_BTX;\n\t\tsc->xl_xcvr = XL_XCVR_AUTO;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing 10/100 internal\\n\",\n\t\t\t    sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_CYCLONE_10_100_COMBO:\t/* 3c905B-COMBO */\n\t\tsc->xl_media = XL_MEDIAOPT_BTX|XL_MEDIAOPT_BNC|XL_MEDIAOPT_AUI;\n\t\tsc->xl_xcvr = XL_XCVR_AUTO;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing 10/100 plus BNC/AUI\\n\",\n\t\t\t    sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_3CCFE575_CARDBUS:\n\tcase TC_DEVICEID_3CCFE575BT_CARDBUS:\n\tcase TC_DEVICEID_3CCFE575CT_CARDBUS:\n\t\tsc->xl_media = XL_MEDIAOPT_MII;\n\t\tsc->xl_xcvr = XL_XCVR_MII;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"xl%d: unknown device ID: %x -- \"\n\t\t\t\"defaulting to 10baseT\\n\", sc->xl_unit, devid);\n\t\tsc->xl_media = XL_MEDIAOPT_BT;\n\t\tbreak;\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "xl_mediacheck",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
    "lines": "874-909",
    "snippet": "void xl_mediacheck(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\t/*\n\t * If some of the media options bits are set, assume they are\n\t * correct. If not, try to figure it out down below.\n\t * XXX I should check for 10baseFL, but I don't have an adapter\n\t * to test with.\n\t */\n\tif (sc->xl_media & (XL_MEDIAOPT_MASK & ~XL_MEDIAOPT_VCO)) {\n\t\t/*\n\t \t * Check the XCVR value. If it's not in the normal range\n\t \t * of values, we need to fake it up here.\n\t \t */\n\t\tif (sc->xl_xcvr <= XL_XCVR_AUTO)\n\t\t\treturn;\n\t\telse {\n\t\t\tprintf(\"xl%d: bogus xcvr value \"\n\t\t\t\"in EEPROM (%x)\\n\", sc->xl_unit, sc->xl_xcvr);\n\t\t\tprintf(\"xl%d: choosing new default based \"\n\t\t\t\t\"on card type\\n\", sc->xl_unit);\n\t\t}\n\t} else {\n\t\tif (sc->xl_type == XL_TYPE_905B &&\n\t\t    sc->xl_media & XL_MEDIAOPT_10FL)\n\t\t\treturn;\n\t\tprintf(\"xl%d: WARNING: no media options bits set in \"\n\t\t\t\"the media options register!!\\n\", sc->xl_unit);\n\t\tprintf(\"xl%d: this could be a manufacturing defect in \"\n\t\t\t\"your adapter or system\\n\", sc->xl_unit);\n\t\tprintf(\"xl%d: attempting to guess media type; you \"\n\t\t\t\"should probably consult your vendor\\n\", sc->xl_unit);\n\t}\n\n\txl_choose_xcvr(sc, 1);\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void xl_mediacheck",
      "void xl_choose_xcvr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xl_choose_xcvr",
          "args": [
            "sc",
            "1"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "xl_choose_xcvr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "911-999",
          "snippet": "void xl_choose_xcvr(sc, verbose)\n\tstruct xl_softc *sc;\n\tint verbose;\n{\n\tu_int16_t devid;\n\n\t/*\n\t * Read the device ID from the EEPROM.\n\t * This is what's loaded into the PCI device ID register, so it has\n\t * to be correct otherwise we wouldn't have gotten this far.\n\t */\n\txl_read_eeprom(sc, (caddr_t)&devid, XL_EE_PRODID, 1, 0);\n\n\tswitch(devid) {\n\tcase TC_DEVICEID_BOOMERANG_10BT:\t/* 3c900-TPO */\n\tcase TC_DEVICEID_KRAKATOA_10BT:\t\t/* 3c900B-TPO */\n\t\tsc->xl_media = XL_MEDIAOPT_BT;\n\t\tsc->xl_xcvr = XL_XCVR_10BT;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing 10BaseT transceiver\\n\",\n\t\t\t    sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_BOOMERANG_10BT_COMBO:\t/* 3c900-COMBO */\n\tcase TC_DEVICEID_KRAKATOA_10BT_COMBO:\t/* 3c900B-COMBO */\n\t\tsc->xl_media = XL_MEDIAOPT_BT|XL_MEDIAOPT_BNC|XL_MEDIAOPT_AUI;\n\t\tsc->xl_xcvr = XL_XCVR_10BT;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing COMBO (AUI/BNC/TP)\\n\",\n\t\t\t    sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_KRAKATOA_10BT_TPC:\t/* 3c900B-TPC */\n\t\tsc->xl_media = XL_MEDIAOPT_BT|XL_MEDIAOPT_BNC;\n\t\tsc->xl_xcvr = XL_XCVR_10BT;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing TPC (BNC/TP)\\n\", sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_CYCLONE_10FL:\t\t/* 3c900B-FL */\n\t\tsc->xl_media = XL_MEDIAOPT_10FL;\n\t\tsc->xl_xcvr = XL_XCVR_AUI;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing 10baseFL\\n\", sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_BOOMERANG_10_100BT:\t/* 3c905-TX */\n\t\tsc->xl_media = XL_MEDIAOPT_MII;\n\t\tsc->xl_xcvr = XL_XCVR_MII;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing MII\\n\", sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_BOOMERANG_100BT4:\t/* 3c905-T4 */\n\tcase TC_DEVICEID_CYCLONE_10_100BT4:\t/* 3c905B-T4 */\n\t\tsc->xl_media = XL_MEDIAOPT_BT4;\n\t\tsc->xl_xcvr = XL_XCVR_MII;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing 100BaseT4/MII\\n\", sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_HURRICANE_10_100BT:\t/* 3c905B-TX */\n\tcase TC_DEVICEID_HURRICANE_10_100BT_SERV:/* 3c980-TX */\n\tcase TC_DEVICEID_TORNADO_10_100BT_SERV:\t/* 3c980C-TX */\n\tcase TC_DEVICEID_HURRICANE_SOHO100TX:\t/* 3cSOHO100-TX */\n\tcase TC_DEVICEID_TORNADO_10_100BT:\t/* 3c905C-TX */\n\tcase TC_DEVICEID_TORNADO_HOMECONNECT:\t/* 3c450-TX */\n\t\tsc->xl_media = XL_MEDIAOPT_BTX;\n\t\tsc->xl_xcvr = XL_XCVR_AUTO;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing 10/100 internal\\n\",\n\t\t\t    sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_CYCLONE_10_100_COMBO:\t/* 3c905B-COMBO */\n\t\tsc->xl_media = XL_MEDIAOPT_BTX|XL_MEDIAOPT_BNC|XL_MEDIAOPT_AUI;\n\t\tsc->xl_xcvr = XL_XCVR_AUTO;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing 10/100 plus BNC/AUI\\n\",\n\t\t\t    sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_3CCFE575_CARDBUS:\n\tcase TC_DEVICEID_3CCFE575BT_CARDBUS:\n\tcase TC_DEVICEID_3CCFE575CT_CARDBUS:\n\t\tsc->xl_media = XL_MEDIAOPT_MII;\n\t\tsc->xl_xcvr = XL_XCVR_MII;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"xl%d: unknown device ID: %x -- \"\n\t\t\t\"defaulting to 10baseT\\n\", sc->xl_unit, devid);\n\t\tsc->xl_media = XL_MEDIAOPT_BT;\n\t\tbreak;\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xl_read_eeprom",
            "void xl_choose_xcvr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint xl_read_eeprom;\nvoid xl_choose_xcvr;\n\nvoid xl_choose_xcvr(sc, verbose)\n\tstruct xl_softc *sc;\n\tint verbose;\n{\n\tu_int16_t devid;\n\n\t/*\n\t * Read the device ID from the EEPROM.\n\t * This is what's loaded into the PCI device ID register, so it has\n\t * to be correct otherwise we wouldn't have gotten this far.\n\t */\n\txl_read_eeprom(sc, (caddr_t)&devid, XL_EE_PRODID, 1, 0);\n\n\tswitch(devid) {\n\tcase TC_DEVICEID_BOOMERANG_10BT:\t/* 3c900-TPO */\n\tcase TC_DEVICEID_KRAKATOA_10BT:\t\t/* 3c900B-TPO */\n\t\tsc->xl_media = XL_MEDIAOPT_BT;\n\t\tsc->xl_xcvr = XL_XCVR_10BT;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing 10BaseT transceiver\\n\",\n\t\t\t    sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_BOOMERANG_10BT_COMBO:\t/* 3c900-COMBO */\n\tcase TC_DEVICEID_KRAKATOA_10BT_COMBO:\t/* 3c900B-COMBO */\n\t\tsc->xl_media = XL_MEDIAOPT_BT|XL_MEDIAOPT_BNC|XL_MEDIAOPT_AUI;\n\t\tsc->xl_xcvr = XL_XCVR_10BT;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing COMBO (AUI/BNC/TP)\\n\",\n\t\t\t    sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_KRAKATOA_10BT_TPC:\t/* 3c900B-TPC */\n\t\tsc->xl_media = XL_MEDIAOPT_BT|XL_MEDIAOPT_BNC;\n\t\tsc->xl_xcvr = XL_XCVR_10BT;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing TPC (BNC/TP)\\n\", sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_CYCLONE_10FL:\t\t/* 3c900B-FL */\n\t\tsc->xl_media = XL_MEDIAOPT_10FL;\n\t\tsc->xl_xcvr = XL_XCVR_AUI;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing 10baseFL\\n\", sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_BOOMERANG_10_100BT:\t/* 3c905-TX */\n\t\tsc->xl_media = XL_MEDIAOPT_MII;\n\t\tsc->xl_xcvr = XL_XCVR_MII;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing MII\\n\", sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_BOOMERANG_100BT4:\t/* 3c905-T4 */\n\tcase TC_DEVICEID_CYCLONE_10_100BT4:\t/* 3c905B-T4 */\n\t\tsc->xl_media = XL_MEDIAOPT_BT4;\n\t\tsc->xl_xcvr = XL_XCVR_MII;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing 100BaseT4/MII\\n\", sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_HURRICANE_10_100BT:\t/* 3c905B-TX */\n\tcase TC_DEVICEID_HURRICANE_10_100BT_SERV:/* 3c980-TX */\n\tcase TC_DEVICEID_TORNADO_10_100BT_SERV:\t/* 3c980C-TX */\n\tcase TC_DEVICEID_HURRICANE_SOHO100TX:\t/* 3cSOHO100-TX */\n\tcase TC_DEVICEID_TORNADO_10_100BT:\t/* 3c905C-TX */\n\tcase TC_DEVICEID_TORNADO_HOMECONNECT:\t/* 3c450-TX */\n\t\tsc->xl_media = XL_MEDIAOPT_BTX;\n\t\tsc->xl_xcvr = XL_XCVR_AUTO;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing 10/100 internal\\n\",\n\t\t\t    sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_CYCLONE_10_100_COMBO:\t/* 3c905B-COMBO */\n\t\tsc->xl_media = XL_MEDIAOPT_BTX|XL_MEDIAOPT_BNC|XL_MEDIAOPT_AUI;\n\t\tsc->xl_xcvr = XL_XCVR_AUTO;\n\t\tif (verbose)\n\t\t\tprintf(\"xl%d: guessing 10/100 plus BNC/AUI\\n\",\n\t\t\t    sc->xl_unit);\n\t\tbreak;\n\tcase TC_DEVICEID_3CCFE575_CARDBUS:\n\tcase TC_DEVICEID_3CCFE575BT_CARDBUS:\n\tcase TC_DEVICEID_3CCFE575CT_CARDBUS:\n\t\tsc->xl_media = XL_MEDIAOPT_MII;\n\t\tsc->xl_xcvr = XL_XCVR_MII;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"xl%d: unknown device ID: %x -- \"\n\t\t\t\"defaulting to 10baseT\\n\", sc->xl_unit, devid);\n\t\tsc->xl_media = XL_MEDIAOPT_BT;\n\t\tbreak;\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"xl%d: attempting to guess media type; you \"\n\t\t\t\"should probably consult your vendor\\n\"",
            "sc->xl_unit"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_mediacheck;\nvoid xl_choose_xcvr;\n\nvoid xl_mediacheck(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\t/*\n\t * If some of the media options bits are set, assume they are\n\t * correct. If not, try to figure it out down below.\n\t * XXX I should check for 10baseFL, but I don't have an adapter\n\t * to test with.\n\t */\n\tif (sc->xl_media & (XL_MEDIAOPT_MASK & ~XL_MEDIAOPT_VCO)) {\n\t\t/*\n\t \t * Check the XCVR value. If it's not in the normal range\n\t \t * of values, we need to fake it up here.\n\t \t */\n\t\tif (sc->xl_xcvr <= XL_XCVR_AUTO)\n\t\t\treturn;\n\t\telse {\n\t\t\tprintf(\"xl%d: bogus xcvr value \"\n\t\t\t\"in EEPROM (%x)\\n\", sc->xl_unit, sc->xl_xcvr);\n\t\t\tprintf(\"xl%d: choosing new default based \"\n\t\t\t\t\"on card type\\n\", sc->xl_unit);\n\t\t}\n\t} else {\n\t\tif (sc->xl_type == XL_TYPE_905B &&\n\t\t    sc->xl_media & XL_MEDIAOPT_10FL)\n\t\t\treturn;\n\t\tprintf(\"xl%d: WARNING: no media options bits set in \"\n\t\t\t\"the media options register!!\\n\", sc->xl_unit);\n\t\tprintf(\"xl%d: this could be a manufacturing defect in \"\n\t\t\t\"your adapter or system\\n\", sc->xl_unit);\n\t\tprintf(\"xl%d: attempting to guess media type; you \"\n\t\t\t\"should probably consult your vendor\\n\", sc->xl_unit);\n\t}\n\n\txl_choose_xcvr(sc, 1);\n}"
  },
  {
    "function_name": "xl_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
    "lines": "831-860",
    "snippet": "void xl_reset(sc, hard)\n\tstruct xl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tXL_SEL_WIN(0);\n\tif (hard)\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RESET);\n\telse\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RESET | 0x0010);\n\txl_wait(sc);\n\n\tfor (i = 0; i < XL_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(CSR_READ_2(sc, XL_STATUS) & XL_STAT_CMDBUSY))\n\t\t\tbreak;\n\t}\n\n\tDELAY(100000);\n\n\t/* Reset TX and RX. */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_RESET);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\txl_wait(sc);\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tDELAY(100000);\n        return;\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void xl_reset",
      "void xl_wait"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "100000"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xl_wait",
          "args": [
            "sc"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "xl_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "200-216",
          "snippet": "void xl_wait(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tfor (i = 0; i < XL_TIMEOUT; i++) {\n\t\tif (!(CSR_READ_2(sc, XL_STATUS) & XL_STAT_CMDBUSY))\n\t\t\tbreak;\n\t}\n\n#ifdef DIAGNOSTIC\n\tif (i == XL_TIMEOUT)\n\t\tprintf(\"xl%d: command never completed!\\n\", sc->xl_unit);\n#endif\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void xl_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_wait;\n\nvoid xl_wait(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tfor (i = 0; i < XL_TIMEOUT; i++) {\n\t\tif (!(CSR_READ_2(sc, XL_STATUS) & XL_STAT_CMDBUSY))\n\t\t\tbreak;\n\t}\n\n#ifdef DIAGNOSTIC\n\tif (i == XL_TIMEOUT)\n\t\tprintf(\"xl%d: command never completed!\\n\", sc->xl_unit);\n#endif\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_TX_RESET"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_RX_RESET"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "100000"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "XL_STATUS"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_RESET | 0x0010"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_RESET"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XL_SEL_WIN",
          "args": [
            "0"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_reset;\nvoid xl_wait;\n\nvoid xl_reset(sc, hard)\n\tstruct xl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tXL_SEL_WIN(0);\n\tif (hard)\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RESET);\n\telse\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RESET | 0x0010);\n\txl_wait(sc);\n\n\tfor (i = 0; i < XL_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(CSR_READ_2(sc, XL_STATUS) & XL_STAT_CMDBUSY))\n\t\t\tbreak;\n\t}\n\n\tDELAY(100000);\n\n\t/* Reset TX and RX. */\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_RESET);\n\txl_wait(sc);\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_TX_RESET);\n\txl_wait(sc);\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tDELAY(100000);\n        return;\n}"
  },
  {
    "function_name": "xl_setmode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
    "lines": "738-829",
    "snippet": "void xl_setmode(sc, media)\n\tstruct xl_softc *sc;\n\tint media;\n{\n\tu_int32_t icfg;\n\tu_int16_t mediastat;\n\n\tprintf(\"xl%d: selecting \", sc->xl_unit);\n\n\tXL_SEL_WIN(4);\n\tmediastat = CSR_READ_2(sc, XL_W4_MEDIA_STATUS);\n\tXL_SEL_WIN(3);\n\ticfg = CSR_READ_4(sc, XL_W3_INTERNAL_CFG);\n\n\tif (sc->xl_media & XL_MEDIAOPT_BT) {\n\t\tif (IFM_SUBTYPE(media) == IFM_10_T) {\n\t\t\tprintf(\"10baseT transceiver, \");\n\t\t\tsc->xl_xcvr = XL_XCVR_10BT;\n\t\t\ticfg &= ~XL_ICFG_CONNECTOR_MASK;\n\t\t\ticfg |= (XL_XCVR_10BT << XL_ICFG_CONNECTOR_BITS);\n\t\t\tmediastat |= XL_MEDIASTAT_LINKBEAT|\n\t\t\t\t\tXL_MEDIASTAT_JABGUARD;\n\t\t\tmediastat &= ~XL_MEDIASTAT_SQEENB;\n\t\t}\n\t}\n\n\tif (sc->xl_media & XL_MEDIAOPT_BFX) {\n\t\tif (IFM_SUBTYPE(media) == IFM_100_FX) {\n\t\t\tprintf(\"100baseFX port, \");\n\t\t\tsc->xl_xcvr = XL_XCVR_100BFX;\n\t\t\ticfg &= ~XL_ICFG_CONNECTOR_MASK;\n\t\t\ticfg |= (XL_XCVR_100BFX << XL_ICFG_CONNECTOR_BITS);\n\t\t\tmediastat |= XL_MEDIASTAT_LINKBEAT;\n\t\t\tmediastat &= ~XL_MEDIASTAT_SQEENB;\n\t\t}\n\t}\n\n\tif (sc->xl_media & (XL_MEDIAOPT_AUI|XL_MEDIAOPT_10FL)) {\n\t\tif (IFM_SUBTYPE(media) == IFM_10_5) {\n\t\t\tprintf(\"AUI port, \");\n\t\t\tsc->xl_xcvr = XL_XCVR_AUI;\n\t\t\ticfg &= ~XL_ICFG_CONNECTOR_MASK;\n\t\t\ticfg |= (XL_XCVR_AUI << XL_ICFG_CONNECTOR_BITS);\n\t\t\tmediastat &= ~(XL_MEDIASTAT_LINKBEAT|\n\t\t\t\t\tXL_MEDIASTAT_JABGUARD);\n\t\t\tmediastat |= ~XL_MEDIASTAT_SQEENB;\n\t\t}\n\t\tif (IFM_SUBTYPE(media) == IFM_10_FL) {\n\t\t\tprintf(\"10baseFL transceiver, \");\n\t\t\tsc->xl_xcvr = XL_XCVR_AUI;\n\t\t\ticfg &= ~XL_ICFG_CONNECTOR_MASK;\n\t\t\ticfg |= (XL_XCVR_AUI << XL_ICFG_CONNECTOR_BITS);\n\t\t\tmediastat &= ~(XL_MEDIASTAT_LINKBEAT|\n\t\t\t\t\tXL_MEDIASTAT_JABGUARD);\n\t\t\tmediastat |= ~XL_MEDIASTAT_SQEENB;\n\t\t}\n\t}\n\n\tif (sc->xl_media & XL_MEDIAOPT_BNC) {\n\t\tif (IFM_SUBTYPE(media) == IFM_10_2) {\n\t\t\tprintf(\"BNC port, \");\n\t\t\tsc->xl_xcvr = XL_XCVR_COAX;\n\t\t\ticfg &= ~XL_ICFG_CONNECTOR_MASK;\n\t\t\ticfg |= (XL_XCVR_COAX << XL_ICFG_CONNECTOR_BITS);\n\t\t\tmediastat &= ~(XL_MEDIASTAT_LINKBEAT|\n\t\t\t\t\tXL_MEDIASTAT_JABGUARD|\n\t\t\t\t\tXL_MEDIASTAT_SQEENB);\n\t\t}\n\t}\n\n\tif ((media & IFM_GMASK) == IFM_FDX ||\n\t\t\tIFM_SUBTYPE(media) == IFM_100_FX) {\n\t\tprintf(\"full duplex\\n\");\n\t\tXL_SEL_WIN(3);\n\t\tCSR_WRITE_1(sc, XL_W3_MAC_CTRL, XL_MACCTRL_DUPLEX);\n\t} else {\n\t\tprintf(\"half duplex\\n\");\n\t\tXL_SEL_WIN(3);\n\t\tCSR_WRITE_1(sc, XL_W3_MAC_CTRL,\n\t\t\t(CSR_READ_1(sc, XL_W3_MAC_CTRL) & ~XL_MACCTRL_DUPLEX));\n\t}\n\n\tif (IFM_SUBTYPE(media) == IFM_10_2)\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_START);\n\telse\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_STOP);\n\tCSR_WRITE_4(sc, XL_W3_INTERNAL_CFG, icfg);\n\tXL_SEL_WIN(4);\n\tCSR_WRITE_2(sc, XL_W4_MEDIA_STATUS, mediastat);\n\tDELAY(800);\n\tXL_SEL_WIN(7);\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void xl_setmode"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XL_SEL_WIN",
          "args": [
            "7"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "800"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_W4_MEDIA_STATUS",
            "mediastat"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XL_SEL_WIN",
          "args": [
            "4"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "XL_W3_INTERNAL_CFG",
            "icfg"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_COAX_STOP"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_COAX_START"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "media"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_1",
          "args": [
            "sc",
            "XL_W3_MAC_CTRL",
            "(CSR_READ_1(sc, XL_W3_MAC_CTRL) & ~XL_MACCTRL_DUPLEX)"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_1",
          "args": [
            "sc",
            "XL_W3_MAC_CTRL"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XL_SEL_WIN",
          "args": [
            "3"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"half duplex\\n\""
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_1",
          "args": [
            "sc",
            "XL_W3_MAC_CTRL",
            "XL_MACCTRL_DUPLEX"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XL_SEL_WIN",
          "args": [
            "3"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "media"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "media"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "media"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "media"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "media"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "media"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "XL_W3_INTERNAL_CFG"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XL_SEL_WIN",
          "args": [
            "3"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "XL_W4_MEDIA_STATUS"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XL_SEL_WIN",
          "args": [
            "4"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_setmode;\n\nvoid xl_setmode(sc, media)\n\tstruct xl_softc *sc;\n\tint media;\n{\n\tu_int32_t icfg;\n\tu_int16_t mediastat;\n\n\tprintf(\"xl%d: selecting \", sc->xl_unit);\n\n\tXL_SEL_WIN(4);\n\tmediastat = CSR_READ_2(sc, XL_W4_MEDIA_STATUS);\n\tXL_SEL_WIN(3);\n\ticfg = CSR_READ_4(sc, XL_W3_INTERNAL_CFG);\n\n\tif (sc->xl_media & XL_MEDIAOPT_BT) {\n\t\tif (IFM_SUBTYPE(media) == IFM_10_T) {\n\t\t\tprintf(\"10baseT transceiver, \");\n\t\t\tsc->xl_xcvr = XL_XCVR_10BT;\n\t\t\ticfg &= ~XL_ICFG_CONNECTOR_MASK;\n\t\t\ticfg |= (XL_XCVR_10BT << XL_ICFG_CONNECTOR_BITS);\n\t\t\tmediastat |= XL_MEDIASTAT_LINKBEAT|\n\t\t\t\t\tXL_MEDIASTAT_JABGUARD;\n\t\t\tmediastat &= ~XL_MEDIASTAT_SQEENB;\n\t\t}\n\t}\n\n\tif (sc->xl_media & XL_MEDIAOPT_BFX) {\n\t\tif (IFM_SUBTYPE(media) == IFM_100_FX) {\n\t\t\tprintf(\"100baseFX port, \");\n\t\t\tsc->xl_xcvr = XL_XCVR_100BFX;\n\t\t\ticfg &= ~XL_ICFG_CONNECTOR_MASK;\n\t\t\ticfg |= (XL_XCVR_100BFX << XL_ICFG_CONNECTOR_BITS);\n\t\t\tmediastat |= XL_MEDIASTAT_LINKBEAT;\n\t\t\tmediastat &= ~XL_MEDIASTAT_SQEENB;\n\t\t}\n\t}\n\n\tif (sc->xl_media & (XL_MEDIAOPT_AUI|XL_MEDIAOPT_10FL)) {\n\t\tif (IFM_SUBTYPE(media) == IFM_10_5) {\n\t\t\tprintf(\"AUI port, \");\n\t\t\tsc->xl_xcvr = XL_XCVR_AUI;\n\t\t\ticfg &= ~XL_ICFG_CONNECTOR_MASK;\n\t\t\ticfg |= (XL_XCVR_AUI << XL_ICFG_CONNECTOR_BITS);\n\t\t\tmediastat &= ~(XL_MEDIASTAT_LINKBEAT|\n\t\t\t\t\tXL_MEDIASTAT_JABGUARD);\n\t\t\tmediastat |= ~XL_MEDIASTAT_SQEENB;\n\t\t}\n\t\tif (IFM_SUBTYPE(media) == IFM_10_FL) {\n\t\t\tprintf(\"10baseFL transceiver, \");\n\t\t\tsc->xl_xcvr = XL_XCVR_AUI;\n\t\t\ticfg &= ~XL_ICFG_CONNECTOR_MASK;\n\t\t\ticfg |= (XL_XCVR_AUI << XL_ICFG_CONNECTOR_BITS);\n\t\t\tmediastat &= ~(XL_MEDIASTAT_LINKBEAT|\n\t\t\t\t\tXL_MEDIASTAT_JABGUARD);\n\t\t\tmediastat |= ~XL_MEDIASTAT_SQEENB;\n\t\t}\n\t}\n\n\tif (sc->xl_media & XL_MEDIAOPT_BNC) {\n\t\tif (IFM_SUBTYPE(media) == IFM_10_2) {\n\t\t\tprintf(\"BNC port, \");\n\t\t\tsc->xl_xcvr = XL_XCVR_COAX;\n\t\t\ticfg &= ~XL_ICFG_CONNECTOR_MASK;\n\t\t\ticfg |= (XL_XCVR_COAX << XL_ICFG_CONNECTOR_BITS);\n\t\t\tmediastat &= ~(XL_MEDIASTAT_LINKBEAT|\n\t\t\t\t\tXL_MEDIASTAT_JABGUARD|\n\t\t\t\t\tXL_MEDIASTAT_SQEENB);\n\t\t}\n\t}\n\n\tif ((media & IFM_GMASK) == IFM_FDX ||\n\t\t\tIFM_SUBTYPE(media) == IFM_100_FX) {\n\t\tprintf(\"full duplex\\n\");\n\t\tXL_SEL_WIN(3);\n\t\tCSR_WRITE_1(sc, XL_W3_MAC_CTRL, XL_MACCTRL_DUPLEX);\n\t} else {\n\t\tprintf(\"half duplex\\n\");\n\t\tXL_SEL_WIN(3);\n\t\tCSR_WRITE_1(sc, XL_W3_MAC_CTRL,\n\t\t\t(CSR_READ_1(sc, XL_W3_MAC_CTRL) & ~XL_MACCTRL_DUPLEX));\n\t}\n\n\tif (IFM_SUBTYPE(media) == IFM_10_2)\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_START);\n\telse\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_COAX_STOP);\n\tCSR_WRITE_4(sc, XL_W3_INTERNAL_CFG, icfg);\n\tXL_SEL_WIN(4);\n\tCSR_WRITE_2(sc, XL_W4_MEDIA_STATUS, mediastat);\n\tDELAY(800);\n\tXL_SEL_WIN(7);\n}"
  },
  {
    "function_name": "xl_setcfg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
    "lines": "720-736",
    "snippet": "void xl_setcfg(sc)\n\tstruct xl_softc *sc;\n{\n\tu_int32_t icfg;\n\n\tXL_SEL_WIN(3);\n\ticfg = CSR_READ_4(sc, XL_W3_INTERNAL_CFG);\n\ticfg &= ~XL_ICFG_CONNECTOR_MASK;\n\tif (sc->xl_media & XL_MEDIAOPT_MII ||\n\t    sc->xl_media & XL_MEDIAOPT_BT4)\n\t\ticfg |= (XL_XCVR_MII << XL_ICFG_CONNECTOR_BITS);\n\tif (sc->xl_media & XL_MEDIAOPT_BTX)\n\t\ticfg |= (XL_XCVR_AUTO << XL_ICFG_CONNECTOR_BITS);\n\n\tCSR_WRITE_4(sc, XL_W3_INTERNAL_CFG, icfg);\n\tCSR_WRITE_4(sc, XL_COMMAND, XL_CMD_COAX_STOP);\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void xl_setcfg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_COAX_STOP"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "XL_W3_INTERNAL_CFG",
            "icfg"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "XL_W3_INTERNAL_CFG"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XL_SEL_WIN",
          "args": [
            "3"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_setcfg;\n\nvoid xl_setcfg(sc)\n\tstruct xl_softc *sc;\n{\n\tu_int32_t icfg;\n\n\tXL_SEL_WIN(3);\n\ticfg = CSR_READ_4(sc, XL_W3_INTERNAL_CFG);\n\ticfg &= ~XL_ICFG_CONNECTOR_MASK;\n\tif (sc->xl_media & XL_MEDIAOPT_MII ||\n\t    sc->xl_media & XL_MEDIAOPT_BT4)\n\t\ticfg |= (XL_XCVR_MII << XL_ICFG_CONNECTOR_BITS);\n\tif (sc->xl_media & XL_MEDIAOPT_BTX)\n\t\ticfg |= (XL_XCVR_AUTO << XL_ICFG_CONNECTOR_BITS);\n\n\tCSR_WRITE_4(sc, XL_W3_INTERNAL_CFG, icfg);\n\tCSR_WRITE_4(sc, XL_COMMAND, XL_CMD_COAX_STOP);\n}"
  },
  {
    "function_name": "xl_testpacket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
    "lines": "691-717",
    "snippet": "void xl_testpacket(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tstruct mbuf\t\t*m;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\n\tif (m == NULL)\n\t\treturn;\n\n\tbcopy(&sc->arpcom.ac_enaddr,\n\t\tmtod(m, struct ether_header *)->ether_dhost, ETHER_ADDR_LEN);\n\tbcopy(&sc->arpcom.ac_enaddr,\n\t\tmtod(m, struct ether_header *)->ether_shost, ETHER_ADDR_LEN);\n\tmtod(m, struct ether_header *)->ether_type = htons(3);\n\tmtod(m, unsigned char *)[14] = 0;\n\tmtod(m, unsigned char *)[15] = 0;\n\tmtod(m, unsigned char *)[16] = 0xE3;\n\tm->m_len = m->m_pkthdr.len = sizeof(struct ether_header) + 3;\n\tIF_ENQUEUE(&ifp->if_snd, m);\n\txl_start(ifp);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void xl_start"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xl_start",
          "args": [
            "ifp"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "xl_start_90xB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "1768-1842",
          "snippet": "void\nxl_start_90xB(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct xl_softc *sc;\n\tstruct mbuf *m_head = NULL;\n\tstruct xl_chain *prev = NULL, *cur_tx = NULL, *start_tx;\n\tint idx;\n\n\tsc = ifp->if_softc;\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\tidx = sc->xl_cdata.xl_tx_prod;\n\tstart_tx = &sc->xl_cdata.xl_tx_chain[idx];\n\n\twhile (sc->xl_cdata.xl_tx_chain[idx].xl_mbuf == NULL) {\n\n\t\tif ((XL_TX_LIST_CNT - sc->xl_cdata.xl_tx_cnt) < 3) {\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tbreak;\n\t\t}\n\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\tcur_tx = &sc->xl_cdata.xl_tx_chain[idx];\n\n\t\t/* Pack the data into the descriptor. */\n\t\txl_encap_90xB(sc, cur_tx, m_head);\n\n\t\t/* Chain it together. */\n\t\tif (prev != NULL)\n\t\t\tprev->xl_ptr->xl_next = cur_tx->xl_phys;\n\t\tprev = cur_tx;\n\n#if NBPFILTER > 0\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, cur_tx->xl_mbuf);\n#endif\n\n\t\tXL_INC(idx, XL_TX_LIST_CNT);\n\t\tsc->xl_cdata.xl_tx_cnt++;\n\t}\n\n\t/*\n\t * If there are no packets queued, bail.\n\t */\n\tif (cur_tx == NULL)\n\t\treturn;\n\n\t/*\n\t * Place the request for the upload interrupt\n\t * in the last descriptor in the chain. This way, if\n\t * we're chaining several packets at once, we'll only\n\t * get an interupt once for the whole chain rather than\n\t * once for each packet.\n\t */\n\tcur_tx->xl_ptr->xl_status |= XL_TXSTAT_DL_INTR;\n\n\t/* Start transmission */\n\tsc->xl_cdata.xl_tx_prod = idx;\n\tstart_tx->xl_prev->xl_ptr->xl_next = start_tx->xl_phys;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xl_encap_90xB",
            "void xl_start_90xB"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint xl_encap_90xB;\nvoid xl_start_90xB;\n\nvoid\nxl_start_90xB(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct xl_softc *sc;\n\tstruct mbuf *m_head = NULL;\n\tstruct xl_chain *prev = NULL, *cur_tx = NULL, *start_tx;\n\tint idx;\n\n\tsc = ifp->if_softc;\n\n\tif (ifp->if_flags & IFF_OACTIVE)\n\t\treturn;\n\n\tidx = sc->xl_cdata.xl_tx_prod;\n\tstart_tx = &sc->xl_cdata.xl_tx_chain[idx];\n\n\twhile (sc->xl_cdata.xl_tx_chain[idx].xl_mbuf == NULL) {\n\n\t\tif ((XL_TX_LIST_CNT - sc->xl_cdata.xl_tx_cnt) < 3) {\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tbreak;\n\t\t}\n\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\tcur_tx = &sc->xl_cdata.xl_tx_chain[idx];\n\n\t\t/* Pack the data into the descriptor. */\n\t\txl_encap_90xB(sc, cur_tx, m_head);\n\n\t\t/* Chain it together. */\n\t\tif (prev != NULL)\n\t\t\tprev->xl_ptr->xl_next = cur_tx->xl_phys;\n\t\tprev = cur_tx;\n\n#if NBPFILTER > 0\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, cur_tx->xl_mbuf);\n#endif\n\n\t\tXL_INC(idx, XL_TX_LIST_CNT);\n\t\tsc->xl_cdata.xl_tx_cnt++;\n\t}\n\n\t/*\n\t * If there are no packets queued, bail.\n\t */\n\tif (cur_tx == NULL)\n\t\treturn;\n\n\t/*\n\t * Place the request for the upload interrupt\n\t * in the last descriptor in the chain. This way, if\n\t * we're chaining several packets at once, we'll only\n\t * get an interupt once for the whole chain rather than\n\t * once for each packet.\n\t */\n\tcur_tx->xl_ptr->xl_status |= XL_TXSTAT_DL_INTR;\n\n\t/* Start transmission */\n\tsc->xl_cdata.xl_tx_prod = idx;\n\tstart_tx->xl_prev->xl_ptr->xl_next = start_tx->xl_phys;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IF_ENQUEUE",
          "args": [
            "&ifp->if_snd",
            "m"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "unsignedchar *"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "unsignedchar *"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "unsignedchar *"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "3"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "structether_header*"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "&sc->arpcom.ac_enaddr",
            "mtod(m, struct ether_header *)->ether_shost",
            "ETHER_ADDR_LEN"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "structether_header*"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "structether_header*"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGETHDR",
          "args": [
            "m",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_start;\n\nvoid xl_testpacket(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tstruct mbuf\t\t*m;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\n\tif (m == NULL)\n\t\treturn;\n\n\tbcopy(&sc->arpcom.ac_enaddr,\n\t\tmtod(m, struct ether_header *)->ether_dhost, ETHER_ADDR_LEN);\n\tbcopy(&sc->arpcom.ac_enaddr,\n\t\tmtod(m, struct ether_header *)->ether_shost, ETHER_ADDR_LEN);\n\tmtod(m, struct ether_header *)->ether_type = htons(3);\n\tmtod(m, unsigned char *)[14] = 0;\n\tmtod(m, unsigned char *)[15] = 0;\n\tmtod(m, unsigned char *)[16] = 0xE3;\n\tm->m_len = m->m_pkthdr.len = sizeof(struct ether_header) + 3;\n\tIF_ENQUEUE(&ifp->if_snd, m);\n\txl_start(ifp);\n\n\treturn;\n}"
  },
  {
    "function_name": "xl_setmulti_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
    "lines": "639-688",
    "snippet": "void xl_setmulti_hash(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\th = 0, i;\n\tstruct arpcom *ac = &sc->arpcom;\n\tstruct ether_multi *enm;\n\tstruct ether_multistep step;\n\tu_int8_t\t\trxfilt;\n\tint\t\t\tmcnt = 0;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tXL_SEL_WIN(5);\n\trxfilt = CSR_READ_1(sc, XL_W5_RX_FILTER);\n\n\tif (ifp->if_flags & IFF_ALLMULTI) {\nallmulti:\n\t\trxfilt |= XL_RXFILTER_ALLMULTI;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t\treturn;\n\t} else\n\t\trxfilt &= ~XL_RXFILTER_ALLMULTI;\n\n\n\t/* first, zot all the existing hash bits */\n\tfor (i = 0; i < XL_HASHFILT_SIZE; i++)\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_HASH|i);\n\n\t/* now program new ones */\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {\n\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\tgoto allmulti;\n\t\t}\n\t\th = xl_calchash(enm->enm_addrlo);\n\t\tmcnt++;\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\n\tif (mcnt)\n\t\trxfilt |= XL_RXFILTER_MULTIHASH;\n\telse\n\t\trxfilt &= ~XL_RXFILTER_MULTIHASH;\n\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "u_int8_t xl_calchash",
      "void xl_setmulti_hash"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_RX_SET_FILT|rxfilt"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ETHER_NEXT_MULTI",
          "args": [
            "step",
            "enm"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xl_calchash",
          "args": [
            "enm->enm_addrlo"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "xl_calchash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "570-593",
          "snippet": "u_int8_t xl_calchash(addr)\n\tcaddr_t\t\t\taddr;\n{\n\tu_int32_t\t\tcrc, carry;\n\tint\t\t\ti, j;\n\tu_int8_t\t\tc;\n\n\t/* Compute CRC for the address value. */\n\tcrc = 0xFFFFFFFF; /* initial value */\n\n\tfor (i = 0; i < 6; i++) {\n\t\tc = *(addr + i);\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tcarry = ((crc & 0x80000000) ? 1 : 0) ^ (c & 0x01);\n\t\t\tcrc <<= 1;\n\t\t\tc >>= 1;\n\t\t\tif (carry)\n\t\t\t\tcrc = (crc ^ 0x04c11db6) | carry;\n\t\t}\n\t}\n\n\t/* return the filter bit position */\n\treturn(crc & 0x000000FF);\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int8_t xl_calchash"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int8_t xl_calchash;\n\nu_int8_t xl_calchash(addr)\n\tcaddr_t\t\t\taddr;\n{\n\tu_int32_t\t\tcrc, carry;\n\tint\t\t\ti, j;\n\tu_int8_t\t\tc;\n\n\t/* Compute CRC for the address value. */\n\tcrc = 0xFFFFFFFF; /* initial value */\n\n\tfor (i = 0; i < 6; i++) {\n\t\tc = *(addr + i);\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tcarry = ((crc & 0x80000000) ? 1 : 0) ^ (c & 0x01);\n\t\t\tcrc <<= 1;\n\t\t\tc >>= 1;\n\t\t\tif (carry)\n\t\t\t\tcrc = (crc ^ 0x04c11db6) | carry;\n\t\t}\n\t}\n\n\t/* return the filter bit position */\n\treturn(crc & 0x000000FF);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "enm->enm_addrlo",
            "enm->enm_addrhi",
            "ETHER_ADDR_LEN"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ETHER_FIRST_MULTI",
          "args": [
            "step",
            "ac",
            "enm"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_RX_SET_HASH|i"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_RX_SET_FILT|rxfilt"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_1",
          "args": [
            "sc",
            "XL_W5_RX_FILTER"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XL_SEL_WIN",
          "args": [
            "5"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int8_t xl_calchash;\nvoid xl_setmulti_hash;\n\nvoid xl_setmulti_hash(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\th = 0, i;\n\tstruct arpcom *ac = &sc->arpcom;\n\tstruct ether_multi *enm;\n\tstruct ether_multistep step;\n\tu_int8_t\t\trxfilt;\n\tint\t\t\tmcnt = 0;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tXL_SEL_WIN(5);\n\trxfilt = CSR_READ_1(sc, XL_W5_RX_FILTER);\n\n\tif (ifp->if_flags & IFF_ALLMULTI) {\nallmulti:\n\t\trxfilt |= XL_RXFILTER_ALLMULTI;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t\treturn;\n\t} else\n\t\trxfilt &= ~XL_RXFILTER_ALLMULTI;\n\n\n\t/* first, zot all the existing hash bits */\n\tfor (i = 0; i < XL_HASHFILT_SIZE; i++)\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_HASH|i);\n\n\t/* now program new ones */\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {\n\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\tgoto allmulti;\n\t\t}\n\t\th = xl_calchash(enm->enm_addrlo);\n\t\tmcnt++;\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\n\tif (mcnt)\n\t\trxfilt |= XL_RXFILTER_MULTIHASH;\n\telse\n\t\trxfilt &= ~XL_RXFILTER_MULTIHASH;\n\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\n\treturn;\n}"
  },
  {
    "function_name": "xl_setmulti",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
    "lines": "599-634",
    "snippet": "void xl_setmulti(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tstruct arpcom *ac = &sc->arpcom;\n\tstruct ether_multi *enm;\n\tstruct ether_multistep step;\n\tu_int8_t\t\trxfilt;\n\tint\t\t\tmcnt = 0;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tXL_SEL_WIN(5);\n\trxfilt = CSR_READ_1(sc, XL_W5_RX_FILTER);\n\n\tif (ifp->if_flags & IFF_ALLMULTI) {\n\t\trxfilt |= XL_RXFILTER_ALLMULTI;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t\treturn;\n\t}\n\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\tmcnt++;\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\n\tif (mcnt)\n\t\trxfilt |= XL_RXFILTER_ALLMULTI;\n\telse\n\t\trxfilt &= ~XL_RXFILTER_ALLMULTI;\n\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void xl_setmulti"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_RX_SET_FILT|rxfilt"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ETHER_NEXT_MULTI",
          "args": [
            "step",
            "enm"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ETHER_FIRST_MULTI",
          "args": [
            "step",
            "ac",
            "enm"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_COMMAND",
            "XL_CMD_RX_SET_FILT|rxfilt"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_1",
          "args": [
            "sc",
            "XL_W5_RX_FILTER"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XL_SEL_WIN",
          "args": [
            "5"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_setmulti;\n\nvoid xl_setmulti(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tstruct arpcom *ac = &sc->arpcom;\n\tstruct ether_multi *enm;\n\tstruct ether_multistep step;\n\tu_int8_t\t\trxfilt;\n\tint\t\t\tmcnt = 0;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tXL_SEL_WIN(5);\n\trxfilt = CSR_READ_1(sc, XL_W5_RX_FILTER);\n\n\tif (ifp->if_flags & IFF_ALLMULTI) {\n\t\trxfilt |= XL_RXFILTER_ALLMULTI;\n\t\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\t\treturn;\n\t}\n\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\tmcnt++;\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\n\tif (mcnt)\n\t\trxfilt |= XL_RXFILTER_ALLMULTI;\n\telse\n\t\trxfilt &= ~XL_RXFILTER_ALLMULTI;\n\n\tCSR_WRITE_2(sc, XL_COMMAND, XL_CMD_RX_SET_FILT|rxfilt);\n\n\treturn;\n}"
  },
  {
    "function_name": "xl_calchash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
    "lines": "570-593",
    "snippet": "u_int8_t xl_calchash(addr)\n\tcaddr_t\t\t\taddr;\n{\n\tu_int32_t\t\tcrc, carry;\n\tint\t\t\ti, j;\n\tu_int8_t\t\tc;\n\n\t/* Compute CRC for the address value. */\n\tcrc = 0xFFFFFFFF; /* initial value */\n\n\tfor (i = 0; i < 6; i++) {\n\t\tc = *(addr + i);\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tcarry = ((crc & 0x80000000) ? 1 : 0) ^ (c & 0x01);\n\t\t\tcrc <<= 1;\n\t\t\tc >>= 1;\n\t\t\tif (carry)\n\t\t\t\tcrc = (crc ^ 0x04c11db6) | carry;\n\t\t}\n\t}\n\n\t/* return the filter bit position */\n\treturn(crc & 0x000000FF);\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "u_int8_t xl_calchash"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int8_t xl_calchash;\n\nu_int8_t xl_calchash(addr)\n\tcaddr_t\t\t\taddr;\n{\n\tu_int32_t\t\tcrc, carry;\n\tint\t\t\ti, j;\n\tu_int8_t\t\tc;\n\n\t/* Compute CRC for the address value. */\n\tcrc = 0xFFFFFFFF; /* initial value */\n\n\tfor (i = 0; i < 6; i++) {\n\t\tc = *(addr + i);\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tcarry = ((crc & 0x80000000) ? 1 : 0) ^ (c & 0x01);\n\t\t\tcrc <<= 1;\n\t\t\tc >>= 1;\n\t\t\tif (carry)\n\t\t\t\tcrc = (crc ^ 0x04c11db6) | carry;\n\t\t}\n\t}\n\n\t/* return the filter bit position */\n\treturn(crc & 0x000000FF);\n}"
  },
  {
    "function_name": "xl_read_eeprom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
    "lines": "518-554",
    "snippet": "int xl_read_eeprom(sc, dest, off, cnt, swap)\n\tstruct xl_softc\t\t*sc;\n\tcaddr_t\t\t\tdest;\n\tint\t\t\toff;\n\tint\t\t\tcnt;\n\tint\t\t\tswap;\n{\n\tint\t\t\terr = 0, i;\n\tu_int16_t\t\tword = 0, *ptr;\n\n\tXL_SEL_WIN(0);\n\n\tif (xl_eeprom_wait(sc))\n\t\treturn(1);\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tswitch (sc->xl_bustype) {\n\t\tcase XL_BUS_PCI:\n\t\t\tCSR_WRITE_2(sc, XL_W0_EE_CMD, XL_EE_READ | (off + i));\n\t\t\tbreak;\n\t\tcase XL_BUS_CARDBUS:\n\t\t\tCSR_WRITE_2(sc, XL_W0_EE_CMD, 0x230 + (off + i));\n\t\t\tbreak;\n\t\t}\n\t\terr = xl_eeprom_wait(sc);\n\t\tif (err)\n\t\t\tbreak;\n\t\tword = CSR_READ_2(sc, XL_W0_EE_DATA);\n\t\tptr = (u_int16_t *)(dest + (i * 2));\n\t\tif (swap)\n\t\t\t*ptr = ntohs(word);\n\t\telse\n\t\t\t*ptr = word;\t\n\t}\n\n\treturn(err ? 1 : 0);\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int xl_eeprom_wait",
      "int xl_read_eeprom"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "word"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "XL_W0_EE_DATA"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xl_eeprom_wait",
          "args": [
            "sc"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "xl_eeprom_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "494-512",
          "snippet": "int xl_eeprom_wait(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < 100; i++) {\n\t\tif (CSR_READ_2(sc, XL_W0_EE_CMD) & XL_EE_BUSY)\n\t\t\tDELAY(162);\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (i == 100) {\n\t\tprintf(\"xl%d: eeprom failed to come ready\\n\", sc->xl_unit);\n\t\treturn(1);\n\t}\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int xl_eeprom_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint xl_eeprom_wait;\n\nint xl_eeprom_wait(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < 100; i++) {\n\t\tif (CSR_READ_2(sc, XL_W0_EE_CMD) & XL_EE_BUSY)\n\t\t\tDELAY(162);\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (i == 100) {\n\t\tprintf(\"xl%d: eeprom failed to come ready\\n\", sc->xl_unit);\n\t\treturn(1);\n\t}\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_W0_EE_CMD",
            "0x230 + (off + i)"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_W0_EE_CMD",
            "XL_EE_READ | (off + i)"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XL_SEL_WIN",
          "args": [
            "0"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint xl_eeprom_wait;\nint xl_read_eeprom;\n\nint xl_read_eeprom(sc, dest, off, cnt, swap)\n\tstruct xl_softc\t\t*sc;\n\tcaddr_t\t\t\tdest;\n\tint\t\t\toff;\n\tint\t\t\tcnt;\n\tint\t\t\tswap;\n{\n\tint\t\t\terr = 0, i;\n\tu_int16_t\t\tword = 0, *ptr;\n\n\tXL_SEL_WIN(0);\n\n\tif (xl_eeprom_wait(sc))\n\t\treturn(1);\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tswitch (sc->xl_bustype) {\n\t\tcase XL_BUS_PCI:\n\t\t\tCSR_WRITE_2(sc, XL_W0_EE_CMD, XL_EE_READ | (off + i));\n\t\t\tbreak;\n\t\tcase XL_BUS_CARDBUS:\n\t\t\tCSR_WRITE_2(sc, XL_W0_EE_CMD, 0x230 + (off + i));\n\t\t\tbreak;\n\t\t}\n\t\terr = xl_eeprom_wait(sc);\n\t\tif (err)\n\t\t\tbreak;\n\t\tword = CSR_READ_2(sc, XL_W0_EE_DATA);\n\t\tptr = (u_int16_t *)(dest + (i * 2));\n\t\tif (swap)\n\t\t\t*ptr = ntohs(word);\n\t\telse\n\t\t\t*ptr = word;\t\n\t}\n\n\treturn(err ? 1 : 0);\n}"
  },
  {
    "function_name": "xl_eeprom_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
    "lines": "494-512",
    "snippet": "int xl_eeprom_wait(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < 100; i++) {\n\t\tif (CSR_READ_2(sc, XL_W0_EE_CMD) & XL_EE_BUSY)\n\t\t\tDELAY(162);\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (i == 100) {\n\t\tprintf(\"xl%d: eeprom failed to come ready\\n\", sc->xl_unit);\n\t\treturn(1);\n\t}\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int xl_eeprom_wait"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"xl%d: eeprom failed to come ready\\n\"",
            "sc->xl_unit"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "162"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "XL_W0_EE_CMD"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint xl_eeprom_wait;\n\nint xl_eeprom_wait(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < 100; i++) {\n\t\tif (CSR_READ_2(sc, XL_W0_EE_CMD) & XL_EE_BUSY)\n\t\t\tDELAY(162);\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (i == 100) {\n\t\tprintf(\"xl%d: eeprom failed to come ready\\n\", sc->xl_unit);\n\t\treturn(1);\n\t}\n\n\treturn(0);\n}"
  },
  {
    "function_name": "xl_miibus_statchg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
    "lines": "474-488",
    "snippet": "void\nxl_miibus_statchg(self)\n\tstruct device *self;\n{\n\tstruct xl_softc *sc = (struct xl_softc *)self;\n\n\txl_setcfg(sc);\n\n\tXL_SEL_WIN(3);\n\tif ((sc->sc_mii.mii_media_active & IFM_GMASK) == IFM_FDX)\n\t\tCSR_WRITE_1(sc, XL_W3_MAC_CTRL, XL_MACCTRL_DUPLEX);\n\telse\n\t\tCSR_WRITE_1(sc, XL_W3_MAC_CTRL,\n\t\t    (CSR_READ_1(sc, XL_W3_MAC_CTRL) & ~XL_MACCTRL_DUPLEX));\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void xl_setcfg",
      "void xl_miibus_statchg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_1",
          "args": [
            "sc",
            "XL_W3_MAC_CTRL",
            "(CSR_READ_1(sc, XL_W3_MAC_CTRL) & ~XL_MACCTRL_DUPLEX)"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_1",
          "args": [
            "sc",
            "XL_W3_MAC_CTRL"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_1",
          "args": [
            "sc",
            "XL_W3_MAC_CTRL",
            "XL_MACCTRL_DUPLEX"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XL_SEL_WIN",
          "args": [
            "3"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xl_setcfg",
          "args": [
            "sc"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "xl_setcfg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "720-736",
          "snippet": "void xl_setcfg(sc)\n\tstruct xl_softc *sc;\n{\n\tu_int32_t icfg;\n\n\tXL_SEL_WIN(3);\n\ticfg = CSR_READ_4(sc, XL_W3_INTERNAL_CFG);\n\ticfg &= ~XL_ICFG_CONNECTOR_MASK;\n\tif (sc->xl_media & XL_MEDIAOPT_MII ||\n\t    sc->xl_media & XL_MEDIAOPT_BT4)\n\t\ticfg |= (XL_XCVR_MII << XL_ICFG_CONNECTOR_BITS);\n\tif (sc->xl_media & XL_MEDIAOPT_BTX)\n\t\ticfg |= (XL_XCVR_AUTO << XL_ICFG_CONNECTOR_BITS);\n\n\tCSR_WRITE_4(sc, XL_W3_INTERNAL_CFG, icfg);\n\tCSR_WRITE_4(sc, XL_COMMAND, XL_CMD_COAX_STOP);\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void xl_setcfg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_setcfg;\n\nvoid xl_setcfg(sc)\n\tstruct xl_softc *sc;\n{\n\tu_int32_t icfg;\n\n\tXL_SEL_WIN(3);\n\ticfg = CSR_READ_4(sc, XL_W3_INTERNAL_CFG);\n\ticfg &= ~XL_ICFG_CONNECTOR_MASK;\n\tif (sc->xl_media & XL_MEDIAOPT_MII ||\n\t    sc->xl_media & XL_MEDIAOPT_BT4)\n\t\ticfg |= (XL_XCVR_MII << XL_ICFG_CONNECTOR_BITS);\n\tif (sc->xl_media & XL_MEDIAOPT_BTX)\n\t\ticfg |= (XL_XCVR_AUTO << XL_ICFG_CONNECTOR_BITS);\n\n\tCSR_WRITE_4(sc, XL_W3_INTERNAL_CFG, icfg);\n\tCSR_WRITE_4(sc, XL_COMMAND, XL_CMD_COAX_STOP);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_setcfg;\nvoid xl_miibus_statchg;\n\nvoid\nxl_miibus_statchg(self)\n\tstruct device *self;\n{\n\tstruct xl_softc *sc = (struct xl_softc *)self;\n\n\txl_setcfg(sc);\n\n\tXL_SEL_WIN(3);\n\tif ((sc->sc_mii.mii_media_active & IFM_GMASK) == IFM_FDX)\n\t\tCSR_WRITE_1(sc, XL_W3_MAC_CTRL, XL_MACCTRL_DUPLEX);\n\telse\n\t\tCSR_WRITE_1(sc, XL_W3_MAC_CTRL,\n\t\t    (CSR_READ_1(sc, XL_W3_MAC_CTRL) & ~XL_MACCTRL_DUPLEX));\n}"
  },
  {
    "function_name": "xl_miibus_writereg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
    "lines": "454-472",
    "snippet": "void\nxl_miibus_writereg(self, phy, reg, data)\n\tstruct device *self;\n\tint phy, reg, data;\n{\n\tstruct xl_softc *sc = (struct xl_softc *)self;\n\tstruct xl_mii_frame\tframe;\n\n\tif (sc->xl_bustype != XL_BUS_CARDBUS && phy != 24)\n\t\treturn;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = phy;\n\tframe.mii_regaddr = reg;\n\tframe.mii_data = data;\n\n\txl_mii_writereg(sc, &frame);\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int xl_mii_writereg",
      "void xl_miibus_writereg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xl_mii_writereg",
          "args": [
            "sc",
            "&frame"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "xl_mii_writereg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "383-432",
          "snippet": "int xl_mii_writereg(sc, frame)\n\tstruct xl_softc\t\t*sc;\n\tstruct xl_mii_frame\t*frame;\n\t\n{\n\tint\t\t\ts;\n\n\ts = splimp();\n\t/*\n\t * Set up frame for TX.\n\t */\n\n\tframe->mii_stdelim = XL_MII_STARTDELIM;\n\tframe->mii_opcode = XL_MII_WRITEOP;\n\tframe->mii_turnaround = XL_MII_TURNAROUND;\n\t\n\t/*\n\t * Select the window 4.\n\t */\n\tXL_SEL_WIN(4);\n\n\t/*\n \t * Turn on data output.\n\t */\n\tMII_SET(XL_MII_DIR);\n\n\txl_mii_sync(sc);\n\n\txl_mii_send(sc, frame->mii_stdelim, 2);\n\txl_mii_send(sc, frame->mii_opcode, 2);\n\txl_mii_send(sc, frame->mii_phyaddr, 5);\n\txl_mii_send(sc, frame->mii_regaddr, 5);\n\txl_mii_send(sc, frame->mii_turnaround, 2);\n\txl_mii_send(sc, frame->mii_data, 16);\n\n\t/* Idle bit. */\n\tMII_SET(XL_MII_CLK);\n\tDELAY(1);\n\tMII_CLR(XL_MII_CLK);\n\tDELAY(1);\n\n\t/*\n\t * Turn off xmit.\n\t */\n\tMII_CLR(XL_MII_DIR);\n\n\tsplx(s);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void xl_mii_sync",
            "void xl_mii_send",
            "int xl_mii_writereg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_mii_sync;\nvoid xl_mii_send;\nint xl_mii_writereg;\n\nint xl_mii_writereg(sc, frame)\n\tstruct xl_softc\t\t*sc;\n\tstruct xl_mii_frame\t*frame;\n\t\n{\n\tint\t\t\ts;\n\n\ts = splimp();\n\t/*\n\t * Set up frame for TX.\n\t */\n\n\tframe->mii_stdelim = XL_MII_STARTDELIM;\n\tframe->mii_opcode = XL_MII_WRITEOP;\n\tframe->mii_turnaround = XL_MII_TURNAROUND;\n\t\n\t/*\n\t * Select the window 4.\n\t */\n\tXL_SEL_WIN(4);\n\n\t/*\n \t * Turn on data output.\n\t */\n\tMII_SET(XL_MII_DIR);\n\n\txl_mii_sync(sc);\n\n\txl_mii_send(sc, frame->mii_stdelim, 2);\n\txl_mii_send(sc, frame->mii_opcode, 2);\n\txl_mii_send(sc, frame->mii_phyaddr, 5);\n\txl_mii_send(sc, frame->mii_regaddr, 5);\n\txl_mii_send(sc, frame->mii_turnaround, 2);\n\txl_mii_send(sc, frame->mii_data, 16);\n\n\t/* Idle bit. */\n\tMII_SET(XL_MII_CLK);\n\tDELAY(1);\n\tMII_CLR(XL_MII_CLK);\n\tDELAY(1);\n\n\t/*\n\t * Turn off xmit.\n\t */\n\tMII_CLR(XL_MII_DIR);\n\n\tsplx(s);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)&frame",
            "sizeof(frame)"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint xl_mii_writereg;\nvoid xl_miibus_writereg;\n\nvoid\nxl_miibus_writereg(self, phy, reg, data)\n\tstruct device *self;\n\tint phy, reg, data;\n{\n\tstruct xl_softc *sc = (struct xl_softc *)self;\n\tstruct xl_mii_frame\tframe;\n\n\tif (sc->xl_bustype != XL_BUS_CARDBUS && phy != 24)\n\t\treturn;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = phy;\n\tframe.mii_regaddr = reg;\n\tframe.mii_data = data;\n\n\txl_mii_writereg(sc, &frame);\n}"
  },
  {
    "function_name": "xl_miibus_readreg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
    "lines": "434-452",
    "snippet": "int\nxl_miibus_readreg(self, phy, reg)\n\tstruct device *self;\n\tint phy, reg;\n{\n\tstruct xl_softc *sc = (struct xl_softc *)self;\n\tstruct xl_mii_frame\tframe;\n\n\tif (sc->xl_bustype != XL_BUS_CARDBUS && phy != 24)\n\t\treturn (0);\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = phy;\n\tframe.mii_regaddr = reg;\n\txl_mii_readreg(sc, &frame);\n\n\treturn(frame.mii_data);\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int xl_mii_readreg",
      "int xl_miibus_readreg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xl_mii_readreg",
          "args": [
            "sc",
            "&frame"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "xl_mii_readreg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "285-378",
          "snippet": "int xl_mii_readreg(sc, frame)\n\tstruct xl_softc\t\t*sc;\n\tstruct xl_mii_frame\t*frame;\n\t\n{\n\tint\t\t\ti, ack, s;\n\n\ts = splimp();\n\n\t/*\n\t * Set up frame for RX.\n\t */\n\tframe->mii_stdelim = XL_MII_STARTDELIM;\n\tframe->mii_opcode = XL_MII_READOP;\n\tframe->mii_turnaround = 0;\n\tframe->mii_data = 0;\n\t\n\t/*\n\t * Select register window 4.\n\t */\n\n\tXL_SEL_WIN(4);\n\n\tCSR_WRITE_2(sc, XL_W4_PHY_MGMT, 0);\n\t/*\n \t * Turn on data xmit.\n\t */\n\tMII_SET(XL_MII_DIR);\n\n\txl_mii_sync(sc);\n\n\t/*\n\t * Send command/address info.\n\t */\n\txl_mii_send(sc, frame->mii_stdelim, 2);\n\txl_mii_send(sc, frame->mii_opcode, 2);\n\txl_mii_send(sc, frame->mii_phyaddr, 5);\n\txl_mii_send(sc, frame->mii_regaddr, 5);\n\n\t/* Idle bit */\n\tMII_CLR((XL_MII_CLK|XL_MII_DATA));\n\tDELAY(1);\n\tMII_SET(XL_MII_CLK);\n\tDELAY(1);\n\n\t/* Turn off xmit. */\n\tMII_CLR(XL_MII_DIR);\n\n\t/* Check for ack */\n\tMII_CLR(XL_MII_CLK);\n\tDELAY(1);\n\tMII_SET(XL_MII_CLK);\n\tDELAY(1);\n\tack = CSR_READ_2(sc, XL_W4_PHY_MGMT) & XL_MII_DATA;\n\n\t/*\n\t * Now try reading data bits. If the ack failed, we still\n\t * need to clock through 16 cycles to keep the PHY(s) in sync.\n\t */\n\tif (ack) {\n\t\tfor(i = 0; i < 16; i++) {\n\t\t\tMII_CLR(XL_MII_CLK);\n\t\t\tDELAY(1);\n\t\t\tMII_SET(XL_MII_CLK);\n\t\t\tDELAY(1);\n\t\t}\n\t\tgoto fail;\n\t}\n\n\tfor (i = 0x8000; i; i >>= 1) {\n\t\tMII_CLR(XL_MII_CLK);\n\t\tDELAY(1);\n\t\tif (!ack) {\n\t\t\tif (CSR_READ_2(sc, XL_W4_PHY_MGMT) & XL_MII_DATA)\n\t\t\t\tframe->mii_data |= i;\n\t\t\tDELAY(1);\n\t\t}\n\t\tMII_SET(XL_MII_CLK);\n\t\tDELAY(1);\n\t}\n\nfail:\n\n\tMII_CLR(XL_MII_CLK);\n\tDELAY(1);\n\tMII_SET(XL_MII_CLK);\n\tDELAY(1);\n\n\tsplx(s);\n\n\tif (ack)\n\t\treturn(1);\n\treturn(0);\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void xl_mii_sync",
            "void xl_mii_send",
            "int xl_mii_readreg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_mii_sync;\nvoid xl_mii_send;\nint xl_mii_readreg;\n\nint xl_mii_readreg(sc, frame)\n\tstruct xl_softc\t\t*sc;\n\tstruct xl_mii_frame\t*frame;\n\t\n{\n\tint\t\t\ti, ack, s;\n\n\ts = splimp();\n\n\t/*\n\t * Set up frame for RX.\n\t */\n\tframe->mii_stdelim = XL_MII_STARTDELIM;\n\tframe->mii_opcode = XL_MII_READOP;\n\tframe->mii_turnaround = 0;\n\tframe->mii_data = 0;\n\t\n\t/*\n\t * Select register window 4.\n\t */\n\n\tXL_SEL_WIN(4);\n\n\tCSR_WRITE_2(sc, XL_W4_PHY_MGMT, 0);\n\t/*\n \t * Turn on data xmit.\n\t */\n\tMII_SET(XL_MII_DIR);\n\n\txl_mii_sync(sc);\n\n\t/*\n\t * Send command/address info.\n\t */\n\txl_mii_send(sc, frame->mii_stdelim, 2);\n\txl_mii_send(sc, frame->mii_opcode, 2);\n\txl_mii_send(sc, frame->mii_phyaddr, 5);\n\txl_mii_send(sc, frame->mii_regaddr, 5);\n\n\t/* Idle bit */\n\tMII_CLR((XL_MII_CLK|XL_MII_DATA));\n\tDELAY(1);\n\tMII_SET(XL_MII_CLK);\n\tDELAY(1);\n\n\t/* Turn off xmit. */\n\tMII_CLR(XL_MII_DIR);\n\n\t/* Check for ack */\n\tMII_CLR(XL_MII_CLK);\n\tDELAY(1);\n\tMII_SET(XL_MII_CLK);\n\tDELAY(1);\n\tack = CSR_READ_2(sc, XL_W4_PHY_MGMT) & XL_MII_DATA;\n\n\t/*\n\t * Now try reading data bits. If the ack failed, we still\n\t * need to clock through 16 cycles to keep the PHY(s) in sync.\n\t */\n\tif (ack) {\n\t\tfor(i = 0; i < 16; i++) {\n\t\t\tMII_CLR(XL_MII_CLK);\n\t\t\tDELAY(1);\n\t\t\tMII_SET(XL_MII_CLK);\n\t\t\tDELAY(1);\n\t\t}\n\t\tgoto fail;\n\t}\n\n\tfor (i = 0x8000; i; i >>= 1) {\n\t\tMII_CLR(XL_MII_CLK);\n\t\tDELAY(1);\n\t\tif (!ack) {\n\t\t\tif (CSR_READ_2(sc, XL_W4_PHY_MGMT) & XL_MII_DATA)\n\t\t\t\tframe->mii_data |= i;\n\t\t\tDELAY(1);\n\t\t}\n\t\tMII_SET(XL_MII_CLK);\n\t\tDELAY(1);\n\t}\n\nfail:\n\n\tMII_CLR(XL_MII_CLK);\n\tDELAY(1);\n\tMII_SET(XL_MII_CLK);\n\tDELAY(1);\n\n\tsplx(s);\n\n\tif (ack)\n\t\treturn(1);\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)&frame",
            "sizeof(frame)"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint xl_mii_readreg;\nint xl_miibus_readreg;\n\nint\nxl_miibus_readreg(self, phy, reg)\n\tstruct device *self;\n\tint phy, reg;\n{\n\tstruct xl_softc *sc = (struct xl_softc *)self;\n\tstruct xl_mii_frame\tframe;\n\n\tif (sc->xl_bustype != XL_BUS_CARDBUS && phy != 24)\n\t\treturn (0);\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = phy;\n\tframe.mii_regaddr = reg;\n\txl_mii_readreg(sc, &frame);\n\n\treturn(frame.mii_data);\n}"
  },
  {
    "function_name": "xl_mii_writereg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
    "lines": "383-432",
    "snippet": "int xl_mii_writereg(sc, frame)\n\tstruct xl_softc\t\t*sc;\n\tstruct xl_mii_frame\t*frame;\n\t\n{\n\tint\t\t\ts;\n\n\ts = splimp();\n\t/*\n\t * Set up frame for TX.\n\t */\n\n\tframe->mii_stdelim = XL_MII_STARTDELIM;\n\tframe->mii_opcode = XL_MII_WRITEOP;\n\tframe->mii_turnaround = XL_MII_TURNAROUND;\n\t\n\t/*\n\t * Select the window 4.\n\t */\n\tXL_SEL_WIN(4);\n\n\t/*\n \t * Turn on data output.\n\t */\n\tMII_SET(XL_MII_DIR);\n\n\txl_mii_sync(sc);\n\n\txl_mii_send(sc, frame->mii_stdelim, 2);\n\txl_mii_send(sc, frame->mii_opcode, 2);\n\txl_mii_send(sc, frame->mii_phyaddr, 5);\n\txl_mii_send(sc, frame->mii_regaddr, 5);\n\txl_mii_send(sc, frame->mii_turnaround, 2);\n\txl_mii_send(sc, frame->mii_data, 16);\n\n\t/* Idle bit. */\n\tMII_SET(XL_MII_CLK);\n\tDELAY(1);\n\tMII_CLR(XL_MII_CLK);\n\tDELAY(1);\n\n\t/*\n\t * Turn off xmit.\n\t */\n\tMII_CLR(XL_MII_DIR);\n\n\tsplx(s);\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void xl_mii_sync",
      "void xl_mii_send",
      "int xl_mii_writereg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_CLR",
          "args": [
            "XL_MII_DIR"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_CLR",
          "args": [
            "XL_MII_CLK"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_SET",
          "args": [
            "XL_MII_CLK"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xl_mii_send",
          "args": [
            "sc",
            "frame->mii_data",
            "16"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "xl_mii_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "259-280",
          "snippet": "void xl_mii_send(sc, bits, cnt)\n\tstruct xl_softc\t\t*sc;\n\tu_int32_t\t\tbits;\n\tint\t\t\tcnt;\n{\n\tint\t\t\ti;\n\n\tXL_SEL_WIN(4);\n\tMII_CLR(XL_MII_CLK);\n\n\tfor (i = (0x1 << (cnt - 1)); i; i >>= 1) {\n                if (bits & i) {\n\t\t\tMII_SET(XL_MII_DATA);\n                } else {\n\t\t\tMII_CLR(XL_MII_DATA);\n                }\n\t\tDELAY(1);\n\t\tMII_CLR(XL_MII_CLK);\n\t\tDELAY(1);\n\t\tMII_SET(XL_MII_CLK);\n\t}\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void xl_mii_send"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_mii_send;\n\nvoid xl_mii_send(sc, bits, cnt)\n\tstruct xl_softc\t\t*sc;\n\tu_int32_t\t\tbits;\n\tint\t\t\tcnt;\n{\n\tint\t\t\ti;\n\n\tXL_SEL_WIN(4);\n\tMII_CLR(XL_MII_CLK);\n\n\tfor (i = (0x1 << (cnt - 1)); i; i >>= 1) {\n                if (bits & i) {\n\t\t\tMII_SET(XL_MII_DATA);\n                } else {\n\t\t\tMII_CLR(XL_MII_DATA);\n                }\n\t\tDELAY(1);\n\t\tMII_CLR(XL_MII_CLK);\n\t\tDELAY(1);\n\t\tMII_SET(XL_MII_CLK);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xl_mii_sync",
          "args": [
            "sc"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "xl_mii_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "238-254",
          "snippet": "void xl_mii_sync(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tXL_SEL_WIN(4);\n\tMII_SET(XL_MII_DIR|XL_MII_DATA);\n\n\tfor (i = 0; i < 32; i++) {\n\t\tMII_SET(XL_MII_CLK);\n\t\tDELAY(1);\n\t\tMII_CLR(XL_MII_CLK);\n\t\tDELAY(1);\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void xl_mii_sync"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_mii_sync;\n\nvoid xl_mii_sync(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tXL_SEL_WIN(4);\n\tMII_SET(XL_MII_DIR|XL_MII_DATA);\n\n\tfor (i = 0; i < 32; i++) {\n\t\tMII_SET(XL_MII_CLK);\n\t\tDELAY(1);\n\t\tMII_CLR(XL_MII_CLK);\n\t\tDELAY(1);\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MII_SET",
          "args": [
            "XL_MII_DIR"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XL_SEL_WIN",
          "args": [
            "4"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_mii_sync;\nvoid xl_mii_send;\nint xl_mii_writereg;\n\nint xl_mii_writereg(sc, frame)\n\tstruct xl_softc\t\t*sc;\n\tstruct xl_mii_frame\t*frame;\n\t\n{\n\tint\t\t\ts;\n\n\ts = splimp();\n\t/*\n\t * Set up frame for TX.\n\t */\n\n\tframe->mii_stdelim = XL_MII_STARTDELIM;\n\tframe->mii_opcode = XL_MII_WRITEOP;\n\tframe->mii_turnaround = XL_MII_TURNAROUND;\n\t\n\t/*\n\t * Select the window 4.\n\t */\n\tXL_SEL_WIN(4);\n\n\t/*\n \t * Turn on data output.\n\t */\n\tMII_SET(XL_MII_DIR);\n\n\txl_mii_sync(sc);\n\n\txl_mii_send(sc, frame->mii_stdelim, 2);\n\txl_mii_send(sc, frame->mii_opcode, 2);\n\txl_mii_send(sc, frame->mii_phyaddr, 5);\n\txl_mii_send(sc, frame->mii_regaddr, 5);\n\txl_mii_send(sc, frame->mii_turnaround, 2);\n\txl_mii_send(sc, frame->mii_data, 16);\n\n\t/* Idle bit. */\n\tMII_SET(XL_MII_CLK);\n\tDELAY(1);\n\tMII_CLR(XL_MII_CLK);\n\tDELAY(1);\n\n\t/*\n\t * Turn off xmit.\n\t */\n\tMII_CLR(XL_MII_DIR);\n\n\tsplx(s);\n\n\treturn(0);\n}"
  },
  {
    "function_name": "xl_mii_readreg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
    "lines": "285-378",
    "snippet": "int xl_mii_readreg(sc, frame)\n\tstruct xl_softc\t\t*sc;\n\tstruct xl_mii_frame\t*frame;\n\t\n{\n\tint\t\t\ti, ack, s;\n\n\ts = splimp();\n\n\t/*\n\t * Set up frame for RX.\n\t */\n\tframe->mii_stdelim = XL_MII_STARTDELIM;\n\tframe->mii_opcode = XL_MII_READOP;\n\tframe->mii_turnaround = 0;\n\tframe->mii_data = 0;\n\t\n\t/*\n\t * Select register window 4.\n\t */\n\n\tXL_SEL_WIN(4);\n\n\tCSR_WRITE_2(sc, XL_W4_PHY_MGMT, 0);\n\t/*\n \t * Turn on data xmit.\n\t */\n\tMII_SET(XL_MII_DIR);\n\n\txl_mii_sync(sc);\n\n\t/*\n\t * Send command/address info.\n\t */\n\txl_mii_send(sc, frame->mii_stdelim, 2);\n\txl_mii_send(sc, frame->mii_opcode, 2);\n\txl_mii_send(sc, frame->mii_phyaddr, 5);\n\txl_mii_send(sc, frame->mii_regaddr, 5);\n\n\t/* Idle bit */\n\tMII_CLR((XL_MII_CLK|XL_MII_DATA));\n\tDELAY(1);\n\tMII_SET(XL_MII_CLK);\n\tDELAY(1);\n\n\t/* Turn off xmit. */\n\tMII_CLR(XL_MII_DIR);\n\n\t/* Check for ack */\n\tMII_CLR(XL_MII_CLK);\n\tDELAY(1);\n\tMII_SET(XL_MII_CLK);\n\tDELAY(1);\n\tack = CSR_READ_2(sc, XL_W4_PHY_MGMT) & XL_MII_DATA;\n\n\t/*\n\t * Now try reading data bits. If the ack failed, we still\n\t * need to clock through 16 cycles to keep the PHY(s) in sync.\n\t */\n\tif (ack) {\n\t\tfor(i = 0; i < 16; i++) {\n\t\t\tMII_CLR(XL_MII_CLK);\n\t\t\tDELAY(1);\n\t\t\tMII_SET(XL_MII_CLK);\n\t\t\tDELAY(1);\n\t\t}\n\t\tgoto fail;\n\t}\n\n\tfor (i = 0x8000; i; i >>= 1) {\n\t\tMII_CLR(XL_MII_CLK);\n\t\tDELAY(1);\n\t\tif (!ack) {\n\t\t\tif (CSR_READ_2(sc, XL_W4_PHY_MGMT) & XL_MII_DATA)\n\t\t\t\tframe->mii_data |= i;\n\t\t\tDELAY(1);\n\t\t}\n\t\tMII_SET(XL_MII_CLK);\n\t\tDELAY(1);\n\t}\n\nfail:\n\n\tMII_CLR(XL_MII_CLK);\n\tDELAY(1);\n\tMII_SET(XL_MII_CLK);\n\tDELAY(1);\n\n\tsplx(s);\n\n\tif (ack)\n\t\treturn(1);\n\treturn(0);\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void xl_mii_sync",
      "void xl_mii_send",
      "int xl_mii_readreg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_SET",
          "args": [
            "XL_MII_CLK"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_CLR",
          "args": [
            "XL_MII_CLK"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_SET",
          "args": [
            "XL_MII_CLK"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "XL_W4_PHY_MGMT"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_CLR",
          "args": [
            "XL_MII_CLK"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_SET",
          "args": [
            "XL_MII_CLK"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_CLR",
          "args": [
            "XL_MII_CLK"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "XL_W4_PHY_MGMT"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_SET",
          "args": [
            "XL_MII_CLK"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_CLR",
          "args": [
            "XL_MII_CLK"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_CLR",
          "args": [
            "XL_MII_DIR"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_SET",
          "args": [
            "XL_MII_CLK"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_CLR",
          "args": [
            "(XL_MII_CLK|XL_MII_DATA)"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xl_mii_send",
          "args": [
            "sc",
            "frame->mii_regaddr",
            "5"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "xl_mii_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "259-280",
          "snippet": "void xl_mii_send(sc, bits, cnt)\n\tstruct xl_softc\t\t*sc;\n\tu_int32_t\t\tbits;\n\tint\t\t\tcnt;\n{\n\tint\t\t\ti;\n\n\tXL_SEL_WIN(4);\n\tMII_CLR(XL_MII_CLK);\n\n\tfor (i = (0x1 << (cnt - 1)); i; i >>= 1) {\n                if (bits & i) {\n\t\t\tMII_SET(XL_MII_DATA);\n                } else {\n\t\t\tMII_CLR(XL_MII_DATA);\n                }\n\t\tDELAY(1);\n\t\tMII_CLR(XL_MII_CLK);\n\t\tDELAY(1);\n\t\tMII_SET(XL_MII_CLK);\n\t}\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void xl_mii_send"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_mii_send;\n\nvoid xl_mii_send(sc, bits, cnt)\n\tstruct xl_softc\t\t*sc;\n\tu_int32_t\t\tbits;\n\tint\t\t\tcnt;\n{\n\tint\t\t\ti;\n\n\tXL_SEL_WIN(4);\n\tMII_CLR(XL_MII_CLK);\n\n\tfor (i = (0x1 << (cnt - 1)); i; i >>= 1) {\n                if (bits & i) {\n\t\t\tMII_SET(XL_MII_DATA);\n                } else {\n\t\t\tMII_CLR(XL_MII_DATA);\n                }\n\t\tDELAY(1);\n\t\tMII_CLR(XL_MII_CLK);\n\t\tDELAY(1);\n\t\tMII_SET(XL_MII_CLK);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xl_mii_sync",
          "args": [
            "sc"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "xl_mii_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
          "lines": "238-254",
          "snippet": "void xl_mii_sync(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tXL_SEL_WIN(4);\n\tMII_SET(XL_MII_DIR|XL_MII_DATA);\n\n\tfor (i = 0; i < 32; i++) {\n\t\tMII_SET(XL_MII_CLK);\n\t\tDELAY(1);\n\t\tMII_CLR(XL_MII_CLK);\n\t\tDELAY(1);\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/xlreg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void xl_mii_sync"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_mii_sync;\n\nvoid xl_mii_sync(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tXL_SEL_WIN(4);\n\tMII_SET(XL_MII_DIR|XL_MII_DATA);\n\n\tfor (i = 0; i < 32; i++) {\n\t\tMII_SET(XL_MII_CLK);\n\t\tDELAY(1);\n\t\tMII_CLR(XL_MII_CLK);\n\t\tDELAY(1);\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MII_SET",
          "args": [
            "XL_MII_DIR"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "XL_W4_PHY_MGMT",
            "0"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XL_SEL_WIN",
          "args": [
            "4"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_mii_sync;\nvoid xl_mii_send;\nint xl_mii_readreg;\n\nint xl_mii_readreg(sc, frame)\n\tstruct xl_softc\t\t*sc;\n\tstruct xl_mii_frame\t*frame;\n\t\n{\n\tint\t\t\ti, ack, s;\n\n\ts = splimp();\n\n\t/*\n\t * Set up frame for RX.\n\t */\n\tframe->mii_stdelim = XL_MII_STARTDELIM;\n\tframe->mii_opcode = XL_MII_READOP;\n\tframe->mii_turnaround = 0;\n\tframe->mii_data = 0;\n\t\n\t/*\n\t * Select register window 4.\n\t */\n\n\tXL_SEL_WIN(4);\n\n\tCSR_WRITE_2(sc, XL_W4_PHY_MGMT, 0);\n\t/*\n \t * Turn on data xmit.\n\t */\n\tMII_SET(XL_MII_DIR);\n\n\txl_mii_sync(sc);\n\n\t/*\n\t * Send command/address info.\n\t */\n\txl_mii_send(sc, frame->mii_stdelim, 2);\n\txl_mii_send(sc, frame->mii_opcode, 2);\n\txl_mii_send(sc, frame->mii_phyaddr, 5);\n\txl_mii_send(sc, frame->mii_regaddr, 5);\n\n\t/* Idle bit */\n\tMII_CLR((XL_MII_CLK|XL_MII_DATA));\n\tDELAY(1);\n\tMII_SET(XL_MII_CLK);\n\tDELAY(1);\n\n\t/* Turn off xmit. */\n\tMII_CLR(XL_MII_DIR);\n\n\t/* Check for ack */\n\tMII_CLR(XL_MII_CLK);\n\tDELAY(1);\n\tMII_SET(XL_MII_CLK);\n\tDELAY(1);\n\tack = CSR_READ_2(sc, XL_W4_PHY_MGMT) & XL_MII_DATA;\n\n\t/*\n\t * Now try reading data bits. If the ack failed, we still\n\t * need to clock through 16 cycles to keep the PHY(s) in sync.\n\t */\n\tif (ack) {\n\t\tfor(i = 0; i < 16; i++) {\n\t\t\tMII_CLR(XL_MII_CLK);\n\t\t\tDELAY(1);\n\t\t\tMII_SET(XL_MII_CLK);\n\t\t\tDELAY(1);\n\t\t}\n\t\tgoto fail;\n\t}\n\n\tfor (i = 0x8000; i; i >>= 1) {\n\t\tMII_CLR(XL_MII_CLK);\n\t\tDELAY(1);\n\t\tif (!ack) {\n\t\t\tif (CSR_READ_2(sc, XL_W4_PHY_MGMT) & XL_MII_DATA)\n\t\t\t\tframe->mii_data |= i;\n\t\t\tDELAY(1);\n\t\t}\n\t\tMII_SET(XL_MII_CLK);\n\t\tDELAY(1);\n\t}\n\nfail:\n\n\tMII_CLR(XL_MII_CLK);\n\tDELAY(1);\n\tMII_SET(XL_MII_CLK);\n\tDELAY(1);\n\n\tsplx(s);\n\n\tif (ack)\n\t\treturn(1);\n\treturn(0);\n}"
  },
  {
    "function_name": "xl_mii_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
    "lines": "259-280",
    "snippet": "void xl_mii_send(sc, bits, cnt)\n\tstruct xl_softc\t\t*sc;\n\tu_int32_t\t\tbits;\n\tint\t\t\tcnt;\n{\n\tint\t\t\ti;\n\n\tXL_SEL_WIN(4);\n\tMII_CLR(XL_MII_CLK);\n\n\tfor (i = (0x1 << (cnt - 1)); i; i >>= 1) {\n                if (bits & i) {\n\t\t\tMII_SET(XL_MII_DATA);\n                } else {\n\t\t\tMII_CLR(XL_MII_DATA);\n                }\n\t\tDELAY(1);\n\t\tMII_CLR(XL_MII_CLK);\n\t\tDELAY(1);\n\t\tMII_SET(XL_MII_CLK);\n\t}\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void xl_mii_send"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MII_SET",
          "args": [
            "XL_MII_CLK"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_CLR",
          "args": [
            "XL_MII_CLK"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_CLR",
          "args": [
            "XL_MII_DATA"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_SET",
          "args": [
            "XL_MII_DATA"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_CLR",
          "args": [
            "XL_MII_CLK"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XL_SEL_WIN",
          "args": [
            "4"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_mii_send;\n\nvoid xl_mii_send(sc, bits, cnt)\n\tstruct xl_softc\t\t*sc;\n\tu_int32_t\t\tbits;\n\tint\t\t\tcnt;\n{\n\tint\t\t\ti;\n\n\tXL_SEL_WIN(4);\n\tMII_CLR(XL_MII_CLK);\n\n\tfor (i = (0x1 << (cnt - 1)); i; i >>= 1) {\n                if (bits & i) {\n\t\t\tMII_SET(XL_MII_DATA);\n                } else {\n\t\t\tMII_CLR(XL_MII_DATA);\n                }\n\t\tDELAY(1);\n\t\tMII_CLR(XL_MII_CLK);\n\t\tDELAY(1);\n\t\tMII_SET(XL_MII_CLK);\n\t}\n}"
  },
  {
    "function_name": "xl_mii_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
    "lines": "238-254",
    "snippet": "void xl_mii_sync(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tXL_SEL_WIN(4);\n\tMII_SET(XL_MII_DIR|XL_MII_DATA);\n\n\tfor (i = 0; i < 32; i++) {\n\t\tMII_SET(XL_MII_CLK);\n\t\tDELAY(1);\n\t\tMII_CLR(XL_MII_CLK);\n\t\tDELAY(1);\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void xl_mii_sync"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_CLR",
          "args": [
            "XL_MII_CLK"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_SET",
          "args": [
            "XL_MII_CLK"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MII_SET",
          "args": [
            "XL_MII_DIR|XL_MII_DATA"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XL_SEL_WIN",
          "args": [
            "4"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_mii_sync;\n\nvoid xl_mii_sync(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tXL_SEL_WIN(4);\n\tMII_SET(XL_MII_DIR|XL_MII_DATA);\n\n\tfor (i = 0; i < 32; i++) {\n\t\tMII_SET(XL_MII_CLK);\n\t\tDELAY(1);\n\t\tMII_CLR(XL_MII_CLK);\n\t\tDELAY(1);\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "xl_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/xl.c",
    "lines": "200-216",
    "snippet": "void xl_wait(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tfor (i = 0; i < XL_TIMEOUT; i++) {\n\t\tif (!(CSR_READ_2(sc, XL_STATUS) & XL_STAT_CMDBUSY))\n\t\t\tbreak;\n\t}\n\n#ifdef DIAGNOSTIC\n\tif (i == XL_TIMEOUT)\n\t\tprintf(\"xl%d: command never completed!\\n\", sc->xl_unit);\n#endif\n\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/xlreg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void xl_wait"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"xl%d: command never completed!\\n\"",
            "sc->xl_unit"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "XL_STATUS"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/xlreg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/proc.h>   /* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid xl_wait;\n\nvoid xl_wait(sc)\n\tstruct xl_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tfor (i = 0; i < XL_TIMEOUT; i++) {\n\t\tif (!(CSR_READ_2(sc, XL_STATUS) & XL_STAT_CMDBUSY))\n\t\t\tbreak;\n\t}\n\n#ifdef DIAGNOSTIC\n\tif (i == XL_TIMEOUT)\n\t\tprintf(\"xl%d: command never completed!\\n\", sc->xl_unit);\n#endif\n\n\treturn;\n}"
  }
]