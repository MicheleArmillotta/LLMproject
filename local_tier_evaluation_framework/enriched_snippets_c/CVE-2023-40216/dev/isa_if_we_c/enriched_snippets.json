[
  {
    "function_name": "we_set_media",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_we.c",
    "lines": "852-884",
    "snippet": "void\nwe_set_media(wsc, media)\n\tstruct we_softc *wsc;\n\tint media;\n{\n\tstruct dp8390_softc *sc = &wsc->sc_dp8390;\n\tbus_space_tag_t asict = wsc->sc_asict;\n\tbus_space_handle_t asich = wsc->sc_asich;\n\tu_int8_t hwr, gcr, irr;\n\n\tif (sc->is790) {\n\t\thwr = bus_space_read_1(asict, asich, WE790_HWR);\n\t\tbus_space_write_1(asict, asich, WE790_HWR,\n\t\t    hwr | WE790_HWR_SWH);\n\t\tgcr = bus_space_read_1(asict, asich, WE790_GCR);\n\t\tif (IFM_SUBTYPE(media) == IFM_10_2)\n\t\t\tgcr |= WE790_GCR_GPOUT;\n\t\telse\n\t\t\tgcr &= ~WE790_GCR_GPOUT;\n\t\tbus_space_write_1(asict, asich, WE790_GCR,\n\t\t    gcr | WE790_GCR_LIT);\n\t\tbus_space_write_1(asict, asich, WE790_HWR,\n\t\t    hwr & ~WE790_HWR_SWH);\n\t\treturn;\n\t}\n\n\tirr = bus_space_read_1(wsc->sc_asict, wsc->sc_asich, WE_IRR);\n\tif (IFM_SUBTYPE(media) == IFM_10_2)\n\t\tirr |= WE_IRR_OUT2;\n\telse\n\t\tirr &= ~WE_IRR_OUT2;\n\tbus_space_write_1(wsc->sc_asict, wsc->sc_asich, WE_IRR, irr);\n}",
    "includes": [
      "#include <dev/isa/if_wereg.h>",
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"we.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\twe_set_media",
      "const char *\nwe_params(asict, asich, typep, memsizep, is16bitp, is790p)\n\tbus_space_tag_t asict;",
      "bus_space_handle_t asich;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "wsc->sc_asict",
            "wsc->sc_asich",
            "WE_IRR",
            "irr"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "media"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "wsc->sc_asict",
            "wsc->sc_asich",
            "WE_IRR"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "asict",
            "asich",
            "WE790_HWR",
            "hwr & ~WE790_HWR_SWH"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "asict",
            "asich",
            "WE790_GCR",
            "gcr | WE790_GCR_LIT"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "media"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "asict",
            "asich",
            "WE790_GCR"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "asict",
            "asich",
            "WE790_HWR",
            "hwr | WE790_HWR_SWH"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "asict",
            "asich",
            "WE790_HWR"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_wereg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"we.h\"\n#include \"bpfilter.h\"\n\nvoid\twe_set_media;\nconst char *\nwe_params(asict, asich, typep, memsizep, is16bitp, is790p)\n\tbus_space_tag_t asict;\nbus_space_handle_t asich;\n\nvoid\nwe_set_media(wsc, media)\n\tstruct we_softc *wsc;\n\tint media;\n{\n\tstruct dp8390_softc *sc = &wsc->sc_dp8390;\n\tbus_space_tag_t asict = wsc->sc_asict;\n\tbus_space_handle_t asich = wsc->sc_asich;\n\tu_int8_t hwr, gcr, irr;\n\n\tif (sc->is790) {\n\t\thwr = bus_space_read_1(asict, asich, WE790_HWR);\n\t\tbus_space_write_1(asict, asich, WE790_HWR,\n\t\t    hwr | WE790_HWR_SWH);\n\t\tgcr = bus_space_read_1(asict, asich, WE790_GCR);\n\t\tif (IFM_SUBTYPE(media) == IFM_10_2)\n\t\t\tgcr |= WE790_GCR_GPOUT;\n\t\telse\n\t\t\tgcr &= ~WE790_GCR_GPOUT;\n\t\tbus_space_write_1(asict, asich, WE790_GCR,\n\t\t    gcr | WE790_GCR_LIT);\n\t\tbus_space_write_1(asict, asich, WE790_HWR,\n\t\t    hwr & ~WE790_HWR_SWH);\n\t\treturn;\n\t}\n\n\tirr = bus_space_read_1(wsc->sc_asict, wsc->sc_asich, WE_IRR);\n\tif (IFM_SUBTYPE(media) == IFM_10_2)\n\t\tirr |= WE_IRR_OUT2;\n\telse\n\t\tirr &= ~WE_IRR_OUT2;\n\tbus_space_write_1(wsc->sc_asict, wsc->sc_asich, WE_IRR, irr);\n}"
  },
  {
    "function_name": "we_init_card",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_we.c",
    "lines": "842-850",
    "snippet": "void\nwe_init_card(sc)\n\tstruct dp8390_softc *sc;\n{\n\tstruct we_softc *wsc = (struct we_softc *)sc;\n\tstruct ifmedia *ifm = &sc->sc_media;\n\n\twe_set_media(wsc, ifm->ifm_cur->ifm_media);\n}",
    "includes": [
      "#include <dev/isa/if_wereg.h>",
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"we.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\twe_set_media",
      "void\twe_init_card"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "we_set_media",
          "args": [
            "wsc",
            "ifm->ifm_cur->ifm_media"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "we_set_media",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_we.c",
          "lines": "852-884",
          "snippet": "void\nwe_set_media(wsc, media)\n\tstruct we_softc *wsc;\n\tint media;\n{\n\tstruct dp8390_softc *sc = &wsc->sc_dp8390;\n\tbus_space_tag_t asict = wsc->sc_asict;\n\tbus_space_handle_t asich = wsc->sc_asich;\n\tu_int8_t hwr, gcr, irr;\n\n\tif (sc->is790) {\n\t\thwr = bus_space_read_1(asict, asich, WE790_HWR);\n\t\tbus_space_write_1(asict, asich, WE790_HWR,\n\t\t    hwr | WE790_HWR_SWH);\n\t\tgcr = bus_space_read_1(asict, asich, WE790_GCR);\n\t\tif (IFM_SUBTYPE(media) == IFM_10_2)\n\t\t\tgcr |= WE790_GCR_GPOUT;\n\t\telse\n\t\t\tgcr &= ~WE790_GCR_GPOUT;\n\t\tbus_space_write_1(asict, asich, WE790_GCR,\n\t\t    gcr | WE790_GCR_LIT);\n\t\tbus_space_write_1(asict, asich, WE790_HWR,\n\t\t    hwr & ~WE790_HWR_SWH);\n\t\treturn;\n\t}\n\n\tirr = bus_space_read_1(wsc->sc_asict, wsc->sc_asich, WE_IRR);\n\tif (IFM_SUBTYPE(media) == IFM_10_2)\n\t\tirr |= WE_IRR_OUT2;\n\telse\n\t\tirr &= ~WE_IRR_OUT2;\n\tbus_space_write_1(wsc->sc_asict, wsc->sc_asich, WE_IRR, irr);\n}",
          "includes": [
            "#include <dev/isa/if_wereg.h>",
            "#include <dev/ic/dp8390var.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/socket.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"we.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\twe_set_media",
            "const char *\nwe_params(asict, asich, typep, memsizep, is16bitp, is790p)\n\tbus_space_tag_t asict;",
            "bus_space_handle_t asich;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_wereg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"we.h\"\n#include \"bpfilter.h\"\n\nvoid\twe_set_media;\nconst char *\nwe_params(asict, asich, typep, memsizep, is16bitp, is790p)\n\tbus_space_tag_t asict;\nbus_space_handle_t asich;\n\nvoid\nwe_set_media(wsc, media)\n\tstruct we_softc *wsc;\n\tint media;\n{\n\tstruct dp8390_softc *sc = &wsc->sc_dp8390;\n\tbus_space_tag_t asict = wsc->sc_asict;\n\tbus_space_handle_t asich = wsc->sc_asich;\n\tu_int8_t hwr, gcr, irr;\n\n\tif (sc->is790) {\n\t\thwr = bus_space_read_1(asict, asich, WE790_HWR);\n\t\tbus_space_write_1(asict, asich, WE790_HWR,\n\t\t    hwr | WE790_HWR_SWH);\n\t\tgcr = bus_space_read_1(asict, asich, WE790_GCR);\n\t\tif (IFM_SUBTYPE(media) == IFM_10_2)\n\t\t\tgcr |= WE790_GCR_GPOUT;\n\t\telse\n\t\t\tgcr &= ~WE790_GCR_GPOUT;\n\t\tbus_space_write_1(asict, asich, WE790_GCR,\n\t\t    gcr | WE790_GCR_LIT);\n\t\tbus_space_write_1(asict, asich, WE790_HWR,\n\t\t    hwr & ~WE790_HWR_SWH);\n\t\treturn;\n\t}\n\n\tirr = bus_space_read_1(wsc->sc_asict, wsc->sc_asich, WE_IRR);\n\tif (IFM_SUBTYPE(media) == IFM_10_2)\n\t\tirr |= WE_IRR_OUT2;\n\telse\n\t\tirr &= ~WE_IRR_OUT2;\n\tbus_space_write_1(wsc->sc_asict, wsc->sc_asich, WE_IRR, irr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_wereg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"we.h\"\n#include \"bpfilter.h\"\n\nvoid\twe_set_media;\nvoid\twe_init_card;\n\nvoid\nwe_init_card(sc)\n\tstruct dp8390_softc *sc;\n{\n\tstruct we_softc *wsc = (struct we_softc *)sc;\n\tstruct ifmedia *ifm = &sc->sc_media;\n\n\twe_set_media(wsc, ifm->ifm_cur->ifm_media);\n}"
  },
  {
    "function_name": "we_mediastatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_we.c",
    "lines": "829-840",
    "snippet": "void\nwe_mediastatus(sc, ifmr)\n\tstruct dp8390_softc *sc;\n\tstruct ifmediareq *ifmr;\n{\n\tstruct ifmedia *ifm = &sc->sc_media;\n\n\t/*\n\t * The currently selected media is always the active media.\n\t */\n\tifmr->ifm_active = ifm->ifm_cur->ifm_media;\n}",
    "includes": [
      "#include <dev/isa/if_wereg.h>",
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"we.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\twe_mediastatus"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/isa/if_wereg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"we.h\"\n#include \"bpfilter.h\"\n\nvoid\twe_mediastatus;\n\nvoid\nwe_mediastatus(sc, ifmr)\n\tstruct dp8390_softc *sc;\n\tstruct ifmediareq *ifmr;\n{\n\tstruct ifmedia *ifm = &sc->sc_media;\n\n\t/*\n\t * The currently selected media is always the active media.\n\t */\n\tifmr->ifm_active = ifm->ifm_cur->ifm_media;\n}"
  },
  {
    "function_name": "we_mediachange",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_we.c",
    "lines": "815-827",
    "snippet": "int\nwe_mediachange(sc)\n\tstruct dp8390_softc *sc;\n{\n\n\t/*\n\t * Current media is already set up.  Just reset the interface\n\t * to let the new value take hold.  The new media will be\n\t * set up in we_init_card() called via dp8390_init().\n\t */\n\tdp8390_reset(sc);\n\treturn (0);\n}",
    "includes": [
      "#include <dev/isa/if_wereg.h>",
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"we.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\twe_mediachange",
      "void\twe_init_card"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dp8390_reset",
          "args": [
            "sc"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "dp8390_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
          "lines": "197-207",
          "snippet": "void\ndp8390_reset(sc)\n\tstruct dp8390_softc *sc;\n{\n\tint     s;\n\n\ts = splnet();\n\tdp8390_stop(sc);\n\tdp8390_init(sc);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/dp8390var.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;\n\nvoid\ndp8390_reset(sc)\n\tstruct dp8390_softc *sc;\n{\n\tint     s;\n\n\ts = splnet();\n\tdp8390_stop(sc);\n\tdp8390_init(sc);\n\tsplx(s);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_wereg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"we.h\"\n#include \"bpfilter.h\"\n\nint\twe_mediachange;\nvoid\twe_init_card;\n\nint\nwe_mediachange(sc)\n\tstruct dp8390_softc *sc;\n{\n\n\t/*\n\t * Current media is already set up.  Just reset the interface\n\t * to let the new value take hold.  The new media will be\n\t * set up in we_init_card() called via dp8390_init().\n\t */\n\tdp8390_reset(sc);\n\treturn (0);\n}"
  },
  {
    "function_name": "we_recv_int",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_we.c",
    "lines": "804-813",
    "snippet": "void\nwe_recv_int(sc)\n\tstruct dp8390_softc *sc;\n{\n\tstruct we_softc *wsc = (struct we_softc *)sc;\n\n\tWE_MEM_ENABLE(wsc);\n\tdp8390_rint(sc);\n\tWE_MEM_DISABLE(wsc);\n}",
    "includes": [
      "#include <dev/isa/if_wereg.h>",
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"we.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\twe_recv_int"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WE_MEM_DISABLE",
          "args": [
            "wsc"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp8390_rint",
          "args": [
            "sc"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "dp8390_rint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
          "lines": "497-610",
          "snippet": "void\ndp8390_rint(sc)\n\tstruct dp8390_softc *sc;\n{\n\tbus_space_tag_t regt = sc->sc_regt;\n\tbus_space_handle_t regh = sc->sc_regh;\n\tstruct dp8390_ring packet_hdr;\n\tint packet_ptr;\n\tu_short len;\n\tu_char boundary, current;\n\tu_char nlen;\n\nloop:\n\t/* Set NIC to page 1 registers to get 'current' pointer. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_1 | ED_CR_STA);\n\n\t/*\n\t * 'sc->next_packet' is the logical beginning of the ring-buffer - i.e.\n\t * it points to where new data has been buffered.  The 'CURR' (current)\n\t * register points to the logical end of the ring-buffer - i.e. it\n\t * points to where additional new data will be added.  We loop here\n\t * until the logical beginning equals the logical end (or in other\n\t * words, until the ring-buffer is empty).\n\t */\n\tcurrent = NIC_GET(regt, regh, ED_P1_CURR);\n\tif (sc->next_packet == current)\n\t\treturn;\n\n\t/* Set NIC to page 0 registers to update boundary register. */\n\tNIC_PUT(regt, regh, ED_P1_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tdo {\n\t\t/* Get pointer to this buffer's header structure. */\n\t\tpacket_ptr = sc->mem_ring +\n\t\t    ((sc->next_packet - sc->rec_page_start) << ED_PAGE_SHIFT);\n\n\t\tif (sc->read_hdr)\n\t\t\t(*sc->read_hdr)(sc, packet_ptr, &packet_hdr);\n\t\telse\n\t\t\tdp8390_read_hdr(sc, packet_ptr, &packet_hdr);\n\t\tlen = packet_hdr.count;\n\n\t\t/*\n\t\t * Try do deal with old, buggy chips that sometimes duplicate\n\t\t * the low byte of the length into the high byte.  We do this\n\t\t * by simply ignoring the high byte of the length and always\n\t\t * recalculating it.\n\t\t *\n\t\t * NOTE: sc->next_packet is pointing at the current packet.\n\t\t */\n\t\tif (packet_hdr.next_packet >= sc->next_packet)\n\t\t\tnlen = (packet_hdr.next_packet - sc->next_packet);\n\t\telse\n\t\t\tnlen = ((packet_hdr.next_packet - sc->rec_page_start) +\n\t\t\t    (sc->rec_page_stop - sc->next_packet));\n\t\t--nlen;\n\t\tif ((len & ED_PAGE_MASK) + sizeof(packet_hdr) > ED_PAGE_SIZE)\n\t\t\t--nlen;\n\t\tlen = (len & ED_PAGE_MASK) | (nlen << ED_PAGE_SHIFT);\n#ifdef DIAGNOSTIC\n\t\tif (len != packet_hdr.count) {\n\t\t\tprintf(\"%s: length does not match \"\n\t\t\t    \"next packet pointer\\n\", sc->sc_dev.dv_xname);\n\t\t\tprintf(\"%s: len %04x nlen %04x start %02x \"\n\t\t\t    \"first %02x curr %02x next %02x stop %02x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, packet_hdr.count, len,\n\t\t\t    sc->rec_page_start, sc->next_packet, current,\n\t\t\t    packet_hdr.next_packet, sc->rec_page_stop);\n\t\t}\n#endif\n\n\t\t/*\n\t\t * Be fairly liberal about what we allow as a \"reasonable\"\n\t\t * length so that a [crufty] packet will make it to BPF (and\n\t\t * can thus be analyzed).  Note that all that is really\n\t\t * important is that we have a length that will fit into one\n\t\t * mbuf cluster or less; the upper layer protocols can then\n\t\t * figure out the length from their own length field(s).\n\t\t */\n\t\tif (len <= MCLBYTES &&\n\t\t    packet_hdr.next_packet >= sc->rec_page_start &&\n\t\t    packet_hdr.next_packet < sc->rec_page_stop) {\n\t\t\t/* Go get packet. */\n\t\t\tdp8390_read(sc,\n\t\t\t    packet_ptr + sizeof(struct dp8390_ring),\n\t\t\t    len - sizeof(struct dp8390_ring));\n\t\t\t++sc->sc_arpcom.ac_if.if_ipackets;\n\t\t} else {\n\t\t\t/* Really BAD.  The ring pointers are corrupted. */\n\t\t\tlog(LOG_ERR, \"%s: NIC memory corrupt - \"\n\t\t\t    \"invalid packet length %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, len);\n\t\t\t++sc->sc_arpcom.ac_if.if_ierrors;\n\t\t\tdp8390_reset(sc);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Update next packet pointer. */\n\t\tsc->next_packet = packet_hdr.next_packet;\n\n\t\t/*\n\t\t * Update NIC boundary pointer - being careful to keep it one\n\t\t * buffer behind (as recommended by NS databook).\n\t\t */\n\t\tboundary = sc->next_packet - 1;\n\t\tif (boundary < sc->rec_page_start)\n\t\t\tboundary = sc->rec_page_stop - 1;\n\t\tNIC_PUT(regt, regh, ED_P0_BNRY, boundary);\n\t} while (sc->next_packet != current);\n\n\tgoto loop;\n}",
          "includes": [
            "#include <dev/ic/dp8390var.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline__ void\tdp8390_read_hdr",
            "struct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic __inline__ void\tdp8390_read_hdr;\nstruct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;\n\nvoid\ndp8390_rint(sc)\n\tstruct dp8390_softc *sc;\n{\n\tbus_space_tag_t regt = sc->sc_regt;\n\tbus_space_handle_t regh = sc->sc_regh;\n\tstruct dp8390_ring packet_hdr;\n\tint packet_ptr;\n\tu_short len;\n\tu_char boundary, current;\n\tu_char nlen;\n\nloop:\n\t/* Set NIC to page 1 registers to get 'current' pointer. */\n\tNIC_PUT(regt, regh, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_1 | ED_CR_STA);\n\n\t/*\n\t * 'sc->next_packet' is the logical beginning of the ring-buffer - i.e.\n\t * it points to where new data has been buffered.  The 'CURR' (current)\n\t * register points to the logical end of the ring-buffer - i.e. it\n\t * points to where additional new data will be added.  We loop here\n\t * until the logical beginning equals the logical end (or in other\n\t * words, until the ring-buffer is empty).\n\t */\n\tcurrent = NIC_GET(regt, regh, ED_P1_CURR);\n\tif (sc->next_packet == current)\n\t\treturn;\n\n\t/* Set NIC to page 0 registers to update boundary register. */\n\tNIC_PUT(regt, regh, ED_P1_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tdo {\n\t\t/* Get pointer to this buffer's header structure. */\n\t\tpacket_ptr = sc->mem_ring +\n\t\t    ((sc->next_packet - sc->rec_page_start) << ED_PAGE_SHIFT);\n\n\t\tif (sc->read_hdr)\n\t\t\t(*sc->read_hdr)(sc, packet_ptr, &packet_hdr);\n\t\telse\n\t\t\tdp8390_read_hdr(sc, packet_ptr, &packet_hdr);\n\t\tlen = packet_hdr.count;\n\n\t\t/*\n\t\t * Try do deal with old, buggy chips that sometimes duplicate\n\t\t * the low byte of the length into the high byte.  We do this\n\t\t * by simply ignoring the high byte of the length and always\n\t\t * recalculating it.\n\t\t *\n\t\t * NOTE: sc->next_packet is pointing at the current packet.\n\t\t */\n\t\tif (packet_hdr.next_packet >= sc->next_packet)\n\t\t\tnlen = (packet_hdr.next_packet - sc->next_packet);\n\t\telse\n\t\t\tnlen = ((packet_hdr.next_packet - sc->rec_page_start) +\n\t\t\t    (sc->rec_page_stop - sc->next_packet));\n\t\t--nlen;\n\t\tif ((len & ED_PAGE_MASK) + sizeof(packet_hdr) > ED_PAGE_SIZE)\n\t\t\t--nlen;\n\t\tlen = (len & ED_PAGE_MASK) | (nlen << ED_PAGE_SHIFT);\n#ifdef DIAGNOSTIC\n\t\tif (len != packet_hdr.count) {\n\t\t\tprintf(\"%s: length does not match \"\n\t\t\t    \"next packet pointer\\n\", sc->sc_dev.dv_xname);\n\t\t\tprintf(\"%s: len %04x nlen %04x start %02x \"\n\t\t\t    \"first %02x curr %02x next %02x stop %02x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, packet_hdr.count, len,\n\t\t\t    sc->rec_page_start, sc->next_packet, current,\n\t\t\t    packet_hdr.next_packet, sc->rec_page_stop);\n\t\t}\n#endif\n\n\t\t/*\n\t\t * Be fairly liberal about what we allow as a \"reasonable\"\n\t\t * length so that a [crufty] packet will make it to BPF (and\n\t\t * can thus be analyzed).  Note that all that is really\n\t\t * important is that we have a length that will fit into one\n\t\t * mbuf cluster or less; the upper layer protocols can then\n\t\t * figure out the length from their own length field(s).\n\t\t */\n\t\tif (len <= MCLBYTES &&\n\t\t    packet_hdr.next_packet >= sc->rec_page_start &&\n\t\t    packet_hdr.next_packet < sc->rec_page_stop) {\n\t\t\t/* Go get packet. */\n\t\t\tdp8390_read(sc,\n\t\t\t    packet_ptr + sizeof(struct dp8390_ring),\n\t\t\t    len - sizeof(struct dp8390_ring));\n\t\t\t++sc->sc_arpcom.ac_if.if_ipackets;\n\t\t} else {\n\t\t\t/* Really BAD.  The ring pointers are corrupted. */\n\t\t\tlog(LOG_ERR, \"%s: NIC memory corrupt - \"\n\t\t\t    \"invalid packet length %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, len);\n\t\t\t++sc->sc_arpcom.ac_if.if_ierrors;\n\t\t\tdp8390_reset(sc);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Update next packet pointer. */\n\t\tsc->next_packet = packet_hdr.next_packet;\n\n\t\t/*\n\t\t * Update NIC boundary pointer - being careful to keep it one\n\t\t * buffer behind (as recommended by NS databook).\n\t\t */\n\t\tboundary = sc->next_packet - 1;\n\t\tif (boundary < sc->rec_page_start)\n\t\t\tboundary = sc->rec_page_stop - 1;\n\t\tNIC_PUT(regt, regh, ED_P0_BNRY, boundary);\n\t} while (sc->next_packet != current);\n\n\tgoto loop;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WE_MEM_ENABLE",
          "args": [
            "wsc"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_wereg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"we.h\"\n#include \"bpfilter.h\"\n\nvoid\twe_recv_int;\n\nvoid\nwe_recv_int(sc)\n\tstruct dp8390_softc *sc;\n{\n\tstruct we_softc *wsc = (struct we_softc *)sc;\n\n\tWE_MEM_ENABLE(wsc);\n\tdp8390_rint(sc);\n\tWE_MEM_DISABLE(wsc);\n}"
  },
  {
    "function_name": "we_read_hdr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_we.c",
    "lines": "789-802",
    "snippet": "void\nwe_read_hdr(sc, packet_ptr, packet_hdrp)\n\tstruct dp8390_softc *sc;\n\tint packet_ptr;\n\tstruct dp8390_ring *packet_hdrp;\n{\n\tstruct we_softc *wsc = (struct we_softc *)sc;\n\n\twe_readmem(wsc, packet_ptr, (u_int8_t *)packet_hdrp,\n\t    sizeof(struct dp8390_ring));\n#if BYTE_ORDER == BIG_ENDIAN\n\tpacket_hdrp->count = swap16(packet_hdrp->count);\n#endif\n}",
    "includes": [
      "#include <dev/isa/if_wereg.h>",
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"we.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\twe_read_hdr",
      "__inline void we_readmem"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "swap16",
          "args": [
            "packet_hdrp->count"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "we_readmem",
          "args": [
            "wsc",
            "packet_ptr",
            "(u_int8_t *)packet_hdrp",
            "sizeof(struct dp8390_ring)"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "we_readmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_we.c",
          "lines": "638-657",
          "snippet": "__inline void\nwe_readmem(wsc, from, to, len)\n\tstruct we_softc *wsc;\n\tint from;\n\tu_int8_t *to;\n\tint len;\n{\n\tbus_space_tag_t memt = wsc->sc_dp8390.sc_buft;\n\tbus_space_handle_t memh = wsc->sc_dp8390.sc_bufh;\n\n\tif (len & 1)\n\t\t++len;\n\n\tif (wsc->sc_16bitp)\n\t\tbus_space_read_region_stream_2(memt, memh, from,\n\t\t    (u_int16_t *)to, len >> 1);\n\telse\n\t\tbus_space_read_region_1(memt, memh, from,\n\t\t    to, len);\n}",
          "includes": [
            "#include <dev/isa/if_wereg.h>",
            "#include <dev/ic/dp8390var.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/socket.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"we.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tbus_space_read_region_stream_2\tbus_space_read_region_2"
          ],
          "globals_used": [
            "__inline void we_readmem"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_wereg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"we.h\"\n#include \"bpfilter.h\"\n\n#define\tbus_space_read_region_stream_2\tbus_space_read_region_2\n\n__inline void we_readmem;\n\n__inline void\nwe_readmem(wsc, from, to, len)\n\tstruct we_softc *wsc;\n\tint from;\n\tu_int8_t *to;\n\tint len;\n{\n\tbus_space_tag_t memt = wsc->sc_dp8390.sc_buft;\n\tbus_space_handle_t memh = wsc->sc_dp8390.sc_bufh;\n\n\tif (len & 1)\n\t\t++len;\n\n\tif (wsc->sc_16bitp)\n\t\tbus_space_read_region_stream_2(memt, memh, from,\n\t\t    (u_int16_t *)to, len >> 1);\n\telse\n\t\tbus_space_read_region_1(memt, memh, from,\n\t\t    to, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_wereg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"we.h\"\n#include \"bpfilter.h\"\n\nvoid\twe_read_hdr;\n__inline void we_readmem;\n\nvoid\nwe_read_hdr(sc, packet_ptr, packet_hdrp)\n\tstruct dp8390_softc *sc;\n\tint packet_ptr;\n\tstruct dp8390_ring *packet_hdrp;\n{\n\tstruct we_softc *wsc = (struct we_softc *)sc;\n\n\twe_readmem(wsc, packet_ptr, (u_int8_t *)packet_hdrp,\n\t    sizeof(struct dp8390_ring));\n#if BYTE_ORDER == BIG_ENDIAN\n\tpacket_hdrp->count = swap16(packet_hdrp->count);\n#endif\n}"
  },
  {
    "function_name": "we_ring_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_we.c",
    "lines": "762-787",
    "snippet": "int\nwe_ring_copy(sc, src, dst, amount)\n\tstruct dp8390_softc *sc;\n\tint src;\n\tcaddr_t dst;\n\tu_short amount;\n{\n\tstruct we_softc *wsc = (struct we_softc *)sc;\n\tu_short tmp_amount;\n\n\t/* Does copy wrap to lower addr in ring buffer? */\n\tif (src + amount > sc->mem_end) {\n\t\ttmp_amount = sc->mem_end - src;\n\n\t\t/* Copy amount up to end of NIC memory. */\n\t\twe_readmem(wsc, src, dst, tmp_amount);\n\n\t\tamount -= tmp_amount;\n\t\tsrc = sc->mem_ring;\n\t\tdst += tmp_amount;\n\t}\n\n\twe_readmem(wsc, src, dst, amount);\n\n\treturn (src + amount);\n}",
    "includes": [
      "#include <dev/isa/if_wereg.h>",
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"we.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\twe_ring_copy",
      "__inline void we_readmem"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "we_readmem",
          "args": [
            "wsc",
            "src",
            "dst",
            "amount"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "we_readmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_we.c",
          "lines": "638-657",
          "snippet": "__inline void\nwe_readmem(wsc, from, to, len)\n\tstruct we_softc *wsc;\n\tint from;\n\tu_int8_t *to;\n\tint len;\n{\n\tbus_space_tag_t memt = wsc->sc_dp8390.sc_buft;\n\tbus_space_handle_t memh = wsc->sc_dp8390.sc_bufh;\n\n\tif (len & 1)\n\t\t++len;\n\n\tif (wsc->sc_16bitp)\n\t\tbus_space_read_region_stream_2(memt, memh, from,\n\t\t    (u_int16_t *)to, len >> 1);\n\telse\n\t\tbus_space_read_region_1(memt, memh, from,\n\t\t    to, len);\n}",
          "includes": [
            "#include <dev/isa/if_wereg.h>",
            "#include <dev/ic/dp8390var.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_ether.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/socket.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"we.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tbus_space_read_region_stream_2\tbus_space_read_region_2"
          ],
          "globals_used": [
            "__inline void we_readmem"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/if_wereg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"we.h\"\n#include \"bpfilter.h\"\n\n#define\tbus_space_read_region_stream_2\tbus_space_read_region_2\n\n__inline void we_readmem;\n\n__inline void\nwe_readmem(wsc, from, to, len)\n\tstruct we_softc *wsc;\n\tint from;\n\tu_int8_t *to;\n\tint len;\n{\n\tbus_space_tag_t memt = wsc->sc_dp8390.sc_buft;\n\tbus_space_handle_t memh = wsc->sc_dp8390.sc_bufh;\n\n\tif (len & 1)\n\t\t++len;\n\n\tif (wsc->sc_16bitp)\n\t\tbus_space_read_region_stream_2(memt, memh, from,\n\t\t    (u_int16_t *)to, len >> 1);\n\telse\n\t\tbus_space_read_region_1(memt, memh, from,\n\t\t    to, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_wereg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"we.h\"\n#include \"bpfilter.h\"\n\nint\twe_ring_copy;\n__inline void we_readmem;\n\nint\nwe_ring_copy(sc, src, dst, amount)\n\tstruct dp8390_softc *sc;\n\tint src;\n\tcaddr_t dst;\n\tu_short amount;\n{\n\tstruct we_softc *wsc = (struct we_softc *)sc;\n\tu_short tmp_amount;\n\n\t/* Does copy wrap to lower addr in ring buffer? */\n\tif (src + amount > sc->mem_end) {\n\t\ttmp_amount = sc->mem_end - src;\n\n\t\t/* Copy amount up to end of NIC memory. */\n\t\twe_readmem(wsc, src, dst, tmp_amount);\n\n\t\tamount -= tmp_amount;\n\t\tsrc = sc->mem_ring;\n\t\tdst += tmp_amount;\n\t}\n\n\twe_readmem(wsc, src, dst, amount);\n\n\treturn (src + amount);\n}"
  },
  {
    "function_name": "we_write_mbuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_we.c",
    "lines": "659-760",
    "snippet": "int\nwe_write_mbuf(sc, m, buf)\n\tstruct dp8390_softc *sc;\n\tstruct mbuf *m;\n\tint buf;\n{\n\tstruct we_softc *wsc = (struct we_softc *)sc;\n\tbus_space_tag_t memt = wsc->sc_dp8390.sc_buft;\n\tbus_space_handle_t memh = wsc->sc_dp8390.sc_bufh;\n\tu_int8_t *data, savebyte[2];\n\tint savelen, len, leftover;\n#ifdef DIAGNOSTIC\n\tu_int8_t *lim;\n#endif\n\n\tsavelen = m->m_pkthdr.len;\n\n\tWE_MEM_ENABLE(wsc);\n\n\t/*\n\t * 8-bit boards are simple; no alignment tricks are necessary.\n\t */\n\tif (wsc->sc_16bitp == 0) {\n\t\tfor (; m != NULL; buf += m->m_len, m = m->m_next)\n\t\t\tbus_space_write_region_1(memt, memh,\n\t\t\t    buf, mtod(m, u_int8_t *), m->m_len);\n\t\tgoto out;\n\t}\n\n\t/* Start out with no leftover data. */\n\tleftover = 0;\n\tsavebyte[0] = savebyte[1] = 0;\n\n\tfor (; m != NULL; m = m->m_next) {\n\t\tlen = m->m_len;\n\t\tif (len == 0)\n\t\t\tcontinue;\n\t\tdata = mtod(m, u_int8_t *);\n#ifdef DIAGNOSTIC\n\t\tlim = data + len;\n#endif\n\t\twhile (len > 0) {\n\t\t\tif (leftover) {\n\t\t\t\t/*\n\t\t\t\t * Data left over (from mbuf or realignment).\n\t\t\t\t * Buffer the next byte, and write it and\n\t\t\t\t * the leftover data out.\n\t\t\t\t */\n\t\t\t\tsavebyte[1] = *data++;\n\t\t\t\tlen--;\n\t\t\t\tbus_space_write_stream_2(memt, memh, buf,\n\t\t\t\t    *(u_int16_t *)savebyte);\n\t\t\t\tbuf += 2;\n\t\t\t\tleftover = 0;\n#ifdef i386\n#define ALIGNED_POINTER(p,t)\t1\n#endif\n#ifdef alpha\n#define ALIGNED_POINTER(p,t)\t((((u_long)(p)) & (sizeof(t)-1)) == 0)\n#endif\n\t\t\t} else if (ALIGNED_POINTER(data, u_int16_t) == 0) {\n\t\t\t\t/*\n\t\t\t\t * Unaligned dta; buffer the next byte.\n\t\t\t\t */\n\t\t\t\tsavebyte[0] = *data++;\n\t\t\t\tlen--;\n\t\t\t\tleftover = 1;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Aligned data; output contiguous words as\n\t\t\t\t * much as we can, then buffer the remaining\n\t\t\t\t * byte, if any.\n\t\t\t\t */\n\t\t\t\tleftover = len & 1;\n\t\t\t\tlen &= ~1;\n\t\t\t\tbus_space_write_region_stream_2(memt, memh,\n\t\t\t\t    buf, (u_int16_t *)data, len >> 1);\n\t\t\t\tdata += len;\n\t\t\t\tbuf += len;\n\t\t\t\tif (leftover)\n\t\t\t\t\tsavebyte[0] = *data++;\n\t\t\t\tlen = 0;\n\t\t\t}\n\t\t}\n\t\tif (len < 0)\n\t\t\tpanic(\"we_write_mbuf: negative len\");\n#ifdef DIAGNOSTIC\n\t\tif (data != lim)\n\t\t\tpanic(\"we_write_mbuf: data != lim\");\n#endif\n\t}\n\tif (leftover) {\n\t\tsavebyte[1] = 0;\n\t\tbus_space_write_stream_2(memt, memh, buf,\n\t\t    *(u_int16_t *)savebyte);\n\t}\n\n out:\n\tWE_MEM_DISABLE(wsc);\n\n\treturn (savelen);\n}",
    "includes": [
      "#include <dev/isa/if_wereg.h>",
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"we.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define\tbus_space_write_region_stream_2\tbus_space_write_region_2",
      "#define\tbus_space_write_stream_2\tbus_space_write_2"
    ],
    "globals_used": [
      "int\twe_write_mbuf"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WE_MEM_DISABLE",
          "args": [
            "wsc"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_stream_2",
          "args": [
            "memt",
            "memh",
            "buf",
            "*(u_int16_t *)savebyte"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"we_write_mbuf: data != lim\""
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"we_write_mbuf: negative len\""
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_region_stream_2",
          "args": [
            "memt",
            "memh",
            "buf",
            "(u_int16_t *)data",
            "len >> 1"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGNED_POINTER",
          "args": [
            "data",
            "u_int16_t"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_stream_2",
          "args": [
            "memt",
            "memh",
            "buf",
            "*(u_int16_t *)savebyte"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "u_int8_t*"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_region_1",
          "args": [
            "memt",
            "memh",
            "buf",
            "mtod(m, u_int8_t *)",
            "m->m_len"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "u_int8_t*"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WE_MEM_ENABLE",
          "args": [
            "wsc"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_wereg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"we.h\"\n#include \"bpfilter.h\"\n\n#define\tbus_space_write_region_stream_2\tbus_space_write_region_2\n#define\tbus_space_write_stream_2\tbus_space_write_2\n\nint\twe_write_mbuf;\n\nint\nwe_write_mbuf(sc, m, buf)\n\tstruct dp8390_softc *sc;\n\tstruct mbuf *m;\n\tint buf;\n{\n\tstruct we_softc *wsc = (struct we_softc *)sc;\n\tbus_space_tag_t memt = wsc->sc_dp8390.sc_buft;\n\tbus_space_handle_t memh = wsc->sc_dp8390.sc_bufh;\n\tu_int8_t *data, savebyte[2];\n\tint savelen, len, leftover;\n#ifdef DIAGNOSTIC\n\tu_int8_t *lim;\n#endif\n\n\tsavelen = m->m_pkthdr.len;\n\n\tWE_MEM_ENABLE(wsc);\n\n\t/*\n\t * 8-bit boards are simple; no alignment tricks are necessary.\n\t */\n\tif (wsc->sc_16bitp == 0) {\n\t\tfor (; m != NULL; buf += m->m_len, m = m->m_next)\n\t\t\tbus_space_write_region_1(memt, memh,\n\t\t\t    buf, mtod(m, u_int8_t *), m->m_len);\n\t\tgoto out;\n\t}\n\n\t/* Start out with no leftover data. */\n\tleftover = 0;\n\tsavebyte[0] = savebyte[1] = 0;\n\n\tfor (; m != NULL; m = m->m_next) {\n\t\tlen = m->m_len;\n\t\tif (len == 0)\n\t\t\tcontinue;\n\t\tdata = mtod(m, u_int8_t *);\n#ifdef DIAGNOSTIC\n\t\tlim = data + len;\n#endif\n\t\twhile (len > 0) {\n\t\t\tif (leftover) {\n\t\t\t\t/*\n\t\t\t\t * Data left over (from mbuf or realignment).\n\t\t\t\t * Buffer the next byte, and write it and\n\t\t\t\t * the leftover data out.\n\t\t\t\t */\n\t\t\t\tsavebyte[1] = *data++;\n\t\t\t\tlen--;\n\t\t\t\tbus_space_write_stream_2(memt, memh, buf,\n\t\t\t\t    *(u_int16_t *)savebyte);\n\t\t\t\tbuf += 2;\n\t\t\t\tleftover = 0;\n#ifdef i386\n#define ALIGNED_POINTER(p,t)\t1\n#endif\n#ifdef alpha\n#define ALIGNED_POINTER(p,t)\t((((u_long)(p)) & (sizeof(t)-1)) == 0)\n#endif\n\t\t\t} else if (ALIGNED_POINTER(data, u_int16_t) == 0) {\n\t\t\t\t/*\n\t\t\t\t * Unaligned dta; buffer the next byte.\n\t\t\t\t */\n\t\t\t\tsavebyte[0] = *data++;\n\t\t\t\tlen--;\n\t\t\t\tleftover = 1;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Aligned data; output contiguous words as\n\t\t\t\t * much as we can, then buffer the remaining\n\t\t\t\t * byte, if any.\n\t\t\t\t */\n\t\t\t\tleftover = len & 1;\n\t\t\t\tlen &= ~1;\n\t\t\t\tbus_space_write_region_stream_2(memt, memh,\n\t\t\t\t    buf, (u_int16_t *)data, len >> 1);\n\t\t\t\tdata += len;\n\t\t\t\tbuf += len;\n\t\t\t\tif (leftover)\n\t\t\t\t\tsavebyte[0] = *data++;\n\t\t\t\tlen = 0;\n\t\t\t}\n\t\t}\n\t\tif (len < 0)\n\t\t\tpanic(\"we_write_mbuf: negative len\");\n#ifdef DIAGNOSTIC\n\t\tif (data != lim)\n\t\t\tpanic(\"we_write_mbuf: data != lim\");\n#endif\n\t}\n\tif (leftover) {\n\t\tsavebyte[1] = 0;\n\t\tbus_space_write_stream_2(memt, memh, buf,\n\t\t    *(u_int16_t *)savebyte);\n\t}\n\n out:\n\tWE_MEM_DISABLE(wsc);\n\n\treturn (savelen);\n}"
  },
  {
    "function_name": "we_readmem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_we.c",
    "lines": "638-657",
    "snippet": "__inline void\nwe_readmem(wsc, from, to, len)\n\tstruct we_softc *wsc;\n\tint from;\n\tu_int8_t *to;\n\tint len;\n{\n\tbus_space_tag_t memt = wsc->sc_dp8390.sc_buft;\n\tbus_space_handle_t memh = wsc->sc_dp8390.sc_bufh;\n\n\tif (len & 1)\n\t\t++len;\n\n\tif (wsc->sc_16bitp)\n\t\tbus_space_read_region_stream_2(memt, memh, from,\n\t\t    (u_int16_t *)to, len >> 1);\n\telse\n\t\tbus_space_read_region_1(memt, memh, from,\n\t\t    to, len);\n}",
    "includes": [
      "#include <dev/isa/if_wereg.h>",
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"we.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define\tbus_space_read_region_stream_2\tbus_space_read_region_2"
    ],
    "globals_used": [
      "__inline void we_readmem"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_read_region_1",
          "args": [
            "memt",
            "memh",
            "from",
            "to",
            "len"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_region_stream_2",
          "args": [
            "memt",
            "memh",
            "from",
            "(u_int16_t *)to",
            "len >> 1"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_wereg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"we.h\"\n#include \"bpfilter.h\"\n\n#define\tbus_space_read_region_stream_2\tbus_space_read_region_2\n\n__inline void we_readmem;\n\n__inline void\nwe_readmem(wsc, from, to, len)\n\tstruct we_softc *wsc;\n\tint from;\n\tu_int8_t *to;\n\tint len;\n{\n\tbus_space_tag_t memt = wsc->sc_dp8390.sc_buft;\n\tbus_space_handle_t memh = wsc->sc_dp8390.sc_bufh;\n\n\tif (len & 1)\n\t\t++len;\n\n\tif (wsc->sc_16bitp)\n\t\tbus_space_read_region_stream_2(memt, memh, from,\n\t\t    (u_int16_t *)to, len >> 1);\n\telse\n\t\tbus_space_read_region_1(memt, memh, from,\n\t\t    to, len);\n}"
  },
  {
    "function_name": "we_test_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_we.c",
    "lines": "597-631",
    "snippet": "int\nwe_test_mem(sc)\n\tstruct dp8390_softc *sc;\n{\n\tstruct we_softc *wsc = (struct we_softc *)sc;\n\tbus_space_tag_t memt = sc->sc_buft;\n\tbus_space_handle_t memh = sc->sc_bufh;\n\tbus_size_t memsize = sc->mem_size;\n\tint i;\n\n\tif (wsc->sc_16bitp)\n\t\tbus_space_set_region_2(memt, memh, 0, 0, memsize >> 1);\n\telse\n\t\tbus_space_set_region_1(memt, memh, 0, 0, memsize);\n\n\tif (wsc->sc_16bitp) {\n\t\tfor (i = 0; i < memsize; i += 2) {\n\t\t\tif (bus_space_read_2(memt, memh, i) != 0)\n\t\t\t\tgoto fail;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < memsize; i++) {\n\t\t\tif (bus_space_read_1(memt, memh, i) != 0)\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\n\treturn (0);\n\n fail:\n\tprintf(\"%s: failed to clear shared memory at offset 0x%x\\n\",\n\t    sc->sc_dev.dv_xname, i);\n\tWE_MEM_DISABLE(wsc);\n\treturn (1);\n}",
    "includes": [
      "#include <dev/isa/if_wereg.h>",
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"we.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\twe_test_mem"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WE_MEM_DISABLE",
          "args": [
            "wsc"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: failed to clear shared memory at offset 0x%x\\n\"",
            "sc->sc_dev.dv_xname",
            "i"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "memt",
            "memh",
            "i"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "memt",
            "memh",
            "i"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_set_region_1",
          "args": [
            "memt",
            "memh",
            "0",
            "0",
            "memsize"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_set_region_2",
          "args": [
            "memt",
            "memh",
            "0",
            "0",
            "memsize >> 1"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_wereg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"we.h\"\n#include \"bpfilter.h\"\n\nint\twe_test_mem;\n\nint\nwe_test_mem(sc)\n\tstruct dp8390_softc *sc;\n{\n\tstruct we_softc *wsc = (struct we_softc *)sc;\n\tbus_space_tag_t memt = sc->sc_buft;\n\tbus_space_handle_t memh = sc->sc_bufh;\n\tbus_size_t memsize = sc->mem_size;\n\tint i;\n\n\tif (wsc->sc_16bitp)\n\t\tbus_space_set_region_2(memt, memh, 0, 0, memsize >> 1);\n\telse\n\t\tbus_space_set_region_1(memt, memh, 0, 0, memsize);\n\n\tif (wsc->sc_16bitp) {\n\t\tfor (i = 0; i < memsize; i += 2) {\n\t\t\tif (bus_space_read_2(memt, memh, i) != 0)\n\t\t\t\tgoto fail;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < memsize; i++) {\n\t\t\tif (bus_space_read_1(memt, memh, i) != 0)\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\n\treturn (0);\n\n fail:\n\tprintf(\"%s: failed to clear shared memory at offset 0x%x\\n\",\n\t    sc->sc_dev.dv_xname, i);\n\tWE_MEM_DISABLE(wsc);\n\treturn (1);\n}"
  },
  {
    "function_name": "we_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_we.c",
    "lines": "362-595",
    "snippet": "void\nwe_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct we_softc *wsc = (struct we_softc *)self;\n\tstruct dp8390_softc *sc = &wsc->sc_dp8390;\n\tstruct isa_attach_args *ia = aux;\n\tbus_space_tag_t nict, asict, memt;\n\tbus_space_handle_t nich, asich, memh;\n\tconst char *typestr;\n\tu_int8_t x;\n\tint i;\n\n\tnict = asict = ia->ia_iot;\n\tmemt = ia->ia_memt;\n\n\t/* Map the device. */\n\tif (!strcmp(parent->dv_cfdata->cf_driver->cd_name, \"isapnp\") && ia->ia_ioh)\n\t\tasich = ia->ia_ioh;\n\telse if (bus_space_map(asict, ia->ia_iobase, WE_NPORTS, 0, &asich)) {\n\t\tprintf(\": can't map nic i/o space\\n\");\n\t\treturn;\n\t}\n\n\tif (bus_space_subregion(asict, asich, WE_NIC_OFFSET, WE_NIC_NPORTS,\n\t    &nich)) {\n\t\tprintf(\": can't subregion i/o space\\n\");\n\t\treturn;\n\t}\n\n\ttypestr = we_params(asict, asich, &wsc->sc_type, NULL,\n\t    &wsc->sc_16bitp, &sc->is790);\n\tif (typestr == NULL) {\n\t\tprintf(\": where did the card go?\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * Map memory space.  Note we use the size that might have\n\t * been overridden by the user.\n\t */\n\tif (!strcmp(parent->dv_cfdata->cf_driver->cd_name, \"isapnp\") && ia->ia_memh)\n\t\tmemh = ia->ia_memh;\n\telse if (bus_space_map(memt, ia->ia_maddr, ia->ia_msize, 0, &memh)) {\n\t\tprintf(\": can't map shared memory\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * Allow user to override 16-bit mode.  8-bit takes precedence.\n\t */\n\tif (self->dv_cfdata->cf_flags & WE_FLAGS_FORCE_16BIT_MODE)\n\t\twsc->sc_16bitp = 1;\n\tif (self->dv_cfdata->cf_flags & WE_FLAGS_FORCE_8BIT_MODE)\n\t\twsc->sc_16bitp = 0;\n\n\twsc->sc_asict = asict;\n\twsc->sc_asich = asich;\n\n\tsc->sc_regt = nict;\n\tsc->sc_regh = nich;\n\n\tsc->sc_buft = memt;\n\tsc->sc_bufh = memh;\n\n\t/* Interface is always enabled. */\n\tsc->sc_enabled = 1;\n\n\t/* Registers are linear. */\n\tfor (i = 0; i < 16; i++)\n\t\tsc->sc_reg_map[i] = i;\n\n\t/* Now we can use the NIC_{GET,PUT}() macros. */\n\n\tprintf(\": %s (%s-bit)\\n\", typestr, wsc->sc_16bitp ? \"16\" : \"8\");\n\n\t/* Get station address from EEPROM. */\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n#ifdef __NetBSD__\n\t\tsc->sc_enaddr[i] = bus_space_read_1(asict, asich, WE_PROM + i);\n#else\n\t\tsc->sc_arpcom.ac_enaddr[i] =\n\t\t    bus_space_read_1(asict, asich, WE_PROM + i);\n#endif\n\n\t/*\n\t * Set upper address bits and 8/16 bit access to shared memory.\n\t */\n\tif (sc->is790) {\n\t\twsc->sc_laar_proto =\n\t\t    bus_space_read_1(asict, asich, WE_LAAR) &\n\t\t    ~WE_LAAR_M16EN;\n\t\tbus_space_write_1(asict, asich, WE_LAAR,\n\t\t    wsc->sc_laar_proto | (wsc->sc_16bitp ? WE_LAAR_M16EN : 0));\n\t} else if ((wsc->sc_type & WE_SOFTCONFIG) ||\n#ifdef TOSH_ETHER\n\t    (wsc->sc_type == WE_TYPE_TOSHIBA1) ||\n\t    (wsc->sc_type == WE_TYPE_TOSHIBA4) ||\n#endif\n\t    (wsc->sc_type == WE_TYPE_WD8013EBT)) {\n\t\twsc->sc_laar_proto = (ia->ia_maddr >> 19) & WE_LAAR_ADDRHI;\n\t\tif (wsc->sc_16bitp)\n\t\t\twsc->sc_laar_proto |= WE_LAAR_L16EN;\n\t\tbus_space_write_1(asict, asich, WE_LAAR,\n\t\t    wsc->sc_laar_proto | (wsc->sc_16bitp ? WE_LAAR_M16EN : 0));\n\t}\n\n\t/*\n\t * Set address and enable interface shared memory.\n\t */\n\tif (sc->is790) {\n\t\t/* XXX MAGIC CONSTANTS XXX */\n\t\tx = bus_space_read_1(asict, asich, 0x04);\n\t\tbus_space_write_1(asict, asich, 0x04, x | 0x80);\n\t\tbus_space_write_1(asict, asich, 0x0b,\n\t\t    ((ia->ia_maddr >> 13) & 0x0f) |\n\t\t    ((ia->ia_maddr >> 11) & 0x40) |\n\t\t    (bus_space_read_1(asict, asich, 0x0b) & 0xb0));\n\t\tbus_space_write_1(asict, asich, 0x04, x);\n\t\twsc->sc_msr_proto = 0x00;\n\t\tsc->cr_proto = 0x00;\n\t} else {\n#ifdef TOSH_ETHER\n\t\tif (wsc->sc_type == WE_TYPE_TOSHIBA1 ||\n\t\t    wsc->sc_type == WE_TYPE_TOSHIBA4) {\n\t\t\tbus_space_write_1(asict, asich, WE_MSR + 1,\n\t\t\t    ((ia->ia_maddr >> 8) & 0xe0) | 0x04);\n\t\t\tbus_space_write_1(asict, asich, WE_MSR + 2,\n\t\t\t    ((ia->ia_maddr >> 16) & 0x0f));\n\t\t\twsc->sc_msr_proto = WE_MSR_POW;\n\t\t} else\n#endif\n\t\t\twsc->sc_msr_proto = (ia->ia_maddr >> 13) &\n\t\t\t    WE_MSR_ADDR;\n\n\t\tsc->cr_proto = ED_CR_RD2;\n\t}\n\n\tbus_space_write_1(asict, asich, WE_MSR,\n\t    wsc->sc_msr_proto | WE_MSR_MENB);\n\tWE_DELAY(wsc);\n\n\t/*\n\t * DCR gets:\n\t *\n\t *\tFIFO threshold to 8, No auto-init Remote DMA,\n\t *\tbyte order=80x86.\n\t *\n\t * 16-bit cards also get word-wide DMA transfers.\n\t */\n\tsc->dcr_reg = ED_DCR_FT1 | ED_DCR_LS |\n\t    (wsc->sc_16bitp ? ED_DCR_WTS : 0);\n\n\tsc->test_mem = we_test_mem;\n\tsc->ring_copy = we_ring_copy;\n\tsc->write_mbuf = we_write_mbuf;\n\tsc->read_hdr = we_read_hdr;\n\tsc->recv_int = we_recv_int;\n\n\tsc->sc_mediachange = we_mediachange;\n\tsc->sc_mediastatus = we_mediastatus;\n\n\tsc->mem_start = 0;\n\tsc->mem_size = ia->ia_msize;\n\n\tsc->sc_flags = self->dv_cfdata->cf_flags;\n\n\t/* Do generic parts of attach. */\n\tif (wsc->sc_type & WE_SOFTCONFIG) {\n\t\tint defmedia = IFM_ETHER;\n\n\t\tif (sc->is790) {\n\t\t\tx = bus_space_read_1(asict, asich, WE790_HWR);\n\t\t\tbus_space_write_1(asict, asich, WE790_HWR,\n\t\t\t    x | WE790_HWR_SWH);\n\t\t\tif (bus_space_read_1(asict, asich, WE790_GCR) &\n\t\t\t    WE790_GCR_GPOUT)\n\t\t\t\tdefmedia |= IFM_10_2;\n\t\t\telse\n\t\t\t\tdefmedia |= IFM_10_5;\n\t\t\tbus_space_write_1(asict, asich, WE790_HWR,\n\t\t\t    x & ~WE790_HWR_SWH);\n\t\t} else {\n\t\t\tx = bus_space_read_1(asict, asich, WE_IRR);\n\t\t\tif (x & WE_IRR_OUT2)\n\t\t\t\tdefmedia |= IFM_10_2;\n\t\t\telse\n\t\t\t\tdefmedia |= IFM_10_5;\n\t\t}\n\t\ti = dp8390_config(sc, we_media, NWE_MEDIA, defmedia);\n\t} else\n\t\ti = dp8390_config(sc, NULL, 0, 0);\n\tif (i) {\n\t\tprintf(\"%s: configuration failed\\n\", sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\t/*\n\t * Disable 16-bit access to shared memory - we leave it disabled\n\t * so that:\n\t *\n\t *\t(1) machines reboot properly when the board is set to\n\t *\t    16-bit mode and there are conflicting 8-bit devices\n\t *\t    within the same 128k address space as this board's\n\t *\t    shared memory, and\n\t *\n\t *\t(2) so that other 8-bit devices with shared memory\n\t *\t    in this same 128k address space will work.\n\t */\n\tWE_MEM_DISABLE(wsc);\n\n\t/*\n\t * Enable the configured interrupt.\n\t */\n\tif (sc->is790)\n\t\tbus_space_write_1(asict, asich, WE790_ICR,\n\t\t    bus_space_read_1(asict, asich, WE790_ICR) |\n\t\t    WE790_ICR_EIL);\n\telse if (wsc->sc_type & WE_SOFTCONFIG)\n\t\tbus_space_write_1(asict, asich, WE_IRR,\n\t\t    bus_space_read_1(asict, asich, WE_IRR) | WE_IRR_IEN);\n\telse if (ia->ia_irq == IRQUNK) {\n\t\tprintf(\"%s: can't wildcard IRQ on a %s\\n\",\n\t\t    sc->sc_dev.dv_xname, typestr);\n\t\treturn;\n\t}\n\n\t/* Establish interrupt handler. */\n\twsc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,\n\t    IPL_NET, dp8390_intr, sc, sc->sc_dev.dv_xname);\n\tif (wsc->sc_ih == NULL)\n\t\tprintf(\"%s: can't establish interrupt\\n\", sc->sc_dev.dv_xname);\n}",
    "includes": [
      "#include <dev/isa/if_wereg.h>",
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"we.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define\tNWE_MEDIA\t(sizeof(we_media) / sizeof(we_media[0]))"
    ],
    "globals_used": [
      "void\twe_attach",
      "const char *we_params",
      "int\twe_mediachange",
      "void\twe_mediastatus",
      "void\twe_recv_int",
      "int\twe_write_mbuf",
      "int\twe_ring_copy",
      "void\twe_read_hdr",
      "int\twe_test_mem",
      "int we_media[] = {\n\tIFM_ETHER|IFM_10_2,\n\tIFM_ETHER|IFM_10_5,\n};",
      "const char *\nwe_params(asict, asich, typep, memsizep, is16bitp, is790p)\n\tbus_space_tag_t asict;",
      "bus_space_handle_t asich;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: can't establish interrupt\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "isa_intr_establish",
          "args": [
            "ia->ia_ic",
            "ia->ia_irq",
            "IST_EDGE",
            "IPL_NET",
            "dp8390_intr",
            "sc",
            "sc->sc_dev.dv_xname"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "asict",
            "asich",
            "WE_IRR",
            "bus_space_read_1(asict, asich, WE_IRR) | WE_IRR_IEN"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "asict",
            "asich",
            "WE_IRR"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "asict",
            "asich",
            "WE790_ICR",
            "bus_space_read_1(asict, asich, WE790_ICR) |\n\t\t    WE790_ICR_EIL"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "asict",
            "asich",
            "WE790_ICR"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WE_MEM_DISABLE",
          "args": [
            "wsc"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp8390_config",
          "args": [
            "sc",
            "NULL",
            "0",
            "0"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "dp8390_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dp8390.c",
          "lines": "86-158",
          "snippet": "int\ndp8390_config(sc, media, nmedia, defmedia)\n\tstruct dp8390_softc *sc;\n\tint *media, nmedia, defmedia;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint i, rv;\n\n\trv = 1;\n\n\tif (!sc->test_mem)\n\t\tsc->test_mem = dp8390_test_mem;\n\n\t/* Allocate one xmit buffer if < 16k, two buffers otherwise. */\n\tif ((sc->mem_size < 16384) ||\n\t    (sc->sc_flags & DP8390_NO_MULTI_BUFFERING))\n\t\tsc->txb_cnt = 1;\n\telse if (sc->mem_size < 8192 * 3)\n\t\tsc->txb_cnt = 2;\n\telse\n\t\tsc->txb_cnt = 3;\n\n\tsc->tx_page_start = sc->mem_start >> ED_PAGE_SHIFT;\n\tsc->rec_page_start = sc->tx_page_start + sc->txb_cnt * ED_TXBUF_SIZE;\n\tsc->rec_page_stop = sc->tx_page_start + (sc->mem_size >> ED_PAGE_SHIFT);\n\tsc->mem_ring = sc->mem_start + (sc->rec_page_start << ED_PAGE_SHIFT);\n\tsc->mem_end = sc->mem_start + sc->mem_size;\n\n\t/* Now zero memory and verify that it is clear. */\n\tif ((*sc->test_mem)(sc))\n\t\tgoto out;\n\n\t/* Set interface to stopped condition (reset). */\n\tdp8390_stop(sc);\n\n\t/* Initialize ifnet structure. */\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_start = dp8390_start;\n\tifp->if_ioctl = dp8390_ioctl;\n\tif (!ifp->if_watchdog)\n\t\tifp->if_watchdog = dp8390_watchdog;\n\tifp->if_flags =\n\t    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;\n\tifp->if_snd.ifq_maxlen = IFQ_MAXLEN;\n\n\t/* Initialize media goo. */\n\tifmedia_init(&sc->sc_media, 0, dp8390_mediachange, dp8390_mediastatus);\n\tif (media != NULL) {\n\t\tfor (i = 0; i < nmedia; i++)\n\t\t\tifmedia_add(&sc->sc_media, media[i], 0, NULL);\n\t\tifmedia_set(&sc->sc_media, defmedia);\n\t} else {\n\t\tifmedia_add(&sc->sc_media, IFM_ETHER|IFM_MANUAL, 0, NULL);\n\t\tifmedia_set(&sc->sc_media, IFM_ETHER|IFM_MANUAL);\n\t}\n\n\t/* Attach the interface. */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n#if NBPFILTER > 0\n\tbpfattach(&sc->sc_arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,\n\t\tsizeof(struct ether_header));\n#endif\n\n\t/* Print additional info when attached. */\n\tprintf(\"%s: address %s\\n\", sc->sc_dev.dv_xname,\n\t    ether_sprintf(sc->sc_arpcom.ac_enaddr));\n\n\trv = 0;\nout:\n\treturn (rv);\n}",
          "includes": [
            "#include <dev/ic/dp8390var.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\tdp8390_test_mem",
            "int\tdp8390_mediachange",
            "void\tdp8390_mediastatus",
            "struct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic int\t\tdp8390_test_mem;\nint\tdp8390_mediachange;\nvoid\tdp8390_mediastatus;\nstruct mbuf *\ndp8390_get(sc, src, total_len)\n\tstruct dp8390_softc *sc;\n\nint\ndp8390_config(sc, media, nmedia, defmedia)\n\tstruct dp8390_softc *sc;\n\tint *media, nmedia, defmedia;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint i, rv;\n\n\trv = 1;\n\n\tif (!sc->test_mem)\n\t\tsc->test_mem = dp8390_test_mem;\n\n\t/* Allocate one xmit buffer if < 16k, two buffers otherwise. */\n\tif ((sc->mem_size < 16384) ||\n\t    (sc->sc_flags & DP8390_NO_MULTI_BUFFERING))\n\t\tsc->txb_cnt = 1;\n\telse if (sc->mem_size < 8192 * 3)\n\t\tsc->txb_cnt = 2;\n\telse\n\t\tsc->txb_cnt = 3;\n\n\tsc->tx_page_start = sc->mem_start >> ED_PAGE_SHIFT;\n\tsc->rec_page_start = sc->tx_page_start + sc->txb_cnt * ED_TXBUF_SIZE;\n\tsc->rec_page_stop = sc->tx_page_start + (sc->mem_size >> ED_PAGE_SHIFT);\n\tsc->mem_ring = sc->mem_start + (sc->rec_page_start << ED_PAGE_SHIFT);\n\tsc->mem_end = sc->mem_start + sc->mem_size;\n\n\t/* Now zero memory and verify that it is clear. */\n\tif ((*sc->test_mem)(sc))\n\t\tgoto out;\n\n\t/* Set interface to stopped condition (reset). */\n\tdp8390_stop(sc);\n\n\t/* Initialize ifnet structure. */\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_start = dp8390_start;\n\tifp->if_ioctl = dp8390_ioctl;\n\tif (!ifp->if_watchdog)\n\t\tifp->if_watchdog = dp8390_watchdog;\n\tifp->if_flags =\n\t    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;\n\tifp->if_snd.ifq_maxlen = IFQ_MAXLEN;\n\n\t/* Initialize media goo. */\n\tifmedia_init(&sc->sc_media, 0, dp8390_mediachange, dp8390_mediastatus);\n\tif (media != NULL) {\n\t\tfor (i = 0; i < nmedia; i++)\n\t\t\tifmedia_add(&sc->sc_media, media[i], 0, NULL);\n\t\tifmedia_set(&sc->sc_media, defmedia);\n\t} else {\n\t\tifmedia_add(&sc->sc_media, IFM_ETHER|IFM_MANUAL, 0, NULL);\n\t\tifmedia_set(&sc->sc_media, IFM_ETHER|IFM_MANUAL);\n\t}\n\n\t/* Attach the interface. */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n#if NBPFILTER > 0\n\tbpfattach(&sc->sc_arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,\n\t\tsizeof(struct ether_header));\n#endif\n\n\t/* Print additional info when attached. */\n\tprintf(\"%s: address %s\\n\", sc->sc_dev.dv_xname,\n\t    ether_sprintf(sc->sc_arpcom.ac_enaddr));\n\n\trv = 0;\nout:\n\treturn (rv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "asict",
            "asich",
            "WE_IRR"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "asict",
            "asich",
            "WE790_HWR",
            "x & ~WE790_HWR_SWH"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "asict",
            "asich",
            "WE790_GCR"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "asict",
            "asich",
            "WE790_HWR",
            "x | WE790_HWR_SWH"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "asict",
            "asich",
            "WE790_HWR"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WE_DELAY",
          "args": [
            "wsc"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "asict",
            "asich",
            "WE_MSR",
            "wsc->sc_msr_proto | WE_MSR_MENB"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "asict",
            "asich",
            "WE_MSR + 2",
            "((ia->ia_maddr >> 16) & 0x0f)"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "asict",
            "asich",
            "WE_MSR + 1",
            "((ia->ia_maddr >> 8) & 0xe0) | 0x04"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "asict",
            "asich",
            "0x04",
            "x"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "asict",
            "asich",
            "0x0b",
            "((ia->ia_maddr >> 13) & 0x0f) |\n\t\t    ((ia->ia_maddr >> 11) & 0x40) |\n\t\t    (bus_space_read_1(asict, asich, 0x0b) & 0xb0)"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "asict",
            "asich",
            "0x0b"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "asict",
            "asich",
            "0x04",
            "x | 0x80"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "asict",
            "asich",
            "0x04"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "asict",
            "asich",
            "WE_LAAR",
            "wsc->sc_laar_proto | (wsc->sc_16bitp ? WE_LAAR_M16EN : 0)"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TOSH_ETHER",
          "args": [
            "wsc->sc_type == WE_TYPE_TOSHIBA1"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "asict",
            "asich",
            "WE_LAAR",
            "wsc->sc_laar_proto | (wsc->sc_16bitp ? WE_LAAR_M16EN : 0)"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "asict",
            "asich",
            "WE_LAAR"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "asict",
            "asich",
            "WE_PROM + i"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "asict",
            "asich",
            "WE_PROM + i"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "memt",
            "ia->ia_maddr",
            "ia->ia_msize",
            "0",
            "&memh"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "parent->dv_cfdata->cf_driver->cd_name",
            "\"isapnp\""
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "we_params",
          "args": [
            "asict",
            "asich",
            "&wsc->sc_type",
            "NULL",
            "&wsc->sc_16bitp",
            "&sc->is790"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_subregion",
          "args": [
            "asict",
            "asich",
            "WE_NIC_OFFSET",
            "WE_NIC_NPORTS",
            "&nich"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "asict",
            "ia->ia_iobase",
            "WE_NPORTS",
            "0",
            "&asich"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "parent->dv_cfdata->cf_driver->cd_name",
            "\"isapnp\""
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_wereg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"we.h\"\n#include \"bpfilter.h\"\n\n#define\tNWE_MEDIA\t(sizeof(we_media) / sizeof(we_media[0]))\n\nvoid\twe_attach;\nconst char *we_params;\nint\twe_mediachange;\nvoid\twe_mediastatus;\nvoid\twe_recv_int;\nint\twe_write_mbuf;\nint\twe_ring_copy;\nvoid\twe_read_hdr;\nint\twe_test_mem;\nint we_media[] = {\n\tIFM_ETHER|IFM_10_2,\n\tIFM_ETHER|IFM_10_5,\n};\nconst char *\nwe_params(asict, asich, typep, memsizep, is16bitp, is790p)\n\tbus_space_tag_t asict;\nbus_space_handle_t asich;\n\nvoid\nwe_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct we_softc *wsc = (struct we_softc *)self;\n\tstruct dp8390_softc *sc = &wsc->sc_dp8390;\n\tstruct isa_attach_args *ia = aux;\n\tbus_space_tag_t nict, asict, memt;\n\tbus_space_handle_t nich, asich, memh;\n\tconst char *typestr;\n\tu_int8_t x;\n\tint i;\n\n\tnict = asict = ia->ia_iot;\n\tmemt = ia->ia_memt;\n\n\t/* Map the device. */\n\tif (!strcmp(parent->dv_cfdata->cf_driver->cd_name, \"isapnp\") && ia->ia_ioh)\n\t\tasich = ia->ia_ioh;\n\telse if (bus_space_map(asict, ia->ia_iobase, WE_NPORTS, 0, &asich)) {\n\t\tprintf(\": can't map nic i/o space\\n\");\n\t\treturn;\n\t}\n\n\tif (bus_space_subregion(asict, asich, WE_NIC_OFFSET, WE_NIC_NPORTS,\n\t    &nich)) {\n\t\tprintf(\": can't subregion i/o space\\n\");\n\t\treturn;\n\t}\n\n\ttypestr = we_params(asict, asich, &wsc->sc_type, NULL,\n\t    &wsc->sc_16bitp, &sc->is790);\n\tif (typestr == NULL) {\n\t\tprintf(\": where did the card go?\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * Map memory space.  Note we use the size that might have\n\t * been overridden by the user.\n\t */\n\tif (!strcmp(parent->dv_cfdata->cf_driver->cd_name, \"isapnp\") && ia->ia_memh)\n\t\tmemh = ia->ia_memh;\n\telse if (bus_space_map(memt, ia->ia_maddr, ia->ia_msize, 0, &memh)) {\n\t\tprintf(\": can't map shared memory\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * Allow user to override 16-bit mode.  8-bit takes precedence.\n\t */\n\tif (self->dv_cfdata->cf_flags & WE_FLAGS_FORCE_16BIT_MODE)\n\t\twsc->sc_16bitp = 1;\n\tif (self->dv_cfdata->cf_flags & WE_FLAGS_FORCE_8BIT_MODE)\n\t\twsc->sc_16bitp = 0;\n\n\twsc->sc_asict = asict;\n\twsc->sc_asich = asich;\n\n\tsc->sc_regt = nict;\n\tsc->sc_regh = nich;\n\n\tsc->sc_buft = memt;\n\tsc->sc_bufh = memh;\n\n\t/* Interface is always enabled. */\n\tsc->sc_enabled = 1;\n\n\t/* Registers are linear. */\n\tfor (i = 0; i < 16; i++)\n\t\tsc->sc_reg_map[i] = i;\n\n\t/* Now we can use the NIC_{GET,PUT}() macros. */\n\n\tprintf(\": %s (%s-bit)\\n\", typestr, wsc->sc_16bitp ? \"16\" : \"8\");\n\n\t/* Get station address from EEPROM. */\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n#ifdef __NetBSD__\n\t\tsc->sc_enaddr[i] = bus_space_read_1(asict, asich, WE_PROM + i);\n#else\n\t\tsc->sc_arpcom.ac_enaddr[i] =\n\t\t    bus_space_read_1(asict, asich, WE_PROM + i);\n#endif\n\n\t/*\n\t * Set upper address bits and 8/16 bit access to shared memory.\n\t */\n\tif (sc->is790) {\n\t\twsc->sc_laar_proto =\n\t\t    bus_space_read_1(asict, asich, WE_LAAR) &\n\t\t    ~WE_LAAR_M16EN;\n\t\tbus_space_write_1(asict, asich, WE_LAAR,\n\t\t    wsc->sc_laar_proto | (wsc->sc_16bitp ? WE_LAAR_M16EN : 0));\n\t} else if ((wsc->sc_type & WE_SOFTCONFIG) ||\n#ifdef TOSH_ETHER\n\t    (wsc->sc_type == WE_TYPE_TOSHIBA1) ||\n\t    (wsc->sc_type == WE_TYPE_TOSHIBA4) ||\n#endif\n\t    (wsc->sc_type == WE_TYPE_WD8013EBT)) {\n\t\twsc->sc_laar_proto = (ia->ia_maddr >> 19) & WE_LAAR_ADDRHI;\n\t\tif (wsc->sc_16bitp)\n\t\t\twsc->sc_laar_proto |= WE_LAAR_L16EN;\n\t\tbus_space_write_1(asict, asich, WE_LAAR,\n\t\t    wsc->sc_laar_proto | (wsc->sc_16bitp ? WE_LAAR_M16EN : 0));\n\t}\n\n\t/*\n\t * Set address and enable interface shared memory.\n\t */\n\tif (sc->is790) {\n\t\t/* XXX MAGIC CONSTANTS XXX */\n\t\tx = bus_space_read_1(asict, asich, 0x04);\n\t\tbus_space_write_1(asict, asich, 0x04, x | 0x80);\n\t\tbus_space_write_1(asict, asich, 0x0b,\n\t\t    ((ia->ia_maddr >> 13) & 0x0f) |\n\t\t    ((ia->ia_maddr >> 11) & 0x40) |\n\t\t    (bus_space_read_1(asict, asich, 0x0b) & 0xb0));\n\t\tbus_space_write_1(asict, asich, 0x04, x);\n\t\twsc->sc_msr_proto = 0x00;\n\t\tsc->cr_proto = 0x00;\n\t} else {\n#ifdef TOSH_ETHER\n\t\tif (wsc->sc_type == WE_TYPE_TOSHIBA1 ||\n\t\t    wsc->sc_type == WE_TYPE_TOSHIBA4) {\n\t\t\tbus_space_write_1(asict, asich, WE_MSR + 1,\n\t\t\t    ((ia->ia_maddr >> 8) & 0xe0) | 0x04);\n\t\t\tbus_space_write_1(asict, asich, WE_MSR + 2,\n\t\t\t    ((ia->ia_maddr >> 16) & 0x0f));\n\t\t\twsc->sc_msr_proto = WE_MSR_POW;\n\t\t} else\n#endif\n\t\t\twsc->sc_msr_proto = (ia->ia_maddr >> 13) &\n\t\t\t    WE_MSR_ADDR;\n\n\t\tsc->cr_proto = ED_CR_RD2;\n\t}\n\n\tbus_space_write_1(asict, asich, WE_MSR,\n\t    wsc->sc_msr_proto | WE_MSR_MENB);\n\tWE_DELAY(wsc);\n\n\t/*\n\t * DCR gets:\n\t *\n\t *\tFIFO threshold to 8, No auto-init Remote DMA,\n\t *\tbyte order=80x86.\n\t *\n\t * 16-bit cards also get word-wide DMA transfers.\n\t */\n\tsc->dcr_reg = ED_DCR_FT1 | ED_DCR_LS |\n\t    (wsc->sc_16bitp ? ED_DCR_WTS : 0);\n\n\tsc->test_mem = we_test_mem;\n\tsc->ring_copy = we_ring_copy;\n\tsc->write_mbuf = we_write_mbuf;\n\tsc->read_hdr = we_read_hdr;\n\tsc->recv_int = we_recv_int;\n\n\tsc->sc_mediachange = we_mediachange;\n\tsc->sc_mediastatus = we_mediastatus;\n\n\tsc->mem_start = 0;\n\tsc->mem_size = ia->ia_msize;\n\n\tsc->sc_flags = self->dv_cfdata->cf_flags;\n\n\t/* Do generic parts of attach. */\n\tif (wsc->sc_type & WE_SOFTCONFIG) {\n\t\tint defmedia = IFM_ETHER;\n\n\t\tif (sc->is790) {\n\t\t\tx = bus_space_read_1(asict, asich, WE790_HWR);\n\t\t\tbus_space_write_1(asict, asich, WE790_HWR,\n\t\t\t    x | WE790_HWR_SWH);\n\t\t\tif (bus_space_read_1(asict, asich, WE790_GCR) &\n\t\t\t    WE790_GCR_GPOUT)\n\t\t\t\tdefmedia |= IFM_10_2;\n\t\t\telse\n\t\t\t\tdefmedia |= IFM_10_5;\n\t\t\tbus_space_write_1(asict, asich, WE790_HWR,\n\t\t\t    x & ~WE790_HWR_SWH);\n\t\t} else {\n\t\t\tx = bus_space_read_1(asict, asich, WE_IRR);\n\t\t\tif (x & WE_IRR_OUT2)\n\t\t\t\tdefmedia |= IFM_10_2;\n\t\t\telse\n\t\t\t\tdefmedia |= IFM_10_5;\n\t\t}\n\t\ti = dp8390_config(sc, we_media, NWE_MEDIA, defmedia);\n\t} else\n\t\ti = dp8390_config(sc, NULL, 0, 0);\n\tif (i) {\n\t\tprintf(\"%s: configuration failed\\n\", sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\t/*\n\t * Disable 16-bit access to shared memory - we leave it disabled\n\t * so that:\n\t *\n\t *\t(1) machines reboot properly when the board is set to\n\t *\t    16-bit mode and there are conflicting 8-bit devices\n\t *\t    within the same 128k address space as this board's\n\t *\t    shared memory, and\n\t *\n\t *\t(2) so that other 8-bit devices with shared memory\n\t *\t    in this same 128k address space will work.\n\t */\n\tWE_MEM_DISABLE(wsc);\n\n\t/*\n\t * Enable the configured interrupt.\n\t */\n\tif (sc->is790)\n\t\tbus_space_write_1(asict, asich, WE790_ICR,\n\t\t    bus_space_read_1(asict, asich, WE790_ICR) |\n\t\t    WE790_ICR_EIL);\n\telse if (wsc->sc_type & WE_SOFTCONFIG)\n\t\tbus_space_write_1(asict, asich, WE_IRR,\n\t\t    bus_space_read_1(asict, asich, WE_IRR) | WE_IRR_IEN);\n\telse if (ia->ia_irq == IRQUNK) {\n\t\tprintf(\"%s: can't wildcard IRQ on a %s\\n\",\n\t\t    sc->sc_dev.dv_xname, typestr);\n\t\treturn;\n\t}\n\n\t/* Establish interrupt handler. */\n\twsc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,\n\t    IPL_NET, dp8390_intr, sc, sc->sc_dev.dv_xname);\n\tif (wsc->sc_ih == NULL)\n\t\tprintf(\"%s: can't establish interrupt\\n\", sc->sc_dev.dv_xname);\n}"
  },
  {
    "function_name": "we_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_we.c",
    "lines": "217-360",
    "snippet": "int\nwe_probe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct isa_attach_args *ia = aux;\n\tstruct cfdata *cf = match;\n\tbus_space_tag_t asict, memt;\n\tbus_space_handle_t asich, memh;\n\tbus_size_t memsize;\n\tint asich_valid, memh_valid;\n\tint i, is790, rv = 0;\n\tu_int8_t x, type;\n\n\tasict = ia->ia_iot;\n\tmemt = ia->ia_memt;\n\n\tasich_valid = memh_valid = 0;\n\n\t/* Disallow wildcarded i/o addresses. */\n\tif (ia->ia_iobase == -1 /* ISACF_PORT_DEFAULT */)\n\t\treturn (0);\n\n\t/* Disallow wildcarded mem address. */\n\tif (ia->ia_maddr == -1 /* ISACF_IOMEM_DEFAULT */)\n\t\treturn (0);\n\n\t/* Attempt to map the device. */\n\tif (!strcmp(parent->dv_cfdata->cf_driver->cd_name, \"isapnp\") && ia->ia_ioh)\n\t\tasich = ia->ia_ioh;\n\telse {\n\t\tif (bus_space_map(asict, ia->ia_iobase, WE_NPORTS, 0, &asich))\n\t\t\tgoto out;\n\t\tasich_valid = 1;\n\t}\n\n#ifdef TOSH_ETHER\n\tbus_space_write_1(asict, asich, WE_MSR, WE_MSR_POW);\n#endif\n\n\t/*\n\t * Attempt to do a checksum over the station address PROM.\n\t * If it fails, it's probably not a WD/SMC board.  There is\n\t * a problem with this, though.  Some clone WD8003E boards\n\t * (e.g. Danpex) won't pass the checksum.  In this case,\n\t * the checksum byte always seems to be 0.\n\t */\n\tfor (x = 0, i = 0; i < 8; i++)\n\t\tx += bus_space_read_1(asict, asich, WE_PROM + i);\n\n\tif (x != WE_ROM_CHECKSUM_TOTAL) {\n\t\t/* Make sure it's an 8003E clone... */\n\t\tif (bus_space_read_1(asict, asich, WE_CARD_ID) !=\n\t\t    WE_TYPE_WD8003E)\n\t\t\tgoto out;\n\n\t\t/* Check the checksum byte. */\n\t\tif (bus_space_read_1(asict, asich, WE_PROM + 7) != 0)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Reset the card to force it into a known state.\n\t */\n#ifdef TOSH_ETHER\n\tbus_space_write_1(asict, asich, WE_MSR, WE_MSR_RST | WE_MSR_POW);\n#else\n\tbus_space_write_1(asict, asich, WE_MSR, WE_MSR_RST);\n#endif\n\tdelay(100);\n\n\tbus_space_write_1(asict, asich, WE_MSR,\n\t    bus_space_read_1(asict, asich, WE_MSR) & ~WE_MSR_RST);\n\n\t/* Wait in case the card is reading it's EEPROM. */\n\tdelay(5000);\n\n\t/*\n\t * Get parameters.\n\t */\n\tif (we_params(asict, asich, &type, &memsize, NULL, &is790) == NULL)\n\t\tgoto out;\n\n\t/* Allow user to override probed value. */\n\tif (ia->ia_msize)\n\t\tmemsize = ia->ia_msize;\n\n\t/* Attempt to map the memory space. */\n\tif (!strcmp(parent->dv_cfdata->cf_driver->cd_name, \"isapnp\") && ia->ia_memh)\n\t\tmemh = ia->ia_memh;\n\telse {\n\t\tif (bus_space_map(memt, ia->ia_maddr, memsize, 0, &memh))\n\t\t\tgoto out;\n\t\tmemh_valid = 1;\n\t}\n\n\t/*\n\t * If possible, get the assigned interrupt number from the card\n\t * and use it.\n\t */\n\tif (is790) {\n\t\tu_int8_t hwr;\n\n\t\t/* Assemble together the encoded interrupt number. */\n\t\thwr = bus_space_read_1(asict, asich, WE790_HWR);\n\t\tbus_space_write_1(asict, asich, WE790_HWR,\n\t\t    hwr | WE790_HWR_SWH);\n\n\t\tx = bus_space_read_1(asict, asich, WE790_GCR);\n\t\ti = ((x & WE790_GCR_IR2) >> 4) |\n\t\t    ((x & (WE790_GCR_IR1|WE790_GCR_IR0)) >> 2);\n\t\tbus_space_write_1(asict, asich, WE790_HWR,\n\t\t    hwr & ~WE790_HWR_SWH);\n\n\t\tif (ia->ia_irq != IRQUNK && ia->ia_irq != we_790_irq[i])\n\t\t\tprintf(\"%s%d: changing IRQ %d to %d\\n\",\n\t\t\t    we_cd.cd_name, cf->cf_unit, ia->ia_irq,\n\t\t\t    we_790_irq[i]);\n\t\tia->ia_irq = we_790_irq[i];\n\t} else if (type & WE_SOFTCONFIG) {\n\t\t/* Assemble together the encoded interrupt number. */\n\t\ti = (bus_space_read_1(asict, asich, WE_ICR) & WE_ICR_IR2) |\n\t\t    ((bus_space_read_1(asict, asich, WE_IRR) &\n\t\t      (WE_IRR_IR0 | WE_IRR_IR1)) >> 5);\n\n\t\tif (ia->ia_irq != IRQUNK && ia->ia_irq != we_584_irq[i])\n\t\t\tprintf(\"%s%d: changing IRQ %d to %d\\n\",\n\t\t\t    we_cd.cd_name, cf->cf_unit, ia->ia_irq,\n\t\t\t    we_584_irq[i]);\n\t\tia->ia_irq = we_584_irq[i];\n\t}\n\n\t/* So, we say we've found it! */\n\tia->ia_iosize = WE_NPORTS;\n\tia->ia_msize = memsize;\n\trv = 1;\n\n out:\n\tif (asich_valid)\n\t\tbus_space_unmap(asict, asich, WE_NPORTS);\n\tif (memh_valid)\n\t\tbus_space_unmap(memt, memh, memsize);\n\treturn (rv);\n}",
    "includes": [
      "#include <dev/isa/if_wereg.h>",
      "#include <dev/ic/dp8390var.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"we.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\twe_probe",
      "const char *we_params",
      "static const int we_584_irq[] = {\n\t9, 3, 5, 7, 10, 11, 15, 4,\n};",
      "static const int we_790_irq[] = {\n\tIRQUNK, 9, 3, 5, 7, 10, 11, 15,\n};",
      "const char *\nwe_params(asict, asich, typep, memsizep, is16bitp, is790p)\n\tbus_space_tag_t asict;",
      "bus_space_handle_t asich;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "memt",
            "memh",
            "memsize"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "asict",
            "asich",
            "WE_NPORTS"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s%d: changing IRQ %d to %d\\n\"",
            "we_cd.cd_name",
            "cf->cf_unit",
            "ia->ia_irq",
            "we_584_irq[i]"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "asict",
            "asich",
            "WE_IRR"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "asict",
            "asich",
            "WE_ICR"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "asict",
            "asich",
            "WE790_HWR",
            "hwr & ~WE790_HWR_SWH"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "asict",
            "asich",
            "WE790_GCR"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "asict",
            "asich",
            "WE790_HWR",
            "hwr | WE790_HWR_SWH"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "asict",
            "asich",
            "WE790_HWR"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "memt",
            "ia->ia_maddr",
            "memsize",
            "0",
            "&memh"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "parent->dv_cfdata->cf_driver->cd_name",
            "\"isapnp\""
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "we_params",
          "args": [
            "asict",
            "asich",
            "&type",
            "&memsize",
            "NULL",
            "&is790"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "5000"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "asict",
            "asich",
            "WE_MSR",
            "bus_space_read_1(asict, asich, WE_MSR) & ~WE_MSR_RST"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "asict",
            "asich",
            "WE_MSR"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "asict",
            "asich",
            "WE_MSR",
            "WE_MSR_RST"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "asict",
            "asich",
            "WE_MSR",
            "WE_MSR_RST | WE_MSR_POW"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "asict",
            "asich",
            "WE_PROM + 7"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "asict",
            "asich",
            "WE_CARD_ID"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "asict",
            "asich",
            "WE_PROM + i"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "asict",
            "asich",
            "WE_MSR",
            "WE_MSR_POW"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "asict",
            "ia->ia_iobase",
            "WE_NPORTS",
            "0",
            "&asich"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "parent->dv_cfdata->cf_driver->cd_name",
            "\"isapnp\""
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/if_wereg.h>\n#include <dev/ic/dp8390var.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_ether.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"we.h\"\n#include \"bpfilter.h\"\n\nint\twe_probe;\nconst char *we_params;\nstatic const int we_584_irq[] = {\n\t9, 3, 5, 7, 10, 11, 15, 4,\n};\nstatic const int we_790_irq[] = {\n\tIRQUNK, 9, 3, 5, 7, 10, 11, 15,\n};\nconst char *\nwe_params(asict, asich, typep, memsizep, is16bitp, is790p)\n\tbus_space_tag_t asict;\nbus_space_handle_t asich;\n\nint\nwe_probe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct isa_attach_args *ia = aux;\n\tstruct cfdata *cf = match;\n\tbus_space_tag_t asict, memt;\n\tbus_space_handle_t asich, memh;\n\tbus_size_t memsize;\n\tint asich_valid, memh_valid;\n\tint i, is790, rv = 0;\n\tu_int8_t x, type;\n\n\tasict = ia->ia_iot;\n\tmemt = ia->ia_memt;\n\n\tasich_valid = memh_valid = 0;\n\n\t/* Disallow wildcarded i/o addresses. */\n\tif (ia->ia_iobase == -1 /* ISACF_PORT_DEFAULT */)\n\t\treturn (0);\n\n\t/* Disallow wildcarded mem address. */\n\tif (ia->ia_maddr == -1 /* ISACF_IOMEM_DEFAULT */)\n\t\treturn (0);\n\n\t/* Attempt to map the device. */\n\tif (!strcmp(parent->dv_cfdata->cf_driver->cd_name, \"isapnp\") && ia->ia_ioh)\n\t\tasich = ia->ia_ioh;\n\telse {\n\t\tif (bus_space_map(asict, ia->ia_iobase, WE_NPORTS, 0, &asich))\n\t\t\tgoto out;\n\t\tasich_valid = 1;\n\t}\n\n#ifdef TOSH_ETHER\n\tbus_space_write_1(asict, asich, WE_MSR, WE_MSR_POW);\n#endif\n\n\t/*\n\t * Attempt to do a checksum over the station address PROM.\n\t * If it fails, it's probably not a WD/SMC board.  There is\n\t * a problem with this, though.  Some clone WD8003E boards\n\t * (e.g. Danpex) won't pass the checksum.  In this case,\n\t * the checksum byte always seems to be 0.\n\t */\n\tfor (x = 0, i = 0; i < 8; i++)\n\t\tx += bus_space_read_1(asict, asich, WE_PROM + i);\n\n\tif (x != WE_ROM_CHECKSUM_TOTAL) {\n\t\t/* Make sure it's an 8003E clone... */\n\t\tif (bus_space_read_1(asict, asich, WE_CARD_ID) !=\n\t\t    WE_TYPE_WD8003E)\n\t\t\tgoto out;\n\n\t\t/* Check the checksum byte. */\n\t\tif (bus_space_read_1(asict, asich, WE_PROM + 7) != 0)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Reset the card to force it into a known state.\n\t */\n#ifdef TOSH_ETHER\n\tbus_space_write_1(asict, asich, WE_MSR, WE_MSR_RST | WE_MSR_POW);\n#else\n\tbus_space_write_1(asict, asich, WE_MSR, WE_MSR_RST);\n#endif\n\tdelay(100);\n\n\tbus_space_write_1(asict, asich, WE_MSR,\n\t    bus_space_read_1(asict, asich, WE_MSR) & ~WE_MSR_RST);\n\n\t/* Wait in case the card is reading it's EEPROM. */\n\tdelay(5000);\n\n\t/*\n\t * Get parameters.\n\t */\n\tif (we_params(asict, asich, &type, &memsize, NULL, &is790) == NULL)\n\t\tgoto out;\n\n\t/* Allow user to override probed value. */\n\tif (ia->ia_msize)\n\t\tmemsize = ia->ia_msize;\n\n\t/* Attempt to map the memory space. */\n\tif (!strcmp(parent->dv_cfdata->cf_driver->cd_name, \"isapnp\") && ia->ia_memh)\n\t\tmemh = ia->ia_memh;\n\telse {\n\t\tif (bus_space_map(memt, ia->ia_maddr, memsize, 0, &memh))\n\t\t\tgoto out;\n\t\tmemh_valid = 1;\n\t}\n\n\t/*\n\t * If possible, get the assigned interrupt number from the card\n\t * and use it.\n\t */\n\tif (is790) {\n\t\tu_int8_t hwr;\n\n\t\t/* Assemble together the encoded interrupt number. */\n\t\thwr = bus_space_read_1(asict, asich, WE790_HWR);\n\t\tbus_space_write_1(asict, asich, WE790_HWR,\n\t\t    hwr | WE790_HWR_SWH);\n\n\t\tx = bus_space_read_1(asict, asich, WE790_GCR);\n\t\ti = ((x & WE790_GCR_IR2) >> 4) |\n\t\t    ((x & (WE790_GCR_IR1|WE790_GCR_IR0)) >> 2);\n\t\tbus_space_write_1(asict, asich, WE790_HWR,\n\t\t    hwr & ~WE790_HWR_SWH);\n\n\t\tif (ia->ia_irq != IRQUNK && ia->ia_irq != we_790_irq[i])\n\t\t\tprintf(\"%s%d: changing IRQ %d to %d\\n\",\n\t\t\t    we_cd.cd_name, cf->cf_unit, ia->ia_irq,\n\t\t\t    we_790_irq[i]);\n\t\tia->ia_irq = we_790_irq[i];\n\t} else if (type & WE_SOFTCONFIG) {\n\t\t/* Assemble together the encoded interrupt number. */\n\t\ti = (bus_space_read_1(asict, asich, WE_ICR) & WE_ICR_IR2) |\n\t\t    ((bus_space_read_1(asict, asich, WE_IRR) &\n\t\t      (WE_IRR_IR0 | WE_IRR_IR1)) >> 5);\n\n\t\tif (ia->ia_irq != IRQUNK && ia->ia_irq != we_584_irq[i])\n\t\t\tprintf(\"%s%d: changing IRQ %d to %d\\n\",\n\t\t\t    we_cd.cd_name, cf->cf_unit, ia->ia_irq,\n\t\t\t    we_584_irq[i]);\n\t\tia->ia_irq = we_584_irq[i];\n\t}\n\n\t/* So, we say we've found it! */\n\tia->ia_iosize = WE_NPORTS;\n\tia->ia_msize = memsize;\n\trv = 1;\n\n out:\n\tif (asich_valid)\n\t\tbus_space_unmap(asict, asich, WE_NPORTS);\n\tif (memh_valid)\n\t\tbus_space_unmap(memt, memh, memsize);\n\treturn (rv);\n}"
  }
]