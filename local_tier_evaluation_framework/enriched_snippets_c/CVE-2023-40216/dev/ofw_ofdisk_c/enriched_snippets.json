[
  {
    "function_name": "ofdsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ofw/ofdisk.c",
    "lines": "357-376",
    "snippet": "int\nofdsize(dev)\n\tdev_t dev;\n{\n\tstruct ofd_softc *of;\n\tint part;\n\tint size;\n\t\n\tif (ofdopen(dev, 0, S_IFBLK) != 0)\n\t\treturn -1;\n\tof = ofdisk_cd.cd_devs[DISKUNIT(dev)];\n\tpart = DISKPART(dev);\n\tif (of->sc_dk.dk_label->d_partitions[part].p_fstype != FS_SWAP)\n\t\tsize = -1;\n\telse\n\t\tsize = of->sc_dk.dk_label->d_partitions[part].p_size;\n\tif (ofdclose(dev, 0, S_IFBLK) != 0)\n\t\treturn -1;\n\treturn size;\n}",
    "includes": [
      "#include <dev/ofw/openfirm.h>",
      "#include <sys/systm.h>",
      "#include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cfdriver ofdisk_cd = {\n\tNULL, \"ofdisk\", DV_DISK\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ofdclose",
          "args": [
            "dev",
            "0",
            "S_IFBLK"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "ofdclose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ofw/ofdisk.c",
          "lines": "196-227",
          "snippet": "int\nofdclose(dev, flags, fmt, p)\n\tdev_t dev;\n\tint flags;\n\tint fmt;\n\tstruct proc *p;\n{\n\tstruct ofd_softc *of = ofdisk_cd.cd_devs[DISKUNIT(dev)];\n\n\tswitch (fmt) {\n\tcase S_IFCHR:\n\t\tof->sc_dk.dk_copenmask &= ~(1 << DISKPART(dev));\n\t\tbreak;\n\tcase S_IFBLK:\n\t\tof->sc_dk.dk_bopenmask &= ~(1 << DISKPART(dev));\n\t\tbreak;\n\t}\n\tof->sc_dk.dk_openmask = of->sc_dk.dk_copenmask | of->sc_dk.dk_bopenmask;\n\t\n#ifdef\tFIREPOWERBUGS\n\t/*\n\t * This is a hack to get the firmware to flush its buffers.\n\t */\n\tOF_seek(of->sc_ihandle, 0);\n#endif\n\tif (!of->sc_dk.dk_openmask) {\n\t\tOF_close(of->sc_ihandle);\n\t\tof->sc_ihandle = 0;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <dev/ofw/openfirm.h>",
            "#include <sys/systm.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/disk.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cfdriver ofdisk_cd = {\n\tNULL, \"ofdisk\", DV_DISK\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ofw/openfirm.h>\n#include <sys/systm.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/fcntl.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/param.h>\n\nstruct cfdriver ofdisk_cd = {\n\tNULL, \"ofdisk\", DV_DISK\n};\n\nint\nofdclose(dev, flags, fmt, p)\n\tdev_t dev;\n\tint flags;\n\tint fmt;\n\tstruct proc *p;\n{\n\tstruct ofd_softc *of = ofdisk_cd.cd_devs[DISKUNIT(dev)];\n\n\tswitch (fmt) {\n\tcase S_IFCHR:\n\t\tof->sc_dk.dk_copenmask &= ~(1 << DISKPART(dev));\n\t\tbreak;\n\tcase S_IFBLK:\n\t\tof->sc_dk.dk_bopenmask &= ~(1 << DISKPART(dev));\n\t\tbreak;\n\t}\n\tof->sc_dk.dk_openmask = of->sc_dk.dk_copenmask | of->sc_dk.dk_bopenmask;\n\t\n#ifdef\tFIREPOWERBUGS\n\t/*\n\t * This is a hack to get the firmware to flush its buffers.\n\t */\n\tOF_seek(of->sc_ihandle, 0);\n#endif\n\tif (!of->sc_dk.dk_openmask) {\n\t\tOF_close(of->sc_ihandle);\n\t\tof->sc_ihandle = 0;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DISKPART",
          "args": [
            "dev"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DISKUNIT",
          "args": [
            "dev"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ofdopen",
          "args": [
            "dev",
            "0",
            "S_IFBLK"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "ofdopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ofw/ofdisk.c",
          "lines": "109-194",
          "snippet": "int\nofdopen(dev, flags, fmt, p)\n\tdev_t dev;\n\tint flags;\n\tint fmt;\n\tstruct proc *p;\n{\n\tint unit = DISKUNIT(dev);\n\tstruct ofd_softc *of;\n\tchar path[256];\n\tstruct disklabel *lp;\n\tint l;\n\t\n\tif (unit >= ofdisk_cd.cd_ndevs)\n\t\treturn ENXIO;\n\tif (!(of = ofdisk_cd.cd_devs[unit]))\n\t\treturn ENXIO;\n\n\tif (!of->sc_ihandle) {\n\n\t\tif ((l = OF_package_to_path(of->sc_phandle, path, sizeof path - 3)) < 0)\n\t\t\treturn ENXIO;\n\t\tif (l >= sizeof path - 3)\n\t\t\treturn ENXIO;\n\t\tpath[l] = 0;\n\n\t\t/*\n\t\t * This is for the benefit of SCSI/IDE disks that don't\n\t\t * have all their childs in the device tree.\n\t\t * YES, I DO THINK THIS IS A BUG IN OPENFIRMWARE!!!\n\t\t * And yes, this is a very gross hack!\t\t\t\t\tXXX\n\t\t * See also ofscsi.c\n\t\t */\n\t\tif (!strcmp(path + l - 4, \"disk\")) {\n\t\t\tpath[l++] = '@';\n\t\t\tpath[l++] = '0' + of->sc_unit;\n\t\t\tpath[l] = 0;\n\t\t}\n\n\t\tstrcat(path, \":0\");\n\n\t\tif (!(of->sc_ihandle = OF_open(path)))\n\t\t\treturn ENXIO;\n\n\t\t/*\n\t\t * Try to get characteristics of the disk.\n\t\t */\n\t\tof->max_transfer = OF_call_method_1(\"max-transfer\", of->sc_ihandle, 0);\n\t\tif (of->max_transfer > MAXPHYS)\n\t\t\tof->max_transfer = MAXPHYS;\n\t\t\n\t\tlp = of->sc_dk.dk_label;\n\t\tbzero(lp, sizeof *lp);\n\t\t\n\t\tlp->d_secsize = OF_call_method_1(\"block-size\", of->sc_ihandle, 0);\n\t\tif (lp->d_secsize == (u_int32_t)-1 || lp->d_secsize > MAXBSIZE)\n\t\t\tlp->d_secsize = DEV_BSIZE;\n\t\t\n\t\tlp->d_secperunit = OF_call_method_1(\"#blocks\", of->sc_ihandle, 0);\n\t\tif (lp->d_secperunit == (u_int32_t)-1)\n\t\t\tlp->d_secperunit = 0x7fffffff;\n\t\t\n\t\tlp->d_secpercyl = 1;\n\t\tlp->d_nsectors = 1;\n\t\tlp->d_ntracks = 1;\n\t\tlp->d_ncylinders = lp->d_secperunit;\n\t\t\t\n\t\tlp->d_partitions[RAW_PART].p_offset = 0;\n\t\tlp->d_partitions[RAW_PART].p_size = lp->d_secperunit;\n\t\t\n\t\treaddisklabel(MAKEDISKDEV(major(dev), unit, RAW_PART),\n\t\t    ofdstrategy, lp, of->sc_dk.dk_cpulabel, 0);\n\t}\n\n\tswitch (fmt) {\n\tcase S_IFCHR:\n\t\tof->sc_dk.dk_copenmask |= 1 << DISKPART(dev);\n\t\tbreak;\n\tcase S_IFBLK:\n\t\tof->sc_dk.dk_bopenmask |= 1 << DISKPART(dev);\n\t\tbreak;\n\t}\n\tof->sc_dk.dk_openmask = of->sc_dk.dk_copenmask | of->sc_dk.dk_bopenmask;\n\t\n\treturn 0;\n}",
          "includes": [
            "#include <dev/ofw/openfirm.h>",
            "#include <sys/systm.h>",
            "#include <sys/stat.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/disk.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cfdriver ofdisk_cd = {\n\tNULL, \"ofdisk\", DV_DISK\n};",
            "void ofdstrategy"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ofw/openfirm.h>\n#include <sys/systm.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/fcntl.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/param.h>\n\nstruct cfdriver ofdisk_cd = {\n\tNULL, \"ofdisk\", DV_DISK\n};\nvoid ofdstrategy;\n\nint\nofdopen(dev, flags, fmt, p)\n\tdev_t dev;\n\tint flags;\n\tint fmt;\n\tstruct proc *p;\n{\n\tint unit = DISKUNIT(dev);\n\tstruct ofd_softc *of;\n\tchar path[256];\n\tstruct disklabel *lp;\n\tint l;\n\t\n\tif (unit >= ofdisk_cd.cd_ndevs)\n\t\treturn ENXIO;\n\tif (!(of = ofdisk_cd.cd_devs[unit]))\n\t\treturn ENXIO;\n\n\tif (!of->sc_ihandle) {\n\n\t\tif ((l = OF_package_to_path(of->sc_phandle, path, sizeof path - 3)) < 0)\n\t\t\treturn ENXIO;\n\t\tif (l >= sizeof path - 3)\n\t\t\treturn ENXIO;\n\t\tpath[l] = 0;\n\n\t\t/*\n\t\t * This is for the benefit of SCSI/IDE disks that don't\n\t\t * have all their childs in the device tree.\n\t\t * YES, I DO THINK THIS IS A BUG IN OPENFIRMWARE!!!\n\t\t * And yes, this is a very gross hack!\t\t\t\t\tXXX\n\t\t * See also ofscsi.c\n\t\t */\n\t\tif (!strcmp(path + l - 4, \"disk\")) {\n\t\t\tpath[l++] = '@';\n\t\t\tpath[l++] = '0' + of->sc_unit;\n\t\t\tpath[l] = 0;\n\t\t}\n\n\t\tstrcat(path, \":0\");\n\n\t\tif (!(of->sc_ihandle = OF_open(path)))\n\t\t\treturn ENXIO;\n\n\t\t/*\n\t\t * Try to get characteristics of the disk.\n\t\t */\n\t\tof->max_transfer = OF_call_method_1(\"max-transfer\", of->sc_ihandle, 0);\n\t\tif (of->max_transfer > MAXPHYS)\n\t\t\tof->max_transfer = MAXPHYS;\n\t\t\n\t\tlp = of->sc_dk.dk_label;\n\t\tbzero(lp, sizeof *lp);\n\t\t\n\t\tlp->d_secsize = OF_call_method_1(\"block-size\", of->sc_ihandle, 0);\n\t\tif (lp->d_secsize == (u_int32_t)-1 || lp->d_secsize > MAXBSIZE)\n\t\t\tlp->d_secsize = DEV_BSIZE;\n\t\t\n\t\tlp->d_secperunit = OF_call_method_1(\"#blocks\", of->sc_ihandle, 0);\n\t\tif (lp->d_secperunit == (u_int32_t)-1)\n\t\t\tlp->d_secperunit = 0x7fffffff;\n\t\t\n\t\tlp->d_secpercyl = 1;\n\t\tlp->d_nsectors = 1;\n\t\tlp->d_ntracks = 1;\n\t\tlp->d_ncylinders = lp->d_secperunit;\n\t\t\t\n\t\tlp->d_partitions[RAW_PART].p_offset = 0;\n\t\tlp->d_partitions[RAW_PART].p_size = lp->d_secperunit;\n\t\t\n\t\treaddisklabel(MAKEDISKDEV(major(dev), unit, RAW_PART),\n\t\t    ofdstrategy, lp, of->sc_dk.dk_cpulabel, 0);\n\t}\n\n\tswitch (fmt) {\n\tcase S_IFCHR:\n\t\tof->sc_dk.dk_copenmask |= 1 << DISKPART(dev);\n\t\tbreak;\n\tcase S_IFBLK:\n\t\tof->sc_dk.dk_bopenmask |= 1 << DISKPART(dev);\n\t\tbreak;\n\t}\n\tof->sc_dk.dk_openmask = of->sc_dk.dk_copenmask | of->sc_dk.dk_bopenmask;\n\t\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ofw/openfirm.h>\n#include <sys/systm.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/fcntl.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/param.h>\n\nstruct cfdriver ofdisk_cd = {\n\tNULL, \"ofdisk\", DV_DISK\n};\n\nint\nofdsize(dev)\n\tdev_t dev;\n{\n\tstruct ofd_softc *of;\n\tint part;\n\tint size;\n\t\n\tif (ofdopen(dev, 0, S_IFBLK) != 0)\n\t\treturn -1;\n\tof = ofdisk_cd.cd_devs[DISKUNIT(dev)];\n\tpart = DISKPART(dev);\n\tif (of->sc_dk.dk_label->d_partitions[part].p_fstype != FS_SWAP)\n\t\tsize = -1;\n\telse\n\t\tsize = of->sc_dk.dk_label->d_partitions[part].p_size;\n\tif (ofdclose(dev, 0, S_IFBLK) != 0)\n\t\treturn -1;\n\treturn size;\n}"
  },
  {
    "function_name": "ofddump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ofw/ofdisk.c",
    "lines": "347-355",
    "snippet": "int\nofddump(dev, blkno, va, size)\n\tdev_t dev;\n\tdaddr_t blkno;\n\tcaddr_t va;\n\tsize_t size;\n{\n\treturn EINVAL;\n}",
    "includes": [
      "#include <dev/ofw/openfirm.h>",
      "#include <sys/systm.h>",
      "#include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ofw/openfirm.h>\n#include <sys/systm.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/fcntl.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/param.h>\n\nint\nofddump(dev, blkno, va, size)\n\tdev_t dev;\n\tdaddr_t blkno;\n\tcaddr_t va;\n\tsize_t size;\n{\n\treturn EINVAL;\n}"
  },
  {
    "function_name": "ofdioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ofw/ofdisk.c",
    "lines": "304-345",
    "snippet": "int\nofdioctl(dev, cmd, data, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct ofd_softc *of = ofdisk_cd.cd_devs[DISKUNIT(dev)];\n\tint error;\n\t\n\tswitch (cmd) {\n\tcase DIOCGDINFO:\n\t\t*(struct disklabel *)data = *of->sc_dk.dk_label;\n\t\treturn 0;\n\t\t\n\tcase DIOCGPART:\n\t\t((struct partinfo *)data)->disklab = of->sc_dk.dk_label;\n\t\t((struct partinfo *)data)->part =\n\t\t\t&of->sc_dk.dk_label->d_partitions[DISKPART(dev)];\n\t\treturn 0;\n\t\t\n\tcase DIOCWDINFO:\n\tcase DIOCSDINFO:\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn EBADF;\n\t\t\n\t\terror = setdisklabel(of->sc_dk.dk_label,\n\t\t\t\t     (struct disklabel *)data, /*of->sc_dk.dk_openmask */0,\n\t\t\t\t     of->sc_dk.dk_cpulabel);\n\t\tif (error == 0 && cmd == DIOCWDINFO)\n\t\t\terror = writedisklabel(MAKEDISKDEV(major(dev),\n\t\t\t\t\t\t\t   DISKUNIT(dev), RAW_PART),\n\t\t\t\t\t       ofdstrategy,\n\t\t\t\t\t       of->sc_dk.dk_label,\n\t\t\t\t\t       of->sc_dk.dk_cpulabel);\n\n\t\treturn error;\n\tdefault:\n\t\treturn ENOTTY;\n\t}\n}",
    "includes": [
      "#include <dev/ofw/openfirm.h>",
      "#include <sys/systm.h>",
      "#include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cfdriver ofdisk_cd = {\n\tNULL, \"ofdisk\", DV_DISK\n};",
      "void ofdstrategy"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "writedisklabel",
          "args": [
            "MAKEDISKDEV(major(dev),\n\t\t\t\t\t\t\t   DISKUNIT(dev), RAW_PART)",
            "ofdstrategy",
            "of->sc_dk.dk_label",
            "of->sc_dk.dk_cpulabel"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAKEDISKDEV",
          "args": [
            "major(dev)",
            "DISKUNIT(dev)",
            "RAW_PART"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DISKUNIT",
          "args": [
            "dev"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "major",
          "args": [
            "dev"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setdisklabel",
          "args": [
            "of->sc_dk.dk_label",
            "(struct disklabel *)data",
            "/*of->sc_dk.dk_openmask */0",
            "of->sc_dk.dk_cpulabel"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DISKPART",
          "args": [
            "dev"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DISKUNIT",
          "args": [
            "dev"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ofw/openfirm.h>\n#include <sys/systm.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/fcntl.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/param.h>\n\nstruct cfdriver ofdisk_cd = {\n\tNULL, \"ofdisk\", DV_DISK\n};\nvoid ofdstrategy;\n\nint\nofdioctl(dev, cmd, data, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct ofd_softc *of = ofdisk_cd.cd_devs[DISKUNIT(dev)];\n\tint error;\n\t\n\tswitch (cmd) {\n\tcase DIOCGDINFO:\n\t\t*(struct disklabel *)data = *of->sc_dk.dk_label;\n\t\treturn 0;\n\t\t\n\tcase DIOCGPART:\n\t\t((struct partinfo *)data)->disklab = of->sc_dk.dk_label;\n\t\t((struct partinfo *)data)->part =\n\t\t\t&of->sc_dk.dk_label->d_partitions[DISKPART(dev)];\n\t\treturn 0;\n\t\t\n\tcase DIOCWDINFO:\n\tcase DIOCSDINFO:\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn EBADF;\n\t\t\n\t\terror = setdisklabel(of->sc_dk.dk_label,\n\t\t\t\t     (struct disklabel *)data, /*of->sc_dk.dk_openmask */0,\n\t\t\t\t     of->sc_dk.dk_cpulabel);\n\t\tif (error == 0 && cmd == DIOCWDINFO)\n\t\t\terror = writedisklabel(MAKEDISKDEV(major(dev),\n\t\t\t\t\t\t\t   DISKUNIT(dev), RAW_PART),\n\t\t\t\t\t       ofdstrategy,\n\t\t\t\t\t       of->sc_dk.dk_label,\n\t\t\t\t\t       of->sc_dk.dk_cpulabel);\n\n\t\treturn error;\n\tdefault:\n\t\treturn ENOTTY;\n\t}\n}"
  },
  {
    "function_name": "ofdwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ofw/ofdisk.c",
    "lines": "296-302",
    "snippet": "int\nofdwrite(dev, uio)\n\tdev_t dev;\n\tstruct uio *uio;\n{\n\treturn physio(ofdstrategy, NULL, dev, B_WRITE, ofminphys, uio);\n}",
    "includes": [
      "#include <dev/ofw/openfirm.h>",
      "#include <sys/systm.h>",
      "#include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void ofdstrategy"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "physio",
          "args": [
            "ofdstrategy",
            "NULL",
            "dev",
            "B_WRITE",
            "ofminphys",
            "uio"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ofw/openfirm.h>\n#include <sys/systm.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/fcntl.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/param.h>\n\nvoid ofdstrategy;\n\nint\nofdwrite(dev, uio)\n\tdev_t dev;\n\tstruct uio *uio;\n{\n\treturn physio(ofdstrategy, NULL, dev, B_WRITE, ofminphys, uio);\n}"
  },
  {
    "function_name": "ofdread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ofw/ofdisk.c",
    "lines": "288-294",
    "snippet": "int\nofdread(dev, uio)\n\tdev_t dev;\n\tstruct uio *uio;\n{\n\treturn physio(ofdstrategy, NULL, dev, B_READ, ofminphys, uio);\n}",
    "includes": [
      "#include <dev/ofw/openfirm.h>",
      "#include <sys/systm.h>",
      "#include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void ofdstrategy"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "physio",
          "args": [
            "ofdstrategy",
            "NULL",
            "dev",
            "B_READ",
            "ofminphys",
            "uio"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ofw/openfirm.h>\n#include <sys/systm.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/fcntl.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/param.h>\n\nvoid ofdstrategy;\n\nint\nofdread(dev, uio)\n\tdev_t dev;\n\tstruct uio *uio;\n{\n\treturn physio(ofdstrategy, NULL, dev, B_READ, ofminphys, uio);\n}"
  },
  {
    "function_name": "ofminphys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ofw/ofdisk.c",
    "lines": "278-286",
    "snippet": "static void\nofminphys(bp)\n\tstruct buf *bp;\n{\n\tstruct ofd_softc *of = ofdisk_cd.cd_devs[DISKUNIT(bp->b_dev)];\n\t\n\tif (bp->b_bcount > of->max_transfer)\n\t\tbp->b_bcount = of->max_transfer;\n}",
    "includes": [
      "#include <dev/ofw/openfirm.h>",
      "#include <sys/systm.h>",
      "#include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cfdriver ofdisk_cd = {\n\tNULL, \"ofdisk\", DV_DISK\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DISKUNIT",
          "args": [
            "bp->b_dev"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ofw/openfirm.h>\n#include <sys/systm.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/fcntl.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/param.h>\n\nstruct cfdriver ofdisk_cd = {\n\tNULL, \"ofdisk\", DV_DISK\n};\n\nstatic void\nofminphys(bp)\n\tstruct buf *bp;\n{\n\tstruct ofd_softc *of = ofdisk_cd.cd_devs[DISKUNIT(bp->b_dev)];\n\t\n\tif (bp->b_bcount > of->max_transfer)\n\t\tbp->b_bcount = of->max_transfer;\n}"
  },
  {
    "function_name": "ofdstrategy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ofw/ofdisk.c",
    "lines": "229-276",
    "snippet": "void\nofdstrategy(bp)\n\tstruct buf *bp;\n{\n\tstruct ofd_softc *of = ofdisk_cd.cd_devs[DISKUNIT(bp->b_dev)];\n\tstruct partition *p;\n\tu_quad_t off;\n\tint read;\n\tint (*OF_io)(int, void *, int);\n\tdaddr_t blkno = bp->b_blkno;\n\t\n\tbp->b_resid = 0;\n\tif (bp->b_bcount == 0)\n\t\tgoto done;\n\t\n\tOF_io = bp->b_flags & B_READ ? OF_read : OF_write;\n\n\tif (DISKPART(bp->b_dev) != RAW_PART) {\n\t\tif (bounds_check_with_label(bp, of->sc_dk.dk_label,\n\t\t    of->sc_dk.dk_cpulabel, 0) <= 0) {\n\t\t\tbp->b_resid = bp->b_bcount;\n\t\t\tgoto done;\n\t\t}\n\t\tp = &of->sc_dk.dk_label->d_partitions[DISKPART(bp->b_dev)];\n\t\tblkno = bp->b_blkno + p->p_offset;\n\t}\n\t\n\tdisk_busy(&of->sc_dk);\n\n\toff = (u_quad_t)blkno * DEV_BSIZE;\n\tread = -1;\n\tdo {\n\t\tif (OF_seek(of->sc_ihandle, off) < 0)\n\t\t\tbreak;\n\t\tread = OF_io(of->sc_ihandle, bp->b_data, bp->b_bcount);\n\t} while (read == -2);\n\tif (read < 0) {\n\t\tbp->b_error = EIO;\n\t\tbp->b_flags |= B_ERROR;\n\t\tbp->b_resid = bp->b_bcount;\n\t} else\n\t\tbp->b_resid = bp->b_bcount - read;\n\n\tdisk_unbusy(&of->sc_dk, bp->b_bcount - bp->b_resid);\n\ndone:\n\tbiodone(bp);\n}",
    "includes": [
      "#include <dev/ofw/openfirm.h>",
      "#include <sys/systm.h>",
      "#include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cfdriver ofdisk_cd = {\n\tNULL, \"ofdisk\", DV_DISK\n};",
      "void ofdstrategy"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "biodone",
          "args": [
            "bp"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_unbusy",
          "args": [
            "&of->sc_dk",
            "bp->b_bcount - bp->b_resid"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OF_io",
          "args": [
            "of->sc_ihandle",
            "bp->b_data",
            "bp->b_bcount"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OF_seek",
          "args": [
            "of->sc_ihandle",
            "off"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_busy",
          "args": [
            "&of->sc_dk"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DISKPART",
          "args": [
            "bp->b_dev"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bounds_check_with_label",
          "args": [
            "bp",
            "of->sc_dk.dk_label",
            "of->sc_dk.dk_cpulabel",
            "0"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DISKPART",
          "args": [
            "bp->b_dev"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DISKUNIT",
          "args": [
            "bp->b_dev"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ofw/openfirm.h>\n#include <sys/systm.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/fcntl.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/param.h>\n\nstruct cfdriver ofdisk_cd = {\n\tNULL, \"ofdisk\", DV_DISK\n};\nvoid ofdstrategy;\n\nvoid\nofdstrategy(bp)\n\tstruct buf *bp;\n{\n\tstruct ofd_softc *of = ofdisk_cd.cd_devs[DISKUNIT(bp->b_dev)];\n\tstruct partition *p;\n\tu_quad_t off;\n\tint read;\n\tint (*OF_io)(int, void *, int);\n\tdaddr_t blkno = bp->b_blkno;\n\t\n\tbp->b_resid = 0;\n\tif (bp->b_bcount == 0)\n\t\tgoto done;\n\t\n\tOF_io = bp->b_flags & B_READ ? OF_read : OF_write;\n\n\tif (DISKPART(bp->b_dev) != RAW_PART) {\n\t\tif (bounds_check_with_label(bp, of->sc_dk.dk_label,\n\t\t    of->sc_dk.dk_cpulabel, 0) <= 0) {\n\t\t\tbp->b_resid = bp->b_bcount;\n\t\t\tgoto done;\n\t\t}\n\t\tp = &of->sc_dk.dk_label->d_partitions[DISKPART(bp->b_dev)];\n\t\tblkno = bp->b_blkno + p->p_offset;\n\t}\n\t\n\tdisk_busy(&of->sc_dk);\n\n\toff = (u_quad_t)blkno * DEV_BSIZE;\n\tread = -1;\n\tdo {\n\t\tif (OF_seek(of->sc_ihandle, off) < 0)\n\t\t\tbreak;\n\t\tread = OF_io(of->sc_ihandle, bp->b_data, bp->b_bcount);\n\t} while (read == -2);\n\tif (read < 0) {\n\t\tbp->b_error = EIO;\n\t\tbp->b_flags |= B_ERROR;\n\t\tbp->b_resid = bp->b_bcount;\n\t} else\n\t\tbp->b_resid = bp->b_bcount - read;\n\n\tdisk_unbusy(&of->sc_dk, bp->b_bcount - bp->b_resid);\n\ndone:\n\tbiodone(bp);\n}"
  },
  {
    "function_name": "ofdclose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ofw/ofdisk.c",
    "lines": "196-227",
    "snippet": "int\nofdclose(dev, flags, fmt, p)\n\tdev_t dev;\n\tint flags;\n\tint fmt;\n\tstruct proc *p;\n{\n\tstruct ofd_softc *of = ofdisk_cd.cd_devs[DISKUNIT(dev)];\n\n\tswitch (fmt) {\n\tcase S_IFCHR:\n\t\tof->sc_dk.dk_copenmask &= ~(1 << DISKPART(dev));\n\t\tbreak;\n\tcase S_IFBLK:\n\t\tof->sc_dk.dk_bopenmask &= ~(1 << DISKPART(dev));\n\t\tbreak;\n\t}\n\tof->sc_dk.dk_openmask = of->sc_dk.dk_copenmask | of->sc_dk.dk_bopenmask;\n\t\n#ifdef\tFIREPOWERBUGS\n\t/*\n\t * This is a hack to get the firmware to flush its buffers.\n\t */\n\tOF_seek(of->sc_ihandle, 0);\n#endif\n\tif (!of->sc_dk.dk_openmask) {\n\t\tOF_close(of->sc_ihandle);\n\t\tof->sc_ihandle = 0;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <dev/ofw/openfirm.h>",
      "#include <sys/systm.h>",
      "#include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cfdriver ofdisk_cd = {\n\tNULL, \"ofdisk\", DV_DISK\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "OF_close",
          "args": [
            "of->sc_ihandle"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OF_seek",
          "args": [
            "of->sc_ihandle",
            "0"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DISKPART",
          "args": [
            "dev"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DISKPART",
          "args": [
            "dev"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DISKUNIT",
          "args": [
            "dev"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ofw/openfirm.h>\n#include <sys/systm.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/fcntl.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/param.h>\n\nstruct cfdriver ofdisk_cd = {\n\tNULL, \"ofdisk\", DV_DISK\n};\n\nint\nofdclose(dev, flags, fmt, p)\n\tdev_t dev;\n\tint flags;\n\tint fmt;\n\tstruct proc *p;\n{\n\tstruct ofd_softc *of = ofdisk_cd.cd_devs[DISKUNIT(dev)];\n\n\tswitch (fmt) {\n\tcase S_IFCHR:\n\t\tof->sc_dk.dk_copenmask &= ~(1 << DISKPART(dev));\n\t\tbreak;\n\tcase S_IFBLK:\n\t\tof->sc_dk.dk_bopenmask &= ~(1 << DISKPART(dev));\n\t\tbreak;\n\t}\n\tof->sc_dk.dk_openmask = of->sc_dk.dk_copenmask | of->sc_dk.dk_bopenmask;\n\t\n#ifdef\tFIREPOWERBUGS\n\t/*\n\t * This is a hack to get the firmware to flush its buffers.\n\t */\n\tOF_seek(of->sc_ihandle, 0);\n#endif\n\tif (!of->sc_dk.dk_openmask) {\n\t\tOF_close(of->sc_ihandle);\n\t\tof->sc_ihandle = 0;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ofdopen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ofw/ofdisk.c",
    "lines": "109-194",
    "snippet": "int\nofdopen(dev, flags, fmt, p)\n\tdev_t dev;\n\tint flags;\n\tint fmt;\n\tstruct proc *p;\n{\n\tint unit = DISKUNIT(dev);\n\tstruct ofd_softc *of;\n\tchar path[256];\n\tstruct disklabel *lp;\n\tint l;\n\t\n\tif (unit >= ofdisk_cd.cd_ndevs)\n\t\treturn ENXIO;\n\tif (!(of = ofdisk_cd.cd_devs[unit]))\n\t\treturn ENXIO;\n\n\tif (!of->sc_ihandle) {\n\n\t\tif ((l = OF_package_to_path(of->sc_phandle, path, sizeof path - 3)) < 0)\n\t\t\treturn ENXIO;\n\t\tif (l >= sizeof path - 3)\n\t\t\treturn ENXIO;\n\t\tpath[l] = 0;\n\n\t\t/*\n\t\t * This is for the benefit of SCSI/IDE disks that don't\n\t\t * have all their childs in the device tree.\n\t\t * YES, I DO THINK THIS IS A BUG IN OPENFIRMWARE!!!\n\t\t * And yes, this is a very gross hack!\t\t\t\t\tXXX\n\t\t * See also ofscsi.c\n\t\t */\n\t\tif (!strcmp(path + l - 4, \"disk\")) {\n\t\t\tpath[l++] = '@';\n\t\t\tpath[l++] = '0' + of->sc_unit;\n\t\t\tpath[l] = 0;\n\t\t}\n\n\t\tstrcat(path, \":0\");\n\n\t\tif (!(of->sc_ihandle = OF_open(path)))\n\t\t\treturn ENXIO;\n\n\t\t/*\n\t\t * Try to get characteristics of the disk.\n\t\t */\n\t\tof->max_transfer = OF_call_method_1(\"max-transfer\", of->sc_ihandle, 0);\n\t\tif (of->max_transfer > MAXPHYS)\n\t\t\tof->max_transfer = MAXPHYS;\n\t\t\n\t\tlp = of->sc_dk.dk_label;\n\t\tbzero(lp, sizeof *lp);\n\t\t\n\t\tlp->d_secsize = OF_call_method_1(\"block-size\", of->sc_ihandle, 0);\n\t\tif (lp->d_secsize == (u_int32_t)-1 || lp->d_secsize > MAXBSIZE)\n\t\t\tlp->d_secsize = DEV_BSIZE;\n\t\t\n\t\tlp->d_secperunit = OF_call_method_1(\"#blocks\", of->sc_ihandle, 0);\n\t\tif (lp->d_secperunit == (u_int32_t)-1)\n\t\t\tlp->d_secperunit = 0x7fffffff;\n\t\t\n\t\tlp->d_secpercyl = 1;\n\t\tlp->d_nsectors = 1;\n\t\tlp->d_ntracks = 1;\n\t\tlp->d_ncylinders = lp->d_secperunit;\n\t\t\t\n\t\tlp->d_partitions[RAW_PART].p_offset = 0;\n\t\tlp->d_partitions[RAW_PART].p_size = lp->d_secperunit;\n\t\t\n\t\treaddisklabel(MAKEDISKDEV(major(dev), unit, RAW_PART),\n\t\t    ofdstrategy, lp, of->sc_dk.dk_cpulabel, 0);\n\t}\n\n\tswitch (fmt) {\n\tcase S_IFCHR:\n\t\tof->sc_dk.dk_copenmask |= 1 << DISKPART(dev);\n\t\tbreak;\n\tcase S_IFBLK:\n\t\tof->sc_dk.dk_bopenmask |= 1 << DISKPART(dev);\n\t\tbreak;\n\t}\n\tof->sc_dk.dk_openmask = of->sc_dk.dk_copenmask | of->sc_dk.dk_bopenmask;\n\t\n\treturn 0;\n}",
    "includes": [
      "#include <dev/ofw/openfirm.h>",
      "#include <sys/systm.h>",
      "#include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cfdriver ofdisk_cd = {\n\tNULL, \"ofdisk\", DV_DISK\n};",
      "void ofdstrategy"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DISKPART",
          "args": [
            "dev"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DISKPART",
          "args": [
            "dev"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdisklabel",
          "args": [
            "MAKEDISKDEV(major(dev), unit, RAW_PART)",
            "ofdstrategy",
            "lp",
            "of->sc_dk.dk_cpulabel",
            "0"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAKEDISKDEV",
          "args": [
            "major(dev)",
            "unit",
            "RAW_PART"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "major",
          "args": [
            "dev"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OF_call_method_1",
          "args": [
            "\"#blocks\"",
            "of->sc_ihandle",
            "0"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OF_call_method_1",
          "args": [
            "\"block-size\"",
            "of->sc_ihandle",
            "0"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "lp",
            "sizeof *lp"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OF_call_method_1",
          "args": [
            "\"max-transfer\"",
            "of->sc_ihandle",
            "0"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OF_open",
          "args": [
            "path"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "path",
            "\":0\""
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "path + l - 4",
            "\"disk\""
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OF_package_to_path",
          "args": [
            "of->sc_phandle",
            "path",
            "sizeof path - 3"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DISKUNIT",
          "args": [
            "dev"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ofw/openfirm.h>\n#include <sys/systm.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/fcntl.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/param.h>\n\nstruct cfdriver ofdisk_cd = {\n\tNULL, \"ofdisk\", DV_DISK\n};\nvoid ofdstrategy;\n\nint\nofdopen(dev, flags, fmt, p)\n\tdev_t dev;\n\tint flags;\n\tint fmt;\n\tstruct proc *p;\n{\n\tint unit = DISKUNIT(dev);\n\tstruct ofd_softc *of;\n\tchar path[256];\n\tstruct disklabel *lp;\n\tint l;\n\t\n\tif (unit >= ofdisk_cd.cd_ndevs)\n\t\treturn ENXIO;\n\tif (!(of = ofdisk_cd.cd_devs[unit]))\n\t\treturn ENXIO;\n\n\tif (!of->sc_ihandle) {\n\n\t\tif ((l = OF_package_to_path(of->sc_phandle, path, sizeof path - 3)) < 0)\n\t\t\treturn ENXIO;\n\t\tif (l >= sizeof path - 3)\n\t\t\treturn ENXIO;\n\t\tpath[l] = 0;\n\n\t\t/*\n\t\t * This is for the benefit of SCSI/IDE disks that don't\n\t\t * have all their childs in the device tree.\n\t\t * YES, I DO THINK THIS IS A BUG IN OPENFIRMWARE!!!\n\t\t * And yes, this is a very gross hack!\t\t\t\t\tXXX\n\t\t * See also ofscsi.c\n\t\t */\n\t\tif (!strcmp(path + l - 4, \"disk\")) {\n\t\t\tpath[l++] = '@';\n\t\t\tpath[l++] = '0' + of->sc_unit;\n\t\t\tpath[l] = 0;\n\t\t}\n\n\t\tstrcat(path, \":0\");\n\n\t\tif (!(of->sc_ihandle = OF_open(path)))\n\t\t\treturn ENXIO;\n\n\t\t/*\n\t\t * Try to get characteristics of the disk.\n\t\t */\n\t\tof->max_transfer = OF_call_method_1(\"max-transfer\", of->sc_ihandle, 0);\n\t\tif (of->max_transfer > MAXPHYS)\n\t\t\tof->max_transfer = MAXPHYS;\n\t\t\n\t\tlp = of->sc_dk.dk_label;\n\t\tbzero(lp, sizeof *lp);\n\t\t\n\t\tlp->d_secsize = OF_call_method_1(\"block-size\", of->sc_ihandle, 0);\n\t\tif (lp->d_secsize == (u_int32_t)-1 || lp->d_secsize > MAXBSIZE)\n\t\t\tlp->d_secsize = DEV_BSIZE;\n\t\t\n\t\tlp->d_secperunit = OF_call_method_1(\"#blocks\", of->sc_ihandle, 0);\n\t\tif (lp->d_secperunit == (u_int32_t)-1)\n\t\t\tlp->d_secperunit = 0x7fffffff;\n\t\t\n\t\tlp->d_secpercyl = 1;\n\t\tlp->d_nsectors = 1;\n\t\tlp->d_ntracks = 1;\n\t\tlp->d_ncylinders = lp->d_secperunit;\n\t\t\t\n\t\tlp->d_partitions[RAW_PART].p_offset = 0;\n\t\tlp->d_partitions[RAW_PART].p_size = lp->d_secperunit;\n\t\t\n\t\treaddisklabel(MAKEDISKDEV(major(dev), unit, RAW_PART),\n\t\t    ofdstrategy, lp, of->sc_dk.dk_cpulabel, 0);\n\t}\n\n\tswitch (fmt) {\n\tcase S_IFCHR:\n\t\tof->sc_dk.dk_copenmask |= 1 << DISKPART(dev);\n\t\tbreak;\n\tcase S_IFBLK:\n\t\tof->sc_dk.dk_bopenmask |= 1 << DISKPART(dev);\n\t\tbreak;\n\t}\n\tof->sc_dk.dk_openmask = of->sc_dk.dk_copenmask | of->sc_dk.dk_bopenmask;\n\t\n\treturn 0;\n}"
  },
  {
    "function_name": "ofdattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ofw/ofdisk.c",
    "lines": "89-107",
    "snippet": "static void\nofdattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct ofd_softc *of = (void *)self;\n\tstruct ofprobe *ofp = aux;\n\tint l;\n\t\n\tof->sc_phandle = ofp->phandle;\n\tof->sc_unit = ofp->unit;\n\tof->sc_ihandle = 0;\n\tof->sc_dk.dk_driver = &ofdkdriver;\n\tof->sc_dk.dk_name = of->sc_name;\n\tstrcpy(of->sc_name, of->sc_dev.dv_xname);\n\tdisk_attach(&of->sc_dk);\n\tdk_establish(&of->sc_dk, self);\t\t\t\t/* XXX */\n\tprintf(\"\\n\");\n}",
    "includes": [
      "#include <dev/ofw/openfirm.h>",
      "#include <sys/systm.h>",
      "#include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ofdattach",
      "struct dkdriver ofdkdriver = { ofdstrategy };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dk_establish",
          "args": [
            "&of->sc_dk",
            "self"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_attach",
          "args": [
            "&of->sc_dk"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "of->sc_name",
            "of->sc_dev.dv_xname"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ofw/openfirm.h>\n#include <sys/systm.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/fcntl.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/param.h>\n\nstatic void ofdattach;\nstruct dkdriver ofdkdriver = { ofdstrategy };\n\nstatic void\nofdattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct ofd_softc *of = (void *)self;\n\tstruct ofprobe *ofp = aux;\n\tint l;\n\t\n\tof->sc_phandle = ofp->phandle;\n\tof->sc_unit = ofp->unit;\n\tof->sc_ihandle = 0;\n\tof->sc_dk.dk_driver = &ofdkdriver;\n\tof->sc_dk.dk_name = of->sc_name;\n\tstrcpy(of->sc_name, of->sc_dev.dv_xname);\n\tdisk_attach(&of->sc_dk);\n\tdk_establish(&of->sc_dk, self);\t\t\t\t/* XXX */\n\tprintf(\"\\n\");\n}"
  },
  {
    "function_name": "ofdprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ofw/ofdisk.c",
    "lines": "72-87",
    "snippet": "static int\nofdprobe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct ofprobe *ofp = aux;\n\tchar type[8];\n\tint l;\n\t\n\tif ((l = OF_getprop(ofp->phandle, \"device_type\", type, sizeof type - 1)) < 0)\n\t\treturn 0;\n\tif (l >= sizeof type)\n\t\treturn 0;\n\ttype[l] = 0;\n\treturn !strcmp(type, \"block\");\n}",
    "includes": [
      "#include <dev/ofw/openfirm.h>",
      "#include <sys/systm.h>",
      "#include <sys/stat.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/disk.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/device.h>",
      "#include <sys/buf.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ofdprobe"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"block\""
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OF_getprop",
          "args": [
            "ofp->phandle",
            "\"device_type\"",
            "type",
            "sizeof type - 1"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ofw/openfirm.h>\n#include <sys/systm.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/fcntl.h>\n#include <sys/disk.h>\n#include <sys/disklabel.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/param.h>\n\nstatic int ofdprobe;\n\nstatic int\nofdprobe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct ofprobe *ofp = aux;\n\tchar type[8];\n\tint l;\n\t\n\tif ((l = OF_getprop(ofp->phandle, \"device_type\", type, sizeof type - 1)) < 0)\n\t\treturn 0;\n\tif (l >= sizeof type)\n\t\treturn 0;\n\ttype[l] = 0;\n\treturn !strcmp(type, \"block\");\n}"
  }
]