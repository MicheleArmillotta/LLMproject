[
  {
    "function_name": "rf_RaidFiveDagSelect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_raid5.c",
    "lines": "180-320",
    "snippet": "void \nrf_RaidFiveDagSelect(\n    RF_Raid_t * raidPtr,\n    RF_IoType_t type,\n    RF_AccessStripeMap_t * asmap,\n    RF_VoidFuncPtr * createFunc)\n{\n\tRF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);\n\tRF_PhysDiskAddr_t *failedPDA = NULL;\n\tRF_RowCol_t frow, fcol;\n\tRF_RowStatus_t rstat;\n\tint     prior_recon;\n\n\tRF_ASSERT(RF_IO_IS_R_OR_W(type));\n\n\tif (asmap->numDataFailed + asmap->numParityFailed > 1) {\n\t\tRF_ERRORMSG(\"Multiple disks failed in a single group!  Aborting I/O operation.\\n\");\n\t\t /* *infoFunc = */ *createFunc = NULL;\n\t\treturn;\n\t} else\n\t\tif (asmap->numDataFailed + asmap->numParityFailed == 1) {\n\n\t\t\t/* if under recon & already reconstructed, redirect\n\t\t\t * the access to the spare drive and eliminate the\n\t\t\t * failure indication */\n\t\t\tfailedPDA = asmap->failedPDAs[0];\n\t\t\tfrow = failedPDA->row;\n\t\t\tfcol = failedPDA->col;\n\t\t\trstat = raidPtr->status[failedPDA->row];\n\t\t\tprior_recon = (rstat == rf_rs_reconfigured) || (\n\t\t\t    (rstat == rf_rs_reconstructing) ?\n\t\t\t    rf_CheckRUReconstructed(raidPtr->reconControl[frow]->reconMap, failedPDA->startSector) : 0\n\t\t\t    );\n\t\t\tif (prior_recon) {\n\t\t\t\tRF_RowCol_t or = failedPDA->row, oc = failedPDA->col;\n\t\t\t\tRF_SectorNum_t oo = failedPDA->startSector;\n\n\t\t\t\tif (layoutPtr->map->flags & RF_DISTRIBUTE_SPARE) {\t/* redirect to dist\n\t\t\t\t\t\t\t\t\t\t\t * spare space */\n\n\t\t\t\t\tif (failedPDA == asmap->parityInfo) {\n\n\t\t\t\t\t\t/* parity has failed */\n\t\t\t\t\t\t(layoutPtr->map->MapParity) (raidPtr, failedPDA->raidAddress, &failedPDA->row,\n\t\t\t\t\t\t    &failedPDA->col, &failedPDA->startSector, RF_REMAP);\n\n\t\t\t\t\t\tif (asmap->parityInfo->next) {\t/* redir 2nd component,\n\t\t\t\t\t\t\t\t\t\t * if any */\n\t\t\t\t\t\t\tRF_PhysDiskAddr_t *p = asmap->parityInfo->next;\n\t\t\t\t\t\t\tRF_SectorNum_t SUoffs = p->startSector % layoutPtr->sectorsPerStripeUnit;\n\t\t\t\t\t\t\tp->row = failedPDA->row;\n\t\t\t\t\t\t\tp->col = failedPDA->col;\n\t\t\t\t\t\t\tp->startSector = rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr, failedPDA->startSector) +\n\t\t\t\t\t\t\t    SUoffs;\t/* cheating:\n\t\t\t\t\t\t\t\t\t * startSector is not\n\t\t\t\t\t\t\t\t\t * really a RAID address */\n\t\t\t\t\t\t}\n\t\t\t\t\t} else\n\t\t\t\t\t\tif (asmap->parityInfo->next && failedPDA == asmap->parityInfo->next) {\n\t\t\t\t\t\t\tRF_ASSERT(0);\t/* should not ever\n\t\t\t\t\t\t\t\t\t * happen */\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t/* data has failed */\n\t\t\t\t\t\t\t(layoutPtr->map->MapSector) (raidPtr, failedPDA->raidAddress, &failedPDA->row,\n\t\t\t\t\t\t\t    &failedPDA->col, &failedPDA->startSector, RF_REMAP);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t} else {\t/* redirect to dedicated spare\n\t\t\t\t\t\t * space */\n\n\t\t\t\t\tfailedPDA->row = raidPtr->Disks[frow][fcol].spareRow;\n\t\t\t\t\tfailedPDA->col = raidPtr->Disks[frow][fcol].spareCol;\n\n\t\t\t\t\t/* the parity may have two distinct\n\t\t\t\t\t * components, both of which may need\n\t\t\t\t\t * to be redirected */\n\t\t\t\t\tif (asmap->parityInfo->next) {\n\t\t\t\t\t\tif (failedPDA == asmap->parityInfo) {\n\t\t\t\t\t\t\tfailedPDA->next->row = failedPDA->row;\n\t\t\t\t\t\t\tfailedPDA->next->col = failedPDA->col;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tif (failedPDA == asmap->parityInfo->next) {\t/* paranoid:  should\n\t\t\t\t\t\t\t\t\t\t\t\t\t * never occur */\n\t\t\t\t\t\t\t\tasmap->parityInfo->row = failedPDA->row;\n\t\t\t\t\t\t\t\tasmap->parityInfo->col = failedPDA->col;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tRF_ASSERT(failedPDA->col != -1);\n\n\t\t\t\tif (rf_dagDebug || rf_mapDebug) {\n\t\t\t\t\tprintf(\"raid%d: Redirected type '%c' r %d c %d o %ld -> r %d c %d o %ld\\n\",\n\t\t\t\t\t       raidPtr->raidid, type, or, oc, \n\t\t\t\t\t       (long) oo, failedPDA->row, \n\t\t\t\t\t       failedPDA->col,\n\t\t\t\t\t    (long) failedPDA->startSector);\n\t\t\t\t}\n\t\t\t\tasmap->numDataFailed = asmap->numParityFailed = 0;\n\t\t\t}\n\t\t}\n\t/* all dags begin/end with block/unblock node therefore, hdrSucc &\n\t * termAnt counts should always be 1 also, these counts should not be\n\t * visible outside dag creation routines - manipulating the counts\n\t * here should be removed */\n\tif (type == RF_IO_TYPE_READ) {\n\t\tif (asmap->numDataFailed == 0)\n\t\t\t*createFunc = (RF_VoidFuncPtr) rf_CreateFaultFreeReadDAG;\n\t\telse\n\t\t\t*createFunc = (RF_VoidFuncPtr) rf_CreateRaidFiveDegradedReadDAG;\n\t} else {\n\n\n\t\t/* if mirroring, always use large writes.  If the access\n\t\t * requires two distinct parity updates, always do a small\n\t\t * write.  If the stripe contains a failure but the access\n\t\t * does not, do a small write. The first conditional\n\t\t * (numStripeUnitsAccessed <= numDataCol/2) uses a\n\t\t * less-than-or-equal rather than just a less-than because\n\t\t * when G is 3 or 4, numDataCol/2 is 1, and I want\n\t\t * single-stripe-unit updates to use just one disk. */\n\t\tif ((asmap->numDataFailed + asmap->numParityFailed) == 0) {\n\t\t\tif (rf_suppressLocksAndLargeWrites ||\n\t\t\t    (((asmap->numStripeUnitsAccessed <= (layoutPtr->numDataCol / 2)) && (layoutPtr->numDataCol != 1)) ||\n\t\t\t\t(asmap->parityInfo->next != NULL) || rf_CheckStripeForFailures(raidPtr, asmap))) {\n\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_CreateSmallWriteDAG;\n\t\t\t} else\n\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_CreateLargeWriteDAG;\n\t\t} else {\n\t\t\tif (asmap->numParityFailed == 1)\n\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_CreateNonRedundantWriteDAG;\n\t\t\telse\n\t\t\t\tif (asmap->numStripeUnitsAccessed != 1 && failedPDA->numSector != layoutPtr->sectorsPerStripeUnit)\n\t\t\t\t\t*createFunc = NULL;\n\t\t\t\telse\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_CreateDegradedWriteDAG;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"rf_utils.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid5.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_CheckStripeForFailures",
          "args": [
            "raidPtr",
            "asmap"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "rf_CheckStripeForFailures",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_map.c",
          "lines": "608-655",
          "snippet": "int \nrf_CheckStripeForFailures(raidPtr, asmap)\n\tRF_Raid_t *raidPtr;\n\tRF_AccessStripeMap_t *asmap;\n{\n\tRF_RowCol_t trow, tcol, prow, pcol, *diskids, row, i;\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_StripeCount_t stripeOffset;\n\tint     numFailures;\n\tRF_RaidAddr_t sosAddr;\n\tRF_SectorNum_t diskOffset, poffset;\n\tRF_RowCol_t testrow;\n\n\t/* quick out in the fault-free case.  */\n\tRF_LOCK_MUTEX(raidPtr->mutex);\n\tnumFailures = raidPtr->numFailures;\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\tif (numFailures == 0)\n\t\treturn (0);\n\n\tsosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, asmap->raidAddress);\n\trow = asmap->physInfo->row;\n\t(layoutPtr->map->IdentifyStripe) (raidPtr, asmap->raidAddress, &diskids, &testrow);\n\t(layoutPtr->map->MapParity) (raidPtr, asmap->raidAddress, &prow, &pcol, &poffset, 0);\t/* get pcol */\n\n\t/* this need not be true if we've redirected the access to a spare in\n\t * another row RF_ASSERT(row == testrow); */\n\tstripeOffset = 0;\n\tfor (i = 0; i < layoutPtr->numDataCol + layoutPtr->numParityCol; i++) {\n\t\tif (diskids[i] != pcol) {\n\t\t\tif (RF_DEAD_DISK(raidPtr->Disks[testrow][diskids[i]].status)) {\n\t\t\t\tif (raidPtr->status[testrow] != rf_rs_reconstructing)\n\t\t\t\t\treturn (1);\n\t\t\t\tRF_ASSERT(raidPtr->reconControl[testrow]->fcol == diskids[i]);\n\t\t\t\tlayoutPtr->map->MapSector(raidPtr,\n\t\t\t\t    sosAddr + stripeOffset * layoutPtr->sectorsPerStripeUnit,\n\t\t\t\t    &trow, &tcol, &diskOffset, 0);\n\t\t\t\tRF_ASSERT((trow == testrow) && (tcol == diskids[i]));\n\t\t\t\tif (!rf_CheckRUReconstructed(raidPtr->reconControl[testrow]->reconMap, diskOffset))\n\t\t\t\t\treturn (1);\n\t\t\t\tasmap->flags |= RF_ASM_REDIR_LARGE_WRITE;\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tstripeOffset++;\n\t\t}\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "RF_AccessStripeMapHeader_t *\nrf_MapAccess(raidPtr, raidAddress, numBlocks, buffer, remap)\n\tRF_Raid_t *raidPtr;",
            "RF_RaidAddr_t raidAddress;",
            "RF_AccessStripeMap_t *\nrf_DuplicateASM(asmap)\n\tRF_AccessStripeMap_t *asmap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nRF_AccessStripeMapHeader_t *\nrf_MapAccess(raidPtr, raidAddress, numBlocks, buffer, remap)\n\tRF_Raid_t *raidPtr;\nRF_RaidAddr_t raidAddress;\nRF_AccessStripeMap_t *\nrf_DuplicateASM(asmap)\n\tRF_AccessStripeMap_t *asmap;\n\nint \nrf_CheckStripeForFailures(raidPtr, asmap)\n\tRF_Raid_t *raidPtr;\n\tRF_AccessStripeMap_t *asmap;\n{\n\tRF_RowCol_t trow, tcol, prow, pcol, *diskids, row, i;\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_StripeCount_t stripeOffset;\n\tint     numFailures;\n\tRF_RaidAddr_t sosAddr;\n\tRF_SectorNum_t diskOffset, poffset;\n\tRF_RowCol_t testrow;\n\n\t/* quick out in the fault-free case.  */\n\tRF_LOCK_MUTEX(raidPtr->mutex);\n\tnumFailures = raidPtr->numFailures;\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\tif (numFailures == 0)\n\t\treturn (0);\n\n\tsosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, asmap->raidAddress);\n\trow = asmap->physInfo->row;\n\t(layoutPtr->map->IdentifyStripe) (raidPtr, asmap->raidAddress, &diskids, &testrow);\n\t(layoutPtr->map->MapParity) (raidPtr, asmap->raidAddress, &prow, &pcol, &poffset, 0);\t/* get pcol */\n\n\t/* this need not be true if we've redirected the access to a spare in\n\t * another row RF_ASSERT(row == testrow); */\n\tstripeOffset = 0;\n\tfor (i = 0; i < layoutPtr->numDataCol + layoutPtr->numParityCol; i++) {\n\t\tif (diskids[i] != pcol) {\n\t\t\tif (RF_DEAD_DISK(raidPtr->Disks[testrow][diskids[i]].status)) {\n\t\t\t\tif (raidPtr->status[testrow] != rf_rs_reconstructing)\n\t\t\t\t\treturn (1);\n\t\t\t\tRF_ASSERT(raidPtr->reconControl[testrow]->fcol == diskids[i]);\n\t\t\t\tlayoutPtr->map->MapSector(raidPtr,\n\t\t\t\t    sosAddr + stripeOffset * layoutPtr->sectorsPerStripeUnit,\n\t\t\t\t    &trow, &tcol, &diskOffset, 0);\n\t\t\t\tRF_ASSERT((trow == testrow) && (tcol == diskids[i]));\n\t\t\t\tif (!rf_CheckRUReconstructed(raidPtr->reconControl[testrow]->reconMap, diskOffset))\n\t\t\t\t\treturn (1);\n\t\t\t\tasmap->flags |= RF_ASM_REDIR_LARGE_WRITE;\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tstripeOffset++;\n\t\t}\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"raid%d: Redirected type '%c' r %d c %d o %ld -> r %d c %d o %ld\\n\"",
            "raidPtr->raidid",
            "type",
            "or",
            "oc",
            "(long) oo",
            "failedPDA->row",
            "failedPDA->col",
            "(long) failedPDA->startSector"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "failedPDA->col != -1"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "raidPtr",
            "failedPDA->raidAddress",
            "&failedPDA->row",
            "&failedPDA->col",
            "&failedPDA->startSector",
            "RF_REMAP"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "0"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressOfPrevStripeUnitBoundary",
          "args": [
            "layoutPtr",
            "failedPDA->startSector"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "raidPtr",
            "failedPDA->raidAddress",
            "&failedPDA->row",
            "&failedPDA->col",
            "&failedPDA->startSector",
            "RF_REMAP"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_CheckRUReconstructed",
          "args": [
            "raidPtr->reconControl[frow]->reconMap",
            "failedPDA->startSector"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "rf_CheckRUReconstructed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconmap.c",
          "lines": "308-319",
          "snippet": "int \nrf_CheckRUReconstructed(mapPtr, startSector)\n\tRF_ReconMap_t *mapPtr;\n\tRF_SectorNum_t startSector;\n{\n\tRF_ReconMapListElem_t *l;\t/* used for searching */\n\tRF_ReconUnitNum_t i;\n\n\ti = startSector / mapPtr->sectorsPerReconUnit;\n\tl = mapPtr->status[i];\n\treturn ((l == RU_ALL) ? 1 : 0);\n}",
          "includes": [
            "#include \"rf_utils.h\"",
            "#include \"rf_general.h\"",
            "#include <sys/time.h>",
            "#include \"rf_raid.h\""
          ],
          "macros_used": [
            "#define RU_ALL      ((RF_ReconMapListElem_t *) -1)"
          ],
          "globals_used": [
            "static void \ncompact_stat_entry(RF_Raid_t * raidPtr, RF_ReconMap_t * mapPtr,\n    int i);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_utils.h\"\n#include \"rf_general.h\"\n#include <sys/time.h>\n#include \"rf_raid.h\"\n\n#define RU_ALL      ((RF_ReconMapListElem_t *) -1)\n\nstatic void \ncompact_stat_entry(RF_Raid_t * raidPtr, RF_ReconMap_t * mapPtr,\n    int i);\n\nint \nrf_CheckRUReconstructed(mapPtr, startSector)\n\tRF_ReconMap_t *mapPtr;\n\tRF_SectorNum_t startSector;\n{\n\tRF_ReconMapListElem_t *l;\t/* used for searching */\n\tRF_ReconUnitNum_t i;\n\n\ti = startSector / mapPtr->sectorsPerReconUnit;\n\tl = mapPtr->status[i];\n\treturn ((l == RU_ALL) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG",
          "args": [
            "\"Multiple disks failed in a single group!  Aborting I/O operation.\\n\""
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "RF_IO_IS_R_OR_W(type)"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_IO_IS_R_OR_W",
          "args": [
            "type"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_utils.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid5.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_RaidFiveDagSelect(\n    RF_Raid_t * raidPtr,\n    RF_IoType_t type,\n    RF_AccessStripeMap_t * asmap,\n    RF_VoidFuncPtr * createFunc)\n{\n\tRF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);\n\tRF_PhysDiskAddr_t *failedPDA = NULL;\n\tRF_RowCol_t frow, fcol;\n\tRF_RowStatus_t rstat;\n\tint     prior_recon;\n\n\tRF_ASSERT(RF_IO_IS_R_OR_W(type));\n\n\tif (asmap->numDataFailed + asmap->numParityFailed > 1) {\n\t\tRF_ERRORMSG(\"Multiple disks failed in a single group!  Aborting I/O operation.\\n\");\n\t\t /* *infoFunc = */ *createFunc = NULL;\n\t\treturn;\n\t} else\n\t\tif (asmap->numDataFailed + asmap->numParityFailed == 1) {\n\n\t\t\t/* if under recon & already reconstructed, redirect\n\t\t\t * the access to the spare drive and eliminate the\n\t\t\t * failure indication */\n\t\t\tfailedPDA = asmap->failedPDAs[0];\n\t\t\tfrow = failedPDA->row;\n\t\t\tfcol = failedPDA->col;\n\t\t\trstat = raidPtr->status[failedPDA->row];\n\t\t\tprior_recon = (rstat == rf_rs_reconfigured) || (\n\t\t\t    (rstat == rf_rs_reconstructing) ?\n\t\t\t    rf_CheckRUReconstructed(raidPtr->reconControl[frow]->reconMap, failedPDA->startSector) : 0\n\t\t\t    );\n\t\t\tif (prior_recon) {\n\t\t\t\tRF_RowCol_t or = failedPDA->row, oc = failedPDA->col;\n\t\t\t\tRF_SectorNum_t oo = failedPDA->startSector;\n\n\t\t\t\tif (layoutPtr->map->flags & RF_DISTRIBUTE_SPARE) {\t/* redirect to dist\n\t\t\t\t\t\t\t\t\t\t\t * spare space */\n\n\t\t\t\t\tif (failedPDA == asmap->parityInfo) {\n\n\t\t\t\t\t\t/* parity has failed */\n\t\t\t\t\t\t(layoutPtr->map->MapParity) (raidPtr, failedPDA->raidAddress, &failedPDA->row,\n\t\t\t\t\t\t    &failedPDA->col, &failedPDA->startSector, RF_REMAP);\n\n\t\t\t\t\t\tif (asmap->parityInfo->next) {\t/* redir 2nd component,\n\t\t\t\t\t\t\t\t\t\t * if any */\n\t\t\t\t\t\t\tRF_PhysDiskAddr_t *p = asmap->parityInfo->next;\n\t\t\t\t\t\t\tRF_SectorNum_t SUoffs = p->startSector % layoutPtr->sectorsPerStripeUnit;\n\t\t\t\t\t\t\tp->row = failedPDA->row;\n\t\t\t\t\t\t\tp->col = failedPDA->col;\n\t\t\t\t\t\t\tp->startSector = rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr, failedPDA->startSector) +\n\t\t\t\t\t\t\t    SUoffs;\t/* cheating:\n\t\t\t\t\t\t\t\t\t * startSector is not\n\t\t\t\t\t\t\t\t\t * really a RAID address */\n\t\t\t\t\t\t}\n\t\t\t\t\t} else\n\t\t\t\t\t\tif (asmap->parityInfo->next && failedPDA == asmap->parityInfo->next) {\n\t\t\t\t\t\t\tRF_ASSERT(0);\t/* should not ever\n\t\t\t\t\t\t\t\t\t * happen */\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t/* data has failed */\n\t\t\t\t\t\t\t(layoutPtr->map->MapSector) (raidPtr, failedPDA->raidAddress, &failedPDA->row,\n\t\t\t\t\t\t\t    &failedPDA->col, &failedPDA->startSector, RF_REMAP);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t} else {\t/* redirect to dedicated spare\n\t\t\t\t\t\t * space */\n\n\t\t\t\t\tfailedPDA->row = raidPtr->Disks[frow][fcol].spareRow;\n\t\t\t\t\tfailedPDA->col = raidPtr->Disks[frow][fcol].spareCol;\n\n\t\t\t\t\t/* the parity may have two distinct\n\t\t\t\t\t * components, both of which may need\n\t\t\t\t\t * to be redirected */\n\t\t\t\t\tif (asmap->parityInfo->next) {\n\t\t\t\t\t\tif (failedPDA == asmap->parityInfo) {\n\t\t\t\t\t\t\tfailedPDA->next->row = failedPDA->row;\n\t\t\t\t\t\t\tfailedPDA->next->col = failedPDA->col;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tif (failedPDA == asmap->parityInfo->next) {\t/* paranoid:  should\n\t\t\t\t\t\t\t\t\t\t\t\t\t * never occur */\n\t\t\t\t\t\t\t\tasmap->parityInfo->row = failedPDA->row;\n\t\t\t\t\t\t\t\tasmap->parityInfo->col = failedPDA->col;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tRF_ASSERT(failedPDA->col != -1);\n\n\t\t\t\tif (rf_dagDebug || rf_mapDebug) {\n\t\t\t\t\tprintf(\"raid%d: Redirected type '%c' r %d c %d o %ld -> r %d c %d o %ld\\n\",\n\t\t\t\t\t       raidPtr->raidid, type, or, oc, \n\t\t\t\t\t       (long) oo, failedPDA->row, \n\t\t\t\t\t       failedPDA->col,\n\t\t\t\t\t    (long) failedPDA->startSector);\n\t\t\t\t}\n\t\t\t\tasmap->numDataFailed = asmap->numParityFailed = 0;\n\t\t\t}\n\t\t}\n\t/* all dags begin/end with block/unblock node therefore, hdrSucc &\n\t * termAnt counts should always be 1 also, these counts should not be\n\t * visible outside dag creation routines - manipulating the counts\n\t * here should be removed */\n\tif (type == RF_IO_TYPE_READ) {\n\t\tif (asmap->numDataFailed == 0)\n\t\t\t*createFunc = (RF_VoidFuncPtr) rf_CreateFaultFreeReadDAG;\n\t\telse\n\t\t\t*createFunc = (RF_VoidFuncPtr) rf_CreateRaidFiveDegradedReadDAG;\n\t} else {\n\n\n\t\t/* if mirroring, always use large writes.  If the access\n\t\t * requires two distinct parity updates, always do a small\n\t\t * write.  If the stripe contains a failure but the access\n\t\t * does not, do a small write. The first conditional\n\t\t * (numStripeUnitsAccessed <= numDataCol/2) uses a\n\t\t * less-than-or-equal rather than just a less-than because\n\t\t * when G is 3 or 4, numDataCol/2 is 1, and I want\n\t\t * single-stripe-unit updates to use just one disk. */\n\t\tif ((asmap->numDataFailed + asmap->numParityFailed) == 0) {\n\t\t\tif (rf_suppressLocksAndLargeWrites ||\n\t\t\t    (((asmap->numStripeUnitsAccessed <= (layoutPtr->numDataCol / 2)) && (layoutPtr->numDataCol != 1)) ||\n\t\t\t\t(asmap->parityInfo->next != NULL) || rf_CheckStripeForFailures(raidPtr, asmap))) {\n\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_CreateSmallWriteDAG;\n\t\t\t} else\n\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_CreateLargeWriteDAG;\n\t\t} else {\n\t\t\tif (asmap->numParityFailed == 1)\n\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_CreateNonRedundantWriteDAG;\n\t\t\telse\n\t\t\t\tif (asmap->numStripeUnitsAccessed != 1 && failedPDA->numSector != layoutPtr->sectorsPerStripeUnit)\n\t\t\t\t\t*createFunc = NULL;\n\t\t\t\telse\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_CreateDegradedWriteDAG;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "rf_MapSIDToPSIDRAID5",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_raid5.c",
    "lines": "166-175",
    "snippet": "void \nrf_MapSIDToPSIDRAID5(\n    RF_RaidLayout_t * layoutPtr,\n    RF_StripeNum_t stripeID,\n    RF_StripeNum_t * psID,\n    RF_ReconUnitNum_t * which_ru)\n{\n\t*which_ru = 0;\n\t*psID = stripeID;\n}",
    "includes": [
      "#include \"rf_utils.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid5.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_utils.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid5.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_MapSIDToPSIDRAID5(\n    RF_RaidLayout_t * layoutPtr,\n    RF_StripeNum_t stripeID,\n    RF_StripeNum_t * psID,\n    RF_ReconUnitNum_t * which_ru)\n{\n\t*which_ru = 0;\n\t*psID = stripeID;\n}"
  },
  {
    "function_name": "rf_IdentifyStripeRAID5",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_raid5.c",
    "lines": "152-164",
    "snippet": "void \nrf_IdentifyStripeRAID5(\n    RF_Raid_t * raidPtr,\n    RF_RaidAddr_t addr,\n    RF_RowCol_t ** diskids,\n    RF_RowCol_t * outRow)\n{\n\tRF_StripeNum_t stripeID = rf_RaidAddressToStripeID(&raidPtr->Layout, addr);\n\tRF_Raid5ConfigInfo_t *info = (RF_Raid5ConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;\n\n\t*outRow = 0;\n\t*diskids = info->stripeIdentifier[stripeID % raidPtr->numCol];\n}",
    "includes": [
      "#include \"rf_utils.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid5.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_RaidAddressToStripeID",
          "args": [
            "&raidPtr->Layout",
            "addr"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_utils.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid5.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_IdentifyStripeRAID5(\n    RF_Raid_t * raidPtr,\n    RF_RaidAddr_t addr,\n    RF_RowCol_t ** diskids,\n    RF_RowCol_t * outRow)\n{\n\tRF_StripeNum_t stripeID = rf_RaidAddressToStripeID(&raidPtr->Layout, addr);\n\tRF_Raid5ConfigInfo_t *info = (RF_Raid5ConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;\n\n\t*outRow = 0;\n\t*diskids = info->stripeIdentifier[stripeID % raidPtr->numCol];\n}"
  },
  {
    "function_name": "rf_MapParityRAID5",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_raid5.c",
    "lines": "135-150",
    "snippet": "void \nrf_MapParityRAID5(\n    RF_Raid_t * raidPtr,\n    RF_RaidAddr_t raidSector,\n    RF_RowCol_t * row,\n    RF_RowCol_t * col,\n    RF_SectorNum_t * diskSector,\n    int remap)\n{\n\tRF_StripeNum_t SUID = raidSector / raidPtr->Layout.sectorsPerStripeUnit;\n\n\t*row = 0;\n\t*col = raidPtr->Layout.numDataCol - (SUID / raidPtr->Layout.numDataCol) % raidPtr->numCol;\n\t*diskSector = (SUID / (raidPtr->Layout.numDataCol)) * raidPtr->Layout.sectorsPerStripeUnit +\n\t    (raidSector % raidPtr->Layout.sectorsPerStripeUnit);\n}",
    "includes": [
      "#include \"rf_utils.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid5.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_utils.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid5.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_MapParityRAID5(\n    RF_Raid_t * raidPtr,\n    RF_RaidAddr_t raidSector,\n    RF_RowCol_t * row,\n    RF_RowCol_t * col,\n    RF_SectorNum_t * diskSector,\n    int remap)\n{\n\tRF_StripeNum_t SUID = raidSector / raidPtr->Layout.sectorsPerStripeUnit;\n\n\t*row = 0;\n\t*col = raidPtr->Layout.numDataCol - (SUID / raidPtr->Layout.numDataCol) % raidPtr->numCol;\n\t*diskSector = (SUID / (raidPtr->Layout.numDataCol)) * raidPtr->Layout.sectorsPerStripeUnit +\n\t    (raidSector % raidPtr->Layout.sectorsPerStripeUnit);\n}"
  },
  {
    "function_name": "rf_MapSectorRAID5",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_raid5.c",
    "lines": "119-133",
    "snippet": "void \nrf_MapSectorRAID5(\n    RF_Raid_t * raidPtr,\n    RF_RaidAddr_t raidSector,\n    RF_RowCol_t * row,\n    RF_RowCol_t * col,\n    RF_SectorNum_t * diskSector,\n    int remap)\n{\n\tRF_StripeNum_t SUID = raidSector / raidPtr->Layout.sectorsPerStripeUnit;\n\t*row = 0;\n\t*col = (SUID % raidPtr->numCol);\n\t*diskSector = (SUID / (raidPtr->Layout.numDataCol)) * raidPtr->Layout.sectorsPerStripeUnit +\n\t    (raidSector % raidPtr->Layout.sectorsPerStripeUnit);\n}",
    "includes": [
      "#include \"rf_utils.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid5.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_utils.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid5.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_MapSectorRAID5(\n    RF_Raid_t * raidPtr,\n    RF_RaidAddr_t raidSector,\n    RF_RowCol_t * row,\n    RF_RowCol_t * col,\n    RF_SectorNum_t * diskSector,\n    int remap)\n{\n\tRF_StripeNum_t SUID = raidSector / raidPtr->Layout.sectorsPerStripeUnit;\n\t*row = 0;\n\t*col = (SUID % raidPtr->numCol);\n\t*diskSector = (SUID / (raidPtr->Layout.numDataCol)) * raidPtr->Layout.sectorsPerStripeUnit +\n\t    (raidSector % raidPtr->Layout.sectorsPerStripeUnit);\n}"
  },
  {
    "function_name": "rf_ShutdownRAID5",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_raid5.c",
    "lines": "112-116",
    "snippet": "int \nrf_ShutdownRAID5(RF_Raid_t * raidPtr)\n{\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_utils.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid5.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_utils.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid5.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nint \nrf_ShutdownRAID5(RF_Raid_t * raidPtr)\n{\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_GetDefaultHeadSepLimitRAID5",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_raid5.c",
    "lines": "105-109",
    "snippet": "RF_HeadSepLimit_t \nrf_GetDefaultHeadSepLimitRAID5(RF_Raid_t * raidPtr)\n{\n\treturn (10);\n}",
    "includes": [
      "#include \"rf_utils.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid5.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_utils.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid5.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nRF_HeadSepLimit_t \nrf_GetDefaultHeadSepLimitRAID5(RF_Raid_t * raidPtr)\n{\n\treturn (10);\n}"
  },
  {
    "function_name": "rf_GetDefaultNumFloatingReconBuffersRAID5",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_raid5.c",
    "lines": "99-103",
    "snippet": "int \nrf_GetDefaultNumFloatingReconBuffersRAID5(RF_Raid_t * raidPtr)\n{\n\treturn (20);\n}",
    "includes": [
      "#include \"rf_utils.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid5.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_utils.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid5.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nint \nrf_GetDefaultNumFloatingReconBuffersRAID5(RF_Raid_t * raidPtr)\n{\n\treturn (20);\n}"
  },
  {
    "function_name": "rf_ConfigureRAID5",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_raid5.c",
    "lines": "54-97",
    "snippet": "int \nrf_ConfigureRAID5(\n    RF_ShutdownList_t ** listp,\n    RF_Raid_t * raidPtr,\n    RF_Config_t * cfgPtr)\n{\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_Raid5ConfigInfo_t *info;\n\tRF_RowCol_t i, j, startdisk;\n\n\t/* create a RAID level 5 configuration structure */\n\tRF_MallocAndAdd(info, sizeof(RF_Raid5ConfigInfo_t), (RF_Raid5ConfigInfo_t *), raidPtr->cleanupList);\n\tif (info == NULL)\n\t\treturn (ENOMEM);\n\tlayoutPtr->layoutSpecificInfo = (void *) info;\n\n\tRF_ASSERT(raidPtr->numRow == 1);\n\n\t/* the stripe identifier must identify the disks in each stripe, IN\n\t * THE ORDER THAT THEY APPEAR IN THE STRIPE. */\n\tinfo->stripeIdentifier = rf_make_2d_array(raidPtr->numCol, raidPtr->numCol, raidPtr->cleanupList);\n\tif (info->stripeIdentifier == NULL)\n\t\treturn (ENOMEM);\n\tstartdisk = 0;\n\tfor (i = 0; i < raidPtr->numCol; i++) {\n\t\tfor (j = 0; j < raidPtr->numCol; j++) {\n\t\t\tinfo->stripeIdentifier[i][j] = (startdisk + j) % raidPtr->numCol;\n\t\t}\n\t\tif ((--startdisk) < 0)\n\t\t\tstartdisk = raidPtr->numCol - 1;\n\t}\n\n\t/* fill in the remaining layout parameters */\n\tlayoutPtr->numStripe = layoutPtr->stripeUnitsPerDisk;\n\tlayoutPtr->bytesPerStripeUnit = layoutPtr->sectorsPerStripeUnit << raidPtr->logBytesPerSector;\n\tlayoutPtr->numDataCol = raidPtr->numCol - 1;\n\tlayoutPtr->dataSectorsPerStripe = layoutPtr->numDataCol * layoutPtr->sectorsPerStripeUnit;\n\tlayoutPtr->numParityCol = 1;\n\tlayoutPtr->dataStripeUnitsPerDisk = layoutPtr->stripeUnitsPerDisk;\n\n\traidPtr->totalSectors = layoutPtr->stripeUnitsPerDisk * layoutPtr->numDataCol * layoutPtr->sectorsPerStripeUnit;\n\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_utils.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid5.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_make_2d_array",
          "args": [
            "raidPtr->numCol",
            "raidPtr->numCol",
            "raidPtr->cleanupList"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "raidPtr->numRow == 1"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_MallocAndAdd",
          "args": [
            "info",
            "sizeof(RF_Raid5ConfigInfo_t)",
            "(RF_Raid5ConfigInfo_t *), raidPtr->cleanupList"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_utils.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid5.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nint \nrf_ConfigureRAID5(\n    RF_ShutdownList_t ** listp,\n    RF_Raid_t * raidPtr,\n    RF_Config_t * cfgPtr)\n{\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_Raid5ConfigInfo_t *info;\n\tRF_RowCol_t i, j, startdisk;\n\n\t/* create a RAID level 5 configuration structure */\n\tRF_MallocAndAdd(info, sizeof(RF_Raid5ConfigInfo_t), (RF_Raid5ConfigInfo_t *), raidPtr->cleanupList);\n\tif (info == NULL)\n\t\treturn (ENOMEM);\n\tlayoutPtr->layoutSpecificInfo = (void *) info;\n\n\tRF_ASSERT(raidPtr->numRow == 1);\n\n\t/* the stripe identifier must identify the disks in each stripe, IN\n\t * THE ORDER THAT THEY APPEAR IN THE STRIPE. */\n\tinfo->stripeIdentifier = rf_make_2d_array(raidPtr->numCol, raidPtr->numCol, raidPtr->cleanupList);\n\tif (info->stripeIdentifier == NULL)\n\t\treturn (ENOMEM);\n\tstartdisk = 0;\n\tfor (i = 0; i < raidPtr->numCol; i++) {\n\t\tfor (j = 0; j < raidPtr->numCol; j++) {\n\t\t\tinfo->stripeIdentifier[i][j] = (startdisk + j) % raidPtr->numCol;\n\t\t}\n\t\tif ((--startdisk) < 0)\n\t\t\tstartdisk = raidPtr->numCol - 1;\n\t}\n\n\t/* fill in the remaining layout parameters */\n\tlayoutPtr->numStripe = layoutPtr->stripeUnitsPerDisk;\n\tlayoutPtr->bytesPerStripeUnit = layoutPtr->sectorsPerStripeUnit << raidPtr->logBytesPerSector;\n\tlayoutPtr->numDataCol = raidPtr->numCol - 1;\n\tlayoutPtr->dataSectorsPerStripe = layoutPtr->numDataCol * layoutPtr->sectorsPerStripeUnit;\n\tlayoutPtr->numParityCol = 1;\n\tlayoutPtr->dataStripeUnitsPerDisk = layoutPtr->stripeUnitsPerDisk;\n\n\traidPtr->totalSectors = layoutPtr->stripeUnitsPerDisk * layoutPtr->numDataCol * layoutPtr->sectorsPerStripeUnit;\n\n\treturn (0);\n}"
  }
]