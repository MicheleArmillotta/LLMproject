[
  {
    "function_name": "print_rbd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
    "lines": "2002-2014",
    "snippet": "void\nprint_rbd(sc, n)\n\tstruct ie_softc *sc;\n\tint n;\n{\n\n\tprintf(\"RBD at %08x:\\n  status %b, next %04x, buffer %lx\\n\"\n\t\t\"length/EOL %04x\\n\", IE_RBD_ADDR(sc->rbds,n),\n\t\tsc->ie_bus_read16(sc, IE_RBD_STATUS(sc->rbds,n)), IE_STAT_BITS,\n\t\tsc->ie_bus_read16(sc, IE_RBD_NEXT(sc->rbds,n)),\n\t\t(u_long)0,/*bus_space_read_4(sc->bt, sc->bh, IE_RBD_BUFADDR(sc->rbds,n)),-* XXX */\n\t\tsc->ie_bus_read16(sc, IE_RBD_BUFLEN(sc->rbds,n)));\n}",
    "includes": [
      "#include <dev/ic/i82596var.h>",
      "#include <dev/ic/i82596reg.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"RBD at %08x:\\n  status %b, next %04x, buffer %lx\\n\"\n\t\t\"length/EOL %04x\\n\"",
            "IE_RBD_ADDR(sc->rbds,n)",
            "sc->ie_bus_read16(sc, IE_RBD_STATUS(sc->rbds,n))",
            "IE_STAT_BITS",
            "sc->ie_bus_read16(sc, IE_RBD_NEXT(sc->rbds,n))",
            "(u_long)0",
            "/*bus_space_read_4(sc->bt, sc->bh, IE_RBD_BUFADDR(sc->rbds,n)),-* XXX */sc->ie_bus_read16(sc, IE_RBD_BUFLEN(sc->rbds,n))"
          ],
          "line": 2008
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_read16",
          "args": [
            "sc",
            "IE_RBD_BUFLEN(sc->rbds,n)"
          ],
          "line": 2013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_RBD_BUFLEN",
          "args": [
            "sc->rbds",
            "n"
          ],
          "line": 2013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_read16",
          "args": [
            "sc",
            "IE_RBD_NEXT(sc->rbds,n)"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_RBD_NEXT",
          "args": [
            "sc->rbds",
            "n"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_read16",
          "args": [
            "sc",
            "IE_RBD_STATUS(sc->rbds,n)"
          ],
          "line": 2010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_RBD_STATUS",
          "args": [
            "sc->rbds",
            "n"
          ],
          "line": 2010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_RBD_ADDR",
          "args": [
            "sc->rbds",
            "n"
          ],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nprint_rbd(sc, n)\n\tstruct ie_softc *sc;\n\tint n;\n{\n\n\tprintf(\"RBD at %08x:\\n  status %b, next %04x, buffer %lx\\n\"\n\t\t\"length/EOL %04x\\n\", IE_RBD_ADDR(sc->rbds,n),\n\t\tsc->ie_bus_read16(sc, IE_RBD_STATUS(sc->rbds,n)), IE_STAT_BITS,\n\t\tsc->ie_bus_read16(sc, IE_RBD_NEXT(sc->rbds,n)),\n\t\t(u_long)0,/*bus_space_read_4(sc->bt, sc->bh, IE_RBD_BUFADDR(sc->rbds,n)),-* XXX */\n\t\tsc->ie_bus_read16(sc, IE_RBD_BUFLEN(sc->rbds,n)));\n}"
  },
  {
    "function_name": "i82596_mediastatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
    "lines": "1990-1999",
    "snippet": "void\ni82596_mediastatus(ifp, ifmr)\n        struct ifnet *ifp;\n        struct ifmediareq *ifmr;\n{\n        struct ie_softc *sc = ifp->if_softc;\n\n        if (sc->sc_mediastatus)\n                (*sc->sc_mediastatus)(sc, ifmr);\n}",
    "includes": [
      "#include <dev/ic/i82596var.h>",
      "#include <dev/ic/i82596reg.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void  \ti82596_mediastatus"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "ifmr"
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid  \ti82596_mediastatus;\n\nvoid\ni82596_mediastatus(ifp, ifmr)\n        struct ifnet *ifp;\n        struct ifmediareq *ifmr;\n{\n        struct ie_softc *sc = ifp->if_softc;\n\n        if (sc->sc_mediastatus)\n                (*sc->sc_mediastatus)(sc, ifmr);\n}"
  },
  {
    "function_name": "i82596_mediachange",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
    "lines": "1976-1985",
    "snippet": "int\ni82596_mediachange(ifp)\n        struct ifnet *ifp;\n{\n        struct ie_softc *sc = ifp->if_softc;\n\n        if (sc->sc_mediachange)\n                return ((*sc->sc_mediachange)(sc));\n        return (EINVAL);\n}",
    "includes": [
      "#include <dev/ic/i82596var.h>",
      "#include <dev/ic/i82596reg.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int   \ti82596_mediachange"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc"
          ],
          "line": 1983
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint   \ti82596_mediachange;\n\nint\ni82596_mediachange(ifp)\n        struct ifnet *ifp;\n{\n        struct ie_softc *sc = ifp->if_softc;\n\n        if (sc->sc_mediachange)\n                return ((*sc->sc_mediachange)(sc));\n        return (EINVAL);\n}"
  },
  {
    "function_name": "ie_mc_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
    "lines": "1922-1971",
    "snippet": "void\nie_mc_reset(sc)\n\tstruct ie_softc *sc;\n{\n\tstruct ether_multi *enm;\n\tstruct ether_multistep step;\n\tint size;\n\n\t/*\n\t * Step through the list of addresses.\n\t */\nagain:\n\tsize = 0;\n\tsc->mcast_count = 0;\n\tETHER_FIRST_MULTI(step, &sc->sc_arpcom, enm);\n\twhile (enm) {\n\t\tsize += 6;\n\t\tif (sc->mcast_count >= IE_MAXMCAST ||\n\t\t    bcmp(enm->enm_addrlo, enm->enm_addrhi, 6) != 0) {\n\t\t\tsc->sc_arpcom.ac_if.if_flags |= IFF_ALLMULTI;\n\t\t\ti82596_ioctl(&sc->sc_arpcom.ac_if,\n\t\t\t\t     SIOCSIFFLAGS, (void *)0);\n\t\t\treturn;\n\t\t}\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\n\tif (size > sc->mcast_addrs_size) {\n\t\t/* Need to allocate more space */\n\t\tif (sc->mcast_addrs_size)\n\t\t\tfree(sc->mcast_addrs, M_IPMADDR);\n\t\tsc->mcast_addrs = (char *)\n\t\t\tmalloc(size, M_IPMADDR, M_WAITOK);\n\t\tsc->mcast_addrs_size = size;\n\t}\n\n\t/*\n\t * We've got the space; now copy the addresses\n\t */\n\tETHER_FIRST_MULTI(step, &sc->sc_arpcom, enm);\n\twhile (enm) {\n\t\tif (sc->mcast_count >= IE_MAXMCAST)\n\t\t\tgoto again; /* Just in case */\n\n\t\tbcopy(enm->enm_addrlo, &sc->mcast_addrs[sc->mcast_count], 6);\n\t\tsc->mcast_count++;\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\tsc->want_mcsetup = 1;\n}",
    "includes": [
      "#include <dev/ic/i82596var.h>",
      "#include <dev/ic/i82596reg.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\ti82596_ioctl",
      "void \tie_mc_reset"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ETHER_NEXT_MULTI",
          "args": [
            "step",
            "enm"
          ],
          "line": 1968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "enm->enm_addrlo",
            "&sc->mcast_addrs[sc->mcast_count]",
            "6"
          ],
          "line": 1966
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ETHER_FIRST_MULTI",
          "args": [
            "step",
            "&sc->sc_arpcom",
            "enm"
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "size",
            "M_IPMADDR",
            "M_WAITOK"
          ],
          "line": 1954
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "sc->mcast_addrs",
            "M_IPMADDR"
          ],
          "line": 1952
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_free_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1617-1633",
          "snippet": "void\nwdc_free_xfer(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct wdc_softc *wdc = chp->wdc;\n\tint s;\n\n\tif (wdc->cap & WDC_CAPABILITY_HWLOCK)\n\t\t(*wdc->free_hw)(chp);\n\ts = splbio();\n\tchp->ch_flags &= ~WDCF_ACTIVE;\n\tTAILQ_REMOVE(&chp->ch_queue->sc_xfer, xfer, c_xferchain);\n\txfer->c_flags &= ~C_INUSE;\n\tLIST_INSERT_HEAD(&xfer_free_list, xfer, free_list);\n\tsplx(s);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwdc_free_xfer(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct wdc_softc *wdc = chp->wdc;\n\tint s;\n\n\tif (wdc->cap & WDC_CAPABILITY_HWLOCK)\n\t\t(*wdc->free_hw)(chp);\n\ts = splbio();\n\tchp->ch_flags &= ~WDCF_ACTIVE;\n\tTAILQ_REMOVE(&chp->ch_queue->sc_xfer, xfer, c_xferchain);\n\txfer->c_flags &= ~C_INUSE;\n\tLIST_INSERT_HEAD(&xfer_free_list, xfer, free_list);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ETHER_NEXT_MULTI",
          "args": [
            "step",
            "enm"
          ],
          "line": 1946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i82596_ioctl",
          "args": [
            "&sc->sc_arpcom.ac_if",
            "SIOCSIFFLAGS",
            "(void *)0"
          ],
          "line": 1942
        },
        "resolved": true,
        "details": {
          "function_name": "i82596_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "1825-1920",
          "snippet": "int\ni82596_ioctl(ifp, cmd, data)\n\tregister struct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct ie_softc *sc = ifp->if_softc;\n\tstruct ifaddr *ifa = (struct ifaddr *)data;\n\tstruct ifreq *ifr = (struct ifreq *)data;\n\tint s, error = 0;\n\n\ts = splnet();\n\n\tif ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {\n\t\tsplx(s);\n\t\treturn error;\n\t}\n\n\tswitch(cmd) {\n\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch(ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\ti82596_init(sc);\n\t\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\ti82596_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS:\n\t\tsc->promisc = ifp->if_flags & (IFF_PROMISC | IFF_ALLMULTI);\n\t\tif ((ifp->if_flags & IFF_UP) == 0 &&\n\t\t    (ifp->if_flags & IFF_RUNNING) != 0) {\n\t\t\t/*\n\t\t\t * If interface is marked down and it is running, then\n\t\t\t * stop it.\n\t\t\t */\n\t\t\ti82596_stop(sc);\n\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\t} else if ((ifp->if_flags & IFF_UP) != 0 &&\n\t\t\t   (ifp->if_flags & IFF_RUNNING) == 0) {\n\t\t\t/*\n\t\t\t * If interface is marked up and it is stopped, then\n\t\t\t * start it.\n\t\t\t */\n\t\t\ti82596_init(sc);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Reset the interface to pick up changes in any other\n\t\t\t * flags that affect hardware registers.\n\t\t\t */\n\t\t\ti82596_stop(sc);\n\t\t\ti82596_init(sc);\n\t\t}\n#ifdef I82596_DEBUG\n\t\tif (ifp->if_flags & IFF_DEBUG)\n\t\t\tsc->sc_debug = IED_ALL;\n\t\telse\n\t\t\tsc->sc_debug = 0;\n#endif\n\t\tbreak;\n\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\terror = (cmd == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->sc_arpcom):\n\t\t    ether_delmulti(ifr, &sc->sc_arpcom);\n\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware filter\n\t\t\t * accordingly.\n\t\t\t */\n\t\t\tie_mc_reset(sc);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n        case SIOCGIFMEDIA:\n        case SIOCSIFMEDIA:\n                error = ifmedia_ioctl(ifp, ifr, &sc->sc_media, cmd);\n                break;\n\n\tdefault:\n\t\terror = EINVAL;\n\t}\n\tsplx(s);\n\treturn (error);\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\ti82596_init",
            "int\ti82596_ioctl",
            "void\ti82596_stop",
            "void \tie_mc_reset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ti82596_init;\nint\ti82596_ioctl;\nvoid\ti82596_stop;\nvoid \tie_mc_reset;\n\nint\ni82596_ioctl(ifp, cmd, data)\n\tregister struct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct ie_softc *sc = ifp->if_softc;\n\tstruct ifaddr *ifa = (struct ifaddr *)data;\n\tstruct ifreq *ifr = (struct ifreq *)data;\n\tint s, error = 0;\n\n\ts = splnet();\n\n\tif ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {\n\t\tsplx(s);\n\t\treturn error;\n\t}\n\n\tswitch(cmd) {\n\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch(ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\ti82596_init(sc);\n\t\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\ti82596_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS:\n\t\tsc->promisc = ifp->if_flags & (IFF_PROMISC | IFF_ALLMULTI);\n\t\tif ((ifp->if_flags & IFF_UP) == 0 &&\n\t\t    (ifp->if_flags & IFF_RUNNING) != 0) {\n\t\t\t/*\n\t\t\t * If interface is marked down and it is running, then\n\t\t\t * stop it.\n\t\t\t */\n\t\t\ti82596_stop(sc);\n\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\t} else if ((ifp->if_flags & IFF_UP) != 0 &&\n\t\t\t   (ifp->if_flags & IFF_RUNNING) == 0) {\n\t\t\t/*\n\t\t\t * If interface is marked up and it is stopped, then\n\t\t\t * start it.\n\t\t\t */\n\t\t\ti82596_init(sc);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Reset the interface to pick up changes in any other\n\t\t\t * flags that affect hardware registers.\n\t\t\t */\n\t\t\ti82596_stop(sc);\n\t\t\ti82596_init(sc);\n\t\t}\n#ifdef I82596_DEBUG\n\t\tif (ifp->if_flags & IFF_DEBUG)\n\t\t\tsc->sc_debug = IED_ALL;\n\t\telse\n\t\t\tsc->sc_debug = 0;\n#endif\n\t\tbreak;\n\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\terror = (cmd == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->sc_arpcom):\n\t\t    ether_delmulti(ifr, &sc->sc_arpcom);\n\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware filter\n\t\t\t * accordingly.\n\t\t\t */\n\t\t\tie_mc_reset(sc);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n        case SIOCGIFMEDIA:\n        case SIOCSIFMEDIA:\n                error = ifmedia_ioctl(ifp, ifr, &sc->sc_media, cmd);\n                break;\n\n\tdefault:\n\t\terror = EINVAL;\n\t}\n\tsplx(s);\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "enm->enm_addrlo",
            "enm->enm_addrhi",
            "6"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ETHER_FIRST_MULTI",
          "args": [
            "step",
            "&sc->sc_arpcom",
            "enm"
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ti82596_ioctl;\nvoid \tie_mc_reset;\n\nvoid\nie_mc_reset(sc)\n\tstruct ie_softc *sc;\n{\n\tstruct ether_multi *enm;\n\tstruct ether_multistep step;\n\tint size;\n\n\t/*\n\t * Step through the list of addresses.\n\t */\nagain:\n\tsize = 0;\n\tsc->mcast_count = 0;\n\tETHER_FIRST_MULTI(step, &sc->sc_arpcom, enm);\n\twhile (enm) {\n\t\tsize += 6;\n\t\tif (sc->mcast_count >= IE_MAXMCAST ||\n\t\t    bcmp(enm->enm_addrlo, enm->enm_addrhi, 6) != 0) {\n\t\t\tsc->sc_arpcom.ac_if.if_flags |= IFF_ALLMULTI;\n\t\t\ti82596_ioctl(&sc->sc_arpcom.ac_if,\n\t\t\t\t     SIOCSIFFLAGS, (void *)0);\n\t\t\treturn;\n\t\t}\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\n\tif (size > sc->mcast_addrs_size) {\n\t\t/* Need to allocate more space */\n\t\tif (sc->mcast_addrs_size)\n\t\t\tfree(sc->mcast_addrs, M_IPMADDR);\n\t\tsc->mcast_addrs = (char *)\n\t\t\tmalloc(size, M_IPMADDR, M_WAITOK);\n\t\tsc->mcast_addrs_size = size;\n\t}\n\n\t/*\n\t * We've got the space; now copy the addresses\n\t */\n\tETHER_FIRST_MULTI(step, &sc->sc_arpcom, enm);\n\twhile (enm) {\n\t\tif (sc->mcast_count >= IE_MAXMCAST)\n\t\t\tgoto again; /* Just in case */\n\n\t\tbcopy(enm->enm_addrlo, &sc->mcast_addrs[sc->mcast_count], 6);\n\t\tsc->mcast_count++;\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\tsc->want_mcsetup = 1;\n}"
  },
  {
    "function_name": "i82596_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
    "lines": "1825-1920",
    "snippet": "int\ni82596_ioctl(ifp, cmd, data)\n\tregister struct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct ie_softc *sc = ifp->if_softc;\n\tstruct ifaddr *ifa = (struct ifaddr *)data;\n\tstruct ifreq *ifr = (struct ifreq *)data;\n\tint s, error = 0;\n\n\ts = splnet();\n\n\tif ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {\n\t\tsplx(s);\n\t\treturn error;\n\t}\n\n\tswitch(cmd) {\n\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch(ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\ti82596_init(sc);\n\t\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\ti82596_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS:\n\t\tsc->promisc = ifp->if_flags & (IFF_PROMISC | IFF_ALLMULTI);\n\t\tif ((ifp->if_flags & IFF_UP) == 0 &&\n\t\t    (ifp->if_flags & IFF_RUNNING) != 0) {\n\t\t\t/*\n\t\t\t * If interface is marked down and it is running, then\n\t\t\t * stop it.\n\t\t\t */\n\t\t\ti82596_stop(sc);\n\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\t} else if ((ifp->if_flags & IFF_UP) != 0 &&\n\t\t\t   (ifp->if_flags & IFF_RUNNING) == 0) {\n\t\t\t/*\n\t\t\t * If interface is marked up and it is stopped, then\n\t\t\t * start it.\n\t\t\t */\n\t\t\ti82596_init(sc);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Reset the interface to pick up changes in any other\n\t\t\t * flags that affect hardware registers.\n\t\t\t */\n\t\t\ti82596_stop(sc);\n\t\t\ti82596_init(sc);\n\t\t}\n#ifdef I82596_DEBUG\n\t\tif (ifp->if_flags & IFF_DEBUG)\n\t\t\tsc->sc_debug = IED_ALL;\n\t\telse\n\t\t\tsc->sc_debug = 0;\n#endif\n\t\tbreak;\n\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\terror = (cmd == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->sc_arpcom):\n\t\t    ether_delmulti(ifr, &sc->sc_arpcom);\n\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware filter\n\t\t\t * accordingly.\n\t\t\t */\n\t\t\tie_mc_reset(sc);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n        case SIOCGIFMEDIA:\n        case SIOCSIFMEDIA:\n                error = ifmedia_ioctl(ifp, ifr, &sc->sc_media, cmd);\n                break;\n\n\tdefault:\n\t\terror = EINVAL;\n\t}\n\tsplx(s);\n\treturn (error);\n}",
    "includes": [
      "#include <dev/ic/i82596var.h>",
      "#include <dev/ic/i82596reg.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\ti82596_init",
      "int\ti82596_ioctl",
      "void\ti82596_stop",
      "void \tie_mc_reset"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_ioctl",
          "args": [
            "ifp",
            "ifr",
            "&sc->sc_media",
            "cmd"
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ie_mc_reset",
          "args": [
            "sc"
          ],
          "line": 1905
        },
        "resolved": true,
        "details": {
          "function_name": "ie_mc_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "1922-1971",
          "snippet": "void\nie_mc_reset(sc)\n\tstruct ie_softc *sc;\n{\n\tstruct ether_multi *enm;\n\tstruct ether_multistep step;\n\tint size;\n\n\t/*\n\t * Step through the list of addresses.\n\t */\nagain:\n\tsize = 0;\n\tsc->mcast_count = 0;\n\tETHER_FIRST_MULTI(step, &sc->sc_arpcom, enm);\n\twhile (enm) {\n\t\tsize += 6;\n\t\tif (sc->mcast_count >= IE_MAXMCAST ||\n\t\t    bcmp(enm->enm_addrlo, enm->enm_addrhi, 6) != 0) {\n\t\t\tsc->sc_arpcom.ac_if.if_flags |= IFF_ALLMULTI;\n\t\t\ti82596_ioctl(&sc->sc_arpcom.ac_if,\n\t\t\t\t     SIOCSIFFLAGS, (void *)0);\n\t\t\treturn;\n\t\t}\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\n\tif (size > sc->mcast_addrs_size) {\n\t\t/* Need to allocate more space */\n\t\tif (sc->mcast_addrs_size)\n\t\t\tfree(sc->mcast_addrs, M_IPMADDR);\n\t\tsc->mcast_addrs = (char *)\n\t\t\tmalloc(size, M_IPMADDR, M_WAITOK);\n\t\tsc->mcast_addrs_size = size;\n\t}\n\n\t/*\n\t * We've got the space; now copy the addresses\n\t */\n\tETHER_FIRST_MULTI(step, &sc->sc_arpcom, enm);\n\twhile (enm) {\n\t\tif (sc->mcast_count >= IE_MAXMCAST)\n\t\t\tgoto again; /* Just in case */\n\n\t\tbcopy(enm->enm_addrlo, &sc->mcast_addrs[sc->mcast_count], 6);\n\t\tsc->mcast_count++;\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\tsc->want_mcsetup = 1;\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\ti82596_ioctl",
            "void \tie_mc_reset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ti82596_ioctl;\nvoid \tie_mc_reset;\n\nvoid\nie_mc_reset(sc)\n\tstruct ie_softc *sc;\n{\n\tstruct ether_multi *enm;\n\tstruct ether_multistep step;\n\tint size;\n\n\t/*\n\t * Step through the list of addresses.\n\t */\nagain:\n\tsize = 0;\n\tsc->mcast_count = 0;\n\tETHER_FIRST_MULTI(step, &sc->sc_arpcom, enm);\n\twhile (enm) {\n\t\tsize += 6;\n\t\tif (sc->mcast_count >= IE_MAXMCAST ||\n\t\t    bcmp(enm->enm_addrlo, enm->enm_addrhi, 6) != 0) {\n\t\t\tsc->sc_arpcom.ac_if.if_flags |= IFF_ALLMULTI;\n\t\t\ti82596_ioctl(&sc->sc_arpcom.ac_if,\n\t\t\t\t     SIOCSIFFLAGS, (void *)0);\n\t\t\treturn;\n\t\t}\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\n\tif (size > sc->mcast_addrs_size) {\n\t\t/* Need to allocate more space */\n\t\tif (sc->mcast_addrs_size)\n\t\t\tfree(sc->mcast_addrs, M_IPMADDR);\n\t\tsc->mcast_addrs = (char *)\n\t\t\tmalloc(size, M_IPMADDR, M_WAITOK);\n\t\tsc->mcast_addrs_size = size;\n\t}\n\n\t/*\n\t * We've got the space; now copy the addresses\n\t */\n\tETHER_FIRST_MULTI(step, &sc->sc_arpcom, enm);\n\twhile (enm) {\n\t\tif (sc->mcast_count >= IE_MAXMCAST)\n\t\t\tgoto again; /* Just in case */\n\n\t\tbcopy(enm->enm_addrlo, &sc->mcast_addrs[sc->mcast_count], 6);\n\t\tsc->mcast_count++;\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\tsc->want_mcsetup = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_delmulti",
          "args": [
            "ifr",
            "&sc->sc_arpcom"
          ],
          "line": 1898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_addmulti",
          "args": [
            "ifr",
            "&sc->sc_arpcom"
          ],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i82596_init",
          "args": [
            "sc"
          ],
          "line": 1884
        },
        "resolved": true,
        "details": {
          "function_name": "i82596_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "1717-1772",
          "snippet": "int\ni82596_init(sc)\n\tstruct ie_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint cmd;\n\n\tsc->async_cmd_inprogress = 0;\n\n\tcmd = sc->buf_area;\n\n\t/*\n\t * Send the configure command first.\n\t */\n\tif (ie_cfg_setup(sc, cmd, sc->promisc, 0) == 0)\n\t\treturn (0);\n\n\t/*\n\t * Send the Individual Address Setup command.\n\t */\n\tif (ie_ia_setup(sc, cmd) == 0)\n\t\treturn (0);\n\n\t/*\n\t * Run the time-domain reflectometer.\n\t */\n\tie_run_tdr(sc, cmd);\n\n\t/*\n\t * Set the multi-cast filter, if any\n\t */\n\tif (ie_mc_setup(sc, cmd) == 0)\n\t\treturn (0);\n\n\t/*\n\t * Acknowledge any interrupts we have generated thus far.\n\t */\n\tie_ack(sc, IE_ST_WHENCE);\n\n\t/*\n\t * Set up the transmit and recv buffers.\n\t */\n\ti82596_setup_bufs(sc);\n\n\tif (sc->hwinit)\n\t\t(sc->hwinit)(sc);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tif (NTXBUF < 2)\n\t\tsc->do_xmitnopchain = 0;\n\n\ti82596_start_transceiver(sc);\n\treturn (1);\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\ti82596_init",
            "void\ti82596_start_transceiver",
            "void \ti82596_setup_bufs",
            "int \tie_cfg_setup",
            "int\tie_ia_setup",
            "void \tie_run_tdr",
            "int \tie_mc_setup"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ti82596_init;\nvoid\ti82596_start_transceiver;\nvoid \ti82596_setup_bufs;\nint \tie_cfg_setup;\nint\tie_ia_setup;\nvoid \tie_run_tdr;\nint \tie_mc_setup;\n\nint\ni82596_init(sc)\n\tstruct ie_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint cmd;\n\n\tsc->async_cmd_inprogress = 0;\n\n\tcmd = sc->buf_area;\n\n\t/*\n\t * Send the configure command first.\n\t */\n\tif (ie_cfg_setup(sc, cmd, sc->promisc, 0) == 0)\n\t\treturn (0);\n\n\t/*\n\t * Send the Individual Address Setup command.\n\t */\n\tif (ie_ia_setup(sc, cmd) == 0)\n\t\treturn (0);\n\n\t/*\n\t * Run the time-domain reflectometer.\n\t */\n\tie_run_tdr(sc, cmd);\n\n\t/*\n\t * Set the multi-cast filter, if any\n\t */\n\tif (ie_mc_setup(sc, cmd) == 0)\n\t\treturn (0);\n\n\t/*\n\t * Acknowledge any interrupts we have generated thus far.\n\t */\n\tie_ack(sc, IE_ST_WHENCE);\n\n\t/*\n\t * Set up the transmit and recv buffers.\n\t */\n\ti82596_setup_bufs(sc);\n\n\tif (sc->hwinit)\n\t\t(sc->hwinit)(sc);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tif (NTXBUF < 2)\n\t\tsc->do_xmitnopchain = 0;\n\n\ti82596_start_transceiver(sc);\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i82596_stop",
          "args": [
            "sc"
          ],
          "line": 1883
        },
        "resolved": true,
        "details": {
          "function_name": "i82596_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "1815-1823",
          "snippet": "void\ni82596_stop(sc)\n\tstruct ie_softc *sc;\n{\n\n\tif (i82596_start_cmd(sc, IE_RUC_SUSPEND | IE_CUC_SUSPEND, 0, 0, 0))\n\t\tprintf(\"%s: i82596_stop: disable commands timed out\\n\",\n\t\t\tsc->sc_dev.dv_xname);\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\ti82596_stop"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ti82596_stop;\n\nvoid\ni82596_stop(sc)\n\tstruct ie_softc *sc;\n{\n\n\tif (i82596_start_cmd(sc, IE_RUC_SUSPEND | IE_CUC_SUSPEND, 0, 0, 0))\n\t\tprintf(\"%s: i82596_stop: disable commands timed out\\n\",\n\t\t\tsc->sc_dev.dv_xname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arp_ifinit",
          "args": [
            "&sc->sc_arpcom",
            "ifa"
          ],
          "line": 1852
        },
        "resolved": true,
        "details": {
          "function_name": "arp_ifinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_devar.h",
          "lines": "929-936",
          "snippet": "static void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}",
          "includes": [
            "#include <sys/devconf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/devconf.h>\n\nstatic void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ioctl",
          "args": [
            "ifp",
            "&sc->sc_arpcom",
            "cmd",
            "data"
          ],
          "line": 1838
        },
        "resolved": true,
        "details": {
          "function_name": "fxp_ether_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
          "lines": "301-348",
          "snippet": "int\nfxp_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tstruct fxp_softc *sc = ifp->if_softc;\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tfxp_init(sc);\n\t\t\tarp_ifinit(&sc->arpcom, ifa);\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t    {\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t /* Set new address. */\n\t\t\t fxp_init(sc);\n\t\t\t break;\n\t\t    }\n#endif\n\t\tdefault:\n\t\t\tfxp_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/ic/fxpvar.h>",
            "#include <dev/ic/fxpreg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void fxp_init",
            "int\tfxp_ether_ioctl"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid fxp_init;\nint\tfxp_ether_ioctl;\n\nint\nfxp_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tstruct fxp_softc *sc = ifp->if_softc;\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tfxp_init(sc);\n\t\t\tarp_ifinit(&sc->arpcom, ifa);\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t    {\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t /* Set new address. */\n\t\t\t fxp_init(sc);\n\t\t\t break;\n\t\t    }\n#endif\n\t\tdefault:\n\t\t\tfxp_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 1836
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ti82596_init;\nint\ti82596_ioctl;\nvoid\ti82596_stop;\nvoid \tie_mc_reset;\n\nint\ni82596_ioctl(ifp, cmd, data)\n\tregister struct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct ie_softc *sc = ifp->if_softc;\n\tstruct ifaddr *ifa = (struct ifaddr *)data;\n\tstruct ifreq *ifr = (struct ifreq *)data;\n\tint s, error = 0;\n\n\ts = splnet();\n\n\tif ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {\n\t\tsplx(s);\n\t\treturn error;\n\t}\n\n\tswitch(cmd) {\n\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch(ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\ti82596_init(sc);\n\t\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\ti82596_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS:\n\t\tsc->promisc = ifp->if_flags & (IFF_PROMISC | IFF_ALLMULTI);\n\t\tif ((ifp->if_flags & IFF_UP) == 0 &&\n\t\t    (ifp->if_flags & IFF_RUNNING) != 0) {\n\t\t\t/*\n\t\t\t * If interface is marked down and it is running, then\n\t\t\t * stop it.\n\t\t\t */\n\t\t\ti82596_stop(sc);\n\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\t} else if ((ifp->if_flags & IFF_UP) != 0 &&\n\t\t\t   (ifp->if_flags & IFF_RUNNING) == 0) {\n\t\t\t/*\n\t\t\t * If interface is marked up and it is stopped, then\n\t\t\t * start it.\n\t\t\t */\n\t\t\ti82596_init(sc);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Reset the interface to pick up changes in any other\n\t\t\t * flags that affect hardware registers.\n\t\t\t */\n\t\t\ti82596_stop(sc);\n\t\t\ti82596_init(sc);\n\t\t}\n#ifdef I82596_DEBUG\n\t\tif (ifp->if_flags & IFF_DEBUG)\n\t\t\tsc->sc_debug = IED_ALL;\n\t\telse\n\t\t\tsc->sc_debug = 0;\n#endif\n\t\tbreak;\n\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\terror = (cmd == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->sc_arpcom):\n\t\t    ether_delmulti(ifr, &sc->sc_arpcom);\n\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware filter\n\t\t\t * accordingly.\n\t\t\t */\n\t\t\tie_mc_reset(sc);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n        case SIOCGIFMEDIA:\n        case SIOCSIFMEDIA:\n                error = ifmedia_ioctl(ifp, ifr, &sc->sc_media, cmd);\n                break;\n\n\tdefault:\n\t\terror = EINVAL;\n\t}\n\tsplx(s);\n\treturn (error);\n}"
  },
  {
    "function_name": "i82596_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
    "lines": "1815-1823",
    "snippet": "void\ni82596_stop(sc)\n\tstruct ie_softc *sc;\n{\n\n\tif (i82596_start_cmd(sc, IE_RUC_SUSPEND | IE_CUC_SUSPEND, 0, 0, 0))\n\t\tprintf(\"%s: i82596_stop: disable commands timed out\\n\",\n\t\t\tsc->sc_dev.dv_xname);\n}",
    "includes": [
      "#include <dev/ic/i82596var.h>",
      "#include <dev/ic/i82596reg.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\ti82596_stop"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: i82596_stop: disable commands timed out\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1821
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i82596_start_cmd",
          "args": [
            "sc",
            "IE_RUC_SUSPEND | IE_CUC_SUSPEND",
            "0",
            "0",
            "0"
          ],
          "line": 1820
        },
        "resolved": true,
        "details": {
          "function_name": "i82596_start_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "398-468",
          "snippet": "int\ni82596_start_cmd(sc, cmd, iecmdbuf, mask, async)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tint iecmdbuf;\n\tint mask;\n\tint async;\n{\n\tregister int i, off;\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_CMDS)\n\t\tprintf(\"start_cmd: %p, %x, %x, %b, %ssync\\n\",\n\t\t       sc, cmd, iecmdbuf, mask, IE_STAT_BITS, async?\"a\":\"\");\n#endif\n\tif (sc->async_cmd_inprogress != 0) {\n\t\t/*\n\t\t * If previous command was issued asynchronously, wait\n\t\t * for it now.\n\t\t */\n\t\tif (i82596_cmd_wait(sc) != 0)\n\t\t\treturn (1);\n\t\tsc->async_cmd_inprogress = 0;\n\t}\n\n\toff = IE_SCB_CMD(sc->scb);\n\t(sc->ie_bus_write16)(sc, off, cmd);\n\tbus_space_barrier(sc->bt, sc->bh, off, 2, BUS_SPACE_BARRIER_WRITE);\n\t(sc->chan_attn)(sc);\n\n\tif (async) {\n\t\tsc->async_cmd_inprogress = 1;\n\t\treturn (0);\n\t}\n\n\tif (IE_ACTION_COMMAND(cmd) && iecmdbuf) {\n\t\tint status;\n\t\t/*\n\t\t * Now spin-lock waiting for status.  This is not a very nice\n\t\t * thing to do, and can kill performance pretty well...\n\t\t * According to the packet driver, the minimum timeout\n\t\t * should be .369 seconds.\n\t\t */\n\t\tfor (i = 0; i < 36900; i++) {\n\t\t\t/* Read the command status */\n\t\t\toff = IE_CMD_COMMON_STATUS(iecmdbuf);\n\t\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\t\tstatus = (sc->ie_bus_read16)(sc, off);\n\t\t\tif (status & mask) {\n#ifdef I82596_DEBUG\n\t\t\t\tif (sc->sc_debug & IED_CMDS)\n\t\t\t\t\tprintf (\"%s: cmd status %b\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\t\tstatus, IE_STAT_BITS);\n#endif\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tdelay(10);\n\t\t}\n\n\t} else {\n\t\t/*\n\t\t * Otherwise, just wait for the command to be accepted.\n\t\t */\n\t\treturn (i82596_cmd_wait(sc));\n\t}\n\n\t/* Timeout */\n\treturn (1);\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\ti82596_cmd_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ti82596_cmd_wait;\n\nint\ni82596_start_cmd(sc, cmd, iecmdbuf, mask, async)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tint iecmdbuf;\n\tint mask;\n\tint async;\n{\n\tregister int i, off;\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_CMDS)\n\t\tprintf(\"start_cmd: %p, %x, %x, %b, %ssync\\n\",\n\t\t       sc, cmd, iecmdbuf, mask, IE_STAT_BITS, async?\"a\":\"\");\n#endif\n\tif (sc->async_cmd_inprogress != 0) {\n\t\t/*\n\t\t * If previous command was issued asynchronously, wait\n\t\t * for it now.\n\t\t */\n\t\tif (i82596_cmd_wait(sc) != 0)\n\t\t\treturn (1);\n\t\tsc->async_cmd_inprogress = 0;\n\t}\n\n\toff = IE_SCB_CMD(sc->scb);\n\t(sc->ie_bus_write16)(sc, off, cmd);\n\tbus_space_barrier(sc->bt, sc->bh, off, 2, BUS_SPACE_BARRIER_WRITE);\n\t(sc->chan_attn)(sc);\n\n\tif (async) {\n\t\tsc->async_cmd_inprogress = 1;\n\t\treturn (0);\n\t}\n\n\tif (IE_ACTION_COMMAND(cmd) && iecmdbuf) {\n\t\tint status;\n\t\t/*\n\t\t * Now spin-lock waiting for status.  This is not a very nice\n\t\t * thing to do, and can kill performance pretty well...\n\t\t * According to the packet driver, the minimum timeout\n\t\t * should be .369 seconds.\n\t\t */\n\t\tfor (i = 0; i < 36900; i++) {\n\t\t\t/* Read the command status */\n\t\t\toff = IE_CMD_COMMON_STATUS(iecmdbuf);\n\t\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\t\tstatus = (sc->ie_bus_read16)(sc, off);\n\t\t\tif (status & mask) {\n#ifdef I82596_DEBUG\n\t\t\t\tif (sc->sc_debug & IED_CMDS)\n\t\t\t\t\tprintf (\"%s: cmd status %b\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\t\tstatus, IE_STAT_BITS);\n#endif\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tdelay(10);\n\t\t}\n\n\t} else {\n\t\t/*\n\t\t * Otherwise, just wait for the command to be accepted.\n\t\t */\n\t\treturn (i82596_cmd_wait(sc));\n\t}\n\n\t/* Timeout */\n\treturn (1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ti82596_stop;\n\nvoid\ni82596_stop(sc)\n\tstruct ie_softc *sc;\n{\n\n\tif (i82596_start_cmd(sc, IE_RUC_SUSPEND | IE_CUC_SUSPEND, 0, 0, 0))\n\t\tprintf(\"%s: i82596_stop: disable commands timed out\\n\",\n\t\t\tsc->sc_dev.dv_xname);\n}"
  },
  {
    "function_name": "i82596_start_transceiver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
    "lines": "1777-1813",
    "snippet": "void\ni82596_start_transceiver(sc)\n\tstruct ie_softc *sc;\n{\n\n\t/*\n\t * Start RU at current position in frame & RBD lists.\n\t */\n\tsc->ie_bus_write16(sc, IE_RFRAME_BUFDESC(sc->rframes,sc->rfhead),\n\t\t\t       IE_RBD_ADDR(sc->rbds, sc->rbhead));\n\n\tsc->ie_bus_write16(sc, IE_SCB_RCVLST(sc->scb),\n\t\t\t       IE_RFRAME_ADDR(sc->rframes,sc->rfhead));\n\n\tif (sc->do_xmitnopchain) {\n\t\t/* Stop transmit command chain */\n\t\tif (i82596_start_cmd(sc, IE_CUC_SUSPEND|IE_RUC_SUSPEND, 0, 0, 0))\n\t\t\tprintf(\"%s: CU/RU stop command timed out\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\n\t\t/* Start the receiver & transmitter chain */\n\t\t/* sc->scb->ie_command_list =\n\t\t\tIEADDR(sc->nop_cmds[(sc->xctail+NTXBUF-1) % NTXBUF]);*/\n\t\tsc->ie_bus_write16(sc, IE_SCB_CMDLST(sc->scb),\n\t\t\t\t   IE_CMD_NOP_ADDR(\n\t\t\t\t\tsc->nop_cmds,\n\t\t\t\t\t(sc->xctail + NTXBUF - 1) % NTXBUF));\n\n\t\tif (i82596_start_cmd(sc, IE_CUC_START|IE_RUC_START, 0, 0, 0))\n\t\t\tprintf(\"%s: CU/RU command timed out\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t} else {\n\t\tif (i82596_start_cmd(sc, IE_RUC_START, 0, 0, 0))\n\t\t\tprintf(\"%s: RU command timed out\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t}\n}",
    "includes": [
      "#include <dev/ic/i82596var.h>",
      "#include <dev/ic/i82596reg.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\ti82596_start_transceiver"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: RU command timed out\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1810
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i82596_start_cmd",
          "args": [
            "sc",
            "IE_RUC_START",
            "0",
            "0",
            "0"
          ],
          "line": 1809
        },
        "resolved": true,
        "details": {
          "function_name": "i82596_start_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "398-468",
          "snippet": "int\ni82596_start_cmd(sc, cmd, iecmdbuf, mask, async)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tint iecmdbuf;\n\tint mask;\n\tint async;\n{\n\tregister int i, off;\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_CMDS)\n\t\tprintf(\"start_cmd: %p, %x, %x, %b, %ssync\\n\",\n\t\t       sc, cmd, iecmdbuf, mask, IE_STAT_BITS, async?\"a\":\"\");\n#endif\n\tif (sc->async_cmd_inprogress != 0) {\n\t\t/*\n\t\t * If previous command was issued asynchronously, wait\n\t\t * for it now.\n\t\t */\n\t\tif (i82596_cmd_wait(sc) != 0)\n\t\t\treturn (1);\n\t\tsc->async_cmd_inprogress = 0;\n\t}\n\n\toff = IE_SCB_CMD(sc->scb);\n\t(sc->ie_bus_write16)(sc, off, cmd);\n\tbus_space_barrier(sc->bt, sc->bh, off, 2, BUS_SPACE_BARRIER_WRITE);\n\t(sc->chan_attn)(sc);\n\n\tif (async) {\n\t\tsc->async_cmd_inprogress = 1;\n\t\treturn (0);\n\t}\n\n\tif (IE_ACTION_COMMAND(cmd) && iecmdbuf) {\n\t\tint status;\n\t\t/*\n\t\t * Now spin-lock waiting for status.  This is not a very nice\n\t\t * thing to do, and can kill performance pretty well...\n\t\t * According to the packet driver, the minimum timeout\n\t\t * should be .369 seconds.\n\t\t */\n\t\tfor (i = 0; i < 36900; i++) {\n\t\t\t/* Read the command status */\n\t\t\toff = IE_CMD_COMMON_STATUS(iecmdbuf);\n\t\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\t\tstatus = (sc->ie_bus_read16)(sc, off);\n\t\t\tif (status & mask) {\n#ifdef I82596_DEBUG\n\t\t\t\tif (sc->sc_debug & IED_CMDS)\n\t\t\t\t\tprintf (\"%s: cmd status %b\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\t\tstatus, IE_STAT_BITS);\n#endif\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tdelay(10);\n\t\t}\n\n\t} else {\n\t\t/*\n\t\t * Otherwise, just wait for the command to be accepted.\n\t\t */\n\t\treturn (i82596_cmd_wait(sc));\n\t}\n\n\t/* Timeout */\n\treturn (1);\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\ti82596_cmd_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ti82596_cmd_wait;\n\nint\ni82596_start_cmd(sc, cmd, iecmdbuf, mask, async)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tint iecmdbuf;\n\tint mask;\n\tint async;\n{\n\tregister int i, off;\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_CMDS)\n\t\tprintf(\"start_cmd: %p, %x, %x, %b, %ssync\\n\",\n\t\t       sc, cmd, iecmdbuf, mask, IE_STAT_BITS, async?\"a\":\"\");\n#endif\n\tif (sc->async_cmd_inprogress != 0) {\n\t\t/*\n\t\t * If previous command was issued asynchronously, wait\n\t\t * for it now.\n\t\t */\n\t\tif (i82596_cmd_wait(sc) != 0)\n\t\t\treturn (1);\n\t\tsc->async_cmd_inprogress = 0;\n\t}\n\n\toff = IE_SCB_CMD(sc->scb);\n\t(sc->ie_bus_write16)(sc, off, cmd);\n\tbus_space_barrier(sc->bt, sc->bh, off, 2, BUS_SPACE_BARRIER_WRITE);\n\t(sc->chan_attn)(sc);\n\n\tif (async) {\n\t\tsc->async_cmd_inprogress = 1;\n\t\treturn (0);\n\t}\n\n\tif (IE_ACTION_COMMAND(cmd) && iecmdbuf) {\n\t\tint status;\n\t\t/*\n\t\t * Now spin-lock waiting for status.  This is not a very nice\n\t\t * thing to do, and can kill performance pretty well...\n\t\t * According to the packet driver, the minimum timeout\n\t\t * should be .369 seconds.\n\t\t */\n\t\tfor (i = 0; i < 36900; i++) {\n\t\t\t/* Read the command status */\n\t\t\toff = IE_CMD_COMMON_STATUS(iecmdbuf);\n\t\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\t\tstatus = (sc->ie_bus_read16)(sc, off);\n\t\t\tif (status & mask) {\n#ifdef I82596_DEBUG\n\t\t\t\tif (sc->sc_debug & IED_CMDS)\n\t\t\t\t\tprintf (\"%s: cmd status %b\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\t\tstatus, IE_STAT_BITS);\n#endif\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tdelay(10);\n\t\t}\n\n\t} else {\n\t\t/*\n\t\t * Otherwise, just wait for the command to be accepted.\n\t\t */\n\t\treturn (i82596_cmd_wait(sc));\n\t}\n\n\t/* Timeout */\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_write16",
          "args": [
            "sc",
            "IE_SCB_CMDLST(sc->scb)",
            "IE_CMD_NOP_ADDR(\n\t\t\t\t\tsc->nop_cmds,\n\t\t\t\t\t(sc->xctail + NTXBUF - 1) % NTXBUF)"
          ],
          "line": 1800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_NOP_ADDR",
          "args": [
            "sc->nop_cmds",
            "(sc->xctail + NTXBUF - 1) % NTXBUF"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_SCB_CMDLST",
          "args": [
            "sc->scb"
          ],
          "line": 1800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_write16",
          "args": [
            "sc",
            "IE_SCB_RCVLST(sc->scb)",
            "IE_RFRAME_ADDR(sc->rframes,sc->rfhead)"
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_RFRAME_ADDR",
          "args": [
            "sc->rframes",
            "sc->rfhead"
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_SCB_RCVLST",
          "args": [
            "sc->scb"
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_write16",
          "args": [
            "sc",
            "IE_RFRAME_BUFDESC(sc->rframes,sc->rfhead)",
            "IE_RBD_ADDR(sc->rbds, sc->rbhead)"
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_RBD_ADDR",
          "args": [
            "sc->rbds",
            "sc->rbhead"
          ],
          "line": 1786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_RFRAME_BUFDESC",
          "args": [
            "sc->rframes",
            "sc->rfhead"
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ti82596_start_transceiver;\n\nvoid\ni82596_start_transceiver(sc)\n\tstruct ie_softc *sc;\n{\n\n\t/*\n\t * Start RU at current position in frame & RBD lists.\n\t */\n\tsc->ie_bus_write16(sc, IE_RFRAME_BUFDESC(sc->rframes,sc->rfhead),\n\t\t\t       IE_RBD_ADDR(sc->rbds, sc->rbhead));\n\n\tsc->ie_bus_write16(sc, IE_SCB_RCVLST(sc->scb),\n\t\t\t       IE_RFRAME_ADDR(sc->rframes,sc->rfhead));\n\n\tif (sc->do_xmitnopchain) {\n\t\t/* Stop transmit command chain */\n\t\tif (i82596_start_cmd(sc, IE_CUC_SUSPEND|IE_RUC_SUSPEND, 0, 0, 0))\n\t\t\tprintf(\"%s: CU/RU stop command timed out\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\n\t\t/* Start the receiver & transmitter chain */\n\t\t/* sc->scb->ie_command_list =\n\t\t\tIEADDR(sc->nop_cmds[(sc->xctail+NTXBUF-1) % NTXBUF]);*/\n\t\tsc->ie_bus_write16(sc, IE_SCB_CMDLST(sc->scb),\n\t\t\t\t   IE_CMD_NOP_ADDR(\n\t\t\t\t\tsc->nop_cmds,\n\t\t\t\t\t(sc->xctail + NTXBUF - 1) % NTXBUF));\n\n\t\tif (i82596_start_cmd(sc, IE_CUC_START|IE_RUC_START, 0, 0, 0))\n\t\t\tprintf(\"%s: CU/RU command timed out\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t} else {\n\t\tif (i82596_start_cmd(sc, IE_RUC_START, 0, 0, 0))\n\t\t\tprintf(\"%s: RU command timed out\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t}\n}"
  },
  {
    "function_name": "i82596_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
    "lines": "1717-1772",
    "snippet": "int\ni82596_init(sc)\n\tstruct ie_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint cmd;\n\n\tsc->async_cmd_inprogress = 0;\n\n\tcmd = sc->buf_area;\n\n\t/*\n\t * Send the configure command first.\n\t */\n\tif (ie_cfg_setup(sc, cmd, sc->promisc, 0) == 0)\n\t\treturn (0);\n\n\t/*\n\t * Send the Individual Address Setup command.\n\t */\n\tif (ie_ia_setup(sc, cmd) == 0)\n\t\treturn (0);\n\n\t/*\n\t * Run the time-domain reflectometer.\n\t */\n\tie_run_tdr(sc, cmd);\n\n\t/*\n\t * Set the multi-cast filter, if any\n\t */\n\tif (ie_mc_setup(sc, cmd) == 0)\n\t\treturn (0);\n\n\t/*\n\t * Acknowledge any interrupts we have generated thus far.\n\t */\n\tie_ack(sc, IE_ST_WHENCE);\n\n\t/*\n\t * Set up the transmit and recv buffers.\n\t */\n\ti82596_setup_bufs(sc);\n\n\tif (sc->hwinit)\n\t\t(sc->hwinit)(sc);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tif (NTXBUF < 2)\n\t\tsc->do_xmitnopchain = 0;\n\n\ti82596_start_transceiver(sc);\n\treturn (1);\n}",
    "includes": [
      "#include <dev/ic/i82596var.h>",
      "#include <dev/ic/i82596reg.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\ti82596_init",
      "void\ti82596_start_transceiver",
      "void \ti82596_setup_bufs",
      "int \tie_cfg_setup",
      "int\tie_ia_setup",
      "void \tie_run_tdr",
      "int \tie_mc_setup"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "i82596_start_transceiver",
          "args": [
            "sc"
          ],
          "line": 1770
        },
        "resolved": true,
        "details": {
          "function_name": "i82596_start_transceiver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "1777-1813",
          "snippet": "void\ni82596_start_transceiver(sc)\n\tstruct ie_softc *sc;\n{\n\n\t/*\n\t * Start RU at current position in frame & RBD lists.\n\t */\n\tsc->ie_bus_write16(sc, IE_RFRAME_BUFDESC(sc->rframes,sc->rfhead),\n\t\t\t       IE_RBD_ADDR(sc->rbds, sc->rbhead));\n\n\tsc->ie_bus_write16(sc, IE_SCB_RCVLST(sc->scb),\n\t\t\t       IE_RFRAME_ADDR(sc->rframes,sc->rfhead));\n\n\tif (sc->do_xmitnopchain) {\n\t\t/* Stop transmit command chain */\n\t\tif (i82596_start_cmd(sc, IE_CUC_SUSPEND|IE_RUC_SUSPEND, 0, 0, 0))\n\t\t\tprintf(\"%s: CU/RU stop command timed out\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\n\t\t/* Start the receiver & transmitter chain */\n\t\t/* sc->scb->ie_command_list =\n\t\t\tIEADDR(sc->nop_cmds[(sc->xctail+NTXBUF-1) % NTXBUF]);*/\n\t\tsc->ie_bus_write16(sc, IE_SCB_CMDLST(sc->scb),\n\t\t\t\t   IE_CMD_NOP_ADDR(\n\t\t\t\t\tsc->nop_cmds,\n\t\t\t\t\t(sc->xctail + NTXBUF - 1) % NTXBUF));\n\n\t\tif (i82596_start_cmd(sc, IE_CUC_START|IE_RUC_START, 0, 0, 0))\n\t\t\tprintf(\"%s: CU/RU command timed out\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t} else {\n\t\tif (i82596_start_cmd(sc, IE_RUC_START, 0, 0, 0))\n\t\t\tprintf(\"%s: RU command timed out\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t}\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\ti82596_start_transceiver"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ti82596_start_transceiver;\n\nvoid\ni82596_start_transceiver(sc)\n\tstruct ie_softc *sc;\n{\n\n\t/*\n\t * Start RU at current position in frame & RBD lists.\n\t */\n\tsc->ie_bus_write16(sc, IE_RFRAME_BUFDESC(sc->rframes,sc->rfhead),\n\t\t\t       IE_RBD_ADDR(sc->rbds, sc->rbhead));\n\n\tsc->ie_bus_write16(sc, IE_SCB_RCVLST(sc->scb),\n\t\t\t       IE_RFRAME_ADDR(sc->rframes,sc->rfhead));\n\n\tif (sc->do_xmitnopchain) {\n\t\t/* Stop transmit command chain */\n\t\tif (i82596_start_cmd(sc, IE_CUC_SUSPEND|IE_RUC_SUSPEND, 0, 0, 0))\n\t\t\tprintf(\"%s: CU/RU stop command timed out\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\n\t\t/* Start the receiver & transmitter chain */\n\t\t/* sc->scb->ie_command_list =\n\t\t\tIEADDR(sc->nop_cmds[(sc->xctail+NTXBUF-1) % NTXBUF]);*/\n\t\tsc->ie_bus_write16(sc, IE_SCB_CMDLST(sc->scb),\n\t\t\t\t   IE_CMD_NOP_ADDR(\n\t\t\t\t\tsc->nop_cmds,\n\t\t\t\t\t(sc->xctail + NTXBUF - 1) % NTXBUF));\n\n\t\tif (i82596_start_cmd(sc, IE_CUC_START|IE_RUC_START, 0, 0, 0))\n\t\t\tprintf(\"%s: CU/RU command timed out\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t} else {\n\t\tif (i82596_start_cmd(sc, IE_RUC_START, 0, 0, 0))\n\t\t\tprintf(\"%s: RU command timed out\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc"
          ],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i82596_setup_bufs",
          "args": [
            "sc"
          ],
          "line": 1759
        },
        "resolved": true,
        "details": {
          "function_name": "i82596_setup_bufs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "1441-1592",
          "snippet": "void\ni82596_setup_bufs(sc)\n\tstruct ie_softc *sc;\n{\n\tregister int n, r, ptr = sc->buf_area;\t/* memory pool */\n\n\t/*\n\t * step 0: zero memory and figure out how many recv buffers and\n\t * frames we can have.\n\t */\n\tptr = (ptr + 3) & ~3;\t/* set alignment and stick with it */\n\n\n\t/*\n\t *  step 1: lay out data structures in the shared-memory area\n\t */\n\n\t/* The no-op commands; used if \"nop-chaining\" is in effect */\n\tsc->nop_cmds = ptr;\n\tptr += NTXBUF * IE_CMD_NOP_SZ;\n\n\t/* The transmit commands */\n\tsc->xmit_cmds = ptr;\n\tptr += NTXBUF * IE_CMD_XMIT_SZ;\n\n\t/* The transmit buffers descriptors */\n\tsc->xbds = ptr;\n\tptr += NTXBUF * IE_XBD_SZ;\n\n\t/* The transmit buffers */\n\tsc->xbufs = ptr;\n\tptr += NTXBUF * IE_TBUF_SIZE;\n\n\tptr = (ptr + 3) & ~3;\t\t/* re-align.. just in case */\n\n\t/* Compute free space for RECV stuff */\n\tn = sc->buf_area_sz - (ptr - sc->buf_area);\n\n\t/* Compute size of one RECV frame */\n\tr = IE_RFRAME_SZ + ((IE_RBD_SZ + IE_RBUF_SIZE) * B_PER_F);\n\n\tsc->nframes = n / r;\n\n\tif (sc->nframes <= 0)\n\t\tpanic(\"ie: bogus buffer calc\\n\");\n\n\tsc->nrxbuf = sc->nframes * B_PER_F;\n\n\t/* The receice frame descriptors */\n\tsc->rframes = ptr;\n\tptr += sc->nframes * IE_RFRAME_SZ;\n\n\t/* The receive buffer descriptors */\n\tsc->rbds = ptr;\n\tptr += sc->nrxbuf * IE_RBD_SZ;\n\n\t/* The receive buffers */\n\tsc->rbufs = ptr;\n\tptr += sc->nrxbuf * IE_RBUF_SIZE;\n\n#ifdef I82596_DEBUG\n\tprintf(\"%s: %d frames %d bufs\\n\", sc->sc_dev.dv_xname, sc->nframes,\n\t\tsc->nrxbuf);\n#endif\n\n\t/*\n\t * step 2: link together the recv frames and set EOL on last one\n\t */\n\tfor (n = 0; n < sc->nframes; n++) {\n\t\tint m = (n == sc->nframes - 1) ? 0 : n + 1;\n\n\t\t/* Clear status */\n\t\tsc->ie_bus_write16(sc, IE_RFRAME_STATUS(sc->rframes,n), 0);\n\n\t\t/* RBD link = NULL */\n\t\tsc->ie_bus_write16(sc, IE_RFRAME_BUFDESC(sc->rframes,n),\n\t\t\t\t       0xffff);\n\n\t\t/* Make a circular list */\n\t\tsc->ie_bus_write16(sc, IE_RFRAME_NEXT(sc->rframes,n),\n\t\t\t\t       IE_RFRAME_ADDR(sc->rframes,m));\n\n\t\t/* Mark last as EOL */\n\t\tsc->ie_bus_write16(sc, IE_RFRAME_LAST(sc->rframes,n),\n\t\t\t\t       ((m==0)? (IE_FD_EOL|IE_FD_SUSP) : 0));\n\t}\n\n\t/*\n\t * step 3: link the RBDs and set EOL on last one\n\t */\n\tfor (n = 0; n < sc->nrxbuf; n++) {\n\t\tint m = (n == sc->nrxbuf - 1) ? 0 : n + 1;\n\n\t\t/* Clear status */\n\t\tsc->ie_bus_write16(sc, IE_RBD_STATUS(sc->rbds,n), 0);\n\n\t\t/* Make a circular list */\n\t\tsc->ie_bus_write16(sc, IE_RBD_NEXT(sc->rbds,n),\n\t\t\t\t       IE_RBD_ADDR(sc->rbds,m));\n\n\t\t/* Link to data buffers */\n\t\tsc->ie_bus_write24(sc, IE_RBD_BUFADDR(sc->rbds, n),\n\t\t\t\t       sc->sc_maddr + IE_RBUF_ADDR(sc, n));\n\t\tsc->ie_bus_write16(sc, IE_RBD_BUFLEN(sc->rbds,n),\n\t\t\t\t       IE_RBUF_SIZE | ((m==0)?IE_RBD_EOL:0));\n\t}\n\n\t/*\n\t * step 4: all xmit no-op commands loopback onto themselves\n\t */\n\tfor (n = 0; n < NTXBUF; n++) {\n\t\t(sc->ie_bus_write16)(sc, IE_CMD_NOP_STATUS(sc->nop_cmds, n), 0);\n\n\t\t(sc->ie_bus_write16)(sc, IE_CMD_NOP_CMD(sc->nop_cmds, n),\n\t\t\t\t\t IE_CMD_NOP);\n\n\t\t(sc->ie_bus_write16)(sc, IE_CMD_NOP_LINK(sc->nop_cmds, n),\n\t\t\t\t\t IE_CMD_NOP_ADDR(sc->nop_cmds, n));\n\t}\n\n\n\t/*\n\t * step 6: set the head and tail pointers on receive to keep track of\n\t * the order in which RFDs and RBDs are used.\n\t */\n\n\t/* Pointers to last packet sent and next available transmit buffer. */\n\tsc->xchead = sc->xctail = 0;\n\n\t/* Clear transmit-busy flag and set number of free transmit buffers. */\n\tsc->xmit_busy = 0;\n\n\t/*\n\t * Pointers to first and last receive frame.\n\t * The RFD pointed to by rftail is the only one that has EOL set.\n\t */\n\tsc->rfhead = 0;\n\tsc->rftail = sc->nframes - 1;\n\n\t/*\n\t * Pointers to first and last receive descriptor buffer.\n\t * The RBD pointed to by rbtail is the only one that has EOL set.\n\t */\n\tsc->rbhead = 0;\n\tsc->rbtail = sc->nrxbuf - 1;\n\n/* link in recv frames * and buffer into the scb. */\n#ifdef I82596_DEBUG\n\tprintf(\"%s: reserved %d bytes\\n\",\n\t\tsc->sc_dev.dv_xname, ptr - sc->buf_area);\n#endif\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void \ti82596_setup_bufs"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid \ti82596_setup_bufs;\n\nvoid\ni82596_setup_bufs(sc)\n\tstruct ie_softc *sc;\n{\n\tregister int n, r, ptr = sc->buf_area;\t/* memory pool */\n\n\t/*\n\t * step 0: zero memory and figure out how many recv buffers and\n\t * frames we can have.\n\t */\n\tptr = (ptr + 3) & ~3;\t/* set alignment and stick with it */\n\n\n\t/*\n\t *  step 1: lay out data structures in the shared-memory area\n\t */\n\n\t/* The no-op commands; used if \"nop-chaining\" is in effect */\n\tsc->nop_cmds = ptr;\n\tptr += NTXBUF * IE_CMD_NOP_SZ;\n\n\t/* The transmit commands */\n\tsc->xmit_cmds = ptr;\n\tptr += NTXBUF * IE_CMD_XMIT_SZ;\n\n\t/* The transmit buffers descriptors */\n\tsc->xbds = ptr;\n\tptr += NTXBUF * IE_XBD_SZ;\n\n\t/* The transmit buffers */\n\tsc->xbufs = ptr;\n\tptr += NTXBUF * IE_TBUF_SIZE;\n\n\tptr = (ptr + 3) & ~3;\t\t/* re-align.. just in case */\n\n\t/* Compute free space for RECV stuff */\n\tn = sc->buf_area_sz - (ptr - sc->buf_area);\n\n\t/* Compute size of one RECV frame */\n\tr = IE_RFRAME_SZ + ((IE_RBD_SZ + IE_RBUF_SIZE) * B_PER_F);\n\n\tsc->nframes = n / r;\n\n\tif (sc->nframes <= 0)\n\t\tpanic(\"ie: bogus buffer calc\\n\");\n\n\tsc->nrxbuf = sc->nframes * B_PER_F;\n\n\t/* The receice frame descriptors */\n\tsc->rframes = ptr;\n\tptr += sc->nframes * IE_RFRAME_SZ;\n\n\t/* The receive buffer descriptors */\n\tsc->rbds = ptr;\n\tptr += sc->nrxbuf * IE_RBD_SZ;\n\n\t/* The receive buffers */\n\tsc->rbufs = ptr;\n\tptr += sc->nrxbuf * IE_RBUF_SIZE;\n\n#ifdef I82596_DEBUG\n\tprintf(\"%s: %d frames %d bufs\\n\", sc->sc_dev.dv_xname, sc->nframes,\n\t\tsc->nrxbuf);\n#endif\n\n\t/*\n\t * step 2: link together the recv frames and set EOL on last one\n\t */\n\tfor (n = 0; n < sc->nframes; n++) {\n\t\tint m = (n == sc->nframes - 1) ? 0 : n + 1;\n\n\t\t/* Clear status */\n\t\tsc->ie_bus_write16(sc, IE_RFRAME_STATUS(sc->rframes,n), 0);\n\n\t\t/* RBD link = NULL */\n\t\tsc->ie_bus_write16(sc, IE_RFRAME_BUFDESC(sc->rframes,n),\n\t\t\t\t       0xffff);\n\n\t\t/* Make a circular list */\n\t\tsc->ie_bus_write16(sc, IE_RFRAME_NEXT(sc->rframes,n),\n\t\t\t\t       IE_RFRAME_ADDR(sc->rframes,m));\n\n\t\t/* Mark last as EOL */\n\t\tsc->ie_bus_write16(sc, IE_RFRAME_LAST(sc->rframes,n),\n\t\t\t\t       ((m==0)? (IE_FD_EOL|IE_FD_SUSP) : 0));\n\t}\n\n\t/*\n\t * step 3: link the RBDs and set EOL on last one\n\t */\n\tfor (n = 0; n < sc->nrxbuf; n++) {\n\t\tint m = (n == sc->nrxbuf - 1) ? 0 : n + 1;\n\n\t\t/* Clear status */\n\t\tsc->ie_bus_write16(sc, IE_RBD_STATUS(sc->rbds,n), 0);\n\n\t\t/* Make a circular list */\n\t\tsc->ie_bus_write16(sc, IE_RBD_NEXT(sc->rbds,n),\n\t\t\t\t       IE_RBD_ADDR(sc->rbds,m));\n\n\t\t/* Link to data buffers */\n\t\tsc->ie_bus_write24(sc, IE_RBD_BUFADDR(sc->rbds, n),\n\t\t\t\t       sc->sc_maddr + IE_RBUF_ADDR(sc, n));\n\t\tsc->ie_bus_write16(sc, IE_RBD_BUFLEN(sc->rbds,n),\n\t\t\t\t       IE_RBUF_SIZE | ((m==0)?IE_RBD_EOL:0));\n\t}\n\n\t/*\n\t * step 4: all xmit no-op commands loopback onto themselves\n\t */\n\tfor (n = 0; n < NTXBUF; n++) {\n\t\t(sc->ie_bus_write16)(sc, IE_CMD_NOP_STATUS(sc->nop_cmds, n), 0);\n\n\t\t(sc->ie_bus_write16)(sc, IE_CMD_NOP_CMD(sc->nop_cmds, n),\n\t\t\t\t\t IE_CMD_NOP);\n\n\t\t(sc->ie_bus_write16)(sc, IE_CMD_NOP_LINK(sc->nop_cmds, n),\n\t\t\t\t\t IE_CMD_NOP_ADDR(sc->nop_cmds, n));\n\t}\n\n\n\t/*\n\t * step 6: set the head and tail pointers on receive to keep track of\n\t * the order in which RFDs and RBDs are used.\n\t */\n\n\t/* Pointers to last packet sent and next available transmit buffer. */\n\tsc->xchead = sc->xctail = 0;\n\n\t/* Clear transmit-busy flag and set number of free transmit buffers. */\n\tsc->xmit_busy = 0;\n\n\t/*\n\t * Pointers to first and last receive frame.\n\t * The RFD pointed to by rftail is the only one that has EOL set.\n\t */\n\tsc->rfhead = 0;\n\tsc->rftail = sc->nframes - 1;\n\n\t/*\n\t * Pointers to first and last receive descriptor buffer.\n\t * The RBD pointed to by rbtail is the only one that has EOL set.\n\t */\n\tsc->rbhead = 0;\n\tsc->rbtail = sc->nrxbuf - 1;\n\n/* link in recv frames * and buffer into the scb. */\n#ifdef I82596_DEBUG\n\tprintf(\"%s: reserved %d bytes\\n\",\n\t\tsc->sc_dev.dv_xname, ptr - sc->buf_area);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ie_ack",
          "args": [
            "sc",
            "IE_ST_WHENCE"
          ],
          "line": 1754
        },
        "resolved": true,
        "details": {
          "function_name": "ie_ack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596var.h",
          "lines": "297-305",
          "snippet": "static __inline__ void\nie_ack(struct ie_softc *sc, u_int mask) /* in native byte-order */\n{\n\tregister u_int status;\n\n\tbus_space_barrier(sc->bt, sc->bh, 0, 0, BUS_SPACE_BARRIER_READ);\n\tstatus = (sc->ie_bus_read16)(sc, IE_SCB_STATUS(sc->scb));\n\ti82596_start_cmd(sc, status & mask, 0, 0, 0);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "int \ti82596_start_cmd"
          ],
          "called_functions": [],
          "contextual_snippet": "int \ti82596_start_cmd;\n\nstatic __inline__ void\nie_ack(struct ie_softc *sc, u_int mask) /* in native byte-order */\n{\n\tregister u_int status;\n\n\tbus_space_barrier(sc->bt, sc->bh, 0, 0, BUS_SPACE_BARRIER_READ);\n\tstatus = (sc->ie_bus_read16)(sc, IE_SCB_STATUS(sc->scb));\n\ti82596_start_cmd(sc, status & mask, 0, 0, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ie_mc_setup",
          "args": [
            "sc",
            "cmd"
          ],
          "line": 1748
        },
        "resolved": true,
        "details": {
          "function_name": "ie_mc_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "1671-1707",
          "snippet": "int\nie_mc_setup(sc, cmdbuf)\n\tstruct ie_softc *sc;\n\tint cmdbuf;\n{\n\tint cmdresult, status;\n\n\tif (sc->mcast_count == 0)\n\t\treturn (1);\n\n\ti82596_simple_command(sc, IE_CMD_MCAST, cmdbuf);\n\n\t(sc->memcopyout)(sc, (caddr_t)sc->mcast_addrs,\n\t\t\t IE_CMD_MCAST_MADDR(cmdbuf),\n\t\t\t sc->mcast_count * ETHER_ADDR_LEN);\n\n\tsc->ie_bus_write16(sc, IE_CMD_MCAST_BYTES(cmdbuf),\n\t\t\t       sc->mcast_count * ETHER_ADDR_LEN);\n\n\t/* Start the command */\n\tcmdresult = i82596_start_cmd(sc, IE_CUC_START, cmdbuf, IE_STAT_COMPL, 0);\n\tstatus = sc->ie_bus_read16(sc, IE_CMD_COMMON_STATUS(cmdbuf));\n\tif (cmdresult != 0) {\n\t\tprintf(\"%s: multicast setup command timed out; status %b\\n\",\n\t\t\tsc->sc_dev.dv_xname, status, IE_STAT_BITS);\n\t\treturn (0);\n\t}\n\tif ((status & IE_STAT_OK) == 0) {\n\t\tprintf(\"%s: multicast setup command failed; status %b\\n\",\n\t\t\tsc->sc_dev.dv_xname, status, IE_STAT_BITS);\n\t\treturn (0);\n\t}\n\n\t/* Squash any pending interrupts */\n\tie_ack(sc, IE_ST_WHENCE);\n\treturn (1);\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\ti82596_simple_command",
            "int \tie_mc_setup"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ti82596_simple_command;\nint \tie_mc_setup;\n\nint\nie_mc_setup(sc, cmdbuf)\n\tstruct ie_softc *sc;\n\tint cmdbuf;\n{\n\tint cmdresult, status;\n\n\tif (sc->mcast_count == 0)\n\t\treturn (1);\n\n\ti82596_simple_command(sc, IE_CMD_MCAST, cmdbuf);\n\n\t(sc->memcopyout)(sc, (caddr_t)sc->mcast_addrs,\n\t\t\t IE_CMD_MCAST_MADDR(cmdbuf),\n\t\t\t sc->mcast_count * ETHER_ADDR_LEN);\n\n\tsc->ie_bus_write16(sc, IE_CMD_MCAST_BYTES(cmdbuf),\n\t\t\t       sc->mcast_count * ETHER_ADDR_LEN);\n\n\t/* Start the command */\n\tcmdresult = i82596_start_cmd(sc, IE_CUC_START, cmdbuf, IE_STAT_COMPL, 0);\n\tstatus = sc->ie_bus_read16(sc, IE_CMD_COMMON_STATUS(cmdbuf));\n\tif (cmdresult != 0) {\n\t\tprintf(\"%s: multicast setup command timed out; status %b\\n\",\n\t\t\tsc->sc_dev.dv_xname, status, IE_STAT_BITS);\n\t\treturn (0);\n\t}\n\tif ((status & IE_STAT_OK) == 0) {\n\t\tprintf(\"%s: multicast setup command failed; status %b\\n\",\n\t\t\tsc->sc_dev.dv_xname, status, IE_STAT_BITS);\n\t\treturn (0);\n\t}\n\n\t/* Squash any pending interrupts */\n\tie_ack(sc, IE_ST_WHENCE);\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ie_run_tdr",
          "args": [
            "sc",
            "cmd"
          ],
          "line": 1743
        },
        "resolved": true,
        "details": {
          "function_name": "ie_run_tdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "1392-1427",
          "snippet": "void\nie_run_tdr(sc, cmd)\n\tstruct ie_softc *sc;\n\tint cmd;\n{\n\tint result;\n\n\ti82596_simple_command(sc, IE_CMD_TDR, cmd);\n\t(sc->ie_bus_write16)(sc, IE_CMD_TDR_TIME(cmd), 0);\n\n\tif (i82596_start_cmd(sc, IE_CUC_START, cmd, IE_STAT_COMPL, 0) ||\n\t    !(sc->ie_bus_read16(sc, IE_CMD_COMMON_STATUS(cmd)) & IE_STAT_OK))\n\t\tresult = 0x10000; /* XXX */\n\telse\n\t\tresult = sc->ie_bus_read16(sc, IE_CMD_TDR_TIME(cmd));\n\n\t/* Squash any pending interrupts */\n\tie_ack(sc, IE_ST_WHENCE);\n\n\tif (result & IE_TDR_SUCCESS)\n\t\treturn;\n\n\tif (result & 0x10000)\n\t\tprintf(\"%s: TDR command failed\\n\", sc->sc_dev.dv_xname);\n\telse if (result & IE_TDR_XCVR)\n\t\tprintf(\"%s: transceiver problem\\n\", sc->sc_dev.dv_xname);\n\telse if (result & IE_TDR_OPEN)\n\t\tprintf(\"%s: TDR detected an open %d clocks away\\n\",\n\t\t\tsc->sc_dev.dv_xname, result & IE_TDR_TIME);\n\telse if (result & IE_TDR_SHORT)\n\t\tprintf(\"%s: TDR detected a short %d clocks away\\n\",\n\t\t\tsc->sc_dev.dv_xname, result & IE_TDR_TIME);\n\telse\n\t\tprintf(\"%s: TDR returned unknown status 0x%x\\n\",\n\t\t\tsc->sc_dev.dv_xname, result);\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\ti82596_simple_command",
            "void \tie_run_tdr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ti82596_simple_command;\nvoid \tie_run_tdr;\n\nvoid\nie_run_tdr(sc, cmd)\n\tstruct ie_softc *sc;\n\tint cmd;\n{\n\tint result;\n\n\ti82596_simple_command(sc, IE_CMD_TDR, cmd);\n\t(sc->ie_bus_write16)(sc, IE_CMD_TDR_TIME(cmd), 0);\n\n\tif (i82596_start_cmd(sc, IE_CUC_START, cmd, IE_STAT_COMPL, 0) ||\n\t    !(sc->ie_bus_read16(sc, IE_CMD_COMMON_STATUS(cmd)) & IE_STAT_OK))\n\t\tresult = 0x10000; /* XXX */\n\telse\n\t\tresult = sc->ie_bus_read16(sc, IE_CMD_TDR_TIME(cmd));\n\n\t/* Squash any pending interrupts */\n\tie_ack(sc, IE_ST_WHENCE);\n\n\tif (result & IE_TDR_SUCCESS)\n\t\treturn;\n\n\tif (result & 0x10000)\n\t\tprintf(\"%s: TDR command failed\\n\", sc->sc_dev.dv_xname);\n\telse if (result & IE_TDR_XCVR)\n\t\tprintf(\"%s: transceiver problem\\n\", sc->sc_dev.dv_xname);\n\telse if (result & IE_TDR_OPEN)\n\t\tprintf(\"%s: TDR detected an open %d clocks away\\n\",\n\t\t\tsc->sc_dev.dv_xname, result & IE_TDR_TIME);\n\telse if (result & IE_TDR_SHORT)\n\t\tprintf(\"%s: TDR detected a short %d clocks away\\n\",\n\t\t\tsc->sc_dev.dv_xname, result & IE_TDR_TIME);\n\telse\n\t\tprintf(\"%s: TDR returned unknown status 0x%x\\n\",\n\t\t\tsc->sc_dev.dv_xname, result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ie_ia_setup",
          "args": [
            "sc",
            "cmd"
          ],
          "line": 1737
        },
        "resolved": true,
        "details": {
          "function_name": "ie_ia_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "1637-1665",
          "snippet": "int\nie_ia_setup(sc, cmdbuf)\n\tstruct ie_softc *sc;\n\tint cmdbuf;\n{\n\tint cmdresult, status;\n\n\ti82596_simple_command(sc, IE_CMD_IASETUP, cmdbuf);\n\n\t(sc->memcopyout)(sc, sc->sc_arpcom.ac_enaddr,\n\t\t\t IE_CMD_IAS_EADDR(cmdbuf), ETHER_ADDR_LEN);\n\n\tcmdresult = i82596_start_cmd(sc, IE_CUC_START, cmdbuf, IE_STAT_COMPL, 0);\n\tstatus = sc->ie_bus_read16(sc, IE_CMD_COMMON_STATUS(cmdbuf));\n\tif (cmdresult != 0) {\n\t\tprintf(\"%s: individual address command timed out; status %b\\n\",\n\t\t\tsc->sc_dev.dv_xname, status, IE_STAT_BITS);\n\t\treturn (0);\n\t}\n\tif ((status & IE_STAT_OK) == 0) {\n\t\tprintf(\"%s: individual address command failed; status %b\\n\",\n\t\t\tsc->sc_dev.dv_xname, status, IE_STAT_BITS);\n\t\treturn (0);\n\t}\n\n\t/* Squash any pending interrupts */\n\tie_ack(sc, IE_ST_WHENCE);\n\treturn (1);\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\ti82596_simple_command",
            "int\tie_ia_setup"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ti82596_simple_command;\nint\tie_ia_setup;\n\nint\nie_ia_setup(sc, cmdbuf)\n\tstruct ie_softc *sc;\n\tint cmdbuf;\n{\n\tint cmdresult, status;\n\n\ti82596_simple_command(sc, IE_CMD_IASETUP, cmdbuf);\n\n\t(sc->memcopyout)(sc, sc->sc_arpcom.ac_enaddr,\n\t\t\t IE_CMD_IAS_EADDR(cmdbuf), ETHER_ADDR_LEN);\n\n\tcmdresult = i82596_start_cmd(sc, IE_CUC_START, cmdbuf, IE_STAT_COMPL, 0);\n\tstatus = sc->ie_bus_read16(sc, IE_CMD_COMMON_STATUS(cmdbuf));\n\tif (cmdresult != 0) {\n\t\tprintf(\"%s: individual address command timed out; status %b\\n\",\n\t\t\tsc->sc_dev.dv_xname, status, IE_STAT_BITS);\n\t\treturn (0);\n\t}\n\tif ((status & IE_STAT_OK) == 0) {\n\t\tprintf(\"%s: individual address command failed; status %b\\n\",\n\t\t\tsc->sc_dev.dv_xname, status, IE_STAT_BITS);\n\t\treturn (0);\n\t}\n\n\t/* Squash any pending interrupts */\n\tie_ack(sc, IE_ST_WHENCE);\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ie_cfg_setup",
          "args": [
            "sc",
            "cmd",
            "sc->promisc",
            "0"
          ],
          "line": 1731
        },
        "resolved": true,
        "details": {
          "function_name": "ie_cfg_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "1594-1635",
          "snippet": "int\nie_cfg_setup(sc, cmd, promiscuous, manchester)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tint promiscuous, manchester;\n{\n\tint cmdresult, status;\n\n\ti82596_simple_command(sc, IE_CMD_CONFIG, cmd);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_CNT(cmd), 0x0c);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_FIFO(cmd), 8);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_SAVEBAD(cmd), 0x40);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_ADDRLEN(cmd), 0x2e);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_PRIORITY(cmd), 0);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_IFS(cmd), 0x60);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_SLOT_LOW(cmd), 0);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_SLOT_HIGH(cmd), 0xf2);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_PROMISC(cmd),\n\t\t\t\t\t  !!promiscuous | manchester << 2);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_CRSCDT(cmd), 0);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_MINLEN(cmd), 64);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_JUNK(cmd), 0xff);\n\tbus_space_barrier(sc->bt, sc->bh, cmd, IE_CMD_CFG_SZ,\n\t\t\t  BUS_SPACE_BARRIER_WRITE);\n\n\tcmdresult = i82596_start_cmd(sc, IE_CUC_START, cmd, IE_STAT_COMPL, 0);\n\tstatus = sc->ie_bus_read16(sc, IE_CMD_COMMON_STATUS(cmd));\n\tif (cmdresult != 0) {\n\t\tprintf(\"%s: configure command timed out; status %b\\n\",\n\t\t\tsc->sc_dev.dv_xname, status, IE_STAT_BITS);\n\t\treturn (0);\n\t}\n\tif ((status & IE_STAT_OK) == 0) {\n\t\tprintf(\"%s: configure command failed; status %b\\n\",\n\t\t\tsc->sc_dev.dv_xname, status, IE_STAT_BITS);\n\t\treturn (0);\n\t}\n\n\t/* Squash any pending interrupts */\n\tie_ack(sc, IE_ST_WHENCE);\n\treturn (1);\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\ti82596_simple_command",
            "int \tie_cfg_setup"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ti82596_simple_command;\nint \tie_cfg_setup;\n\nint\nie_cfg_setup(sc, cmd, promiscuous, manchester)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tint promiscuous, manchester;\n{\n\tint cmdresult, status;\n\n\ti82596_simple_command(sc, IE_CMD_CONFIG, cmd);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_CNT(cmd), 0x0c);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_FIFO(cmd), 8);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_SAVEBAD(cmd), 0x40);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_ADDRLEN(cmd), 0x2e);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_PRIORITY(cmd), 0);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_IFS(cmd), 0x60);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_SLOT_LOW(cmd), 0);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_SLOT_HIGH(cmd), 0xf2);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_PROMISC(cmd),\n\t\t\t\t\t  !!promiscuous | manchester << 2);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_CRSCDT(cmd), 0);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_MINLEN(cmd), 64);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_JUNK(cmd), 0xff);\n\tbus_space_barrier(sc->bt, sc->bh, cmd, IE_CMD_CFG_SZ,\n\t\t\t  BUS_SPACE_BARRIER_WRITE);\n\n\tcmdresult = i82596_start_cmd(sc, IE_CUC_START, cmd, IE_STAT_COMPL, 0);\n\tstatus = sc->ie_bus_read16(sc, IE_CMD_COMMON_STATUS(cmd));\n\tif (cmdresult != 0) {\n\t\tprintf(\"%s: configure command timed out; status %b\\n\",\n\t\t\tsc->sc_dev.dv_xname, status, IE_STAT_BITS);\n\t\treturn (0);\n\t}\n\tif ((status & IE_STAT_OK) == 0) {\n\t\tprintf(\"%s: configure command failed; status %b\\n\",\n\t\t\tsc->sc_dev.dv_xname, status, IE_STAT_BITS);\n\t\treturn (0);\n\t}\n\n\t/* Squash any pending interrupts */\n\tie_ack(sc, IE_ST_WHENCE);\n\treturn (1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ti82596_init;\nvoid\ti82596_start_transceiver;\nvoid \ti82596_setup_bufs;\nint \tie_cfg_setup;\nint\tie_ia_setup;\nvoid \tie_run_tdr;\nint \tie_mc_setup;\n\nint\ni82596_init(sc)\n\tstruct ie_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint cmd;\n\n\tsc->async_cmd_inprogress = 0;\n\n\tcmd = sc->buf_area;\n\n\t/*\n\t * Send the configure command first.\n\t */\n\tif (ie_cfg_setup(sc, cmd, sc->promisc, 0) == 0)\n\t\treturn (0);\n\n\t/*\n\t * Send the Individual Address Setup command.\n\t */\n\tif (ie_ia_setup(sc, cmd) == 0)\n\t\treturn (0);\n\n\t/*\n\t * Run the time-domain reflectometer.\n\t */\n\tie_run_tdr(sc, cmd);\n\n\t/*\n\t * Set the multi-cast filter, if any\n\t */\n\tif (ie_mc_setup(sc, cmd) == 0)\n\t\treturn (0);\n\n\t/*\n\t * Acknowledge any interrupts we have generated thus far.\n\t */\n\tie_ack(sc, IE_ST_WHENCE);\n\n\t/*\n\t * Set up the transmit and recv buffers.\n\t */\n\ti82596_setup_bufs(sc);\n\n\tif (sc->hwinit)\n\t\t(sc->hwinit)(sc);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tif (NTXBUF < 2)\n\t\tsc->do_xmitnopchain = 0;\n\n\ti82596_start_transceiver(sc);\n\treturn (1);\n}"
  },
  {
    "function_name": "ie_mc_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
    "lines": "1671-1707",
    "snippet": "int\nie_mc_setup(sc, cmdbuf)\n\tstruct ie_softc *sc;\n\tint cmdbuf;\n{\n\tint cmdresult, status;\n\n\tif (sc->mcast_count == 0)\n\t\treturn (1);\n\n\ti82596_simple_command(sc, IE_CMD_MCAST, cmdbuf);\n\n\t(sc->memcopyout)(sc, (caddr_t)sc->mcast_addrs,\n\t\t\t IE_CMD_MCAST_MADDR(cmdbuf),\n\t\t\t sc->mcast_count * ETHER_ADDR_LEN);\n\n\tsc->ie_bus_write16(sc, IE_CMD_MCAST_BYTES(cmdbuf),\n\t\t\t       sc->mcast_count * ETHER_ADDR_LEN);\n\n\t/* Start the command */\n\tcmdresult = i82596_start_cmd(sc, IE_CUC_START, cmdbuf, IE_STAT_COMPL, 0);\n\tstatus = sc->ie_bus_read16(sc, IE_CMD_COMMON_STATUS(cmdbuf));\n\tif (cmdresult != 0) {\n\t\tprintf(\"%s: multicast setup command timed out; status %b\\n\",\n\t\t\tsc->sc_dev.dv_xname, status, IE_STAT_BITS);\n\t\treturn (0);\n\t}\n\tif ((status & IE_STAT_OK) == 0) {\n\t\tprintf(\"%s: multicast setup command failed; status %b\\n\",\n\t\t\tsc->sc_dev.dv_xname, status, IE_STAT_BITS);\n\t\treturn (0);\n\t}\n\n\t/* Squash any pending interrupts */\n\tie_ack(sc, IE_ST_WHENCE);\n\treturn (1);\n}",
    "includes": [
      "#include <dev/ic/i82596var.h>",
      "#include <dev/ic/i82596reg.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\ti82596_simple_command",
      "int \tie_mc_setup"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ie_ack",
          "args": [
            "sc",
            "IE_ST_WHENCE"
          ],
          "line": 1705
        },
        "resolved": true,
        "details": {
          "function_name": "ie_ack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596var.h",
          "lines": "297-305",
          "snippet": "static __inline__ void\nie_ack(struct ie_softc *sc, u_int mask) /* in native byte-order */\n{\n\tregister u_int status;\n\n\tbus_space_barrier(sc->bt, sc->bh, 0, 0, BUS_SPACE_BARRIER_READ);\n\tstatus = (sc->ie_bus_read16)(sc, IE_SCB_STATUS(sc->scb));\n\ti82596_start_cmd(sc, status & mask, 0, 0, 0);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "int \ti82596_start_cmd"
          ],
          "called_functions": [],
          "contextual_snippet": "int \ti82596_start_cmd;\n\nstatic __inline__ void\nie_ack(struct ie_softc *sc, u_int mask) /* in native byte-order */\n{\n\tregister u_int status;\n\n\tbus_space_barrier(sc->bt, sc->bh, 0, 0, BUS_SPACE_BARRIER_READ);\n\tstatus = (sc->ie_bus_read16)(sc, IE_SCB_STATUS(sc->scb));\n\ti82596_start_cmd(sc, status & mask, 0, 0, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: multicast setup command failed; status %b\\n\"",
            "sc->sc_dev.dv_xname",
            "status",
            "IE_STAT_BITS"
          ],
          "line": 1699
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_read16",
          "args": [
            "sc",
            "IE_CMD_COMMON_STATUS(cmdbuf)"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_COMMON_STATUS",
          "args": [
            "cmdbuf"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i82596_start_cmd",
          "args": [
            "sc",
            "IE_CUC_START",
            "cmdbuf",
            "IE_STAT_COMPL",
            "0"
          ],
          "line": 1691
        },
        "resolved": true,
        "details": {
          "function_name": "i82596_start_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "398-468",
          "snippet": "int\ni82596_start_cmd(sc, cmd, iecmdbuf, mask, async)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tint iecmdbuf;\n\tint mask;\n\tint async;\n{\n\tregister int i, off;\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_CMDS)\n\t\tprintf(\"start_cmd: %p, %x, %x, %b, %ssync\\n\",\n\t\t       sc, cmd, iecmdbuf, mask, IE_STAT_BITS, async?\"a\":\"\");\n#endif\n\tif (sc->async_cmd_inprogress != 0) {\n\t\t/*\n\t\t * If previous command was issued asynchronously, wait\n\t\t * for it now.\n\t\t */\n\t\tif (i82596_cmd_wait(sc) != 0)\n\t\t\treturn (1);\n\t\tsc->async_cmd_inprogress = 0;\n\t}\n\n\toff = IE_SCB_CMD(sc->scb);\n\t(sc->ie_bus_write16)(sc, off, cmd);\n\tbus_space_barrier(sc->bt, sc->bh, off, 2, BUS_SPACE_BARRIER_WRITE);\n\t(sc->chan_attn)(sc);\n\n\tif (async) {\n\t\tsc->async_cmd_inprogress = 1;\n\t\treturn (0);\n\t}\n\n\tif (IE_ACTION_COMMAND(cmd) && iecmdbuf) {\n\t\tint status;\n\t\t/*\n\t\t * Now spin-lock waiting for status.  This is not a very nice\n\t\t * thing to do, and can kill performance pretty well...\n\t\t * According to the packet driver, the minimum timeout\n\t\t * should be .369 seconds.\n\t\t */\n\t\tfor (i = 0; i < 36900; i++) {\n\t\t\t/* Read the command status */\n\t\t\toff = IE_CMD_COMMON_STATUS(iecmdbuf);\n\t\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\t\tstatus = (sc->ie_bus_read16)(sc, off);\n\t\t\tif (status & mask) {\n#ifdef I82596_DEBUG\n\t\t\t\tif (sc->sc_debug & IED_CMDS)\n\t\t\t\t\tprintf (\"%s: cmd status %b\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\t\tstatus, IE_STAT_BITS);\n#endif\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tdelay(10);\n\t\t}\n\n\t} else {\n\t\t/*\n\t\t * Otherwise, just wait for the command to be accepted.\n\t\t */\n\t\treturn (i82596_cmd_wait(sc));\n\t}\n\n\t/* Timeout */\n\treturn (1);\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\ti82596_cmd_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ti82596_cmd_wait;\n\nint\ni82596_start_cmd(sc, cmd, iecmdbuf, mask, async)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tint iecmdbuf;\n\tint mask;\n\tint async;\n{\n\tregister int i, off;\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_CMDS)\n\t\tprintf(\"start_cmd: %p, %x, %x, %b, %ssync\\n\",\n\t\t       sc, cmd, iecmdbuf, mask, IE_STAT_BITS, async?\"a\":\"\");\n#endif\n\tif (sc->async_cmd_inprogress != 0) {\n\t\t/*\n\t\t * If previous command was issued asynchronously, wait\n\t\t * for it now.\n\t\t */\n\t\tif (i82596_cmd_wait(sc) != 0)\n\t\t\treturn (1);\n\t\tsc->async_cmd_inprogress = 0;\n\t}\n\n\toff = IE_SCB_CMD(sc->scb);\n\t(sc->ie_bus_write16)(sc, off, cmd);\n\tbus_space_barrier(sc->bt, sc->bh, off, 2, BUS_SPACE_BARRIER_WRITE);\n\t(sc->chan_attn)(sc);\n\n\tif (async) {\n\t\tsc->async_cmd_inprogress = 1;\n\t\treturn (0);\n\t}\n\n\tif (IE_ACTION_COMMAND(cmd) && iecmdbuf) {\n\t\tint status;\n\t\t/*\n\t\t * Now spin-lock waiting for status.  This is not a very nice\n\t\t * thing to do, and can kill performance pretty well...\n\t\t * According to the packet driver, the minimum timeout\n\t\t * should be .369 seconds.\n\t\t */\n\t\tfor (i = 0; i < 36900; i++) {\n\t\t\t/* Read the command status */\n\t\t\toff = IE_CMD_COMMON_STATUS(iecmdbuf);\n\t\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\t\tstatus = (sc->ie_bus_read16)(sc, off);\n\t\t\tif (status & mask) {\n#ifdef I82596_DEBUG\n\t\t\t\tif (sc->sc_debug & IED_CMDS)\n\t\t\t\t\tprintf (\"%s: cmd status %b\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\t\tstatus, IE_STAT_BITS);\n#endif\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tdelay(10);\n\t\t}\n\n\t} else {\n\t\t/*\n\t\t * Otherwise, just wait for the command to be accepted.\n\t\t */\n\t\treturn (i82596_cmd_wait(sc));\n\t}\n\n\t/* Timeout */\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_write16",
          "args": [
            "sc",
            "IE_CMD_MCAST_BYTES(cmdbuf)",
            "sc->mcast_count * ETHER_ADDR_LEN"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_MCAST_BYTES",
          "args": [
            "cmdbuf"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "(caddr_t)sc->mcast_addrs",
            "IE_CMD_MCAST_MADDR(cmdbuf)",
            "sc->mcast_count * ETHER_ADDR_LEN"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_MCAST_MADDR",
          "args": [
            "cmdbuf"
          ],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i82596_simple_command",
          "args": [
            "sc",
            "IE_CMD_MCAST",
            "cmdbuf"
          ],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "i82596_simple_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "1374-1387",
          "snippet": "void\ni82596_simple_command(sc, cmd, cmdbuf)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tint cmdbuf;\n{\n\t/* Setup a simple command */\n\tsc->ie_bus_write16(sc, IE_CMD_COMMON_STATUS(cmdbuf), 0);\n\tsc->ie_bus_write16(sc, IE_CMD_COMMON_CMD(cmdbuf), cmd | IE_CMD_LAST);\n\tsc->ie_bus_write16(sc, IE_CMD_COMMON_LINK(cmdbuf), 0xffff);\n\n\t/* Assign the command buffer to the SCB command list */\n\tsc->ie_bus_write16(sc, IE_SCB_CMDLST(sc->scb), cmdbuf);\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\ti82596_simple_command"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ti82596_simple_command;\n\nvoid\ni82596_simple_command(sc, cmd, cmdbuf)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tint cmdbuf;\n{\n\t/* Setup a simple command */\n\tsc->ie_bus_write16(sc, IE_CMD_COMMON_STATUS(cmdbuf), 0);\n\tsc->ie_bus_write16(sc, IE_CMD_COMMON_CMD(cmdbuf), cmd | IE_CMD_LAST);\n\tsc->ie_bus_write16(sc, IE_CMD_COMMON_LINK(cmdbuf), 0xffff);\n\n\t/* Assign the command buffer to the SCB command list */\n\tsc->ie_bus_write16(sc, IE_SCB_CMDLST(sc->scb), cmdbuf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ti82596_simple_command;\nint \tie_mc_setup;\n\nint\nie_mc_setup(sc, cmdbuf)\n\tstruct ie_softc *sc;\n\tint cmdbuf;\n{\n\tint cmdresult, status;\n\n\tif (sc->mcast_count == 0)\n\t\treturn (1);\n\n\ti82596_simple_command(sc, IE_CMD_MCAST, cmdbuf);\n\n\t(sc->memcopyout)(sc, (caddr_t)sc->mcast_addrs,\n\t\t\t IE_CMD_MCAST_MADDR(cmdbuf),\n\t\t\t sc->mcast_count * ETHER_ADDR_LEN);\n\n\tsc->ie_bus_write16(sc, IE_CMD_MCAST_BYTES(cmdbuf),\n\t\t\t       sc->mcast_count * ETHER_ADDR_LEN);\n\n\t/* Start the command */\n\tcmdresult = i82596_start_cmd(sc, IE_CUC_START, cmdbuf, IE_STAT_COMPL, 0);\n\tstatus = sc->ie_bus_read16(sc, IE_CMD_COMMON_STATUS(cmdbuf));\n\tif (cmdresult != 0) {\n\t\tprintf(\"%s: multicast setup command timed out; status %b\\n\",\n\t\t\tsc->sc_dev.dv_xname, status, IE_STAT_BITS);\n\t\treturn (0);\n\t}\n\tif ((status & IE_STAT_OK) == 0) {\n\t\tprintf(\"%s: multicast setup command failed; status %b\\n\",\n\t\t\tsc->sc_dev.dv_xname, status, IE_STAT_BITS);\n\t\treturn (0);\n\t}\n\n\t/* Squash any pending interrupts */\n\tie_ack(sc, IE_ST_WHENCE);\n\treturn (1);\n}"
  },
  {
    "function_name": "ie_ia_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
    "lines": "1637-1665",
    "snippet": "int\nie_ia_setup(sc, cmdbuf)\n\tstruct ie_softc *sc;\n\tint cmdbuf;\n{\n\tint cmdresult, status;\n\n\ti82596_simple_command(sc, IE_CMD_IASETUP, cmdbuf);\n\n\t(sc->memcopyout)(sc, sc->sc_arpcom.ac_enaddr,\n\t\t\t IE_CMD_IAS_EADDR(cmdbuf), ETHER_ADDR_LEN);\n\n\tcmdresult = i82596_start_cmd(sc, IE_CUC_START, cmdbuf, IE_STAT_COMPL, 0);\n\tstatus = sc->ie_bus_read16(sc, IE_CMD_COMMON_STATUS(cmdbuf));\n\tif (cmdresult != 0) {\n\t\tprintf(\"%s: individual address command timed out; status %b\\n\",\n\t\t\tsc->sc_dev.dv_xname, status, IE_STAT_BITS);\n\t\treturn (0);\n\t}\n\tif ((status & IE_STAT_OK) == 0) {\n\t\tprintf(\"%s: individual address command failed; status %b\\n\",\n\t\t\tsc->sc_dev.dv_xname, status, IE_STAT_BITS);\n\t\treturn (0);\n\t}\n\n\t/* Squash any pending interrupts */\n\tie_ack(sc, IE_ST_WHENCE);\n\treturn (1);\n}",
    "includes": [
      "#include <dev/ic/i82596var.h>",
      "#include <dev/ic/i82596reg.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\ti82596_simple_command",
      "int\tie_ia_setup"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ie_ack",
          "args": [
            "sc",
            "IE_ST_WHENCE"
          ],
          "line": 1663
        },
        "resolved": true,
        "details": {
          "function_name": "ie_ack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596var.h",
          "lines": "297-305",
          "snippet": "static __inline__ void\nie_ack(struct ie_softc *sc, u_int mask) /* in native byte-order */\n{\n\tregister u_int status;\n\n\tbus_space_barrier(sc->bt, sc->bh, 0, 0, BUS_SPACE_BARRIER_READ);\n\tstatus = (sc->ie_bus_read16)(sc, IE_SCB_STATUS(sc->scb));\n\ti82596_start_cmd(sc, status & mask, 0, 0, 0);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "int \ti82596_start_cmd"
          ],
          "called_functions": [],
          "contextual_snippet": "int \ti82596_start_cmd;\n\nstatic __inline__ void\nie_ack(struct ie_softc *sc, u_int mask) /* in native byte-order */\n{\n\tregister u_int status;\n\n\tbus_space_barrier(sc->bt, sc->bh, 0, 0, BUS_SPACE_BARRIER_READ);\n\tstatus = (sc->ie_bus_read16)(sc, IE_SCB_STATUS(sc->scb));\n\ti82596_start_cmd(sc, status & mask, 0, 0, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: individual address command failed; status %b\\n\"",
            "sc->sc_dev.dv_xname",
            "status",
            "IE_STAT_BITS"
          ],
          "line": 1657
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_read16",
          "args": [
            "sc",
            "IE_CMD_COMMON_STATUS(cmdbuf)"
          ],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_COMMON_STATUS",
          "args": [
            "cmdbuf"
          ],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i82596_start_cmd",
          "args": [
            "sc",
            "IE_CUC_START",
            "cmdbuf",
            "IE_STAT_COMPL",
            "0"
          ],
          "line": 1649
        },
        "resolved": true,
        "details": {
          "function_name": "i82596_start_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "398-468",
          "snippet": "int\ni82596_start_cmd(sc, cmd, iecmdbuf, mask, async)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tint iecmdbuf;\n\tint mask;\n\tint async;\n{\n\tregister int i, off;\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_CMDS)\n\t\tprintf(\"start_cmd: %p, %x, %x, %b, %ssync\\n\",\n\t\t       sc, cmd, iecmdbuf, mask, IE_STAT_BITS, async?\"a\":\"\");\n#endif\n\tif (sc->async_cmd_inprogress != 0) {\n\t\t/*\n\t\t * If previous command was issued asynchronously, wait\n\t\t * for it now.\n\t\t */\n\t\tif (i82596_cmd_wait(sc) != 0)\n\t\t\treturn (1);\n\t\tsc->async_cmd_inprogress = 0;\n\t}\n\n\toff = IE_SCB_CMD(sc->scb);\n\t(sc->ie_bus_write16)(sc, off, cmd);\n\tbus_space_barrier(sc->bt, sc->bh, off, 2, BUS_SPACE_BARRIER_WRITE);\n\t(sc->chan_attn)(sc);\n\n\tif (async) {\n\t\tsc->async_cmd_inprogress = 1;\n\t\treturn (0);\n\t}\n\n\tif (IE_ACTION_COMMAND(cmd) && iecmdbuf) {\n\t\tint status;\n\t\t/*\n\t\t * Now spin-lock waiting for status.  This is not a very nice\n\t\t * thing to do, and can kill performance pretty well...\n\t\t * According to the packet driver, the minimum timeout\n\t\t * should be .369 seconds.\n\t\t */\n\t\tfor (i = 0; i < 36900; i++) {\n\t\t\t/* Read the command status */\n\t\t\toff = IE_CMD_COMMON_STATUS(iecmdbuf);\n\t\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\t\tstatus = (sc->ie_bus_read16)(sc, off);\n\t\t\tif (status & mask) {\n#ifdef I82596_DEBUG\n\t\t\t\tif (sc->sc_debug & IED_CMDS)\n\t\t\t\t\tprintf (\"%s: cmd status %b\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\t\tstatus, IE_STAT_BITS);\n#endif\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tdelay(10);\n\t\t}\n\n\t} else {\n\t\t/*\n\t\t * Otherwise, just wait for the command to be accepted.\n\t\t */\n\t\treturn (i82596_cmd_wait(sc));\n\t}\n\n\t/* Timeout */\n\treturn (1);\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\ti82596_cmd_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ti82596_cmd_wait;\n\nint\ni82596_start_cmd(sc, cmd, iecmdbuf, mask, async)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tint iecmdbuf;\n\tint mask;\n\tint async;\n{\n\tregister int i, off;\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_CMDS)\n\t\tprintf(\"start_cmd: %p, %x, %x, %b, %ssync\\n\",\n\t\t       sc, cmd, iecmdbuf, mask, IE_STAT_BITS, async?\"a\":\"\");\n#endif\n\tif (sc->async_cmd_inprogress != 0) {\n\t\t/*\n\t\t * If previous command was issued asynchronously, wait\n\t\t * for it now.\n\t\t */\n\t\tif (i82596_cmd_wait(sc) != 0)\n\t\t\treturn (1);\n\t\tsc->async_cmd_inprogress = 0;\n\t}\n\n\toff = IE_SCB_CMD(sc->scb);\n\t(sc->ie_bus_write16)(sc, off, cmd);\n\tbus_space_barrier(sc->bt, sc->bh, off, 2, BUS_SPACE_BARRIER_WRITE);\n\t(sc->chan_attn)(sc);\n\n\tif (async) {\n\t\tsc->async_cmd_inprogress = 1;\n\t\treturn (0);\n\t}\n\n\tif (IE_ACTION_COMMAND(cmd) && iecmdbuf) {\n\t\tint status;\n\t\t/*\n\t\t * Now spin-lock waiting for status.  This is not a very nice\n\t\t * thing to do, and can kill performance pretty well...\n\t\t * According to the packet driver, the minimum timeout\n\t\t * should be .369 seconds.\n\t\t */\n\t\tfor (i = 0; i < 36900; i++) {\n\t\t\t/* Read the command status */\n\t\t\toff = IE_CMD_COMMON_STATUS(iecmdbuf);\n\t\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\t\tstatus = (sc->ie_bus_read16)(sc, off);\n\t\t\tif (status & mask) {\n#ifdef I82596_DEBUG\n\t\t\t\tif (sc->sc_debug & IED_CMDS)\n\t\t\t\t\tprintf (\"%s: cmd status %b\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\t\tstatus, IE_STAT_BITS);\n#endif\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tdelay(10);\n\t\t}\n\n\t} else {\n\t\t/*\n\t\t * Otherwise, just wait for the command to be accepted.\n\t\t */\n\t\treturn (i82596_cmd_wait(sc));\n\t}\n\n\t/* Timeout */\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "sc->sc_arpcom.ac_enaddr",
            "IE_CMD_IAS_EADDR(cmdbuf)",
            "ETHER_ADDR_LEN"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_IAS_EADDR",
          "args": [
            "cmdbuf"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i82596_simple_command",
          "args": [
            "sc",
            "IE_CMD_IASETUP",
            "cmdbuf"
          ],
          "line": 1644
        },
        "resolved": true,
        "details": {
          "function_name": "i82596_simple_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "1374-1387",
          "snippet": "void\ni82596_simple_command(sc, cmd, cmdbuf)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tint cmdbuf;\n{\n\t/* Setup a simple command */\n\tsc->ie_bus_write16(sc, IE_CMD_COMMON_STATUS(cmdbuf), 0);\n\tsc->ie_bus_write16(sc, IE_CMD_COMMON_CMD(cmdbuf), cmd | IE_CMD_LAST);\n\tsc->ie_bus_write16(sc, IE_CMD_COMMON_LINK(cmdbuf), 0xffff);\n\n\t/* Assign the command buffer to the SCB command list */\n\tsc->ie_bus_write16(sc, IE_SCB_CMDLST(sc->scb), cmdbuf);\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\ti82596_simple_command"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ti82596_simple_command;\n\nvoid\ni82596_simple_command(sc, cmd, cmdbuf)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tint cmdbuf;\n{\n\t/* Setup a simple command */\n\tsc->ie_bus_write16(sc, IE_CMD_COMMON_STATUS(cmdbuf), 0);\n\tsc->ie_bus_write16(sc, IE_CMD_COMMON_CMD(cmdbuf), cmd | IE_CMD_LAST);\n\tsc->ie_bus_write16(sc, IE_CMD_COMMON_LINK(cmdbuf), 0xffff);\n\n\t/* Assign the command buffer to the SCB command list */\n\tsc->ie_bus_write16(sc, IE_SCB_CMDLST(sc->scb), cmdbuf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ti82596_simple_command;\nint\tie_ia_setup;\n\nint\nie_ia_setup(sc, cmdbuf)\n\tstruct ie_softc *sc;\n\tint cmdbuf;\n{\n\tint cmdresult, status;\n\n\ti82596_simple_command(sc, IE_CMD_IASETUP, cmdbuf);\n\n\t(sc->memcopyout)(sc, sc->sc_arpcom.ac_enaddr,\n\t\t\t IE_CMD_IAS_EADDR(cmdbuf), ETHER_ADDR_LEN);\n\n\tcmdresult = i82596_start_cmd(sc, IE_CUC_START, cmdbuf, IE_STAT_COMPL, 0);\n\tstatus = sc->ie_bus_read16(sc, IE_CMD_COMMON_STATUS(cmdbuf));\n\tif (cmdresult != 0) {\n\t\tprintf(\"%s: individual address command timed out; status %b\\n\",\n\t\t\tsc->sc_dev.dv_xname, status, IE_STAT_BITS);\n\t\treturn (0);\n\t}\n\tif ((status & IE_STAT_OK) == 0) {\n\t\tprintf(\"%s: individual address command failed; status %b\\n\",\n\t\t\tsc->sc_dev.dv_xname, status, IE_STAT_BITS);\n\t\treturn (0);\n\t}\n\n\t/* Squash any pending interrupts */\n\tie_ack(sc, IE_ST_WHENCE);\n\treturn (1);\n}"
  },
  {
    "function_name": "ie_cfg_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
    "lines": "1594-1635",
    "snippet": "int\nie_cfg_setup(sc, cmd, promiscuous, manchester)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tint promiscuous, manchester;\n{\n\tint cmdresult, status;\n\n\ti82596_simple_command(sc, IE_CMD_CONFIG, cmd);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_CNT(cmd), 0x0c);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_FIFO(cmd), 8);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_SAVEBAD(cmd), 0x40);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_ADDRLEN(cmd), 0x2e);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_PRIORITY(cmd), 0);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_IFS(cmd), 0x60);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_SLOT_LOW(cmd), 0);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_SLOT_HIGH(cmd), 0xf2);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_PROMISC(cmd),\n\t\t\t\t\t  !!promiscuous | manchester << 2);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_CRSCDT(cmd), 0);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_MINLEN(cmd), 64);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_JUNK(cmd), 0xff);\n\tbus_space_barrier(sc->bt, sc->bh, cmd, IE_CMD_CFG_SZ,\n\t\t\t  BUS_SPACE_BARRIER_WRITE);\n\n\tcmdresult = i82596_start_cmd(sc, IE_CUC_START, cmd, IE_STAT_COMPL, 0);\n\tstatus = sc->ie_bus_read16(sc, IE_CMD_COMMON_STATUS(cmd));\n\tif (cmdresult != 0) {\n\t\tprintf(\"%s: configure command timed out; status %b\\n\",\n\t\t\tsc->sc_dev.dv_xname, status, IE_STAT_BITS);\n\t\treturn (0);\n\t}\n\tif ((status & IE_STAT_OK) == 0) {\n\t\tprintf(\"%s: configure command failed; status %b\\n\",\n\t\t\tsc->sc_dev.dv_xname, status, IE_STAT_BITS);\n\t\treturn (0);\n\t}\n\n\t/* Squash any pending interrupts */\n\tie_ack(sc, IE_ST_WHENCE);\n\treturn (1);\n}",
    "includes": [
      "#include <dev/ic/i82596var.h>",
      "#include <dev/ic/i82596reg.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\ti82596_simple_command",
      "int \tie_cfg_setup"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ie_ack",
          "args": [
            "sc",
            "IE_ST_WHENCE"
          ],
          "line": 1633
        },
        "resolved": true,
        "details": {
          "function_name": "ie_ack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596var.h",
          "lines": "297-305",
          "snippet": "static __inline__ void\nie_ack(struct ie_softc *sc, u_int mask) /* in native byte-order */\n{\n\tregister u_int status;\n\n\tbus_space_barrier(sc->bt, sc->bh, 0, 0, BUS_SPACE_BARRIER_READ);\n\tstatus = (sc->ie_bus_read16)(sc, IE_SCB_STATUS(sc->scb));\n\ti82596_start_cmd(sc, status & mask, 0, 0, 0);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "int \ti82596_start_cmd"
          ],
          "called_functions": [],
          "contextual_snippet": "int \ti82596_start_cmd;\n\nstatic __inline__ void\nie_ack(struct ie_softc *sc, u_int mask) /* in native byte-order */\n{\n\tregister u_int status;\n\n\tbus_space_barrier(sc->bt, sc->bh, 0, 0, BUS_SPACE_BARRIER_READ);\n\tstatus = (sc->ie_bus_read16)(sc, IE_SCB_STATUS(sc->scb));\n\ti82596_start_cmd(sc, status & mask, 0, 0, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: configure command failed; status %b\\n\"",
            "sc->sc_dev.dv_xname",
            "status",
            "IE_STAT_BITS"
          ],
          "line": 1627
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_read16",
          "args": [
            "sc",
            "IE_CMD_COMMON_STATUS(cmd)"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_COMMON_STATUS",
          "args": [
            "cmd"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i82596_start_cmd",
          "args": [
            "sc",
            "IE_CUC_START",
            "cmd",
            "IE_STAT_COMPL",
            "0"
          ],
          "line": 1619
        },
        "resolved": true,
        "details": {
          "function_name": "i82596_start_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "398-468",
          "snippet": "int\ni82596_start_cmd(sc, cmd, iecmdbuf, mask, async)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tint iecmdbuf;\n\tint mask;\n\tint async;\n{\n\tregister int i, off;\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_CMDS)\n\t\tprintf(\"start_cmd: %p, %x, %x, %b, %ssync\\n\",\n\t\t       sc, cmd, iecmdbuf, mask, IE_STAT_BITS, async?\"a\":\"\");\n#endif\n\tif (sc->async_cmd_inprogress != 0) {\n\t\t/*\n\t\t * If previous command was issued asynchronously, wait\n\t\t * for it now.\n\t\t */\n\t\tif (i82596_cmd_wait(sc) != 0)\n\t\t\treturn (1);\n\t\tsc->async_cmd_inprogress = 0;\n\t}\n\n\toff = IE_SCB_CMD(sc->scb);\n\t(sc->ie_bus_write16)(sc, off, cmd);\n\tbus_space_barrier(sc->bt, sc->bh, off, 2, BUS_SPACE_BARRIER_WRITE);\n\t(sc->chan_attn)(sc);\n\n\tif (async) {\n\t\tsc->async_cmd_inprogress = 1;\n\t\treturn (0);\n\t}\n\n\tif (IE_ACTION_COMMAND(cmd) && iecmdbuf) {\n\t\tint status;\n\t\t/*\n\t\t * Now spin-lock waiting for status.  This is not a very nice\n\t\t * thing to do, and can kill performance pretty well...\n\t\t * According to the packet driver, the minimum timeout\n\t\t * should be .369 seconds.\n\t\t */\n\t\tfor (i = 0; i < 36900; i++) {\n\t\t\t/* Read the command status */\n\t\t\toff = IE_CMD_COMMON_STATUS(iecmdbuf);\n\t\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\t\tstatus = (sc->ie_bus_read16)(sc, off);\n\t\t\tif (status & mask) {\n#ifdef I82596_DEBUG\n\t\t\t\tif (sc->sc_debug & IED_CMDS)\n\t\t\t\t\tprintf (\"%s: cmd status %b\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\t\tstatus, IE_STAT_BITS);\n#endif\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tdelay(10);\n\t\t}\n\n\t} else {\n\t\t/*\n\t\t * Otherwise, just wait for the command to be accepted.\n\t\t */\n\t\treturn (i82596_cmd_wait(sc));\n\t}\n\n\t/* Timeout */\n\treturn (1);\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\ti82596_cmd_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ti82596_cmd_wait;\n\nint\ni82596_start_cmd(sc, cmd, iecmdbuf, mask, async)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tint iecmdbuf;\n\tint mask;\n\tint async;\n{\n\tregister int i, off;\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_CMDS)\n\t\tprintf(\"start_cmd: %p, %x, %x, %b, %ssync\\n\",\n\t\t       sc, cmd, iecmdbuf, mask, IE_STAT_BITS, async?\"a\":\"\");\n#endif\n\tif (sc->async_cmd_inprogress != 0) {\n\t\t/*\n\t\t * If previous command was issued asynchronously, wait\n\t\t * for it now.\n\t\t */\n\t\tif (i82596_cmd_wait(sc) != 0)\n\t\t\treturn (1);\n\t\tsc->async_cmd_inprogress = 0;\n\t}\n\n\toff = IE_SCB_CMD(sc->scb);\n\t(sc->ie_bus_write16)(sc, off, cmd);\n\tbus_space_barrier(sc->bt, sc->bh, off, 2, BUS_SPACE_BARRIER_WRITE);\n\t(sc->chan_attn)(sc);\n\n\tif (async) {\n\t\tsc->async_cmd_inprogress = 1;\n\t\treturn (0);\n\t}\n\n\tif (IE_ACTION_COMMAND(cmd) && iecmdbuf) {\n\t\tint status;\n\t\t/*\n\t\t * Now spin-lock waiting for status.  This is not a very nice\n\t\t * thing to do, and can kill performance pretty well...\n\t\t * According to the packet driver, the minimum timeout\n\t\t * should be .369 seconds.\n\t\t */\n\t\tfor (i = 0; i < 36900; i++) {\n\t\t\t/* Read the command status */\n\t\t\toff = IE_CMD_COMMON_STATUS(iecmdbuf);\n\t\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\t\tstatus = (sc->ie_bus_read16)(sc, off);\n\t\t\tif (status & mask) {\n#ifdef I82596_DEBUG\n\t\t\t\tif (sc->sc_debug & IED_CMDS)\n\t\t\t\t\tprintf (\"%s: cmd status %b\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\t\tstatus, IE_STAT_BITS);\n#endif\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tdelay(10);\n\t\t}\n\n\t} else {\n\t\t/*\n\t\t * Otherwise, just wait for the command to be accepted.\n\t\t */\n\t\treturn (i82596_cmd_wait(sc));\n\t}\n\n\t/* Timeout */\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_barrier",
          "args": [
            "sc->bt",
            "sc->bh",
            "cmd",
            "IE_CMD_CFG_SZ",
            "BUS_SPACE_BARRIER_WRITE"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->bt",
            "sc->bh",
            "IE_CMD_CFG_JUNK(cmd)",
            "0xff"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_CFG_JUNK",
          "args": [
            "cmd"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->bt",
            "sc->bh",
            "IE_CMD_CFG_MINLEN(cmd)",
            "64"
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_CFG_MINLEN",
          "args": [
            "cmd"
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->bt",
            "sc->bh",
            "IE_CMD_CFG_CRSCDT(cmd)",
            "0"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_CFG_CRSCDT",
          "args": [
            "cmd"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->bt",
            "sc->bh",
            "IE_CMD_CFG_PROMISC(cmd)",
            "!!promiscuous | manchester << 2"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_CFG_PROMISC",
          "args": [
            "cmd"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->bt",
            "sc->bh",
            "IE_CMD_CFG_SLOT_HIGH(cmd)",
            "0xf2"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_CFG_SLOT_HIGH",
          "args": [
            "cmd"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->bt",
            "sc->bh",
            "IE_CMD_CFG_SLOT_LOW(cmd)",
            "0"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_CFG_SLOT_LOW",
          "args": [
            "cmd"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->bt",
            "sc->bh",
            "IE_CMD_CFG_IFS(cmd)",
            "0x60"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_CFG_IFS",
          "args": [
            "cmd"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->bt",
            "sc->bh",
            "IE_CMD_CFG_PRIORITY(cmd)",
            "0"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_CFG_PRIORITY",
          "args": [
            "cmd"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->bt",
            "sc->bh",
            "IE_CMD_CFG_ADDRLEN(cmd)",
            "0x2e"
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_CFG_ADDRLEN",
          "args": [
            "cmd"
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->bt",
            "sc->bh",
            "IE_CMD_CFG_SAVEBAD(cmd)",
            "0x40"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_CFG_SAVEBAD",
          "args": [
            "cmd"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->bt",
            "sc->bh",
            "IE_CMD_CFG_FIFO(cmd)",
            "8"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_CFG_FIFO",
          "args": [
            "cmd"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->bt",
            "sc->bh",
            "IE_CMD_CFG_CNT(cmd)",
            "0x0c"
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_CFG_CNT",
          "args": [
            "cmd"
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i82596_simple_command",
          "args": [
            "sc",
            "IE_CMD_CONFIG",
            "cmd"
          ],
          "line": 1602
        },
        "resolved": true,
        "details": {
          "function_name": "i82596_simple_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "1374-1387",
          "snippet": "void\ni82596_simple_command(sc, cmd, cmdbuf)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tint cmdbuf;\n{\n\t/* Setup a simple command */\n\tsc->ie_bus_write16(sc, IE_CMD_COMMON_STATUS(cmdbuf), 0);\n\tsc->ie_bus_write16(sc, IE_CMD_COMMON_CMD(cmdbuf), cmd | IE_CMD_LAST);\n\tsc->ie_bus_write16(sc, IE_CMD_COMMON_LINK(cmdbuf), 0xffff);\n\n\t/* Assign the command buffer to the SCB command list */\n\tsc->ie_bus_write16(sc, IE_SCB_CMDLST(sc->scb), cmdbuf);\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\ti82596_simple_command"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ti82596_simple_command;\n\nvoid\ni82596_simple_command(sc, cmd, cmdbuf)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tint cmdbuf;\n{\n\t/* Setup a simple command */\n\tsc->ie_bus_write16(sc, IE_CMD_COMMON_STATUS(cmdbuf), 0);\n\tsc->ie_bus_write16(sc, IE_CMD_COMMON_CMD(cmdbuf), cmd | IE_CMD_LAST);\n\tsc->ie_bus_write16(sc, IE_CMD_COMMON_LINK(cmdbuf), 0xffff);\n\n\t/* Assign the command buffer to the SCB command list */\n\tsc->ie_bus_write16(sc, IE_SCB_CMDLST(sc->scb), cmdbuf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ti82596_simple_command;\nint \tie_cfg_setup;\n\nint\nie_cfg_setup(sc, cmd, promiscuous, manchester)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tint promiscuous, manchester;\n{\n\tint cmdresult, status;\n\n\ti82596_simple_command(sc, IE_CMD_CONFIG, cmd);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_CNT(cmd), 0x0c);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_FIFO(cmd), 8);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_SAVEBAD(cmd), 0x40);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_ADDRLEN(cmd), 0x2e);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_PRIORITY(cmd), 0);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_IFS(cmd), 0x60);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_SLOT_LOW(cmd), 0);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_SLOT_HIGH(cmd), 0xf2);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_PROMISC(cmd),\n\t\t\t\t\t  !!promiscuous | manchester << 2);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_CRSCDT(cmd), 0);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_MINLEN(cmd), 64);\n\tbus_space_write_1(sc->bt, sc->bh, IE_CMD_CFG_JUNK(cmd), 0xff);\n\tbus_space_barrier(sc->bt, sc->bh, cmd, IE_CMD_CFG_SZ,\n\t\t\t  BUS_SPACE_BARRIER_WRITE);\n\n\tcmdresult = i82596_start_cmd(sc, IE_CUC_START, cmd, IE_STAT_COMPL, 0);\n\tstatus = sc->ie_bus_read16(sc, IE_CMD_COMMON_STATUS(cmd));\n\tif (cmdresult != 0) {\n\t\tprintf(\"%s: configure command timed out; status %b\\n\",\n\t\t\tsc->sc_dev.dv_xname, status, IE_STAT_BITS);\n\t\treturn (0);\n\t}\n\tif ((status & IE_STAT_OK) == 0) {\n\t\tprintf(\"%s: configure command failed; status %b\\n\",\n\t\t\tsc->sc_dev.dv_xname, status, IE_STAT_BITS);\n\t\treturn (0);\n\t}\n\n\t/* Squash any pending interrupts */\n\tie_ack(sc, IE_ST_WHENCE);\n\treturn (1);\n}"
  },
  {
    "function_name": "i82596_setup_bufs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
    "lines": "1441-1592",
    "snippet": "void\ni82596_setup_bufs(sc)\n\tstruct ie_softc *sc;\n{\n\tregister int n, r, ptr = sc->buf_area;\t/* memory pool */\n\n\t/*\n\t * step 0: zero memory and figure out how many recv buffers and\n\t * frames we can have.\n\t */\n\tptr = (ptr + 3) & ~3;\t/* set alignment and stick with it */\n\n\n\t/*\n\t *  step 1: lay out data structures in the shared-memory area\n\t */\n\n\t/* The no-op commands; used if \"nop-chaining\" is in effect */\n\tsc->nop_cmds = ptr;\n\tptr += NTXBUF * IE_CMD_NOP_SZ;\n\n\t/* The transmit commands */\n\tsc->xmit_cmds = ptr;\n\tptr += NTXBUF * IE_CMD_XMIT_SZ;\n\n\t/* The transmit buffers descriptors */\n\tsc->xbds = ptr;\n\tptr += NTXBUF * IE_XBD_SZ;\n\n\t/* The transmit buffers */\n\tsc->xbufs = ptr;\n\tptr += NTXBUF * IE_TBUF_SIZE;\n\n\tptr = (ptr + 3) & ~3;\t\t/* re-align.. just in case */\n\n\t/* Compute free space for RECV stuff */\n\tn = sc->buf_area_sz - (ptr - sc->buf_area);\n\n\t/* Compute size of one RECV frame */\n\tr = IE_RFRAME_SZ + ((IE_RBD_SZ + IE_RBUF_SIZE) * B_PER_F);\n\n\tsc->nframes = n / r;\n\n\tif (sc->nframes <= 0)\n\t\tpanic(\"ie: bogus buffer calc\\n\");\n\n\tsc->nrxbuf = sc->nframes * B_PER_F;\n\n\t/* The receice frame descriptors */\n\tsc->rframes = ptr;\n\tptr += sc->nframes * IE_RFRAME_SZ;\n\n\t/* The receive buffer descriptors */\n\tsc->rbds = ptr;\n\tptr += sc->nrxbuf * IE_RBD_SZ;\n\n\t/* The receive buffers */\n\tsc->rbufs = ptr;\n\tptr += sc->nrxbuf * IE_RBUF_SIZE;\n\n#ifdef I82596_DEBUG\n\tprintf(\"%s: %d frames %d bufs\\n\", sc->sc_dev.dv_xname, sc->nframes,\n\t\tsc->nrxbuf);\n#endif\n\n\t/*\n\t * step 2: link together the recv frames and set EOL on last one\n\t */\n\tfor (n = 0; n < sc->nframes; n++) {\n\t\tint m = (n == sc->nframes - 1) ? 0 : n + 1;\n\n\t\t/* Clear status */\n\t\tsc->ie_bus_write16(sc, IE_RFRAME_STATUS(sc->rframes,n), 0);\n\n\t\t/* RBD link = NULL */\n\t\tsc->ie_bus_write16(sc, IE_RFRAME_BUFDESC(sc->rframes,n),\n\t\t\t\t       0xffff);\n\n\t\t/* Make a circular list */\n\t\tsc->ie_bus_write16(sc, IE_RFRAME_NEXT(sc->rframes,n),\n\t\t\t\t       IE_RFRAME_ADDR(sc->rframes,m));\n\n\t\t/* Mark last as EOL */\n\t\tsc->ie_bus_write16(sc, IE_RFRAME_LAST(sc->rframes,n),\n\t\t\t\t       ((m==0)? (IE_FD_EOL|IE_FD_SUSP) : 0));\n\t}\n\n\t/*\n\t * step 3: link the RBDs and set EOL on last one\n\t */\n\tfor (n = 0; n < sc->nrxbuf; n++) {\n\t\tint m = (n == sc->nrxbuf - 1) ? 0 : n + 1;\n\n\t\t/* Clear status */\n\t\tsc->ie_bus_write16(sc, IE_RBD_STATUS(sc->rbds,n), 0);\n\n\t\t/* Make a circular list */\n\t\tsc->ie_bus_write16(sc, IE_RBD_NEXT(sc->rbds,n),\n\t\t\t\t       IE_RBD_ADDR(sc->rbds,m));\n\n\t\t/* Link to data buffers */\n\t\tsc->ie_bus_write24(sc, IE_RBD_BUFADDR(sc->rbds, n),\n\t\t\t\t       sc->sc_maddr + IE_RBUF_ADDR(sc, n));\n\t\tsc->ie_bus_write16(sc, IE_RBD_BUFLEN(sc->rbds,n),\n\t\t\t\t       IE_RBUF_SIZE | ((m==0)?IE_RBD_EOL:0));\n\t}\n\n\t/*\n\t * step 4: all xmit no-op commands loopback onto themselves\n\t */\n\tfor (n = 0; n < NTXBUF; n++) {\n\t\t(sc->ie_bus_write16)(sc, IE_CMD_NOP_STATUS(sc->nop_cmds, n), 0);\n\n\t\t(sc->ie_bus_write16)(sc, IE_CMD_NOP_CMD(sc->nop_cmds, n),\n\t\t\t\t\t IE_CMD_NOP);\n\n\t\t(sc->ie_bus_write16)(sc, IE_CMD_NOP_LINK(sc->nop_cmds, n),\n\t\t\t\t\t IE_CMD_NOP_ADDR(sc->nop_cmds, n));\n\t}\n\n\n\t/*\n\t * step 6: set the head and tail pointers on receive to keep track of\n\t * the order in which RFDs and RBDs are used.\n\t */\n\n\t/* Pointers to last packet sent and next available transmit buffer. */\n\tsc->xchead = sc->xctail = 0;\n\n\t/* Clear transmit-busy flag and set number of free transmit buffers. */\n\tsc->xmit_busy = 0;\n\n\t/*\n\t * Pointers to first and last receive frame.\n\t * The RFD pointed to by rftail is the only one that has EOL set.\n\t */\n\tsc->rfhead = 0;\n\tsc->rftail = sc->nframes - 1;\n\n\t/*\n\t * Pointers to first and last receive descriptor buffer.\n\t * The RBD pointed to by rbtail is the only one that has EOL set.\n\t */\n\tsc->rbhead = 0;\n\tsc->rbtail = sc->nrxbuf - 1;\n\n/* link in recv frames * and buffer into the scb. */\n#ifdef I82596_DEBUG\n\tprintf(\"%s: reserved %d bytes\\n\",\n\t\tsc->sc_dev.dv_xname, ptr - sc->buf_area);\n#endif\n}",
    "includes": [
      "#include <dev/ic/i82596var.h>",
      "#include <dev/ic/i82596reg.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void \ti82596_setup_bufs"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: reserved %d bytes\\n\"",
            "sc->sc_dev.dv_xname",
            "ptr - sc->buf_area"
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "IE_CMD_NOP_LINK(sc->nop_cmds, n)",
            "IE_CMD_NOP_ADDR(sc->nop_cmds, n)"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_NOP_ADDR",
          "args": [
            "sc->nop_cmds",
            "n"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_NOP_LINK",
          "args": [
            "sc->nop_cmds",
            "n"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "IE_CMD_NOP_CMD(sc->nop_cmds, n)",
            "IE_CMD_NOP"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_NOP_CMD",
          "args": [
            "sc->nop_cmds",
            "n"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "IE_CMD_NOP_STATUS(sc->nop_cmds, n)",
            "0"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_NOP_STATUS",
          "args": [
            "sc->nop_cmds",
            "n"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_write16",
          "args": [
            "sc",
            "IE_RBD_BUFLEN(sc->rbds,n)",
            "IE_RBUF_SIZE | ((m==0)?IE_RBD_EOL:0)"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_RBD_BUFLEN",
          "args": [
            "sc->rbds",
            "n"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_write24",
          "args": [
            "sc",
            "IE_RBD_BUFADDR(sc->rbds, n)",
            "sc->sc_maddr + IE_RBUF_ADDR(sc, n)"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_RBUF_ADDR",
          "args": [
            "sc",
            "n"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_RBD_BUFADDR",
          "args": [
            "sc->rbds",
            "n"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_write16",
          "args": [
            "sc",
            "IE_RBD_NEXT(sc->rbds,n)",
            "IE_RBD_ADDR(sc->rbds,m)"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_RBD_ADDR",
          "args": [
            "sc->rbds",
            "m"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_RBD_NEXT",
          "args": [
            "sc->rbds",
            "n"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_write16",
          "args": [
            "sc",
            "IE_RBD_STATUS(sc->rbds,n)",
            "0"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_RBD_STATUS",
          "args": [
            "sc->rbds",
            "n"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_write16",
          "args": [
            "sc",
            "IE_RFRAME_LAST(sc->rframes,n)",
            "((m==0)? (IE_FD_EOL|IE_FD_SUSP) : 0)"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_RFRAME_LAST",
          "args": [
            "sc->rframes",
            "n"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_write16",
          "args": [
            "sc",
            "IE_RFRAME_NEXT(sc->rframes,n)",
            "IE_RFRAME_ADDR(sc->rframes,m)"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_RFRAME_ADDR",
          "args": [
            "sc->rframes",
            "m"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_RFRAME_NEXT",
          "args": [
            "sc->rframes",
            "n"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_write16",
          "args": [
            "sc",
            "IE_RFRAME_BUFDESC(sc->rframes,n)",
            "0xffff"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_RFRAME_BUFDESC",
          "args": [
            "sc->rframes",
            "n"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_write16",
          "args": [
            "sc",
            "IE_RFRAME_STATUS(sc->rframes,n)",
            "0"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_RFRAME_STATUS",
          "args": [
            "sc->rframes",
            "n"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ie: bogus buffer calc\\n\""
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid \ti82596_setup_bufs;\n\nvoid\ni82596_setup_bufs(sc)\n\tstruct ie_softc *sc;\n{\n\tregister int n, r, ptr = sc->buf_area;\t/* memory pool */\n\n\t/*\n\t * step 0: zero memory and figure out how many recv buffers and\n\t * frames we can have.\n\t */\n\tptr = (ptr + 3) & ~3;\t/* set alignment and stick with it */\n\n\n\t/*\n\t *  step 1: lay out data structures in the shared-memory area\n\t */\n\n\t/* The no-op commands; used if \"nop-chaining\" is in effect */\n\tsc->nop_cmds = ptr;\n\tptr += NTXBUF * IE_CMD_NOP_SZ;\n\n\t/* The transmit commands */\n\tsc->xmit_cmds = ptr;\n\tptr += NTXBUF * IE_CMD_XMIT_SZ;\n\n\t/* The transmit buffers descriptors */\n\tsc->xbds = ptr;\n\tptr += NTXBUF * IE_XBD_SZ;\n\n\t/* The transmit buffers */\n\tsc->xbufs = ptr;\n\tptr += NTXBUF * IE_TBUF_SIZE;\n\n\tptr = (ptr + 3) & ~3;\t\t/* re-align.. just in case */\n\n\t/* Compute free space for RECV stuff */\n\tn = sc->buf_area_sz - (ptr - sc->buf_area);\n\n\t/* Compute size of one RECV frame */\n\tr = IE_RFRAME_SZ + ((IE_RBD_SZ + IE_RBUF_SIZE) * B_PER_F);\n\n\tsc->nframes = n / r;\n\n\tif (sc->nframes <= 0)\n\t\tpanic(\"ie: bogus buffer calc\\n\");\n\n\tsc->nrxbuf = sc->nframes * B_PER_F;\n\n\t/* The receice frame descriptors */\n\tsc->rframes = ptr;\n\tptr += sc->nframes * IE_RFRAME_SZ;\n\n\t/* The receive buffer descriptors */\n\tsc->rbds = ptr;\n\tptr += sc->nrxbuf * IE_RBD_SZ;\n\n\t/* The receive buffers */\n\tsc->rbufs = ptr;\n\tptr += sc->nrxbuf * IE_RBUF_SIZE;\n\n#ifdef I82596_DEBUG\n\tprintf(\"%s: %d frames %d bufs\\n\", sc->sc_dev.dv_xname, sc->nframes,\n\t\tsc->nrxbuf);\n#endif\n\n\t/*\n\t * step 2: link together the recv frames and set EOL on last one\n\t */\n\tfor (n = 0; n < sc->nframes; n++) {\n\t\tint m = (n == sc->nframes - 1) ? 0 : n + 1;\n\n\t\t/* Clear status */\n\t\tsc->ie_bus_write16(sc, IE_RFRAME_STATUS(sc->rframes,n), 0);\n\n\t\t/* RBD link = NULL */\n\t\tsc->ie_bus_write16(sc, IE_RFRAME_BUFDESC(sc->rframes,n),\n\t\t\t\t       0xffff);\n\n\t\t/* Make a circular list */\n\t\tsc->ie_bus_write16(sc, IE_RFRAME_NEXT(sc->rframes,n),\n\t\t\t\t       IE_RFRAME_ADDR(sc->rframes,m));\n\n\t\t/* Mark last as EOL */\n\t\tsc->ie_bus_write16(sc, IE_RFRAME_LAST(sc->rframes,n),\n\t\t\t\t       ((m==0)? (IE_FD_EOL|IE_FD_SUSP) : 0));\n\t}\n\n\t/*\n\t * step 3: link the RBDs and set EOL on last one\n\t */\n\tfor (n = 0; n < sc->nrxbuf; n++) {\n\t\tint m = (n == sc->nrxbuf - 1) ? 0 : n + 1;\n\n\t\t/* Clear status */\n\t\tsc->ie_bus_write16(sc, IE_RBD_STATUS(sc->rbds,n), 0);\n\n\t\t/* Make a circular list */\n\t\tsc->ie_bus_write16(sc, IE_RBD_NEXT(sc->rbds,n),\n\t\t\t\t       IE_RBD_ADDR(sc->rbds,m));\n\n\t\t/* Link to data buffers */\n\t\tsc->ie_bus_write24(sc, IE_RBD_BUFADDR(sc->rbds, n),\n\t\t\t\t       sc->sc_maddr + IE_RBUF_ADDR(sc, n));\n\t\tsc->ie_bus_write16(sc, IE_RBD_BUFLEN(sc->rbds,n),\n\t\t\t\t       IE_RBUF_SIZE | ((m==0)?IE_RBD_EOL:0));\n\t}\n\n\t/*\n\t * step 4: all xmit no-op commands loopback onto themselves\n\t */\n\tfor (n = 0; n < NTXBUF; n++) {\n\t\t(sc->ie_bus_write16)(sc, IE_CMD_NOP_STATUS(sc->nop_cmds, n), 0);\n\n\t\t(sc->ie_bus_write16)(sc, IE_CMD_NOP_CMD(sc->nop_cmds, n),\n\t\t\t\t\t IE_CMD_NOP);\n\n\t\t(sc->ie_bus_write16)(sc, IE_CMD_NOP_LINK(sc->nop_cmds, n),\n\t\t\t\t\t IE_CMD_NOP_ADDR(sc->nop_cmds, n));\n\t}\n\n\n\t/*\n\t * step 6: set the head and tail pointers on receive to keep track of\n\t * the order in which RFDs and RBDs are used.\n\t */\n\n\t/* Pointers to last packet sent and next available transmit buffer. */\n\tsc->xchead = sc->xctail = 0;\n\n\t/* Clear transmit-busy flag and set number of free transmit buffers. */\n\tsc->xmit_busy = 0;\n\n\t/*\n\t * Pointers to first and last receive frame.\n\t * The RFD pointed to by rftail is the only one that has EOL set.\n\t */\n\tsc->rfhead = 0;\n\tsc->rftail = sc->nframes - 1;\n\n\t/*\n\t * Pointers to first and last receive descriptor buffer.\n\t * The RBD pointed to by rbtail is the only one that has EOL set.\n\t */\n\tsc->rbhead = 0;\n\tsc->rbtail = sc->nrxbuf - 1;\n\n/* link in recv frames * and buffer into the scb. */\n#ifdef I82596_DEBUG\n\tprintf(\"%s: reserved %d bytes\\n\",\n\t\tsc->sc_dev.dv_xname, ptr - sc->buf_area);\n#endif\n}"
  },
  {
    "function_name": "ie_run_tdr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
    "lines": "1392-1427",
    "snippet": "void\nie_run_tdr(sc, cmd)\n\tstruct ie_softc *sc;\n\tint cmd;\n{\n\tint result;\n\n\ti82596_simple_command(sc, IE_CMD_TDR, cmd);\n\t(sc->ie_bus_write16)(sc, IE_CMD_TDR_TIME(cmd), 0);\n\n\tif (i82596_start_cmd(sc, IE_CUC_START, cmd, IE_STAT_COMPL, 0) ||\n\t    !(sc->ie_bus_read16(sc, IE_CMD_COMMON_STATUS(cmd)) & IE_STAT_OK))\n\t\tresult = 0x10000; /* XXX */\n\telse\n\t\tresult = sc->ie_bus_read16(sc, IE_CMD_TDR_TIME(cmd));\n\n\t/* Squash any pending interrupts */\n\tie_ack(sc, IE_ST_WHENCE);\n\n\tif (result & IE_TDR_SUCCESS)\n\t\treturn;\n\n\tif (result & 0x10000)\n\t\tprintf(\"%s: TDR command failed\\n\", sc->sc_dev.dv_xname);\n\telse if (result & IE_TDR_XCVR)\n\t\tprintf(\"%s: transceiver problem\\n\", sc->sc_dev.dv_xname);\n\telse if (result & IE_TDR_OPEN)\n\t\tprintf(\"%s: TDR detected an open %d clocks away\\n\",\n\t\t\tsc->sc_dev.dv_xname, result & IE_TDR_TIME);\n\telse if (result & IE_TDR_SHORT)\n\t\tprintf(\"%s: TDR detected a short %d clocks away\\n\",\n\t\t\tsc->sc_dev.dv_xname, result & IE_TDR_TIME);\n\telse\n\t\tprintf(\"%s: TDR returned unknown status 0x%x\\n\",\n\t\t\tsc->sc_dev.dv_xname, result);\n}",
    "includes": [
      "#include <dev/ic/i82596var.h>",
      "#include <dev/ic/i82596reg.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\ti82596_simple_command",
      "void \tie_run_tdr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: TDR returned unknown status 0x%x\\n\"",
            "sc->sc_dev.dv_xname",
            "result"
          ],
          "line": 1425
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ie_ack",
          "args": [
            "sc",
            "IE_ST_WHENCE"
          ],
          "line": 1409
        },
        "resolved": true,
        "details": {
          "function_name": "ie_ack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596var.h",
          "lines": "297-305",
          "snippet": "static __inline__ void\nie_ack(struct ie_softc *sc, u_int mask) /* in native byte-order */\n{\n\tregister u_int status;\n\n\tbus_space_barrier(sc->bt, sc->bh, 0, 0, BUS_SPACE_BARRIER_READ);\n\tstatus = (sc->ie_bus_read16)(sc, IE_SCB_STATUS(sc->scb));\n\ti82596_start_cmd(sc, status & mask, 0, 0, 0);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "int \ti82596_start_cmd"
          ],
          "called_functions": [],
          "contextual_snippet": "int \ti82596_start_cmd;\n\nstatic __inline__ void\nie_ack(struct ie_softc *sc, u_int mask) /* in native byte-order */\n{\n\tregister u_int status;\n\n\tbus_space_barrier(sc->bt, sc->bh, 0, 0, BUS_SPACE_BARRIER_READ);\n\tstatus = (sc->ie_bus_read16)(sc, IE_SCB_STATUS(sc->scb));\n\ti82596_start_cmd(sc, status & mask, 0, 0, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_read16",
          "args": [
            "sc",
            "IE_CMD_TDR_TIME(cmd)"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_TDR_TIME",
          "args": [
            "cmd"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_read16",
          "args": [
            "sc",
            "IE_CMD_COMMON_STATUS(cmd)"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_COMMON_STATUS",
          "args": [
            "cmd"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i82596_start_cmd",
          "args": [
            "sc",
            "IE_CUC_START",
            "cmd",
            "IE_STAT_COMPL",
            "0"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "i82596_start_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "398-468",
          "snippet": "int\ni82596_start_cmd(sc, cmd, iecmdbuf, mask, async)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tint iecmdbuf;\n\tint mask;\n\tint async;\n{\n\tregister int i, off;\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_CMDS)\n\t\tprintf(\"start_cmd: %p, %x, %x, %b, %ssync\\n\",\n\t\t       sc, cmd, iecmdbuf, mask, IE_STAT_BITS, async?\"a\":\"\");\n#endif\n\tif (sc->async_cmd_inprogress != 0) {\n\t\t/*\n\t\t * If previous command was issued asynchronously, wait\n\t\t * for it now.\n\t\t */\n\t\tif (i82596_cmd_wait(sc) != 0)\n\t\t\treturn (1);\n\t\tsc->async_cmd_inprogress = 0;\n\t}\n\n\toff = IE_SCB_CMD(sc->scb);\n\t(sc->ie_bus_write16)(sc, off, cmd);\n\tbus_space_barrier(sc->bt, sc->bh, off, 2, BUS_SPACE_BARRIER_WRITE);\n\t(sc->chan_attn)(sc);\n\n\tif (async) {\n\t\tsc->async_cmd_inprogress = 1;\n\t\treturn (0);\n\t}\n\n\tif (IE_ACTION_COMMAND(cmd) && iecmdbuf) {\n\t\tint status;\n\t\t/*\n\t\t * Now spin-lock waiting for status.  This is not a very nice\n\t\t * thing to do, and can kill performance pretty well...\n\t\t * According to the packet driver, the minimum timeout\n\t\t * should be .369 seconds.\n\t\t */\n\t\tfor (i = 0; i < 36900; i++) {\n\t\t\t/* Read the command status */\n\t\t\toff = IE_CMD_COMMON_STATUS(iecmdbuf);\n\t\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\t\tstatus = (sc->ie_bus_read16)(sc, off);\n\t\t\tif (status & mask) {\n#ifdef I82596_DEBUG\n\t\t\t\tif (sc->sc_debug & IED_CMDS)\n\t\t\t\t\tprintf (\"%s: cmd status %b\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\t\tstatus, IE_STAT_BITS);\n#endif\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tdelay(10);\n\t\t}\n\n\t} else {\n\t\t/*\n\t\t * Otherwise, just wait for the command to be accepted.\n\t\t */\n\t\treturn (i82596_cmd_wait(sc));\n\t}\n\n\t/* Timeout */\n\treturn (1);\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\ti82596_cmd_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ti82596_cmd_wait;\n\nint\ni82596_start_cmd(sc, cmd, iecmdbuf, mask, async)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tint iecmdbuf;\n\tint mask;\n\tint async;\n{\n\tregister int i, off;\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_CMDS)\n\t\tprintf(\"start_cmd: %p, %x, %x, %b, %ssync\\n\",\n\t\t       sc, cmd, iecmdbuf, mask, IE_STAT_BITS, async?\"a\":\"\");\n#endif\n\tif (sc->async_cmd_inprogress != 0) {\n\t\t/*\n\t\t * If previous command was issued asynchronously, wait\n\t\t * for it now.\n\t\t */\n\t\tif (i82596_cmd_wait(sc) != 0)\n\t\t\treturn (1);\n\t\tsc->async_cmd_inprogress = 0;\n\t}\n\n\toff = IE_SCB_CMD(sc->scb);\n\t(sc->ie_bus_write16)(sc, off, cmd);\n\tbus_space_barrier(sc->bt, sc->bh, off, 2, BUS_SPACE_BARRIER_WRITE);\n\t(sc->chan_attn)(sc);\n\n\tif (async) {\n\t\tsc->async_cmd_inprogress = 1;\n\t\treturn (0);\n\t}\n\n\tif (IE_ACTION_COMMAND(cmd) && iecmdbuf) {\n\t\tint status;\n\t\t/*\n\t\t * Now spin-lock waiting for status.  This is not a very nice\n\t\t * thing to do, and can kill performance pretty well...\n\t\t * According to the packet driver, the minimum timeout\n\t\t * should be .369 seconds.\n\t\t */\n\t\tfor (i = 0; i < 36900; i++) {\n\t\t\t/* Read the command status */\n\t\t\toff = IE_CMD_COMMON_STATUS(iecmdbuf);\n\t\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\t\tstatus = (sc->ie_bus_read16)(sc, off);\n\t\t\tif (status & mask) {\n#ifdef I82596_DEBUG\n\t\t\t\tif (sc->sc_debug & IED_CMDS)\n\t\t\t\t\tprintf (\"%s: cmd status %b\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\t\tstatus, IE_STAT_BITS);\n#endif\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tdelay(10);\n\t\t}\n\n\t} else {\n\t\t/*\n\t\t * Otherwise, just wait for the command to be accepted.\n\t\t */\n\t\treturn (i82596_cmd_wait(sc));\n\t}\n\n\t/* Timeout */\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "IE_CMD_TDR_TIME(cmd)",
            "0"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_TDR_TIME",
          "args": [
            "cmd"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i82596_simple_command",
          "args": [
            "sc",
            "IE_CMD_TDR",
            "cmd"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "i82596_simple_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "1374-1387",
          "snippet": "void\ni82596_simple_command(sc, cmd, cmdbuf)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tint cmdbuf;\n{\n\t/* Setup a simple command */\n\tsc->ie_bus_write16(sc, IE_CMD_COMMON_STATUS(cmdbuf), 0);\n\tsc->ie_bus_write16(sc, IE_CMD_COMMON_CMD(cmdbuf), cmd | IE_CMD_LAST);\n\tsc->ie_bus_write16(sc, IE_CMD_COMMON_LINK(cmdbuf), 0xffff);\n\n\t/* Assign the command buffer to the SCB command list */\n\tsc->ie_bus_write16(sc, IE_SCB_CMDLST(sc->scb), cmdbuf);\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\ti82596_simple_command"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ti82596_simple_command;\n\nvoid\ni82596_simple_command(sc, cmd, cmdbuf)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tint cmdbuf;\n{\n\t/* Setup a simple command */\n\tsc->ie_bus_write16(sc, IE_CMD_COMMON_STATUS(cmdbuf), 0);\n\tsc->ie_bus_write16(sc, IE_CMD_COMMON_CMD(cmdbuf), cmd | IE_CMD_LAST);\n\tsc->ie_bus_write16(sc, IE_CMD_COMMON_LINK(cmdbuf), 0xffff);\n\n\t/* Assign the command buffer to the SCB command list */\n\tsc->ie_bus_write16(sc, IE_SCB_CMDLST(sc->scb), cmdbuf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ti82596_simple_command;\nvoid \tie_run_tdr;\n\nvoid\nie_run_tdr(sc, cmd)\n\tstruct ie_softc *sc;\n\tint cmd;\n{\n\tint result;\n\n\ti82596_simple_command(sc, IE_CMD_TDR, cmd);\n\t(sc->ie_bus_write16)(sc, IE_CMD_TDR_TIME(cmd), 0);\n\n\tif (i82596_start_cmd(sc, IE_CUC_START, cmd, IE_STAT_COMPL, 0) ||\n\t    !(sc->ie_bus_read16(sc, IE_CMD_COMMON_STATUS(cmd)) & IE_STAT_OK))\n\t\tresult = 0x10000; /* XXX */\n\telse\n\t\tresult = sc->ie_bus_read16(sc, IE_CMD_TDR_TIME(cmd));\n\n\t/* Squash any pending interrupts */\n\tie_ack(sc, IE_ST_WHENCE);\n\n\tif (result & IE_TDR_SUCCESS)\n\t\treturn;\n\n\tif (result & 0x10000)\n\t\tprintf(\"%s: TDR command failed\\n\", sc->sc_dev.dv_xname);\n\telse if (result & IE_TDR_XCVR)\n\t\tprintf(\"%s: transceiver problem\\n\", sc->sc_dev.dv_xname);\n\telse if (result & IE_TDR_OPEN)\n\t\tprintf(\"%s: TDR detected an open %d clocks away\\n\",\n\t\t\tsc->sc_dev.dv_xname, result & IE_TDR_TIME);\n\telse if (result & IE_TDR_SHORT)\n\t\tprintf(\"%s: TDR detected a short %d clocks away\\n\",\n\t\t\tsc->sc_dev.dv_xname, result & IE_TDR_TIME);\n\telse\n\t\tprintf(\"%s: TDR returned unknown status 0x%x\\n\",\n\t\t\tsc->sc_dev.dv_xname, result);\n}"
  },
  {
    "function_name": "i82596_simple_command",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
    "lines": "1374-1387",
    "snippet": "void\ni82596_simple_command(sc, cmd, cmdbuf)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tint cmdbuf;\n{\n\t/* Setup a simple command */\n\tsc->ie_bus_write16(sc, IE_CMD_COMMON_STATUS(cmdbuf), 0);\n\tsc->ie_bus_write16(sc, IE_CMD_COMMON_CMD(cmdbuf), cmd | IE_CMD_LAST);\n\tsc->ie_bus_write16(sc, IE_CMD_COMMON_LINK(cmdbuf), 0xffff);\n\n\t/* Assign the command buffer to the SCB command list */\n\tsc->ie_bus_write16(sc, IE_SCB_CMDLST(sc->scb), cmdbuf);\n}",
    "includes": [
      "#include <dev/ic/i82596var.h>",
      "#include <dev/ic/i82596reg.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\ti82596_simple_command"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sc->ie_bus_write16",
          "args": [
            "sc",
            "IE_SCB_CMDLST(sc->scb)",
            "cmdbuf"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_SCB_CMDLST",
          "args": [
            "sc->scb"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_write16",
          "args": [
            "sc",
            "IE_CMD_COMMON_LINK(cmdbuf)",
            "0xffff"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_COMMON_LINK",
          "args": [
            "cmdbuf"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_write16",
          "args": [
            "sc",
            "IE_CMD_COMMON_CMD(cmdbuf)",
            "cmd | IE_CMD_LAST"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_COMMON_CMD",
          "args": [
            "cmdbuf"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_write16",
          "args": [
            "sc",
            "IE_CMD_COMMON_STATUS(cmdbuf)",
            "0"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_COMMON_STATUS",
          "args": [
            "cmdbuf"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ti82596_simple_command;\n\nvoid\ni82596_simple_command(sc, cmd, cmdbuf)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tint cmdbuf;\n{\n\t/* Setup a simple command */\n\tsc->ie_bus_write16(sc, IE_CMD_COMMON_STATUS(cmdbuf), 0);\n\tsc->ie_bus_write16(sc, IE_CMD_COMMON_CMD(cmdbuf), cmd | IE_CMD_LAST);\n\tsc->ie_bus_write16(sc, IE_CMD_COMMON_LINK(cmdbuf), 0xffff);\n\n\t/* Assign the command buffer to the SCB command list */\n\tsc->ie_bus_write16(sc, IE_SCB_CMDLST(sc->scb), cmdbuf);\n}"
  },
  {
    "function_name": "i82596_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
    "lines": "1333-1372",
    "snippet": "void\ni82596_reset(sc, hard)\n\tstruct ie_softc *sc;\n\tint hard;\n{\n\tint s = splnet();\n\n\tif (hard)\n\t\tprintf(\"%s: reset\\n\", sc->sc_dev.dv_xname);\n\n\t/* Clear OACTIVE in case we're called from watchdog (frozen xmit). */\n\tsc->sc_arpcom.ac_if.if_timer = 0;\n\tsc->sc_arpcom.ac_if.if_flags &= ~IFF_OACTIVE;\n\n\t/*\n\t * Stop i82596 dead in its tracks.\n\t */\n\tif (i82596_start_cmd(sc, IE_RUC_ABORT | IE_CUC_ABORT, 0, 0, 0))\n\t\tprintf(\"%s: abort commands timed out\\n\", sc->sc_dev.dv_xname);\n\n\t/*\n\t * This can really slow down the i82596_reset() on some cards, but it's\n\t * necessary to unwedge other ones (eg, the Sun VME ones) from certain\n\t * lockups.\n\t */\n\tif (hard && sc->hwreset)\n\t\t(sc->hwreset)(sc, IE_CARD_RESET);\n\n\tdelay(100);\n\tie_ack(sc, IE_ST_WHENCE);\n\n\tif ((sc->sc_arpcom.ac_if.if_flags & IFF_UP) != 0) {\n\t\tint retries=0;\t/* XXX - find out why init sometimes fails */\n\t\twhile (retries++ < 2)\n\t\t\tif (i82596_init(sc) == 1)\n\t\t\t\tbreak;\n\t}\n\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/ic/i82596var.h>",
      "#include <dev/ic/i82596reg.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\ti82596_reset",
      "int\ti82596_init"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i82596_init",
          "args": [
            "sc"
          ],
          "line": 1367
        },
        "resolved": true,
        "details": {
          "function_name": "i82596_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "1717-1772",
          "snippet": "int\ni82596_init(sc)\n\tstruct ie_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint cmd;\n\n\tsc->async_cmd_inprogress = 0;\n\n\tcmd = sc->buf_area;\n\n\t/*\n\t * Send the configure command first.\n\t */\n\tif (ie_cfg_setup(sc, cmd, sc->promisc, 0) == 0)\n\t\treturn (0);\n\n\t/*\n\t * Send the Individual Address Setup command.\n\t */\n\tif (ie_ia_setup(sc, cmd) == 0)\n\t\treturn (0);\n\n\t/*\n\t * Run the time-domain reflectometer.\n\t */\n\tie_run_tdr(sc, cmd);\n\n\t/*\n\t * Set the multi-cast filter, if any\n\t */\n\tif (ie_mc_setup(sc, cmd) == 0)\n\t\treturn (0);\n\n\t/*\n\t * Acknowledge any interrupts we have generated thus far.\n\t */\n\tie_ack(sc, IE_ST_WHENCE);\n\n\t/*\n\t * Set up the transmit and recv buffers.\n\t */\n\ti82596_setup_bufs(sc);\n\n\tif (sc->hwinit)\n\t\t(sc->hwinit)(sc);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tif (NTXBUF < 2)\n\t\tsc->do_xmitnopchain = 0;\n\n\ti82596_start_transceiver(sc);\n\treturn (1);\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\ti82596_init",
            "void\ti82596_start_transceiver",
            "void \ti82596_setup_bufs",
            "int \tie_cfg_setup",
            "int\tie_ia_setup",
            "void \tie_run_tdr",
            "int \tie_mc_setup"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ti82596_init;\nvoid\ti82596_start_transceiver;\nvoid \ti82596_setup_bufs;\nint \tie_cfg_setup;\nint\tie_ia_setup;\nvoid \tie_run_tdr;\nint \tie_mc_setup;\n\nint\ni82596_init(sc)\n\tstruct ie_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint cmd;\n\n\tsc->async_cmd_inprogress = 0;\n\n\tcmd = sc->buf_area;\n\n\t/*\n\t * Send the configure command first.\n\t */\n\tif (ie_cfg_setup(sc, cmd, sc->promisc, 0) == 0)\n\t\treturn (0);\n\n\t/*\n\t * Send the Individual Address Setup command.\n\t */\n\tif (ie_ia_setup(sc, cmd) == 0)\n\t\treturn (0);\n\n\t/*\n\t * Run the time-domain reflectometer.\n\t */\n\tie_run_tdr(sc, cmd);\n\n\t/*\n\t * Set the multi-cast filter, if any\n\t */\n\tif (ie_mc_setup(sc, cmd) == 0)\n\t\treturn (0);\n\n\t/*\n\t * Acknowledge any interrupts we have generated thus far.\n\t */\n\tie_ack(sc, IE_ST_WHENCE);\n\n\t/*\n\t * Set up the transmit and recv buffers.\n\t */\n\ti82596_setup_bufs(sc);\n\n\tif (sc->hwinit)\n\t\t(sc->hwinit)(sc);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tif (NTXBUF < 2)\n\t\tsc->do_xmitnopchain = 0;\n\n\ti82596_start_transceiver(sc);\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ie_ack",
          "args": [
            "sc",
            "IE_ST_WHENCE"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "ie_ack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596var.h",
          "lines": "297-305",
          "snippet": "static __inline__ void\nie_ack(struct ie_softc *sc, u_int mask) /* in native byte-order */\n{\n\tregister u_int status;\n\n\tbus_space_barrier(sc->bt, sc->bh, 0, 0, BUS_SPACE_BARRIER_READ);\n\tstatus = (sc->ie_bus_read16)(sc, IE_SCB_STATUS(sc->scb));\n\ti82596_start_cmd(sc, status & mask, 0, 0, 0);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "int \ti82596_start_cmd"
          ],
          "called_functions": [],
          "contextual_snippet": "int \ti82596_start_cmd;\n\nstatic __inline__ void\nie_ack(struct ie_softc *sc, u_int mask) /* in native byte-order */\n{\n\tregister u_int status;\n\n\tbus_space_barrier(sc->bt, sc->bh, 0, 0, BUS_SPACE_BARRIER_READ);\n\tstatus = (sc->ie_bus_read16)(sc, IE_SCB_STATUS(sc->scb));\n\ti82596_start_cmd(sc, status & mask, 0, 0, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "100"
          ],
          "line": 1361
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "IE_CARD_RESET"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: abort commands timed out\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i82596_start_cmd",
          "args": [
            "sc",
            "IE_RUC_ABORT | IE_CUC_ABORT",
            "0",
            "0",
            "0"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "i82596_start_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "398-468",
          "snippet": "int\ni82596_start_cmd(sc, cmd, iecmdbuf, mask, async)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tint iecmdbuf;\n\tint mask;\n\tint async;\n{\n\tregister int i, off;\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_CMDS)\n\t\tprintf(\"start_cmd: %p, %x, %x, %b, %ssync\\n\",\n\t\t       sc, cmd, iecmdbuf, mask, IE_STAT_BITS, async?\"a\":\"\");\n#endif\n\tif (sc->async_cmd_inprogress != 0) {\n\t\t/*\n\t\t * If previous command was issued asynchronously, wait\n\t\t * for it now.\n\t\t */\n\t\tif (i82596_cmd_wait(sc) != 0)\n\t\t\treturn (1);\n\t\tsc->async_cmd_inprogress = 0;\n\t}\n\n\toff = IE_SCB_CMD(sc->scb);\n\t(sc->ie_bus_write16)(sc, off, cmd);\n\tbus_space_barrier(sc->bt, sc->bh, off, 2, BUS_SPACE_BARRIER_WRITE);\n\t(sc->chan_attn)(sc);\n\n\tif (async) {\n\t\tsc->async_cmd_inprogress = 1;\n\t\treturn (0);\n\t}\n\n\tif (IE_ACTION_COMMAND(cmd) && iecmdbuf) {\n\t\tint status;\n\t\t/*\n\t\t * Now spin-lock waiting for status.  This is not a very nice\n\t\t * thing to do, and can kill performance pretty well...\n\t\t * According to the packet driver, the minimum timeout\n\t\t * should be .369 seconds.\n\t\t */\n\t\tfor (i = 0; i < 36900; i++) {\n\t\t\t/* Read the command status */\n\t\t\toff = IE_CMD_COMMON_STATUS(iecmdbuf);\n\t\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\t\tstatus = (sc->ie_bus_read16)(sc, off);\n\t\t\tif (status & mask) {\n#ifdef I82596_DEBUG\n\t\t\t\tif (sc->sc_debug & IED_CMDS)\n\t\t\t\t\tprintf (\"%s: cmd status %b\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\t\tstatus, IE_STAT_BITS);\n#endif\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tdelay(10);\n\t\t}\n\n\t} else {\n\t\t/*\n\t\t * Otherwise, just wait for the command to be accepted.\n\t\t */\n\t\treturn (i82596_cmd_wait(sc));\n\t}\n\n\t/* Timeout */\n\treturn (1);\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\ti82596_cmd_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ti82596_cmd_wait;\n\nint\ni82596_start_cmd(sc, cmd, iecmdbuf, mask, async)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tint iecmdbuf;\n\tint mask;\n\tint async;\n{\n\tregister int i, off;\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_CMDS)\n\t\tprintf(\"start_cmd: %p, %x, %x, %b, %ssync\\n\",\n\t\t       sc, cmd, iecmdbuf, mask, IE_STAT_BITS, async?\"a\":\"\");\n#endif\n\tif (sc->async_cmd_inprogress != 0) {\n\t\t/*\n\t\t * If previous command was issued asynchronously, wait\n\t\t * for it now.\n\t\t */\n\t\tif (i82596_cmd_wait(sc) != 0)\n\t\t\treturn (1);\n\t\tsc->async_cmd_inprogress = 0;\n\t}\n\n\toff = IE_SCB_CMD(sc->scb);\n\t(sc->ie_bus_write16)(sc, off, cmd);\n\tbus_space_barrier(sc->bt, sc->bh, off, 2, BUS_SPACE_BARRIER_WRITE);\n\t(sc->chan_attn)(sc);\n\n\tif (async) {\n\t\tsc->async_cmd_inprogress = 1;\n\t\treturn (0);\n\t}\n\n\tif (IE_ACTION_COMMAND(cmd) && iecmdbuf) {\n\t\tint status;\n\t\t/*\n\t\t * Now spin-lock waiting for status.  This is not a very nice\n\t\t * thing to do, and can kill performance pretty well...\n\t\t * According to the packet driver, the minimum timeout\n\t\t * should be .369 seconds.\n\t\t */\n\t\tfor (i = 0; i < 36900; i++) {\n\t\t\t/* Read the command status */\n\t\t\toff = IE_CMD_COMMON_STATUS(iecmdbuf);\n\t\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\t\tstatus = (sc->ie_bus_read16)(sc, off);\n\t\t\tif (status & mask) {\n#ifdef I82596_DEBUG\n\t\t\t\tif (sc->sc_debug & IED_CMDS)\n\t\t\t\t\tprintf (\"%s: cmd status %b\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\t\tstatus, IE_STAT_BITS);\n#endif\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tdelay(10);\n\t\t}\n\n\t} else {\n\t\t/*\n\t\t * Otherwise, just wait for the command to be accepted.\n\t\t */\n\t\treturn (i82596_cmd_wait(sc));\n\t}\n\n\t/* Timeout */\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ti82596_reset;\nint\ti82596_init;\n\nvoid\ni82596_reset(sc, hard)\n\tstruct ie_softc *sc;\n\tint hard;\n{\n\tint s = splnet();\n\n\tif (hard)\n\t\tprintf(\"%s: reset\\n\", sc->sc_dev.dv_xname);\n\n\t/* Clear OACTIVE in case we're called from watchdog (frozen xmit). */\n\tsc->sc_arpcom.ac_if.if_timer = 0;\n\tsc->sc_arpcom.ac_if.if_flags &= ~IFF_OACTIVE;\n\n\t/*\n\t * Stop i82596 dead in its tracks.\n\t */\n\tif (i82596_start_cmd(sc, IE_RUC_ABORT | IE_CUC_ABORT, 0, 0, 0))\n\t\tprintf(\"%s: abort commands timed out\\n\", sc->sc_dev.dv_xname);\n\n\t/*\n\t * This can really slow down the i82596_reset() on some cards, but it's\n\t * necessary to unwedge other ones (eg, the Sun VME ones) from certain\n\t * lockups.\n\t */\n\tif (hard && sc->hwreset)\n\t\t(sc->hwreset)(sc, IE_CARD_RESET);\n\n\tdelay(100);\n\tie_ack(sc, IE_ST_WHENCE);\n\n\tif ((sc->sc_arpcom.ac_if.if_flags & IFF_UP) != 0) {\n\t\tint retries=0;\t/* XXX - find out why init sometimes fails */\n\t\twhile (retries++ < 2)\n\t\t\tif (i82596_init(sc) == 1)\n\t\t\t\tbreak;\n\t}\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "i82596_proberam",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
    "lines": "1299-1331",
    "snippet": "int\ni82596_proberam(sc)\n\tstruct ie_softc *sc;\n{\n\tint result, off;\n\n\t/* Put in 16-bit mode */\n\toff = IE_SCP_BUS_USE(sc->scp);\n\tbus_space_write_1(sc->bt, sc->bh, off, 0);\n\tbus_space_barrier(sc->bt, sc->bh, off, 1, BUS_SPACE_BARRIER_WRITE);\n\n\t/* Set the ISCP `busy' bit */\n\toff = IE_ISCP_BUSY(sc->iscp);\n\tbus_space_write_1(sc->bt, sc->bh, off, 1);\n\tbus_space_barrier(sc->bt, sc->bh, off, 1, BUS_SPACE_BARRIER_WRITE);\n\n\tif (sc->hwreset)\n\t\t(sc->hwreset)(sc, IE_CHIP_PROBE);\n\n\t(sc->chan_attn) (sc);\n\n\tdelay(100);\t\t/* wait a while... */\n\n\t/* Read back the ISCP `busy' bit; it should be clear by now */\n\toff = IE_ISCP_BUSY(sc->iscp);\n\tbus_space_barrier(sc->bt, sc->bh, off, 1, BUS_SPACE_BARRIER_READ);\n\tresult = bus_space_read_1(sc->bt, sc->bh, off) == 0;\n\n\t/* Acknowledge any interrupts we may have caused. */\n\tie_ack(sc, IE_ST_WHENCE);\n\n\treturn (result);\n}",
    "includes": [
      "#include <dev/ic/i82596var.h>",
      "#include <dev/ic/i82596reg.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ie_ack",
          "args": [
            "sc",
            "IE_ST_WHENCE"
          ],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "ie_ack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596var.h",
          "lines": "297-305",
          "snippet": "static __inline__ void\nie_ack(struct ie_softc *sc, u_int mask) /* in native byte-order */\n{\n\tregister u_int status;\n\n\tbus_space_barrier(sc->bt, sc->bh, 0, 0, BUS_SPACE_BARRIER_READ);\n\tstatus = (sc->ie_bus_read16)(sc, IE_SCB_STATUS(sc->scb));\n\ti82596_start_cmd(sc, status & mask, 0, 0, 0);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "int \ti82596_start_cmd"
          ],
          "called_functions": [],
          "contextual_snippet": "int \ti82596_start_cmd;\n\nstatic __inline__ void\nie_ack(struct ie_softc *sc, u_int mask) /* in native byte-order */\n{\n\tregister u_int status;\n\n\tbus_space_barrier(sc->bt, sc->bh, 0, 0, BUS_SPACE_BARRIER_READ);\n\tstatus = (sc->ie_bus_read16)(sc, IE_SCB_STATUS(sc->scb));\n\ti82596_start_cmd(sc, status & mask, 0, 0, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "sc->bt",
            "sc->bh",
            "off"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_barrier",
          "args": [
            "sc->bt",
            "sc->bh",
            "off",
            "1",
            "BUS_SPACE_BARRIER_READ"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_ISCP_BUSY",
          "args": [
            "sc->iscp"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "100"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "IE_CHIP_PROBE"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_barrier",
          "args": [
            "sc->bt",
            "sc->bh",
            "off",
            "1",
            "BUS_SPACE_BARRIER_WRITE"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->bt",
            "sc->bh",
            "off",
            "1"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_ISCP_BUSY",
          "args": [
            "sc->iscp"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_barrier",
          "args": [
            "sc->bt",
            "sc->bh",
            "off",
            "1",
            "BUS_SPACE_BARRIER_WRITE"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->bt",
            "sc->bh",
            "off",
            "0"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_SCP_BUS_USE",
          "args": [
            "sc->scp"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ni82596_proberam(sc)\n\tstruct ie_softc *sc;\n{\n\tint result, off;\n\n\t/* Put in 16-bit mode */\n\toff = IE_SCP_BUS_USE(sc->scp);\n\tbus_space_write_1(sc->bt, sc->bh, off, 0);\n\tbus_space_barrier(sc->bt, sc->bh, off, 1, BUS_SPACE_BARRIER_WRITE);\n\n\t/* Set the ISCP `busy' bit */\n\toff = IE_ISCP_BUSY(sc->iscp);\n\tbus_space_write_1(sc->bt, sc->bh, off, 1);\n\tbus_space_barrier(sc->bt, sc->bh, off, 1, BUS_SPACE_BARRIER_WRITE);\n\n\tif (sc->hwreset)\n\t\t(sc->hwreset)(sc, IE_CHIP_PROBE);\n\n\t(sc->chan_attn) (sc);\n\n\tdelay(100);\t\t/* wait a while... */\n\n\t/* Read back the ISCP `busy' bit; it should be clear by now */\n\toff = IE_ISCP_BUSY(sc->iscp);\n\tbus_space_barrier(sc->bt, sc->bh, off, 1, BUS_SPACE_BARRIER_READ);\n\tresult = bus_space_read_1(sc->bt, sc->bh, off) == 0;\n\n\t/* Acknowledge any interrupts we may have caused. */\n\tie_ack(sc, IE_ST_WHENCE);\n\n\treturn (result);\n}"
  },
  {
    "function_name": "i82596_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
    "lines": "1212-1293",
    "snippet": "void\ni82596_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct ie_softc *sc = ifp->if_softc;\n\tstruct mbuf *m0, *m;\n\tint\tbuffer, head, xbase;\n\tu_short\tlen;\n\tint\ts;\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_ENQ)\n\t\tprintf (\"i82596_start(%p)\\n\", ifp);\n#endif\n\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\n\tfor (;;) {\n\t\tif (sc->xmit_busy == NTXBUF) {\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tbreak;\n\t\t}\n\n\t\thead = sc->xchead;\n\t\txbase = sc->xbds;\n\n\t\tIF_DEQUEUE(&ifp->if_snd, m0);\n\t\tif (m0 == 0)\n\t\t\tbreak;\n\n\t\t/* We need to use m->m_pkthdr.len, so require the header */\n\t\tif ((m0->m_flags & M_PKTHDR) == 0)\n\t\t\tpanic(\"i82596_start: no header mbuf\");\n\n#if NBPFILTER > 0\n\t\t/* Tap off here if there is a BPF listener. */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n#ifdef I82596_DEBUG\n\t\tif (sc->sc_debug & IED_ENQ)\n\t\t\tprintf(\"%s: fill buffer %d\\n\", sc->sc_dev.dv_xname,\n\t\t\t\tsc->xchead);\n#endif\n\n\t\tif (m0->m_pkthdr.len > IE_TBUF_SIZE)\n\t\t\tprintf(\"%s: tbuf overflow\\n\", sc->sc_dev.dv_xname);\n\n\t\tbuffer = IE_XBUF_ADDR(sc, head);\n\t\tfor (m = m0; m != 0; m = m->m_next) {\n\t\t\t(sc->memcopyout)(sc, mtod(m,caddr_t), buffer, m->m_len);\n\t\t\tbuffer += m->m_len;\n\t\t}\n\n\t\tlen = max(m0->m_pkthdr.len, ETHER_MIN_LEN);\n\t\tm_freem(m0);\n\n\t\t/*\n\t\t * Setup the transmit buffer descriptor here, while we\n\t\t * know the packet's length.\n\t\t */\n\t\tsc->ie_bus_write16(sc, IE_XBD_FLAGS(xbase, head),\n\t\t\t\t       len | IE_TBD_EOL);\n\t\tsc->ie_bus_write16(sc, IE_XBD_NEXT(xbase, head), 0xffff);\n\t\tsc->ie_bus_write24(sc, IE_XBD_BUF(xbase, head),\n\t\t\t\t       sc->sc_maddr + IE_XBUF_ADDR(sc, head));\n\n\t\tif (++head == NTXBUF)\n\t\t\thead = 0;\n\t\tsc->xchead = head;\n\n\t\ts = splnet();\n\t\t/* Start the first packet transmitting. */\n\t\tif (sc->xmit_busy == 0)\n\t\t\ti82596_xmit(sc);\n\n\t\tsc->xmit_busy++;\n\t\tsplx(s);\n\t}\n}",
    "includes": [
      "#include <dev/ic/i82596var.h>",
      "#include <dev/ic/i82596reg.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\ti82596_start",
      "void \ti82596_xmit"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i82596_xmit",
          "args": [
            "sc"
          ],
          "line": 1288
        },
        "resolved": true,
        "details": {
          "function_name": "i82596_xmit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "1136-1206",
          "snippet": "void\ni82596_xmit(sc)\n\tstruct ie_softc *sc;\n{\n\tint off, cur, prev;\n\n\tcur = sc->xctail;\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_XMIT)\n\t\tprintf(\"%s: xmit buffer %d\\n\", sc->sc_dev.dv_xname, cur);\n#endif\n\n\t/*\n\t * Setup the transmit command.\n\t */\n\tsc->ie_bus_write16(sc, IE_CMD_XMIT_DESC(sc->xmit_cmds, cur),\n\t\t\t       IE_XBD_ADDR(sc->xbds, cur));\n\n\tsc->ie_bus_write16(sc, IE_CMD_XMIT_STATUS(sc->xmit_cmds, cur), 0);\n\n\tif (sc->do_xmitnopchain) {\n\t\t/*\n\t\t * Gate this XMIT command to the following NOP\n\t\t */\n\t\tsc->ie_bus_write16(sc, IE_CMD_XMIT_LINK(sc->xmit_cmds, cur),\n\t\t\t\t       IE_CMD_NOP_ADDR(sc->nop_cmds, cur));\n\t\tsc->ie_bus_write16(sc, IE_CMD_XMIT_CMD(sc->xmit_cmds, cur),\n\t\t\t\t       IE_CMD_XMIT | IE_CMD_INTR);\n\n\t\t/*\n\t\t * Loopback at following NOP\n\t\t */\n\t\tsc->ie_bus_write16(sc, IE_CMD_NOP_STATUS(sc->nop_cmds, cur), 0);\n\t\tsc->ie_bus_write16(sc, IE_CMD_NOP_LINK(sc->nop_cmds, cur),\n\t\t\t\t       IE_CMD_NOP_ADDR(sc->nop_cmds, cur));\n\n\t\t/*\n\t\t * Gate preceding NOP to this XMIT command\n\t\t */\n\t\tprev = (cur + NTXBUF - 1) % NTXBUF;\n\t\tsc->ie_bus_write16(sc, IE_CMD_NOP_STATUS(sc->nop_cmds, prev), 0);\n\t\tsc->ie_bus_write16(sc, IE_CMD_NOP_LINK(sc->nop_cmds, prev),\n\t\t\t\t       IE_CMD_XMIT_ADDR(sc->xmit_cmds, cur));\n\n\t\toff = IE_SCB_STATUS(sc->scb);\n\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\tif ((sc->ie_bus_read16(sc, off) & IE_CUS_ACTIVE) == 0) {\n\t\t\tprintf(\"i82596_xmit: CU not active\\n\");\n\t\t\ti82596_start_transceiver(sc);\n\t\t}\n\t} else {\n\t\tsc->ie_bus_write16(sc, IE_CMD_XMIT_LINK(sc->xmit_cmds,cur),\n\t\t\t\t       0xffff);\n\n\t\tsc->ie_bus_write16(sc, IE_CMD_XMIT_CMD(sc->xmit_cmds, cur),\n\t\t\t\t       IE_CMD_XMIT | IE_CMD_INTR | IE_CMD_LAST);\n\n\t\toff = IE_SCB_CMDLST(sc->scb);\n\t\tsc->ie_bus_write16(sc, off, IE_CMD_XMIT_ADDR(sc->xmit_cmds, cur));\n\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t  BUS_SPACE_BARRIER_WRITE);\n\n\t\tif (i82596_start_cmd(sc, IE_CUC_START, 0, 0, 1))\n\t\t\tprintf(\"%s: i82596_xmit: start xmit command timed out\\n\",\n\t\t\t       sc->sc_dev.dv_xname);\n\t}\n\n\tsc->sc_arpcom.ac_if.if_timer = 5;\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\ti82596_start_transceiver",
            "void \ti82596_xmit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ti82596_start_transceiver;\nvoid \ti82596_xmit;\n\nvoid\ni82596_xmit(sc)\n\tstruct ie_softc *sc;\n{\n\tint off, cur, prev;\n\n\tcur = sc->xctail;\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_XMIT)\n\t\tprintf(\"%s: xmit buffer %d\\n\", sc->sc_dev.dv_xname, cur);\n#endif\n\n\t/*\n\t * Setup the transmit command.\n\t */\n\tsc->ie_bus_write16(sc, IE_CMD_XMIT_DESC(sc->xmit_cmds, cur),\n\t\t\t       IE_XBD_ADDR(sc->xbds, cur));\n\n\tsc->ie_bus_write16(sc, IE_CMD_XMIT_STATUS(sc->xmit_cmds, cur), 0);\n\n\tif (sc->do_xmitnopchain) {\n\t\t/*\n\t\t * Gate this XMIT command to the following NOP\n\t\t */\n\t\tsc->ie_bus_write16(sc, IE_CMD_XMIT_LINK(sc->xmit_cmds, cur),\n\t\t\t\t       IE_CMD_NOP_ADDR(sc->nop_cmds, cur));\n\t\tsc->ie_bus_write16(sc, IE_CMD_XMIT_CMD(sc->xmit_cmds, cur),\n\t\t\t\t       IE_CMD_XMIT | IE_CMD_INTR);\n\n\t\t/*\n\t\t * Loopback at following NOP\n\t\t */\n\t\tsc->ie_bus_write16(sc, IE_CMD_NOP_STATUS(sc->nop_cmds, cur), 0);\n\t\tsc->ie_bus_write16(sc, IE_CMD_NOP_LINK(sc->nop_cmds, cur),\n\t\t\t\t       IE_CMD_NOP_ADDR(sc->nop_cmds, cur));\n\n\t\t/*\n\t\t * Gate preceding NOP to this XMIT command\n\t\t */\n\t\tprev = (cur + NTXBUF - 1) % NTXBUF;\n\t\tsc->ie_bus_write16(sc, IE_CMD_NOP_STATUS(sc->nop_cmds, prev), 0);\n\t\tsc->ie_bus_write16(sc, IE_CMD_NOP_LINK(sc->nop_cmds, prev),\n\t\t\t\t       IE_CMD_XMIT_ADDR(sc->xmit_cmds, cur));\n\n\t\toff = IE_SCB_STATUS(sc->scb);\n\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\tif ((sc->ie_bus_read16(sc, off) & IE_CUS_ACTIVE) == 0) {\n\t\t\tprintf(\"i82596_xmit: CU not active\\n\");\n\t\t\ti82596_start_transceiver(sc);\n\t\t}\n\t} else {\n\t\tsc->ie_bus_write16(sc, IE_CMD_XMIT_LINK(sc->xmit_cmds,cur),\n\t\t\t\t       0xffff);\n\n\t\tsc->ie_bus_write16(sc, IE_CMD_XMIT_CMD(sc->xmit_cmds, cur),\n\t\t\t\t       IE_CMD_XMIT | IE_CMD_INTR | IE_CMD_LAST);\n\n\t\toff = IE_SCB_CMDLST(sc->scb);\n\t\tsc->ie_bus_write16(sc, off, IE_CMD_XMIT_ADDR(sc->xmit_cmds, cur));\n\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t  BUS_SPACE_BARRIER_WRITE);\n\n\t\tif (i82596_start_cmd(sc, IE_CUC_START, 0, 0, 1))\n\t\t\tprintf(\"%s: i82596_xmit: start xmit command timed out\\n\",\n\t\t\t       sc->sc_dev.dv_xname);\n\t}\n\n\tsc->sc_arpcom.ac_if.if_timer = 5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_write24",
          "args": [
            "sc",
            "IE_XBD_BUF(xbase, head)",
            "sc->sc_maddr + IE_XBUF_ADDR(sc, head)"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_XBUF_ADDR",
          "args": [
            "sc",
            "head"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_XBD_BUF",
          "args": [
            "xbase",
            "head"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_write16",
          "args": [
            "sc",
            "IE_XBD_NEXT(xbase, head)",
            "0xffff"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_XBD_NEXT",
          "args": [
            "xbase",
            "head"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_write16",
          "args": [
            "sc",
            "IE_XBD_FLAGS(xbase, head)",
            "len | IE_TBD_EOL"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_XBD_FLAGS",
          "args": [
            "xbase",
            "head"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m0"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "m0->m_pkthdr.len",
            "ETHER_MIN_LEN"
          ],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_setmaxtags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5620-5630",
          "snippet": "static void ncr_setmaxtags (tcb_p tp, u_long usrtags)\n{\n\tint l;\n\tfor (l=0; l<MAX_LUN; l++) {\n\t\tlcb_p lp;\n\t\tif (!tp) break;\n\t\tlp=tp->lp[l];\n\t\tif (!lp) continue;\n\t\tncr_settags (tp, lp, usrtags);\n\t};\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [
            "#define MAX_LUN     (8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\n#define MAX_LUN     (8)\n\nstatic void ncr_setmaxtags (tcb_p tp, u_long usrtags)\n{\n\tint l;\n\tfor (l=0; l<MAX_LUN; l++) {\n\t\tlcb_p lp;\n\t\tif (!tp) break;\n\t\tlp=tp->lp[l];\n\t\tif (!lp) continue;\n\t\tncr_settags (tp, lp, usrtags);\n\t};\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "mtod(m,caddr_t)",
            "buffer",
            "m->m_len"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "caddr_t"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_XBUF_ADDR",
          "args": [
            "sc",
            "head"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: tbuf overflow\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "m0"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"i82596_start: no header mbuf\""
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "m0"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ti82596_start;\nvoid \ti82596_xmit;\n\nvoid\ni82596_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct ie_softc *sc = ifp->if_softc;\n\tstruct mbuf *m0, *m;\n\tint\tbuffer, head, xbase;\n\tu_short\tlen;\n\tint\ts;\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_ENQ)\n\t\tprintf (\"i82596_start(%p)\\n\", ifp);\n#endif\n\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\n\tfor (;;) {\n\t\tif (sc->xmit_busy == NTXBUF) {\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tbreak;\n\t\t}\n\n\t\thead = sc->xchead;\n\t\txbase = sc->xbds;\n\n\t\tIF_DEQUEUE(&ifp->if_snd, m0);\n\t\tif (m0 == 0)\n\t\t\tbreak;\n\n\t\t/* We need to use m->m_pkthdr.len, so require the header */\n\t\tif ((m0->m_flags & M_PKTHDR) == 0)\n\t\t\tpanic(\"i82596_start: no header mbuf\");\n\n#if NBPFILTER > 0\n\t\t/* Tap off here if there is a BPF listener. */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n#ifdef I82596_DEBUG\n\t\tif (sc->sc_debug & IED_ENQ)\n\t\t\tprintf(\"%s: fill buffer %d\\n\", sc->sc_dev.dv_xname,\n\t\t\t\tsc->xchead);\n#endif\n\n\t\tif (m0->m_pkthdr.len > IE_TBUF_SIZE)\n\t\t\tprintf(\"%s: tbuf overflow\\n\", sc->sc_dev.dv_xname);\n\n\t\tbuffer = IE_XBUF_ADDR(sc, head);\n\t\tfor (m = m0; m != 0; m = m->m_next) {\n\t\t\t(sc->memcopyout)(sc, mtod(m,caddr_t), buffer, m->m_len);\n\t\t\tbuffer += m->m_len;\n\t\t}\n\n\t\tlen = max(m0->m_pkthdr.len, ETHER_MIN_LEN);\n\t\tm_freem(m0);\n\n\t\t/*\n\t\t * Setup the transmit buffer descriptor here, while we\n\t\t * know the packet's length.\n\t\t */\n\t\tsc->ie_bus_write16(sc, IE_XBD_FLAGS(xbase, head),\n\t\t\t\t       len | IE_TBD_EOL);\n\t\tsc->ie_bus_write16(sc, IE_XBD_NEXT(xbase, head), 0xffff);\n\t\tsc->ie_bus_write24(sc, IE_XBD_BUF(xbase, head),\n\t\t\t\t       sc->sc_maddr + IE_XBUF_ADDR(sc, head));\n\n\t\tif (++head == NTXBUF)\n\t\t\thead = 0;\n\t\tsc->xchead = head;\n\n\t\ts = splnet();\n\t\t/* Start the first packet transmitting. */\n\t\tif (sc->xmit_busy == 0)\n\t\t\ti82596_xmit(sc);\n\n\t\tsc->xmit_busy++;\n\t\tsplx(s);\n\t}\n}"
  },
  {
    "function_name": "i82596_xmit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
    "lines": "1136-1206",
    "snippet": "void\ni82596_xmit(sc)\n\tstruct ie_softc *sc;\n{\n\tint off, cur, prev;\n\n\tcur = sc->xctail;\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_XMIT)\n\t\tprintf(\"%s: xmit buffer %d\\n\", sc->sc_dev.dv_xname, cur);\n#endif\n\n\t/*\n\t * Setup the transmit command.\n\t */\n\tsc->ie_bus_write16(sc, IE_CMD_XMIT_DESC(sc->xmit_cmds, cur),\n\t\t\t       IE_XBD_ADDR(sc->xbds, cur));\n\n\tsc->ie_bus_write16(sc, IE_CMD_XMIT_STATUS(sc->xmit_cmds, cur), 0);\n\n\tif (sc->do_xmitnopchain) {\n\t\t/*\n\t\t * Gate this XMIT command to the following NOP\n\t\t */\n\t\tsc->ie_bus_write16(sc, IE_CMD_XMIT_LINK(sc->xmit_cmds, cur),\n\t\t\t\t       IE_CMD_NOP_ADDR(sc->nop_cmds, cur));\n\t\tsc->ie_bus_write16(sc, IE_CMD_XMIT_CMD(sc->xmit_cmds, cur),\n\t\t\t\t       IE_CMD_XMIT | IE_CMD_INTR);\n\n\t\t/*\n\t\t * Loopback at following NOP\n\t\t */\n\t\tsc->ie_bus_write16(sc, IE_CMD_NOP_STATUS(sc->nop_cmds, cur), 0);\n\t\tsc->ie_bus_write16(sc, IE_CMD_NOP_LINK(sc->nop_cmds, cur),\n\t\t\t\t       IE_CMD_NOP_ADDR(sc->nop_cmds, cur));\n\n\t\t/*\n\t\t * Gate preceding NOP to this XMIT command\n\t\t */\n\t\tprev = (cur + NTXBUF - 1) % NTXBUF;\n\t\tsc->ie_bus_write16(sc, IE_CMD_NOP_STATUS(sc->nop_cmds, prev), 0);\n\t\tsc->ie_bus_write16(sc, IE_CMD_NOP_LINK(sc->nop_cmds, prev),\n\t\t\t\t       IE_CMD_XMIT_ADDR(sc->xmit_cmds, cur));\n\n\t\toff = IE_SCB_STATUS(sc->scb);\n\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\tif ((sc->ie_bus_read16(sc, off) & IE_CUS_ACTIVE) == 0) {\n\t\t\tprintf(\"i82596_xmit: CU not active\\n\");\n\t\t\ti82596_start_transceiver(sc);\n\t\t}\n\t} else {\n\t\tsc->ie_bus_write16(sc, IE_CMD_XMIT_LINK(sc->xmit_cmds,cur),\n\t\t\t\t       0xffff);\n\n\t\tsc->ie_bus_write16(sc, IE_CMD_XMIT_CMD(sc->xmit_cmds, cur),\n\t\t\t\t       IE_CMD_XMIT | IE_CMD_INTR | IE_CMD_LAST);\n\n\t\toff = IE_SCB_CMDLST(sc->scb);\n\t\tsc->ie_bus_write16(sc, off, IE_CMD_XMIT_ADDR(sc->xmit_cmds, cur));\n\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t  BUS_SPACE_BARRIER_WRITE);\n\n\t\tif (i82596_start_cmd(sc, IE_CUC_START, 0, 0, 1))\n\t\t\tprintf(\"%s: i82596_xmit: start xmit command timed out\\n\",\n\t\t\t       sc->sc_dev.dv_xname);\n\t}\n\n\tsc->sc_arpcom.ac_if.if_timer = 5;\n}",
    "includes": [
      "#include <dev/ic/i82596var.h>",
      "#include <dev/ic/i82596reg.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\ti82596_start_transceiver",
      "void \ti82596_xmit"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: i82596_xmit: start xmit command timed out\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i82596_start_cmd",
          "args": [
            "sc",
            "IE_CUC_START",
            "0",
            "0",
            "1"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "i82596_start_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "398-468",
          "snippet": "int\ni82596_start_cmd(sc, cmd, iecmdbuf, mask, async)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tint iecmdbuf;\n\tint mask;\n\tint async;\n{\n\tregister int i, off;\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_CMDS)\n\t\tprintf(\"start_cmd: %p, %x, %x, %b, %ssync\\n\",\n\t\t       sc, cmd, iecmdbuf, mask, IE_STAT_BITS, async?\"a\":\"\");\n#endif\n\tif (sc->async_cmd_inprogress != 0) {\n\t\t/*\n\t\t * If previous command was issued asynchronously, wait\n\t\t * for it now.\n\t\t */\n\t\tif (i82596_cmd_wait(sc) != 0)\n\t\t\treturn (1);\n\t\tsc->async_cmd_inprogress = 0;\n\t}\n\n\toff = IE_SCB_CMD(sc->scb);\n\t(sc->ie_bus_write16)(sc, off, cmd);\n\tbus_space_barrier(sc->bt, sc->bh, off, 2, BUS_SPACE_BARRIER_WRITE);\n\t(sc->chan_attn)(sc);\n\n\tif (async) {\n\t\tsc->async_cmd_inprogress = 1;\n\t\treturn (0);\n\t}\n\n\tif (IE_ACTION_COMMAND(cmd) && iecmdbuf) {\n\t\tint status;\n\t\t/*\n\t\t * Now spin-lock waiting for status.  This is not a very nice\n\t\t * thing to do, and can kill performance pretty well...\n\t\t * According to the packet driver, the minimum timeout\n\t\t * should be .369 seconds.\n\t\t */\n\t\tfor (i = 0; i < 36900; i++) {\n\t\t\t/* Read the command status */\n\t\t\toff = IE_CMD_COMMON_STATUS(iecmdbuf);\n\t\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\t\tstatus = (sc->ie_bus_read16)(sc, off);\n\t\t\tif (status & mask) {\n#ifdef I82596_DEBUG\n\t\t\t\tif (sc->sc_debug & IED_CMDS)\n\t\t\t\t\tprintf (\"%s: cmd status %b\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\t\tstatus, IE_STAT_BITS);\n#endif\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tdelay(10);\n\t\t}\n\n\t} else {\n\t\t/*\n\t\t * Otherwise, just wait for the command to be accepted.\n\t\t */\n\t\treturn (i82596_cmd_wait(sc));\n\t}\n\n\t/* Timeout */\n\treturn (1);\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\ti82596_cmd_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ti82596_cmd_wait;\n\nint\ni82596_start_cmd(sc, cmd, iecmdbuf, mask, async)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tint iecmdbuf;\n\tint mask;\n\tint async;\n{\n\tregister int i, off;\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_CMDS)\n\t\tprintf(\"start_cmd: %p, %x, %x, %b, %ssync\\n\",\n\t\t       sc, cmd, iecmdbuf, mask, IE_STAT_BITS, async?\"a\":\"\");\n#endif\n\tif (sc->async_cmd_inprogress != 0) {\n\t\t/*\n\t\t * If previous command was issued asynchronously, wait\n\t\t * for it now.\n\t\t */\n\t\tif (i82596_cmd_wait(sc) != 0)\n\t\t\treturn (1);\n\t\tsc->async_cmd_inprogress = 0;\n\t}\n\n\toff = IE_SCB_CMD(sc->scb);\n\t(sc->ie_bus_write16)(sc, off, cmd);\n\tbus_space_barrier(sc->bt, sc->bh, off, 2, BUS_SPACE_BARRIER_WRITE);\n\t(sc->chan_attn)(sc);\n\n\tif (async) {\n\t\tsc->async_cmd_inprogress = 1;\n\t\treturn (0);\n\t}\n\n\tif (IE_ACTION_COMMAND(cmd) && iecmdbuf) {\n\t\tint status;\n\t\t/*\n\t\t * Now spin-lock waiting for status.  This is not a very nice\n\t\t * thing to do, and can kill performance pretty well...\n\t\t * According to the packet driver, the minimum timeout\n\t\t * should be .369 seconds.\n\t\t */\n\t\tfor (i = 0; i < 36900; i++) {\n\t\t\t/* Read the command status */\n\t\t\toff = IE_CMD_COMMON_STATUS(iecmdbuf);\n\t\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\t\tstatus = (sc->ie_bus_read16)(sc, off);\n\t\t\tif (status & mask) {\n#ifdef I82596_DEBUG\n\t\t\t\tif (sc->sc_debug & IED_CMDS)\n\t\t\t\t\tprintf (\"%s: cmd status %b\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\t\tstatus, IE_STAT_BITS);\n#endif\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tdelay(10);\n\t\t}\n\n\t} else {\n\t\t/*\n\t\t * Otherwise, just wait for the command to be accepted.\n\t\t */\n\t\treturn (i82596_cmd_wait(sc));\n\t}\n\n\t/* Timeout */\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_barrier",
          "args": [
            "sc->bt",
            "sc->bh",
            "off",
            "2",
            "BUS_SPACE_BARRIER_WRITE"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_write16",
          "args": [
            "sc",
            "off",
            "IE_CMD_XMIT_ADDR(sc->xmit_cmds, cur)"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_XMIT_ADDR",
          "args": [
            "sc->xmit_cmds",
            "cur"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_SCB_CMDLST",
          "args": [
            "sc->scb"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_write16",
          "args": [
            "sc",
            "IE_CMD_XMIT_CMD(sc->xmit_cmds, cur)",
            "IE_CMD_XMIT | IE_CMD_INTR | IE_CMD_LAST"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_XMIT_CMD",
          "args": [
            "sc->xmit_cmds",
            "cur"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_write16",
          "args": [
            "sc",
            "IE_CMD_XMIT_LINK(sc->xmit_cmds,cur)",
            "0xffff"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_XMIT_LINK",
          "args": [
            "sc->xmit_cmds",
            "cur"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i82596_start_transceiver",
          "args": [
            "sc"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "i82596_start_transceiver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "1777-1813",
          "snippet": "void\ni82596_start_transceiver(sc)\n\tstruct ie_softc *sc;\n{\n\n\t/*\n\t * Start RU at current position in frame & RBD lists.\n\t */\n\tsc->ie_bus_write16(sc, IE_RFRAME_BUFDESC(sc->rframes,sc->rfhead),\n\t\t\t       IE_RBD_ADDR(sc->rbds, sc->rbhead));\n\n\tsc->ie_bus_write16(sc, IE_SCB_RCVLST(sc->scb),\n\t\t\t       IE_RFRAME_ADDR(sc->rframes,sc->rfhead));\n\n\tif (sc->do_xmitnopchain) {\n\t\t/* Stop transmit command chain */\n\t\tif (i82596_start_cmd(sc, IE_CUC_SUSPEND|IE_RUC_SUSPEND, 0, 0, 0))\n\t\t\tprintf(\"%s: CU/RU stop command timed out\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\n\t\t/* Start the receiver & transmitter chain */\n\t\t/* sc->scb->ie_command_list =\n\t\t\tIEADDR(sc->nop_cmds[(sc->xctail+NTXBUF-1) % NTXBUF]);*/\n\t\tsc->ie_bus_write16(sc, IE_SCB_CMDLST(sc->scb),\n\t\t\t\t   IE_CMD_NOP_ADDR(\n\t\t\t\t\tsc->nop_cmds,\n\t\t\t\t\t(sc->xctail + NTXBUF - 1) % NTXBUF));\n\n\t\tif (i82596_start_cmd(sc, IE_CUC_START|IE_RUC_START, 0, 0, 0))\n\t\t\tprintf(\"%s: CU/RU command timed out\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t} else {\n\t\tif (i82596_start_cmd(sc, IE_RUC_START, 0, 0, 0))\n\t\t\tprintf(\"%s: RU command timed out\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t}\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\ti82596_start_transceiver"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ti82596_start_transceiver;\n\nvoid\ni82596_start_transceiver(sc)\n\tstruct ie_softc *sc;\n{\n\n\t/*\n\t * Start RU at current position in frame & RBD lists.\n\t */\n\tsc->ie_bus_write16(sc, IE_RFRAME_BUFDESC(sc->rframes,sc->rfhead),\n\t\t\t       IE_RBD_ADDR(sc->rbds, sc->rbhead));\n\n\tsc->ie_bus_write16(sc, IE_SCB_RCVLST(sc->scb),\n\t\t\t       IE_RFRAME_ADDR(sc->rframes,sc->rfhead));\n\n\tif (sc->do_xmitnopchain) {\n\t\t/* Stop transmit command chain */\n\t\tif (i82596_start_cmd(sc, IE_CUC_SUSPEND|IE_RUC_SUSPEND, 0, 0, 0))\n\t\t\tprintf(\"%s: CU/RU stop command timed out\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\n\t\t/* Start the receiver & transmitter chain */\n\t\t/* sc->scb->ie_command_list =\n\t\t\tIEADDR(sc->nop_cmds[(sc->xctail+NTXBUF-1) % NTXBUF]);*/\n\t\tsc->ie_bus_write16(sc, IE_SCB_CMDLST(sc->scb),\n\t\t\t\t   IE_CMD_NOP_ADDR(\n\t\t\t\t\tsc->nop_cmds,\n\t\t\t\t\t(sc->xctail + NTXBUF - 1) % NTXBUF));\n\n\t\tif (i82596_start_cmd(sc, IE_CUC_START|IE_RUC_START, 0, 0, 0))\n\t\t\tprintf(\"%s: CU/RU command timed out\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t} else {\n\t\tif (i82596_start_cmd(sc, IE_RUC_START, 0, 0, 0))\n\t\t\tprintf(\"%s: RU command timed out\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_read16",
          "args": [
            "sc",
            "off"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_barrier",
          "args": [
            "sc->bt",
            "sc->bh",
            "off",
            "2",
            "BUS_SPACE_BARRIER_READ"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_SCB_STATUS",
          "args": [
            "sc->scb"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_write16",
          "args": [
            "sc",
            "IE_CMD_NOP_LINK(sc->nop_cmds, prev)",
            "IE_CMD_XMIT_ADDR(sc->xmit_cmds, cur)"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_XMIT_ADDR",
          "args": [
            "sc->xmit_cmds",
            "cur"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_NOP_LINK",
          "args": [
            "sc->nop_cmds",
            "prev"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_write16",
          "args": [
            "sc",
            "IE_CMD_NOP_STATUS(sc->nop_cmds, prev)",
            "0"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_NOP_STATUS",
          "args": [
            "sc->nop_cmds",
            "prev"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_write16",
          "args": [
            "sc",
            "IE_CMD_NOP_LINK(sc->nop_cmds, cur)",
            "IE_CMD_NOP_ADDR(sc->nop_cmds, cur)"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_NOP_ADDR",
          "args": [
            "sc->nop_cmds",
            "cur"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_NOP_LINK",
          "args": [
            "sc->nop_cmds",
            "cur"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_write16",
          "args": [
            "sc",
            "IE_CMD_NOP_STATUS(sc->nop_cmds, cur)",
            "0"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_NOP_STATUS",
          "args": [
            "sc->nop_cmds",
            "cur"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_write16",
          "args": [
            "sc",
            "IE_CMD_XMIT_CMD(sc->xmit_cmds, cur)",
            "IE_CMD_XMIT | IE_CMD_INTR"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_XMIT_CMD",
          "args": [
            "sc->xmit_cmds",
            "cur"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_write16",
          "args": [
            "sc",
            "IE_CMD_XMIT_LINK(sc->xmit_cmds, cur)",
            "IE_CMD_NOP_ADDR(sc->nop_cmds, cur)"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_NOP_ADDR",
          "args": [
            "sc->nop_cmds",
            "cur"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_XMIT_LINK",
          "args": [
            "sc->xmit_cmds",
            "cur"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_write16",
          "args": [
            "sc",
            "IE_CMD_XMIT_STATUS(sc->xmit_cmds, cur)",
            "0"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_XMIT_STATUS",
          "args": [
            "sc->xmit_cmds",
            "cur"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_write16",
          "args": [
            "sc",
            "IE_CMD_XMIT_DESC(sc->xmit_cmds, cur)",
            "IE_XBD_ADDR(sc->xbds, cur)"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_XBD_ADDR",
          "args": [
            "sc->xbds",
            "cur"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_XMIT_DESC",
          "args": [
            "sc->xmit_cmds",
            "cur"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ti82596_start_transceiver;\nvoid \ti82596_xmit;\n\nvoid\ni82596_xmit(sc)\n\tstruct ie_softc *sc;\n{\n\tint off, cur, prev;\n\n\tcur = sc->xctail;\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_XMIT)\n\t\tprintf(\"%s: xmit buffer %d\\n\", sc->sc_dev.dv_xname, cur);\n#endif\n\n\t/*\n\t * Setup the transmit command.\n\t */\n\tsc->ie_bus_write16(sc, IE_CMD_XMIT_DESC(sc->xmit_cmds, cur),\n\t\t\t       IE_XBD_ADDR(sc->xbds, cur));\n\n\tsc->ie_bus_write16(sc, IE_CMD_XMIT_STATUS(sc->xmit_cmds, cur), 0);\n\n\tif (sc->do_xmitnopchain) {\n\t\t/*\n\t\t * Gate this XMIT command to the following NOP\n\t\t */\n\t\tsc->ie_bus_write16(sc, IE_CMD_XMIT_LINK(sc->xmit_cmds, cur),\n\t\t\t\t       IE_CMD_NOP_ADDR(sc->nop_cmds, cur));\n\t\tsc->ie_bus_write16(sc, IE_CMD_XMIT_CMD(sc->xmit_cmds, cur),\n\t\t\t\t       IE_CMD_XMIT | IE_CMD_INTR);\n\n\t\t/*\n\t\t * Loopback at following NOP\n\t\t */\n\t\tsc->ie_bus_write16(sc, IE_CMD_NOP_STATUS(sc->nop_cmds, cur), 0);\n\t\tsc->ie_bus_write16(sc, IE_CMD_NOP_LINK(sc->nop_cmds, cur),\n\t\t\t\t       IE_CMD_NOP_ADDR(sc->nop_cmds, cur));\n\n\t\t/*\n\t\t * Gate preceding NOP to this XMIT command\n\t\t */\n\t\tprev = (cur + NTXBUF - 1) % NTXBUF;\n\t\tsc->ie_bus_write16(sc, IE_CMD_NOP_STATUS(sc->nop_cmds, prev), 0);\n\t\tsc->ie_bus_write16(sc, IE_CMD_NOP_LINK(sc->nop_cmds, prev),\n\t\t\t\t       IE_CMD_XMIT_ADDR(sc->xmit_cmds, cur));\n\n\t\toff = IE_SCB_STATUS(sc->scb);\n\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\tif ((sc->ie_bus_read16(sc, off) & IE_CUS_ACTIVE) == 0) {\n\t\t\tprintf(\"i82596_xmit: CU not active\\n\");\n\t\t\ti82596_start_transceiver(sc);\n\t\t}\n\t} else {\n\t\tsc->ie_bus_write16(sc, IE_CMD_XMIT_LINK(sc->xmit_cmds,cur),\n\t\t\t\t       0xffff);\n\n\t\tsc->ie_bus_write16(sc, IE_CMD_XMIT_CMD(sc->xmit_cmds, cur),\n\t\t\t\t       IE_CMD_XMIT | IE_CMD_INTR | IE_CMD_LAST);\n\n\t\toff = IE_SCB_CMDLST(sc->scb);\n\t\tsc->ie_bus_write16(sc, off, IE_CMD_XMIT_ADDR(sc->xmit_cmds, cur));\n\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t  BUS_SPACE_BARRIER_WRITE);\n\n\t\tif (i82596_start_cmd(sc, IE_CUC_START, 0, 0, 1))\n\t\t\tprintf(\"%s: i82596_xmit: start xmit command timed out\\n\",\n\t\t\t       sc->sc_dev.dv_xname);\n\t}\n\n\tsc->sc_arpcom.ac_if.if_timer = 5;\n}"
  },
  {
    "function_name": "i82596_readframe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
    "lines": "1070-1129",
    "snippet": "int\ni82596_readframe(sc, num)\n\tstruct ie_softc *sc;\n\tint num;\t\t/* frame number to read */\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tstruct mbuf *m;\n\tstruct ether_header eh;\n\tu_int16_t bstart, bend;\n\tint pktlen;\n\n\tif (i82596_get_rbd_list(sc, &bstart, &bend, &pktlen) == 0) {\n\t\tifp->if_ierrors++;\n\t\treturn (1);\n\t}\n\n\tm = i82596_get(sc, &eh, bstart, pktlen);\n\ti82596_release_rbd_list(sc, bstart, bend);\n\n\tif (m == 0) {\n\t\tsc->sc_arpcom.ac_if.if_ierrors++;\n\t\treturn (0);\n\t}\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_READFRAME)\n\t\tprintf(\"%s: frame from ether %s type 0x%x len %d\\n\",\n\t\t       sc->sc_dev.dv_xname,\n\t\t       ether_sprintf(eh.ether_shost),\n\t\t       (u_int)eh.ether_type, pktlen);\n#endif\n\n#if NBPFILTER > 0\n\t/*\n\t * Check for a BPF filter; if so, hand it up.\n\t * Note that we have to stick an extra mbuf up front, because bpf_mtap\n\t * expects to have the ether header at the front.\n\t * It doesn't matter that this results in an ill-formatted mbuf chain,\n\t * since BPF just looks at the data.  (It doesn't try to free the mbuf,\n\t * tho' it will make a copy for tcpdump.)\n\t */\n\tif (ifp->if_bpf) {\n\t\tstruct mbuf m0;\n\t\tm0.m_len = sizeof eh;\n\t\tm0.m_data = (caddr_t)&eh;\n\t\tm0.m_next = m;\n\n\t\t/* Pass it up. */\n\t\tbpf_mtap(ifp->if_bpf, &m0);\n\n\t}\n#endif /* NBPFILTER > 0 */\n\n\t/*\n\t * Finally pass this packet up to higher layers.\n\t */\n\tether_input(ifp, &eh, m);\n\tifp->if_ipackets++;\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/i82596var.h>",
      "#include <dev/ic/i82596reg.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int \ti82596_readframe",
      "int\ti82596_get_rbd_list",
      "void\ti82596_release_rbd_list"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ether_input",
          "args": [
            "ifp",
            "&eh",
            "m"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "&m0"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: frame from ether %s type 0x%x len %d\\n\"",
            "sc->sc_dev.dv_xname",
            "ether_sprintf(eh.ether_shost)",
            "(u_int)eh.ether_type",
            "pktlen"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_sprintf",
          "args": [
            "eh.ether_shost"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i82596_release_rbd_list",
          "args": [
            "sc",
            "bstart",
            "bend"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "i82596_release_rbd_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "866-896",
          "snippet": "void\ni82596_release_rbd_list(sc, start, end)\n\tstruct ie_softc *sc;\n\tu_int16_t\tstart;\n\tu_int16_t\tend;\n{\n\tregister int\toff, rbbase = sc->rbds;\n\tregister int\trbindex = start;\n\n\tdo {\n\t\t/* Clear buffer status */\n\t\toff = IE_RBD_STATUS(rbbase, rbindex);\n\t\tsc->ie_bus_write16(sc, off, 0);\n\t\tif (++rbindex == sc->nrxbuf)\n\t\t\trbindex = 0;\n\t} while (rbindex != end);\n\n\t/* Mark EOL at new tail */\n\trbindex = ((rbindex == 0) ? sc->nrxbuf : rbindex) - 1;\n\toff = IE_RBD_BUFLEN(rbbase, rbindex);\n\tsc->ie_bus_write16(sc, off, IE_RBUF_SIZE|IE_RBD_EOL);\n\n\t/* Remove EOL from current tail */\n\toff = IE_RBD_BUFLEN(rbbase, sc->rbtail);\n\tsc->ie_bus_write16(sc, off, IE_RBUF_SIZE);\n\n\t/* New head & tail pointer */\n/* hmm, why have both? head is always (tail + 1) % NRXBUF */\n\tsc->rbhead = end;\n\tsc->rbtail = rbindex;\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\ti82596_release_rbd_list"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ti82596_release_rbd_list;\n\nvoid\ni82596_release_rbd_list(sc, start, end)\n\tstruct ie_softc *sc;\n\tu_int16_t\tstart;\n\tu_int16_t\tend;\n{\n\tregister int\toff, rbbase = sc->rbds;\n\tregister int\trbindex = start;\n\n\tdo {\n\t\t/* Clear buffer status */\n\t\toff = IE_RBD_STATUS(rbbase, rbindex);\n\t\tsc->ie_bus_write16(sc, off, 0);\n\t\tif (++rbindex == sc->nrxbuf)\n\t\t\trbindex = 0;\n\t} while (rbindex != end);\n\n\t/* Mark EOL at new tail */\n\trbindex = ((rbindex == 0) ? sc->nrxbuf : rbindex) - 1;\n\toff = IE_RBD_BUFLEN(rbbase, rbindex);\n\tsc->ie_bus_write16(sc, off, IE_RBUF_SIZE|IE_RBD_EOL);\n\n\t/* Remove EOL from current tail */\n\toff = IE_RBD_BUFLEN(rbbase, sc->rbtail);\n\tsc->ie_bus_write16(sc, off, IE_RBUF_SIZE);\n\n\t/* New head & tail pointer */\n/* hmm, why have both? head is always (tail + 1) % NRXBUF */\n\tsc->rbhead = end;\n\tsc->rbtail = rbindex;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i82596_get",
          "args": [
            "sc",
            "&eh",
            "bstart",
            "pktlen"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "i82596_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "971-1059",
          "snippet": "static __inline__ struct mbuf *\ni82596_get(struct ie_softc *sc, struct ether_header *ehp, int head, int totlen)\n{\n\tstruct mbuf *top, **mp, *m;\n\tint len, resid;\n\tint thisrboff, thismboff;\n\n\t/*\n\t * Snarf the Ethernet header.\n\t */\n\t(sc->memcopyin)(sc, ehp, IE_RBUF_ADDR(sc,head), sizeof *ehp);\n\n\tresid = totlen -= (thisrboff = sizeof *ehp);\n\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\tif (m == 0)\n\t\treturn (0);\n\tm->m_pkthdr.rcvif = &sc->sc_arpcom.ac_if;\n\tm->m_pkthdr.len = totlen;\n\tlen = MHLEN;\n\ttop = 0;\n\tmp = &top;\n\n\t/*\n\t * This loop goes through and allocates mbufs for all the data we will\n\t * be copying in.  It does not actually do the copying yet.\n\t */\n\twhile (totlen > 0) {\n\t\tif (top) {\n\t\t\tMGET(m, M_DONTWAIT, MT_DATA);\n\t\t\tif (m == 0) {\n\t\t\t\tm_freem(top);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tlen = MLEN;\n\t\t}\n\t\tif (totlen >= MINCLSIZE) {\n\t\t\tMCLGET(m, M_DONTWAIT);\n\t\t\tif ((m->m_flags & M_EXT) == 0) {\n\t\t\t\tm_freem(top);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tlen = MCLBYTES;\n\t\t}\n\t\tm->m_len = len = min(totlen, len);\n\t\ttotlen -= len;\n\t\t*mp = m;\n\t\tmp = &m->m_next;\n\t}\n\n\tm = top;\n\tthismboff = 0;\n\n\t/*\n\t * Now we take the mbuf chain (hopefully only one mbuf most of the\n\t * time) and stuff the data into it.  There are no possible failures\n\t * at or after this point.\n\t */\n\twhile (resid > 0) {\n\t\tint thisrblen = IE_RBUF_SIZE - thisrboff,\n\t\t    thismblen = m->m_len - thismboff;\n\t\tlen = min(thisrblen, thismblen);\n\n\t\t(sc->memcopyin)(sc, mtod(m, caddr_t) + thismboff,\n\t\t\t\tIE_RBUF_ADDR(sc,head) + thisrboff,\n\t\t\t\t(u_int)len);\n\t\tresid -= len;\n\n\t\tif (len == thismblen) {\n\t\t\tm = m->m_next;\n\t\t\tthismboff = 0;\n\t\t} else\n\t\t\tthismboff += len;\n\n\t\tif (len == thisrblen) {\n\t\t\tif (++head == sc->nrxbuf)\n\t\t\t\thead = 0;\n\t\t\tthisrboff = 0;\n\t\t} else\n\t\t\tthisrboff += len;\n\t}\n\n\t/*\n\t * Unless something changed strangely while we were doing the copy,\n\t * we have now copied everything in from the shared memory.\n\t * This means that we are done.\n\t */\n\treturn (top);\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline__ struct mbuf *\ni82596_get(struct ie_softc *sc, struct ether_header *ehp, int head, int totlen)\n{\n\tstruct mbuf *top, **mp, *m;\n\tint len, resid;\n\tint thisrboff, thismboff;\n\n\t/*\n\t * Snarf the Ethernet header.\n\t */\n\t(sc->memcopyin)(sc, ehp, IE_RBUF_ADDR(sc,head), sizeof *ehp);\n\n\tresid = totlen -= (thisrboff = sizeof *ehp);\n\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\tif (m == 0)\n\t\treturn (0);\n\tm->m_pkthdr.rcvif = &sc->sc_arpcom.ac_if;\n\tm->m_pkthdr.len = totlen;\n\tlen = MHLEN;\n\ttop = 0;\n\tmp = &top;\n\n\t/*\n\t * This loop goes through and allocates mbufs for all the data we will\n\t * be copying in.  It does not actually do the copying yet.\n\t */\n\twhile (totlen > 0) {\n\t\tif (top) {\n\t\t\tMGET(m, M_DONTWAIT, MT_DATA);\n\t\t\tif (m == 0) {\n\t\t\t\tm_freem(top);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tlen = MLEN;\n\t\t}\n\t\tif (totlen >= MINCLSIZE) {\n\t\t\tMCLGET(m, M_DONTWAIT);\n\t\t\tif ((m->m_flags & M_EXT) == 0) {\n\t\t\t\tm_freem(top);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tlen = MCLBYTES;\n\t\t}\n\t\tm->m_len = len = min(totlen, len);\n\t\ttotlen -= len;\n\t\t*mp = m;\n\t\tmp = &m->m_next;\n\t}\n\n\tm = top;\n\tthismboff = 0;\n\n\t/*\n\t * Now we take the mbuf chain (hopefully only one mbuf most of the\n\t * time) and stuff the data into it.  There are no possible failures\n\t * at or after this point.\n\t */\n\twhile (resid > 0) {\n\t\tint thisrblen = IE_RBUF_SIZE - thisrboff,\n\t\t    thismblen = m->m_len - thismboff;\n\t\tlen = min(thisrblen, thismblen);\n\n\t\t(sc->memcopyin)(sc, mtod(m, caddr_t) + thismboff,\n\t\t\t\tIE_RBUF_ADDR(sc,head) + thisrboff,\n\t\t\t\t(u_int)len);\n\t\tresid -= len;\n\n\t\tif (len == thismblen) {\n\t\t\tm = m->m_next;\n\t\t\tthismboff = 0;\n\t\t} else\n\t\t\tthismboff += len;\n\n\t\tif (len == thisrblen) {\n\t\t\tif (++head == sc->nrxbuf)\n\t\t\t\thead = 0;\n\t\t\tthisrboff = 0;\n\t\t} else\n\t\t\tthisrboff += len;\n\t}\n\n\t/*\n\t * Unless something changed strangely while we were doing the copy,\n\t * we have now copied everything in from the shared memory.\n\t * This means that we are done.\n\t */\n\treturn (top);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i82596_get_rbd_list",
          "args": [
            "sc",
            "&bstart",
            "&bend",
            "&pktlen"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "i82596_get_rbd_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "818-860",
          "snippet": "int\ni82596_get_rbd_list(sc, start, end, pktlen)\n\tstruct ie_softc *sc;\n\tu_int16_t\t*start;\n\tu_int16_t\t*end;\n\tint\t\t*pktlen;\n{\n\tint\toff, rbbase = sc->rbds;\n\tint\trbindex, count = 0;\n\tint\tplen = 0;\n\tint\trbdstatus;\n\n\t*start = rbindex = sc->rbhead;\n\n\tdo {\n\t\toff = IE_RBD_STATUS(rbbase, rbindex);\n\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\trbdstatus = sc->ie_bus_read16(sc, off);\n\t\tif ((rbdstatus & IE_RBD_USED) == 0) {\n\t\t\t/*\n\t\t\t * This means we are somehow out of sync.  So, we\n\t\t\t * reset the adapter.\n\t\t\t */\n#ifdef I82596_DEBUG\n\t\t\tprint_rbd(sc, rbindex);\n#endif\n\t\t\tlog(LOG_ERR,\n\t\t\t    \"%s: receive descriptors out of sync at %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, rbindex);\n\t\t\treturn (0);\n\t\t}\n\t\tplen += (rbdstatus & IE_RBD_CNTMASK);\n\n\t\tif (++rbindex == sc->nrxbuf)\n\t\t\trbindex = 0;\n\n\t\t++count;\n\t} while ((rbdstatus & IE_RBD_LAST) == 0);\n\t*end = rbindex;\n\t*pktlen = plen;\n\treturn (count);\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\ti82596_get_rbd_list"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ti82596_get_rbd_list;\n\nint\ni82596_get_rbd_list(sc, start, end, pktlen)\n\tstruct ie_softc *sc;\n\tu_int16_t\t*start;\n\tu_int16_t\t*end;\n\tint\t\t*pktlen;\n{\n\tint\toff, rbbase = sc->rbds;\n\tint\trbindex, count = 0;\n\tint\tplen = 0;\n\tint\trbdstatus;\n\n\t*start = rbindex = sc->rbhead;\n\n\tdo {\n\t\toff = IE_RBD_STATUS(rbbase, rbindex);\n\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\trbdstatus = sc->ie_bus_read16(sc, off);\n\t\tif ((rbdstatus & IE_RBD_USED) == 0) {\n\t\t\t/*\n\t\t\t * This means we are somehow out of sync.  So, we\n\t\t\t * reset the adapter.\n\t\t\t */\n#ifdef I82596_DEBUG\n\t\t\tprint_rbd(sc, rbindex);\n#endif\n\t\t\tlog(LOG_ERR,\n\t\t\t    \"%s: receive descriptors out of sync at %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, rbindex);\n\t\t\treturn (0);\n\t\t}\n\t\tplen += (rbdstatus & IE_RBD_CNTMASK);\n\n\t\tif (++rbindex == sc->nrxbuf)\n\t\t\trbindex = 0;\n\n\t\t++count;\n\t} while ((rbdstatus & IE_RBD_LAST) == 0);\n\t*end = rbindex;\n\t*pktlen = plen;\n\treturn (count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint \ti82596_readframe;\nint\ti82596_get_rbd_list;\nvoid\ti82596_release_rbd_list;\n\nint\ni82596_readframe(sc, num)\n\tstruct ie_softc *sc;\n\tint num;\t\t/* frame number to read */\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tstruct mbuf *m;\n\tstruct ether_header eh;\n\tu_int16_t bstart, bend;\n\tint pktlen;\n\n\tif (i82596_get_rbd_list(sc, &bstart, &bend, &pktlen) == 0) {\n\t\tifp->if_ierrors++;\n\t\treturn (1);\n\t}\n\n\tm = i82596_get(sc, &eh, bstart, pktlen);\n\ti82596_release_rbd_list(sc, bstart, bend);\n\n\tif (m == 0) {\n\t\tsc->sc_arpcom.ac_if.if_ierrors++;\n\t\treturn (0);\n\t}\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_READFRAME)\n\t\tprintf(\"%s: frame from ether %s type 0x%x len %d\\n\",\n\t\t       sc->sc_dev.dv_xname,\n\t\t       ether_sprintf(eh.ether_shost),\n\t\t       (u_int)eh.ether_type, pktlen);\n#endif\n\n#if NBPFILTER > 0\n\t/*\n\t * Check for a BPF filter; if so, hand it up.\n\t * Note that we have to stick an extra mbuf up front, because bpf_mtap\n\t * expects to have the ether header at the front.\n\t * It doesn't matter that this results in an ill-formatted mbuf chain,\n\t * since BPF just looks at the data.  (It doesn't try to free the mbuf,\n\t * tho' it will make a copy for tcpdump.)\n\t */\n\tif (ifp->if_bpf) {\n\t\tstruct mbuf m0;\n\t\tm0.m_len = sizeof eh;\n\t\tm0.m_data = (caddr_t)&eh;\n\t\tm0.m_next = m;\n\n\t\t/* Pass it up. */\n\t\tbpf_mtap(ifp->if_bpf, &m0);\n\n\t}\n#endif /* NBPFILTER > 0 */\n\n\t/*\n\t * Finally pass this packet up to higher layers.\n\t */\n\tether_input(ifp, &eh, m);\n\tifp->if_ipackets++;\n\treturn (0);\n}"
  },
  {
    "function_name": "i82596_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
    "lines": "971-1059",
    "snippet": "static __inline__ struct mbuf *\ni82596_get(struct ie_softc *sc, struct ether_header *ehp, int head, int totlen)\n{\n\tstruct mbuf *top, **mp, *m;\n\tint len, resid;\n\tint thisrboff, thismboff;\n\n\t/*\n\t * Snarf the Ethernet header.\n\t */\n\t(sc->memcopyin)(sc, ehp, IE_RBUF_ADDR(sc,head), sizeof *ehp);\n\n\tresid = totlen -= (thisrboff = sizeof *ehp);\n\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\tif (m == 0)\n\t\treturn (0);\n\tm->m_pkthdr.rcvif = &sc->sc_arpcom.ac_if;\n\tm->m_pkthdr.len = totlen;\n\tlen = MHLEN;\n\ttop = 0;\n\tmp = &top;\n\n\t/*\n\t * This loop goes through and allocates mbufs for all the data we will\n\t * be copying in.  It does not actually do the copying yet.\n\t */\n\twhile (totlen > 0) {\n\t\tif (top) {\n\t\t\tMGET(m, M_DONTWAIT, MT_DATA);\n\t\t\tif (m == 0) {\n\t\t\t\tm_freem(top);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tlen = MLEN;\n\t\t}\n\t\tif (totlen >= MINCLSIZE) {\n\t\t\tMCLGET(m, M_DONTWAIT);\n\t\t\tif ((m->m_flags & M_EXT) == 0) {\n\t\t\t\tm_freem(top);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tlen = MCLBYTES;\n\t\t}\n\t\tm->m_len = len = min(totlen, len);\n\t\ttotlen -= len;\n\t\t*mp = m;\n\t\tmp = &m->m_next;\n\t}\n\n\tm = top;\n\tthismboff = 0;\n\n\t/*\n\t * Now we take the mbuf chain (hopefully only one mbuf most of the\n\t * time) and stuff the data into it.  There are no possible failures\n\t * at or after this point.\n\t */\n\twhile (resid > 0) {\n\t\tint thisrblen = IE_RBUF_SIZE - thisrboff,\n\t\t    thismblen = m->m_len - thismboff;\n\t\tlen = min(thisrblen, thismblen);\n\n\t\t(sc->memcopyin)(sc, mtod(m, caddr_t) + thismboff,\n\t\t\t\tIE_RBUF_ADDR(sc,head) + thisrboff,\n\t\t\t\t(u_int)len);\n\t\tresid -= len;\n\n\t\tif (len == thismblen) {\n\t\t\tm = m->m_next;\n\t\t\tthismboff = 0;\n\t\t} else\n\t\t\tthismboff += len;\n\n\t\tif (len == thisrblen) {\n\t\t\tif (++head == sc->nrxbuf)\n\t\t\t\thead = 0;\n\t\t\tthisrboff = 0;\n\t\t} else\n\t\t\tthisrboff += len;\n\t}\n\n\t/*\n\t * Unless something changed strangely while we were doing the copy,\n\t * we have now copied everything in from the shared memory.\n\t * This means that we are done.\n\t */\n\treturn (top);\n}",
    "includes": [
      "#include <dev/ic/i82596var.h>",
      "#include <dev/ic/i82596reg.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "mtod(m, caddr_t) + thismboff",
            "IE_RBUF_ADDR(sc,head) + thisrboff",
            "(u_int)len"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_RBUF_ADDR",
          "args": [
            "sc",
            "head"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "caddr_t"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "thisrblen",
            "thismblen"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "am7990_meminit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
          "lines": "231-295",
          "snippet": "void\nam7990_meminit(sc)\n\tregister struct am7990_softc *sc;\n{\n\tu_long a;\n\tint bix;\n\tstruct leinit init;\n\tstruct lermd rmd;\n\tstruct letmd tmd;\n\n#if NBPFILTER > 0\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tinit.init_mode = LE_MODE_NORMAL | LE_MODE_PROM;\n\telse\n#endif\n\t\tinit.init_mode = LE_MODE_NORMAL;\n\tinit.init_padr[0] =\n\t    (sc->sc_arpcom.ac_enaddr[1] << 8) | sc->sc_arpcom.ac_enaddr[0];\n\tinit.init_padr[1] =\n\t    (sc->sc_arpcom.ac_enaddr[3] << 8) | sc->sc_arpcom.ac_enaddr[2];\n\tinit.init_padr[2] =\n\t    (sc->sc_arpcom.ac_enaddr[5] << 8) | sc->sc_arpcom.ac_enaddr[4];\n\tam7990_setladrf(&sc->sc_arpcom, init.init_ladrf);\n\n\tsc->sc_last_rd = 0;\n\tsc->sc_first_td = sc->sc_last_td = sc->sc_no_td = 0;\n\n\ta = sc->sc_addr + LE_RMDADDR(sc, 0);\n\tinit.init_rdra = a;\n\tinit.init_rlen = (a >> 16) | ((ffs(sc->sc_nrbuf) - 1) << 13);\n\n\ta = sc->sc_addr + LE_TMDADDR(sc, 0);\n\tinit.init_tdra = a;\n\tinit.init_tlen = (a >> 16) | ((ffs(sc->sc_ntbuf) - 1) << 13);\n\n\t(*sc->sc_copytodesc)(sc, &init, LE_INITADDR(sc), sizeof(init));\n\n\t/*\n\t * Set up receive ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_nrbuf; bix++) {\n\t\ta = sc->sc_addr + LE_RBUFADDR(sc, bix);\n\t\trmd.rmd0 = a;\n\t\trmd.rmd1_hadr = a >> 16;\n\t\trmd.rmd1_bits = LE_R1_OWN;\n\t\trmd.rmd2 = -LEBLEN | LE_XMD2_ONES;\n\t\trmd.rmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &rmd, LE_RMDADDR(sc, bix),\n\t\t    sizeof(rmd));\n\t}\n\n\t/*\n\t * Set up transmit ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_ntbuf; bix++) {\n\t\ta = sc->sc_addr + LE_TBUFADDR(sc, bix);\n\t\ttmd.tmd0 = a;\n\t\ttmd.tmd1_hadr = a >> 16;\n\t\ttmd.tmd1_bits = 0;\n\t\ttmd.tmd2 = 0 | LE_XMD2_ONES;\n\t\ttmd.tmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &tmd, LE_TMDADDR(sc, bix),\n\t\t    sizeof(tmd));\n\t}\n}",
          "includes": [
            "#include <dev/ic/am7990var.h>",
            "#include <dev/ic/am7990reg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tifp\t(&sc->sc_arpcom.ac_if)"
          ],
          "globals_used": [
            "am7990_rint __P((struct am7990_softc *));",
            "am7990_tint __P((struct am7990_softc *));",
            "integrate struct",
            "integrate struct",
            "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tifp\t(&sc->sc_arpcom.ac_if)\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_meminit(sc)\n\tregister struct am7990_softc *sc;\n{\n\tu_long a;\n\tint bix;\n\tstruct leinit init;\n\tstruct lermd rmd;\n\tstruct letmd tmd;\n\n#if NBPFILTER > 0\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tinit.init_mode = LE_MODE_NORMAL | LE_MODE_PROM;\n\telse\n#endif\n\t\tinit.init_mode = LE_MODE_NORMAL;\n\tinit.init_padr[0] =\n\t    (sc->sc_arpcom.ac_enaddr[1] << 8) | sc->sc_arpcom.ac_enaddr[0];\n\tinit.init_padr[1] =\n\t    (sc->sc_arpcom.ac_enaddr[3] << 8) | sc->sc_arpcom.ac_enaddr[2];\n\tinit.init_padr[2] =\n\t    (sc->sc_arpcom.ac_enaddr[5] << 8) | sc->sc_arpcom.ac_enaddr[4];\n\tam7990_setladrf(&sc->sc_arpcom, init.init_ladrf);\n\n\tsc->sc_last_rd = 0;\n\tsc->sc_first_td = sc->sc_last_td = sc->sc_no_td = 0;\n\n\ta = sc->sc_addr + LE_RMDADDR(sc, 0);\n\tinit.init_rdra = a;\n\tinit.init_rlen = (a >> 16) | ((ffs(sc->sc_nrbuf) - 1) << 13);\n\n\ta = sc->sc_addr + LE_TMDADDR(sc, 0);\n\tinit.init_tdra = a;\n\tinit.init_tlen = (a >> 16) | ((ffs(sc->sc_ntbuf) - 1) << 13);\n\n\t(*sc->sc_copytodesc)(sc, &init, LE_INITADDR(sc), sizeof(init));\n\n\t/*\n\t * Set up receive ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_nrbuf; bix++) {\n\t\ta = sc->sc_addr + LE_RBUFADDR(sc, bix);\n\t\trmd.rmd0 = a;\n\t\trmd.rmd1_hadr = a >> 16;\n\t\trmd.rmd1_bits = LE_R1_OWN;\n\t\trmd.rmd2 = -LEBLEN | LE_XMD2_ONES;\n\t\trmd.rmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &rmd, LE_RMDADDR(sc, bix),\n\t\t    sizeof(rmd));\n\t}\n\n\t/*\n\t * Set up transmit ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_ntbuf; bix++) {\n\t\ta = sc->sc_addr + LE_TBUFADDR(sc, bix);\n\t\ttmd.tmd0 = a;\n\t\ttmd.tmd1_hadr = a >> 16;\n\t\ttmd.tmd1_bits = 0;\n\t\ttmd.tmd2 = 0 | LE_XMD2_ONES;\n\t\ttmd.tmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &tmd, LE_TMDADDR(sc, bix),\n\t\t    sizeof(tmd));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "top"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCLGET",
          "args": [
            "m",
            "M_DONTWAIT"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "top"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGET",
          "args": [
            "m",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGETHDR",
          "args": [
            "m",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "ehp",
            "IE_RBUF_ADDR(sc,head)",
            "sizeof *ehp"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_RBUF_ADDR",
          "args": [
            "sc",
            "head"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline__ struct mbuf *\ni82596_get(struct ie_softc *sc, struct ether_header *ehp, int head, int totlen)\n{\n\tstruct mbuf *top, **mp, *m;\n\tint len, resid;\n\tint thisrboff, thismboff;\n\n\t/*\n\t * Snarf the Ethernet header.\n\t */\n\t(sc->memcopyin)(sc, ehp, IE_RBUF_ADDR(sc,head), sizeof *ehp);\n\n\tresid = totlen -= (thisrboff = sizeof *ehp);\n\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\tif (m == 0)\n\t\treturn (0);\n\tm->m_pkthdr.rcvif = &sc->sc_arpcom.ac_if;\n\tm->m_pkthdr.len = totlen;\n\tlen = MHLEN;\n\ttop = 0;\n\tmp = &top;\n\n\t/*\n\t * This loop goes through and allocates mbufs for all the data we will\n\t * be copying in.  It does not actually do the copying yet.\n\t */\n\twhile (totlen > 0) {\n\t\tif (top) {\n\t\t\tMGET(m, M_DONTWAIT, MT_DATA);\n\t\t\tif (m == 0) {\n\t\t\t\tm_freem(top);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tlen = MLEN;\n\t\t}\n\t\tif (totlen >= MINCLSIZE) {\n\t\t\tMCLGET(m, M_DONTWAIT);\n\t\t\tif ((m->m_flags & M_EXT) == 0) {\n\t\t\t\tm_freem(top);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tlen = MCLBYTES;\n\t\t}\n\t\tm->m_len = len = min(totlen, len);\n\t\ttotlen -= len;\n\t\t*mp = m;\n\t\tmp = &m->m_next;\n\t}\n\n\tm = top;\n\tthismboff = 0;\n\n\t/*\n\t * Now we take the mbuf chain (hopefully only one mbuf most of the\n\t * time) and stuff the data into it.  There are no possible failures\n\t * at or after this point.\n\t */\n\twhile (resid > 0) {\n\t\tint thisrblen = IE_RBUF_SIZE - thisrboff,\n\t\t    thismblen = m->m_len - thismboff;\n\t\tlen = min(thisrblen, thismblen);\n\n\t\t(sc->memcopyin)(sc, mtod(m, caddr_t) + thismboff,\n\t\t\t\tIE_RBUF_ADDR(sc,head) + thisrboff,\n\t\t\t\t(u_int)len);\n\t\tresid -= len;\n\n\t\tif (len == thismblen) {\n\t\t\tm = m->m_next;\n\t\t\tthismboff = 0;\n\t\t} else\n\t\t\tthismboff += len;\n\n\t\tif (len == thisrblen) {\n\t\t\tif (++head == sc->nrxbuf)\n\t\t\t\thead = 0;\n\t\t\tthisrboff = 0;\n\t\t} else\n\t\t\tthisrboff += len;\n\t}\n\n\t/*\n\t * Unless something changed strangely while we were doing the copy,\n\t * we have now copied everything in from the shared memory.\n\t * This means that we are done.\n\t */\n\treturn (top);\n}"
  },
  {
    "function_name": "i82596_chk_rx_ring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
    "lines": "926-959",
    "snippet": "int\ni82596_chk_rx_ring(sc)\n\tstruct ie_softc *sc;\n{\n\tint n, off, val;\n\n\tfor (n = 0; n < sc->nrxbuf; n++) {\n\t\toff = IE_RBD_BUFLEN(sc->rbds, n);\n\t\tval = sc->ie_bus_read16(sc, off);\n\t\tif ((n == sc->rbtail) ^ ((val & IE_RBD_EOL) != 0)) {\n\t\t\t/* `rbtail' and EOL flag out of sync */\n\t\t\tlog(LOG_ERR,\n\t\t\t    \"%s: rx buffer descriptors out of sync at %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, n);\n\t\t\treturn (1);\n\t\t}\n\n\t\t/* Take the opportunity to clear the status fields here ? */\n\t}\n\n\tfor (n = 0; n < sc->nframes; n++) {\n\t\toff = IE_RFRAME_LAST(sc->rframes, n);\n\t\tval = sc->ie_bus_read16(sc, off);\n\t\tif ((n == sc->rftail) ^ ((val & (IE_FD_EOL|IE_FD_SUSP)) != 0)) {\n\t\t\t/* `rftail' and EOL flag out of sync */\n\t\t\tlog(LOG_ERR,\n\t\t\t    \"%s: rx frame list out of sync at %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, n);\n\t\t\treturn (1);\n\t\t}\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/i82596var.h>",
      "#include <dev/ic/i82596reg.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\ti82596_chk_rx_ring"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_ERR",
            "\"%s: rx frame list out of sync at %d\\n\"",
            "sc->sc_dev.dv_xname",
            "n"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1387-1401",
          "snippet": "int\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_read16",
          "args": [
            "sc",
            "off"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_RFRAME_LAST",
          "args": [
            "sc->rframes",
            "n"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_read16",
          "args": [
            "sc",
            "off"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_RBD_BUFLEN",
          "args": [
            "sc->rbds",
            "n"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ti82596_chk_rx_ring;\n\nint\ni82596_chk_rx_ring(sc)\n\tstruct ie_softc *sc;\n{\n\tint n, off, val;\n\n\tfor (n = 0; n < sc->nrxbuf; n++) {\n\t\toff = IE_RBD_BUFLEN(sc->rbds, n);\n\t\tval = sc->ie_bus_read16(sc, off);\n\t\tif ((n == sc->rbtail) ^ ((val & IE_RBD_EOL) != 0)) {\n\t\t\t/* `rbtail' and EOL flag out of sync */\n\t\t\tlog(LOG_ERR,\n\t\t\t    \"%s: rx buffer descriptors out of sync at %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, n);\n\t\t\treturn (1);\n\t\t}\n\n\t\t/* Take the opportunity to clear the status fields here ? */\n\t}\n\n\tfor (n = 0; n < sc->nframes; n++) {\n\t\toff = IE_RFRAME_LAST(sc->rframes, n);\n\t\tval = sc->ie_bus_read16(sc, off);\n\t\tif ((n == sc->rftail) ^ ((val & (IE_FD_EOL|IE_FD_SUSP)) != 0)) {\n\t\t\t/* `rftail' and EOL flag out of sync */\n\t\t\tlog(LOG_ERR,\n\t\t\t    \"%s: rx frame list out of sync at %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, n);\n\t\t\treturn (1);\n\t\t}\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "i82596_drop_frames",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
    "lines": "904-915",
    "snippet": "int\ni82596_drop_frames(sc)\n\tstruct ie_softc *sc;\n{\n\tu_int16_t bstart, bend;\n\tint pktlen;\n\n\tif (!i82596_get_rbd_list(sc, &bstart, &bend, &pktlen))\n\t\treturn (1);\n\ti82596_release_rbd_list(sc, bstart, bend);\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/i82596var.h>",
      "#include <dev/ic/i82596reg.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\ti82596_get_rbd_list",
      "void\ti82596_release_rbd_list",
      "int\ti82596_drop_frames"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "i82596_release_rbd_list",
          "args": [
            "sc",
            "bstart",
            "bend"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "i82596_release_rbd_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "866-896",
          "snippet": "void\ni82596_release_rbd_list(sc, start, end)\n\tstruct ie_softc *sc;\n\tu_int16_t\tstart;\n\tu_int16_t\tend;\n{\n\tregister int\toff, rbbase = sc->rbds;\n\tregister int\trbindex = start;\n\n\tdo {\n\t\t/* Clear buffer status */\n\t\toff = IE_RBD_STATUS(rbbase, rbindex);\n\t\tsc->ie_bus_write16(sc, off, 0);\n\t\tif (++rbindex == sc->nrxbuf)\n\t\t\trbindex = 0;\n\t} while (rbindex != end);\n\n\t/* Mark EOL at new tail */\n\trbindex = ((rbindex == 0) ? sc->nrxbuf : rbindex) - 1;\n\toff = IE_RBD_BUFLEN(rbbase, rbindex);\n\tsc->ie_bus_write16(sc, off, IE_RBUF_SIZE|IE_RBD_EOL);\n\n\t/* Remove EOL from current tail */\n\toff = IE_RBD_BUFLEN(rbbase, sc->rbtail);\n\tsc->ie_bus_write16(sc, off, IE_RBUF_SIZE);\n\n\t/* New head & tail pointer */\n/* hmm, why have both? head is always (tail + 1) % NRXBUF */\n\tsc->rbhead = end;\n\tsc->rbtail = rbindex;\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\ti82596_release_rbd_list"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ti82596_release_rbd_list;\n\nvoid\ni82596_release_rbd_list(sc, start, end)\n\tstruct ie_softc *sc;\n\tu_int16_t\tstart;\n\tu_int16_t\tend;\n{\n\tregister int\toff, rbbase = sc->rbds;\n\tregister int\trbindex = start;\n\n\tdo {\n\t\t/* Clear buffer status */\n\t\toff = IE_RBD_STATUS(rbbase, rbindex);\n\t\tsc->ie_bus_write16(sc, off, 0);\n\t\tif (++rbindex == sc->nrxbuf)\n\t\t\trbindex = 0;\n\t} while (rbindex != end);\n\n\t/* Mark EOL at new tail */\n\trbindex = ((rbindex == 0) ? sc->nrxbuf : rbindex) - 1;\n\toff = IE_RBD_BUFLEN(rbbase, rbindex);\n\tsc->ie_bus_write16(sc, off, IE_RBUF_SIZE|IE_RBD_EOL);\n\n\t/* Remove EOL from current tail */\n\toff = IE_RBD_BUFLEN(rbbase, sc->rbtail);\n\tsc->ie_bus_write16(sc, off, IE_RBUF_SIZE);\n\n\t/* New head & tail pointer */\n/* hmm, why have both? head is always (tail + 1) % NRXBUF */\n\tsc->rbhead = end;\n\tsc->rbtail = rbindex;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i82596_get_rbd_list",
          "args": [
            "sc",
            "&bstart",
            "&bend",
            "&pktlen"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "i82596_get_rbd_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "818-860",
          "snippet": "int\ni82596_get_rbd_list(sc, start, end, pktlen)\n\tstruct ie_softc *sc;\n\tu_int16_t\t*start;\n\tu_int16_t\t*end;\n\tint\t\t*pktlen;\n{\n\tint\toff, rbbase = sc->rbds;\n\tint\trbindex, count = 0;\n\tint\tplen = 0;\n\tint\trbdstatus;\n\n\t*start = rbindex = sc->rbhead;\n\n\tdo {\n\t\toff = IE_RBD_STATUS(rbbase, rbindex);\n\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\trbdstatus = sc->ie_bus_read16(sc, off);\n\t\tif ((rbdstatus & IE_RBD_USED) == 0) {\n\t\t\t/*\n\t\t\t * This means we are somehow out of sync.  So, we\n\t\t\t * reset the adapter.\n\t\t\t */\n#ifdef I82596_DEBUG\n\t\t\tprint_rbd(sc, rbindex);\n#endif\n\t\t\tlog(LOG_ERR,\n\t\t\t    \"%s: receive descriptors out of sync at %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, rbindex);\n\t\t\treturn (0);\n\t\t}\n\t\tplen += (rbdstatus & IE_RBD_CNTMASK);\n\n\t\tif (++rbindex == sc->nrxbuf)\n\t\t\trbindex = 0;\n\n\t\t++count;\n\t} while ((rbdstatus & IE_RBD_LAST) == 0);\n\t*end = rbindex;\n\t*pktlen = plen;\n\treturn (count);\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\ti82596_get_rbd_list"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ti82596_get_rbd_list;\n\nint\ni82596_get_rbd_list(sc, start, end, pktlen)\n\tstruct ie_softc *sc;\n\tu_int16_t\t*start;\n\tu_int16_t\t*end;\n\tint\t\t*pktlen;\n{\n\tint\toff, rbbase = sc->rbds;\n\tint\trbindex, count = 0;\n\tint\tplen = 0;\n\tint\trbdstatus;\n\n\t*start = rbindex = sc->rbhead;\n\n\tdo {\n\t\toff = IE_RBD_STATUS(rbbase, rbindex);\n\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\trbdstatus = sc->ie_bus_read16(sc, off);\n\t\tif ((rbdstatus & IE_RBD_USED) == 0) {\n\t\t\t/*\n\t\t\t * This means we are somehow out of sync.  So, we\n\t\t\t * reset the adapter.\n\t\t\t */\n#ifdef I82596_DEBUG\n\t\t\tprint_rbd(sc, rbindex);\n#endif\n\t\t\tlog(LOG_ERR,\n\t\t\t    \"%s: receive descriptors out of sync at %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, rbindex);\n\t\t\treturn (0);\n\t\t}\n\t\tplen += (rbdstatus & IE_RBD_CNTMASK);\n\n\t\tif (++rbindex == sc->nrxbuf)\n\t\t\trbindex = 0;\n\n\t\t++count;\n\t} while ((rbdstatus & IE_RBD_LAST) == 0);\n\t*end = rbindex;\n\t*pktlen = plen;\n\treturn (count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ti82596_get_rbd_list;\nvoid\ti82596_release_rbd_list;\nint\ti82596_drop_frames;\n\nint\ni82596_drop_frames(sc)\n\tstruct ie_softc *sc;\n{\n\tu_int16_t bstart, bend;\n\tint pktlen;\n\n\tif (!i82596_get_rbd_list(sc, &bstart, &bend, &pktlen))\n\t\treturn (1);\n\ti82596_release_rbd_list(sc, bstart, bend);\n\treturn (0);\n}"
  },
  {
    "function_name": "i82596_release_rbd_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
    "lines": "866-896",
    "snippet": "void\ni82596_release_rbd_list(sc, start, end)\n\tstruct ie_softc *sc;\n\tu_int16_t\tstart;\n\tu_int16_t\tend;\n{\n\tregister int\toff, rbbase = sc->rbds;\n\tregister int\trbindex = start;\n\n\tdo {\n\t\t/* Clear buffer status */\n\t\toff = IE_RBD_STATUS(rbbase, rbindex);\n\t\tsc->ie_bus_write16(sc, off, 0);\n\t\tif (++rbindex == sc->nrxbuf)\n\t\t\trbindex = 0;\n\t} while (rbindex != end);\n\n\t/* Mark EOL at new tail */\n\trbindex = ((rbindex == 0) ? sc->nrxbuf : rbindex) - 1;\n\toff = IE_RBD_BUFLEN(rbbase, rbindex);\n\tsc->ie_bus_write16(sc, off, IE_RBUF_SIZE|IE_RBD_EOL);\n\n\t/* Remove EOL from current tail */\n\toff = IE_RBD_BUFLEN(rbbase, sc->rbtail);\n\tsc->ie_bus_write16(sc, off, IE_RBUF_SIZE);\n\n\t/* New head & tail pointer */\n/* hmm, why have both? head is always (tail + 1) % NRXBUF */\n\tsc->rbhead = end;\n\tsc->rbtail = rbindex;\n}",
    "includes": [
      "#include <dev/ic/i82596var.h>",
      "#include <dev/ic/i82596reg.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\ti82596_release_rbd_list"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sc->ie_bus_write16",
          "args": [
            "sc",
            "off",
            "IE_RBUF_SIZE"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_RBD_BUFLEN",
          "args": [
            "rbbase",
            "sc->rbtail"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_write16",
          "args": [
            "sc",
            "off",
            "IE_RBUF_SIZE|IE_RBD_EOL"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_RBD_BUFLEN",
          "args": [
            "rbbase",
            "rbindex"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_write16",
          "args": [
            "sc",
            "off",
            "0"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_RBD_STATUS",
          "args": [
            "rbbase",
            "rbindex"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ti82596_release_rbd_list;\n\nvoid\ni82596_release_rbd_list(sc, start, end)\n\tstruct ie_softc *sc;\n\tu_int16_t\tstart;\n\tu_int16_t\tend;\n{\n\tregister int\toff, rbbase = sc->rbds;\n\tregister int\trbindex = start;\n\n\tdo {\n\t\t/* Clear buffer status */\n\t\toff = IE_RBD_STATUS(rbbase, rbindex);\n\t\tsc->ie_bus_write16(sc, off, 0);\n\t\tif (++rbindex == sc->nrxbuf)\n\t\t\trbindex = 0;\n\t} while (rbindex != end);\n\n\t/* Mark EOL at new tail */\n\trbindex = ((rbindex == 0) ? sc->nrxbuf : rbindex) - 1;\n\toff = IE_RBD_BUFLEN(rbbase, rbindex);\n\tsc->ie_bus_write16(sc, off, IE_RBUF_SIZE|IE_RBD_EOL);\n\n\t/* Remove EOL from current tail */\n\toff = IE_RBD_BUFLEN(rbbase, sc->rbtail);\n\tsc->ie_bus_write16(sc, off, IE_RBUF_SIZE);\n\n\t/* New head & tail pointer */\n/* hmm, why have both? head is always (tail + 1) % NRXBUF */\n\tsc->rbhead = end;\n\tsc->rbtail = rbindex;\n}"
  },
  {
    "function_name": "i82596_get_rbd_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
    "lines": "818-860",
    "snippet": "int\ni82596_get_rbd_list(sc, start, end, pktlen)\n\tstruct ie_softc *sc;\n\tu_int16_t\t*start;\n\tu_int16_t\t*end;\n\tint\t\t*pktlen;\n{\n\tint\toff, rbbase = sc->rbds;\n\tint\trbindex, count = 0;\n\tint\tplen = 0;\n\tint\trbdstatus;\n\n\t*start = rbindex = sc->rbhead;\n\n\tdo {\n\t\toff = IE_RBD_STATUS(rbbase, rbindex);\n\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\trbdstatus = sc->ie_bus_read16(sc, off);\n\t\tif ((rbdstatus & IE_RBD_USED) == 0) {\n\t\t\t/*\n\t\t\t * This means we are somehow out of sync.  So, we\n\t\t\t * reset the adapter.\n\t\t\t */\n#ifdef I82596_DEBUG\n\t\t\tprint_rbd(sc, rbindex);\n#endif\n\t\t\tlog(LOG_ERR,\n\t\t\t    \"%s: receive descriptors out of sync at %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, rbindex);\n\t\t\treturn (0);\n\t\t}\n\t\tplen += (rbdstatus & IE_RBD_CNTMASK);\n\n\t\tif (++rbindex == sc->nrxbuf)\n\t\t\trbindex = 0;\n\n\t\t++count;\n\t} while ((rbdstatus & IE_RBD_LAST) == 0);\n\t*end = rbindex;\n\t*pktlen = plen;\n\treturn (count);\n}",
    "includes": [
      "#include <dev/ic/i82596var.h>",
      "#include <dev/ic/i82596reg.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\ti82596_get_rbd_list"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_ERR",
            "\"%s: receive descriptors out of sync at %d\\n\"",
            "sc->sc_dev.dv_xname",
            "rbindex"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1387-1401",
          "snippet": "int\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_rbd",
          "args": [
            "sc",
            "rbindex"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "print_rbd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "2002-2014",
          "snippet": "void\nprint_rbd(sc, n)\n\tstruct ie_softc *sc;\n\tint n;\n{\n\n\tprintf(\"RBD at %08x:\\n  status %b, next %04x, buffer %lx\\n\"\n\t\t\"length/EOL %04x\\n\", IE_RBD_ADDR(sc->rbds,n),\n\t\tsc->ie_bus_read16(sc, IE_RBD_STATUS(sc->rbds,n)), IE_STAT_BITS,\n\t\tsc->ie_bus_read16(sc, IE_RBD_NEXT(sc->rbds,n)),\n\t\t(u_long)0,/*bus_space_read_4(sc->bt, sc->bh, IE_RBD_BUFADDR(sc->rbds,n)),-* XXX */\n\t\tsc->ie_bus_read16(sc, IE_RBD_BUFLEN(sc->rbds,n)));\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nprint_rbd(sc, n)\n\tstruct ie_softc *sc;\n\tint n;\n{\n\n\tprintf(\"RBD at %08x:\\n  status %b, next %04x, buffer %lx\\n\"\n\t\t\"length/EOL %04x\\n\", IE_RBD_ADDR(sc->rbds,n),\n\t\tsc->ie_bus_read16(sc, IE_RBD_STATUS(sc->rbds,n)), IE_STAT_BITS,\n\t\tsc->ie_bus_read16(sc, IE_RBD_NEXT(sc->rbds,n)),\n\t\t(u_long)0,/*bus_space_read_4(sc->bt, sc->bh, IE_RBD_BUFADDR(sc->rbds,n)),-* XXX */\n\t\tsc->ie_bus_read16(sc, IE_RBD_BUFLEN(sc->rbds,n)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_read16",
          "args": [
            "sc",
            "off"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_barrier",
          "args": [
            "sc->bt",
            "sc->bh",
            "off",
            "2",
            "BUS_SPACE_BARRIER_READ"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_RBD_STATUS",
          "args": [
            "rbbase",
            "rbindex"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ti82596_get_rbd_list;\n\nint\ni82596_get_rbd_list(sc, start, end, pktlen)\n\tstruct ie_softc *sc;\n\tu_int16_t\t*start;\n\tu_int16_t\t*end;\n\tint\t\t*pktlen;\n{\n\tint\toff, rbbase = sc->rbds;\n\tint\trbindex, count = 0;\n\tint\tplen = 0;\n\tint\trbdstatus;\n\n\t*start = rbindex = sc->rbhead;\n\n\tdo {\n\t\toff = IE_RBD_STATUS(rbbase, rbindex);\n\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\trbdstatus = sc->ie_bus_read16(sc, off);\n\t\tif ((rbdstatus & IE_RBD_USED) == 0) {\n\t\t\t/*\n\t\t\t * This means we are somehow out of sync.  So, we\n\t\t\t * reset the adapter.\n\t\t\t */\n#ifdef I82596_DEBUG\n\t\t\tprint_rbd(sc, rbindex);\n#endif\n\t\t\tlog(LOG_ERR,\n\t\t\t    \"%s: receive descriptors out of sync at %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, rbindex);\n\t\t\treturn (0);\n\t\t}\n\t\tplen += (rbdstatus & IE_RBD_CNTMASK);\n\n\t\tif (++rbindex == sc->nrxbuf)\n\t\t\trbindex = 0;\n\n\t\t++count;\n\t} while ((rbdstatus & IE_RBD_LAST) == 0);\n\t*end = rbindex;\n\t*pktlen = plen;\n\treturn (count);\n}"
  },
  {
    "function_name": "i82596_tint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
    "lines": "731-813",
    "snippet": "int\ni82596_tint(sc, scbstatus)\n\tstruct ie_softc *sc;\n\tint\tscbstatus;\n{\n\tregister struct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tregister int status;\n\n\tifp->if_timer = 0;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n#ifdef I82596_DEBUG\n\tif (sc->xmit_busy <= 0) {\n\t\tprintf(\"%s: i82596_tint: WEIRD:\"\n\t\t       \"xmit_busy=%d, xctail=%d, xchead=%d\\n\",\n\t\t       sc->sc_dev.dv_xname,\n\t\t       sc->xmit_busy, sc->xctail, sc->xchead);\n\t\treturn (0);\n\t}\n#endif\n\n\tstatus = sc->ie_bus_read16(sc, IE_CMD_XMIT_STATUS(sc->xmit_cmds,\n\t\t\t\t\t\t\t  sc->xctail));\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_TINT)\n\t\tprintf(\"%s: tint: SCB status %b; xmit status %b\\n\",\n\t\t\tsc->sc_dev.dv_xname, scbstatus, IE_ST_BITS,\n\t\t\tstatus, IE_XS_BITS);\n#endif\n\n\tif ((status & IE_STAT_COMPL) == 0 || (status & IE_STAT_BUSY)) {\n\t\tprintf(\"%s: i82596_tint: command still busy;\"\n\t\t       \"status=%b; tail=%d\\n\", sc->sc_dev.dv_xname,\n\t\t       status, IE_XS_BITS, sc->xctail);\n\t\tprintf(\"iestatus = %b\\n\", scbstatus, IE_ST_BITS);\n\t}\n\n\tif (status & IE_STAT_OK) {\n\t\tifp->if_opackets++;\n\t\tifp->if_collisions += (status & IE_XS_MAXCOLL);\n\t} else {\n\t\tifp->if_oerrors++;\n\t\t/*\n\t\t * Check SQE and DEFERRED?\n\t\t * What if more than one bit is set?\n\t\t */\n\t\tif (status & IE_STAT_ABORT)\n\t\t\tprintf(\"%s: send aborted\\n\", sc->sc_dev.dv_xname);\n\t\telse if (status & IE_XS_NOCARRIER)\n\t\t\tprintf(\"%s: no carrier\\n\", sc->sc_dev.dv_xname);\n\t\telse if (status & IE_XS_LOSTCTS)\n\t\t\tprintf(\"%s: lost CTS\\n\", sc->sc_dev.dv_xname);\n\t\telse if (status & IE_XS_UNDERRUN)\n\t\t\tprintf(\"%s: DMA underrun\\n\", sc->sc_dev.dv_xname);\n\t\telse if (status & IE_XS_EXCMAX) {\n\t\t\tprintf(\"%s: too many collisions\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\tsc->sc_arpcom.ac_if.if_collisions += 16;\n\t\t}\n\t}\n\n\t/*\n\t * If multicast addresses were added or deleted while transmitting,\n\t * ie_mc_reset() set the want_mcsetup flag indicating that we\n\t * should do it.\n\t */\n\tif (sc->want_mcsetup) {\n\t\tie_mc_setup(sc, IE_XBUF_ADDR(sc, sc->xctail));\n\t\tsc->want_mcsetup = 0;\n\t}\n\n\t/* Done with the buffer. */\n\tsc->xmit_busy--;\n\tsc->xctail = (sc->xctail + 1) % NTXBUF;\n\n\t/* Start the next packet, if any, transmitting. */\n\tif (sc->xmit_busy > 0)\n\t\ti82596_xmit(sc);\n\n\ti82596_start(ifp);\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/i82596var.h>",
      "#include <dev/ic/i82596reg.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\ti82596_start",
      "int\ti82596_tint",
      "void \ti82596_xmit",
      "int \tie_mc_setup",
      "void \tie_mc_reset"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "i82596_start",
          "args": [
            "ifp"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "i82596_start_transceiver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "1777-1813",
          "snippet": "void\ni82596_start_transceiver(sc)\n\tstruct ie_softc *sc;\n{\n\n\t/*\n\t * Start RU at current position in frame & RBD lists.\n\t */\n\tsc->ie_bus_write16(sc, IE_RFRAME_BUFDESC(sc->rframes,sc->rfhead),\n\t\t\t       IE_RBD_ADDR(sc->rbds, sc->rbhead));\n\n\tsc->ie_bus_write16(sc, IE_SCB_RCVLST(sc->scb),\n\t\t\t       IE_RFRAME_ADDR(sc->rframes,sc->rfhead));\n\n\tif (sc->do_xmitnopchain) {\n\t\t/* Stop transmit command chain */\n\t\tif (i82596_start_cmd(sc, IE_CUC_SUSPEND|IE_RUC_SUSPEND, 0, 0, 0))\n\t\t\tprintf(\"%s: CU/RU stop command timed out\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\n\t\t/* Start the receiver & transmitter chain */\n\t\t/* sc->scb->ie_command_list =\n\t\t\tIEADDR(sc->nop_cmds[(sc->xctail+NTXBUF-1) % NTXBUF]);*/\n\t\tsc->ie_bus_write16(sc, IE_SCB_CMDLST(sc->scb),\n\t\t\t\t   IE_CMD_NOP_ADDR(\n\t\t\t\t\tsc->nop_cmds,\n\t\t\t\t\t(sc->xctail + NTXBUF - 1) % NTXBUF));\n\n\t\tif (i82596_start_cmd(sc, IE_CUC_START|IE_RUC_START, 0, 0, 0))\n\t\t\tprintf(\"%s: CU/RU command timed out\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t} else {\n\t\tif (i82596_start_cmd(sc, IE_RUC_START, 0, 0, 0))\n\t\t\tprintf(\"%s: RU command timed out\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t}\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\ti82596_start_transceiver"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ti82596_start_transceiver;\n\nvoid\ni82596_start_transceiver(sc)\n\tstruct ie_softc *sc;\n{\n\n\t/*\n\t * Start RU at current position in frame & RBD lists.\n\t */\n\tsc->ie_bus_write16(sc, IE_RFRAME_BUFDESC(sc->rframes,sc->rfhead),\n\t\t\t       IE_RBD_ADDR(sc->rbds, sc->rbhead));\n\n\tsc->ie_bus_write16(sc, IE_SCB_RCVLST(sc->scb),\n\t\t\t       IE_RFRAME_ADDR(sc->rframes,sc->rfhead));\n\n\tif (sc->do_xmitnopchain) {\n\t\t/* Stop transmit command chain */\n\t\tif (i82596_start_cmd(sc, IE_CUC_SUSPEND|IE_RUC_SUSPEND, 0, 0, 0))\n\t\t\tprintf(\"%s: CU/RU stop command timed out\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\n\t\t/* Start the receiver & transmitter chain */\n\t\t/* sc->scb->ie_command_list =\n\t\t\tIEADDR(sc->nop_cmds[(sc->xctail+NTXBUF-1) % NTXBUF]);*/\n\t\tsc->ie_bus_write16(sc, IE_SCB_CMDLST(sc->scb),\n\t\t\t\t   IE_CMD_NOP_ADDR(\n\t\t\t\t\tsc->nop_cmds,\n\t\t\t\t\t(sc->xctail + NTXBUF - 1) % NTXBUF));\n\n\t\tif (i82596_start_cmd(sc, IE_CUC_START|IE_RUC_START, 0, 0, 0))\n\t\t\tprintf(\"%s: CU/RU command timed out\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t} else {\n\t\tif (i82596_start_cmd(sc, IE_RUC_START, 0, 0, 0))\n\t\t\tprintf(\"%s: RU command timed out\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i82596_xmit",
          "args": [
            "sc"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "i82596_xmit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "1136-1206",
          "snippet": "void\ni82596_xmit(sc)\n\tstruct ie_softc *sc;\n{\n\tint off, cur, prev;\n\n\tcur = sc->xctail;\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_XMIT)\n\t\tprintf(\"%s: xmit buffer %d\\n\", sc->sc_dev.dv_xname, cur);\n#endif\n\n\t/*\n\t * Setup the transmit command.\n\t */\n\tsc->ie_bus_write16(sc, IE_CMD_XMIT_DESC(sc->xmit_cmds, cur),\n\t\t\t       IE_XBD_ADDR(sc->xbds, cur));\n\n\tsc->ie_bus_write16(sc, IE_CMD_XMIT_STATUS(sc->xmit_cmds, cur), 0);\n\n\tif (sc->do_xmitnopchain) {\n\t\t/*\n\t\t * Gate this XMIT command to the following NOP\n\t\t */\n\t\tsc->ie_bus_write16(sc, IE_CMD_XMIT_LINK(sc->xmit_cmds, cur),\n\t\t\t\t       IE_CMD_NOP_ADDR(sc->nop_cmds, cur));\n\t\tsc->ie_bus_write16(sc, IE_CMD_XMIT_CMD(sc->xmit_cmds, cur),\n\t\t\t\t       IE_CMD_XMIT | IE_CMD_INTR);\n\n\t\t/*\n\t\t * Loopback at following NOP\n\t\t */\n\t\tsc->ie_bus_write16(sc, IE_CMD_NOP_STATUS(sc->nop_cmds, cur), 0);\n\t\tsc->ie_bus_write16(sc, IE_CMD_NOP_LINK(sc->nop_cmds, cur),\n\t\t\t\t       IE_CMD_NOP_ADDR(sc->nop_cmds, cur));\n\n\t\t/*\n\t\t * Gate preceding NOP to this XMIT command\n\t\t */\n\t\tprev = (cur + NTXBUF - 1) % NTXBUF;\n\t\tsc->ie_bus_write16(sc, IE_CMD_NOP_STATUS(sc->nop_cmds, prev), 0);\n\t\tsc->ie_bus_write16(sc, IE_CMD_NOP_LINK(sc->nop_cmds, prev),\n\t\t\t\t       IE_CMD_XMIT_ADDR(sc->xmit_cmds, cur));\n\n\t\toff = IE_SCB_STATUS(sc->scb);\n\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\tif ((sc->ie_bus_read16(sc, off) & IE_CUS_ACTIVE) == 0) {\n\t\t\tprintf(\"i82596_xmit: CU not active\\n\");\n\t\t\ti82596_start_transceiver(sc);\n\t\t}\n\t} else {\n\t\tsc->ie_bus_write16(sc, IE_CMD_XMIT_LINK(sc->xmit_cmds,cur),\n\t\t\t\t       0xffff);\n\n\t\tsc->ie_bus_write16(sc, IE_CMD_XMIT_CMD(sc->xmit_cmds, cur),\n\t\t\t\t       IE_CMD_XMIT | IE_CMD_INTR | IE_CMD_LAST);\n\n\t\toff = IE_SCB_CMDLST(sc->scb);\n\t\tsc->ie_bus_write16(sc, off, IE_CMD_XMIT_ADDR(sc->xmit_cmds, cur));\n\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t  BUS_SPACE_BARRIER_WRITE);\n\n\t\tif (i82596_start_cmd(sc, IE_CUC_START, 0, 0, 1))\n\t\t\tprintf(\"%s: i82596_xmit: start xmit command timed out\\n\",\n\t\t\t       sc->sc_dev.dv_xname);\n\t}\n\n\tsc->sc_arpcom.ac_if.if_timer = 5;\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\ti82596_start_transceiver",
            "void \ti82596_xmit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ti82596_start_transceiver;\nvoid \ti82596_xmit;\n\nvoid\ni82596_xmit(sc)\n\tstruct ie_softc *sc;\n{\n\tint off, cur, prev;\n\n\tcur = sc->xctail;\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_XMIT)\n\t\tprintf(\"%s: xmit buffer %d\\n\", sc->sc_dev.dv_xname, cur);\n#endif\n\n\t/*\n\t * Setup the transmit command.\n\t */\n\tsc->ie_bus_write16(sc, IE_CMD_XMIT_DESC(sc->xmit_cmds, cur),\n\t\t\t       IE_XBD_ADDR(sc->xbds, cur));\n\n\tsc->ie_bus_write16(sc, IE_CMD_XMIT_STATUS(sc->xmit_cmds, cur), 0);\n\n\tif (sc->do_xmitnopchain) {\n\t\t/*\n\t\t * Gate this XMIT command to the following NOP\n\t\t */\n\t\tsc->ie_bus_write16(sc, IE_CMD_XMIT_LINK(sc->xmit_cmds, cur),\n\t\t\t\t       IE_CMD_NOP_ADDR(sc->nop_cmds, cur));\n\t\tsc->ie_bus_write16(sc, IE_CMD_XMIT_CMD(sc->xmit_cmds, cur),\n\t\t\t\t       IE_CMD_XMIT | IE_CMD_INTR);\n\n\t\t/*\n\t\t * Loopback at following NOP\n\t\t */\n\t\tsc->ie_bus_write16(sc, IE_CMD_NOP_STATUS(sc->nop_cmds, cur), 0);\n\t\tsc->ie_bus_write16(sc, IE_CMD_NOP_LINK(sc->nop_cmds, cur),\n\t\t\t\t       IE_CMD_NOP_ADDR(sc->nop_cmds, cur));\n\n\t\t/*\n\t\t * Gate preceding NOP to this XMIT command\n\t\t */\n\t\tprev = (cur + NTXBUF - 1) % NTXBUF;\n\t\tsc->ie_bus_write16(sc, IE_CMD_NOP_STATUS(sc->nop_cmds, prev), 0);\n\t\tsc->ie_bus_write16(sc, IE_CMD_NOP_LINK(sc->nop_cmds, prev),\n\t\t\t\t       IE_CMD_XMIT_ADDR(sc->xmit_cmds, cur));\n\n\t\toff = IE_SCB_STATUS(sc->scb);\n\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\tif ((sc->ie_bus_read16(sc, off) & IE_CUS_ACTIVE) == 0) {\n\t\t\tprintf(\"i82596_xmit: CU not active\\n\");\n\t\t\ti82596_start_transceiver(sc);\n\t\t}\n\t} else {\n\t\tsc->ie_bus_write16(sc, IE_CMD_XMIT_LINK(sc->xmit_cmds,cur),\n\t\t\t\t       0xffff);\n\n\t\tsc->ie_bus_write16(sc, IE_CMD_XMIT_CMD(sc->xmit_cmds, cur),\n\t\t\t\t       IE_CMD_XMIT | IE_CMD_INTR | IE_CMD_LAST);\n\n\t\toff = IE_SCB_CMDLST(sc->scb);\n\t\tsc->ie_bus_write16(sc, off, IE_CMD_XMIT_ADDR(sc->xmit_cmds, cur));\n\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t  BUS_SPACE_BARRIER_WRITE);\n\n\t\tif (i82596_start_cmd(sc, IE_CUC_START, 0, 0, 1))\n\t\t\tprintf(\"%s: i82596_xmit: start xmit command timed out\\n\",\n\t\t\t       sc->sc_dev.dv_xname);\n\t}\n\n\tsc->sc_arpcom.ac_if.if_timer = 5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ie_mc_setup",
          "args": [
            "sc",
            "IE_XBUF_ADDR(sc, sc->xctail)"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "ie_mc_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "1671-1707",
          "snippet": "int\nie_mc_setup(sc, cmdbuf)\n\tstruct ie_softc *sc;\n\tint cmdbuf;\n{\n\tint cmdresult, status;\n\n\tif (sc->mcast_count == 0)\n\t\treturn (1);\n\n\ti82596_simple_command(sc, IE_CMD_MCAST, cmdbuf);\n\n\t(sc->memcopyout)(sc, (caddr_t)sc->mcast_addrs,\n\t\t\t IE_CMD_MCAST_MADDR(cmdbuf),\n\t\t\t sc->mcast_count * ETHER_ADDR_LEN);\n\n\tsc->ie_bus_write16(sc, IE_CMD_MCAST_BYTES(cmdbuf),\n\t\t\t       sc->mcast_count * ETHER_ADDR_LEN);\n\n\t/* Start the command */\n\tcmdresult = i82596_start_cmd(sc, IE_CUC_START, cmdbuf, IE_STAT_COMPL, 0);\n\tstatus = sc->ie_bus_read16(sc, IE_CMD_COMMON_STATUS(cmdbuf));\n\tif (cmdresult != 0) {\n\t\tprintf(\"%s: multicast setup command timed out; status %b\\n\",\n\t\t\tsc->sc_dev.dv_xname, status, IE_STAT_BITS);\n\t\treturn (0);\n\t}\n\tif ((status & IE_STAT_OK) == 0) {\n\t\tprintf(\"%s: multicast setup command failed; status %b\\n\",\n\t\t\tsc->sc_dev.dv_xname, status, IE_STAT_BITS);\n\t\treturn (0);\n\t}\n\n\t/* Squash any pending interrupts */\n\tie_ack(sc, IE_ST_WHENCE);\n\treturn (1);\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\ti82596_simple_command",
            "int \tie_mc_setup"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ti82596_simple_command;\nint \tie_mc_setup;\n\nint\nie_mc_setup(sc, cmdbuf)\n\tstruct ie_softc *sc;\n\tint cmdbuf;\n{\n\tint cmdresult, status;\n\n\tif (sc->mcast_count == 0)\n\t\treturn (1);\n\n\ti82596_simple_command(sc, IE_CMD_MCAST, cmdbuf);\n\n\t(sc->memcopyout)(sc, (caddr_t)sc->mcast_addrs,\n\t\t\t IE_CMD_MCAST_MADDR(cmdbuf),\n\t\t\t sc->mcast_count * ETHER_ADDR_LEN);\n\n\tsc->ie_bus_write16(sc, IE_CMD_MCAST_BYTES(cmdbuf),\n\t\t\t       sc->mcast_count * ETHER_ADDR_LEN);\n\n\t/* Start the command */\n\tcmdresult = i82596_start_cmd(sc, IE_CUC_START, cmdbuf, IE_STAT_COMPL, 0);\n\tstatus = sc->ie_bus_read16(sc, IE_CMD_COMMON_STATUS(cmdbuf));\n\tif (cmdresult != 0) {\n\t\tprintf(\"%s: multicast setup command timed out; status %b\\n\",\n\t\t\tsc->sc_dev.dv_xname, status, IE_STAT_BITS);\n\t\treturn (0);\n\t}\n\tif ((status & IE_STAT_OK) == 0) {\n\t\tprintf(\"%s: multicast setup command failed; status %b\\n\",\n\t\t\tsc->sc_dev.dv_xname, status, IE_STAT_BITS);\n\t\treturn (0);\n\t}\n\n\t/* Squash any pending interrupts */\n\tie_ack(sc, IE_ST_WHENCE);\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IE_XBUF_ADDR",
          "args": [
            "sc",
            "sc->xctail"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: too many collisions\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_read16",
          "args": [
            "sc",
            "IE_CMD_XMIT_STATUS(sc->xmit_cmds,\n\t\t\t\t\t\t\t  sc->xctail)"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_XMIT_STATUS",
          "args": [
            "sc->xmit_cmds",
            "sc->xctail"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ti82596_start;\nint\ti82596_tint;\nvoid \ti82596_xmit;\nint \tie_mc_setup;\nvoid \tie_mc_reset;\n\nint\ni82596_tint(sc, scbstatus)\n\tstruct ie_softc *sc;\n\tint\tscbstatus;\n{\n\tregister struct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tregister int status;\n\n\tifp->if_timer = 0;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n#ifdef I82596_DEBUG\n\tif (sc->xmit_busy <= 0) {\n\t\tprintf(\"%s: i82596_tint: WEIRD:\"\n\t\t       \"xmit_busy=%d, xctail=%d, xchead=%d\\n\",\n\t\t       sc->sc_dev.dv_xname,\n\t\t       sc->xmit_busy, sc->xctail, sc->xchead);\n\t\treturn (0);\n\t}\n#endif\n\n\tstatus = sc->ie_bus_read16(sc, IE_CMD_XMIT_STATUS(sc->xmit_cmds,\n\t\t\t\t\t\t\t  sc->xctail));\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_TINT)\n\t\tprintf(\"%s: tint: SCB status %b; xmit status %b\\n\",\n\t\t\tsc->sc_dev.dv_xname, scbstatus, IE_ST_BITS,\n\t\t\tstatus, IE_XS_BITS);\n#endif\n\n\tif ((status & IE_STAT_COMPL) == 0 || (status & IE_STAT_BUSY)) {\n\t\tprintf(\"%s: i82596_tint: command still busy;\"\n\t\t       \"status=%b; tail=%d\\n\", sc->sc_dev.dv_xname,\n\t\t       status, IE_XS_BITS, sc->xctail);\n\t\tprintf(\"iestatus = %b\\n\", scbstatus, IE_ST_BITS);\n\t}\n\n\tif (status & IE_STAT_OK) {\n\t\tifp->if_opackets++;\n\t\tifp->if_collisions += (status & IE_XS_MAXCOLL);\n\t} else {\n\t\tifp->if_oerrors++;\n\t\t/*\n\t\t * Check SQE and DEFERRED?\n\t\t * What if more than one bit is set?\n\t\t */\n\t\tif (status & IE_STAT_ABORT)\n\t\t\tprintf(\"%s: send aborted\\n\", sc->sc_dev.dv_xname);\n\t\telse if (status & IE_XS_NOCARRIER)\n\t\t\tprintf(\"%s: no carrier\\n\", sc->sc_dev.dv_xname);\n\t\telse if (status & IE_XS_LOSTCTS)\n\t\t\tprintf(\"%s: lost CTS\\n\", sc->sc_dev.dv_xname);\n\t\telse if (status & IE_XS_UNDERRUN)\n\t\t\tprintf(\"%s: DMA underrun\\n\", sc->sc_dev.dv_xname);\n\t\telse if (status & IE_XS_EXCMAX) {\n\t\t\tprintf(\"%s: too many collisions\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\tsc->sc_arpcom.ac_if.if_collisions += 16;\n\t\t}\n\t}\n\n\t/*\n\t * If multicast addresses were added or deleted while transmitting,\n\t * ie_mc_reset() set the want_mcsetup flag indicating that we\n\t * should do it.\n\t */\n\tif (sc->want_mcsetup) {\n\t\tie_mc_setup(sc, IE_XBUF_ADDR(sc, sc->xctail));\n\t\tsc->want_mcsetup = 0;\n\t}\n\n\t/* Done with the buffer. */\n\tsc->xmit_busy--;\n\tsc->xctail = (sc->xctail + 1) % NTXBUF;\n\n\t/* Start the next packet, if any, transmitting. */\n\tif (sc->xmit_busy > 0)\n\t\ti82596_xmit(sc);\n\n\ti82596_start(ifp);\n\treturn (0);\n}"
  },
  {
    "function_name": "i82596_rint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
    "lines": "575-724",
    "snippet": "int\ni82596_rint(sc, scbstatus)\n\tstruct\tie_softc *sc;\n\tint\tscbstatus;\n{\n\tstatic int timesthru = 1024;\n\tregister int i, status, off;\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_RINT)\n\t\tprintf(\"%s: rint: status %b\\n\",\n\t\t\tsc->sc_dev.dv_xname, scbstatus, IE_ST_BITS);\n#endif\n\n\tfor (;;) {\n\t\tregister int drop = 0;\n\n\t\ti = sc->rfhead;\n\t\toff = IE_RFRAME_STATUS(sc->rframes, i);\n\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\tstatus = sc->ie_bus_read16(sc, off);\n\n#ifdef I82596_DEBUG\n\t\tif (sc->sc_debug & IED_RINT)\n\t\t\tprintf(\"%s: rint: frame(%d) status %b\\n\",\n\t\t\t\tsc->sc_dev.dv_xname, i, status, IE_ST_BITS);\n#endif\n\t\tif ((status & IE_FD_COMPLETE) == 0) {\n\t\t\tif ((status & IE_FD_OK) != 0) {\n\t\t\t\tprintf(\"%s: rint: weird: \",\n\t\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\t\ti82596_rx_errors(sc, i, status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (--timesthru == 0) {\n\t\t\t\t/* Account the accumulated errors */\n\t\t\t\ti82596_count_errors(sc);\n\t\t\t\ttimesthru = 1024;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if ((status & IE_FD_OK) == 0) {\n\t\t\t/*\n\t\t\t * If the chip is configured to automatically\n\t\t\t * discard bad frames, the only reason we can\n\t\t\t * get here is an \"out-of-resource\" condition.\n\t\t\t */\n\t\t\ti82596_rx_errors(sc, i, status);\n\t\t\tdrop = 1;\n\t\t}\n\n#ifdef I82596_DEBUG\n\t\tif ((status & IE_FD_BUSY) != 0)\n\t\t\tprintf(\"%s: rint: frame(%d) busy; status=%x\\n\",\n\t\t\t\tsc->sc_dev.dv_xname, i, status, IE_ST_BITS);\n#endif\n\n\n\t\t/*\n\t\t * Advance the RFD list, since we're done with\n\t\t * this descriptor.\n\t\t */\n\n\t\t/* Clear frame status */\n\t\tsc->ie_bus_write16(sc, off, 0);\n\n\t\t/* Put fence at this frame (the head) */\n\t\toff = IE_RFRAME_LAST(sc->rframes, i);\n\t\tsc->ie_bus_write16(sc, off, IE_FD_EOL|IE_FD_SUSP);\n\n\t\t/* and clear RBD field */\n\t\toff = IE_RFRAME_BUFDESC(sc->rframes, i);\n\t\tsc->ie_bus_write16(sc, off, 0xffff);\n\n\t\t/* Remove fence from current tail */\n\t\toff = IE_RFRAME_LAST(sc->rframes, sc->rftail);\n\t\tsc->ie_bus_write16(sc, off, 0);\n\n\t\tif (++sc->rftail == sc->nframes)\n\t\t\tsc->rftail = 0;\n\t\tif (++sc->rfhead == sc->nframes)\n\t\t\tsc->rfhead = 0;\n\n\t\t/* Pull the frame off the board */\n\t\tif (drop) {\n\t\t\ti82596_drop_frames(sc);\n\t\t\tif ((status & IE_FD_RNR) != 0)\n\t\t\t\tsc->rnr_expect = 1;\n\t\t\tsc->sc_arpcom.ac_if.if_ierrors++;\n\t\t} else if (i82596_readframe(sc, i) != 0)\n\t\t\treturn (1);\n\t}\n\n\tif ((scbstatus & IE_ST_RNR) != 0) {\n\n\t\t/*\n\t\t * Receiver went \"Not Ready\". We try to figure out\n\t\t * whether this was an expected event based on past\n\t\t * frame status values.\n\t\t */\n\n\t\tif ((scbstatus & IE_RUS_SUSPEND) != 0) {\n\t\t\t/*\n\t\t\t * We use the \"suspend on last frame\" flag.\n\t\t\t * Send a RU RESUME command in response, since\n\t\t\t * we should have dealt with all completed frames\n\t\t\t * by now.\n\t\t\t */\n\t\t\tprintf(\"RINT: SUSPENDED; scbstatus=%b\\n\",\n\t\t\t\tscbstatus, IE_ST_BITS);\n\t\t\tif (i82596_start_cmd(sc, IE_RUC_RESUME, 0, 0, 0) == 0)\n\t\t\t\treturn (0);\n\t\t\tprintf(\"%s: RU RESUME command timed out\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\treturn (1);\t/* Ask for a reset */\n\t\t}\n\n\t\tif (sc->rnr_expect != 0) {\n\t\t\t/*\n\t\t\t * The RNR condition was announced in the previously\n\t\t\t * completed frame.  Assume the receive ring is Ok,\n\t\t\t * so restart the receiver without further delay.\n\t\t\t */\n\t\t\ti82596_start_transceiver(sc);\n\t\t\tsc->rnr_expect = 0;\n\t\t\treturn (0);\n\n\t\t} else if ((scbstatus & IE_RUS_NOSPACE) != 0) {\n\t\t\t/*\n\t\t\t * We saw no previous IF_FD_RNR flag.\n\t\t\t * We check our ring invariants and, if ok,\n\t\t\t * just restart the receiver at the current\n\t\t\t * point in the ring.\n\t\t\t */\n\t\t\tif (i82596_chk_rx_ring(sc) != 0)\n\t\t\t\treturn (1);\n\n\t\t\ti82596_start_transceiver(sc);\n\t\t\tsc->sc_arpcom.ac_if.if_ierrors++;\n\t\t\treturn (0);\n\t\t} else\n\t\t\tprintf(\"%s: receiver not ready; scbstatus=%b\\n\",\n\t\t\t\tsc->sc_dev.dv_xname, scbstatus, IE_ST_BITS);\n\n\t\tsc->sc_arpcom.ac_if.if_ierrors++;\n\t\treturn (1);\t/* Ask for a reset */\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/ic/i82596var.h>",
      "#include <dev/ic/i82596reg.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\ti82596_rint",
      "int \ti82596_readframe",
      "int\ti82596_drop_frames",
      "int\ti82596_chk_rx_ring",
      "void\ti82596_start_transceiver"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: receiver not ready; scbstatus=%b\\n\"",
            "sc->sc_dev.dv_xname",
            "scbstatus",
            "IE_ST_BITS"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i82596_start_transceiver",
          "args": [
            "sc"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "i82596_start_transceiver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "1777-1813",
          "snippet": "void\ni82596_start_transceiver(sc)\n\tstruct ie_softc *sc;\n{\n\n\t/*\n\t * Start RU at current position in frame & RBD lists.\n\t */\n\tsc->ie_bus_write16(sc, IE_RFRAME_BUFDESC(sc->rframes,sc->rfhead),\n\t\t\t       IE_RBD_ADDR(sc->rbds, sc->rbhead));\n\n\tsc->ie_bus_write16(sc, IE_SCB_RCVLST(sc->scb),\n\t\t\t       IE_RFRAME_ADDR(sc->rframes,sc->rfhead));\n\n\tif (sc->do_xmitnopchain) {\n\t\t/* Stop transmit command chain */\n\t\tif (i82596_start_cmd(sc, IE_CUC_SUSPEND|IE_RUC_SUSPEND, 0, 0, 0))\n\t\t\tprintf(\"%s: CU/RU stop command timed out\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\n\t\t/* Start the receiver & transmitter chain */\n\t\t/* sc->scb->ie_command_list =\n\t\t\tIEADDR(sc->nop_cmds[(sc->xctail+NTXBUF-1) % NTXBUF]);*/\n\t\tsc->ie_bus_write16(sc, IE_SCB_CMDLST(sc->scb),\n\t\t\t\t   IE_CMD_NOP_ADDR(\n\t\t\t\t\tsc->nop_cmds,\n\t\t\t\t\t(sc->xctail + NTXBUF - 1) % NTXBUF));\n\n\t\tif (i82596_start_cmd(sc, IE_CUC_START|IE_RUC_START, 0, 0, 0))\n\t\t\tprintf(\"%s: CU/RU command timed out\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t} else {\n\t\tif (i82596_start_cmd(sc, IE_RUC_START, 0, 0, 0))\n\t\t\tprintf(\"%s: RU command timed out\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t}\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\ti82596_start_transceiver"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ti82596_start_transceiver;\n\nvoid\ni82596_start_transceiver(sc)\n\tstruct ie_softc *sc;\n{\n\n\t/*\n\t * Start RU at current position in frame & RBD lists.\n\t */\n\tsc->ie_bus_write16(sc, IE_RFRAME_BUFDESC(sc->rframes,sc->rfhead),\n\t\t\t       IE_RBD_ADDR(sc->rbds, sc->rbhead));\n\n\tsc->ie_bus_write16(sc, IE_SCB_RCVLST(sc->scb),\n\t\t\t       IE_RFRAME_ADDR(sc->rframes,sc->rfhead));\n\n\tif (sc->do_xmitnopchain) {\n\t\t/* Stop transmit command chain */\n\t\tif (i82596_start_cmd(sc, IE_CUC_SUSPEND|IE_RUC_SUSPEND, 0, 0, 0))\n\t\t\tprintf(\"%s: CU/RU stop command timed out\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\n\t\t/* Start the receiver & transmitter chain */\n\t\t/* sc->scb->ie_command_list =\n\t\t\tIEADDR(sc->nop_cmds[(sc->xctail+NTXBUF-1) % NTXBUF]);*/\n\t\tsc->ie_bus_write16(sc, IE_SCB_CMDLST(sc->scb),\n\t\t\t\t   IE_CMD_NOP_ADDR(\n\t\t\t\t\tsc->nop_cmds,\n\t\t\t\t\t(sc->xctail + NTXBUF - 1) % NTXBUF));\n\n\t\tif (i82596_start_cmd(sc, IE_CUC_START|IE_RUC_START, 0, 0, 0))\n\t\t\tprintf(\"%s: CU/RU command timed out\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t} else {\n\t\tif (i82596_start_cmd(sc, IE_RUC_START, 0, 0, 0))\n\t\t\tprintf(\"%s: RU command timed out\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i82596_chk_rx_ring",
          "args": [
            "sc"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "i82596_chk_rx_ring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "926-959",
          "snippet": "int\ni82596_chk_rx_ring(sc)\n\tstruct ie_softc *sc;\n{\n\tint n, off, val;\n\n\tfor (n = 0; n < sc->nrxbuf; n++) {\n\t\toff = IE_RBD_BUFLEN(sc->rbds, n);\n\t\tval = sc->ie_bus_read16(sc, off);\n\t\tif ((n == sc->rbtail) ^ ((val & IE_RBD_EOL) != 0)) {\n\t\t\t/* `rbtail' and EOL flag out of sync */\n\t\t\tlog(LOG_ERR,\n\t\t\t    \"%s: rx buffer descriptors out of sync at %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, n);\n\t\t\treturn (1);\n\t\t}\n\n\t\t/* Take the opportunity to clear the status fields here ? */\n\t}\n\n\tfor (n = 0; n < sc->nframes; n++) {\n\t\toff = IE_RFRAME_LAST(sc->rframes, n);\n\t\tval = sc->ie_bus_read16(sc, off);\n\t\tif ((n == sc->rftail) ^ ((val & (IE_FD_EOL|IE_FD_SUSP)) != 0)) {\n\t\t\t/* `rftail' and EOL flag out of sync */\n\t\t\tlog(LOG_ERR,\n\t\t\t    \"%s: rx frame list out of sync at %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, n);\n\t\t\treturn (1);\n\t\t}\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\ti82596_chk_rx_ring"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ti82596_chk_rx_ring;\n\nint\ni82596_chk_rx_ring(sc)\n\tstruct ie_softc *sc;\n{\n\tint n, off, val;\n\n\tfor (n = 0; n < sc->nrxbuf; n++) {\n\t\toff = IE_RBD_BUFLEN(sc->rbds, n);\n\t\tval = sc->ie_bus_read16(sc, off);\n\t\tif ((n == sc->rbtail) ^ ((val & IE_RBD_EOL) != 0)) {\n\t\t\t/* `rbtail' and EOL flag out of sync */\n\t\t\tlog(LOG_ERR,\n\t\t\t    \"%s: rx buffer descriptors out of sync at %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, n);\n\t\t\treturn (1);\n\t\t}\n\n\t\t/* Take the opportunity to clear the status fields here ? */\n\t}\n\n\tfor (n = 0; n < sc->nframes; n++) {\n\t\toff = IE_RFRAME_LAST(sc->rframes, n);\n\t\tval = sc->ie_bus_read16(sc, off);\n\t\tif ((n == sc->rftail) ^ ((val & (IE_FD_EOL|IE_FD_SUSP)) != 0)) {\n\t\t\t/* `rftail' and EOL flag out of sync */\n\t\t\tlog(LOG_ERR,\n\t\t\t    \"%s: rx frame list out of sync at %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, n);\n\t\t\treturn (1);\n\t\t}\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i82596_start_cmd",
          "args": [
            "sc",
            "IE_RUC_RESUME",
            "0",
            "0",
            "0"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "i82596_start_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "398-468",
          "snippet": "int\ni82596_start_cmd(sc, cmd, iecmdbuf, mask, async)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tint iecmdbuf;\n\tint mask;\n\tint async;\n{\n\tregister int i, off;\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_CMDS)\n\t\tprintf(\"start_cmd: %p, %x, %x, %b, %ssync\\n\",\n\t\t       sc, cmd, iecmdbuf, mask, IE_STAT_BITS, async?\"a\":\"\");\n#endif\n\tif (sc->async_cmd_inprogress != 0) {\n\t\t/*\n\t\t * If previous command was issued asynchronously, wait\n\t\t * for it now.\n\t\t */\n\t\tif (i82596_cmd_wait(sc) != 0)\n\t\t\treturn (1);\n\t\tsc->async_cmd_inprogress = 0;\n\t}\n\n\toff = IE_SCB_CMD(sc->scb);\n\t(sc->ie_bus_write16)(sc, off, cmd);\n\tbus_space_barrier(sc->bt, sc->bh, off, 2, BUS_SPACE_BARRIER_WRITE);\n\t(sc->chan_attn)(sc);\n\n\tif (async) {\n\t\tsc->async_cmd_inprogress = 1;\n\t\treturn (0);\n\t}\n\n\tif (IE_ACTION_COMMAND(cmd) && iecmdbuf) {\n\t\tint status;\n\t\t/*\n\t\t * Now spin-lock waiting for status.  This is not a very nice\n\t\t * thing to do, and can kill performance pretty well...\n\t\t * According to the packet driver, the minimum timeout\n\t\t * should be .369 seconds.\n\t\t */\n\t\tfor (i = 0; i < 36900; i++) {\n\t\t\t/* Read the command status */\n\t\t\toff = IE_CMD_COMMON_STATUS(iecmdbuf);\n\t\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\t\tstatus = (sc->ie_bus_read16)(sc, off);\n\t\t\tif (status & mask) {\n#ifdef I82596_DEBUG\n\t\t\t\tif (sc->sc_debug & IED_CMDS)\n\t\t\t\t\tprintf (\"%s: cmd status %b\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\t\tstatus, IE_STAT_BITS);\n#endif\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tdelay(10);\n\t\t}\n\n\t} else {\n\t\t/*\n\t\t * Otherwise, just wait for the command to be accepted.\n\t\t */\n\t\treturn (i82596_cmd_wait(sc));\n\t}\n\n\t/* Timeout */\n\treturn (1);\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\ti82596_cmd_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ti82596_cmd_wait;\n\nint\ni82596_start_cmd(sc, cmd, iecmdbuf, mask, async)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tint iecmdbuf;\n\tint mask;\n\tint async;\n{\n\tregister int i, off;\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_CMDS)\n\t\tprintf(\"start_cmd: %p, %x, %x, %b, %ssync\\n\",\n\t\t       sc, cmd, iecmdbuf, mask, IE_STAT_BITS, async?\"a\":\"\");\n#endif\n\tif (sc->async_cmd_inprogress != 0) {\n\t\t/*\n\t\t * If previous command was issued asynchronously, wait\n\t\t * for it now.\n\t\t */\n\t\tif (i82596_cmd_wait(sc) != 0)\n\t\t\treturn (1);\n\t\tsc->async_cmd_inprogress = 0;\n\t}\n\n\toff = IE_SCB_CMD(sc->scb);\n\t(sc->ie_bus_write16)(sc, off, cmd);\n\tbus_space_barrier(sc->bt, sc->bh, off, 2, BUS_SPACE_BARRIER_WRITE);\n\t(sc->chan_attn)(sc);\n\n\tif (async) {\n\t\tsc->async_cmd_inprogress = 1;\n\t\treturn (0);\n\t}\n\n\tif (IE_ACTION_COMMAND(cmd) && iecmdbuf) {\n\t\tint status;\n\t\t/*\n\t\t * Now spin-lock waiting for status.  This is not a very nice\n\t\t * thing to do, and can kill performance pretty well...\n\t\t * According to the packet driver, the minimum timeout\n\t\t * should be .369 seconds.\n\t\t */\n\t\tfor (i = 0; i < 36900; i++) {\n\t\t\t/* Read the command status */\n\t\t\toff = IE_CMD_COMMON_STATUS(iecmdbuf);\n\t\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\t\tstatus = (sc->ie_bus_read16)(sc, off);\n\t\t\tif (status & mask) {\n#ifdef I82596_DEBUG\n\t\t\t\tif (sc->sc_debug & IED_CMDS)\n\t\t\t\t\tprintf (\"%s: cmd status %b\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\t\tstatus, IE_STAT_BITS);\n#endif\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tdelay(10);\n\t\t}\n\n\t} else {\n\t\t/*\n\t\t * Otherwise, just wait for the command to be accepted.\n\t\t */\n\t\treturn (i82596_cmd_wait(sc));\n\t}\n\n\t/* Timeout */\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i82596_readframe",
          "args": [
            "sc",
            "i"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "i82596_readframe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "1070-1129",
          "snippet": "int\ni82596_readframe(sc, num)\n\tstruct ie_softc *sc;\n\tint num;\t\t/* frame number to read */\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tstruct mbuf *m;\n\tstruct ether_header eh;\n\tu_int16_t bstart, bend;\n\tint pktlen;\n\n\tif (i82596_get_rbd_list(sc, &bstart, &bend, &pktlen) == 0) {\n\t\tifp->if_ierrors++;\n\t\treturn (1);\n\t}\n\n\tm = i82596_get(sc, &eh, bstart, pktlen);\n\ti82596_release_rbd_list(sc, bstart, bend);\n\n\tif (m == 0) {\n\t\tsc->sc_arpcom.ac_if.if_ierrors++;\n\t\treturn (0);\n\t}\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_READFRAME)\n\t\tprintf(\"%s: frame from ether %s type 0x%x len %d\\n\",\n\t\t       sc->sc_dev.dv_xname,\n\t\t       ether_sprintf(eh.ether_shost),\n\t\t       (u_int)eh.ether_type, pktlen);\n#endif\n\n#if NBPFILTER > 0\n\t/*\n\t * Check for a BPF filter; if so, hand it up.\n\t * Note that we have to stick an extra mbuf up front, because bpf_mtap\n\t * expects to have the ether header at the front.\n\t * It doesn't matter that this results in an ill-formatted mbuf chain,\n\t * since BPF just looks at the data.  (It doesn't try to free the mbuf,\n\t * tho' it will make a copy for tcpdump.)\n\t */\n\tif (ifp->if_bpf) {\n\t\tstruct mbuf m0;\n\t\tm0.m_len = sizeof eh;\n\t\tm0.m_data = (caddr_t)&eh;\n\t\tm0.m_next = m;\n\n\t\t/* Pass it up. */\n\t\tbpf_mtap(ifp->if_bpf, &m0);\n\n\t}\n#endif /* NBPFILTER > 0 */\n\n\t/*\n\t * Finally pass this packet up to higher layers.\n\t */\n\tether_input(ifp, &eh, m);\n\tifp->if_ipackets++;\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int \ti82596_readframe",
            "int\ti82596_get_rbd_list",
            "void\ti82596_release_rbd_list"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint \ti82596_readframe;\nint\ti82596_get_rbd_list;\nvoid\ti82596_release_rbd_list;\n\nint\ni82596_readframe(sc, num)\n\tstruct ie_softc *sc;\n\tint num;\t\t/* frame number to read */\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tstruct mbuf *m;\n\tstruct ether_header eh;\n\tu_int16_t bstart, bend;\n\tint pktlen;\n\n\tif (i82596_get_rbd_list(sc, &bstart, &bend, &pktlen) == 0) {\n\t\tifp->if_ierrors++;\n\t\treturn (1);\n\t}\n\n\tm = i82596_get(sc, &eh, bstart, pktlen);\n\ti82596_release_rbd_list(sc, bstart, bend);\n\n\tif (m == 0) {\n\t\tsc->sc_arpcom.ac_if.if_ierrors++;\n\t\treturn (0);\n\t}\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_READFRAME)\n\t\tprintf(\"%s: frame from ether %s type 0x%x len %d\\n\",\n\t\t       sc->sc_dev.dv_xname,\n\t\t       ether_sprintf(eh.ether_shost),\n\t\t       (u_int)eh.ether_type, pktlen);\n#endif\n\n#if NBPFILTER > 0\n\t/*\n\t * Check for a BPF filter; if so, hand it up.\n\t * Note that we have to stick an extra mbuf up front, because bpf_mtap\n\t * expects to have the ether header at the front.\n\t * It doesn't matter that this results in an ill-formatted mbuf chain,\n\t * since BPF just looks at the data.  (It doesn't try to free the mbuf,\n\t * tho' it will make a copy for tcpdump.)\n\t */\n\tif (ifp->if_bpf) {\n\t\tstruct mbuf m0;\n\t\tm0.m_len = sizeof eh;\n\t\tm0.m_data = (caddr_t)&eh;\n\t\tm0.m_next = m;\n\n\t\t/* Pass it up. */\n\t\tbpf_mtap(ifp->if_bpf, &m0);\n\n\t}\n#endif /* NBPFILTER > 0 */\n\n\t/*\n\t * Finally pass this packet up to higher layers.\n\t */\n\tether_input(ifp, &eh, m);\n\tifp->if_ipackets++;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i82596_drop_frames",
          "args": [
            "sc"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "i82596_drop_frames",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "904-915",
          "snippet": "int\ni82596_drop_frames(sc)\n\tstruct ie_softc *sc;\n{\n\tu_int16_t bstart, bend;\n\tint pktlen;\n\n\tif (!i82596_get_rbd_list(sc, &bstart, &bend, &pktlen))\n\t\treturn (1);\n\ti82596_release_rbd_list(sc, bstart, bend);\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\ti82596_get_rbd_list",
            "void\ti82596_release_rbd_list",
            "int\ti82596_drop_frames"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ti82596_get_rbd_list;\nvoid\ti82596_release_rbd_list;\nint\ti82596_drop_frames;\n\nint\ni82596_drop_frames(sc)\n\tstruct ie_softc *sc;\n{\n\tu_int16_t bstart, bend;\n\tint pktlen;\n\n\tif (!i82596_get_rbd_list(sc, &bstart, &bend, &pktlen))\n\t\treturn (1);\n\ti82596_release_rbd_list(sc, bstart, bend);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_write16",
          "args": [
            "sc",
            "off",
            "0"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_RFRAME_LAST",
          "args": [
            "sc->rframes",
            "sc->rftail"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_write16",
          "args": [
            "sc",
            "off",
            "0xffff"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_RFRAME_BUFDESC",
          "args": [
            "sc->rframes",
            "i"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_write16",
          "args": [
            "sc",
            "off",
            "IE_FD_EOL|IE_FD_SUSP"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_RFRAME_LAST",
          "args": [
            "sc->rframes",
            "i"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_write16",
          "args": [
            "sc",
            "off",
            "0"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i82596_rx_errors",
          "args": [
            "sc",
            "i",
            "status"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "i82596_rx_errors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "491-496",
          "snippet": "static __inline void\ni82596_rx_errors(struct ie_softc *sc, int fn, int status)\n{\n\tlog(LOG_ERR, \"%s: rx error (frame# %d): %b\\n\", sc->sc_dev.dv_xname, fn,\n\t    status, IE_FD_STATUSBITS);\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline void\ni82596_rx_errors(struct ie_softc *sc, int fn, int status)\n{\n\tlog(LOG_ERR, \"%s: rx error (frame# %d): %b\\n\", sc->sc_dev.dv_xname, fn,\n\t    status, IE_FD_STATUSBITS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i82596_count_errors",
          "args": [
            "sc"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "i82596_count_errors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "473-489",
          "snippet": "static __inline void\ni82596_count_errors(struct ie_softc *sc)\n{\n\tint scb = sc->scb;\n\n\tsc->sc_arpcom.ac_if.if_ierrors +=\n\t    sc->ie_bus_read16(sc, IE_SCB_ERRCRC(scb)) +\n\t    sc->ie_bus_read16(sc, IE_SCB_ERRALN(scb)) +\n\t    sc->ie_bus_read16(sc, IE_SCB_ERRRES(scb)) +\n\t    sc->ie_bus_read16(sc, IE_SCB_ERROVR(scb));\n\n\t/* Clear error counters */\n\tsc->ie_bus_write16(sc, IE_SCB_ERRCRC(scb), 0);\n\tsc->ie_bus_write16(sc, IE_SCB_ERRALN(scb), 0);\n\tsc->ie_bus_write16(sc, IE_SCB_ERRRES(scb), 0);\n\tsc->ie_bus_write16(sc, IE_SCB_ERROVR(scb), 0);\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline void\ni82596_count_errors(struct ie_softc *sc)\n{\n\tint scb = sc->scb;\n\n\tsc->sc_arpcom.ac_if.if_ierrors +=\n\t    sc->ie_bus_read16(sc, IE_SCB_ERRCRC(scb)) +\n\t    sc->ie_bus_read16(sc, IE_SCB_ERRALN(scb)) +\n\t    sc->ie_bus_read16(sc, IE_SCB_ERRRES(scb)) +\n\t    sc->ie_bus_read16(sc, IE_SCB_ERROVR(scb));\n\n\t/* Clear error counters */\n\tsc->ie_bus_write16(sc, IE_SCB_ERRCRC(scb), 0);\n\tsc->ie_bus_write16(sc, IE_SCB_ERRALN(scb), 0);\n\tsc->ie_bus_write16(sc, IE_SCB_ERRRES(scb), 0);\n\tsc->ie_bus_write16(sc, IE_SCB_ERROVR(scb), 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_read16",
          "args": [
            "sc",
            "off"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_barrier",
          "args": [
            "sc->bt",
            "sc->bh",
            "off",
            "2",
            "BUS_SPACE_BARRIER_READ"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_RFRAME_STATUS",
          "args": [
            "sc->rframes",
            "i"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ti82596_rint;\nint \ti82596_readframe;\nint\ti82596_drop_frames;\nint\ti82596_chk_rx_ring;\nvoid\ti82596_start_transceiver;\n\nint\ni82596_rint(sc, scbstatus)\n\tstruct\tie_softc *sc;\n\tint\tscbstatus;\n{\n\tstatic int timesthru = 1024;\n\tregister int i, status, off;\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_RINT)\n\t\tprintf(\"%s: rint: status %b\\n\",\n\t\t\tsc->sc_dev.dv_xname, scbstatus, IE_ST_BITS);\n#endif\n\n\tfor (;;) {\n\t\tregister int drop = 0;\n\n\t\ti = sc->rfhead;\n\t\toff = IE_RFRAME_STATUS(sc->rframes, i);\n\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\tstatus = sc->ie_bus_read16(sc, off);\n\n#ifdef I82596_DEBUG\n\t\tif (sc->sc_debug & IED_RINT)\n\t\t\tprintf(\"%s: rint: frame(%d) status %b\\n\",\n\t\t\t\tsc->sc_dev.dv_xname, i, status, IE_ST_BITS);\n#endif\n\t\tif ((status & IE_FD_COMPLETE) == 0) {\n\t\t\tif ((status & IE_FD_OK) != 0) {\n\t\t\t\tprintf(\"%s: rint: weird: \",\n\t\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\t\ti82596_rx_errors(sc, i, status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (--timesthru == 0) {\n\t\t\t\t/* Account the accumulated errors */\n\t\t\t\ti82596_count_errors(sc);\n\t\t\t\ttimesthru = 1024;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if ((status & IE_FD_OK) == 0) {\n\t\t\t/*\n\t\t\t * If the chip is configured to automatically\n\t\t\t * discard bad frames, the only reason we can\n\t\t\t * get here is an \"out-of-resource\" condition.\n\t\t\t */\n\t\t\ti82596_rx_errors(sc, i, status);\n\t\t\tdrop = 1;\n\t\t}\n\n#ifdef I82596_DEBUG\n\t\tif ((status & IE_FD_BUSY) != 0)\n\t\t\tprintf(\"%s: rint: frame(%d) busy; status=%x\\n\",\n\t\t\t\tsc->sc_dev.dv_xname, i, status, IE_ST_BITS);\n#endif\n\n\n\t\t/*\n\t\t * Advance the RFD list, since we're done with\n\t\t * this descriptor.\n\t\t */\n\n\t\t/* Clear frame status */\n\t\tsc->ie_bus_write16(sc, off, 0);\n\n\t\t/* Put fence at this frame (the head) */\n\t\toff = IE_RFRAME_LAST(sc->rframes, i);\n\t\tsc->ie_bus_write16(sc, off, IE_FD_EOL|IE_FD_SUSP);\n\n\t\t/* and clear RBD field */\n\t\toff = IE_RFRAME_BUFDESC(sc->rframes, i);\n\t\tsc->ie_bus_write16(sc, off, 0xffff);\n\n\t\t/* Remove fence from current tail */\n\t\toff = IE_RFRAME_LAST(sc->rframes, sc->rftail);\n\t\tsc->ie_bus_write16(sc, off, 0);\n\n\t\tif (++sc->rftail == sc->nframes)\n\t\t\tsc->rftail = 0;\n\t\tif (++sc->rfhead == sc->nframes)\n\t\t\tsc->rfhead = 0;\n\n\t\t/* Pull the frame off the board */\n\t\tif (drop) {\n\t\t\ti82596_drop_frames(sc);\n\t\t\tif ((status & IE_FD_RNR) != 0)\n\t\t\t\tsc->rnr_expect = 1;\n\t\t\tsc->sc_arpcom.ac_if.if_ierrors++;\n\t\t} else if (i82596_readframe(sc, i) != 0)\n\t\t\treturn (1);\n\t}\n\n\tif ((scbstatus & IE_ST_RNR) != 0) {\n\n\t\t/*\n\t\t * Receiver went \"Not Ready\". We try to figure out\n\t\t * whether this was an expected event based on past\n\t\t * frame status values.\n\t\t */\n\n\t\tif ((scbstatus & IE_RUS_SUSPEND) != 0) {\n\t\t\t/*\n\t\t\t * We use the \"suspend on last frame\" flag.\n\t\t\t * Send a RU RESUME command in response, since\n\t\t\t * we should have dealt with all completed frames\n\t\t\t * by now.\n\t\t\t */\n\t\t\tprintf(\"RINT: SUSPENDED; scbstatus=%b\\n\",\n\t\t\t\tscbstatus, IE_ST_BITS);\n\t\t\tif (i82596_start_cmd(sc, IE_RUC_RESUME, 0, 0, 0) == 0)\n\t\t\t\treturn (0);\n\t\t\tprintf(\"%s: RU RESUME command timed out\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\treturn (1);\t/* Ask for a reset */\n\t\t}\n\n\t\tif (sc->rnr_expect != 0) {\n\t\t\t/*\n\t\t\t * The RNR condition was announced in the previously\n\t\t\t * completed frame.  Assume the receive ring is Ok,\n\t\t\t * so restart the receiver without further delay.\n\t\t\t */\n\t\t\ti82596_start_transceiver(sc);\n\t\t\tsc->rnr_expect = 0;\n\t\t\treturn (0);\n\n\t\t} else if ((scbstatus & IE_RUS_NOSPACE) != 0) {\n\t\t\t/*\n\t\t\t * We saw no previous IF_FD_RNR flag.\n\t\t\t * We check our ring invariants and, if ok,\n\t\t\t * just restart the receiver at the current\n\t\t\t * point in the ring.\n\t\t\t */\n\t\t\tif (i82596_chk_rx_ring(sc) != 0)\n\t\t\t\treturn (1);\n\n\t\t\ti82596_start_transceiver(sc);\n\t\t\tsc->sc_arpcom.ac_if.if_ierrors++;\n\t\t\treturn (0);\n\t\t} else\n\t\t\tprintf(\"%s: receiver not ready; scbstatus=%b\\n\",\n\t\t\t\tsc->sc_dev.dv_xname, scbstatus, IE_ST_BITS);\n\n\t\tsc->sc_arpcom.ac_if.if_ierrors++;\n\t\treturn (1);\t/* Ask for a reset */\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "i82596_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
    "lines": "501-570",
    "snippet": "int\ni82596_intr(v)\n\tvoid *v;\n{\n\tregister struct ie_softc *sc = v;\n\tregister u_int status;\n\tregister int off;\n\n        /*\n         * Implementation dependent interrupt handling.\n         */\n\tif (sc->intrhook)\n\t\t(sc->intrhook)(sc, IE_INTR_ENTER);\n\n\toff = IE_SCB_STATUS(sc->scb);\n\tbus_space_barrier(sc->bt, sc->bh, off, 2, BUS_SPACE_BARRIER_READ);\n\tstatus = sc->ie_bus_read16(sc, off) /* & IE_ST_WHENCE */;\n\n\tif ((status & IE_ST_WHENCE) == 0) {\n\t\tif (sc->intrhook)\n\t\t\t(sc->intrhook)(sc, IE_INTR_EXIT);\n\n\t\treturn (0);\n\t}\n\nloop:\n\t/* Ack interrupts FIRST in case we receive more during the ISR. */\n#if 0\n\tie_ack(sc, status & IE_ST_WHENCE);\n#endif\n\ti82596_start_cmd(sc, status & IE_ST_WHENCE, 0, 0, 1);\n\n\tif (status & (IE_ST_FR | IE_ST_RNR))\n\t\tif (i82596_rint(sc, status) != 0)\n\t\t\tgoto reset;\n\n\tif (status & IE_ST_CX)\n\t\tif (i82596_tint(sc, status) != 0)\n\t\t\tgoto reset;\n\n#ifdef I82596_DEBUG\n\tif ((status & IE_ST_CNA) && (sc->sc_debug & IED_CNA))\n\t\tprintf(\"%s: cna; status=%b\\n\", sc->sc_dev.dv_xname,\n\t\t\tstatus, IE_ST_BITS);\n#endif\n\tif (sc->intrhook)\n\t\t(sc->intrhook)(sc, IE_INTR_LOOP);\n\n\t/*\n\t * Interrupt ACK was posted asynchronously; wait for\n\t * completion here before reading SCB status again.\n\t */\n\ti82596_cmd_wait(sc);\n\n\tbus_space_barrier(sc->bt, sc->bh, off, 2, BUS_SPACE_BARRIER_READ);\n\tstatus = sc->ie_bus_read16(sc, off);\n\tif ((status & IE_ST_WHENCE) != 0)\n\t\tgoto loop;\n\nout:\n\tif (sc->intrhook)\n\t\t(sc->intrhook)(sc, IE_INTR_EXIT);\n\treturn (1);\n\nreset:\n\ti82596_cmd_wait(sc);\n\ti82596_reset(sc, 1);\n\tgoto out;\n\n}",
    "includes": [
      "#include <dev/ic/i82596var.h>",
      "#include <dev/ic/i82596reg.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\ti82596_reset",
      "int\ti82596_rint",
      "int\ti82596_tint",
      "int\ti82596_cmd_wait"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "i82596_reset",
          "args": [
            "sc",
            "1"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "i82596_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "1333-1372",
          "snippet": "void\ni82596_reset(sc, hard)\n\tstruct ie_softc *sc;\n\tint hard;\n{\n\tint s = splnet();\n\n\tif (hard)\n\t\tprintf(\"%s: reset\\n\", sc->sc_dev.dv_xname);\n\n\t/* Clear OACTIVE in case we're called from watchdog (frozen xmit). */\n\tsc->sc_arpcom.ac_if.if_timer = 0;\n\tsc->sc_arpcom.ac_if.if_flags &= ~IFF_OACTIVE;\n\n\t/*\n\t * Stop i82596 dead in its tracks.\n\t */\n\tif (i82596_start_cmd(sc, IE_RUC_ABORT | IE_CUC_ABORT, 0, 0, 0))\n\t\tprintf(\"%s: abort commands timed out\\n\", sc->sc_dev.dv_xname);\n\n\t/*\n\t * This can really slow down the i82596_reset() on some cards, but it's\n\t * necessary to unwedge other ones (eg, the Sun VME ones) from certain\n\t * lockups.\n\t */\n\tif (hard && sc->hwreset)\n\t\t(sc->hwreset)(sc, IE_CARD_RESET);\n\n\tdelay(100);\n\tie_ack(sc, IE_ST_WHENCE);\n\n\tif ((sc->sc_arpcom.ac_if.if_flags & IFF_UP) != 0) {\n\t\tint retries=0;\t/* XXX - find out why init sometimes fails */\n\t\twhile (retries++ < 2)\n\t\t\tif (i82596_init(sc) == 1)\n\t\t\t\tbreak;\n\t}\n\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\ti82596_reset",
            "int\ti82596_init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ti82596_reset;\nint\ti82596_init;\n\nvoid\ni82596_reset(sc, hard)\n\tstruct ie_softc *sc;\n\tint hard;\n{\n\tint s = splnet();\n\n\tif (hard)\n\t\tprintf(\"%s: reset\\n\", sc->sc_dev.dv_xname);\n\n\t/* Clear OACTIVE in case we're called from watchdog (frozen xmit). */\n\tsc->sc_arpcom.ac_if.if_timer = 0;\n\tsc->sc_arpcom.ac_if.if_flags &= ~IFF_OACTIVE;\n\n\t/*\n\t * Stop i82596 dead in its tracks.\n\t */\n\tif (i82596_start_cmd(sc, IE_RUC_ABORT | IE_CUC_ABORT, 0, 0, 0))\n\t\tprintf(\"%s: abort commands timed out\\n\", sc->sc_dev.dv_xname);\n\n\t/*\n\t * This can really slow down the i82596_reset() on some cards, but it's\n\t * necessary to unwedge other ones (eg, the Sun VME ones) from certain\n\t * lockups.\n\t */\n\tif (hard && sc->hwreset)\n\t\t(sc->hwreset)(sc, IE_CARD_RESET);\n\n\tdelay(100);\n\tie_ack(sc, IE_ST_WHENCE);\n\n\tif ((sc->sc_arpcom.ac_if.if_flags & IFF_UP) != 0) {\n\t\tint retries=0;\t/* XXX - find out why init sometimes fails */\n\t\twhile (retries++ < 2)\n\t\t\tif (i82596_init(sc) == 1)\n\t\t\t\tbreak;\n\t}\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i82596_cmd_wait",
          "args": [
            "sc"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "i82596_cmd_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "359-386",
          "snippet": "int\ni82596_cmd_wait(sc)\n\tstruct ie_softc *sc;\n{\n\t/* spin on i82596 command acknowledge; wait at most 0.9 (!) seconds */\n\tregister int i, off;\n\n\tfor (i = 0; i < 90000; i++) {\n\t\t/* Read the command word */\n\t\toff = IE_SCB_CMD(sc->scb);\n\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\tif ((sc->ie_bus_read16)(sc, off) == 0) {\n#ifdef I82596_DEBUG1\n\t\t\tif (sc->sc_debug & IED_CMDS)\n\t\t\t\tprintf (\"%s: cmd_wait after %d usec\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname, (90000 - i) * 10);\n#endif\n\t\t\treturn (0);\n\t\t}\n\t\tdelay(10);\n\t}\n\n\tprintf (\"i82596_cmd_wait: timo(%ssync): scb status: %b\\n\",\n\t\tsc->async_cmd_inprogress?\"a\":\"\",\n\t\tsc->ie_bus_read16(sc, off), IE_STAT_BITS);\n\treturn (1);\t/* Timeout */\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\ti82596_cmd_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ti82596_cmd_wait;\n\nint\ni82596_cmd_wait(sc)\n\tstruct ie_softc *sc;\n{\n\t/* spin on i82596 command acknowledge; wait at most 0.9 (!) seconds */\n\tregister int i, off;\n\n\tfor (i = 0; i < 90000; i++) {\n\t\t/* Read the command word */\n\t\toff = IE_SCB_CMD(sc->scb);\n\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\tif ((sc->ie_bus_read16)(sc, off) == 0) {\n#ifdef I82596_DEBUG1\n\t\t\tif (sc->sc_debug & IED_CMDS)\n\t\t\t\tprintf (\"%s: cmd_wait after %d usec\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname, (90000 - i) * 10);\n#endif\n\t\t\treturn (0);\n\t\t}\n\t\tdelay(10);\n\t}\n\n\tprintf (\"i82596_cmd_wait: timo(%ssync): scb status: %b\\n\",\n\t\tsc->async_cmd_inprogress?\"a\":\"\",\n\t\tsc->ie_bus_read16(sc, off), IE_STAT_BITS);\n\treturn (1);\t/* Timeout */\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "IE_INTR_EXIT"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_read16",
          "args": [
            "sc",
            "off"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_barrier",
          "args": [
            "sc->bt",
            "sc->bh",
            "off",
            "2",
            "BUS_SPACE_BARRIER_READ"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "IE_INTR_LOOP"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: cna; status=%b\\n\"",
            "sc->sc_dev.dv_xname",
            "status",
            "IE_ST_BITS"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i82596_tint",
          "args": [
            "sc",
            "status"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "i82596_tint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "731-813",
          "snippet": "int\ni82596_tint(sc, scbstatus)\n\tstruct ie_softc *sc;\n\tint\tscbstatus;\n{\n\tregister struct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tregister int status;\n\n\tifp->if_timer = 0;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n#ifdef I82596_DEBUG\n\tif (sc->xmit_busy <= 0) {\n\t\tprintf(\"%s: i82596_tint: WEIRD:\"\n\t\t       \"xmit_busy=%d, xctail=%d, xchead=%d\\n\",\n\t\t       sc->sc_dev.dv_xname,\n\t\t       sc->xmit_busy, sc->xctail, sc->xchead);\n\t\treturn (0);\n\t}\n#endif\n\n\tstatus = sc->ie_bus_read16(sc, IE_CMD_XMIT_STATUS(sc->xmit_cmds,\n\t\t\t\t\t\t\t  sc->xctail));\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_TINT)\n\t\tprintf(\"%s: tint: SCB status %b; xmit status %b\\n\",\n\t\t\tsc->sc_dev.dv_xname, scbstatus, IE_ST_BITS,\n\t\t\tstatus, IE_XS_BITS);\n#endif\n\n\tif ((status & IE_STAT_COMPL) == 0 || (status & IE_STAT_BUSY)) {\n\t\tprintf(\"%s: i82596_tint: command still busy;\"\n\t\t       \"status=%b; tail=%d\\n\", sc->sc_dev.dv_xname,\n\t\t       status, IE_XS_BITS, sc->xctail);\n\t\tprintf(\"iestatus = %b\\n\", scbstatus, IE_ST_BITS);\n\t}\n\n\tif (status & IE_STAT_OK) {\n\t\tifp->if_opackets++;\n\t\tifp->if_collisions += (status & IE_XS_MAXCOLL);\n\t} else {\n\t\tifp->if_oerrors++;\n\t\t/*\n\t\t * Check SQE and DEFERRED?\n\t\t * What if more than one bit is set?\n\t\t */\n\t\tif (status & IE_STAT_ABORT)\n\t\t\tprintf(\"%s: send aborted\\n\", sc->sc_dev.dv_xname);\n\t\telse if (status & IE_XS_NOCARRIER)\n\t\t\tprintf(\"%s: no carrier\\n\", sc->sc_dev.dv_xname);\n\t\telse if (status & IE_XS_LOSTCTS)\n\t\t\tprintf(\"%s: lost CTS\\n\", sc->sc_dev.dv_xname);\n\t\telse if (status & IE_XS_UNDERRUN)\n\t\t\tprintf(\"%s: DMA underrun\\n\", sc->sc_dev.dv_xname);\n\t\telse if (status & IE_XS_EXCMAX) {\n\t\t\tprintf(\"%s: too many collisions\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\tsc->sc_arpcom.ac_if.if_collisions += 16;\n\t\t}\n\t}\n\n\t/*\n\t * If multicast addresses were added or deleted while transmitting,\n\t * ie_mc_reset() set the want_mcsetup flag indicating that we\n\t * should do it.\n\t */\n\tif (sc->want_mcsetup) {\n\t\tie_mc_setup(sc, IE_XBUF_ADDR(sc, sc->xctail));\n\t\tsc->want_mcsetup = 0;\n\t}\n\n\t/* Done with the buffer. */\n\tsc->xmit_busy--;\n\tsc->xctail = (sc->xctail + 1) % NTXBUF;\n\n\t/* Start the next packet, if any, transmitting. */\n\tif (sc->xmit_busy > 0)\n\t\ti82596_xmit(sc);\n\n\ti82596_start(ifp);\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\ti82596_start",
            "int\ti82596_tint",
            "void \ti82596_xmit",
            "int \tie_mc_setup",
            "void \tie_mc_reset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ti82596_start;\nint\ti82596_tint;\nvoid \ti82596_xmit;\nint \tie_mc_setup;\nvoid \tie_mc_reset;\n\nint\ni82596_tint(sc, scbstatus)\n\tstruct ie_softc *sc;\n\tint\tscbstatus;\n{\n\tregister struct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tregister int status;\n\n\tifp->if_timer = 0;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n#ifdef I82596_DEBUG\n\tif (sc->xmit_busy <= 0) {\n\t\tprintf(\"%s: i82596_tint: WEIRD:\"\n\t\t       \"xmit_busy=%d, xctail=%d, xchead=%d\\n\",\n\t\t       sc->sc_dev.dv_xname,\n\t\t       sc->xmit_busy, sc->xctail, sc->xchead);\n\t\treturn (0);\n\t}\n#endif\n\n\tstatus = sc->ie_bus_read16(sc, IE_CMD_XMIT_STATUS(sc->xmit_cmds,\n\t\t\t\t\t\t\t  sc->xctail));\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_TINT)\n\t\tprintf(\"%s: tint: SCB status %b; xmit status %b\\n\",\n\t\t\tsc->sc_dev.dv_xname, scbstatus, IE_ST_BITS,\n\t\t\tstatus, IE_XS_BITS);\n#endif\n\n\tif ((status & IE_STAT_COMPL) == 0 || (status & IE_STAT_BUSY)) {\n\t\tprintf(\"%s: i82596_tint: command still busy;\"\n\t\t       \"status=%b; tail=%d\\n\", sc->sc_dev.dv_xname,\n\t\t       status, IE_XS_BITS, sc->xctail);\n\t\tprintf(\"iestatus = %b\\n\", scbstatus, IE_ST_BITS);\n\t}\n\n\tif (status & IE_STAT_OK) {\n\t\tifp->if_opackets++;\n\t\tifp->if_collisions += (status & IE_XS_MAXCOLL);\n\t} else {\n\t\tifp->if_oerrors++;\n\t\t/*\n\t\t * Check SQE and DEFERRED?\n\t\t * What if more than one bit is set?\n\t\t */\n\t\tif (status & IE_STAT_ABORT)\n\t\t\tprintf(\"%s: send aborted\\n\", sc->sc_dev.dv_xname);\n\t\telse if (status & IE_XS_NOCARRIER)\n\t\t\tprintf(\"%s: no carrier\\n\", sc->sc_dev.dv_xname);\n\t\telse if (status & IE_XS_LOSTCTS)\n\t\t\tprintf(\"%s: lost CTS\\n\", sc->sc_dev.dv_xname);\n\t\telse if (status & IE_XS_UNDERRUN)\n\t\t\tprintf(\"%s: DMA underrun\\n\", sc->sc_dev.dv_xname);\n\t\telse if (status & IE_XS_EXCMAX) {\n\t\t\tprintf(\"%s: too many collisions\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\tsc->sc_arpcom.ac_if.if_collisions += 16;\n\t\t}\n\t}\n\n\t/*\n\t * If multicast addresses were added or deleted while transmitting,\n\t * ie_mc_reset() set the want_mcsetup flag indicating that we\n\t * should do it.\n\t */\n\tif (sc->want_mcsetup) {\n\t\tie_mc_setup(sc, IE_XBUF_ADDR(sc, sc->xctail));\n\t\tsc->want_mcsetup = 0;\n\t}\n\n\t/* Done with the buffer. */\n\tsc->xmit_busy--;\n\tsc->xctail = (sc->xctail + 1) % NTXBUF;\n\n\t/* Start the next packet, if any, transmitting. */\n\tif (sc->xmit_busy > 0)\n\t\ti82596_xmit(sc);\n\n\ti82596_start(ifp);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i82596_rint",
          "args": [
            "sc",
            "status"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "i82596_rint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "575-724",
          "snippet": "int\ni82596_rint(sc, scbstatus)\n\tstruct\tie_softc *sc;\n\tint\tscbstatus;\n{\n\tstatic int timesthru = 1024;\n\tregister int i, status, off;\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_RINT)\n\t\tprintf(\"%s: rint: status %b\\n\",\n\t\t\tsc->sc_dev.dv_xname, scbstatus, IE_ST_BITS);\n#endif\n\n\tfor (;;) {\n\t\tregister int drop = 0;\n\n\t\ti = sc->rfhead;\n\t\toff = IE_RFRAME_STATUS(sc->rframes, i);\n\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\tstatus = sc->ie_bus_read16(sc, off);\n\n#ifdef I82596_DEBUG\n\t\tif (sc->sc_debug & IED_RINT)\n\t\t\tprintf(\"%s: rint: frame(%d) status %b\\n\",\n\t\t\t\tsc->sc_dev.dv_xname, i, status, IE_ST_BITS);\n#endif\n\t\tif ((status & IE_FD_COMPLETE) == 0) {\n\t\t\tif ((status & IE_FD_OK) != 0) {\n\t\t\t\tprintf(\"%s: rint: weird: \",\n\t\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\t\ti82596_rx_errors(sc, i, status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (--timesthru == 0) {\n\t\t\t\t/* Account the accumulated errors */\n\t\t\t\ti82596_count_errors(sc);\n\t\t\t\ttimesthru = 1024;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if ((status & IE_FD_OK) == 0) {\n\t\t\t/*\n\t\t\t * If the chip is configured to automatically\n\t\t\t * discard bad frames, the only reason we can\n\t\t\t * get here is an \"out-of-resource\" condition.\n\t\t\t */\n\t\t\ti82596_rx_errors(sc, i, status);\n\t\t\tdrop = 1;\n\t\t}\n\n#ifdef I82596_DEBUG\n\t\tif ((status & IE_FD_BUSY) != 0)\n\t\t\tprintf(\"%s: rint: frame(%d) busy; status=%x\\n\",\n\t\t\t\tsc->sc_dev.dv_xname, i, status, IE_ST_BITS);\n#endif\n\n\n\t\t/*\n\t\t * Advance the RFD list, since we're done with\n\t\t * this descriptor.\n\t\t */\n\n\t\t/* Clear frame status */\n\t\tsc->ie_bus_write16(sc, off, 0);\n\n\t\t/* Put fence at this frame (the head) */\n\t\toff = IE_RFRAME_LAST(sc->rframes, i);\n\t\tsc->ie_bus_write16(sc, off, IE_FD_EOL|IE_FD_SUSP);\n\n\t\t/* and clear RBD field */\n\t\toff = IE_RFRAME_BUFDESC(sc->rframes, i);\n\t\tsc->ie_bus_write16(sc, off, 0xffff);\n\n\t\t/* Remove fence from current tail */\n\t\toff = IE_RFRAME_LAST(sc->rframes, sc->rftail);\n\t\tsc->ie_bus_write16(sc, off, 0);\n\n\t\tif (++sc->rftail == sc->nframes)\n\t\t\tsc->rftail = 0;\n\t\tif (++sc->rfhead == sc->nframes)\n\t\t\tsc->rfhead = 0;\n\n\t\t/* Pull the frame off the board */\n\t\tif (drop) {\n\t\t\ti82596_drop_frames(sc);\n\t\t\tif ((status & IE_FD_RNR) != 0)\n\t\t\t\tsc->rnr_expect = 1;\n\t\t\tsc->sc_arpcom.ac_if.if_ierrors++;\n\t\t} else if (i82596_readframe(sc, i) != 0)\n\t\t\treturn (1);\n\t}\n\n\tif ((scbstatus & IE_ST_RNR) != 0) {\n\n\t\t/*\n\t\t * Receiver went \"Not Ready\". We try to figure out\n\t\t * whether this was an expected event based on past\n\t\t * frame status values.\n\t\t */\n\n\t\tif ((scbstatus & IE_RUS_SUSPEND) != 0) {\n\t\t\t/*\n\t\t\t * We use the \"suspend on last frame\" flag.\n\t\t\t * Send a RU RESUME command in response, since\n\t\t\t * we should have dealt with all completed frames\n\t\t\t * by now.\n\t\t\t */\n\t\t\tprintf(\"RINT: SUSPENDED; scbstatus=%b\\n\",\n\t\t\t\tscbstatus, IE_ST_BITS);\n\t\t\tif (i82596_start_cmd(sc, IE_RUC_RESUME, 0, 0, 0) == 0)\n\t\t\t\treturn (0);\n\t\t\tprintf(\"%s: RU RESUME command timed out\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\treturn (1);\t/* Ask for a reset */\n\t\t}\n\n\t\tif (sc->rnr_expect != 0) {\n\t\t\t/*\n\t\t\t * The RNR condition was announced in the previously\n\t\t\t * completed frame.  Assume the receive ring is Ok,\n\t\t\t * so restart the receiver without further delay.\n\t\t\t */\n\t\t\ti82596_start_transceiver(sc);\n\t\t\tsc->rnr_expect = 0;\n\t\t\treturn (0);\n\n\t\t} else if ((scbstatus & IE_RUS_NOSPACE) != 0) {\n\t\t\t/*\n\t\t\t * We saw no previous IF_FD_RNR flag.\n\t\t\t * We check our ring invariants and, if ok,\n\t\t\t * just restart the receiver at the current\n\t\t\t * point in the ring.\n\t\t\t */\n\t\t\tif (i82596_chk_rx_ring(sc) != 0)\n\t\t\t\treturn (1);\n\n\t\t\ti82596_start_transceiver(sc);\n\t\t\tsc->sc_arpcom.ac_if.if_ierrors++;\n\t\t\treturn (0);\n\t\t} else\n\t\t\tprintf(\"%s: receiver not ready; scbstatus=%b\\n\",\n\t\t\t\tsc->sc_dev.dv_xname, scbstatus, IE_ST_BITS);\n\n\t\tsc->sc_arpcom.ac_if.if_ierrors++;\n\t\treturn (1);\t/* Ask for a reset */\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\ti82596_rint",
            "int \ti82596_readframe",
            "int\ti82596_drop_frames",
            "int\ti82596_chk_rx_ring",
            "void\ti82596_start_transceiver"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ti82596_rint;\nint \ti82596_readframe;\nint\ti82596_drop_frames;\nint\ti82596_chk_rx_ring;\nvoid\ti82596_start_transceiver;\n\nint\ni82596_rint(sc, scbstatus)\n\tstruct\tie_softc *sc;\n\tint\tscbstatus;\n{\n\tstatic int timesthru = 1024;\n\tregister int i, status, off;\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_RINT)\n\t\tprintf(\"%s: rint: status %b\\n\",\n\t\t\tsc->sc_dev.dv_xname, scbstatus, IE_ST_BITS);\n#endif\n\n\tfor (;;) {\n\t\tregister int drop = 0;\n\n\t\ti = sc->rfhead;\n\t\toff = IE_RFRAME_STATUS(sc->rframes, i);\n\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\tstatus = sc->ie_bus_read16(sc, off);\n\n#ifdef I82596_DEBUG\n\t\tif (sc->sc_debug & IED_RINT)\n\t\t\tprintf(\"%s: rint: frame(%d) status %b\\n\",\n\t\t\t\tsc->sc_dev.dv_xname, i, status, IE_ST_BITS);\n#endif\n\t\tif ((status & IE_FD_COMPLETE) == 0) {\n\t\t\tif ((status & IE_FD_OK) != 0) {\n\t\t\t\tprintf(\"%s: rint: weird: \",\n\t\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\t\ti82596_rx_errors(sc, i, status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (--timesthru == 0) {\n\t\t\t\t/* Account the accumulated errors */\n\t\t\t\ti82596_count_errors(sc);\n\t\t\t\ttimesthru = 1024;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if ((status & IE_FD_OK) == 0) {\n\t\t\t/*\n\t\t\t * If the chip is configured to automatically\n\t\t\t * discard bad frames, the only reason we can\n\t\t\t * get here is an \"out-of-resource\" condition.\n\t\t\t */\n\t\t\ti82596_rx_errors(sc, i, status);\n\t\t\tdrop = 1;\n\t\t}\n\n#ifdef I82596_DEBUG\n\t\tif ((status & IE_FD_BUSY) != 0)\n\t\t\tprintf(\"%s: rint: frame(%d) busy; status=%x\\n\",\n\t\t\t\tsc->sc_dev.dv_xname, i, status, IE_ST_BITS);\n#endif\n\n\n\t\t/*\n\t\t * Advance the RFD list, since we're done with\n\t\t * this descriptor.\n\t\t */\n\n\t\t/* Clear frame status */\n\t\tsc->ie_bus_write16(sc, off, 0);\n\n\t\t/* Put fence at this frame (the head) */\n\t\toff = IE_RFRAME_LAST(sc->rframes, i);\n\t\tsc->ie_bus_write16(sc, off, IE_FD_EOL|IE_FD_SUSP);\n\n\t\t/* and clear RBD field */\n\t\toff = IE_RFRAME_BUFDESC(sc->rframes, i);\n\t\tsc->ie_bus_write16(sc, off, 0xffff);\n\n\t\t/* Remove fence from current tail */\n\t\toff = IE_RFRAME_LAST(sc->rframes, sc->rftail);\n\t\tsc->ie_bus_write16(sc, off, 0);\n\n\t\tif (++sc->rftail == sc->nframes)\n\t\t\tsc->rftail = 0;\n\t\tif (++sc->rfhead == sc->nframes)\n\t\t\tsc->rfhead = 0;\n\n\t\t/* Pull the frame off the board */\n\t\tif (drop) {\n\t\t\ti82596_drop_frames(sc);\n\t\t\tif ((status & IE_FD_RNR) != 0)\n\t\t\t\tsc->rnr_expect = 1;\n\t\t\tsc->sc_arpcom.ac_if.if_ierrors++;\n\t\t} else if (i82596_readframe(sc, i) != 0)\n\t\t\treturn (1);\n\t}\n\n\tif ((scbstatus & IE_ST_RNR) != 0) {\n\n\t\t/*\n\t\t * Receiver went \"Not Ready\". We try to figure out\n\t\t * whether this was an expected event based on past\n\t\t * frame status values.\n\t\t */\n\n\t\tif ((scbstatus & IE_RUS_SUSPEND) != 0) {\n\t\t\t/*\n\t\t\t * We use the \"suspend on last frame\" flag.\n\t\t\t * Send a RU RESUME command in response, since\n\t\t\t * we should have dealt with all completed frames\n\t\t\t * by now.\n\t\t\t */\n\t\t\tprintf(\"RINT: SUSPENDED; scbstatus=%b\\n\",\n\t\t\t\tscbstatus, IE_ST_BITS);\n\t\t\tif (i82596_start_cmd(sc, IE_RUC_RESUME, 0, 0, 0) == 0)\n\t\t\t\treturn (0);\n\t\t\tprintf(\"%s: RU RESUME command timed out\\n\",\n\t\t\t\tsc->sc_dev.dv_xname);\n\t\t\treturn (1);\t/* Ask for a reset */\n\t\t}\n\n\t\tif (sc->rnr_expect != 0) {\n\t\t\t/*\n\t\t\t * The RNR condition was announced in the previously\n\t\t\t * completed frame.  Assume the receive ring is Ok,\n\t\t\t * so restart the receiver without further delay.\n\t\t\t */\n\t\t\ti82596_start_transceiver(sc);\n\t\t\tsc->rnr_expect = 0;\n\t\t\treturn (0);\n\n\t\t} else if ((scbstatus & IE_RUS_NOSPACE) != 0) {\n\t\t\t/*\n\t\t\t * We saw no previous IF_FD_RNR flag.\n\t\t\t * We check our ring invariants and, if ok,\n\t\t\t * just restart the receiver at the current\n\t\t\t * point in the ring.\n\t\t\t */\n\t\t\tif (i82596_chk_rx_ring(sc) != 0)\n\t\t\t\treturn (1);\n\n\t\t\ti82596_start_transceiver(sc);\n\t\t\tsc->sc_arpcom.ac_if.if_ierrors++;\n\t\t\treturn (0);\n\t\t} else\n\t\t\tprintf(\"%s: receiver not ready; scbstatus=%b\\n\",\n\t\t\t\tsc->sc_dev.dv_xname, scbstatus, IE_ST_BITS);\n\n\t\tsc->sc_arpcom.ac_if.if_ierrors++;\n\t\treturn (1);\t/* Ask for a reset */\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i82596_start_cmd",
          "args": [
            "sc",
            "status & IE_ST_WHENCE",
            "0",
            "0",
            "1"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "i82596_start_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "398-468",
          "snippet": "int\ni82596_start_cmd(sc, cmd, iecmdbuf, mask, async)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tint iecmdbuf;\n\tint mask;\n\tint async;\n{\n\tregister int i, off;\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_CMDS)\n\t\tprintf(\"start_cmd: %p, %x, %x, %b, %ssync\\n\",\n\t\t       sc, cmd, iecmdbuf, mask, IE_STAT_BITS, async?\"a\":\"\");\n#endif\n\tif (sc->async_cmd_inprogress != 0) {\n\t\t/*\n\t\t * If previous command was issued asynchronously, wait\n\t\t * for it now.\n\t\t */\n\t\tif (i82596_cmd_wait(sc) != 0)\n\t\t\treturn (1);\n\t\tsc->async_cmd_inprogress = 0;\n\t}\n\n\toff = IE_SCB_CMD(sc->scb);\n\t(sc->ie_bus_write16)(sc, off, cmd);\n\tbus_space_barrier(sc->bt, sc->bh, off, 2, BUS_SPACE_BARRIER_WRITE);\n\t(sc->chan_attn)(sc);\n\n\tif (async) {\n\t\tsc->async_cmd_inprogress = 1;\n\t\treturn (0);\n\t}\n\n\tif (IE_ACTION_COMMAND(cmd) && iecmdbuf) {\n\t\tint status;\n\t\t/*\n\t\t * Now spin-lock waiting for status.  This is not a very nice\n\t\t * thing to do, and can kill performance pretty well...\n\t\t * According to the packet driver, the minimum timeout\n\t\t * should be .369 seconds.\n\t\t */\n\t\tfor (i = 0; i < 36900; i++) {\n\t\t\t/* Read the command status */\n\t\t\toff = IE_CMD_COMMON_STATUS(iecmdbuf);\n\t\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\t\tstatus = (sc->ie_bus_read16)(sc, off);\n\t\t\tif (status & mask) {\n#ifdef I82596_DEBUG\n\t\t\t\tif (sc->sc_debug & IED_CMDS)\n\t\t\t\t\tprintf (\"%s: cmd status %b\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\t\tstatus, IE_STAT_BITS);\n#endif\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tdelay(10);\n\t\t}\n\n\t} else {\n\t\t/*\n\t\t * Otherwise, just wait for the command to be accepted.\n\t\t */\n\t\treturn (i82596_cmd_wait(sc));\n\t}\n\n\t/* Timeout */\n\treturn (1);\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\ti82596_cmd_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ti82596_cmd_wait;\n\nint\ni82596_start_cmd(sc, cmd, iecmdbuf, mask, async)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tint iecmdbuf;\n\tint mask;\n\tint async;\n{\n\tregister int i, off;\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_CMDS)\n\t\tprintf(\"start_cmd: %p, %x, %x, %b, %ssync\\n\",\n\t\t       sc, cmd, iecmdbuf, mask, IE_STAT_BITS, async?\"a\":\"\");\n#endif\n\tif (sc->async_cmd_inprogress != 0) {\n\t\t/*\n\t\t * If previous command was issued asynchronously, wait\n\t\t * for it now.\n\t\t */\n\t\tif (i82596_cmd_wait(sc) != 0)\n\t\t\treturn (1);\n\t\tsc->async_cmd_inprogress = 0;\n\t}\n\n\toff = IE_SCB_CMD(sc->scb);\n\t(sc->ie_bus_write16)(sc, off, cmd);\n\tbus_space_barrier(sc->bt, sc->bh, off, 2, BUS_SPACE_BARRIER_WRITE);\n\t(sc->chan_attn)(sc);\n\n\tif (async) {\n\t\tsc->async_cmd_inprogress = 1;\n\t\treturn (0);\n\t}\n\n\tif (IE_ACTION_COMMAND(cmd) && iecmdbuf) {\n\t\tint status;\n\t\t/*\n\t\t * Now spin-lock waiting for status.  This is not a very nice\n\t\t * thing to do, and can kill performance pretty well...\n\t\t * According to the packet driver, the minimum timeout\n\t\t * should be .369 seconds.\n\t\t */\n\t\tfor (i = 0; i < 36900; i++) {\n\t\t\t/* Read the command status */\n\t\t\toff = IE_CMD_COMMON_STATUS(iecmdbuf);\n\t\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\t\tstatus = (sc->ie_bus_read16)(sc, off);\n\t\t\tif (status & mask) {\n#ifdef I82596_DEBUG\n\t\t\t\tif (sc->sc_debug & IED_CMDS)\n\t\t\t\t\tprintf (\"%s: cmd status %b\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\t\tstatus, IE_STAT_BITS);\n#endif\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tdelay(10);\n\t\t}\n\n\t} else {\n\t\t/*\n\t\t * Otherwise, just wait for the command to be accepted.\n\t\t */\n\t\treturn (i82596_cmd_wait(sc));\n\t}\n\n\t/* Timeout */\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ie_ack",
          "args": [
            "sc",
            "status & IE_ST_WHENCE"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "ie_ack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596var.h",
          "lines": "297-305",
          "snippet": "static __inline__ void\nie_ack(struct ie_softc *sc, u_int mask) /* in native byte-order */\n{\n\tregister u_int status;\n\n\tbus_space_barrier(sc->bt, sc->bh, 0, 0, BUS_SPACE_BARRIER_READ);\n\tstatus = (sc->ie_bus_read16)(sc, IE_SCB_STATUS(sc->scb));\n\ti82596_start_cmd(sc, status & mask, 0, 0, 0);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [
            "int \ti82596_start_cmd"
          ],
          "called_functions": [],
          "contextual_snippet": "int \ti82596_start_cmd;\n\nstatic __inline__ void\nie_ack(struct ie_softc *sc, u_int mask) /* in native byte-order */\n{\n\tregister u_int status;\n\n\tbus_space_barrier(sc->bt, sc->bh, 0, 0, BUS_SPACE_BARRIER_READ);\n\tstatus = (sc->ie_bus_read16)(sc, IE_SCB_STATUS(sc->scb));\n\ti82596_start_cmd(sc, status & mask, 0, 0, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "IE_INTR_EXIT"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_read16",
          "args": [
            "sc",
            "off"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_barrier",
          "args": [
            "sc->bt",
            "sc->bh",
            "off",
            "2",
            "BUS_SPACE_BARRIER_READ"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_SCB_STATUS",
          "args": [
            "sc->scb"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "IE_INTR_ENTER"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ti82596_reset;\nint\ti82596_rint;\nint\ti82596_tint;\nint\ti82596_cmd_wait;\n\nint\ni82596_intr(v)\n\tvoid *v;\n{\n\tregister struct ie_softc *sc = v;\n\tregister u_int status;\n\tregister int off;\n\n        /*\n         * Implementation dependent interrupt handling.\n         */\n\tif (sc->intrhook)\n\t\t(sc->intrhook)(sc, IE_INTR_ENTER);\n\n\toff = IE_SCB_STATUS(sc->scb);\n\tbus_space_barrier(sc->bt, sc->bh, off, 2, BUS_SPACE_BARRIER_READ);\n\tstatus = sc->ie_bus_read16(sc, off) /* & IE_ST_WHENCE */;\n\n\tif ((status & IE_ST_WHENCE) == 0) {\n\t\tif (sc->intrhook)\n\t\t\t(sc->intrhook)(sc, IE_INTR_EXIT);\n\n\t\treturn (0);\n\t}\n\nloop:\n\t/* Ack interrupts FIRST in case we receive more during the ISR. */\n#if 0\n\tie_ack(sc, status & IE_ST_WHENCE);\n#endif\n\ti82596_start_cmd(sc, status & IE_ST_WHENCE, 0, 0, 1);\n\n\tif (status & (IE_ST_FR | IE_ST_RNR))\n\t\tif (i82596_rint(sc, status) != 0)\n\t\t\tgoto reset;\n\n\tif (status & IE_ST_CX)\n\t\tif (i82596_tint(sc, status) != 0)\n\t\t\tgoto reset;\n\n#ifdef I82596_DEBUG\n\tif ((status & IE_ST_CNA) && (sc->sc_debug & IED_CNA))\n\t\tprintf(\"%s: cna; status=%b\\n\", sc->sc_dev.dv_xname,\n\t\t\tstatus, IE_ST_BITS);\n#endif\n\tif (sc->intrhook)\n\t\t(sc->intrhook)(sc, IE_INTR_LOOP);\n\n\t/*\n\t * Interrupt ACK was posted asynchronously; wait for\n\t * completion here before reading SCB status again.\n\t */\n\ti82596_cmd_wait(sc);\n\n\tbus_space_barrier(sc->bt, sc->bh, off, 2, BUS_SPACE_BARRIER_READ);\n\tstatus = sc->ie_bus_read16(sc, off);\n\tif ((status & IE_ST_WHENCE) != 0)\n\t\tgoto loop;\n\nout:\n\tif (sc->intrhook)\n\t\t(sc->intrhook)(sc, IE_INTR_EXIT);\n\treturn (1);\n\nreset:\n\ti82596_cmd_wait(sc);\n\ti82596_reset(sc, 1);\n\tgoto out;\n\n}"
  },
  {
    "function_name": "i82596_rx_errors",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
    "lines": "491-496",
    "snippet": "static __inline void\ni82596_rx_errors(struct ie_softc *sc, int fn, int status)\n{\n\tlog(LOG_ERR, \"%s: rx error (frame# %d): %b\\n\", sc->sc_dev.dv_xname, fn,\n\t    status, IE_FD_STATUSBITS);\n}",
    "includes": [
      "#include <dev/ic/i82596var.h>",
      "#include <dev/ic/i82596reg.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_ERR",
            "\"%s: rx error (frame# %d): %b\\n\"",
            "sc->sc_dev.dv_xname",
            "fn",
            "status",
            "IE_FD_STATUSBITS"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1387-1401",
          "snippet": "int\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline void\ni82596_rx_errors(struct ie_softc *sc, int fn, int status)\n{\n\tlog(LOG_ERR, \"%s: rx error (frame# %d): %b\\n\", sc->sc_dev.dv_xname, fn,\n\t    status, IE_FD_STATUSBITS);\n}"
  },
  {
    "function_name": "i82596_count_errors",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
    "lines": "473-489",
    "snippet": "static __inline void\ni82596_count_errors(struct ie_softc *sc)\n{\n\tint scb = sc->scb;\n\n\tsc->sc_arpcom.ac_if.if_ierrors +=\n\t    sc->ie_bus_read16(sc, IE_SCB_ERRCRC(scb)) +\n\t    sc->ie_bus_read16(sc, IE_SCB_ERRALN(scb)) +\n\t    sc->ie_bus_read16(sc, IE_SCB_ERRRES(scb)) +\n\t    sc->ie_bus_read16(sc, IE_SCB_ERROVR(scb));\n\n\t/* Clear error counters */\n\tsc->ie_bus_write16(sc, IE_SCB_ERRCRC(scb), 0);\n\tsc->ie_bus_write16(sc, IE_SCB_ERRALN(scb), 0);\n\tsc->ie_bus_write16(sc, IE_SCB_ERRRES(scb), 0);\n\tsc->ie_bus_write16(sc, IE_SCB_ERROVR(scb), 0);\n}",
    "includes": [
      "#include <dev/ic/i82596var.h>",
      "#include <dev/ic/i82596reg.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sc->ie_bus_write16",
          "args": [
            "sc",
            "IE_SCB_ERROVR(scb)",
            "0"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_SCB_ERROVR",
          "args": [
            "scb"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_write16",
          "args": [
            "sc",
            "IE_SCB_ERRRES(scb)",
            "0"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_SCB_ERRRES",
          "args": [
            "scb"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_write16",
          "args": [
            "sc",
            "IE_SCB_ERRALN(scb)",
            "0"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_SCB_ERRALN",
          "args": [
            "scb"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_write16",
          "args": [
            "sc",
            "IE_SCB_ERRCRC(scb)",
            "0"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_SCB_ERRCRC",
          "args": [
            "scb"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_read16",
          "args": [
            "sc",
            "IE_SCB_ERROVR(scb)"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_SCB_ERROVR",
          "args": [
            "scb"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_read16",
          "args": [
            "sc",
            "IE_SCB_ERRRES(scb)"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_SCB_ERRRES",
          "args": [
            "scb"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_read16",
          "args": [
            "sc",
            "IE_SCB_ERRALN(scb)"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_SCB_ERRALN",
          "args": [
            "scb"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_read16",
          "args": [
            "sc",
            "IE_SCB_ERRCRC(scb)"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_SCB_ERRCRC",
          "args": [
            "scb"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline void\ni82596_count_errors(struct ie_softc *sc)\n{\n\tint scb = sc->scb;\n\n\tsc->sc_arpcom.ac_if.if_ierrors +=\n\t    sc->ie_bus_read16(sc, IE_SCB_ERRCRC(scb)) +\n\t    sc->ie_bus_read16(sc, IE_SCB_ERRALN(scb)) +\n\t    sc->ie_bus_read16(sc, IE_SCB_ERRRES(scb)) +\n\t    sc->ie_bus_read16(sc, IE_SCB_ERROVR(scb));\n\n\t/* Clear error counters */\n\tsc->ie_bus_write16(sc, IE_SCB_ERRCRC(scb), 0);\n\tsc->ie_bus_write16(sc, IE_SCB_ERRALN(scb), 0);\n\tsc->ie_bus_write16(sc, IE_SCB_ERRRES(scb), 0);\n\tsc->ie_bus_write16(sc, IE_SCB_ERROVR(scb), 0);\n}"
  },
  {
    "function_name": "i82596_start_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
    "lines": "398-468",
    "snippet": "int\ni82596_start_cmd(sc, cmd, iecmdbuf, mask, async)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tint iecmdbuf;\n\tint mask;\n\tint async;\n{\n\tregister int i, off;\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_CMDS)\n\t\tprintf(\"start_cmd: %p, %x, %x, %b, %ssync\\n\",\n\t\t       sc, cmd, iecmdbuf, mask, IE_STAT_BITS, async?\"a\":\"\");\n#endif\n\tif (sc->async_cmd_inprogress != 0) {\n\t\t/*\n\t\t * If previous command was issued asynchronously, wait\n\t\t * for it now.\n\t\t */\n\t\tif (i82596_cmd_wait(sc) != 0)\n\t\t\treturn (1);\n\t\tsc->async_cmd_inprogress = 0;\n\t}\n\n\toff = IE_SCB_CMD(sc->scb);\n\t(sc->ie_bus_write16)(sc, off, cmd);\n\tbus_space_barrier(sc->bt, sc->bh, off, 2, BUS_SPACE_BARRIER_WRITE);\n\t(sc->chan_attn)(sc);\n\n\tif (async) {\n\t\tsc->async_cmd_inprogress = 1;\n\t\treturn (0);\n\t}\n\n\tif (IE_ACTION_COMMAND(cmd) && iecmdbuf) {\n\t\tint status;\n\t\t/*\n\t\t * Now spin-lock waiting for status.  This is not a very nice\n\t\t * thing to do, and can kill performance pretty well...\n\t\t * According to the packet driver, the minimum timeout\n\t\t * should be .369 seconds.\n\t\t */\n\t\tfor (i = 0; i < 36900; i++) {\n\t\t\t/* Read the command status */\n\t\t\toff = IE_CMD_COMMON_STATUS(iecmdbuf);\n\t\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\t\tstatus = (sc->ie_bus_read16)(sc, off);\n\t\t\tif (status & mask) {\n#ifdef I82596_DEBUG\n\t\t\t\tif (sc->sc_debug & IED_CMDS)\n\t\t\t\t\tprintf (\"%s: cmd status %b\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\t\tstatus, IE_STAT_BITS);\n#endif\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tdelay(10);\n\t\t}\n\n\t} else {\n\t\t/*\n\t\t * Otherwise, just wait for the command to be accepted.\n\t\t */\n\t\treturn (i82596_cmd_wait(sc));\n\t}\n\n\t/* Timeout */\n\treturn (1);\n}",
    "includes": [
      "#include <dev/ic/i82596var.h>",
      "#include <dev/ic/i82596reg.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\ti82596_cmd_wait"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "i82596_cmd_wait",
          "args": [
            "sc"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "i82596_cmd_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "359-386",
          "snippet": "int\ni82596_cmd_wait(sc)\n\tstruct ie_softc *sc;\n{\n\t/* spin on i82596 command acknowledge; wait at most 0.9 (!) seconds */\n\tregister int i, off;\n\n\tfor (i = 0; i < 90000; i++) {\n\t\t/* Read the command word */\n\t\toff = IE_SCB_CMD(sc->scb);\n\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\tif ((sc->ie_bus_read16)(sc, off) == 0) {\n#ifdef I82596_DEBUG1\n\t\t\tif (sc->sc_debug & IED_CMDS)\n\t\t\t\tprintf (\"%s: cmd_wait after %d usec\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname, (90000 - i) * 10);\n#endif\n\t\t\treturn (0);\n\t\t}\n\t\tdelay(10);\n\t}\n\n\tprintf (\"i82596_cmd_wait: timo(%ssync): scb status: %b\\n\",\n\t\tsc->async_cmd_inprogress?\"a\":\"\",\n\t\tsc->ie_bus_read16(sc, off), IE_STAT_BITS);\n\treturn (1);\t/* Timeout */\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\ti82596_cmd_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ti82596_cmd_wait;\n\nint\ni82596_cmd_wait(sc)\n\tstruct ie_softc *sc;\n{\n\t/* spin on i82596 command acknowledge; wait at most 0.9 (!) seconds */\n\tregister int i, off;\n\n\tfor (i = 0; i < 90000; i++) {\n\t\t/* Read the command word */\n\t\toff = IE_SCB_CMD(sc->scb);\n\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\tif ((sc->ie_bus_read16)(sc, off) == 0) {\n#ifdef I82596_DEBUG1\n\t\t\tif (sc->sc_debug & IED_CMDS)\n\t\t\t\tprintf (\"%s: cmd_wait after %d usec\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname, (90000 - i) * 10);\n#endif\n\t\t\treturn (0);\n\t\t}\n\t\tdelay(10);\n\t}\n\n\tprintf (\"i82596_cmd_wait: timo(%ssync): scb status: %b\\n\",\n\t\tsc->async_cmd_inprogress?\"a\":\"\",\n\t\tsc->ie_bus_read16(sc, off), IE_STAT_BITS);\n\treturn (1);\t/* Timeout */\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "10"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: cmd status %b\\n\"",
            "sc->sc_dev.dv_xname",
            "status",
            "IE_STAT_BITS"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "off"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_barrier",
          "args": [
            "sc->bt",
            "sc->bh",
            "off",
            "2",
            "BUS_SPACE_BARRIER_READ"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_CMD_COMMON_STATUS",
          "args": [
            "iecmdbuf"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_ACTION_COMMAND",
          "args": [
            "cmd"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_barrier",
          "args": [
            "sc->bt",
            "sc->bh",
            "off",
            "2",
            "BUS_SPACE_BARRIER_WRITE"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "off",
            "cmd"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_SCB_CMD",
          "args": [
            "sc->scb"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ti82596_cmd_wait;\n\nint\ni82596_start_cmd(sc, cmd, iecmdbuf, mask, async)\n\tstruct ie_softc *sc;\n\tint cmd;\n\tint iecmdbuf;\n\tint mask;\n\tint async;\n{\n\tregister int i, off;\n\n#ifdef I82596_DEBUG\n\tif (sc->sc_debug & IED_CMDS)\n\t\tprintf(\"start_cmd: %p, %x, %x, %b, %ssync\\n\",\n\t\t       sc, cmd, iecmdbuf, mask, IE_STAT_BITS, async?\"a\":\"\");\n#endif\n\tif (sc->async_cmd_inprogress != 0) {\n\t\t/*\n\t\t * If previous command was issued asynchronously, wait\n\t\t * for it now.\n\t\t */\n\t\tif (i82596_cmd_wait(sc) != 0)\n\t\t\treturn (1);\n\t\tsc->async_cmd_inprogress = 0;\n\t}\n\n\toff = IE_SCB_CMD(sc->scb);\n\t(sc->ie_bus_write16)(sc, off, cmd);\n\tbus_space_barrier(sc->bt, sc->bh, off, 2, BUS_SPACE_BARRIER_WRITE);\n\t(sc->chan_attn)(sc);\n\n\tif (async) {\n\t\tsc->async_cmd_inprogress = 1;\n\t\treturn (0);\n\t}\n\n\tif (IE_ACTION_COMMAND(cmd) && iecmdbuf) {\n\t\tint status;\n\t\t/*\n\t\t * Now spin-lock waiting for status.  This is not a very nice\n\t\t * thing to do, and can kill performance pretty well...\n\t\t * According to the packet driver, the minimum timeout\n\t\t * should be .369 seconds.\n\t\t */\n\t\tfor (i = 0; i < 36900; i++) {\n\t\t\t/* Read the command status */\n\t\t\toff = IE_CMD_COMMON_STATUS(iecmdbuf);\n\t\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\t\tstatus = (sc->ie_bus_read16)(sc, off);\n\t\t\tif (status & mask) {\n#ifdef I82596_DEBUG\n\t\t\t\tif (sc->sc_debug & IED_CMDS)\n\t\t\t\t\tprintf (\"%s: cmd status %b\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname,\n\t\t\t\t\t\tstatus, IE_STAT_BITS);\n#endif\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tdelay(10);\n\t\t}\n\n\t} else {\n\t\t/*\n\t\t * Otherwise, just wait for the command to be accepted.\n\t\t */\n\t\treturn (i82596_cmd_wait(sc));\n\t}\n\n\t/* Timeout */\n\treturn (1);\n}"
  },
  {
    "function_name": "i82596_cmd_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
    "lines": "359-386",
    "snippet": "int\ni82596_cmd_wait(sc)\n\tstruct ie_softc *sc;\n{\n\t/* spin on i82596 command acknowledge; wait at most 0.9 (!) seconds */\n\tregister int i, off;\n\n\tfor (i = 0; i < 90000; i++) {\n\t\t/* Read the command word */\n\t\toff = IE_SCB_CMD(sc->scb);\n\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\tif ((sc->ie_bus_read16)(sc, off) == 0) {\n#ifdef I82596_DEBUG1\n\t\t\tif (sc->sc_debug & IED_CMDS)\n\t\t\t\tprintf (\"%s: cmd_wait after %d usec\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname, (90000 - i) * 10);\n#endif\n\t\t\treturn (0);\n\t\t}\n\t\tdelay(10);\n\t}\n\n\tprintf (\"i82596_cmd_wait: timo(%ssync): scb status: %b\\n\",\n\t\tsc->async_cmd_inprogress?\"a\":\"\",\n\t\tsc->ie_bus_read16(sc, off), IE_STAT_BITS);\n\treturn (1);\t/* Timeout */\n}",
    "includes": [
      "#include <dev/ic/i82596var.h>",
      "#include <dev/ic/i82596reg.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\ti82596_cmd_wait"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"i82596_cmd_wait: timo(%ssync): scb status: %b\\n\"",
            "sc->async_cmd_inprogress?\"a\":\"\"",
            "sc->ie_bus_read16(sc, off)",
            "IE_STAT_BITS"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc->ie_bus_read16",
          "args": [
            "sc",
            "off"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "10"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "off"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_barrier",
          "args": [
            "sc->bt",
            "sc->bh",
            "off",
            "2",
            "BUS_SPACE_BARRIER_READ"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_SCB_CMD",
          "args": [
            "sc->scb"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ti82596_cmd_wait;\n\nint\ni82596_cmd_wait(sc)\n\tstruct ie_softc *sc;\n{\n\t/* spin on i82596 command acknowledge; wait at most 0.9 (!) seconds */\n\tregister int i, off;\n\n\tfor (i = 0; i < 90000; i++) {\n\t\t/* Read the command word */\n\t\toff = IE_SCB_CMD(sc->scb);\n\t\tbus_space_barrier(sc->bt, sc->bh, off, 2,\n\t\t\t\t  BUS_SPACE_BARRIER_READ);\n\t\tif ((sc->ie_bus_read16)(sc, off) == 0) {\n#ifdef I82596_DEBUG1\n\t\t\tif (sc->sc_debug & IED_CMDS)\n\t\t\t\tprintf (\"%s: cmd_wait after %d usec\\n\",\n\t\t\t\t\tsc->sc_dev.dv_xname, (90000 - i) * 10);\n#endif\n\t\t\treturn (0);\n\t\t}\n\t\tdelay(10);\n\t}\n\n\tprintf (\"i82596_cmd_wait: timo(%ssync): scb status: %b\\n\",\n\t\tsc->async_cmd_inprogress?\"a\":\"\",\n\t\tsc->ie_bus_read16(sc, off), IE_STAT_BITS);\n\treturn (1);\t/* Timeout */\n}"
  },
  {
    "function_name": "i82596_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
    "lines": "347-357",
    "snippet": "void\ni82596_watchdog(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct ie_softc *sc = ifp->if_softc;\n\n\tlog(LOG_ERR, \"%s: device timeout\\n\", sc->sc_dev.dv_xname);\n\t++ifp->if_oerrors;\n\n\ti82596_reset(sc, 1);\n}",
    "includes": [
      "#include <dev/ic/i82596var.h>",
      "#include <dev/ic/i82596reg.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\ti82596_reset",
      "void\ti82596_watchdog"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "i82596_reset",
          "args": [
            "sc",
            "1"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "i82596_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
          "lines": "1333-1372",
          "snippet": "void\ni82596_reset(sc, hard)\n\tstruct ie_softc *sc;\n\tint hard;\n{\n\tint s = splnet();\n\n\tif (hard)\n\t\tprintf(\"%s: reset\\n\", sc->sc_dev.dv_xname);\n\n\t/* Clear OACTIVE in case we're called from watchdog (frozen xmit). */\n\tsc->sc_arpcom.ac_if.if_timer = 0;\n\tsc->sc_arpcom.ac_if.if_flags &= ~IFF_OACTIVE;\n\n\t/*\n\t * Stop i82596 dead in its tracks.\n\t */\n\tif (i82596_start_cmd(sc, IE_RUC_ABORT | IE_CUC_ABORT, 0, 0, 0))\n\t\tprintf(\"%s: abort commands timed out\\n\", sc->sc_dev.dv_xname);\n\n\t/*\n\t * This can really slow down the i82596_reset() on some cards, but it's\n\t * necessary to unwedge other ones (eg, the Sun VME ones) from certain\n\t * lockups.\n\t */\n\tif (hard && sc->hwreset)\n\t\t(sc->hwreset)(sc, IE_CARD_RESET);\n\n\tdelay(100);\n\tie_ack(sc, IE_ST_WHENCE);\n\n\tif ((sc->sc_arpcom.ac_if.if_flags & IFF_UP) != 0) {\n\t\tint retries=0;\t/* XXX - find out why init sometimes fails */\n\t\twhile (retries++ < 2)\n\t\t\tif (i82596_init(sc) == 1)\n\t\t\t\tbreak;\n\t}\n\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/i82596var.h>",
            "#include <dev/ic/i82596reg.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\ti82596_reset",
            "int\ti82596_init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ti82596_reset;\nint\ti82596_init;\n\nvoid\ni82596_reset(sc, hard)\n\tstruct ie_softc *sc;\n\tint hard;\n{\n\tint s = splnet();\n\n\tif (hard)\n\t\tprintf(\"%s: reset\\n\", sc->sc_dev.dv_xname);\n\n\t/* Clear OACTIVE in case we're called from watchdog (frozen xmit). */\n\tsc->sc_arpcom.ac_if.if_timer = 0;\n\tsc->sc_arpcom.ac_if.if_flags &= ~IFF_OACTIVE;\n\n\t/*\n\t * Stop i82596 dead in its tracks.\n\t */\n\tif (i82596_start_cmd(sc, IE_RUC_ABORT | IE_CUC_ABORT, 0, 0, 0))\n\t\tprintf(\"%s: abort commands timed out\\n\", sc->sc_dev.dv_xname);\n\n\t/*\n\t * This can really slow down the i82596_reset() on some cards, but it's\n\t * necessary to unwedge other ones (eg, the Sun VME ones) from certain\n\t * lockups.\n\t */\n\tif (hard && sc->hwreset)\n\t\t(sc->hwreset)(sc, IE_CARD_RESET);\n\n\tdelay(100);\n\tie_ack(sc, IE_ST_WHENCE);\n\n\tif ((sc->sc_arpcom.ac_if.if_flags & IFF_UP) != 0) {\n\t\tint retries=0;\t/* XXX - find out why init sometimes fails */\n\t\twhile (retries++ < 2)\n\t\t\tif (i82596_init(sc) == 1)\n\t\t\t\tbreak;\n\t}\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_ERR",
            "\"%s: device timeout\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1387-1401",
          "snippet": "int\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ti82596_reset;\nvoid\ti82596_watchdog;\n\nvoid\ni82596_watchdog(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct ie_softc *sc = ifp->if_softc;\n\n\tlog(LOG_ERR, \"%s: device timeout\\n\", sc->sc_dev.dv_xname);\n\t++ifp->if_oerrors;\n\n\ti82596_reset(sc, 1);\n}"
  },
  {
    "function_name": "i82596_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
    "lines": "288-339",
    "snippet": "void\ni82596_attach(sc, name, etheraddr, media, nmedia, defmedia)\n\tstruct ie_softc *sc;\n\tconst char *name;\n\tu_int8_t *etheraddr;\n        int *media, nmedia, defmedia;\n{\n\tint i;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\t/* Setup SCP+ISCP */\n\t(sc->ie_bus_write16)(sc, IE_ISCP_BUSY(sc->iscp), 1);\n\t(sc->ie_bus_write16)(sc, IE_ISCP_SCB(sc->iscp), sc->scb);\n\t(sc->ie_bus_write24)(sc, IE_ISCP_BASE(sc->iscp), sc->sc_maddr);\n\t(sc->ie_bus_write24)(sc, IE_SCP_ISCP(sc->scp), sc->sc_maddr +sc->iscp);\n\t(sc->ie_bus_write16)(sc, IE_SCP_BUS_USE(sc->scp), sc->sysbus);\n\t(sc->hwreset)(sc, IE_CARD_RESET);\n\n\t/* Setup Iface */\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_start = i82596_start;\n\tifp->if_ioctl = i82596_ioctl;\n\tifp->if_watchdog = i82596_watchdog;\n\tifp->if_flags =\n#ifdef I82596_DEBUG\n\t\tIFF_DEBUG |\n#endif\n\t\tIFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;\n\n        /* Initialize media goo. */\n        ifmedia_init(&sc->sc_media, 0, i82596_mediachange, i82596_mediastatus);\n        if (media != NULL) {\n                for (i = 0; i < nmedia; i++)\n                        ifmedia_add(&sc->sc_media, media[i], 0, NULL);\n                ifmedia_set(&sc->sc_media, defmedia);\n        } else {\n                ifmedia_add(&sc->sc_media, IFM_ETHER|IFM_MANUAL, 0, NULL);\n                ifmedia_set(&sc->sc_media, IFM_ETHER|IFM_MANUAL);\n        }\n\n\t/* Attach the interface. */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n\tprintf(\" %s v%d.%d, address %s\\n\", name, sc->sc_vers / 10,\n\t       sc->sc_vers % 10, ether_sprintf(etheraddr));\n\n#if NBPFILTER > 0\n\tbpfattach(&ifp->if_bpf, ifp, DLT_EN10MB, sizeof(struct ether_header));\n#endif\n}",
    "includes": [
      "#include <dev/ic/i82596var.h>",
      "#include <dev/ic/i82596reg.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\ti82596_watchdog",
      "int\ti82596_ioctl",
      "void\ti82596_start",
      "int   \ti82596_mediachange",
      "void  \ti82596_mediastatus"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpfattach",
          "args": [
            "&ifp->if_bpf",
            "ifp",
            "DLT_EN10MB",
            "sizeof(struct ether_header)"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" %s v%d.%d, address %s\\n\"",
            "name",
            "sc->sc_vers / 10",
            "sc->sc_vers % 10",
            "ether_sprintf(etheraddr)"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_sprintf",
          "args": [
            "etheraddr"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ifattach",
          "args": [
            "ifp"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_attach",
          "args": [
            "ifp"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_set",
          "args": [
            "&sc->sc_media",
            "IFM_ETHER|IFM_MANUAL"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->sc_media",
            "IFM_ETHER|IFM_MANUAL",
            "0",
            "NULL"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_set",
          "args": [
            "&sc->sc_media",
            "defmedia"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->sc_media",
            "media[i]",
            "0",
            "NULL"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_init",
          "args": [
            "&sc->sc_media",
            "0",
            "i82596_mediachange",
            "i82596_mediastatus"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "sc->sc_dev.dv_xname",
            "ifp->if_xname",
            "IFNAMSIZ"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "IE_CARD_RESET"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "IE_SCP_BUS_USE(sc->scp)",
            "sc->sysbus"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_SCP_BUS_USE",
          "args": [
            "sc->scp"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "IE_SCP_ISCP(sc->scp)",
            "sc->sc_maddr +sc->iscp"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_SCP_ISCP",
          "args": [
            "sc->scp"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "IE_ISCP_BASE(sc->iscp)",
            "sc->sc_maddr"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_ISCP_BASE",
          "args": [
            "sc->iscp"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "IE_ISCP_SCB(sc->iscp)",
            "sc->scb"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_ISCP_SCB",
          "args": [
            "sc->iscp"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "IE_ISCP_BUSY(sc->iscp)",
            "1"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_ISCP_BUSY",
          "args": [
            "sc->iscp"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ti82596_watchdog;\nint\ti82596_ioctl;\nvoid\ti82596_start;\nint   \ti82596_mediachange;\nvoid  \ti82596_mediastatus;\n\nvoid\ni82596_attach(sc, name, etheraddr, media, nmedia, defmedia)\n\tstruct ie_softc *sc;\n\tconst char *name;\n\tu_int8_t *etheraddr;\n        int *media, nmedia, defmedia;\n{\n\tint i;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\t/* Setup SCP+ISCP */\n\t(sc->ie_bus_write16)(sc, IE_ISCP_BUSY(sc->iscp), 1);\n\t(sc->ie_bus_write16)(sc, IE_ISCP_SCB(sc->iscp), sc->scb);\n\t(sc->ie_bus_write24)(sc, IE_ISCP_BASE(sc->iscp), sc->sc_maddr);\n\t(sc->ie_bus_write24)(sc, IE_SCP_ISCP(sc->scp), sc->sc_maddr +sc->iscp);\n\t(sc->ie_bus_write16)(sc, IE_SCP_BUS_USE(sc->scp), sc->sysbus);\n\t(sc->hwreset)(sc, IE_CARD_RESET);\n\n\t/* Setup Iface */\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_start = i82596_start;\n\tifp->if_ioctl = i82596_ioctl;\n\tifp->if_watchdog = i82596_watchdog;\n\tifp->if_flags =\n#ifdef I82596_DEBUG\n\t\tIFF_DEBUG |\n#endif\n\t\tIFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;\n\n        /* Initialize media goo. */\n        ifmedia_init(&sc->sc_media, 0, i82596_mediachange, i82596_mediastatus);\n        if (media != NULL) {\n                for (i = 0; i < nmedia; i++)\n                        ifmedia_add(&sc->sc_media, media[i], 0, NULL);\n                ifmedia_set(&sc->sc_media, defmedia);\n        } else {\n                ifmedia_add(&sc->sc_media, IFM_ETHER|IFM_MANUAL, 0, NULL);\n                ifmedia_set(&sc->sc_media, IFM_ETHER|IFM_MANUAL);\n        }\n\n\t/* Attach the interface. */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n\tprintf(\" %s v%d.%d, address %s\\n\", name, sc->sc_vers / 10,\n\t       sc->sc_vers % 10, ether_sprintf(etheraddr));\n\n#if NBPFILTER > 0\n\tbpfattach(&ifp->if_bpf, ifp, DLT_EN10MB, sizeof(struct ether_header));\n#endif\n}"
  },
  {
    "function_name": "i82596_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/i82596.c",
    "lines": "221-264",
    "snippet": "int\ni82596_probe(sc)\n\tstruct ie_softc *sc;\n{\n\tint i;\n\n\tsc->scp = sc->sc_msize - IE_SCP_SZ;\n\tsc->iscp = 0;\n\tsc->scb = 32;\n\n\t(sc->ie_bus_write16)(sc, IE_ISCP_BUSY(sc->iscp), 1);\n\t(sc->ie_bus_write16)(sc, IE_ISCP_SCB(sc->iscp), sc->scb);\n\t(sc->ie_bus_write24)(sc, IE_ISCP_BASE(sc->iscp), sc->sc_maddr);\n\t(sc->ie_bus_write24)(sc, IE_SCP_ISCP(sc->scp), sc->sc_maddr);\n\t(sc->ie_bus_write16)(sc, IE_SCP_BUS_USE(sc->scp), sc->sysbus);\n\n\t(sc->hwreset)(sc, IE_CARD_RESET);\n\t(sc->chan_attn)(sc);\n\tDELAY(1000);\n\n\tif ((sc->ie_bus_read16)(sc, IE_ISCP_BUSY(sc->iscp))) {\n#ifdef I82596_DEBUG\n\t\tprintf (\"%s: ISCP set failed\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\treturn 0;\n\t}\n\n\tif (sc->port) {\n\t\t(sc->ie_bus_write24)(sc, IE_SCP_TEST(sc->scp), -1);\n\t\t(sc->port)(sc, IE_PORT_TEST);\n\t\tfor (i = 9000; i-- &&\n\t\t\t     (sc->ie_bus_read16)(sc, IE_SCP_TEST(sc->scp));\n\t\t     DELAY(100));\n\n#ifdef I82596_DEBUG\n\t\tprintf (\"%s: test %x:%x\\n\", sc->sc_dev.dv_xname,\n\t\t\t*((volatile int32_t *)(sc->bh + sc->scp)),\n\t\t\t*(int32_t *)(sc->bh + IE_SCP_TEST(sc->scp)));\n\n#endif\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include <dev/ic/i82596var.h>",
      "#include <dev/ic/i82596reg.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: test %x:%x\\n\"",
            "sc->sc_dev.dv_xname",
            "*((volatile int32_t *)(sc->bh + sc->scp))",
            "*(int32_t *)(sc->bh + IE_SCP_TEST(sc->scp))"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IE_SCP_TEST",
          "args": [
            "sc->scp"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "100"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "IE_SCP_TEST(sc->scp)"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_SCP_TEST",
          "args": [
            "sc->scp"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "IE_PORT_TEST"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "IE_SCP_TEST(sc->scp)",
            "-1"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_SCP_TEST",
          "args": [
            "sc->scp"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "IE_ISCP_BUSY(sc->iscp)"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_ISCP_BUSY",
          "args": [
            "sc->iscp"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "IE_CARD_RESET"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "IE_SCP_BUS_USE(sc->scp)",
            "sc->sysbus"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_SCP_BUS_USE",
          "args": [
            "sc->scp"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "IE_SCP_ISCP(sc->scp)",
            "sc->sc_maddr"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_SCP_ISCP",
          "args": [
            "sc->scp"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "IE_ISCP_BASE(sc->iscp)",
            "sc->sc_maddr"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_ISCP_BASE",
          "args": [
            "sc->iscp"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "IE_ISCP_SCB(sc->iscp)",
            "sc->scb"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_ISCP_SCB",
          "args": [
            "sc->iscp"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "IE_ISCP_BUSY(sc->iscp)",
            "1"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IE_ISCP_BUSY",
          "args": [
            "sc->iscp"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82596var.h>\n#include <dev/ic/i82596reg.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ni82596_probe(sc)\n\tstruct ie_softc *sc;\n{\n\tint i;\n\n\tsc->scp = sc->sc_msize - IE_SCP_SZ;\n\tsc->iscp = 0;\n\tsc->scb = 32;\n\n\t(sc->ie_bus_write16)(sc, IE_ISCP_BUSY(sc->iscp), 1);\n\t(sc->ie_bus_write16)(sc, IE_ISCP_SCB(sc->iscp), sc->scb);\n\t(sc->ie_bus_write24)(sc, IE_ISCP_BASE(sc->iscp), sc->sc_maddr);\n\t(sc->ie_bus_write24)(sc, IE_SCP_ISCP(sc->scp), sc->sc_maddr);\n\t(sc->ie_bus_write16)(sc, IE_SCP_BUS_USE(sc->scp), sc->sysbus);\n\n\t(sc->hwreset)(sc, IE_CARD_RESET);\n\t(sc->chan_attn)(sc);\n\tDELAY(1000);\n\n\tif ((sc->ie_bus_read16)(sc, IE_ISCP_BUSY(sc->iscp))) {\n#ifdef I82596_DEBUG\n\t\tprintf (\"%s: ISCP set failed\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\treturn 0;\n\t}\n\n\tif (sc->port) {\n\t\t(sc->ie_bus_write24)(sc, IE_SCP_TEST(sc->scp), -1);\n\t\t(sc->port)(sc, IE_PORT_TEST);\n\t\tfor (i = 9000; i-- &&\n\t\t\t     (sc->ie_bus_read16)(sc, IE_SCP_TEST(sc->scp));\n\t\t     DELAY(100));\n\n#ifdef I82596_DEBUG\n\t\tprintf (\"%s: test %x:%x\\n\", sc->sc_dev.dv_xname,\n\t\t\t*((volatile int32_t *)(sc->bh + sc->scp)),\n\t\t\t*(int32_t *)(sc->bh + IE_SCP_TEST(sc->scp)));\n\n#endif\n\t}\n\n\treturn 1;\n}"
  }
]