[
  {
    "function_name": "cnw_activate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_cnw.c",
    "lines": "870-899",
    "snippet": "int\ncnw_activate(dev, act)\n\tstruct device *dev;\n\tenum devact act;\n{\n\tstruct cnw_softc *sc = (struct cnw_softc *)dev;\n        struct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint s;\n\n\ts = splnet();\n\tswitch (act) {\n\tcase DVACT_ACTIVATE:\n\t\tpcmcia_function_enable(sc->sc_pf);\n\t\tprintf(\"%s:\", sc->sc_dev.dv_xname);\n\t\tsc->sc_ih =\n\t\t    pcmcia_intr_establish(sc->sc_pf, IPL_NET, cnw_intr, sc);\n\t\tprintf(\"\\n\");\n\t\tcnw_init(sc);\n\t\tbreak;\n\n\tcase DVACT_DEACTIVATE:\n\t\tifp->if_timer = 0;\n\t\tifp->if_flags &= ~IFF_RUNNING; /* XXX no cnw_stop() ? */\n\t\tpcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);\n\t\tpcmcia_function_disable(sc->sc_pf);\n\t\tbreak;\n\t}\n\tsplx(s);\n\treturn (0);\n}",
    "includes": [
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/pcmcia/if_cnwreg.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tcnw_activate",
      "void cnw_init",
      "int cnw_intr",
      "struct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_function_disable",
          "args": [
            "sc->sc_pf"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_function_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "570-622",
          "snippet": "void\npcmcia_function_disable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\tif ((pf->pf_flags & PFF_ENABLED) == 0) {\n\t\t/*\n\t\t * Don't do anything if we're already disabled.\n\t\t */\n\t\treturn;\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE) {\n\t\tpf->pf_flags &= ~PFF_ENABLED;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * it's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.  Note we mark us as disabled\n\t * first to avoid matching ourself.\n\t */\n\tpf->pf_flags &= ~PFF_ENABLED;\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t(tmp->ccr_base - tmp->pf_ccr_offset + tmp->pf_ccr_realsize)))\n\t\t\tbreak;\n\t}\n\n\t/* Not used by anyone else; unmap the CCR. */\n\tif (tmp == NULL) {\n\t\tpcmcia_mem_unmap(pf, pf->pf_ccr_window);\n\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t}\n\n done:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nvoid\npcmcia_function_disable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\tif ((pf->pf_flags & PFF_ENABLED) == 0) {\n\t\t/*\n\t\t * Don't do anything if we're already disabled.\n\t\t */\n\t\treturn;\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE) {\n\t\tpf->pf_flags &= ~PFF_ENABLED;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * it's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.  Note we mark us as disabled\n\t * first to avoid matching ourself.\n\t */\n\tpf->pf_flags &= ~PFF_ENABLED;\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t(tmp->ccr_base - tmp->pf_ccr_offset + tmp->pf_ccr_realsize)))\n\t\t\tbreak;\n\t}\n\n\t/* Not used by anyone else; unmap the CCR. */\n\tif (tmp == NULL) {\n\t\tpcmcia_mem_unmap(pf, pf->pf_ccr_window);\n\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t}\n\n done:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_intr_disestablish",
          "args": [
            "sc->sc_pf",
            "sc->sc_ih"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_intr_disestablish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "784-866",
          "snippet": "void\npcmcia_intr_disestablish(pf, ih)\n\tstruct pcmcia_function *pf;\n\tvoid *ih;\n{\n\tint s, reg, ihcnt, hiipl;\n\tstruct pcmcia_function *pf2;\n\n\t/* Behave differently if this is a multifunction card.  */\n\tif (pcmcia_mfc(pf->sc)) {\n\t\t/*\n\t\t * Mask all the ipl's which are already used by this card,\n\t\t * and find the highest ipl number (lowest priority).  Skip\n\t\t * the current function.\n\t\t */\n\t\tihcnt = 0;\n\t\tfor (pf2 = pf->sc->card.pf_head.sqh_first; pf2 != NULL;\n\t\t    pf2 = pf2->pf_list.sqe_next) {\n\t\t\tif (pf2 == pf)\n\t\t\t\tcontinue;\n\n\t\t\tif (pf2->ih_fct) {\n\t\t\t\tif (ihcnt == 0)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\telse if (pf2->ih_ipl > hiipl)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\tihcnt++;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the ih being removed is lower priority than the lowest\n\t\t * priority remaining interrupt, up the priority.\n\t\t */\n\n\t\t/*\n\t\t * ihcnt is the number of interrupt handlers *not* including\n\t\t * the one about to be removed.\n\t\t */\n\t\tif (ihcnt == 0) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"disestablishing last function, but card has no ih\");\n#endif\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\n\t\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);\n\t\t\treg &= ~PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\t\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tpf->sc->ih = NULL;\n\t\t} else if (pf->ih_ipl > hiipl) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"changing ih ipl, but card has no ih\");\n#endif\n\t\t\ts = spltty();\n\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\t\t\tpf->sc->ih = pcmcia_chip_intr_establish(pf->sc->pct,\n\t\t\t    pf->sc->pch, pf, hiipl, pcmcia_card_intr, pf->sc);\n\n\t\t\t/* Null out the handler for this function. */\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t} else {\n\t\t\ts = spltty();\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t}\n\t} else\n\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch, ih);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int pcmcia_card_intr",
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;",
            "int ipl;",
            "int (*ih_fct)",
            "void *ih_arg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint pcmcia_card_intr;\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\nint ipl;\nint (*ih_fct);\nvoid *ih_arg;\n\nvoid\npcmcia_intr_disestablish(pf, ih)\n\tstruct pcmcia_function *pf;\n\tvoid *ih;\n{\n\tint s, reg, ihcnt, hiipl;\n\tstruct pcmcia_function *pf2;\n\n\t/* Behave differently if this is a multifunction card.  */\n\tif (pcmcia_mfc(pf->sc)) {\n\t\t/*\n\t\t * Mask all the ipl's which are already used by this card,\n\t\t * and find the highest ipl number (lowest priority).  Skip\n\t\t * the current function.\n\t\t */\n\t\tihcnt = 0;\n\t\tfor (pf2 = pf->sc->card.pf_head.sqh_first; pf2 != NULL;\n\t\t    pf2 = pf2->pf_list.sqe_next) {\n\t\t\tif (pf2 == pf)\n\t\t\t\tcontinue;\n\n\t\t\tif (pf2->ih_fct) {\n\t\t\t\tif (ihcnt == 0)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\telse if (pf2->ih_ipl > hiipl)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\tihcnt++;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the ih being removed is lower priority than the lowest\n\t\t * priority remaining interrupt, up the priority.\n\t\t */\n\n\t\t/*\n\t\t * ihcnt is the number of interrupt handlers *not* including\n\t\t * the one about to be removed.\n\t\t */\n\t\tif (ihcnt == 0) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"disestablishing last function, but card has no ih\");\n#endif\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\n\t\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);\n\t\t\treg &= ~PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\t\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tpf->sc->ih = NULL;\n\t\t} else if (pf->ih_ipl > hiipl) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"changing ih ipl, but card has no ih\");\n#endif\n\t\t\ts = spltty();\n\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\t\t\tpf->sc->ih = pcmcia_chip_intr_establish(pf->sc->pct,\n\t\t\t    pf->sc->pch, pf, hiipl, pcmcia_card_intr, pf->sc);\n\n\t\t\t/* Null out the handler for this function. */\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t} else {\n\t\t\ts = spltty();\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t}\n\t} else\n\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch, ih);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cnw_init",
          "args": [
            "sc"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "cnw_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_cnw.c",
          "lines": "273-307",
          "snippet": "void\ncnw_init(sc)\n\tstruct cnw_softc *sc;\n{\n\t/* Reset the card */\n\tcnw_reset(sc);\n\n\t/* Issue a NOP to check the card */\n\tCNW_CMD0(sc, CNW_CMD_NOP);\n\n\t/* Set up receive configuration */\n\tCNW_CMD1(sc, CNW_CMD_SRC, CNW_RXCONF_RXENA | CNW_RXCONF_BCAST);\n\n\t/* Set up transmit configuration */\n\tCNW_CMD1(sc, CNW_CMD_STC, CNW_TXCONF_TXENA);\n\n\t/* Set domain */\n\tCNW_CMD2(sc, CNW_CMD_SMD, sc->sc_domain, sc->sc_domain >> 8);\n\n\t/* Set scramble key */\n\tCNW_CMD2(sc, CNW_CMD_SSK, sc->sc_skey, sc->sc_skey >> 8);\n\n\t/* Enable interrupts */\n\tWAIT_WOC(sc);\n\tbus_space_write_1(sc->sc_iot, sc->sc_ioh,\n\t\t\t  CNW_REG_IMR, CNW_IMR_IENA | CNW_IMR_RFU1);\n\n\t/* Enable receiver */\n\tCNW_CMD0(sc, CNW_CMD_ER);\n\n\t/* \"Set the IENA bit in COR\" */\n\tWAIT_WOC(sc);\n\tbus_space_write_1(sc->sc_iot, sc->sc_ioh, CNW_REG_COR,\n\t\t\t  CNW_COR_IENA | CNW_COR_LVLREQ);\n}",
          "includes": [
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/pcmcia/if_cnwreg.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/socket.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void cnw_reset",
            "void cnw_init",
            "struct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/if_cnwreg.h>\n#include <sys/ioctl.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid cnw_reset;\nvoid cnw_init;\nstruct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;\n\nvoid\ncnw_init(sc)\n\tstruct cnw_softc *sc;\n{\n\t/* Reset the card */\n\tcnw_reset(sc);\n\n\t/* Issue a NOP to check the card */\n\tCNW_CMD0(sc, CNW_CMD_NOP);\n\n\t/* Set up receive configuration */\n\tCNW_CMD1(sc, CNW_CMD_SRC, CNW_RXCONF_RXENA | CNW_RXCONF_BCAST);\n\n\t/* Set up transmit configuration */\n\tCNW_CMD1(sc, CNW_CMD_STC, CNW_TXCONF_TXENA);\n\n\t/* Set domain */\n\tCNW_CMD2(sc, CNW_CMD_SMD, sc->sc_domain, sc->sc_domain >> 8);\n\n\t/* Set scramble key */\n\tCNW_CMD2(sc, CNW_CMD_SSK, sc->sc_skey, sc->sc_skey >> 8);\n\n\t/* Enable interrupts */\n\tWAIT_WOC(sc);\n\tbus_space_write_1(sc->sc_iot, sc->sc_ioh,\n\t\t\t  CNW_REG_IMR, CNW_IMR_IENA | CNW_IMR_RFU1);\n\n\t/* Enable receiver */\n\tCNW_CMD0(sc, CNW_CMD_ER);\n\n\t/* \"Set the IENA bit in COR\" */\n\tWAIT_WOC(sc);\n\tbus_space_write_1(sc->sc_iot, sc->sc_ioh, CNW_REG_COR,\n\t\t\t  CNW_COR_IENA | CNW_COR_LVLREQ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_intr_establish",
          "args": [
            "sc->sc_pf",
            "IPL_NET",
            "cnw_intr",
            "sc"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_function_enable",
          "args": [
            "sc->sc_pf"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_function_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "419-567",
          "snippet": "int\npcmcia_function_enable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\tint reg;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\t/*\n\t * Increase the reference count on the socket, enabling power, if\n\t * necessary.\n\t */\n\tif (pf->sc->sc_enabled_count++ == 0)\n\t\tpcmcia_chip_socket_enable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: ++enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\tif (pf->pf_flags & PFF_ENABLED) {\n\t\t/*\n\t\t * Don't do anything if we're already enabled.\n\t\t */\n\t\tDPRINTF((\"%s: pcmcia_function_enable on enabled func\\n\"));\n\t\treturn (0);\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE)\n\t\tgoto done;\n\n\t/*\n\t * It's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.\n\t */\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t     (tmp->ccr_base - tmp->pf_ccr_offset +\n\t\t      tmp->pf_ccr_realsize))) {\n\t\t\tpf->pf_ccrt = tmp->pf_ccrt;\n\t\t\tpf->pf_ccrh = tmp->pf_ccrh;\n\t\t\tpf->pf_ccr_realsize = tmp->pf_ccr_realsize;\n\n\t\t\t/*\n\t\t\t * pf->pf_ccr_offset = (tmp->pf_ccr_offset -\n\t\t\t * tmp->ccr_base) + pf->ccr_base;\n\t\t\t */\n\t\t\tpf->pf_ccr_offset =\n\t\t\t    (tmp->pf_ccr_offset + pf->ccr_base) -\n\t\t\t    tmp->ccr_base;\n\t\t\tpf->pf_ccr_window = tmp->pf_ccr_window;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (tmp == NULL) {\n\t\tif (pcmcia_mem_alloc(pf, PCMCIA_CCR_SIZE, &pf->pf_pcmh))\n\t\t\tgoto bad;\n\n\t\tif (pcmcia_mem_map(pf, PCMCIA_MEM_ATTR, pf->ccr_base,\n\t\t    PCMCIA_CCR_SIZE, &pf->pf_pcmh, &pf->pf_ccr_offset,\n\t\t    &pf->pf_ccr_window)) {\n\t\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\treg = (pf->cfe->number & PCMCIA_CCR_OPTION_CFINDEX);\n\treg |= PCMCIA_CCR_OPTION_LEVIREQ;\n\tif (pcmcia_mfc(pf->sc)) {\n\t\treg |= (PCMCIA_CCR_OPTION_FUNC_ENABLE |\n\t\t\tPCMCIA_CCR_OPTION_ADDR_DECODE);\n\t\tif (pf->ih_fct)\n\t\t\treg |= PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\n\t}\n\t\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\treg = 0;\n\n\tif ((pf->cfe->flags & PCMCIA_CFE_IO16) == 0)\n\t\treg |= PCMCIA_CCR_STATUS_IOIS8;\n\tif (pf->cfe->flags & PCMCIA_CFE_AUDIO)\n\t\treg |= PCMCIA_CCR_STATUS_AUDIO;\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_STATUS, reg);\n\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_SOCKETCOPY, 0);\n\t\n\tif (pcmcia_mfc(pf->sc)) {\n\t\tlong tmp, iosize;\n\n\t\ttmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;\n\t\t/* round up to nearest (2^n)-1 */\n\t\tfor (iosize = 1; iosize < tmp; iosize <<= 1)\n\t\t\t;\n\t\tiosize--;\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,\n\t\t\t\t pf->pf_mfc_iobase & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,\n\t\t\t\t (pf->pf_mfc_iobase >> 8) & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);\n\t}\n\n#ifdef PCMCIADEBUG\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t     tmp = tmp->pf_list.sqe_next) {\n\t\tprintf(\"%s: function %d CCR at %d offset %lx: \"\n\t\t       \"%x %x %x %x, %x %x %x %x, %x\\n\",\n\t\t       tmp->sc->dev.dv_xname, tmp->number,\n\t\t       tmp->pf_ccr_window, tmp->pf_ccr_offset,\n\t\t       pcmcia_ccr_read(tmp, 0x00),\n\t\t       pcmcia_ccr_read(tmp, 0x02),\n\t\t       pcmcia_ccr_read(tmp, 0x04),\n\t\t       pcmcia_ccr_read(tmp, 0x06),\n\n\t\t       pcmcia_ccr_read(tmp, 0x0A),\n\t\t       pcmcia_ccr_read(tmp, 0x0C), \n\t\t       pcmcia_ccr_read(tmp, 0x0E),\n\t\t       pcmcia_ccr_read(tmp, 0x10),\n\n\t\t       pcmcia_ccr_read(tmp, 0x12));\n\t}\n#endif\n\n done:\n\tpf->pf_flags |= PFF_ENABLED;\n\tdelay(1000);\n\treturn (0);\n\n bad:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\treturn (1);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;",
            "int (*ih_fct)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\nint (*ih_fct);\n\nint\npcmcia_function_enable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\tint reg;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\t/*\n\t * Increase the reference count on the socket, enabling power, if\n\t * necessary.\n\t */\n\tif (pf->sc->sc_enabled_count++ == 0)\n\t\tpcmcia_chip_socket_enable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: ++enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\tif (pf->pf_flags & PFF_ENABLED) {\n\t\t/*\n\t\t * Don't do anything if we're already enabled.\n\t\t */\n\t\tDPRINTF((\"%s: pcmcia_function_enable on enabled func\\n\"));\n\t\treturn (0);\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE)\n\t\tgoto done;\n\n\t/*\n\t * It's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.\n\t */\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t     (tmp->ccr_base - tmp->pf_ccr_offset +\n\t\t      tmp->pf_ccr_realsize))) {\n\t\t\tpf->pf_ccrt = tmp->pf_ccrt;\n\t\t\tpf->pf_ccrh = tmp->pf_ccrh;\n\t\t\tpf->pf_ccr_realsize = tmp->pf_ccr_realsize;\n\n\t\t\t/*\n\t\t\t * pf->pf_ccr_offset = (tmp->pf_ccr_offset -\n\t\t\t * tmp->ccr_base) + pf->ccr_base;\n\t\t\t */\n\t\t\tpf->pf_ccr_offset =\n\t\t\t    (tmp->pf_ccr_offset + pf->ccr_base) -\n\t\t\t    tmp->ccr_base;\n\t\t\tpf->pf_ccr_window = tmp->pf_ccr_window;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (tmp == NULL) {\n\t\tif (pcmcia_mem_alloc(pf, PCMCIA_CCR_SIZE, &pf->pf_pcmh))\n\t\t\tgoto bad;\n\n\t\tif (pcmcia_mem_map(pf, PCMCIA_MEM_ATTR, pf->ccr_base,\n\t\t    PCMCIA_CCR_SIZE, &pf->pf_pcmh, &pf->pf_ccr_offset,\n\t\t    &pf->pf_ccr_window)) {\n\t\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\treg = (pf->cfe->number & PCMCIA_CCR_OPTION_CFINDEX);\n\treg |= PCMCIA_CCR_OPTION_LEVIREQ;\n\tif (pcmcia_mfc(pf->sc)) {\n\t\treg |= (PCMCIA_CCR_OPTION_FUNC_ENABLE |\n\t\t\tPCMCIA_CCR_OPTION_ADDR_DECODE);\n\t\tif (pf->ih_fct)\n\t\t\treg |= PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\n\t}\n\t\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\treg = 0;\n\n\tif ((pf->cfe->flags & PCMCIA_CFE_IO16) == 0)\n\t\treg |= PCMCIA_CCR_STATUS_IOIS8;\n\tif (pf->cfe->flags & PCMCIA_CFE_AUDIO)\n\t\treg |= PCMCIA_CCR_STATUS_AUDIO;\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_STATUS, reg);\n\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_SOCKETCOPY, 0);\n\t\n\tif (pcmcia_mfc(pf->sc)) {\n\t\tlong tmp, iosize;\n\n\t\ttmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;\n\t\t/* round up to nearest (2^n)-1 */\n\t\tfor (iosize = 1; iosize < tmp; iosize <<= 1)\n\t\t\t;\n\t\tiosize--;\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,\n\t\t\t\t pf->pf_mfc_iobase & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,\n\t\t\t\t (pf->pf_mfc_iobase >> 8) & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);\n\t}\n\n#ifdef PCMCIADEBUG\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t     tmp = tmp->pf_list.sqe_next) {\n\t\tprintf(\"%s: function %d CCR at %d offset %lx: \"\n\t\t       \"%x %x %x %x, %x %x %x %x, %x\\n\",\n\t\t       tmp->sc->dev.dv_xname, tmp->number,\n\t\t       tmp->pf_ccr_window, tmp->pf_ccr_offset,\n\t\t       pcmcia_ccr_read(tmp, 0x00),\n\t\t       pcmcia_ccr_read(tmp, 0x02),\n\t\t       pcmcia_ccr_read(tmp, 0x04),\n\t\t       pcmcia_ccr_read(tmp, 0x06),\n\n\t\t       pcmcia_ccr_read(tmp, 0x0A),\n\t\t       pcmcia_ccr_read(tmp, 0x0C), \n\t\t       pcmcia_ccr_read(tmp, 0x0E),\n\t\t       pcmcia_ccr_read(tmp, 0x10),\n\n\t\t       pcmcia_ccr_read(tmp, 0x12));\n\t}\n#endif\n\n done:\n\tpf->pf_flags |= PFF_ENABLED;\n\tdelay(1000);\n\treturn (0);\n\n bad:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/if_cnwreg.h>\n#include <sys/ioctl.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\tcnw_activate;\nvoid cnw_init;\nint cnw_intr;\nstruct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;\n\nint\ncnw_activate(dev, act)\n\tstruct device *dev;\n\tenum devact act;\n{\n\tstruct cnw_softc *sc = (struct cnw_softc *)dev;\n        struct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint s;\n\n\ts = splnet();\n\tswitch (act) {\n\tcase DVACT_ACTIVATE:\n\t\tpcmcia_function_enable(sc->sc_pf);\n\t\tprintf(\"%s:\", sc->sc_dev.dv_xname);\n\t\tsc->sc_ih =\n\t\t    pcmcia_intr_establish(sc->sc_pf, IPL_NET, cnw_intr, sc);\n\t\tprintf(\"\\n\");\n\t\tcnw_init(sc);\n\t\tbreak;\n\n\tcase DVACT_DEACTIVATE:\n\t\tifp->if_timer = 0;\n\t\tifp->if_flags &= ~IFF_RUNNING; /* XXX no cnw_stop() ? */\n\t\tpcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);\n\t\tpcmcia_function_disable(sc->sc_pf);\n\t\tbreak;\n\t}\n\tsplx(s);\n\treturn (0);\n}"
  },
  {
    "function_name": "cnw_detach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_cnw.c",
    "lines": "850-868",
    "snippet": "int\ncnw_detach(dev, flags)\n\tstruct device *dev;\n\tint flags;\n{\n\tstruct cnw_softc *sc = (struct cnw_softc *)dev;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint rv = 0;\n\n\tpcmcia_io_unmap(sc->sc_pf, sc->sc_iowin);\n\tpcmcia_io_free(sc->sc_pf, &sc->sc_pcioh);\n\tpcmcia_mem_unmap(sc->sc_pf, sc->sc_memwin);\n\tpcmcia_mem_free(sc->sc_pf, &sc->sc_pcmemh);\n\n\tether_ifdetach(ifp);\n\tif_detach(ifp);\n\n\treturn (rv);\n}",
    "includes": [
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/pcmcia/if_cnwreg.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tcnw_detach",
      "struct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "if_detach",
          "args": [
            "ifp"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ifdetach",
          "args": [
            "ifp"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_mem_free",
          "args": [
            "sc->sc_pf",
            "&sc->sc_pcmemh"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_mem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "2382-2395",
          "snippet": "STATIC void\npccbb_pcmcia_mem_free(pch, pcmhp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_mem_handle *pcmhp;\n{\n#if rbus\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ph->ph_parent;\n\n\trbus_space_free(sc->sc_rbus_memt, pcmhp->memh, pcmhp->realsize, NULL);\n#else\n\tbus_space_free(pcmhp->memt, pcmhp->memh, pcmhp->realsize);\n#endif\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define STATIC static",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "cb_reset __P((struct pccbb_softc *));",
            "STATIC int",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "pccbb_pcmcia_mem_alloc __P((pcmcia_chipset_handle_t, bus_size_t,\n    struct pcmcia_mem_handle *));",
            "STATIC void",
            "pccbb_pcmcia_mem_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_mem_handle *));",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC void",
            "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
            "STATIC void",
            "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
            "STATIC void",
            "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
            "STATIC int",
            "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "struct pcic_handle *ph = poll->ph;",
            "struct pccbb_softc *sc = ph->sc;",
            "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\ncb_reset __P((struct pccbb_softc *));\nSTATIC int;\ncb_detect_voltage __P((struct pccbb_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\npccbb_pcmcia_mem_alloc __P((pcmcia_chipset_handle_t, bus_size_t,\n    struct pcmcia_mem_handle *));\nSTATIC void;\npccbb_pcmcia_mem_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_mem_handle *));\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pcic_handle *ph = poll->ph;\nstruct pccbb_softc *sc = ph->sc;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC void\npccbb_pcmcia_mem_free(pch, pcmhp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_mem_handle *pcmhp;\n{\n#if rbus\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ph->ph_parent;\n\n\trbus_space_free(sc->sc_rbus_memt, pcmhp->memh, pcmhp->realsize, NULL);\n#else\n\tbus_space_free(pcmhp->memt, pcmhp->memh, pcmhp->realsize);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_mem_unmap",
          "args": [
            "sc->sc_pf",
            "sc->sc_memwin"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_mem_unmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "2584-2601",
          "snippet": "STATIC void\npccbb_pcmcia_mem_unmap(pch, window)\n\tpcmcia_chipset_handle_t pch;\n\tint window;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tint reg;\n\n\tif (window >= PCIC_MEM_WINS) {\n\t\tpanic(\"pccbb_pcmcia_mem_unmap: window out of range\");\n\t}\n\n\treg = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);\n\treg &= ~(1 << window);\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, reg);\n\n\tph->memalloc &= ~(1 << window);\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define STATIC static",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC void",
            "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
            "STATIC void",
            "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
            "STATIC void",
            "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
            "STATIC int",
            "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
            "struct pcic_handle *ph = poll->ph;",
            "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pcic_handle *ph = poll->ph;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC void\npccbb_pcmcia_mem_unmap(pch, window)\n\tpcmcia_chipset_handle_t pch;\n\tint window;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tint reg;\n\n\tif (window >= PCIC_MEM_WINS) {\n\t\tpanic(\"pccbb_pcmcia_mem_unmap: window out of range\");\n\t}\n\n\treg = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);\n\treg &= ~(1 << window);\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, reg);\n\n\tph->memalloc &= ~(1 << window);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_io_free",
          "args": [
            "sc->sc_pf",
            "&sc->sc_pcioh"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_io_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "1873-1896",
          "snippet": "void\npccbb_pcmcia_io_free(pch, pcihp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_io_handle *pcihp;\n{\n#if !rbus\n\tbus_space_tag_t iot = pcihp->iot;\n#endif\n\tbus_space_handle_t ioh = pcihp->ioh;\n\tbus_size_t size = pcihp->size;\n\n#if rbus\n\tstruct pccbb_softc *sc =\n\t    (struct pccbb_softc *)((struct pcic_handle *)pch)->ph_parent;\n\trbus_tag_t rb = sc->sc_rbus_iot;\n\n\trbus_space_free(rb, ioh, size, NULL);\n#else\n\tif (pcihp->flags & PCMCIA_IO_ALLOCATED)\n\t\tbus_space_free(iot, ioh, size);\n\telse\n\t\tbus_space_unmap(iot, ioh, size);\n#endif\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "cb_reset __P((struct pccbb_softc *));",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
            "pccbb_pcmcia_io_alloc __P((pcmcia_chipset_handle_t, bus_addr_t,\n    bus_size_t, bus_size_t, struct pcmcia_io_handle *));",
            "pccbb_pcmcia_io_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_io_handle *));",
            "pccbb_pcmcia_io_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_io_handle *, int *));",
            "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
            "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
            "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
            "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
            "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "struct pccbb_softc *sc = ph->sc;",
            "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\ncb_reset __P((struct pccbb_softc *));\ncb_detect_voltage __P((struct pccbb_softc *));\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\npccbb_pcmcia_io_alloc __P((pcmcia_chipset_handle_t, bus_addr_t,\n    bus_size_t, bus_size_t, struct pcmcia_io_handle *));\npccbb_pcmcia_io_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_io_handle *));\npccbb_pcmcia_io_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_io_handle *, int *));\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pccbb_softc *sc = ph->sc;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nvoid\npccbb_pcmcia_io_free(pch, pcihp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_io_handle *pcihp;\n{\n#if !rbus\n\tbus_space_tag_t iot = pcihp->iot;\n#endif\n\tbus_space_handle_t ioh = pcihp->ioh;\n\tbus_size_t size = pcihp->size;\n\n#if rbus\n\tstruct pccbb_softc *sc =\n\t    (struct pccbb_softc *)((struct pcic_handle *)pch)->ph_parent;\n\trbus_tag_t rb = sc->sc_rbus_iot;\n\n\trbus_space_free(rb, ioh, size, NULL);\n#else\n\tif (pcihp->flags & PCMCIA_IO_ALLOCATED)\n\t\tbus_space_free(iot, ioh, size);\n\telse\n\t\tbus_space_unmap(iot, ioh, size);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_io_unmap",
          "args": [
            "sc->sc_pf",
            "sc->sc_iowin"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_io_unmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "2057-2081",
          "snippet": "STATIC void\npccbb_pcmcia_io_unmap(pch, win)\n\tpcmcia_chipset_handle_t pch;\n\tint win;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tint reg;\n\n\tif (win >= PCIC_IO_WINS || win < 0) {\n\t\tpanic(\"pccbb_pcmcia_io_unmap: window out of range\");\n\t}\n\n\treg = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);\n\tswitch (win) {\n\tcase 0:\n\t\treg &= ~PCIC_ADDRWIN_ENABLE_IO0;\n\t\tbreak;\n\tcase 1:\n\t\treg &= ~PCIC_ADDRWIN_ENABLE_IO1;\n\t\tbreak;\n\t}\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, reg);\n\n\tph->ioalloc &= ~(1 << win);\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define STATIC static",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC void",
            "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
            "STATIC void",
            "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
            "STATIC void",
            "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
            "STATIC int",
            "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
            "struct pcic_handle *ph = poll->ph;",
            "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pcic_handle *ph = poll->ph;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC void\npccbb_pcmcia_io_unmap(pch, win)\n\tpcmcia_chipset_handle_t pch;\n\tint win;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tint reg;\n\n\tif (win >= PCIC_IO_WINS || win < 0) {\n\t\tpanic(\"pccbb_pcmcia_io_unmap: window out of range\");\n\t}\n\n\treg = Pcic_read(ph, PCIC_ADDRWIN_ENABLE);\n\tswitch (win) {\n\tcase 0:\n\t\treg &= ~PCIC_ADDRWIN_ENABLE_IO0;\n\t\tbreak;\n\tcase 1:\n\t\treg &= ~PCIC_ADDRWIN_ENABLE_IO1;\n\t\tbreak;\n\t}\n\tPcic_write(ph, PCIC_ADDRWIN_ENABLE, reg);\n\n\tph->ioalloc &= ~(1 << win);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/if_cnwreg.h>\n#include <sys/ioctl.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\tcnw_detach;\nstruct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;\n\nint\ncnw_detach(dev, flags)\n\tstruct device *dev;\n\tint flags;\n{\n\tstruct cnw_softc *sc = (struct cnw_softc *)dev;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint rv = 0;\n\n\tpcmcia_io_unmap(sc->sc_pf, sc->sc_iowin);\n\tpcmcia_io_free(sc->sc_pf, &sc->sc_pcioh);\n\tpcmcia_mem_unmap(sc->sc_pf, sc->sc_memwin);\n\tpcmcia_mem_free(sc->sc_pf, &sc->sc_pcmemh);\n\n\tether_ifdetach(ifp);\n\tif_detach(ifp);\n\n\treturn (rv);\n}"
  },
  {
    "function_name": "cnw_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_cnw.c",
    "lines": "838-847",
    "snippet": "void\ncnw_watchdog(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct cnw_softc *sc = ifp->if_softc;\n\n\tprintf(\"%s: device timeout; card reset\\n\", sc->sc_dev.dv_xname);\n\t++ifp->if_oerrors;\n\tcnw_init(sc);\n}",
    "includes": [
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/pcmcia/if_cnwreg.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void cnw_init",
      "void cnw_watchdog",
      "struct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cnw_init",
          "args": [
            "sc"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "cnw_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_cnw.c",
          "lines": "273-307",
          "snippet": "void\ncnw_init(sc)\n\tstruct cnw_softc *sc;\n{\n\t/* Reset the card */\n\tcnw_reset(sc);\n\n\t/* Issue a NOP to check the card */\n\tCNW_CMD0(sc, CNW_CMD_NOP);\n\n\t/* Set up receive configuration */\n\tCNW_CMD1(sc, CNW_CMD_SRC, CNW_RXCONF_RXENA | CNW_RXCONF_BCAST);\n\n\t/* Set up transmit configuration */\n\tCNW_CMD1(sc, CNW_CMD_STC, CNW_TXCONF_TXENA);\n\n\t/* Set domain */\n\tCNW_CMD2(sc, CNW_CMD_SMD, sc->sc_domain, sc->sc_domain >> 8);\n\n\t/* Set scramble key */\n\tCNW_CMD2(sc, CNW_CMD_SSK, sc->sc_skey, sc->sc_skey >> 8);\n\n\t/* Enable interrupts */\n\tWAIT_WOC(sc);\n\tbus_space_write_1(sc->sc_iot, sc->sc_ioh,\n\t\t\t  CNW_REG_IMR, CNW_IMR_IENA | CNW_IMR_RFU1);\n\n\t/* Enable receiver */\n\tCNW_CMD0(sc, CNW_CMD_ER);\n\n\t/* \"Set the IENA bit in COR\" */\n\tWAIT_WOC(sc);\n\tbus_space_write_1(sc->sc_iot, sc->sc_ioh, CNW_REG_COR,\n\t\t\t  CNW_COR_IENA | CNW_COR_LVLREQ);\n}",
          "includes": [
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/pcmcia/if_cnwreg.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/socket.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void cnw_reset",
            "void cnw_init",
            "struct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/if_cnwreg.h>\n#include <sys/ioctl.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid cnw_reset;\nvoid cnw_init;\nstruct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;\n\nvoid\ncnw_init(sc)\n\tstruct cnw_softc *sc;\n{\n\t/* Reset the card */\n\tcnw_reset(sc);\n\n\t/* Issue a NOP to check the card */\n\tCNW_CMD0(sc, CNW_CMD_NOP);\n\n\t/* Set up receive configuration */\n\tCNW_CMD1(sc, CNW_CMD_SRC, CNW_RXCONF_RXENA | CNW_RXCONF_BCAST);\n\n\t/* Set up transmit configuration */\n\tCNW_CMD1(sc, CNW_CMD_STC, CNW_TXCONF_TXENA);\n\n\t/* Set domain */\n\tCNW_CMD2(sc, CNW_CMD_SMD, sc->sc_domain, sc->sc_domain >> 8);\n\n\t/* Set scramble key */\n\tCNW_CMD2(sc, CNW_CMD_SSK, sc->sc_skey, sc->sc_skey >> 8);\n\n\t/* Enable interrupts */\n\tWAIT_WOC(sc);\n\tbus_space_write_1(sc->sc_iot, sc->sc_ioh,\n\t\t\t  CNW_REG_IMR, CNW_IMR_IENA | CNW_IMR_RFU1);\n\n\t/* Enable receiver */\n\tCNW_CMD0(sc, CNW_CMD_ER);\n\n\t/* \"Set the IENA bit in COR\" */\n\tWAIT_WOC(sc);\n\tbus_space_write_1(sc->sc_iot, sc->sc_ioh, CNW_REG_COR,\n\t\t\t  CNW_COR_IENA | CNW_COR_LVLREQ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: device timeout; card reset\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/if_cnwreg.h>\n#include <sys/ioctl.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid cnw_init;\nvoid cnw_watchdog;\nstruct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;\n\nvoid\ncnw_watchdog(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct cnw_softc *sc = ifp->if_softc;\n\n\tprintf(\"%s: device timeout; card reset\\n\", sc->sc_dev.dv_xname);\n\t++ifp->if_oerrors;\n\tcnw_init(sc);\n}"
  },
  {
    "function_name": "cnw_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_cnw.c",
    "lines": "780-831",
    "snippet": "int\ncnw_ioctl(ifp, cmd, data)\n\tregister struct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct cnw_softc *sc = ifp->if_softc;\n\tstruct ifaddr *ifa = (struct ifaddr *)data;\n\tint s, error = 0;\n\n\ts = splnet();\n\n\tswitch (cmd) {\n\n\tcase SIOCSIFADDR:\n\t\tif (!(ifp->if_flags & IFF_RUNNING) &&\n\t\t    (error = cnw_enable(sc)) != 0)\n\t\t\tbreak;\n\t\tifp->if_flags |= IFF_UP;\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS:\n\t\tif ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) == IFF_RUNNING) {\n\t\t\t/*\n\t\t\t * The interface is marked down and it is running, so\n\t\t\t * stop it.\n\t\t\t */\n\t\t\tcnw_disable(sc);\n\t\t} else if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) == IFF_UP){\n\t\t\t/*\n\t\t\t * The interface is marked up and it is stopped, so\n\t\t\t * start it.\n\t\t\t */\n\t\t\terror = cnw_enable(sc);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\tsplx(s);\n\treturn (error);\n}",
    "includes": [
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/pcmcia/if_cnwreg.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int cnw_enable",
      "void cnw_disable",
      "int cnw_ioctl",
      "struct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cnw_enable",
          "args": [
            "sc"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "cnw_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_cnw.c",
          "lines": "313-332",
          "snippet": "int\ncnw_enable(sc)\n\tstruct cnw_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\tsc->sc_ih = pcmcia_intr_establish(sc->sc_pf, IPL_NET, cnw_intr, sc);\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\"%s: couldn't establish interrupt handler\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn (EIO);\n\t}\n\tif (pcmcia_function_enable(sc->sc_pf) != 0) {\n\t\tprintf(\"%s: couldn't enable card\\n\", sc->sc_dev.dv_xname);\n\t\treturn (EIO);\n\t}\n\tcnw_init(sc);\n\tifp->if_flags |= IFF_RUNNING;\n\treturn (0);\n}",
          "includes": [
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/pcmcia/if_cnwreg.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/socket.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void cnw_init",
            "int cnw_enable",
            "int cnw_intr",
            "struct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/if_cnwreg.h>\n#include <sys/ioctl.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid cnw_init;\nint cnw_enable;\nint cnw_intr;\nstruct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;\n\nint\ncnw_enable(sc)\n\tstruct cnw_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\tsc->sc_ih = pcmcia_intr_establish(sc->sc_pf, IPL_NET, cnw_intr, sc);\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\"%s: couldn't establish interrupt handler\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn (EIO);\n\t}\n\tif (pcmcia_function_enable(sc->sc_pf) != 0) {\n\t\tprintf(\"%s: couldn't enable card\\n\", sc->sc_dev.dv_xname);\n\t\treturn (EIO);\n\t}\n\tcnw_init(sc);\n\tifp->if_flags |= IFF_RUNNING;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cnw_disable",
          "args": [
            "sc"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "cnw_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_cnw.c",
          "lines": "338-348",
          "snippet": "void\ncnw_disable(sc)\n\tstruct cnw_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\tpcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);\n\tpcmcia_function_disable(sc->sc_pf);\n\tifp->if_flags &= ~IFF_RUNNING;\n\tifp->if_timer = 0;\n}",
          "includes": [
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/pcmcia/if_cnwreg.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/socket.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void cnw_disable",
            "struct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/if_cnwreg.h>\n#include <sys/ioctl.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid cnw_disable;\nstruct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;\n\nvoid\ncnw_disable(sc)\n\tstruct cnw_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\tpcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);\n\tpcmcia_function_disable(sc->sc_pf);\n\tifp->if_flags &= ~IFF_RUNNING;\n\tifp->if_timer = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arp_ifinit",
          "args": [
            "&sc->sc_arpcom",
            "ifa"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "arp_ifinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_devar.h",
          "lines": "929-936",
          "snippet": "static void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}",
          "includes": [
            "#include <sys/devconf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/devconf.h>\n\nstatic void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/if_cnwreg.h>\n#include <sys/ioctl.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint cnw_enable;\nvoid cnw_disable;\nint cnw_ioctl;\nstruct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;\n\nint\ncnw_ioctl(ifp, cmd, data)\n\tregister struct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct cnw_softc *sc = ifp->if_softc;\n\tstruct ifaddr *ifa = (struct ifaddr *)data;\n\tint s, error = 0;\n\n\ts = splnet();\n\n\tswitch (cmd) {\n\n\tcase SIOCSIFADDR:\n\t\tif (!(ifp->if_flags & IFF_RUNNING) &&\n\t\t    (error = cnw_enable(sc)) != 0)\n\t\t\tbreak;\n\t\tifp->if_flags |= IFF_UP;\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS:\n\t\tif ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) == IFF_RUNNING) {\n\t\t\t/*\n\t\t\t * The interface is marked down and it is running, so\n\t\t\t * stop it.\n\t\t\t */\n\t\t\tcnw_disable(sc);\n\t\t} else if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) == IFF_UP){\n\t\t\t/*\n\t\t\t * The interface is marked up and it is stopped, so\n\t\t\t * start it.\n\t\t\t */\n\t\t\terror = cnw_enable(sc);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\tsplx(s);\n\treturn (error);\n}"
  },
  {
    "function_name": "cnw_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_cnw.c",
    "lines": "700-774",
    "snippet": "int\ncnw_intr(arg)\n\tvoid *arg;\n{\n\tstruct cnw_softc *sc = arg;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint ret, status, rser, tser;\n\n\tif (!(sc->sc_arpcom.ac_if.if_flags & IFF_RUNNING))\n\t\treturn (0);\n\tifp->if_timer = 0;\t/* stop watchdog timer */\n\n\tret = 0;\n\tfor (;;) {\n\t\tWAIT_WOC(sc);\n\t\tif (!(bus_space_read_1(sc->sc_iot, sc->sc_ioh,\n\t\t\t\t       CNW_REG_CCSR) & 0x02)) {\n\t\t\tif (ret == 0)\n\t\t\t\tprintf(\"%s: spurious interrupt\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname);\n\t\t\treturn (ret);\n\t\t}\n\t\tret = 1;\n\t\tstatus = bus_space_read_1(sc->sc_iot, sc->sc_ioh, CNW_REG_ASR);\n\n\t\t/* Anything to receive? */\n\t\tif (status & CNW_ASR_RXRDY)\n\t\t\tcnw_recv(sc);\n\n\t\t/* Receive error */\n\t\tif (status & CNW_ASR_RXERR) {\n\t\t\t/*\n\t\t\t * I get a *lot* of spurious receive errors\n\t\t\t * (many per second), even when the interface\n\t\t\t * is quiescent, so we don't increment\n\t\t\t * if_ierrors here.\n\t\t\t */\n\t\t\trser = bus_space_read_1(sc->sc_memt, sc->sc_memh,\n\t\t\t\t\t\tsc->sc_memoff + CNW_EREG_RSER);\n\t\t\t/* Clear error bits in RSER */\n\t\t\tWAIT_WOC(sc);\n\t\t\tbus_space_write_1(sc->sc_memt, sc->sc_memh,\n\t\t\t\tsc->sc_memoff + CNW_EREG_RSERW,\n\t\t\t\tCNW_RSER_RXERR |\n\t\t\t\t(rser & (CNW_RSER_RXCRC | CNW_RSER_RXBIG)));\n\t\t\t/* Clear RXERR in ASR */\n\t\t\tWAIT_WOC(sc);\n\t\t\tbus_space_write_1(sc->sc_memt, sc->sc_memh,\n\t\t\t\tsc->sc_memoff + CNW_EREG_ASCC, CNW_ASR_RXERR);\n\t\t}\n\n\t\t/* Transmit done */\n\t\tif (status & CNW_ASR_TXDN) {\n\t\t\ttser = bus_space_read_1(sc->sc_memt, sc->sc_memh,\n\t\t\t\t\t\tCNW_EREG_TSER);\n\t\t\tif (tser & CNW_TSER_TXOK) {\n\t\t\t\tWAIT_WOC(sc);\n\t\t\t\tbus_space_write_1(sc->sc_memt, sc->sc_memh,\n\t\t\t\t\tsc->sc_memoff + CNW_EREG_TSERW,\n\t\t\t\t\tCNW_TSER_TXOK | CNW_TSER_RTRY);\n\t\t\t}\n\t\t\tif (tser & CNW_TSER_ERROR) {\n\t\t\t\t++ifp->if_oerrors;\n\t\t\t\tWAIT_WOC(sc);\n\t\t\t\tbus_space_write_1(sc->sc_memt, sc->sc_memh,\n\t\t\t\t\tsc->sc_memoff + CNW_EREG_TSERW,\n\t\t\t\t\t(tser & CNW_TSER_ERROR) |\n\t\t\t\t\tCNW_TSER_RTRY);\n\t\t\t}\n\t\t\t/* Continue to send packets from the queue */\n\t\t\tcnw_start(&sc->sc_arpcom.ac_if);\n\t\t}\n\t\t\t\t\n\t}\n}",
    "includes": [
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/pcmcia/if_cnwreg.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void cnw_start",
      "void cnw_recv",
      "int cnw_intr",
      "struct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cnw_start",
          "args": [
            "&sc->sc_arpcom.ac_if"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "cnw_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_cnw.c",
          "lines": "453-491",
          "snippet": "void\ncnw_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct cnw_softc *sc = ifp->if_softc;\n\tstruct mbuf *m0;\n\tint asr;\n\n#ifdef CNW_DEBUG\n\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\tprintf(\"%s: cnw_start\\n\", ifp->if_xname);\n#endif\n\n\tfor (;;) {\n\t\t/* Is there any buffer space available on the card? */\n\t\tWAIT_WOC(sc);\n\t\tasr = bus_space_read_1(sc->sc_iot, sc->sc_ioh, CNW_REG_ASR);\n\t\tif (!(asr & CNW_ASR_TXBA)) {\n#ifdef CNW_DEBUG\n\t\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\t\tprintf(\"%s: no buffer space\\n\", ifp->if_xname);\n#endif\n\t\t\treturn;\n\t\t}\n\n\t\tIF_DEQUEUE(&ifp->if_snd, m0);\n\t\tif (m0 == 0)\n\t\t\treturn;\n\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\t\t\n\t\tcnw_transmit(sc, m0);\n\t\t++ifp->if_opackets;\n\t\tifp->if_timer = 3; /* start watchdog timer */\n\t}\n}",
          "includes": [
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/pcmcia/if_cnwreg.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/socket.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void cnw_start",
            "void cnw_transmit",
            "struct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/if_cnwreg.h>\n#include <sys/ioctl.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid cnw_start;\nvoid cnw_transmit;\nstruct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;\n\nvoid\ncnw_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct cnw_softc *sc = ifp->if_softc;\n\tstruct mbuf *m0;\n\tint asr;\n\n#ifdef CNW_DEBUG\n\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\tprintf(\"%s: cnw_start\\n\", ifp->if_xname);\n#endif\n\n\tfor (;;) {\n\t\t/* Is there any buffer space available on the card? */\n\t\tWAIT_WOC(sc);\n\t\tasr = bus_space_read_1(sc->sc_iot, sc->sc_ioh, CNW_REG_ASR);\n\t\tif (!(asr & CNW_ASR_TXBA)) {\n#ifdef CNW_DEBUG\n\t\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\t\tprintf(\"%s: no buffer space\\n\", ifp->if_xname);\n#endif\n\t\t\treturn;\n\t\t}\n\n\t\tIF_DEQUEUE(&ifp->if_snd, m0);\n\t\tif (m0 == 0)\n\t\t\treturn;\n\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\t\t\n\t\tcnw_transmit(sc, m0);\n\t\t++ifp->if_opackets;\n\t\tifp->if_timer = 3; /* start watchdog timer */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_memt",
            "sc->sc_memh",
            "sc->sc_memoff + CNW_EREG_TSERW",
            "(tser & CNW_TSER_ERROR) |\n\t\t\t\t\tCNW_TSER_RTRY"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WAIT_WOC",
          "args": [
            "sc"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_memt",
            "sc->sc_memh",
            "sc->sc_memoff + CNW_EREG_TSERW",
            "CNW_TSER_TXOK | CNW_TSER_RTRY"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WAIT_WOC",
          "args": [
            "sc"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "sc->sc_memt",
            "sc->sc_memh",
            "CNW_EREG_TSER"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_memt",
            "sc->sc_memh",
            "sc->sc_memoff + CNW_EREG_ASCC",
            "CNW_ASR_RXERR"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WAIT_WOC",
          "args": [
            "sc"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_memt",
            "sc->sc_memh",
            "sc->sc_memoff + CNW_EREG_RSERW",
            "CNW_RSER_RXERR |\n\t\t\t\t(rser & (CNW_RSER_RXCRC | CNW_RSER_RXBIG))"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WAIT_WOC",
          "args": [
            "sc"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "sc->sc_memt",
            "sc->sc_memh",
            "sc->sc_memoff + CNW_EREG_RSER"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cnw_recv",
          "args": [
            "sc"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "cnw_recv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_cnw.c",
          "lines": "643-694",
          "snippet": "void\ncnw_recv(sc)\n\tstruct cnw_softc *sc;\n{\n\tint rser;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tstruct mbuf *m;\n\tstruct ether_header *eh;\n\n\tfor (;;) {\n\t\tWAIT_WOC(sc);\n\t\trser = bus_space_read_1(sc->sc_memt, sc->sc_memh,\n\t\t\t\t\tsc->sc_memoff + CNW_EREG_RSER);\n\t\tif (!(rser & CNW_RSER_RXAVAIL))\n\t\t\treturn;\n\n\t\t/* Pull packet off card */\n\t\tm = cnw_read(sc);\n\n\t\t/* Acknowledge packet */\n\t\tCNW_CMD0(sc, CNW_CMD_SRP);\n\n\t\t/* Did we manage to get the packet from the interface? */\n\t\tif (m == 0) {\n\t\t\t++ifp->if_ierrors;\n\t\t\treturn;\n\t\t}\n\t\t++ifp->if_ipackets;\n\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t\t/*\n\t\t * Check that the packet is for us or {multi,broad}cast. Maybe\n\t\t * there's a fool-poof hardware check for this, but I don't\n\t\t * really know...\n\t\t */\n\t\teh = mtod(m, struct ether_header *);\n\t\tif ((eh->ether_dhost[0] & 1) == 0 && /* !mcast and !bcast */\n\t\t    bcmp(sc->sc_arpcom.ac_enaddr, eh->ether_dhost,\n\t\t\tsizeof(eh->ether_dhost)) != 0) {\n\t\t\tm_freem(m);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Pass the packet up, with the ether header sort-of removed */\n\t\tm_adj(m, sizeof(struct ether_header));\n\t\tether_input(ifp, eh, m);\n\t}\n}",
          "includes": [
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/pcmcia/if_cnwreg.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/socket.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct mbuf *cnw_read",
            "void cnw_recv",
            "struct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/if_cnwreg.h>\n#include <sys/ioctl.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *cnw_read;\nvoid cnw_recv;\nstruct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;\n\nvoid\ncnw_recv(sc)\n\tstruct cnw_softc *sc;\n{\n\tint rser;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tstruct mbuf *m;\n\tstruct ether_header *eh;\n\n\tfor (;;) {\n\t\tWAIT_WOC(sc);\n\t\trser = bus_space_read_1(sc->sc_memt, sc->sc_memh,\n\t\t\t\t\tsc->sc_memoff + CNW_EREG_RSER);\n\t\tif (!(rser & CNW_RSER_RXAVAIL))\n\t\t\treturn;\n\n\t\t/* Pull packet off card */\n\t\tm = cnw_read(sc);\n\n\t\t/* Acknowledge packet */\n\t\tCNW_CMD0(sc, CNW_CMD_SRP);\n\n\t\t/* Did we manage to get the packet from the interface? */\n\t\tif (m == 0) {\n\t\t\t++ifp->if_ierrors;\n\t\t\treturn;\n\t\t}\n\t\t++ifp->if_ipackets;\n\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t\t/*\n\t\t * Check that the packet is for us or {multi,broad}cast. Maybe\n\t\t * there's a fool-poof hardware check for this, but I don't\n\t\t * really know...\n\t\t */\n\t\teh = mtod(m, struct ether_header *);\n\t\tif ((eh->ether_dhost[0] & 1) == 0 && /* !mcast and !bcast */\n\t\t    bcmp(sc->sc_arpcom.ac_enaddr, eh->ether_dhost,\n\t\t\tsizeof(eh->ether_dhost)) != 0) {\n\t\t\tm_freem(m);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Pass the packet up, with the ether header sort-of removed */\n\t\tm_adj(m, sizeof(struct ether_header));\n\t\tether_input(ifp, eh, m);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "sc->sc_iot",
            "sc->sc_ioh",
            "CNW_REG_ASR"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: spurious interrupt\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "sc->sc_iot",
            "sc->sc_ioh",
            "CNW_REG_CCSR"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WAIT_WOC",
          "args": [
            "sc"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/if_cnwreg.h>\n#include <sys/ioctl.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid cnw_start;\nvoid cnw_recv;\nint cnw_intr;\nstruct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;\n\nint\ncnw_intr(arg)\n\tvoid *arg;\n{\n\tstruct cnw_softc *sc = arg;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint ret, status, rser, tser;\n\n\tif (!(sc->sc_arpcom.ac_if.if_flags & IFF_RUNNING))\n\t\treturn (0);\n\tifp->if_timer = 0;\t/* stop watchdog timer */\n\n\tret = 0;\n\tfor (;;) {\n\t\tWAIT_WOC(sc);\n\t\tif (!(bus_space_read_1(sc->sc_iot, sc->sc_ioh,\n\t\t\t\t       CNW_REG_CCSR) & 0x02)) {\n\t\t\tif (ret == 0)\n\t\t\t\tprintf(\"%s: spurious interrupt\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname);\n\t\t\treturn (ret);\n\t\t}\n\t\tret = 1;\n\t\tstatus = bus_space_read_1(sc->sc_iot, sc->sc_ioh, CNW_REG_ASR);\n\n\t\t/* Anything to receive? */\n\t\tif (status & CNW_ASR_RXRDY)\n\t\t\tcnw_recv(sc);\n\n\t\t/* Receive error */\n\t\tif (status & CNW_ASR_RXERR) {\n\t\t\t/*\n\t\t\t * I get a *lot* of spurious receive errors\n\t\t\t * (many per second), even when the interface\n\t\t\t * is quiescent, so we don't increment\n\t\t\t * if_ierrors here.\n\t\t\t */\n\t\t\trser = bus_space_read_1(sc->sc_memt, sc->sc_memh,\n\t\t\t\t\t\tsc->sc_memoff + CNW_EREG_RSER);\n\t\t\t/* Clear error bits in RSER */\n\t\t\tWAIT_WOC(sc);\n\t\t\tbus_space_write_1(sc->sc_memt, sc->sc_memh,\n\t\t\t\tsc->sc_memoff + CNW_EREG_RSERW,\n\t\t\t\tCNW_RSER_RXERR |\n\t\t\t\t(rser & (CNW_RSER_RXCRC | CNW_RSER_RXBIG)));\n\t\t\t/* Clear RXERR in ASR */\n\t\t\tWAIT_WOC(sc);\n\t\t\tbus_space_write_1(sc->sc_memt, sc->sc_memh,\n\t\t\t\tsc->sc_memoff + CNW_EREG_ASCC, CNW_ASR_RXERR);\n\t\t}\n\n\t\t/* Transmit done */\n\t\tif (status & CNW_ASR_TXDN) {\n\t\t\ttser = bus_space_read_1(sc->sc_memt, sc->sc_memh,\n\t\t\t\t\t\tCNW_EREG_TSER);\n\t\t\tif (tser & CNW_TSER_TXOK) {\n\t\t\t\tWAIT_WOC(sc);\n\t\t\t\tbus_space_write_1(sc->sc_memt, sc->sc_memh,\n\t\t\t\t\tsc->sc_memoff + CNW_EREG_TSERW,\n\t\t\t\t\tCNW_TSER_TXOK | CNW_TSER_RTRY);\n\t\t\t}\n\t\t\tif (tser & CNW_TSER_ERROR) {\n\t\t\t\t++ifp->if_oerrors;\n\t\t\t\tWAIT_WOC(sc);\n\t\t\t\tbus_space_write_1(sc->sc_memt, sc->sc_memh,\n\t\t\t\t\tsc->sc_memoff + CNW_EREG_TSERW,\n\t\t\t\t\t(tser & CNW_TSER_ERROR) |\n\t\t\t\t\tCNW_TSER_RTRY);\n\t\t\t}\n\t\t\t/* Continue to send packets from the queue */\n\t\t\tcnw_start(&sc->sc_arpcom.ac_if);\n\t\t}\n\t\t\t\t\n\t}\n}"
  },
  {
    "function_name": "cnw_recv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_cnw.c",
    "lines": "643-694",
    "snippet": "void\ncnw_recv(sc)\n\tstruct cnw_softc *sc;\n{\n\tint rser;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tstruct mbuf *m;\n\tstruct ether_header *eh;\n\n\tfor (;;) {\n\t\tWAIT_WOC(sc);\n\t\trser = bus_space_read_1(sc->sc_memt, sc->sc_memh,\n\t\t\t\t\tsc->sc_memoff + CNW_EREG_RSER);\n\t\tif (!(rser & CNW_RSER_RXAVAIL))\n\t\t\treturn;\n\n\t\t/* Pull packet off card */\n\t\tm = cnw_read(sc);\n\n\t\t/* Acknowledge packet */\n\t\tCNW_CMD0(sc, CNW_CMD_SRP);\n\n\t\t/* Did we manage to get the packet from the interface? */\n\t\tif (m == 0) {\n\t\t\t++ifp->if_ierrors;\n\t\t\treturn;\n\t\t}\n\t\t++ifp->if_ipackets;\n\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t\t/*\n\t\t * Check that the packet is for us or {multi,broad}cast. Maybe\n\t\t * there's a fool-poof hardware check for this, but I don't\n\t\t * really know...\n\t\t */\n\t\teh = mtod(m, struct ether_header *);\n\t\tif ((eh->ether_dhost[0] & 1) == 0 && /* !mcast and !bcast */\n\t\t    bcmp(sc->sc_arpcom.ac_enaddr, eh->ether_dhost,\n\t\t\tsizeof(eh->ether_dhost)) != 0) {\n\t\t\tm_freem(m);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Pass the packet up, with the ether header sort-of removed */\n\t\tm_adj(m, sizeof(struct ether_header));\n\t\tether_input(ifp, eh, m);\n\t}\n}",
    "includes": [
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/pcmcia/if_cnwreg.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct mbuf *cnw_read",
      "void cnw_recv",
      "struct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ether_input",
          "args": [
            "ifp",
            "eh",
            "m"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_adj",
          "args": [
            "m",
            "sizeof(struct ether_header)"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "sc->sc_arpcom.ac_enaddr",
            "eh->ether_dhost",
            "sizeof(eh->ether_dhost)"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "structether_header*"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "m"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CNW_CMD0",
          "args": [
            "sc",
            "CNW_CMD_SRP"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cnw_read",
          "args": [
            "sc"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "sc->sc_memt",
            "sc->sc_memh",
            "sc->sc_memoff + CNW_EREG_RSER"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WAIT_WOC",
          "args": [
            "sc"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/if_cnwreg.h>\n#include <sys/ioctl.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstruct mbuf *cnw_read;\nvoid cnw_recv;\nstruct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;\n\nvoid\ncnw_recv(sc)\n\tstruct cnw_softc *sc;\n{\n\tint rser;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tstruct mbuf *m;\n\tstruct ether_header *eh;\n\n\tfor (;;) {\n\t\tWAIT_WOC(sc);\n\t\trser = bus_space_read_1(sc->sc_memt, sc->sc_memh,\n\t\t\t\t\tsc->sc_memoff + CNW_EREG_RSER);\n\t\tif (!(rser & CNW_RSER_RXAVAIL))\n\t\t\treturn;\n\n\t\t/* Pull packet off card */\n\t\tm = cnw_read(sc);\n\n\t\t/* Acknowledge packet */\n\t\tCNW_CMD0(sc, CNW_CMD_SRP);\n\n\t\t/* Did we manage to get the packet from the interface? */\n\t\tif (m == 0) {\n\t\t\t++ifp->if_ierrors;\n\t\t\treturn;\n\t\t}\n\t\t++ifp->if_ipackets;\n\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t\t/*\n\t\t * Check that the packet is for us or {multi,broad}cast. Maybe\n\t\t * there's a fool-poof hardware check for this, but I don't\n\t\t * really know...\n\t\t */\n\t\teh = mtod(m, struct ether_header *);\n\t\tif ((eh->ether_dhost[0] & 1) == 0 && /* !mcast and !bcast */\n\t\t    bcmp(sc->sc_arpcom.ac_enaddr, eh->ether_dhost,\n\t\t\tsizeof(eh->ether_dhost)) != 0) {\n\t\t\tm_freem(m);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Pass the packet up, with the ether header sort-of removed */\n\t\tm_adj(m, sizeof(struct ether_header));\n\t\tether_input(ifp, eh, m);\n\t}\n}"
  },
  {
    "function_name": "cnw_transmit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_cnw.c",
    "lines": "497-549",
    "snippet": "void\ncnw_transmit(sc, m0)\n\tstruct cnw_softc *sc;\n\tstruct mbuf *m0;\n{\n\tint buffer, bufsize, bufoffset, bufptr, bufspace, len, mbytes, n;\n\tstruct mbuf *m;\n\tu_int8_t *mptr;\n\n\t/* Get buffer info from card */\n\tbuffer = read16(sc, CNW_EREG_TDP);\n\tbufsize = read16(sc, CNW_EREG_TDP + 2);\n\tbufoffset = read16(sc, CNW_EREG_TDP + 4);\n#ifdef CNW_DEBUG\n\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\tprintf(\"%s: cnw_transmit b=0x%x s=%d o=0x%x\\n\",\n\t\t       sc->sc_dev.dv_xname, buffer, bufsize, bufoffset);\n#endif\n\n\t/* Copy data from mbuf chain to card buffers */\n\tbufptr = sc->sc_memoff + buffer + bufoffset;\n\tbufspace = bufsize;\n\tlen = 0;\n\tfor (m = m0; m; ) {\n\t\tmptr = mtod(m, u_int8_t *);\n\t\tmbytes = m->m_len;\n\t\tlen += mbytes;\n\t\twhile (mbytes > 0) {\n\t\t\tif (bufspace == 0) {\n\t\t\t\tbuffer = read16(sc, buffer);\n\t\t\t\tbufptr = sc->sc_memoff + buffer + bufoffset;\n\t\t\t\tbufspace = bufsize;\n#ifdef CNW_DEBUG\n\t\t\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\t\t\tprintf(\"%s:   next buffer @0x%x\\n\",\n\t\t\t\t\t       sc->sc_dev.dv_xname, buffer);\n#endif\n\t\t\t}\n\t\t\tn = mbytes <= bufspace ? mbytes : bufspace;\n\t\t\tbus_space_write_region_1(sc->sc_memt, sc->sc_memh,\n\t\t\t\t\t\t bufptr, mptr, n);\n\t\t\tbufptr += n;\n\t\t\tbufspace -= n;\n\t\t\tmptr += n;\n\t\t\tmbytes -= n;\n\t\t}\n\t\tMFREE(m, m0);\n\t\tm = m0;\n\t}\n\n\t/* Issue transmit command */\n\tCNW_CMD2(sc, CNW_CMD_TL, len, len >> 8);\n}",
    "includes": [
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/pcmcia/if_cnwreg.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void cnw_transmit",
      "static int read16",
      "struct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CNW_CMD2",
          "args": [
            "sc",
            "CNW_CMD_TL",
            "len",
            "len >> 8"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MFREE",
          "args": [
            "m",
            "m0"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_region_1",
          "args": [
            "sc->sc_memt",
            "sc->sc_memh",
            "bufptr",
            "mptr",
            "n"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s:   next buffer @0x%x\\n\"",
            "sc->sc_dev.dv_xname",
            "buffer"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "read16",
          "args": [
            "sc",
            "buffer"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "read16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_cnw.c",
          "lines": "190-207",
          "snippet": "static int\nread16(sc, offset)\n\tstruct cnw_softc *sc;\n\tint offset;\n{\n\tint hi, lo;\n\n\t/* This could presumably be done more efficient with\n\t * bus_space_read_2(), but I don't know anything about the\n\t * byte sex guarantees... Besides, this is pretty cheap as\n\t * well :-)\n\t */\n\tlo = bus_space_read_1(sc->sc_memt, sc->sc_memh,\n\t\t\t      sc->sc_memoff + offset);\n\thi = bus_space_read_1(sc->sc_memt, sc->sc_memh,\n\t\t\t      sc->sc_memoff + offset + 1);\n\treturn ((hi << 8) | lo);\n}",
          "includes": [
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/pcmcia/if_cnwreg.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/socket.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int read16",
            "struct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/if_cnwreg.h>\n#include <sys/ioctl.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic int read16;\nstruct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;\n\nstatic int\nread16(sc, offset)\n\tstruct cnw_softc *sc;\n\tint offset;\n{\n\tint hi, lo;\n\n\t/* This could presumably be done more efficient with\n\t * bus_space_read_2(), but I don't know anything about the\n\t * byte sex guarantees... Besides, this is pretty cheap as\n\t * well :-)\n\t */\n\tlo = bus_space_read_1(sc->sc_memt, sc->sc_memh,\n\t\t\t      sc->sc_memoff + offset);\n\thi = bus_space_read_1(sc->sc_memt, sc->sc_memh,\n\t\t\t      sc->sc_memoff + offset + 1);\n\treturn ((hi << 8) | lo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "u_int8_t*"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/if_cnwreg.h>\n#include <sys/ioctl.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid cnw_transmit;\nstatic int read16;\nstruct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;\n\nvoid\ncnw_transmit(sc, m0)\n\tstruct cnw_softc *sc;\n\tstruct mbuf *m0;\n{\n\tint buffer, bufsize, bufoffset, bufptr, bufspace, len, mbytes, n;\n\tstruct mbuf *m;\n\tu_int8_t *mptr;\n\n\t/* Get buffer info from card */\n\tbuffer = read16(sc, CNW_EREG_TDP);\n\tbufsize = read16(sc, CNW_EREG_TDP + 2);\n\tbufoffset = read16(sc, CNW_EREG_TDP + 4);\n#ifdef CNW_DEBUG\n\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\tprintf(\"%s: cnw_transmit b=0x%x s=%d o=0x%x\\n\",\n\t\t       sc->sc_dev.dv_xname, buffer, bufsize, bufoffset);\n#endif\n\n\t/* Copy data from mbuf chain to card buffers */\n\tbufptr = sc->sc_memoff + buffer + bufoffset;\n\tbufspace = bufsize;\n\tlen = 0;\n\tfor (m = m0; m; ) {\n\t\tmptr = mtod(m, u_int8_t *);\n\t\tmbytes = m->m_len;\n\t\tlen += mbytes;\n\t\twhile (mbytes > 0) {\n\t\t\tif (bufspace == 0) {\n\t\t\t\tbuffer = read16(sc, buffer);\n\t\t\t\tbufptr = sc->sc_memoff + buffer + bufoffset;\n\t\t\t\tbufspace = bufsize;\n#ifdef CNW_DEBUG\n\t\t\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\t\t\tprintf(\"%s:   next buffer @0x%x\\n\",\n\t\t\t\t\t       sc->sc_dev.dv_xname, buffer);\n#endif\n\t\t\t}\n\t\t\tn = mbytes <= bufspace ? mbytes : bufspace;\n\t\t\tbus_space_write_region_1(sc->sc_memt, sc->sc_memh,\n\t\t\t\t\t\t bufptr, mptr, n);\n\t\t\tbufptr += n;\n\t\t\tbufspace -= n;\n\t\t\tmptr += n;\n\t\t\tmbytes -= n;\n\t\t}\n\t\tMFREE(m, m0);\n\t\tm = m0;\n\t}\n\n\t/* Issue transmit command */\n\tCNW_CMD2(sc, CNW_CMD_TL, len, len >> 8);\n}"
  },
  {
    "function_name": "cnw_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_cnw.c",
    "lines": "453-491",
    "snippet": "void\ncnw_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct cnw_softc *sc = ifp->if_softc;\n\tstruct mbuf *m0;\n\tint asr;\n\n#ifdef CNW_DEBUG\n\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\tprintf(\"%s: cnw_start\\n\", ifp->if_xname);\n#endif\n\n\tfor (;;) {\n\t\t/* Is there any buffer space available on the card? */\n\t\tWAIT_WOC(sc);\n\t\tasr = bus_space_read_1(sc->sc_iot, sc->sc_ioh, CNW_REG_ASR);\n\t\tif (!(asr & CNW_ASR_TXBA)) {\n#ifdef CNW_DEBUG\n\t\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\t\tprintf(\"%s: no buffer space\\n\", ifp->if_xname);\n#endif\n\t\t\treturn;\n\t\t}\n\n\t\tIF_DEQUEUE(&ifp->if_snd, m0);\n\t\tif (m0 == 0)\n\t\t\treturn;\n\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\t\t\n\t\tcnw_transmit(sc, m0);\n\t\t++ifp->if_opackets;\n\t\tifp->if_timer = 3; /* start watchdog timer */\n\t}\n}",
    "includes": [
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/pcmcia/if_cnwreg.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void cnw_start",
      "void cnw_transmit",
      "struct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cnw_transmit",
          "args": [
            "sc",
            "m0"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "cnw_transmit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_cnw.c",
          "lines": "497-549",
          "snippet": "void\ncnw_transmit(sc, m0)\n\tstruct cnw_softc *sc;\n\tstruct mbuf *m0;\n{\n\tint buffer, bufsize, bufoffset, bufptr, bufspace, len, mbytes, n;\n\tstruct mbuf *m;\n\tu_int8_t *mptr;\n\n\t/* Get buffer info from card */\n\tbuffer = read16(sc, CNW_EREG_TDP);\n\tbufsize = read16(sc, CNW_EREG_TDP + 2);\n\tbufoffset = read16(sc, CNW_EREG_TDP + 4);\n#ifdef CNW_DEBUG\n\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\tprintf(\"%s: cnw_transmit b=0x%x s=%d o=0x%x\\n\",\n\t\t       sc->sc_dev.dv_xname, buffer, bufsize, bufoffset);\n#endif\n\n\t/* Copy data from mbuf chain to card buffers */\n\tbufptr = sc->sc_memoff + buffer + bufoffset;\n\tbufspace = bufsize;\n\tlen = 0;\n\tfor (m = m0; m; ) {\n\t\tmptr = mtod(m, u_int8_t *);\n\t\tmbytes = m->m_len;\n\t\tlen += mbytes;\n\t\twhile (mbytes > 0) {\n\t\t\tif (bufspace == 0) {\n\t\t\t\tbuffer = read16(sc, buffer);\n\t\t\t\tbufptr = sc->sc_memoff + buffer + bufoffset;\n\t\t\t\tbufspace = bufsize;\n#ifdef CNW_DEBUG\n\t\t\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\t\t\tprintf(\"%s:   next buffer @0x%x\\n\",\n\t\t\t\t\t       sc->sc_dev.dv_xname, buffer);\n#endif\n\t\t\t}\n\t\t\tn = mbytes <= bufspace ? mbytes : bufspace;\n\t\t\tbus_space_write_region_1(sc->sc_memt, sc->sc_memh,\n\t\t\t\t\t\t bufptr, mptr, n);\n\t\t\tbufptr += n;\n\t\t\tbufspace -= n;\n\t\t\tmptr += n;\n\t\t\tmbytes -= n;\n\t\t}\n\t\tMFREE(m, m0);\n\t\tm = m0;\n\t}\n\n\t/* Issue transmit command */\n\tCNW_CMD2(sc, CNW_CMD_TL, len, len >> 8);\n}",
          "includes": [
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/pcmcia/if_cnwreg.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/socket.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void cnw_transmit",
            "static int read16",
            "struct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/if_cnwreg.h>\n#include <sys/ioctl.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid cnw_transmit;\nstatic int read16;\nstruct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;\n\nvoid\ncnw_transmit(sc, m0)\n\tstruct cnw_softc *sc;\n\tstruct mbuf *m0;\n{\n\tint buffer, bufsize, bufoffset, bufptr, bufspace, len, mbytes, n;\n\tstruct mbuf *m;\n\tu_int8_t *mptr;\n\n\t/* Get buffer info from card */\n\tbuffer = read16(sc, CNW_EREG_TDP);\n\tbufsize = read16(sc, CNW_EREG_TDP + 2);\n\tbufoffset = read16(sc, CNW_EREG_TDP + 4);\n#ifdef CNW_DEBUG\n\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\tprintf(\"%s: cnw_transmit b=0x%x s=%d o=0x%x\\n\",\n\t\t       sc->sc_dev.dv_xname, buffer, bufsize, bufoffset);\n#endif\n\n\t/* Copy data from mbuf chain to card buffers */\n\tbufptr = sc->sc_memoff + buffer + bufoffset;\n\tbufspace = bufsize;\n\tlen = 0;\n\tfor (m = m0; m; ) {\n\t\tmptr = mtod(m, u_int8_t *);\n\t\tmbytes = m->m_len;\n\t\tlen += mbytes;\n\t\twhile (mbytes > 0) {\n\t\t\tif (bufspace == 0) {\n\t\t\t\tbuffer = read16(sc, buffer);\n\t\t\t\tbufptr = sc->sc_memoff + buffer + bufoffset;\n\t\t\t\tbufspace = bufsize;\n#ifdef CNW_DEBUG\n\t\t\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\t\t\tprintf(\"%s:   next buffer @0x%x\\n\",\n\t\t\t\t\t       sc->sc_dev.dv_xname, buffer);\n#endif\n\t\t\t}\n\t\t\tn = mbytes <= bufspace ? mbytes : bufspace;\n\t\t\tbus_space_write_region_1(sc->sc_memt, sc->sc_memh,\n\t\t\t\t\t\t bufptr, mptr, n);\n\t\t\tbufptr += n;\n\t\t\tbufspace -= n;\n\t\t\tmptr += n;\n\t\t\tmbytes -= n;\n\t\t}\n\t\tMFREE(m, m0);\n\t\tm = m0;\n\t}\n\n\t/* Issue transmit command */\n\tCNW_CMD2(sc, CNW_CMD_TL, len, len >> 8);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "m0"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "m0"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: no buffer space\\n\"",
            "ifp->if_xname"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "sc->sc_iot",
            "sc->sc_ioh",
            "CNW_REG_ASR"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WAIT_WOC",
          "args": [
            "sc"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/if_cnwreg.h>\n#include <sys/ioctl.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid cnw_start;\nvoid cnw_transmit;\nstruct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;\n\nvoid\ncnw_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct cnw_softc *sc = ifp->if_softc;\n\tstruct mbuf *m0;\n\tint asr;\n\n#ifdef CNW_DEBUG\n\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\tprintf(\"%s: cnw_start\\n\", ifp->if_xname);\n#endif\n\n\tfor (;;) {\n\t\t/* Is there any buffer space available on the card? */\n\t\tWAIT_WOC(sc);\n\t\tasr = bus_space_read_1(sc->sc_iot, sc->sc_ioh, CNW_REG_ASR);\n\t\tif (!(asr & CNW_ASR_TXBA)) {\n#ifdef CNW_DEBUG\n\t\t\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\t\t\tprintf(\"%s: no buffer space\\n\", ifp->if_xname);\n#endif\n\t\t\treturn;\n\t\t}\n\n\t\tIF_DEQUEUE(&ifp->if_snd, m0);\n\t\tif (m0 == 0)\n\t\t\treturn;\n\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\t\t\n\t\tcnw_transmit(sc, m0);\n\t\t++ifp->if_opackets;\n\t\tifp->if_timer = 3; /* start watchdog timer */\n\t}\n}"
  },
  {
    "function_name": "cnw_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_cnw.c",
    "lines": "374-448",
    "snippet": "void\ncnw_attach(parent, self, aux)\n\tstruct device  *parent, *self;\n\tvoid           *aux;\n{\n\tstruct cnw_softc *sc = (void *) self;\n\tstruct pcmcia_attach_args *pa = aux;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint i;\n\n\t/* Enable the card */\n\tsc->sc_pf = pa->pf;\n\tpcmcia_function_init(sc->sc_pf, sc->sc_pf->cfe_head.sqh_first);\n\tif (pcmcia_function_enable(sc->sc_pf)) {\n\t\tprintf(\": function enable failed\\n\");\n\t\treturn;\n\t}\n\n\t/* Map I/O register and \"memory\" */\n\tif (pcmcia_io_alloc(sc->sc_pf, 0, CNW_IO_SIZE, CNW_IO_SIZE,\n\t\t\t    &sc->sc_pcioh) != 0) {\n\t\tprintf(\": can't allocate i/o space\\n\");\n\t\treturn;\n\t}\n\tif (pcmcia_io_map(sc->sc_pf, PCMCIA_WIDTH_IO16, 0,\n\t\t\t  CNW_IO_SIZE, &sc->sc_pcioh, &sc->sc_iowin) != 0) {\n\t\tprintf(\": can't map i/o space\\n\");\n\t\treturn;\n\t}\n\tsc->sc_iot = sc->sc_pcioh.iot;\n\tsc->sc_ioh = sc->sc_pcioh.ioh;\n\tif (pcmcia_mem_alloc(sc->sc_pf, CNW_MEM_SIZE, &sc->sc_pcmemh) != 0) {\n\t\tprintf(\": can't allocate memory\\n\");\n\t\treturn;\n\t}\n\tif (pcmcia_mem_map(sc->sc_pf, PCMCIA_MEM_COMMON, CNW_MEM_ADDR,\n\t\t\t   CNW_MEM_SIZE, &sc->sc_pcmemh, &sc->sc_memoff,\n\t\t\t   &sc->sc_memwin) != 0) {\n\t\tprintf(\": can't map memory\\n\");\n\t\treturn;\n\t}\n\tsc->sc_memt = sc->sc_pcmemh.memt;\n\tsc->sc_memh = sc->sc_pcmemh.memh;\n\n\t/* Finish setup of softc */\n\tsc->sc_domain = cnw_domain;\n\tsc->sc_skey = cnw_skey;\n\n\t/* Get MAC address */\n\tcnw_reset(sc);\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\tsc->sc_arpcom.ac_enaddr[i] = bus_space_read_1(sc->sc_memt,\n\t\t    sc->sc_memh, sc->sc_memoff + CNW_EREG_PA + i);\n\tprintf(\"%s: address %s\\n\", sc->sc_dev.dv_xname,\n\t       ether_sprintf(sc->sc_arpcom.ac_enaddr));\n\n\t/* Set up ifnet structure */\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_start = cnw_start;\n\tifp->if_ioctl = cnw_ioctl;\n\tifp->if_watchdog = cnw_watchdog;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS;\n\n\t/* Attach the interface */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n#if NBPFILTER > 0\n\tbpfattach(&sc->sc_arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,\n\t\t  sizeof(struct ether_header));\n#endif\n\n\t/* Disable the card now, and turn it on when the interface goes up */\n\tpcmcia_function_disable(sc->sc_pf);\n}",
    "includes": [
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/pcmcia/if_cnwreg.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int cnw_domain = CNW_DOMAIN;",
      "int cnw_skey = CNW_SCRAMBLEKEY;",
      "void\tcnw_attach",
      "void cnw_reset",
      "void cnw_start",
      "int cnw_ioctl",
      "void cnw_watchdog",
      "struct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcmcia_function_disable",
          "args": [
            "sc->sc_pf"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_function_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "570-622",
          "snippet": "void\npcmcia_function_disable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\tif ((pf->pf_flags & PFF_ENABLED) == 0) {\n\t\t/*\n\t\t * Don't do anything if we're already disabled.\n\t\t */\n\t\treturn;\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE) {\n\t\tpf->pf_flags &= ~PFF_ENABLED;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * it's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.  Note we mark us as disabled\n\t * first to avoid matching ourself.\n\t */\n\tpf->pf_flags &= ~PFF_ENABLED;\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t(tmp->ccr_base - tmp->pf_ccr_offset + tmp->pf_ccr_realsize)))\n\t\t\tbreak;\n\t}\n\n\t/* Not used by anyone else; unmap the CCR. */\n\tif (tmp == NULL) {\n\t\tpcmcia_mem_unmap(pf, pf->pf_ccr_window);\n\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t}\n\n done:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nvoid\npcmcia_function_disable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\tif ((pf->pf_flags & PFF_ENABLED) == 0) {\n\t\t/*\n\t\t * Don't do anything if we're already disabled.\n\t\t */\n\t\treturn;\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE) {\n\t\tpf->pf_flags &= ~PFF_ENABLED;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * it's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.  Note we mark us as disabled\n\t * first to avoid matching ourself.\n\t */\n\tpf->pf_flags &= ~PFF_ENABLED;\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t(tmp->ccr_base - tmp->pf_ccr_offset + tmp->pf_ccr_realsize)))\n\t\t\tbreak;\n\t}\n\n\t/* Not used by anyone else; unmap the CCR. */\n\tif (tmp == NULL) {\n\t\tpcmcia_mem_unmap(pf, pf->pf_ccr_window);\n\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t}\n\n done:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpfattach",
          "args": [
            "&sc->sc_arpcom.ac_if.if_bpf",
            "ifp",
            "DLT_EN10MB",
            "sizeof(struct ether_header)"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ifattach",
          "args": [
            "ifp"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_attach",
          "args": [
            "ifp"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "sc->sc_dev.dv_xname",
            "ifp->if_xname",
            "IFNAMSIZ"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: address %s\\n\"",
            "sc->sc_dev.dv_xname",
            "ether_sprintf(sc->sc_arpcom.ac_enaddr)"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_sprintf",
          "args": [
            "sc->sc_arpcom.ac_enaddr"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "sc->sc_memt",
            "sc->sc_memh",
            "sc->sc_memoff + CNW_EREG_PA + i"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cnw_reset",
          "args": [
            "sc"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "cnw_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_cnw.c",
          "lines": "254-267",
          "snippet": "void\ncnw_reset(sc)\n\tstruct cnw_softc *sc;\n{\n#ifdef CNW_DEBUG\n\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\tprintf(\"%s: resetting\\n\", sc->sc_dev.dv_xname);\n#endif\n\twait_WOC(sc, 0);\n\tbus_space_write_1(sc->sc_iot, sc->sc_ioh, CNW_REG_PMR, CNW_PMR_RESET);\n\tbus_space_write_1(sc->sc_memt, sc->sc_memh,\n\t\t\t  sc->sc_memoff + CNW_EREG_ASCC, CNW_ASR_WOC);\n\tbus_space_write_1(sc->sc_iot, sc->sc_ioh, CNW_REG_PMR, 0);\n}",
          "includes": [
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/pcmcia/if_cnwreg.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/socket.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void cnw_reset",
            "static int wait_WOC",
            "struct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/if_cnwreg.h>\n#include <sys/ioctl.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid cnw_reset;\nstatic int wait_WOC;\nstruct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;\n\nvoid\ncnw_reset(sc)\n\tstruct cnw_softc *sc;\n{\n#ifdef CNW_DEBUG\n\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\tprintf(\"%s: resetting\\n\", sc->sc_dev.dv_xname);\n#endif\n\twait_WOC(sc, 0);\n\tbus_space_write_1(sc->sc_iot, sc->sc_ioh, CNW_REG_PMR, CNW_PMR_RESET);\n\tbus_space_write_1(sc->sc_memt, sc->sc_memh,\n\t\t\t  sc->sc_memoff + CNW_EREG_ASCC, CNW_ASR_WOC);\n\tbus_space_write_1(sc->sc_iot, sc->sc_ioh, CNW_REG_PMR, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_mem_map",
          "args": [
            "sc->sc_pf",
            "PCMCIA_MEM_COMMON",
            "CNW_MEM_ADDR",
            "CNW_MEM_SIZE",
            "&sc->sc_pcmemh",
            "&sc->sc_memoff",
            "&sc->sc_memwin"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_mem_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "2509-2575",
          "snippet": "STATIC int\npccbb_pcmcia_mem_map(pch, kind, card_addr, size, pcmhp, offsetp, windowp)\n\tpcmcia_chipset_handle_t pch;\n\tint kind;\n\tbus_addr_t card_addr;\n\tbus_size_t size;\n\tstruct pcmcia_mem_handle *pcmhp;\n\tbus_addr_t *offsetp;\n\tint *windowp;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tbus_addr_t busaddr;\n\tlong card_offset;\n\tint win;\n\n\tfor (win = 0; win < PCIC_MEM_WINS; ++win) {\n\t\tif ((ph->memalloc & (1 << win)) == 0) {\n\t\t\tph->memalloc |= (1 << win);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (win == PCIC_MEM_WINS) {\n\t\treturn 1;\n\t}\n\n\t*windowp = win;\n\n\t/* XXX this is pretty gross */\n\n\tif (((struct pccbb_softc *)ph->ph_parent)->sc_memt != pcmhp->memt) {\n\t\tpanic(\"pccbb_pcmcia_mem_map memt is bogus\");\n\t}\n\n\tbusaddr = pcmhp->addr;\n\n\t/* \n\t * compute the address offset to the pcmcia address space for the\n\t * pcic.  this is intentionally signed.  The masks and shifts below\n\t * will cause TRT to happen in the pcic registers.  Deal with making\n\t * sure the address is aligned, and return the alignment offset.\n\t */\n\n\t*offsetp = card_addr % PCIC_MEM_PAGESIZE;\n\tcard_addr -= *offsetp;\n\n\tDPRINTF((\"pccbb_pcmcia_mem_map window %d bus %lx+%lx+%lx at card addr \"\n\t    \"%lx\\n\", win, (u_long) busaddr, (u_long) * offsetp, (u_long) size,\n\t    (u_long) card_addr));\n\n\t/* \n\t * include the offset in the size, and decrement size by one, since\n\t * the hw wants start/stop\n\t */\n\tsize += *offsetp - 1;\n\n\tcard_offset = (((long)card_addr) - ((long)busaddr));\n\n\tph->mem[win].addr = busaddr;\n\tph->mem[win].size = size;\n\tph->mem[win].offset = card_offset;\n\tph->mem[win].kind = kind;\n\n\tpccbb_pcmcia_do_mem_map(ph, win);\n\n\treturn 0;\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define STATIC static",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "cb_reset __P((struct pccbb_softc *));",
            "STATIC int",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "pccbb_pcmcia_mem_alloc __P((pcmcia_chipset_handle_t, bus_size_t,\n    struct pcmcia_mem_handle *));",
            "STATIC void",
            "pccbb_pcmcia_mem_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_mem_handle *));",
            "STATIC int",
            "pccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));",
            "STATIC void",
            "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC void",
            "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
            "STATIC void",
            "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
            "STATIC void",
            "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
            "STATIC int",
            "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
            "static void pccbb_pcmcia_do_mem_map",
            "struct pcic_handle *ph = poll->ph;",
            "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\ncb_reset __P((struct pccbb_softc *));\nSTATIC int;\ncb_detect_voltage __P((struct pccbb_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\npccbb_pcmcia_mem_alloc __P((pcmcia_chipset_handle_t, bus_size_t,\n    struct pcmcia_mem_handle *));\nSTATIC void;\npccbb_pcmcia_mem_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_mem_handle *));\nSTATIC int;\npccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstatic void pccbb_pcmcia_do_mem_map;\nstruct pcic_handle *ph = poll->ph;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC int\npccbb_pcmcia_mem_map(pch, kind, card_addr, size, pcmhp, offsetp, windowp)\n\tpcmcia_chipset_handle_t pch;\n\tint kind;\n\tbus_addr_t card_addr;\n\tbus_size_t size;\n\tstruct pcmcia_mem_handle *pcmhp;\n\tbus_addr_t *offsetp;\n\tint *windowp;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tbus_addr_t busaddr;\n\tlong card_offset;\n\tint win;\n\n\tfor (win = 0; win < PCIC_MEM_WINS; ++win) {\n\t\tif ((ph->memalloc & (1 << win)) == 0) {\n\t\t\tph->memalloc |= (1 << win);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (win == PCIC_MEM_WINS) {\n\t\treturn 1;\n\t}\n\n\t*windowp = win;\n\n\t/* XXX this is pretty gross */\n\n\tif (((struct pccbb_softc *)ph->ph_parent)->sc_memt != pcmhp->memt) {\n\t\tpanic(\"pccbb_pcmcia_mem_map memt is bogus\");\n\t}\n\n\tbusaddr = pcmhp->addr;\n\n\t/* \n\t * compute the address offset to the pcmcia address space for the\n\t * pcic.  this is intentionally signed.  The masks and shifts below\n\t * will cause TRT to happen in the pcic registers.  Deal with making\n\t * sure the address is aligned, and return the alignment offset.\n\t */\n\n\t*offsetp = card_addr % PCIC_MEM_PAGESIZE;\n\tcard_addr -= *offsetp;\n\n\tDPRINTF((\"pccbb_pcmcia_mem_map window %d bus %lx+%lx+%lx at card addr \"\n\t    \"%lx\\n\", win, (u_long) busaddr, (u_long) * offsetp, (u_long) size,\n\t    (u_long) card_addr));\n\n\t/* \n\t * include the offset in the size, and decrement size by one, since\n\t * the hw wants start/stop\n\t */\n\tsize += *offsetp - 1;\n\n\tcard_offset = (((long)card_addr) - ((long)busaddr));\n\n\tph->mem[win].addr = busaddr;\n\tph->mem[win].size = size;\n\tph->mem[win].offset = card_offset;\n\tph->mem[win].kind = kind;\n\n\tpccbb_pcmcia_do_mem_map(ph, win);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_mem_alloc",
          "args": [
            "sc->sc_pf",
            "CNW_MEM_SIZE",
            "&sc->sc_pcmemh"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_mem_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "2307-2373",
          "snippet": "STATIC int\npccbb_pcmcia_mem_alloc(pch, size, pcmhp)\n\tpcmcia_chipset_handle_t pch;\n\tbus_size_t size;\n\tstruct pcmcia_mem_handle *pcmhp;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tbus_space_handle_t memh;\n\tbus_addr_t addr;\n\tbus_size_t sizepg;\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ph->ph_parent;\n#if rbus\n\trbus_tag_t rb;\n#endif\n\n\t/* out of sc->memh, allocate as many pages as necessary */\n\n\t/* convert size to PCIC pages */\n\t/* \n\t * This is not enough; when the requested region is on the page\n\t * boundaries, this may calculate wrong result.\n\t */\n\tsizepg = (size + (PCIC_MEM_PAGESIZE - 1)) / PCIC_MEM_PAGESIZE;\n#if 0\n\tif (sizepg > PCIC_MAX_MEM_PAGES) {\n\t\treturn 1;\n\t}\n#endif\n\n\tif (!(sc->sc_pcmcia_flags & PCCBB_PCMCIA_MEM_32)) {\n\t\treturn 1;\n\t}\n\n\taddr = 0;\t\t       /* XXX gcc -Wuninitialized */\n\n#if rbus\n\trb = sc->sc_rbus_memt;\n\tif (rbus_space_alloc(rb, 0, sizepg * PCIC_MEM_PAGESIZE,\n\t    sizepg * PCIC_MEM_PAGESIZE - 1, PCIC_MEM_PAGESIZE, 0,\n\t    &addr, &memh)) {\n\t\treturn 1;\n\t}\n#else\n\tif (bus_space_alloc(sc->sc_memt, sc->sc_mem_start, sc->sc_mem_end,\n\t    sizepg * PCIC_MEM_PAGESIZE, PCIC_MEM_PAGESIZE,\n\t    0, /* boundary */\n\t    0,\t/* flags */\n\t    &addr, &memh)) {\n\t\treturn 1;\n\t}\n#endif\n\n\tDPRINTF(\n\t    (\"pccbb_pcmcia_alloc_mem: addr 0x%lx size 0x%lx, realsize 0x%lx\\n\",\n\t    addr, size, sizepg * PCIC_MEM_PAGESIZE));\n\n\tpcmhp->memt = sc->sc_memt;\n\tpcmhp->memh = memh;\n\tpcmhp->addr = addr;\n\tpcmhp->size = size;\n\tpcmhp->realsize = sizepg * PCIC_MEM_PAGESIZE;\n\t/* What is mhandle?  I feel it is very dirty and it must go trush. */\n\tpcmhp->mhandle = 0;\n\t/* No offset???  Funny. */\n\n\treturn 0;\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define STATIC static",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "cb_reset __P((struct pccbb_softc *));",
            "STATIC int",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "pccbb_pcmcia_mem_alloc __P((pcmcia_chipset_handle_t, bus_size_t,\n    struct pcmcia_mem_handle *));",
            "STATIC void",
            "pccbb_pcmcia_mem_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_mem_handle *));",
            "STATIC int",
            "pccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));",
            "STATIC void",
            "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC void",
            "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
            "STATIC void",
            "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
            "STATIC void",
            "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
            "STATIC int",
            "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "struct pcic_handle *ph = poll->ph;",
            "struct pccbb_softc *sc = ph->sc;",
            "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\ncb_reset __P((struct pccbb_softc *));\nSTATIC int;\ncb_detect_voltage __P((struct pccbb_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\npccbb_pcmcia_mem_alloc __P((pcmcia_chipset_handle_t, bus_size_t,\n    struct pcmcia_mem_handle *));\nSTATIC void;\npccbb_pcmcia_mem_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_mem_handle *));\nSTATIC int;\npccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pcic_handle *ph = poll->ph;\nstruct pccbb_softc *sc = ph->sc;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC int\npccbb_pcmcia_mem_alloc(pch, size, pcmhp)\n\tpcmcia_chipset_handle_t pch;\n\tbus_size_t size;\n\tstruct pcmcia_mem_handle *pcmhp;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tbus_space_handle_t memh;\n\tbus_addr_t addr;\n\tbus_size_t sizepg;\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ph->ph_parent;\n#if rbus\n\trbus_tag_t rb;\n#endif\n\n\t/* out of sc->memh, allocate as many pages as necessary */\n\n\t/* convert size to PCIC pages */\n\t/* \n\t * This is not enough; when the requested region is on the page\n\t * boundaries, this may calculate wrong result.\n\t */\n\tsizepg = (size + (PCIC_MEM_PAGESIZE - 1)) / PCIC_MEM_PAGESIZE;\n#if 0\n\tif (sizepg > PCIC_MAX_MEM_PAGES) {\n\t\treturn 1;\n\t}\n#endif\n\n\tif (!(sc->sc_pcmcia_flags & PCCBB_PCMCIA_MEM_32)) {\n\t\treturn 1;\n\t}\n\n\taddr = 0;\t\t       /* XXX gcc -Wuninitialized */\n\n#if rbus\n\trb = sc->sc_rbus_memt;\n\tif (rbus_space_alloc(rb, 0, sizepg * PCIC_MEM_PAGESIZE,\n\t    sizepg * PCIC_MEM_PAGESIZE - 1, PCIC_MEM_PAGESIZE, 0,\n\t    &addr, &memh)) {\n\t\treturn 1;\n\t}\n#else\n\tif (bus_space_alloc(sc->sc_memt, sc->sc_mem_start, sc->sc_mem_end,\n\t    sizepg * PCIC_MEM_PAGESIZE, PCIC_MEM_PAGESIZE,\n\t    0, /* boundary */\n\t    0,\t/* flags */\n\t    &addr, &memh)) {\n\t\treturn 1;\n\t}\n#endif\n\n\tDPRINTF(\n\t    (\"pccbb_pcmcia_alloc_mem: addr 0x%lx size 0x%lx, realsize 0x%lx\\n\",\n\t    addr, size, sizepg * PCIC_MEM_PAGESIZE));\n\n\tpcmhp->memt = sc->sc_memt;\n\tpcmhp->memh = memh;\n\tpcmhp->addr = addr;\n\tpcmhp->size = size;\n\tpcmhp->realsize = sizepg * PCIC_MEM_PAGESIZE;\n\t/* What is mhandle?  I feel it is very dirty and it must go trush. */\n\tpcmhp->mhandle = 0;\n\t/* No offset???  Funny. */\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_io_map",
          "args": [
            "sc->sc_pf",
            "PCMCIA_WIDTH_IO16",
            "0",
            "CNW_IO_SIZE",
            "&sc->sc_pcioh",
            "&sc->sc_iowin"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_io_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "624-679",
          "snippet": "int\npcmcia_io_map(pf, width, offset, size, pcihp, windowp)\n\tstruct pcmcia_function *pf;\n\tint width;\n\tbus_addr_t offset;\n\tbus_size_t size;\n\tstruct pcmcia_io_handle *pcihp;\n\tint *windowp;\n{\n\tint reg;\n\n\tif (pcmcia_chip_io_map(pf->sc->pct, pf->sc->pch,\n\t    width, offset, size, pcihp, windowp))\n\t\treturn (1);\n\n\t/*\n\t * XXX In the multifunction multi-iospace-per-function case, this\n\t * needs to cooperate with io_alloc to make sure that the spaces\n\t * don't overlap, and that the ccr's are set correctly.\n\t */\n\n\tif (pcmcia_mfc(pf->sc)) {\n\t\tlong tmp, iosize;\n\n\t\tif (pf->pf_mfc_iomax == 0) {\n\t\t\tpf->pf_mfc_iobase = pcihp->addr + offset;\n\t\t\tpf->pf_mfc_iomax = pf->pf_mfc_iobase + size;\n\t\t} else {\n\t\t\t/* This makes the assumption that nothing overlaps. */\n\t\t\tif (pf->pf_mfc_iobase > pcihp->addr + offset)\n\t\t\t\tpf->pf_mfc_iobase = pcihp->addr + offset;\n\t\t\tif (pf->pf_mfc_iomax < pcihp->addr + offset + size)\n\t\t\t\tpf->pf_mfc_iomax = pcihp->addr + offset + size;\n\t\t}\n\n\t\ttmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;\n\t\t/* round up to nearest (2^n)-1 */\n\t\tfor (iosize = 1; iosize >= tmp; iosize <<= 1)\n\t\t\t;\n\t\tiosize--;\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,\n\t\t\t\t pf->pf_mfc_iobase & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,\n\t\t\t\t (pf->pf_mfc_iobase >> 8) & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);\n\n\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);\n\t\treg |= PCMCIA_CCR_OPTION_ADDR_DECODE;\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nint\npcmcia_io_map(pf, width, offset, size, pcihp, windowp)\n\tstruct pcmcia_function *pf;\n\tint width;\n\tbus_addr_t offset;\n\tbus_size_t size;\n\tstruct pcmcia_io_handle *pcihp;\n\tint *windowp;\n{\n\tint reg;\n\n\tif (pcmcia_chip_io_map(pf->sc->pct, pf->sc->pch,\n\t    width, offset, size, pcihp, windowp))\n\t\treturn (1);\n\n\t/*\n\t * XXX In the multifunction multi-iospace-per-function case, this\n\t * needs to cooperate with io_alloc to make sure that the spaces\n\t * don't overlap, and that the ccr's are set correctly.\n\t */\n\n\tif (pcmcia_mfc(pf->sc)) {\n\t\tlong tmp, iosize;\n\n\t\tif (pf->pf_mfc_iomax == 0) {\n\t\t\tpf->pf_mfc_iobase = pcihp->addr + offset;\n\t\t\tpf->pf_mfc_iomax = pf->pf_mfc_iobase + size;\n\t\t} else {\n\t\t\t/* This makes the assumption that nothing overlaps. */\n\t\t\tif (pf->pf_mfc_iobase > pcihp->addr + offset)\n\t\t\t\tpf->pf_mfc_iobase = pcihp->addr + offset;\n\t\t\tif (pf->pf_mfc_iomax < pcihp->addr + offset + size)\n\t\t\t\tpf->pf_mfc_iomax = pcihp->addr + offset + size;\n\t\t}\n\n\t\ttmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;\n\t\t/* round up to nearest (2^n)-1 */\n\t\tfor (iosize = 1; iosize >= tmp; iosize <<= 1)\n\t\t\t;\n\t\tiosize--;\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,\n\t\t\t\t pf->pf_mfc_iobase & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,\n\t\t\t\t (pf->pf_mfc_iobase >> 8) & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);\n\n\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);\n\t\treg |= PCMCIA_CCR_OPTION_ADDR_DECODE;\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_io_alloc",
          "args": [
            "sc->sc_pf",
            "0",
            "CNW_IO_SIZE",
            "CNW_IO_SIZE",
            "&sc->sc_pcioh"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_io_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "1803-1863",
          "snippet": "STATIC int\npccbb_pcmcia_io_alloc(pch, start, size, align, pcihp)\n\tpcmcia_chipset_handle_t pch;\n\tbus_addr_t start;\t       /* start address */\n\tbus_size_t size;\n\tbus_size_t align;\n\tstruct pcmcia_io_handle *pcihp;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tbus_addr_t ioaddr;\n\tint flags = 0;\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n#if rbus\n\trbus_tag_t rb;\n#endif\n\tif (align == 0) {\n\t\talign = size;\t       /* XXX: funny??? */\n\t}\n\n\t/* \n\t * Allocate some arbitrary I/O space.\n\t */\n\n\tiot = ((struct pccbb_softc *)(ph->ph_parent))->sc_iot;\n\n#if rbus\n\trb = ((struct pccbb_softc *)(ph->ph_parent))->sc_rbus_iot;\n\t/* XXX: I assume all card decode lower 10 bits by its hardware */\n\tif (rbus_space_alloc(rb, start, size, 0x3ff, align, 0, &ioaddr, &ioh)) {\n\t\treturn 1;\n\t}\n#else\n\tif (start) {\n\t\tioaddr = start;\n\t\tif (bus_space_map(iot, start, size, 0, &ioh)) {\n\t\t\treturn 1;\n\t\t}\n\t\tDPRINTF((\"pccbb_pcmcia_io_alloc map port %lx+%lx\\n\",\n\t\t    (u_long) ioaddr, (u_long) size));\n\t} else {\n\t\tflags |= PCMCIA_IO_ALLOCATED;\n\t\tif (bus_space_alloc(iot, 0x700 /* ph->sc->sc_iobase */ ,\n\t\t    0x800,\t/* ph->sc->sc_iobase + ph->sc->sc_iosize */\n\t\t    size, align, 0, 0, &ioaddr, &ioh)) {\n\t\t\t/* No room be able to be get. */\n\t\t\treturn 1;\n\t\t}\n\t\tDPRINTF((\"pccbb_pcmmcia_io_alloc alloc port 0x%lx+0x%lx\\n\",\n\t\t    (u_long) ioaddr, (u_long) size));\n\t}\n#endif\n\n\tpcihp->iot = iot;\n\tpcihp->ioh = ioh;\n\tpcihp->addr = ioaddr;\n\tpcihp->size = size;\n\tpcihp->flags = flags;\n\n\treturn 0;\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define STATIC static",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "cb_reset __P((struct pccbb_softc *));",
            "STATIC int",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "pccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));",
            "STATIC void",
            "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC int",
            "pccbb_pcmcia_io_alloc __P((pcmcia_chipset_handle_t, bus_addr_t,\n    bus_size_t, bus_size_t, struct pcmcia_io_handle *));",
            "STATIC void",
            "pccbb_pcmcia_io_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_io_handle *));",
            "STATIC int",
            "pccbb_pcmcia_io_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_io_handle *, int *));",
            "STATIC void",
            "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC void",
            "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
            "STATIC void",
            "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
            "STATIC void",
            "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
            "STATIC int",
            "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "struct pcic_handle *ph = poll->ph;",
            "struct pccbb_softc *sc = ph->sc;",
            "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\ncb_reset __P((struct pccbb_softc *));\nSTATIC int;\ncb_detect_voltage __P((struct pccbb_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC int;\npccbb_pcmcia_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\npccbb_pcmcia_io_alloc __P((pcmcia_chipset_handle_t, bus_addr_t,\n    bus_size_t, bus_size_t, struct pcmcia_io_handle *));\nSTATIC void;\npccbb_pcmcia_io_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_io_handle *));\nSTATIC int;\npccbb_pcmcia_io_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,\n    bus_size_t, struct pcmcia_io_handle *, int *));\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pcic_handle *ph = poll->ph;\nstruct pccbb_softc *sc = ph->sc;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC int\npccbb_pcmcia_io_alloc(pch, start, size, align, pcihp)\n\tpcmcia_chipset_handle_t pch;\n\tbus_addr_t start;\t       /* start address */\n\tbus_size_t size;\n\tbus_size_t align;\n\tstruct pcmcia_io_handle *pcihp;\n{\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tbus_addr_t ioaddr;\n\tint flags = 0;\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n#if rbus\n\trbus_tag_t rb;\n#endif\n\tif (align == 0) {\n\t\talign = size;\t       /* XXX: funny??? */\n\t}\n\n\t/* \n\t * Allocate some arbitrary I/O space.\n\t */\n\n\tiot = ((struct pccbb_softc *)(ph->ph_parent))->sc_iot;\n\n#if rbus\n\trb = ((struct pccbb_softc *)(ph->ph_parent))->sc_rbus_iot;\n\t/* XXX: I assume all card decode lower 10 bits by its hardware */\n\tif (rbus_space_alloc(rb, start, size, 0x3ff, align, 0, &ioaddr, &ioh)) {\n\t\treturn 1;\n\t}\n#else\n\tif (start) {\n\t\tioaddr = start;\n\t\tif (bus_space_map(iot, start, size, 0, &ioh)) {\n\t\t\treturn 1;\n\t\t}\n\t\tDPRINTF((\"pccbb_pcmcia_io_alloc map port %lx+%lx\\n\",\n\t\t    (u_long) ioaddr, (u_long) size));\n\t} else {\n\t\tflags |= PCMCIA_IO_ALLOCATED;\n\t\tif (bus_space_alloc(iot, 0x700 /* ph->sc->sc_iobase */ ,\n\t\t    0x800,\t/* ph->sc->sc_iobase + ph->sc->sc_iosize */\n\t\t    size, align, 0, 0, &ioaddr, &ioh)) {\n\t\t\t/* No room be able to be get. */\n\t\t\treturn 1;\n\t\t}\n\t\tDPRINTF((\"pccbb_pcmmcia_io_alloc alloc port 0x%lx+0x%lx\\n\",\n\t\t    (u_long) ioaddr, (u_long) size));\n\t}\n#endif\n\n\tpcihp->iot = iot;\n\tpcihp->ioh = ioh;\n\tpcihp->addr = ioaddr;\n\tpcihp->size = size;\n\tpcihp->flags = flags;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_function_enable",
          "args": [
            "sc->sc_pf"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_function_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "419-567",
          "snippet": "int\npcmcia_function_enable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\tint reg;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\t/*\n\t * Increase the reference count on the socket, enabling power, if\n\t * necessary.\n\t */\n\tif (pf->sc->sc_enabled_count++ == 0)\n\t\tpcmcia_chip_socket_enable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: ++enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\tif (pf->pf_flags & PFF_ENABLED) {\n\t\t/*\n\t\t * Don't do anything if we're already enabled.\n\t\t */\n\t\tDPRINTF((\"%s: pcmcia_function_enable on enabled func\\n\"));\n\t\treturn (0);\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE)\n\t\tgoto done;\n\n\t/*\n\t * It's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.\n\t */\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t     (tmp->ccr_base - tmp->pf_ccr_offset +\n\t\t      tmp->pf_ccr_realsize))) {\n\t\t\tpf->pf_ccrt = tmp->pf_ccrt;\n\t\t\tpf->pf_ccrh = tmp->pf_ccrh;\n\t\t\tpf->pf_ccr_realsize = tmp->pf_ccr_realsize;\n\n\t\t\t/*\n\t\t\t * pf->pf_ccr_offset = (tmp->pf_ccr_offset -\n\t\t\t * tmp->ccr_base) + pf->ccr_base;\n\t\t\t */\n\t\t\tpf->pf_ccr_offset =\n\t\t\t    (tmp->pf_ccr_offset + pf->ccr_base) -\n\t\t\t    tmp->ccr_base;\n\t\t\tpf->pf_ccr_window = tmp->pf_ccr_window;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (tmp == NULL) {\n\t\tif (pcmcia_mem_alloc(pf, PCMCIA_CCR_SIZE, &pf->pf_pcmh))\n\t\t\tgoto bad;\n\n\t\tif (pcmcia_mem_map(pf, PCMCIA_MEM_ATTR, pf->ccr_base,\n\t\t    PCMCIA_CCR_SIZE, &pf->pf_pcmh, &pf->pf_ccr_offset,\n\t\t    &pf->pf_ccr_window)) {\n\t\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\treg = (pf->cfe->number & PCMCIA_CCR_OPTION_CFINDEX);\n\treg |= PCMCIA_CCR_OPTION_LEVIREQ;\n\tif (pcmcia_mfc(pf->sc)) {\n\t\treg |= (PCMCIA_CCR_OPTION_FUNC_ENABLE |\n\t\t\tPCMCIA_CCR_OPTION_ADDR_DECODE);\n\t\tif (pf->ih_fct)\n\t\t\treg |= PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\n\t}\n\t\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\treg = 0;\n\n\tif ((pf->cfe->flags & PCMCIA_CFE_IO16) == 0)\n\t\treg |= PCMCIA_CCR_STATUS_IOIS8;\n\tif (pf->cfe->flags & PCMCIA_CFE_AUDIO)\n\t\treg |= PCMCIA_CCR_STATUS_AUDIO;\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_STATUS, reg);\n\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_SOCKETCOPY, 0);\n\t\n\tif (pcmcia_mfc(pf->sc)) {\n\t\tlong tmp, iosize;\n\n\t\ttmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;\n\t\t/* round up to nearest (2^n)-1 */\n\t\tfor (iosize = 1; iosize < tmp; iosize <<= 1)\n\t\t\t;\n\t\tiosize--;\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,\n\t\t\t\t pf->pf_mfc_iobase & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,\n\t\t\t\t (pf->pf_mfc_iobase >> 8) & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);\n\t}\n\n#ifdef PCMCIADEBUG\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t     tmp = tmp->pf_list.sqe_next) {\n\t\tprintf(\"%s: function %d CCR at %d offset %lx: \"\n\t\t       \"%x %x %x %x, %x %x %x %x, %x\\n\",\n\t\t       tmp->sc->dev.dv_xname, tmp->number,\n\t\t       tmp->pf_ccr_window, tmp->pf_ccr_offset,\n\t\t       pcmcia_ccr_read(tmp, 0x00),\n\t\t       pcmcia_ccr_read(tmp, 0x02),\n\t\t       pcmcia_ccr_read(tmp, 0x04),\n\t\t       pcmcia_ccr_read(tmp, 0x06),\n\n\t\t       pcmcia_ccr_read(tmp, 0x0A),\n\t\t       pcmcia_ccr_read(tmp, 0x0C), \n\t\t       pcmcia_ccr_read(tmp, 0x0E),\n\t\t       pcmcia_ccr_read(tmp, 0x10),\n\n\t\t       pcmcia_ccr_read(tmp, 0x12));\n\t}\n#endif\n\n done:\n\tpf->pf_flags |= PFF_ENABLED;\n\tdelay(1000);\n\treturn (0);\n\n bad:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\treturn (1);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;",
            "int (*ih_fct)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\nint (*ih_fct);\n\nint\npcmcia_function_enable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\tint reg;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\t/*\n\t * Increase the reference count on the socket, enabling power, if\n\t * necessary.\n\t */\n\tif (pf->sc->sc_enabled_count++ == 0)\n\t\tpcmcia_chip_socket_enable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: ++enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\tif (pf->pf_flags & PFF_ENABLED) {\n\t\t/*\n\t\t * Don't do anything if we're already enabled.\n\t\t */\n\t\tDPRINTF((\"%s: pcmcia_function_enable on enabled func\\n\"));\n\t\treturn (0);\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE)\n\t\tgoto done;\n\n\t/*\n\t * It's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.\n\t */\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t     (tmp->ccr_base - tmp->pf_ccr_offset +\n\t\t      tmp->pf_ccr_realsize))) {\n\t\t\tpf->pf_ccrt = tmp->pf_ccrt;\n\t\t\tpf->pf_ccrh = tmp->pf_ccrh;\n\t\t\tpf->pf_ccr_realsize = tmp->pf_ccr_realsize;\n\n\t\t\t/*\n\t\t\t * pf->pf_ccr_offset = (tmp->pf_ccr_offset -\n\t\t\t * tmp->ccr_base) + pf->ccr_base;\n\t\t\t */\n\t\t\tpf->pf_ccr_offset =\n\t\t\t    (tmp->pf_ccr_offset + pf->ccr_base) -\n\t\t\t    tmp->ccr_base;\n\t\t\tpf->pf_ccr_window = tmp->pf_ccr_window;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (tmp == NULL) {\n\t\tif (pcmcia_mem_alloc(pf, PCMCIA_CCR_SIZE, &pf->pf_pcmh))\n\t\t\tgoto bad;\n\n\t\tif (pcmcia_mem_map(pf, PCMCIA_MEM_ATTR, pf->ccr_base,\n\t\t    PCMCIA_CCR_SIZE, &pf->pf_pcmh, &pf->pf_ccr_offset,\n\t\t    &pf->pf_ccr_window)) {\n\t\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\treg = (pf->cfe->number & PCMCIA_CCR_OPTION_CFINDEX);\n\treg |= PCMCIA_CCR_OPTION_LEVIREQ;\n\tif (pcmcia_mfc(pf->sc)) {\n\t\treg |= (PCMCIA_CCR_OPTION_FUNC_ENABLE |\n\t\t\tPCMCIA_CCR_OPTION_ADDR_DECODE);\n\t\tif (pf->ih_fct)\n\t\t\treg |= PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\n\t}\n\t\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\treg = 0;\n\n\tif ((pf->cfe->flags & PCMCIA_CFE_IO16) == 0)\n\t\treg |= PCMCIA_CCR_STATUS_IOIS8;\n\tif (pf->cfe->flags & PCMCIA_CFE_AUDIO)\n\t\treg |= PCMCIA_CCR_STATUS_AUDIO;\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_STATUS, reg);\n\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_SOCKETCOPY, 0);\n\t\n\tif (pcmcia_mfc(pf->sc)) {\n\t\tlong tmp, iosize;\n\n\t\ttmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;\n\t\t/* round up to nearest (2^n)-1 */\n\t\tfor (iosize = 1; iosize < tmp; iosize <<= 1)\n\t\t\t;\n\t\tiosize--;\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,\n\t\t\t\t pf->pf_mfc_iobase & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,\n\t\t\t\t (pf->pf_mfc_iobase >> 8) & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);\n\t}\n\n#ifdef PCMCIADEBUG\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t     tmp = tmp->pf_list.sqe_next) {\n\t\tprintf(\"%s: function %d CCR at %d offset %lx: \"\n\t\t       \"%x %x %x %x, %x %x %x %x, %x\\n\",\n\t\t       tmp->sc->dev.dv_xname, tmp->number,\n\t\t       tmp->pf_ccr_window, tmp->pf_ccr_offset,\n\t\t       pcmcia_ccr_read(tmp, 0x00),\n\t\t       pcmcia_ccr_read(tmp, 0x02),\n\t\t       pcmcia_ccr_read(tmp, 0x04),\n\t\t       pcmcia_ccr_read(tmp, 0x06),\n\n\t\t       pcmcia_ccr_read(tmp, 0x0A),\n\t\t       pcmcia_ccr_read(tmp, 0x0C), \n\t\t       pcmcia_ccr_read(tmp, 0x0E),\n\t\t       pcmcia_ccr_read(tmp, 0x10),\n\n\t\t       pcmcia_ccr_read(tmp, 0x12));\n\t}\n#endif\n\n done:\n\tpf->pf_flags |= PFF_ENABLED;\n\tdelay(1000);\n\treturn (0);\n\n bad:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_function_init",
          "args": [
            "sc->sc_pf",
            "sc->sc_pf->cfe_head.sqh_first"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_function_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "392-402",
          "snippet": "void\npcmcia_function_init(pf, cfe)\n\tstruct pcmcia_function *pf;\n\tstruct pcmcia_config_entry *cfe;\n{\n\tif (pf->pf_flags & PFF_ENABLED)\n\t\tpanic(\"pcmcia_function_init: function is enabled\");\n\n\t/* Remember which configuration entry we are using. */\n\tpf->cfe = cfe;\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nvoid\npcmcia_function_init(pf, cfe)\n\tstruct pcmcia_function *pf;\n\tstruct pcmcia_config_entry *cfe;\n{\n\tif (pf->pf_flags & PFF_ENABLED)\n\t\tpanic(\"pcmcia_function_init: function is enabled\");\n\n\t/* Remember which configuration entry we are using. */\n\tpf->cfe = cfe;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/if_cnwreg.h>\n#include <sys/ioctl.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint cnw_domain = CNW_DOMAIN;\nint cnw_skey = CNW_SCRAMBLEKEY;\nvoid\tcnw_attach;\nvoid cnw_reset;\nvoid cnw_start;\nint cnw_ioctl;\nvoid cnw_watchdog;\nstruct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;\n\nvoid\ncnw_attach(parent, self, aux)\n\tstruct device  *parent, *self;\n\tvoid           *aux;\n{\n\tstruct cnw_softc *sc = (void *) self;\n\tstruct pcmcia_attach_args *pa = aux;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint i;\n\n\t/* Enable the card */\n\tsc->sc_pf = pa->pf;\n\tpcmcia_function_init(sc->sc_pf, sc->sc_pf->cfe_head.sqh_first);\n\tif (pcmcia_function_enable(sc->sc_pf)) {\n\t\tprintf(\": function enable failed\\n\");\n\t\treturn;\n\t}\n\n\t/* Map I/O register and \"memory\" */\n\tif (pcmcia_io_alloc(sc->sc_pf, 0, CNW_IO_SIZE, CNW_IO_SIZE,\n\t\t\t    &sc->sc_pcioh) != 0) {\n\t\tprintf(\": can't allocate i/o space\\n\");\n\t\treturn;\n\t}\n\tif (pcmcia_io_map(sc->sc_pf, PCMCIA_WIDTH_IO16, 0,\n\t\t\t  CNW_IO_SIZE, &sc->sc_pcioh, &sc->sc_iowin) != 0) {\n\t\tprintf(\": can't map i/o space\\n\");\n\t\treturn;\n\t}\n\tsc->sc_iot = sc->sc_pcioh.iot;\n\tsc->sc_ioh = sc->sc_pcioh.ioh;\n\tif (pcmcia_mem_alloc(sc->sc_pf, CNW_MEM_SIZE, &sc->sc_pcmemh) != 0) {\n\t\tprintf(\": can't allocate memory\\n\");\n\t\treturn;\n\t}\n\tif (pcmcia_mem_map(sc->sc_pf, PCMCIA_MEM_COMMON, CNW_MEM_ADDR,\n\t\t\t   CNW_MEM_SIZE, &sc->sc_pcmemh, &sc->sc_memoff,\n\t\t\t   &sc->sc_memwin) != 0) {\n\t\tprintf(\": can't map memory\\n\");\n\t\treturn;\n\t}\n\tsc->sc_memt = sc->sc_pcmemh.memt;\n\tsc->sc_memh = sc->sc_pcmemh.memh;\n\n\t/* Finish setup of softc */\n\tsc->sc_domain = cnw_domain;\n\tsc->sc_skey = cnw_skey;\n\n\t/* Get MAC address */\n\tcnw_reset(sc);\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\tsc->sc_arpcom.ac_enaddr[i] = bus_space_read_1(sc->sc_memt,\n\t\t    sc->sc_memh, sc->sc_memoff + CNW_EREG_PA + i);\n\tprintf(\"%s: address %s\\n\", sc->sc_dev.dv_xname,\n\t       ether_sprintf(sc->sc_arpcom.ac_enaddr));\n\n\t/* Set up ifnet structure */\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_start = cnw_start;\n\tifp->if_ioctl = cnw_ioctl;\n\tifp->if_watchdog = cnw_watchdog;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS;\n\n\t/* Attach the interface */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n#if NBPFILTER > 0\n\tbpfattach(&sc->sc_arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,\n\t\t  sizeof(struct ether_header));\n#endif\n\n\t/* Disable the card now, and turn it on when the interface goes up */\n\tpcmcia_function_disable(sc->sc_pf);\n}"
  },
  {
    "function_name": "cnw_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_cnw.c",
    "lines": "354-368",
    "snippet": "int\ncnw_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct pcmcia_attach_args *pa = aux;\n\n\tif (pa->manufacturer == PCMCIA_VENDOR_XIRCOM &&\n\t    pa->product == PCMCIA_PRODUCT_XIRCOM_XIR_CNW_801)\n\t\treturn (1);\n\tif (pa->manufacturer == PCMCIA_VENDOR_XIRCOM &&\n\t    pa->product == PCMCIA_PRODUCT_XIRCOM_XIR_CNW_802)\n\t\treturn (1);\n\treturn (0);\n}",
    "includes": [
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/pcmcia/if_cnwreg.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tcnw_match"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/if_cnwreg.h>\n#include <sys/ioctl.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\tcnw_match;\n\nint\ncnw_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct pcmcia_attach_args *pa = aux;\n\n\tif (pa->manufacturer == PCMCIA_VENDOR_XIRCOM &&\n\t    pa->product == PCMCIA_PRODUCT_XIRCOM_XIR_CNW_801)\n\t\treturn (1);\n\tif (pa->manufacturer == PCMCIA_VENDOR_XIRCOM &&\n\t    pa->product == PCMCIA_PRODUCT_XIRCOM_XIR_CNW_802)\n\t\treturn (1);\n\treturn (0);\n}"
  },
  {
    "function_name": "cnw_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_cnw.c",
    "lines": "338-348",
    "snippet": "void\ncnw_disable(sc)\n\tstruct cnw_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\tpcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);\n\tpcmcia_function_disable(sc->sc_pf);\n\tifp->if_flags &= ~IFF_RUNNING;\n\tifp->if_timer = 0;\n}",
    "includes": [
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/pcmcia/if_cnwreg.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void cnw_disable",
      "struct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcmcia_function_disable",
          "args": [
            "sc->sc_pf"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_function_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "570-622",
          "snippet": "void\npcmcia_function_disable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\tif ((pf->pf_flags & PFF_ENABLED) == 0) {\n\t\t/*\n\t\t * Don't do anything if we're already disabled.\n\t\t */\n\t\treturn;\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE) {\n\t\tpf->pf_flags &= ~PFF_ENABLED;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * it's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.  Note we mark us as disabled\n\t * first to avoid matching ourself.\n\t */\n\tpf->pf_flags &= ~PFF_ENABLED;\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t(tmp->ccr_base - tmp->pf_ccr_offset + tmp->pf_ccr_realsize)))\n\t\t\tbreak;\n\t}\n\n\t/* Not used by anyone else; unmap the CCR. */\n\tif (tmp == NULL) {\n\t\tpcmcia_mem_unmap(pf, pf->pf_ccr_window);\n\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t}\n\n done:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\n\nvoid\npcmcia_function_disable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\tif ((pf->pf_flags & PFF_ENABLED) == 0) {\n\t\t/*\n\t\t * Don't do anything if we're already disabled.\n\t\t */\n\t\treturn;\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE) {\n\t\tpf->pf_flags &= ~PFF_ENABLED;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * it's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.  Note we mark us as disabled\n\t * first to avoid matching ourself.\n\t */\n\tpf->pf_flags &= ~PFF_ENABLED;\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t(tmp->ccr_base - tmp->pf_ccr_offset + tmp->pf_ccr_realsize)))\n\t\t\tbreak;\n\t}\n\n\t/* Not used by anyone else; unmap the CCR. */\n\tif (tmp == NULL) {\n\t\tpcmcia_mem_unmap(pf, pf->pf_ccr_window);\n\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t}\n\n done:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_intr_disestablish",
          "args": [
            "sc->sc_pf",
            "sc->sc_ih"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_intr_disestablish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "784-866",
          "snippet": "void\npcmcia_intr_disestablish(pf, ih)\n\tstruct pcmcia_function *pf;\n\tvoid *ih;\n{\n\tint s, reg, ihcnt, hiipl;\n\tstruct pcmcia_function *pf2;\n\n\t/* Behave differently if this is a multifunction card.  */\n\tif (pcmcia_mfc(pf->sc)) {\n\t\t/*\n\t\t * Mask all the ipl's which are already used by this card,\n\t\t * and find the highest ipl number (lowest priority).  Skip\n\t\t * the current function.\n\t\t */\n\t\tihcnt = 0;\n\t\tfor (pf2 = pf->sc->card.pf_head.sqh_first; pf2 != NULL;\n\t\t    pf2 = pf2->pf_list.sqe_next) {\n\t\t\tif (pf2 == pf)\n\t\t\t\tcontinue;\n\n\t\t\tif (pf2->ih_fct) {\n\t\t\t\tif (ihcnt == 0)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\telse if (pf2->ih_ipl > hiipl)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\tihcnt++;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the ih being removed is lower priority than the lowest\n\t\t * priority remaining interrupt, up the priority.\n\t\t */\n\n\t\t/*\n\t\t * ihcnt is the number of interrupt handlers *not* including\n\t\t * the one about to be removed.\n\t\t */\n\t\tif (ihcnt == 0) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"disestablishing last function, but card has no ih\");\n#endif\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\n\t\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);\n\t\t\treg &= ~PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\t\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tpf->sc->ih = NULL;\n\t\t} else if (pf->ih_ipl > hiipl) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"changing ih ipl, but card has no ih\");\n#endif\n\t\t\ts = spltty();\n\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\t\t\tpf->sc->ih = pcmcia_chip_intr_establish(pf->sc->pct,\n\t\t\t    pf->sc->pch, pf, hiipl, pcmcia_card_intr, pf->sc);\n\n\t\t\t/* Null out the handler for this function. */\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t} else {\n\t\t\ts = spltty();\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t}\n\t} else\n\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch, ih);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int pcmcia_card_intr",
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;",
            "int ipl;",
            "int (*ih_fct)",
            "void *ih_arg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint pcmcia_card_intr;\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\nint ipl;\nint (*ih_fct);\nvoid *ih_arg;\n\nvoid\npcmcia_intr_disestablish(pf, ih)\n\tstruct pcmcia_function *pf;\n\tvoid *ih;\n{\n\tint s, reg, ihcnt, hiipl;\n\tstruct pcmcia_function *pf2;\n\n\t/* Behave differently if this is a multifunction card.  */\n\tif (pcmcia_mfc(pf->sc)) {\n\t\t/*\n\t\t * Mask all the ipl's which are already used by this card,\n\t\t * and find the highest ipl number (lowest priority).  Skip\n\t\t * the current function.\n\t\t */\n\t\tihcnt = 0;\n\t\tfor (pf2 = pf->sc->card.pf_head.sqh_first; pf2 != NULL;\n\t\t    pf2 = pf2->pf_list.sqe_next) {\n\t\t\tif (pf2 == pf)\n\t\t\t\tcontinue;\n\n\t\t\tif (pf2->ih_fct) {\n\t\t\t\tif (ihcnt == 0)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\telse if (pf2->ih_ipl > hiipl)\n\t\t\t\t\thiipl = pf2->ih_ipl;\n\t\t\t\tihcnt++;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the ih being removed is lower priority than the lowest\n\t\t * priority remaining interrupt, up the priority.\n\t\t */\n\n\t\t/*\n\t\t * ihcnt is the number of interrupt handlers *not* including\n\t\t * the one about to be removed.\n\t\t */\n\t\tif (ihcnt == 0) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"disestablishing last function, but card has no ih\");\n#endif\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\n\t\t\treg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);\n\t\t\treg &= ~PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\t\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tpf->sc->ih = NULL;\n\t\t} else if (pf->ih_ipl > hiipl) {\n#ifdef DIAGNOSTIC\n\t\t\tif (pf->sc->ih == NULL)\n\t\t\t\tpanic(\"changing ih ipl, but card has no ih\");\n#endif\n\t\t\ts = spltty();\n\n\t\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,\n\t\t\t    pf->sc->ih);\n\t\t\tpf->sc->ih = pcmcia_chip_intr_establish(pf->sc->pct,\n\t\t\t    pf->sc->pch, pf, hiipl, pcmcia_card_intr, pf->sc);\n\n\t\t\t/* Null out the handler for this function. */\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t} else {\n\t\t\ts = spltty();\n\n\t\t\tpf->ih_fct = NULL;\n\t\t\tpf->ih_arg = NULL;\n\n\t\t\tsplx(s);\n\t\t}\n\t} else\n\t\tpcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch, ih);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/if_cnwreg.h>\n#include <sys/ioctl.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid cnw_disable;\nstruct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;\n\nvoid\ncnw_disable(sc)\n\tstruct cnw_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\tpcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);\n\tpcmcia_function_disable(sc->sc_pf);\n\tifp->if_flags &= ~IFF_RUNNING;\n\tifp->if_timer = 0;\n}"
  },
  {
    "function_name": "cnw_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_cnw.c",
    "lines": "313-332",
    "snippet": "int\ncnw_enable(sc)\n\tstruct cnw_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\tsc->sc_ih = pcmcia_intr_establish(sc->sc_pf, IPL_NET, cnw_intr, sc);\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\"%s: couldn't establish interrupt handler\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn (EIO);\n\t}\n\tif (pcmcia_function_enable(sc->sc_pf) != 0) {\n\t\tprintf(\"%s: couldn't enable card\\n\", sc->sc_dev.dv_xname);\n\t\treturn (EIO);\n\t}\n\tcnw_init(sc);\n\tifp->if_flags |= IFF_RUNNING;\n\treturn (0);\n}",
    "includes": [
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/pcmcia/if_cnwreg.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void cnw_init",
      "int cnw_enable",
      "int cnw_intr",
      "struct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cnw_init",
          "args": [
            "sc"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "cnw_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_cnw.c",
          "lines": "273-307",
          "snippet": "void\ncnw_init(sc)\n\tstruct cnw_softc *sc;\n{\n\t/* Reset the card */\n\tcnw_reset(sc);\n\n\t/* Issue a NOP to check the card */\n\tCNW_CMD0(sc, CNW_CMD_NOP);\n\n\t/* Set up receive configuration */\n\tCNW_CMD1(sc, CNW_CMD_SRC, CNW_RXCONF_RXENA | CNW_RXCONF_BCAST);\n\n\t/* Set up transmit configuration */\n\tCNW_CMD1(sc, CNW_CMD_STC, CNW_TXCONF_TXENA);\n\n\t/* Set domain */\n\tCNW_CMD2(sc, CNW_CMD_SMD, sc->sc_domain, sc->sc_domain >> 8);\n\n\t/* Set scramble key */\n\tCNW_CMD2(sc, CNW_CMD_SSK, sc->sc_skey, sc->sc_skey >> 8);\n\n\t/* Enable interrupts */\n\tWAIT_WOC(sc);\n\tbus_space_write_1(sc->sc_iot, sc->sc_ioh,\n\t\t\t  CNW_REG_IMR, CNW_IMR_IENA | CNW_IMR_RFU1);\n\n\t/* Enable receiver */\n\tCNW_CMD0(sc, CNW_CMD_ER);\n\n\t/* \"Set the IENA bit in COR\" */\n\tWAIT_WOC(sc);\n\tbus_space_write_1(sc->sc_iot, sc->sc_ioh, CNW_REG_COR,\n\t\t\t  CNW_COR_IENA | CNW_COR_LVLREQ);\n}",
          "includes": [
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/pcmcia/if_cnwreg.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/socket.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void cnw_reset",
            "void cnw_init",
            "struct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/if_cnwreg.h>\n#include <sys/ioctl.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid cnw_reset;\nvoid cnw_init;\nstruct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;\n\nvoid\ncnw_init(sc)\n\tstruct cnw_softc *sc;\n{\n\t/* Reset the card */\n\tcnw_reset(sc);\n\n\t/* Issue a NOP to check the card */\n\tCNW_CMD0(sc, CNW_CMD_NOP);\n\n\t/* Set up receive configuration */\n\tCNW_CMD1(sc, CNW_CMD_SRC, CNW_RXCONF_RXENA | CNW_RXCONF_BCAST);\n\n\t/* Set up transmit configuration */\n\tCNW_CMD1(sc, CNW_CMD_STC, CNW_TXCONF_TXENA);\n\n\t/* Set domain */\n\tCNW_CMD2(sc, CNW_CMD_SMD, sc->sc_domain, sc->sc_domain >> 8);\n\n\t/* Set scramble key */\n\tCNW_CMD2(sc, CNW_CMD_SSK, sc->sc_skey, sc->sc_skey >> 8);\n\n\t/* Enable interrupts */\n\tWAIT_WOC(sc);\n\tbus_space_write_1(sc->sc_iot, sc->sc_ioh,\n\t\t\t  CNW_REG_IMR, CNW_IMR_IENA | CNW_IMR_RFU1);\n\n\t/* Enable receiver */\n\tCNW_CMD0(sc, CNW_CMD_ER);\n\n\t/* \"Set the IENA bit in COR\" */\n\tWAIT_WOC(sc);\n\tbus_space_write_1(sc->sc_iot, sc->sc_ioh, CNW_REG_COR,\n\t\t\t  CNW_COR_IENA | CNW_COR_LVLREQ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: couldn't enable card\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_function_enable",
          "args": [
            "sc->sc_pf"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_function_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia.c",
          "lines": "419-567",
          "snippet": "int\npcmcia_function_enable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\tint reg;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\t/*\n\t * Increase the reference count on the socket, enabling power, if\n\t * necessary.\n\t */\n\tif (pf->sc->sc_enabled_count++ == 0)\n\t\tpcmcia_chip_socket_enable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: ++enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\tif (pf->pf_flags & PFF_ENABLED) {\n\t\t/*\n\t\t * Don't do anything if we're already enabled.\n\t\t */\n\t\tDPRINTF((\"%s: pcmcia_function_enable on enabled func\\n\"));\n\t\treturn (0);\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE)\n\t\tgoto done;\n\n\t/*\n\t * It's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.\n\t */\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t     (tmp->ccr_base - tmp->pf_ccr_offset +\n\t\t      tmp->pf_ccr_realsize))) {\n\t\t\tpf->pf_ccrt = tmp->pf_ccrt;\n\t\t\tpf->pf_ccrh = tmp->pf_ccrh;\n\t\t\tpf->pf_ccr_realsize = tmp->pf_ccr_realsize;\n\n\t\t\t/*\n\t\t\t * pf->pf_ccr_offset = (tmp->pf_ccr_offset -\n\t\t\t * tmp->ccr_base) + pf->ccr_base;\n\t\t\t */\n\t\t\tpf->pf_ccr_offset =\n\t\t\t    (tmp->pf_ccr_offset + pf->ccr_base) -\n\t\t\t    tmp->ccr_base;\n\t\t\tpf->pf_ccr_window = tmp->pf_ccr_window;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (tmp == NULL) {\n\t\tif (pcmcia_mem_alloc(pf, PCMCIA_CCR_SIZE, &pf->pf_pcmh))\n\t\t\tgoto bad;\n\n\t\tif (pcmcia_mem_map(pf, PCMCIA_MEM_ATTR, pf->ccr_base,\n\t\t    PCMCIA_CCR_SIZE, &pf->pf_pcmh, &pf->pf_ccr_offset,\n\t\t    &pf->pf_ccr_window)) {\n\t\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\treg = (pf->cfe->number & PCMCIA_CCR_OPTION_CFINDEX);\n\treg |= PCMCIA_CCR_OPTION_LEVIREQ;\n\tif (pcmcia_mfc(pf->sc)) {\n\t\treg |= (PCMCIA_CCR_OPTION_FUNC_ENABLE |\n\t\t\tPCMCIA_CCR_OPTION_ADDR_DECODE);\n\t\tif (pf->ih_fct)\n\t\t\treg |= PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\n\t}\n\t\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\treg = 0;\n\n\tif ((pf->cfe->flags & PCMCIA_CFE_IO16) == 0)\n\t\treg |= PCMCIA_CCR_STATUS_IOIS8;\n\tif (pf->cfe->flags & PCMCIA_CFE_AUDIO)\n\t\treg |= PCMCIA_CCR_STATUS_AUDIO;\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_STATUS, reg);\n\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_SOCKETCOPY, 0);\n\t\n\tif (pcmcia_mfc(pf->sc)) {\n\t\tlong tmp, iosize;\n\n\t\ttmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;\n\t\t/* round up to nearest (2^n)-1 */\n\t\tfor (iosize = 1; iosize < tmp; iosize <<= 1)\n\t\t\t;\n\t\tiosize--;\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,\n\t\t\t\t pf->pf_mfc_iobase & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,\n\t\t\t\t (pf->pf_mfc_iobase >> 8) & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);\n\t}\n\n#ifdef PCMCIADEBUG\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t     tmp = tmp->pf_list.sqe_next) {\n\t\tprintf(\"%s: function %d CCR at %d offset %lx: \"\n\t\t       \"%x %x %x %x, %x %x %x %x, %x\\n\",\n\t\t       tmp->sc->dev.dv_xname, tmp->number,\n\t\t       tmp->pf_ccr_window, tmp->pf_ccr_offset,\n\t\t       pcmcia_ccr_read(tmp, 0x00),\n\t\t       pcmcia_ccr_read(tmp, 0x02),\n\t\t       pcmcia_ccr_read(tmp, 0x04),\n\t\t       pcmcia_ccr_read(tmp, 0x06),\n\n\t\t       pcmcia_ccr_read(tmp, 0x0A),\n\t\t       pcmcia_ccr_read(tmp, 0x0C), \n\t\t       pcmcia_ccr_read(tmp, 0x0E),\n\t\t       pcmcia_ccr_read(tmp, 0x10),\n\n\t\t       pcmcia_ccr_read(tmp, 0x12));\n\t}\n#endif\n\n done:\n\tpf->pf_flags |= PFF_ENABLED;\n\tdelay(1000);\n\treturn (0);\n\n bad:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\treturn (1);\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;",
            "int (*ih_fct)"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid *\npcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)\n\tstruct pcmcia_function *pf;\nint (*ih_fct);\n\nint\npcmcia_function_enable(pf)\n\tstruct pcmcia_function *pf;\n{\n\tstruct pcmcia_function *tmp;\n\tint reg;\n\n\tif (pf->cfe == NULL)\n\t\tpanic(\"pcmcia_function_enable: function not initialized\");\n\n\t/*\n\t * Increase the reference count on the socket, enabling power, if\n\t * necessary.\n\t */\n\tif (pf->sc->sc_enabled_count++ == 0)\n\t\tpcmcia_chip_socket_enable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: ++enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\tif (pf->pf_flags & PFF_ENABLED) {\n\t\t/*\n\t\t * Don't do anything if we're already enabled.\n\t\t */\n\t\tDPRINTF((\"%s: pcmcia_function_enable on enabled func\\n\"));\n\t\treturn (0);\n\t}\n\n\t/* If there was no CIS don't mess with CCR */\n\tif (pf->pf_flags & PFF_FAKE)\n\t\tgoto done;\n\n\t/*\n\t * It's possible for different functions' CCRs to be in the same\n\t * underlying page.  Check for that.\n\t */\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t    tmp = tmp->pf_list.sqe_next) {\n\t\tif ((tmp->pf_flags & PFF_ENABLED) &&\n\t\t    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&\n\t\t    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=\n\t\t     (tmp->ccr_base - tmp->pf_ccr_offset +\n\t\t      tmp->pf_ccr_realsize))) {\n\t\t\tpf->pf_ccrt = tmp->pf_ccrt;\n\t\t\tpf->pf_ccrh = tmp->pf_ccrh;\n\t\t\tpf->pf_ccr_realsize = tmp->pf_ccr_realsize;\n\n\t\t\t/*\n\t\t\t * pf->pf_ccr_offset = (tmp->pf_ccr_offset -\n\t\t\t * tmp->ccr_base) + pf->ccr_base;\n\t\t\t */\n\t\t\tpf->pf_ccr_offset =\n\t\t\t    (tmp->pf_ccr_offset + pf->ccr_base) -\n\t\t\t    tmp->ccr_base;\n\t\t\tpf->pf_ccr_window = tmp->pf_ccr_window;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (tmp == NULL) {\n\t\tif (pcmcia_mem_alloc(pf, PCMCIA_CCR_SIZE, &pf->pf_pcmh))\n\t\t\tgoto bad;\n\n\t\tif (pcmcia_mem_map(pf, PCMCIA_MEM_ATTR, pf->ccr_base,\n\t\t    PCMCIA_CCR_SIZE, &pf->pf_pcmh, &pf->pf_ccr_offset,\n\t\t    &pf->pf_ccr_window)) {\n\t\t\tpcmcia_mem_free(pf, &pf->pf_pcmh);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\treg = (pf->cfe->number & PCMCIA_CCR_OPTION_CFINDEX);\n\treg |= PCMCIA_CCR_OPTION_LEVIREQ;\n\tif (pcmcia_mfc(pf->sc)) {\n\t\treg |= (PCMCIA_CCR_OPTION_FUNC_ENABLE |\n\t\t\tPCMCIA_CCR_OPTION_ADDR_DECODE);\n\t\tif (pf->ih_fct)\n\t\t\treg |= PCMCIA_CCR_OPTION_IREQ_ENABLE;\n\n\t}\n\t\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);\n\n\treg = 0;\n\n\tif ((pf->cfe->flags & PCMCIA_CFE_IO16) == 0)\n\t\treg |= PCMCIA_CCR_STATUS_IOIS8;\n\tif (pf->cfe->flags & PCMCIA_CFE_AUDIO)\n\t\treg |= PCMCIA_CCR_STATUS_AUDIO;\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_STATUS, reg);\n\n\tpcmcia_ccr_write(pf, PCMCIA_CCR_SOCKETCOPY, 0);\n\t\n\tif (pcmcia_mfc(pf->sc)) {\n\t\tlong tmp, iosize;\n\n\t\ttmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;\n\t\t/* round up to nearest (2^n)-1 */\n\t\tfor (iosize = 1; iosize < tmp; iosize <<= 1)\n\t\t\t;\n\t\tiosize--;\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,\n\t\t\t\t pf->pf_mfc_iobase & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,\n\t\t\t\t (pf->pf_mfc_iobase >> 8) & 0xff);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);\n\n\t\tpcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);\n\t}\n\n#ifdef PCMCIADEBUG\n\tfor (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;\n\t     tmp = tmp->pf_list.sqe_next) {\n\t\tprintf(\"%s: function %d CCR at %d offset %lx: \"\n\t\t       \"%x %x %x %x, %x %x %x %x, %x\\n\",\n\t\t       tmp->sc->dev.dv_xname, tmp->number,\n\t\t       tmp->pf_ccr_window, tmp->pf_ccr_offset,\n\t\t       pcmcia_ccr_read(tmp, 0x00),\n\t\t       pcmcia_ccr_read(tmp, 0x02),\n\t\t       pcmcia_ccr_read(tmp, 0x04),\n\t\t       pcmcia_ccr_read(tmp, 0x06),\n\n\t\t       pcmcia_ccr_read(tmp, 0x0A),\n\t\t       pcmcia_ccr_read(tmp, 0x0C), \n\t\t       pcmcia_ccr_read(tmp, 0x0E),\n\t\t       pcmcia_ccr_read(tmp, 0x10),\n\n\t\t       pcmcia_ccr_read(tmp, 0x12));\n\t}\n#endif\n\n done:\n\tpf->pf_flags |= PFF_ENABLED;\n\tdelay(1000);\n\treturn (0);\n\n bad:\n\t/*\n\t * Decrement the reference count, and power down the socket, if\n\t * necessary.\n\t */\n\tif (--pf->sc->sc_enabled_count == 0)\n\t\tpcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);\n\tDPRINTF((\"%s: --enabled_count = %d\\n\", pf->sc->dev.dv_xname,\n\t\t pf->sc->sc_enabled_count));\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_intr_establish",
          "args": [
            "sc->sc_pf",
            "IPL_NET",
            "cnw_intr",
            "sc"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/if_cnwreg.h>\n#include <sys/ioctl.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid cnw_init;\nint cnw_enable;\nint cnw_intr;\nstruct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;\n\nint\ncnw_enable(sc)\n\tstruct cnw_softc *sc;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\tsc->sc_ih = pcmcia_intr_establish(sc->sc_pf, IPL_NET, cnw_intr, sc);\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\"%s: couldn't establish interrupt handler\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn (EIO);\n\t}\n\tif (pcmcia_function_enable(sc->sc_pf) != 0) {\n\t\tprintf(\"%s: couldn't enable card\\n\", sc->sc_dev.dv_xname);\n\t\treturn (EIO);\n\t}\n\tcnw_init(sc);\n\tifp->if_flags |= IFF_RUNNING;\n\treturn (0);\n}"
  },
  {
    "function_name": "cnw_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_cnw.c",
    "lines": "273-307",
    "snippet": "void\ncnw_init(sc)\n\tstruct cnw_softc *sc;\n{\n\t/* Reset the card */\n\tcnw_reset(sc);\n\n\t/* Issue a NOP to check the card */\n\tCNW_CMD0(sc, CNW_CMD_NOP);\n\n\t/* Set up receive configuration */\n\tCNW_CMD1(sc, CNW_CMD_SRC, CNW_RXCONF_RXENA | CNW_RXCONF_BCAST);\n\n\t/* Set up transmit configuration */\n\tCNW_CMD1(sc, CNW_CMD_STC, CNW_TXCONF_TXENA);\n\n\t/* Set domain */\n\tCNW_CMD2(sc, CNW_CMD_SMD, sc->sc_domain, sc->sc_domain >> 8);\n\n\t/* Set scramble key */\n\tCNW_CMD2(sc, CNW_CMD_SSK, sc->sc_skey, sc->sc_skey >> 8);\n\n\t/* Enable interrupts */\n\tWAIT_WOC(sc);\n\tbus_space_write_1(sc->sc_iot, sc->sc_ioh,\n\t\t\t  CNW_REG_IMR, CNW_IMR_IENA | CNW_IMR_RFU1);\n\n\t/* Enable receiver */\n\tCNW_CMD0(sc, CNW_CMD_ER);\n\n\t/* \"Set the IENA bit in COR\" */\n\tWAIT_WOC(sc);\n\tbus_space_write_1(sc->sc_iot, sc->sc_ioh, CNW_REG_COR,\n\t\t\t  CNW_COR_IENA | CNW_COR_LVLREQ);\n}",
    "includes": [
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/pcmcia/if_cnwreg.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void cnw_reset",
      "void cnw_init",
      "struct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_iot",
            "sc->sc_ioh",
            "CNW_REG_COR",
            "CNW_COR_IENA | CNW_COR_LVLREQ"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WAIT_WOC",
          "args": [
            "sc"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CNW_CMD0",
          "args": [
            "sc",
            "CNW_CMD_ER"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_iot",
            "sc->sc_ioh",
            "CNW_REG_IMR",
            "CNW_IMR_IENA | CNW_IMR_RFU1"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WAIT_WOC",
          "args": [
            "sc"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CNW_CMD2",
          "args": [
            "sc",
            "CNW_CMD_SSK",
            "sc->sc_skey",
            "sc->sc_skey >> 8"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CNW_CMD2",
          "args": [
            "sc",
            "CNW_CMD_SMD",
            "sc->sc_domain",
            "sc->sc_domain >> 8"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CNW_CMD1",
          "args": [
            "sc",
            "CNW_CMD_STC",
            "CNW_TXCONF_TXENA"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CNW_CMD1",
          "args": [
            "sc",
            "CNW_CMD_SRC",
            "CNW_RXCONF_RXENA | CNW_RXCONF_BCAST"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CNW_CMD0",
          "args": [
            "sc",
            "CNW_CMD_NOP"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cnw_reset",
          "args": [
            "sc"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "cnw_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_cnw.c",
          "lines": "254-267",
          "snippet": "void\ncnw_reset(sc)\n\tstruct cnw_softc *sc;\n{\n#ifdef CNW_DEBUG\n\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\tprintf(\"%s: resetting\\n\", sc->sc_dev.dv_xname);\n#endif\n\twait_WOC(sc, 0);\n\tbus_space_write_1(sc->sc_iot, sc->sc_ioh, CNW_REG_PMR, CNW_PMR_RESET);\n\tbus_space_write_1(sc->sc_memt, sc->sc_memh,\n\t\t\t  sc->sc_memoff + CNW_EREG_ASCC, CNW_ASR_WOC);\n\tbus_space_write_1(sc->sc_iot, sc->sc_ioh, CNW_REG_PMR, 0);\n}",
          "includes": [
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/pcmcia/if_cnwreg.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/socket.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void cnw_reset",
            "static int wait_WOC",
            "struct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/if_cnwreg.h>\n#include <sys/ioctl.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid cnw_reset;\nstatic int wait_WOC;\nstruct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;\n\nvoid\ncnw_reset(sc)\n\tstruct cnw_softc *sc;\n{\n#ifdef CNW_DEBUG\n\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\tprintf(\"%s: resetting\\n\", sc->sc_dev.dv_xname);\n#endif\n\twait_WOC(sc, 0);\n\tbus_space_write_1(sc->sc_iot, sc->sc_ioh, CNW_REG_PMR, CNW_PMR_RESET);\n\tbus_space_write_1(sc->sc_memt, sc->sc_memh,\n\t\t\t  sc->sc_memoff + CNW_EREG_ASCC, CNW_ASR_WOC);\n\tbus_space_write_1(sc->sc_iot, sc->sc_ioh, CNW_REG_PMR, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/if_cnwreg.h>\n#include <sys/ioctl.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid cnw_reset;\nvoid cnw_init;\nstruct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;\n\nvoid\ncnw_init(sc)\n\tstruct cnw_softc *sc;\n{\n\t/* Reset the card */\n\tcnw_reset(sc);\n\n\t/* Issue a NOP to check the card */\n\tCNW_CMD0(sc, CNW_CMD_NOP);\n\n\t/* Set up receive configuration */\n\tCNW_CMD1(sc, CNW_CMD_SRC, CNW_RXCONF_RXENA | CNW_RXCONF_BCAST);\n\n\t/* Set up transmit configuration */\n\tCNW_CMD1(sc, CNW_CMD_STC, CNW_TXCONF_TXENA);\n\n\t/* Set domain */\n\tCNW_CMD2(sc, CNW_CMD_SMD, sc->sc_domain, sc->sc_domain >> 8);\n\n\t/* Set scramble key */\n\tCNW_CMD2(sc, CNW_CMD_SSK, sc->sc_skey, sc->sc_skey >> 8);\n\n\t/* Enable interrupts */\n\tWAIT_WOC(sc);\n\tbus_space_write_1(sc->sc_iot, sc->sc_ioh,\n\t\t\t  CNW_REG_IMR, CNW_IMR_IENA | CNW_IMR_RFU1);\n\n\t/* Enable receiver */\n\tCNW_CMD0(sc, CNW_CMD_ER);\n\n\t/* \"Set the IENA bit in COR\" */\n\tWAIT_WOC(sc);\n\tbus_space_write_1(sc->sc_iot, sc->sc_ioh, CNW_REG_COR,\n\t\t\t  CNW_COR_IENA | CNW_COR_LVLREQ);\n}"
  },
  {
    "function_name": "cnw_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_cnw.c",
    "lines": "254-267",
    "snippet": "void\ncnw_reset(sc)\n\tstruct cnw_softc *sc;\n{\n#ifdef CNW_DEBUG\n\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\tprintf(\"%s: resetting\\n\", sc->sc_dev.dv_xname);\n#endif\n\twait_WOC(sc, 0);\n\tbus_space_write_1(sc->sc_iot, sc->sc_ioh, CNW_REG_PMR, CNW_PMR_RESET);\n\tbus_space_write_1(sc->sc_memt, sc->sc_memh,\n\t\t\t  sc->sc_memoff + CNW_EREG_ASCC, CNW_ASR_WOC);\n\tbus_space_write_1(sc->sc_iot, sc->sc_ioh, CNW_REG_PMR, 0);\n}",
    "includes": [
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/pcmcia/if_cnwreg.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void cnw_reset",
      "static int wait_WOC",
      "struct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_iot",
            "sc->sc_ioh",
            "CNW_REG_PMR",
            "0"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_memt",
            "sc->sc_memh",
            "sc->sc_memoff + CNW_EREG_ASCC",
            "CNW_ASR_WOC"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_iot",
            "sc->sc_ioh",
            "CNW_REG_PMR",
            "CNW_PMR_RESET"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_WOC",
          "args": [
            "sc",
            "0"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "wait_WOC",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_cnw.c",
          "lines": "167-183",
          "snippet": "static int\nwait_WOC(sc, line)\n\tstruct cnw_softc *sc;\n\tint line;\n{\n\tint i, asr;\n\n\tfor (i = 0; i < 5000; i++) {\n\t\tasr = bus_space_read_1(sc->sc_iot, sc->sc_ioh, CNW_REG_ASR);\n\t\tif (asr & CNW_ASR_WOC)\n\t\t\treturn (0);\n\t\tDELAY(100);\n\t}\n\tif (line > 0)\n\t\tprintf(\"%s: wedged at line %d\\n\", sc->sc_dev.dv_xname, line);\n\treturn (1);\n}",
          "includes": [
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/pcmcia/if_cnwreg.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/socket.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int wait_WOC",
            "struct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/if_cnwreg.h>\n#include <sys/ioctl.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic int wait_WOC;\nstruct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;\n\nstatic int\nwait_WOC(sc, line)\n\tstruct cnw_softc *sc;\n\tint line;\n{\n\tint i, asr;\n\n\tfor (i = 0; i < 5000; i++) {\n\t\tasr = bus_space_read_1(sc->sc_iot, sc->sc_ioh, CNW_REG_ASR);\n\t\tif (asr & CNW_ASR_WOC)\n\t\t\treturn (0);\n\t\tDELAY(100);\n\t}\n\tif (line > 0)\n\t\tprintf(\"%s: wedged at line %d\\n\", sc->sc_dev.dv_xname, line);\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: resetting\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/if_cnwreg.h>\n#include <sys/ioctl.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid cnw_reset;\nstatic int wait_WOC;\nstruct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;\n\nvoid\ncnw_reset(sc)\n\tstruct cnw_softc *sc;\n{\n#ifdef CNW_DEBUG\n\tif (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)\n\t\tprintf(\"%s: resetting\\n\", sc->sc_dev.dv_xname);\n#endif\n\twait_WOC(sc, 0);\n\tbus_space_write_1(sc->sc_iot, sc->sc_ioh, CNW_REG_PMR, CNW_PMR_RESET);\n\tbus_space_write_1(sc->sc_memt, sc->sc_memh,\n\t\t\t  sc->sc_memoff + CNW_EREG_ASCC, CNW_ASR_WOC);\n\tbus_space_write_1(sc->sc_iot, sc->sc_ioh, CNW_REG_PMR, 0);\n}"
  },
  {
    "function_name": "cnw_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_cnw.c",
    "lines": "213-241",
    "snippet": "int\ncnw_cmd(sc, cmd, count, arg1, arg2)\n\tstruct cnw_softc *sc;\n\tint cmd, count, arg1, arg2;\n{\n\tint ptr = sc->sc_memoff + CNW_EREG_CB;\n\n\tif (wait_WOC(sc, 0)) {\n\t\tprintf(\"%s: wedged when issuing cmd 0x%x\\n\",\n\t\t       sc->sc_dev.dv_xname, cmd);\n\t\t/*\n\t\t * We'll continue anyway, as that's probably the best\n\t\t * thing we can do; at least the user knows there's a\n\t\t * problem, and can reset the interface with ifconfig\n\t\t * down/up.\n\t\t */\n\t}\n\n\tbus_space_write_1(sc->sc_memt, sc->sc_memh, ptr, cmd);\n\tif (count > 0) {\n\t\tbus_space_write_1(sc->sc_memt, sc->sc_memh, ptr + 1, arg1);\n\t\tif (count > 1)\n\t\t\tbus_space_write_1(sc->sc_memt, sc->sc_memh,\n\t\t\t\t\t  ptr + 2, arg2);\n\t}\n\tbus_space_write_1(sc->sc_memt, sc->sc_memh,\n\t\t\t  ptr + count + 1, CNW_CMD_EOC);\n\treturn (0);\n}",
    "includes": [
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/pcmcia/if_cnwreg.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int wait_WOC",
      "static int cnw_cmd",
      "struct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_memt",
            "sc->sc_memh",
            "ptr + count + 1",
            "CNW_CMD_EOC"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_memt",
            "sc->sc_memh",
            "ptr + 2",
            "arg2"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_memt",
            "sc->sc_memh",
            "ptr + 1",
            "arg1"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_memt",
            "sc->sc_memh",
            "ptr",
            "cmd"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: wedged when issuing cmd 0x%x\\n\"",
            "sc->sc_dev.dv_xname",
            "cmd"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_WOC",
          "args": [
            "sc",
            "0"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "wait_WOC",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_cnw.c",
          "lines": "167-183",
          "snippet": "static int\nwait_WOC(sc, line)\n\tstruct cnw_softc *sc;\n\tint line;\n{\n\tint i, asr;\n\n\tfor (i = 0; i < 5000; i++) {\n\t\tasr = bus_space_read_1(sc->sc_iot, sc->sc_ioh, CNW_REG_ASR);\n\t\tif (asr & CNW_ASR_WOC)\n\t\t\treturn (0);\n\t\tDELAY(100);\n\t}\n\tif (line > 0)\n\t\tprintf(\"%s: wedged at line %d\\n\", sc->sc_dev.dv_xname, line);\n\treturn (1);\n}",
          "includes": [
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <dev/pcmcia/pcmciadevs.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/pcmcia/if_cnwreg.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/socket.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int wait_WOC",
            "struct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/if_cnwreg.h>\n#include <sys/ioctl.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic int wait_WOC;\nstruct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;\n\nstatic int\nwait_WOC(sc, line)\n\tstruct cnw_softc *sc;\n\tint line;\n{\n\tint i, asr;\n\n\tfor (i = 0; i < 5000; i++) {\n\t\tasr = bus_space_read_1(sc->sc_iot, sc->sc_ioh, CNW_REG_ASR);\n\t\tif (asr & CNW_ASR_WOC)\n\t\t\treturn (0);\n\t\tDELAY(100);\n\t}\n\tif (line > 0)\n\t\tprintf(\"%s: wedged at line %d\\n\", sc->sc_dev.dv_xname, line);\n\treturn (1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/if_cnwreg.h>\n#include <sys/ioctl.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic int wait_WOC;\nstatic int cnw_cmd;\nstruct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;\n\nint\ncnw_cmd(sc, cmd, count, arg1, arg2)\n\tstruct cnw_softc *sc;\n\tint cmd, count, arg1, arg2;\n{\n\tint ptr = sc->sc_memoff + CNW_EREG_CB;\n\n\tif (wait_WOC(sc, 0)) {\n\t\tprintf(\"%s: wedged when issuing cmd 0x%x\\n\",\n\t\t       sc->sc_dev.dv_xname, cmd);\n\t\t/*\n\t\t * We'll continue anyway, as that's probably the best\n\t\t * thing we can do; at least the user knows there's a\n\t\t * problem, and can reset the interface with ifconfig\n\t\t * down/up.\n\t\t */\n\t}\n\n\tbus_space_write_1(sc->sc_memt, sc->sc_memh, ptr, cmd);\n\tif (count > 0) {\n\t\tbus_space_write_1(sc->sc_memt, sc->sc_memh, ptr + 1, arg1);\n\t\tif (count > 1)\n\t\t\tbus_space_write_1(sc->sc_memt, sc->sc_memh,\n\t\t\t\t\t  ptr + 2, arg2);\n\t}\n\tbus_space_write_1(sc->sc_memt, sc->sc_memh,\n\t\t\t  ptr + count + 1, CNW_CMD_EOC);\n\treturn (0);\n}"
  },
  {
    "function_name": "read16",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_cnw.c",
    "lines": "190-207",
    "snippet": "static int\nread16(sc, offset)\n\tstruct cnw_softc *sc;\n\tint offset;\n{\n\tint hi, lo;\n\n\t/* This could presumably be done more efficient with\n\t * bus_space_read_2(), but I don't know anything about the\n\t * byte sex guarantees... Besides, this is pretty cheap as\n\t * well :-)\n\t */\n\tlo = bus_space_read_1(sc->sc_memt, sc->sc_memh,\n\t\t\t      sc->sc_memoff + offset);\n\thi = bus_space_read_1(sc->sc_memt, sc->sc_memh,\n\t\t\t      sc->sc_memoff + offset + 1);\n\treturn ((hi << 8) | lo);\n}",
    "includes": [
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/pcmcia/if_cnwreg.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int read16",
      "struct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "sc->sc_memt",
            "sc->sc_memh",
            "sc->sc_memoff + offset + 1"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "sc->sc_memt",
            "sc->sc_memh",
            "sc->sc_memoff + offset"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/if_cnwreg.h>\n#include <sys/ioctl.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic int read16;\nstruct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;\n\nstatic int\nread16(sc, offset)\n\tstruct cnw_softc *sc;\n\tint offset;\n{\n\tint hi, lo;\n\n\t/* This could presumably be done more efficient with\n\t * bus_space_read_2(), but I don't know anything about the\n\t * byte sex guarantees... Besides, this is pretty cheap as\n\t * well :-)\n\t */\n\tlo = bus_space_read_1(sc->sc_memt, sc->sc_memh,\n\t\t\t      sc->sc_memoff + offset);\n\thi = bus_space_read_1(sc->sc_memt, sc->sc_memh,\n\t\t\t      sc->sc_memoff + offset + 1);\n\treturn ((hi << 8) | lo);\n}"
  },
  {
    "function_name": "wait_WOC",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/if_cnw.c",
    "lines": "167-183",
    "snippet": "static int\nwait_WOC(sc, line)\n\tstruct cnw_softc *sc;\n\tint line;\n{\n\tint i, asr;\n\n\tfor (i = 0; i < 5000; i++) {\n\t\tasr = bus_space_read_1(sc->sc_iot, sc->sc_ioh, CNW_REG_ASR);\n\t\tif (asr & CNW_ASR_WOC)\n\t\t\treturn (0);\n\t\tDELAY(100);\n\t}\n\tif (line > 0)\n\t\tprintf(\"%s: wedged at line %d\\n\", sc->sc_dev.dv_xname, line);\n\treturn (1);\n}",
    "includes": [
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <dev/pcmcia/pcmciadevs.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/pcmcia/pcmciareg.h>",
      "#include <dev/pcmcia/if_cnwreg.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/socket.h>",
      "#include <sys/device.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int wait_WOC",
      "struct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: wedged at line %d\\n\"",
            "sc->sc_dev.dv_xname",
            "line"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "100"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "sc->sc_iot",
            "sc->sc_ioh",
            "CNW_REG_ASR"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <dev/pcmcia/pcmciadevs.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/pcmcia/if_cnwreg.h>\n#include <sys/ioctl.h>\n#include <sys/mbuf.h>\n#include <sys/socket.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic int wait_WOC;\nstruct mbuf *\ncnw_read(sc)\n\tstruct cnw_softc *sc;\n\nstatic int\nwait_WOC(sc, line)\n\tstruct cnw_softc *sc;\n\tint line;\n{\n\tint i, asr;\n\n\tfor (i = 0; i < 5000; i++) {\n\t\tasr = bus_space_read_1(sc->sc_iot, sc->sc_ioh, CNW_REG_ASR);\n\t\tif (asr & CNW_ASR_WOC)\n\t\t\treturn (0);\n\t\tDELAY(100);\n\t}\n\tif (line > 0)\n\t\tprintf(\"%s: wedged at line %d\\n\", sc->sc_dev.dv_xname, line);\n\treturn (1);\n}"
  }
]