[
  {
    "function_name": "rf_CreateMirrorPartitionReadDAG",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagffrd.c",
    "lines": "428-439",
    "snippet": "void \nrf_CreateMirrorPartitionReadDAG(\n    RF_Raid_t * raidPtr,\n    RF_AccessStripeMap_t * asmap,\n    RF_DagHeader_t * dag_h,\n    void *bp,\n    RF_RaidAccessFlags_t flags,\n    RF_AllocListElem_t * allocList)\n{\n\tCreateMirrorReadDAG(raidPtr, asmap, dag_h, bp, flags, allocList,\n\t    rf_DiskReadMirrorPartitionFunc);\n}",
    "includes": [
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_memchunk.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CreateMirrorReadDAG",
          "args": [
            "raidPtr",
            "asmap",
            "dag_h",
            "bp",
            "flags",
            "allocList",
            "rf_DiskReadMirrorPartitionFunc"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "CreateMirrorReadDAG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagffrd.c",
          "lines": "306-413",
          "snippet": "static void \nCreateMirrorReadDAG(\n    RF_Raid_t * raidPtr,\n    RF_AccessStripeMap_t * asmap,\n    RF_DagHeader_t * dag_h,\n    void *bp,\n    RF_RaidAccessFlags_t flags,\n    RF_AllocListElem_t * allocList,\n    int (*readfunc) (RF_DagNode_t * node))\n{\n\tRF_DagNode_t *readNodes, *nodes, *blockNode, *commitNode, *termNode;\n\tRF_PhysDiskAddr_t *data_pda = asmap->physInfo;\n\tRF_PhysDiskAddr_t *parity_pda = asmap->parityInfo;\n\tint     i, n, totalNumNodes;\n\n\tn = asmap->numStripeUnitsAccessed;\n\tdag_h->creator = \"RaidOneReadDAG\";\n\tif (rf_dagDebug) {\n\t\tprintf(\"[Creating RAID level 1 read DAG]\\n\");\n\t}\n\t/*\n         * This dag can not commit until the commit node is reached\n         * errors prior to the commit point imply the dag has failed.\n         */\n\tdag_h->numCommitNodes = 1;\n\tdag_h->numCommits = 0;\n\tdag_h->numSuccedents = 1;\n\n\t/*\n         * Node count:\n         * n data reads\n         * 1 block node\n         * 1 commit node\n         * 1 terminator node\n         */\n\tRF_ASSERT(n > 0);\n\ttotalNumNodes = n + 3;\n\tRF_CallocAndAdd(nodes, totalNumNodes, sizeof(RF_DagNode_t),\n\t    (RF_DagNode_t *), allocList);\n\ti = 0;\n\treadNodes = &nodes[i];\n\ti += n;\n\tblockNode = &nodes[i];\n\ti += 1;\n\tcommitNode = &nodes[i];\n\ti += 1;\n\ttermNode = &nodes[i];\n\ti += 1;\n\tRF_ASSERT(i == totalNumNodes);\n\n\t/* initialize nodes */\n\trf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc,\n\t    rf_NullNodeUndoFunc, NULL, n, 0, 0, 0, dag_h, \"Nil\", allocList);\n\trf_InitNode(commitNode, rf_wait, RF_TRUE, rf_NullNodeFunc,\n\t    rf_NullNodeUndoFunc, NULL, 1, n, 0, 0, dag_h, \"Cmt\", allocList);\n\trf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc,\n\t    rf_TerminateUndoFunc, NULL, 0, 1, 0, 0, dag_h, \"Trm\", allocList);\n\n\tfor (i = 0; i < n; i++) {\n\t\tRF_ASSERT(data_pda != NULL);\n\t\tRF_ASSERT(parity_pda != NULL);\n\t\trf_InitNode(&readNodes[i], rf_wait, RF_FALSE, readfunc,\n\t\t    rf_DiskReadMirrorUndoFunc, rf_GenericWakeupFunc, 1, 1, 5, 0, dag_h,\n\t\t    \"Rmir\", allocList);\n\t\treadNodes[i].params[0].p = data_pda;\n\t\treadNodes[i].params[1].p = data_pda->bufPtr;\n\t\t/* parity stripe id is not necessary */\n\t\treadNodes[i].params[2].p = 0;\n\t\treadNodes[i].params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, 0);\n\t\treadNodes[i].params[4].p = parity_pda;\n\t\tdata_pda = data_pda->next;\n\t\tparity_pda = parity_pda->next;\n\t}\n\n\t/*\n         * Connect nodes\n         */\n\n\t/* connect hdr to block node */\n\tRF_ASSERT(blockNode->numAntecedents == 0);\n\tdag_h->succedents[0] = blockNode;\n\n\t/* connect block node to read nodes */\n\tRF_ASSERT(blockNode->numSuccedents == n);\n\tfor (i = 0; i < n; i++) {\n\t\tRF_ASSERT(readNodes[i].numAntecedents == 1);\n\t\tblockNode->succedents[i] = &readNodes[i];\n\t\treadNodes[i].antecedents[0] = blockNode;\n\t\treadNodes[i].antType[0] = rf_control;\n\t}\n\n\t/* connect read nodes to commit node */\n\tRF_ASSERT(commitNode->numAntecedents == n);\n\tfor (i = 0; i < n; i++) {\n\t\tRF_ASSERT(readNodes[i].numSuccedents == 1);\n\t\treadNodes[i].succedents[0] = commitNode;\n\t\tcommitNode->antecedents[i] = &readNodes[i];\n\t\tcommitNode->antType[i] = rf_control;\n\t}\n\n\t/* connect commit node to term node */\n\tRF_ASSERT(commitNode->numSuccedents == 1);\n\tRF_ASSERT(termNode->numAntecedents == 1);\n\tRF_ASSERT(termNode->numSuccedents == 0);\n\tcommitNode->succedents[0] = termNode;\n\ttermNode->antecedents[0] = commitNode;\n\ttermNode->antType[0] = rf_control;\n}",
          "includes": [
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_memchunk.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_dagffrd.h\"\n#include \"rf_general.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic void \nCreateMirrorReadDAG(\n    RF_Raid_t * raidPtr,\n    RF_AccessStripeMap_t * asmap,\n    RF_DagHeader_t * dag_h,\n    void *bp,\n    RF_RaidAccessFlags_t flags,\n    RF_AllocListElem_t * allocList,\n    int (*readfunc) (RF_DagNode_t * node))\n{\n\tRF_DagNode_t *readNodes, *nodes, *blockNode, *commitNode, *termNode;\n\tRF_PhysDiskAddr_t *data_pda = asmap->physInfo;\n\tRF_PhysDiskAddr_t *parity_pda = asmap->parityInfo;\n\tint     i, n, totalNumNodes;\n\n\tn = asmap->numStripeUnitsAccessed;\n\tdag_h->creator = \"RaidOneReadDAG\";\n\tif (rf_dagDebug) {\n\t\tprintf(\"[Creating RAID level 1 read DAG]\\n\");\n\t}\n\t/*\n         * This dag can not commit until the commit node is reached\n         * errors prior to the commit point imply the dag has failed.\n         */\n\tdag_h->numCommitNodes = 1;\n\tdag_h->numCommits = 0;\n\tdag_h->numSuccedents = 1;\n\n\t/*\n         * Node count:\n         * n data reads\n         * 1 block node\n         * 1 commit node\n         * 1 terminator node\n         */\n\tRF_ASSERT(n > 0);\n\ttotalNumNodes = n + 3;\n\tRF_CallocAndAdd(nodes, totalNumNodes, sizeof(RF_DagNode_t),\n\t    (RF_DagNode_t *), allocList);\n\ti = 0;\n\treadNodes = &nodes[i];\n\ti += n;\n\tblockNode = &nodes[i];\n\ti += 1;\n\tcommitNode = &nodes[i];\n\ti += 1;\n\ttermNode = &nodes[i];\n\ti += 1;\n\tRF_ASSERT(i == totalNumNodes);\n\n\t/* initialize nodes */\n\trf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc,\n\t    rf_NullNodeUndoFunc, NULL, n, 0, 0, 0, dag_h, \"Nil\", allocList);\n\trf_InitNode(commitNode, rf_wait, RF_TRUE, rf_NullNodeFunc,\n\t    rf_NullNodeUndoFunc, NULL, 1, n, 0, 0, dag_h, \"Cmt\", allocList);\n\trf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc,\n\t    rf_TerminateUndoFunc, NULL, 0, 1, 0, 0, dag_h, \"Trm\", allocList);\n\n\tfor (i = 0; i < n; i++) {\n\t\tRF_ASSERT(data_pda != NULL);\n\t\tRF_ASSERT(parity_pda != NULL);\n\t\trf_InitNode(&readNodes[i], rf_wait, RF_FALSE, readfunc,\n\t\t    rf_DiskReadMirrorUndoFunc, rf_GenericWakeupFunc, 1, 1, 5, 0, dag_h,\n\t\t    \"Rmir\", allocList);\n\t\treadNodes[i].params[0].p = data_pda;\n\t\treadNodes[i].params[1].p = data_pda->bufPtr;\n\t\t/* parity stripe id is not necessary */\n\t\treadNodes[i].params[2].p = 0;\n\t\treadNodes[i].params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, 0);\n\t\treadNodes[i].params[4].p = parity_pda;\n\t\tdata_pda = data_pda->next;\n\t\tparity_pda = parity_pda->next;\n\t}\n\n\t/*\n         * Connect nodes\n         */\n\n\t/* connect hdr to block node */\n\tRF_ASSERT(blockNode->numAntecedents == 0);\n\tdag_h->succedents[0] = blockNode;\n\n\t/* connect block node to read nodes */\n\tRF_ASSERT(blockNode->numSuccedents == n);\n\tfor (i = 0; i < n; i++) {\n\t\tRF_ASSERT(readNodes[i].numAntecedents == 1);\n\t\tblockNode->succedents[i] = &readNodes[i];\n\t\treadNodes[i].antecedents[0] = blockNode;\n\t\treadNodes[i].antType[0] = rf_control;\n\t}\n\n\t/* connect read nodes to commit node */\n\tRF_ASSERT(commitNode->numAntecedents == n);\n\tfor (i = 0; i < n; i++) {\n\t\tRF_ASSERT(readNodes[i].numSuccedents == 1);\n\t\treadNodes[i].succedents[0] = commitNode;\n\t\tcommitNode->antecedents[i] = &readNodes[i];\n\t\tcommitNode->antType[i] = rf_control;\n\t}\n\n\t/* connect commit node to term node */\n\tRF_ASSERT(commitNode->numSuccedents == 1);\n\tRF_ASSERT(termNode->numAntecedents == 1);\n\tRF_ASSERT(termNode->numSuccedents == 0);\n\tcommitNode->succedents[0] = termNode;\n\ttermNode->antecedents[0] = commitNode;\n\ttermNode->antType[0] = rf_control;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_dagffrd.h\"\n#include \"rf_general.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_CreateMirrorPartitionReadDAG(\n    RF_Raid_t * raidPtr,\n    RF_AccessStripeMap_t * asmap,\n    RF_DagHeader_t * dag_h,\n    void *bp,\n    RF_RaidAccessFlags_t flags,\n    RF_AllocListElem_t * allocList)\n{\n\tCreateMirrorReadDAG(raidPtr, asmap, dag_h, bp, flags, allocList,\n\t    rf_DiskReadMirrorPartitionFunc);\n}"
  },
  {
    "function_name": "rf_CreateMirrorIdleReadDAG",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagffrd.c",
    "lines": "415-426",
    "snippet": "void \nrf_CreateMirrorIdleReadDAG(\n    RF_Raid_t * raidPtr,\n    RF_AccessStripeMap_t * asmap,\n    RF_DagHeader_t * dag_h,\n    void *bp,\n    RF_RaidAccessFlags_t flags,\n    RF_AllocListElem_t * allocList)\n{\n\tCreateMirrorReadDAG(raidPtr, asmap, dag_h, bp, flags, allocList,\n\t    rf_DiskReadMirrorIdleFunc);\n}",
    "includes": [
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_memchunk.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CreateMirrorReadDAG",
          "args": [
            "raidPtr",
            "asmap",
            "dag_h",
            "bp",
            "flags",
            "allocList",
            "rf_DiskReadMirrorIdleFunc"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "CreateMirrorReadDAG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagffrd.c",
          "lines": "306-413",
          "snippet": "static void \nCreateMirrorReadDAG(\n    RF_Raid_t * raidPtr,\n    RF_AccessStripeMap_t * asmap,\n    RF_DagHeader_t * dag_h,\n    void *bp,\n    RF_RaidAccessFlags_t flags,\n    RF_AllocListElem_t * allocList,\n    int (*readfunc) (RF_DagNode_t * node))\n{\n\tRF_DagNode_t *readNodes, *nodes, *blockNode, *commitNode, *termNode;\n\tRF_PhysDiskAddr_t *data_pda = asmap->physInfo;\n\tRF_PhysDiskAddr_t *parity_pda = asmap->parityInfo;\n\tint     i, n, totalNumNodes;\n\n\tn = asmap->numStripeUnitsAccessed;\n\tdag_h->creator = \"RaidOneReadDAG\";\n\tif (rf_dagDebug) {\n\t\tprintf(\"[Creating RAID level 1 read DAG]\\n\");\n\t}\n\t/*\n         * This dag can not commit until the commit node is reached\n         * errors prior to the commit point imply the dag has failed.\n         */\n\tdag_h->numCommitNodes = 1;\n\tdag_h->numCommits = 0;\n\tdag_h->numSuccedents = 1;\n\n\t/*\n         * Node count:\n         * n data reads\n         * 1 block node\n         * 1 commit node\n         * 1 terminator node\n         */\n\tRF_ASSERT(n > 0);\n\ttotalNumNodes = n + 3;\n\tRF_CallocAndAdd(nodes, totalNumNodes, sizeof(RF_DagNode_t),\n\t    (RF_DagNode_t *), allocList);\n\ti = 0;\n\treadNodes = &nodes[i];\n\ti += n;\n\tblockNode = &nodes[i];\n\ti += 1;\n\tcommitNode = &nodes[i];\n\ti += 1;\n\ttermNode = &nodes[i];\n\ti += 1;\n\tRF_ASSERT(i == totalNumNodes);\n\n\t/* initialize nodes */\n\trf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc,\n\t    rf_NullNodeUndoFunc, NULL, n, 0, 0, 0, dag_h, \"Nil\", allocList);\n\trf_InitNode(commitNode, rf_wait, RF_TRUE, rf_NullNodeFunc,\n\t    rf_NullNodeUndoFunc, NULL, 1, n, 0, 0, dag_h, \"Cmt\", allocList);\n\trf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc,\n\t    rf_TerminateUndoFunc, NULL, 0, 1, 0, 0, dag_h, \"Trm\", allocList);\n\n\tfor (i = 0; i < n; i++) {\n\t\tRF_ASSERT(data_pda != NULL);\n\t\tRF_ASSERT(parity_pda != NULL);\n\t\trf_InitNode(&readNodes[i], rf_wait, RF_FALSE, readfunc,\n\t\t    rf_DiskReadMirrorUndoFunc, rf_GenericWakeupFunc, 1, 1, 5, 0, dag_h,\n\t\t    \"Rmir\", allocList);\n\t\treadNodes[i].params[0].p = data_pda;\n\t\treadNodes[i].params[1].p = data_pda->bufPtr;\n\t\t/* parity stripe id is not necessary */\n\t\treadNodes[i].params[2].p = 0;\n\t\treadNodes[i].params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, 0);\n\t\treadNodes[i].params[4].p = parity_pda;\n\t\tdata_pda = data_pda->next;\n\t\tparity_pda = parity_pda->next;\n\t}\n\n\t/*\n         * Connect nodes\n         */\n\n\t/* connect hdr to block node */\n\tRF_ASSERT(blockNode->numAntecedents == 0);\n\tdag_h->succedents[0] = blockNode;\n\n\t/* connect block node to read nodes */\n\tRF_ASSERT(blockNode->numSuccedents == n);\n\tfor (i = 0; i < n; i++) {\n\t\tRF_ASSERT(readNodes[i].numAntecedents == 1);\n\t\tblockNode->succedents[i] = &readNodes[i];\n\t\treadNodes[i].antecedents[0] = blockNode;\n\t\treadNodes[i].antType[0] = rf_control;\n\t}\n\n\t/* connect read nodes to commit node */\n\tRF_ASSERT(commitNode->numAntecedents == n);\n\tfor (i = 0; i < n; i++) {\n\t\tRF_ASSERT(readNodes[i].numSuccedents == 1);\n\t\treadNodes[i].succedents[0] = commitNode;\n\t\tcommitNode->antecedents[i] = &readNodes[i];\n\t\tcommitNode->antType[i] = rf_control;\n\t}\n\n\t/* connect commit node to term node */\n\tRF_ASSERT(commitNode->numSuccedents == 1);\n\tRF_ASSERT(termNode->numAntecedents == 1);\n\tRF_ASSERT(termNode->numSuccedents == 0);\n\tcommitNode->succedents[0] = termNode;\n\ttermNode->antecedents[0] = commitNode;\n\ttermNode->antType[0] = rf_control;\n}",
          "includes": [
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_memchunk.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_dagffrd.h\"\n#include \"rf_general.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic void \nCreateMirrorReadDAG(\n    RF_Raid_t * raidPtr,\n    RF_AccessStripeMap_t * asmap,\n    RF_DagHeader_t * dag_h,\n    void *bp,\n    RF_RaidAccessFlags_t flags,\n    RF_AllocListElem_t * allocList,\n    int (*readfunc) (RF_DagNode_t * node))\n{\n\tRF_DagNode_t *readNodes, *nodes, *blockNode, *commitNode, *termNode;\n\tRF_PhysDiskAddr_t *data_pda = asmap->physInfo;\n\tRF_PhysDiskAddr_t *parity_pda = asmap->parityInfo;\n\tint     i, n, totalNumNodes;\n\n\tn = asmap->numStripeUnitsAccessed;\n\tdag_h->creator = \"RaidOneReadDAG\";\n\tif (rf_dagDebug) {\n\t\tprintf(\"[Creating RAID level 1 read DAG]\\n\");\n\t}\n\t/*\n         * This dag can not commit until the commit node is reached\n         * errors prior to the commit point imply the dag has failed.\n         */\n\tdag_h->numCommitNodes = 1;\n\tdag_h->numCommits = 0;\n\tdag_h->numSuccedents = 1;\n\n\t/*\n         * Node count:\n         * n data reads\n         * 1 block node\n         * 1 commit node\n         * 1 terminator node\n         */\n\tRF_ASSERT(n > 0);\n\ttotalNumNodes = n + 3;\n\tRF_CallocAndAdd(nodes, totalNumNodes, sizeof(RF_DagNode_t),\n\t    (RF_DagNode_t *), allocList);\n\ti = 0;\n\treadNodes = &nodes[i];\n\ti += n;\n\tblockNode = &nodes[i];\n\ti += 1;\n\tcommitNode = &nodes[i];\n\ti += 1;\n\ttermNode = &nodes[i];\n\ti += 1;\n\tRF_ASSERT(i == totalNumNodes);\n\n\t/* initialize nodes */\n\trf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc,\n\t    rf_NullNodeUndoFunc, NULL, n, 0, 0, 0, dag_h, \"Nil\", allocList);\n\trf_InitNode(commitNode, rf_wait, RF_TRUE, rf_NullNodeFunc,\n\t    rf_NullNodeUndoFunc, NULL, 1, n, 0, 0, dag_h, \"Cmt\", allocList);\n\trf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc,\n\t    rf_TerminateUndoFunc, NULL, 0, 1, 0, 0, dag_h, \"Trm\", allocList);\n\n\tfor (i = 0; i < n; i++) {\n\t\tRF_ASSERT(data_pda != NULL);\n\t\tRF_ASSERT(parity_pda != NULL);\n\t\trf_InitNode(&readNodes[i], rf_wait, RF_FALSE, readfunc,\n\t\t    rf_DiskReadMirrorUndoFunc, rf_GenericWakeupFunc, 1, 1, 5, 0, dag_h,\n\t\t    \"Rmir\", allocList);\n\t\treadNodes[i].params[0].p = data_pda;\n\t\treadNodes[i].params[1].p = data_pda->bufPtr;\n\t\t/* parity stripe id is not necessary */\n\t\treadNodes[i].params[2].p = 0;\n\t\treadNodes[i].params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, 0);\n\t\treadNodes[i].params[4].p = parity_pda;\n\t\tdata_pda = data_pda->next;\n\t\tparity_pda = parity_pda->next;\n\t}\n\n\t/*\n         * Connect nodes\n         */\n\n\t/* connect hdr to block node */\n\tRF_ASSERT(blockNode->numAntecedents == 0);\n\tdag_h->succedents[0] = blockNode;\n\n\t/* connect block node to read nodes */\n\tRF_ASSERT(blockNode->numSuccedents == n);\n\tfor (i = 0; i < n; i++) {\n\t\tRF_ASSERT(readNodes[i].numAntecedents == 1);\n\t\tblockNode->succedents[i] = &readNodes[i];\n\t\treadNodes[i].antecedents[0] = blockNode;\n\t\treadNodes[i].antType[0] = rf_control;\n\t}\n\n\t/* connect read nodes to commit node */\n\tRF_ASSERT(commitNode->numAntecedents == n);\n\tfor (i = 0; i < n; i++) {\n\t\tRF_ASSERT(readNodes[i].numSuccedents == 1);\n\t\treadNodes[i].succedents[0] = commitNode;\n\t\tcommitNode->antecedents[i] = &readNodes[i];\n\t\tcommitNode->antType[i] = rf_control;\n\t}\n\n\t/* connect commit node to term node */\n\tRF_ASSERT(commitNode->numSuccedents == 1);\n\tRF_ASSERT(termNode->numAntecedents == 1);\n\tRF_ASSERT(termNode->numSuccedents == 0);\n\tcommitNode->succedents[0] = termNode;\n\ttermNode->antecedents[0] = commitNode;\n\ttermNode->antType[0] = rf_control;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_dagffrd.h\"\n#include \"rf_general.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_CreateMirrorIdleReadDAG(\n    RF_Raid_t * raidPtr,\n    RF_AccessStripeMap_t * asmap,\n    RF_DagHeader_t * dag_h,\n    void *bp,\n    RF_RaidAccessFlags_t flags,\n    RF_AllocListElem_t * allocList)\n{\n\tCreateMirrorReadDAG(raidPtr, asmap, dag_h, bp, flags, allocList,\n\t    rf_DiskReadMirrorIdleFunc);\n}"
  },
  {
    "function_name": "CreateMirrorReadDAG",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagffrd.c",
    "lines": "306-413",
    "snippet": "static void \nCreateMirrorReadDAG(\n    RF_Raid_t * raidPtr,\n    RF_AccessStripeMap_t * asmap,\n    RF_DagHeader_t * dag_h,\n    void *bp,\n    RF_RaidAccessFlags_t flags,\n    RF_AllocListElem_t * allocList,\n    int (*readfunc) (RF_DagNode_t * node))\n{\n\tRF_DagNode_t *readNodes, *nodes, *blockNode, *commitNode, *termNode;\n\tRF_PhysDiskAddr_t *data_pda = asmap->physInfo;\n\tRF_PhysDiskAddr_t *parity_pda = asmap->parityInfo;\n\tint     i, n, totalNumNodes;\n\n\tn = asmap->numStripeUnitsAccessed;\n\tdag_h->creator = \"RaidOneReadDAG\";\n\tif (rf_dagDebug) {\n\t\tprintf(\"[Creating RAID level 1 read DAG]\\n\");\n\t}\n\t/*\n         * This dag can not commit until the commit node is reached\n         * errors prior to the commit point imply the dag has failed.\n         */\n\tdag_h->numCommitNodes = 1;\n\tdag_h->numCommits = 0;\n\tdag_h->numSuccedents = 1;\n\n\t/*\n         * Node count:\n         * n data reads\n         * 1 block node\n         * 1 commit node\n         * 1 terminator node\n         */\n\tRF_ASSERT(n > 0);\n\ttotalNumNodes = n + 3;\n\tRF_CallocAndAdd(nodes, totalNumNodes, sizeof(RF_DagNode_t),\n\t    (RF_DagNode_t *), allocList);\n\ti = 0;\n\treadNodes = &nodes[i];\n\ti += n;\n\tblockNode = &nodes[i];\n\ti += 1;\n\tcommitNode = &nodes[i];\n\ti += 1;\n\ttermNode = &nodes[i];\n\ti += 1;\n\tRF_ASSERT(i == totalNumNodes);\n\n\t/* initialize nodes */\n\trf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc,\n\t    rf_NullNodeUndoFunc, NULL, n, 0, 0, 0, dag_h, \"Nil\", allocList);\n\trf_InitNode(commitNode, rf_wait, RF_TRUE, rf_NullNodeFunc,\n\t    rf_NullNodeUndoFunc, NULL, 1, n, 0, 0, dag_h, \"Cmt\", allocList);\n\trf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc,\n\t    rf_TerminateUndoFunc, NULL, 0, 1, 0, 0, dag_h, \"Trm\", allocList);\n\n\tfor (i = 0; i < n; i++) {\n\t\tRF_ASSERT(data_pda != NULL);\n\t\tRF_ASSERT(parity_pda != NULL);\n\t\trf_InitNode(&readNodes[i], rf_wait, RF_FALSE, readfunc,\n\t\t    rf_DiskReadMirrorUndoFunc, rf_GenericWakeupFunc, 1, 1, 5, 0, dag_h,\n\t\t    \"Rmir\", allocList);\n\t\treadNodes[i].params[0].p = data_pda;\n\t\treadNodes[i].params[1].p = data_pda->bufPtr;\n\t\t/* parity stripe id is not necessary */\n\t\treadNodes[i].params[2].p = 0;\n\t\treadNodes[i].params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, 0);\n\t\treadNodes[i].params[4].p = parity_pda;\n\t\tdata_pda = data_pda->next;\n\t\tparity_pda = parity_pda->next;\n\t}\n\n\t/*\n         * Connect nodes\n         */\n\n\t/* connect hdr to block node */\n\tRF_ASSERT(blockNode->numAntecedents == 0);\n\tdag_h->succedents[0] = blockNode;\n\n\t/* connect block node to read nodes */\n\tRF_ASSERT(blockNode->numSuccedents == n);\n\tfor (i = 0; i < n; i++) {\n\t\tRF_ASSERT(readNodes[i].numAntecedents == 1);\n\t\tblockNode->succedents[i] = &readNodes[i];\n\t\treadNodes[i].antecedents[0] = blockNode;\n\t\treadNodes[i].antType[0] = rf_control;\n\t}\n\n\t/* connect read nodes to commit node */\n\tRF_ASSERT(commitNode->numAntecedents == n);\n\tfor (i = 0; i < n; i++) {\n\t\tRF_ASSERT(readNodes[i].numSuccedents == 1);\n\t\treadNodes[i].succedents[0] = commitNode;\n\t\tcommitNode->antecedents[i] = &readNodes[i];\n\t\tcommitNode->antType[i] = rf_control;\n\t}\n\n\t/* connect commit node to term node */\n\tRF_ASSERT(commitNode->numSuccedents == 1);\n\tRF_ASSERT(termNode->numAntecedents == 1);\n\tRF_ASSERT(termNode->numSuccedents == 0);\n\tcommitNode->succedents[0] = termNode;\n\ttermNode->antecedents[0] = commitNode;\n\ttermNode->antType[0] = rf_control;\n}",
    "includes": [
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_memchunk.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "termNode->numSuccedents == 0"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "termNode->numAntecedents == 1"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "commitNode->numSuccedents == 1"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "readNodes[i].numSuccedents == 1"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "commitNode->numAntecedents == n"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "readNodes[i].numAntecedents == 1"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "blockNode->numSuccedents == n"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "blockNode->numAntecedents == 0"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_CREATE_PARAM3",
          "args": [
            "RF_IO_NORMAL_PRIORITY",
            "0",
            "0",
            "0"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_InitNode",
          "args": [
            "&readNodes[i]",
            "rf_wait",
            "RF_FALSE",
            "readfunc",
            "rf_DiskReadMirrorUndoFunc",
            "rf_GenericWakeupFunc",
            "1",
            "1",
            "5",
            "0",
            "dag_h",
            "\"Rmir\"",
            "allocList"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "rf_InitNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
          "lines": "74-143",
          "snippet": "void \nrf_InitNode(\n    RF_DagNode_t * node,\n    RF_NodeStatus_t initstatus,\n    int commit,\n    int (*doFunc) (RF_DagNode_t * node),\n    int (*undoFunc) (RF_DagNode_t * node),\n    int (*wakeFunc) (RF_DagNode_t * node, int status),\n    int nSucc,\n    int nAnte,\n    int nParam,\n    int nResult,\n    RF_DagHeader_t * hdr,\n    char *name,\n    RF_AllocListElem_t * alist)\n{\n\tvoid  **ptrs;\n\tint     nptrs;\n\n\tif (nAnte > RF_MAX_ANTECEDENTS)\n\t\tRF_PANIC();\n\tnode->status = initstatus;\n\tnode->commitNode = commit;\n\tnode->doFunc = doFunc;\n\tnode->undoFunc = undoFunc;\n\tnode->wakeFunc = wakeFunc;\n\tnode->numParams = nParam;\n\tnode->numResults = nResult;\n\tnode->numAntecedents = nAnte;\n\tnode->numAntDone = 0;\n\tnode->next = NULL;\n\tnode->numSuccedents = nSucc;\n\tnode->name = name;\n\tnode->dagHdr = hdr;\n\tnode->visited = 0;\n\n\t/* allocate all the pointers with one call to malloc */\n\tnptrs = nSucc + nAnte + nResult + nSucc;\n\n\tif (nptrs <= RF_DAG_PTRCACHESIZE) {\n\t\t/*\n\t         * The dag_ptrs field of the node is basically some scribble\n\t         * space to be used here. We could get rid of it, and always\n\t         * allocate the range of pointers, but that's expensive. So,\n\t         * we pick a \"common case\" size for the pointer cache. Hopefully,\n\t         * we'll find that:\n\t         * (1) Generally, nptrs doesn't exceed RF_DAG_PTRCACHESIZE by\n\t         *     only a little bit (least efficient case)\n\t         * (2) Generally, ntprs isn't a lot less than RF_DAG_PTRCACHESIZE\n\t         *     (wasted memory)\n\t         */\n\t\tptrs = (void **) node->dag_ptrs;\n\t} else {\n\t\tRF_CallocAndAdd(ptrs, nptrs, sizeof(void *), (void **), alist);\n\t}\n\tnode->succedents = (nSucc) ? (RF_DagNode_t **) ptrs : NULL;\n\tnode->antecedents = (nAnte) ? (RF_DagNode_t **) (ptrs + nSucc) : NULL;\n\tnode->results = (nResult) ? (void **) (ptrs + nSucc + nAnte) : NULL;\n\tnode->propList = (nSucc) ? (RF_PropHeader_t **) (ptrs + nSucc + nAnte + nResult) : NULL;\n\n\tif (nParam) {\n\t\tif (nParam <= RF_DAG_PARAMCACHESIZE) {\n\t\t\tnode->params = (RF_DagParam_t *) node->dag_params;\n\t\t} else {\n\t\t\tRF_CallocAndAdd(node->params, nParam, sizeof(RF_DagParam_t), (RF_DagParam_t *), alist);\n\t\t}\n\t} else {\n\t\tnode->params = NULL;\n\t}\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void rf_RecurPrintDAG(RF_DagNode_t *, int, int);",
            "static void rf_PrintDAG(RF_DagHeader_t *);",
            "static int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);",
            "static void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);",
            "static void rf_ValidateVisitedBits(RF_DagHeader_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_RecurPrintDAG(RF_DagNode_t *, int, int);\nstatic void rf_PrintDAG(RF_DagHeader_t *);\nstatic int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);\nstatic void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);\nstatic void rf_ValidateVisitedBits(RF_DagHeader_t *);\n\nvoid \nrf_InitNode(\n    RF_DagNode_t * node,\n    RF_NodeStatus_t initstatus,\n    int commit,\n    int (*doFunc) (RF_DagNode_t * node),\n    int (*undoFunc) (RF_DagNode_t * node),\n    int (*wakeFunc) (RF_DagNode_t * node, int status),\n    int nSucc,\n    int nAnte,\n    int nParam,\n    int nResult,\n    RF_DagHeader_t * hdr,\n    char *name,\n    RF_AllocListElem_t * alist)\n{\n\tvoid  **ptrs;\n\tint     nptrs;\n\n\tif (nAnte > RF_MAX_ANTECEDENTS)\n\t\tRF_PANIC();\n\tnode->status = initstatus;\n\tnode->commitNode = commit;\n\tnode->doFunc = doFunc;\n\tnode->undoFunc = undoFunc;\n\tnode->wakeFunc = wakeFunc;\n\tnode->numParams = nParam;\n\tnode->numResults = nResult;\n\tnode->numAntecedents = nAnte;\n\tnode->numAntDone = 0;\n\tnode->next = NULL;\n\tnode->numSuccedents = nSucc;\n\tnode->name = name;\n\tnode->dagHdr = hdr;\n\tnode->visited = 0;\n\n\t/* allocate all the pointers with one call to malloc */\n\tnptrs = nSucc + nAnte + nResult + nSucc;\n\n\tif (nptrs <= RF_DAG_PTRCACHESIZE) {\n\t\t/*\n\t         * The dag_ptrs field of the node is basically some scribble\n\t         * space to be used here. We could get rid of it, and always\n\t         * allocate the range of pointers, but that's expensive. So,\n\t         * we pick a \"common case\" size for the pointer cache. Hopefully,\n\t         * we'll find that:\n\t         * (1) Generally, nptrs doesn't exceed RF_DAG_PTRCACHESIZE by\n\t         *     only a little bit (least efficient case)\n\t         * (2) Generally, ntprs isn't a lot less than RF_DAG_PTRCACHESIZE\n\t         *     (wasted memory)\n\t         */\n\t\tptrs = (void **) node->dag_ptrs;\n\t} else {\n\t\tRF_CallocAndAdd(ptrs, nptrs, sizeof(void *), (void **), alist);\n\t}\n\tnode->succedents = (nSucc) ? (RF_DagNode_t **) ptrs : NULL;\n\tnode->antecedents = (nAnte) ? (RF_DagNode_t **) (ptrs + nSucc) : NULL;\n\tnode->results = (nResult) ? (void **) (ptrs + nSucc + nAnte) : NULL;\n\tnode->propList = (nSucc) ? (RF_PropHeader_t **) (ptrs + nSucc + nAnte + nResult) : NULL;\n\n\tif (nParam) {\n\t\tif (nParam <= RF_DAG_PARAMCACHESIZE) {\n\t\t\tnode->params = (RF_DagParam_t *) node->dag_params;\n\t\t} else {\n\t\t\tRF_CallocAndAdd(node->params, nParam, sizeof(RF_DagParam_t), (RF_DagParam_t *), alist);\n\t\t}\n\t} else {\n\t\tnode->params = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "parity_pda != NULL"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "data_pda != NULL"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "i == totalNumNodes"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_CallocAndAdd",
          "args": [
            "nodes",
            "totalNumNodes",
            "sizeof(RF_DagNode_t)",
            "(RF_DagNode_t *), allocList"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "n > 0"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"[Creating RAID level 1 read DAG]\\n\""
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_dagffrd.h\"\n#include \"rf_general.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic void \nCreateMirrorReadDAG(\n    RF_Raid_t * raidPtr,\n    RF_AccessStripeMap_t * asmap,\n    RF_DagHeader_t * dag_h,\n    void *bp,\n    RF_RaidAccessFlags_t flags,\n    RF_AllocListElem_t * allocList,\n    int (*readfunc) (RF_DagNode_t * node))\n{\n\tRF_DagNode_t *readNodes, *nodes, *blockNode, *commitNode, *termNode;\n\tRF_PhysDiskAddr_t *data_pda = asmap->physInfo;\n\tRF_PhysDiskAddr_t *parity_pda = asmap->parityInfo;\n\tint     i, n, totalNumNodes;\n\n\tn = asmap->numStripeUnitsAccessed;\n\tdag_h->creator = \"RaidOneReadDAG\";\n\tif (rf_dagDebug) {\n\t\tprintf(\"[Creating RAID level 1 read DAG]\\n\");\n\t}\n\t/*\n         * This dag can not commit until the commit node is reached\n         * errors prior to the commit point imply the dag has failed.\n         */\n\tdag_h->numCommitNodes = 1;\n\tdag_h->numCommits = 0;\n\tdag_h->numSuccedents = 1;\n\n\t/*\n         * Node count:\n         * n data reads\n         * 1 block node\n         * 1 commit node\n         * 1 terminator node\n         */\n\tRF_ASSERT(n > 0);\n\ttotalNumNodes = n + 3;\n\tRF_CallocAndAdd(nodes, totalNumNodes, sizeof(RF_DagNode_t),\n\t    (RF_DagNode_t *), allocList);\n\ti = 0;\n\treadNodes = &nodes[i];\n\ti += n;\n\tblockNode = &nodes[i];\n\ti += 1;\n\tcommitNode = &nodes[i];\n\ti += 1;\n\ttermNode = &nodes[i];\n\ti += 1;\n\tRF_ASSERT(i == totalNumNodes);\n\n\t/* initialize nodes */\n\trf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc,\n\t    rf_NullNodeUndoFunc, NULL, n, 0, 0, 0, dag_h, \"Nil\", allocList);\n\trf_InitNode(commitNode, rf_wait, RF_TRUE, rf_NullNodeFunc,\n\t    rf_NullNodeUndoFunc, NULL, 1, n, 0, 0, dag_h, \"Cmt\", allocList);\n\trf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc,\n\t    rf_TerminateUndoFunc, NULL, 0, 1, 0, 0, dag_h, \"Trm\", allocList);\n\n\tfor (i = 0; i < n; i++) {\n\t\tRF_ASSERT(data_pda != NULL);\n\t\tRF_ASSERT(parity_pda != NULL);\n\t\trf_InitNode(&readNodes[i], rf_wait, RF_FALSE, readfunc,\n\t\t    rf_DiskReadMirrorUndoFunc, rf_GenericWakeupFunc, 1, 1, 5, 0, dag_h,\n\t\t    \"Rmir\", allocList);\n\t\treadNodes[i].params[0].p = data_pda;\n\t\treadNodes[i].params[1].p = data_pda->bufPtr;\n\t\t/* parity stripe id is not necessary */\n\t\treadNodes[i].params[2].p = 0;\n\t\treadNodes[i].params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, 0);\n\t\treadNodes[i].params[4].p = parity_pda;\n\t\tdata_pda = data_pda->next;\n\t\tparity_pda = parity_pda->next;\n\t}\n\n\t/*\n         * Connect nodes\n         */\n\n\t/* connect hdr to block node */\n\tRF_ASSERT(blockNode->numAntecedents == 0);\n\tdag_h->succedents[0] = blockNode;\n\n\t/* connect block node to read nodes */\n\tRF_ASSERT(blockNode->numSuccedents == n);\n\tfor (i = 0; i < n; i++) {\n\t\tRF_ASSERT(readNodes[i].numAntecedents == 1);\n\t\tblockNode->succedents[i] = &readNodes[i];\n\t\treadNodes[i].antecedents[0] = blockNode;\n\t\treadNodes[i].antType[0] = rf_control;\n\t}\n\n\t/* connect read nodes to commit node */\n\tRF_ASSERT(commitNode->numAntecedents == n);\n\tfor (i = 0; i < n; i++) {\n\t\tRF_ASSERT(readNodes[i].numSuccedents == 1);\n\t\treadNodes[i].succedents[0] = commitNode;\n\t\tcommitNode->antecedents[i] = &readNodes[i];\n\t\tcommitNode->antType[i] = rf_control;\n\t}\n\n\t/* connect commit node to term node */\n\tRF_ASSERT(commitNode->numSuccedents == 1);\n\tRF_ASSERT(termNode->numAntecedents == 1);\n\tRF_ASSERT(termNode->numSuccedents == 0);\n\tcommitNode->succedents[0] = termNode;\n\ttermNode->antecedents[0] = commitNode;\n\ttermNode->antType[0] = rf_control;\n}"
  },
  {
    "function_name": "rf_CreateNonredundantDAG",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagffrd.c",
    "lines": "127-288",
    "snippet": "void \nrf_CreateNonredundantDAG(\n    RF_Raid_t * raidPtr,\n    RF_AccessStripeMap_t * asmap,\n    RF_DagHeader_t * dag_h,\n    void *bp,\n    RF_RaidAccessFlags_t flags,\n    RF_AllocListElem_t * allocList,\n    RF_IoType_t type)\n{\n\tRF_DagNode_t *nodes, *diskNodes, *blockNode, *commitNode, *termNode;\n\tRF_PhysDiskAddr_t *pda = asmap->physInfo;\n\tint     (*doFunc) (RF_DagNode_t *), (*undoFunc) (RF_DagNode_t *);\n\tint     i, n, totalNumNodes;\n\tchar   *name;\n\n\tn = asmap->numStripeUnitsAccessed;\n\tdag_h->creator = \"NonredundantDAG\";\n\n\tRF_ASSERT(RF_IO_IS_R_OR_W(type));\n\tswitch (type) {\n\tcase RF_IO_TYPE_READ:\n\t\tdoFunc = rf_DiskReadFunc;\n\t\tundoFunc = rf_DiskReadUndoFunc;\n\t\tname = \"R  \";\n\t\tif (rf_dagDebug)\n\t\t\tprintf(\"[Creating non-redundant read DAG]\\n\");\n\t\tbreak;\n\tcase RF_IO_TYPE_WRITE:\n\t\tdoFunc = rf_DiskWriteFunc;\n\t\tundoFunc = rf_DiskWriteUndoFunc;\n\t\tname = \"W  \";\n\t\tif (rf_dagDebug)\n\t\t\tprintf(\"[Creating non-redundant write DAG]\\n\");\n\t\tbreak;\n\tdefault:\n\t\tRF_PANIC();\n\t}\n\n\t/*\n         * For reads, the dag can not commit until the block node is reached.\n         * for writes, the dag commits immediately.\n         */\n\tdag_h->numCommitNodes = 1;\n\tdag_h->numCommits = 0;\n\tdag_h->numSuccedents = 1;\n\n\t/*\n         * Node count:\n         * 1 block node\n         * n data reads (or writes)\n         * 1 commit node\n         * 1 terminator node\n         */\n\tRF_ASSERT(n > 0);\n\ttotalNumNodes = n + 3;\n\tRF_CallocAndAdd(nodes, totalNumNodes, sizeof(RF_DagNode_t),\n\t    (RF_DagNode_t *), allocList);\n\ti = 0;\n\tdiskNodes = &nodes[i];\n\ti += n;\n\tblockNode = &nodes[i];\n\ti += 1;\n\tcommitNode = &nodes[i];\n\ti += 1;\n\ttermNode = &nodes[i];\n\ti += 1;\n\tRF_ASSERT(i == totalNumNodes);\n\n\t/* initialize nodes */\n\tswitch (type) {\n\tcase RF_IO_TYPE_READ:\n\t\trf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc, rf_NullNodeUndoFunc,\n\t\t    NULL, n, 0, 0, 0, dag_h, \"Nil\", allocList);\n\t\trf_InitNode(commitNode, rf_wait, RF_TRUE, rf_NullNodeFunc, rf_NullNodeUndoFunc,\n\t\t    NULL, 1, n, 0, 0, dag_h, \"Cmt\", allocList);\n\t\trf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc, rf_TerminateUndoFunc,\n\t\t    NULL, 0, 1, 0, 0, dag_h, \"Trm\", allocList);\n\t\tbreak;\n\tcase RF_IO_TYPE_WRITE:\n\t\trf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc, rf_NullNodeUndoFunc,\n\t\t    NULL, 1, 0, 0, 0, dag_h, \"Nil\", allocList);\n\t\trf_InitNode(commitNode, rf_wait, RF_TRUE, rf_NullNodeFunc, rf_NullNodeUndoFunc,\n\t\t    NULL, n, 1, 0, 0, dag_h, \"Cmt\", allocList);\n\t\trf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc, rf_TerminateUndoFunc,\n\t\t    NULL, 0, n, 0, 0, dag_h, \"Trm\", allocList);\n\t\tbreak;\n\tdefault:\n\t\tRF_PANIC();\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\tRF_ASSERT(pda != NULL);\n\t\trf_InitNode(&diskNodes[i], rf_wait, RF_FALSE, doFunc, undoFunc, rf_GenericWakeupFunc,\n\t\t    1, 1, 4, 0, dag_h, name, allocList);\n\t\tdiskNodes[i].params[0].p = pda;\n\t\tdiskNodes[i].params[1].p = pda->bufPtr;\n\t\t/* parity stripe id is not necessary */\n\t\tdiskNodes[i].params[2].v = 0;\n\t\tdiskNodes[i].params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, 0);\n\t\tpda = pda->next;\n\t}\n\n\t/*\n         * Connect nodes.\n         */\n\n\t/* connect hdr to block node */\n\tRF_ASSERT(blockNode->numAntecedents == 0);\n\tdag_h->succedents[0] = blockNode;\n\n\tif (type == RF_IO_TYPE_READ) {\n\t\t/* connecting a nonredundant read DAG */\n\t\tRF_ASSERT(blockNode->numSuccedents == n);\n\t\tRF_ASSERT(commitNode->numAntecedents == n);\n\t\tfor (i = 0; i < n; i++) {\n\t\t\t/* connect block node to each read node */\n\t\t\tRF_ASSERT(diskNodes[i].numAntecedents == 1);\n\t\t\tblockNode->succedents[i] = &diskNodes[i];\n\t\t\tdiskNodes[i].antecedents[0] = blockNode;\n\t\t\tdiskNodes[i].antType[0] = rf_control;\n\n\t\t\t/* connect each read node to the commit node */\n\t\t\tRF_ASSERT(diskNodes[i].numSuccedents == 1);\n\t\t\tdiskNodes[i].succedents[0] = commitNode;\n\t\t\tcommitNode->antecedents[i] = &diskNodes[i];\n\t\t\tcommitNode->antType[i] = rf_control;\n\t\t}\n\t\t/* connect the commit node to the term node */\n\t\tRF_ASSERT(commitNode->numSuccedents == 1);\n\t\tRF_ASSERT(termNode->numAntecedents == 1);\n\t\tRF_ASSERT(termNode->numSuccedents == 0);\n\t\tcommitNode->succedents[0] = termNode;\n\t\ttermNode->antecedents[0] = commitNode;\n\t\ttermNode->antType[0] = rf_control;\n\t} else {\n\t\t/* connecting a nonredundant write DAG */\n\t\t/* connect the block node to the commit node */\n\t\tRF_ASSERT(blockNode->numSuccedents == 1);\n\t\tRF_ASSERT(commitNode->numAntecedents == 1);\n\t\tblockNode->succedents[0] = commitNode;\n\t\tcommitNode->antecedents[0] = blockNode;\n\t\tcommitNode->antType[0] = rf_control;\n\n\t\tRF_ASSERT(commitNode->numSuccedents == n);\n\t\tRF_ASSERT(termNode->numAntecedents == n);\n\t\tRF_ASSERT(termNode->numSuccedents == 0);\n\t\tfor (i = 0; i < n; i++) {\n\t\t\t/* connect the commit node to each write node */\n\t\t\tRF_ASSERT(diskNodes[i].numAntecedents == 1);\n\t\t\tcommitNode->succedents[i] = &diskNodes[i];\n\t\t\tdiskNodes[i].antecedents[0] = commitNode;\n\t\t\tdiskNodes[i].antType[0] = rf_control;\n\n\t\t\t/* connect each write node to the term node */\n\t\t\tRF_ASSERT(diskNodes[i].numSuccedents == 1);\n\t\t\tdiskNodes[i].succedents[0] = termNode;\n\t\t\ttermNode->antecedents[i] = &diskNodes[i];\n\t\t\ttermNode->antType[i] = rf_control;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_memchunk.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "diskNodes[i].numSuccedents == 1"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "diskNodes[i].numAntecedents == 1"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "termNode->numSuccedents == 0"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "termNode->numAntecedents == n"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "commitNode->numSuccedents == n"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "commitNode->numAntecedents == 1"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "blockNode->numSuccedents == 1"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "termNode->numSuccedents == 0"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "termNode->numAntecedents == 1"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "commitNode->numSuccedents == 1"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "diskNodes[i].numSuccedents == 1"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "diskNodes[i].numAntecedents == 1"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "commitNode->numAntecedents == n"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "blockNode->numSuccedents == n"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "blockNode->numAntecedents == 0"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_CREATE_PARAM3",
          "args": [
            "RF_IO_NORMAL_PRIORITY",
            "0",
            "0",
            "0"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_InitNode",
          "args": [
            "&diskNodes[i]",
            "rf_wait",
            "RF_FALSE",
            "doFunc",
            "undoFunc",
            "rf_GenericWakeupFunc",
            "1",
            "1",
            "4",
            "0",
            "dag_h",
            "name",
            "allocList"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "rf_InitNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
          "lines": "74-143",
          "snippet": "void \nrf_InitNode(\n    RF_DagNode_t * node,\n    RF_NodeStatus_t initstatus,\n    int commit,\n    int (*doFunc) (RF_DagNode_t * node),\n    int (*undoFunc) (RF_DagNode_t * node),\n    int (*wakeFunc) (RF_DagNode_t * node, int status),\n    int nSucc,\n    int nAnte,\n    int nParam,\n    int nResult,\n    RF_DagHeader_t * hdr,\n    char *name,\n    RF_AllocListElem_t * alist)\n{\n\tvoid  **ptrs;\n\tint     nptrs;\n\n\tif (nAnte > RF_MAX_ANTECEDENTS)\n\t\tRF_PANIC();\n\tnode->status = initstatus;\n\tnode->commitNode = commit;\n\tnode->doFunc = doFunc;\n\tnode->undoFunc = undoFunc;\n\tnode->wakeFunc = wakeFunc;\n\tnode->numParams = nParam;\n\tnode->numResults = nResult;\n\tnode->numAntecedents = nAnte;\n\tnode->numAntDone = 0;\n\tnode->next = NULL;\n\tnode->numSuccedents = nSucc;\n\tnode->name = name;\n\tnode->dagHdr = hdr;\n\tnode->visited = 0;\n\n\t/* allocate all the pointers with one call to malloc */\n\tnptrs = nSucc + nAnte + nResult + nSucc;\n\n\tif (nptrs <= RF_DAG_PTRCACHESIZE) {\n\t\t/*\n\t         * The dag_ptrs field of the node is basically some scribble\n\t         * space to be used here. We could get rid of it, and always\n\t         * allocate the range of pointers, but that's expensive. So,\n\t         * we pick a \"common case\" size for the pointer cache. Hopefully,\n\t         * we'll find that:\n\t         * (1) Generally, nptrs doesn't exceed RF_DAG_PTRCACHESIZE by\n\t         *     only a little bit (least efficient case)\n\t         * (2) Generally, ntprs isn't a lot less than RF_DAG_PTRCACHESIZE\n\t         *     (wasted memory)\n\t         */\n\t\tptrs = (void **) node->dag_ptrs;\n\t} else {\n\t\tRF_CallocAndAdd(ptrs, nptrs, sizeof(void *), (void **), alist);\n\t}\n\tnode->succedents = (nSucc) ? (RF_DagNode_t **) ptrs : NULL;\n\tnode->antecedents = (nAnte) ? (RF_DagNode_t **) (ptrs + nSucc) : NULL;\n\tnode->results = (nResult) ? (void **) (ptrs + nSucc + nAnte) : NULL;\n\tnode->propList = (nSucc) ? (RF_PropHeader_t **) (ptrs + nSucc + nAnte + nResult) : NULL;\n\n\tif (nParam) {\n\t\tif (nParam <= RF_DAG_PARAMCACHESIZE) {\n\t\t\tnode->params = (RF_DagParam_t *) node->dag_params;\n\t\t} else {\n\t\t\tRF_CallocAndAdd(node->params, nParam, sizeof(RF_DagParam_t), (RF_DagParam_t *), alist);\n\t\t}\n\t} else {\n\t\tnode->params = NULL;\n\t}\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void rf_RecurPrintDAG(RF_DagNode_t *, int, int);",
            "static void rf_PrintDAG(RF_DagHeader_t *);",
            "static int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);",
            "static void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);",
            "static void rf_ValidateVisitedBits(RF_DagHeader_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_RecurPrintDAG(RF_DagNode_t *, int, int);\nstatic void rf_PrintDAG(RF_DagHeader_t *);\nstatic int \nrf_ValidateBranch(RF_DagNode_t *, int *, int *,\n    RF_DagNode_t **, int);\nstatic void rf_ValidateBranchVisitedBits(RF_DagNode_t *, int, int);\nstatic void rf_ValidateVisitedBits(RF_DagHeader_t *);\n\nvoid \nrf_InitNode(\n    RF_DagNode_t * node,\n    RF_NodeStatus_t initstatus,\n    int commit,\n    int (*doFunc) (RF_DagNode_t * node),\n    int (*undoFunc) (RF_DagNode_t * node),\n    int (*wakeFunc) (RF_DagNode_t * node, int status),\n    int nSucc,\n    int nAnte,\n    int nParam,\n    int nResult,\n    RF_DagHeader_t * hdr,\n    char *name,\n    RF_AllocListElem_t * alist)\n{\n\tvoid  **ptrs;\n\tint     nptrs;\n\n\tif (nAnte > RF_MAX_ANTECEDENTS)\n\t\tRF_PANIC();\n\tnode->status = initstatus;\n\tnode->commitNode = commit;\n\tnode->doFunc = doFunc;\n\tnode->undoFunc = undoFunc;\n\tnode->wakeFunc = wakeFunc;\n\tnode->numParams = nParam;\n\tnode->numResults = nResult;\n\tnode->numAntecedents = nAnte;\n\tnode->numAntDone = 0;\n\tnode->next = NULL;\n\tnode->numSuccedents = nSucc;\n\tnode->name = name;\n\tnode->dagHdr = hdr;\n\tnode->visited = 0;\n\n\t/* allocate all the pointers with one call to malloc */\n\tnptrs = nSucc + nAnte + nResult + nSucc;\n\n\tif (nptrs <= RF_DAG_PTRCACHESIZE) {\n\t\t/*\n\t         * The dag_ptrs field of the node is basically some scribble\n\t         * space to be used here. We could get rid of it, and always\n\t         * allocate the range of pointers, but that's expensive. So,\n\t         * we pick a \"common case\" size for the pointer cache. Hopefully,\n\t         * we'll find that:\n\t         * (1) Generally, nptrs doesn't exceed RF_DAG_PTRCACHESIZE by\n\t         *     only a little bit (least efficient case)\n\t         * (2) Generally, ntprs isn't a lot less than RF_DAG_PTRCACHESIZE\n\t         *     (wasted memory)\n\t         */\n\t\tptrs = (void **) node->dag_ptrs;\n\t} else {\n\t\tRF_CallocAndAdd(ptrs, nptrs, sizeof(void *), (void **), alist);\n\t}\n\tnode->succedents = (nSucc) ? (RF_DagNode_t **) ptrs : NULL;\n\tnode->antecedents = (nAnte) ? (RF_DagNode_t **) (ptrs + nSucc) : NULL;\n\tnode->results = (nResult) ? (void **) (ptrs + nSucc + nAnte) : NULL;\n\tnode->propList = (nSucc) ? (RF_PropHeader_t **) (ptrs + nSucc + nAnte + nResult) : NULL;\n\n\tif (nParam) {\n\t\tif (nParam <= RF_DAG_PARAMCACHESIZE) {\n\t\t\tnode->params = (RF_DagParam_t *) node->dag_params;\n\t\t} else {\n\t\t\tRF_CallocAndAdd(node->params, nParam, sizeof(RF_DagParam_t), (RF_DagParam_t *), alist);\n\t\t}\n\t} else {\n\t\tnode->params = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "pda != NULL"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_PANIC",
          "args": [],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "i == totalNumNodes"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_CallocAndAdd",
          "args": [
            "nodes",
            "totalNumNodes",
            "sizeof(RF_DagNode_t)",
            "(RF_DagNode_t *), allocList"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "n > 0"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_PANIC",
          "args": [],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"[Creating non-redundant write DAG]\\n\""
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "RF_IO_IS_R_OR_W(type)"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_IO_IS_R_OR_W",
          "args": [
            "type"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_dagffrd.h\"\n#include \"rf_general.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_CreateNonredundantDAG(\n    RF_Raid_t * raidPtr,\n    RF_AccessStripeMap_t * asmap,\n    RF_DagHeader_t * dag_h,\n    void *bp,\n    RF_RaidAccessFlags_t flags,\n    RF_AllocListElem_t * allocList,\n    RF_IoType_t type)\n{\n\tRF_DagNode_t *nodes, *diskNodes, *blockNode, *commitNode, *termNode;\n\tRF_PhysDiskAddr_t *pda = asmap->physInfo;\n\tint     (*doFunc) (RF_DagNode_t *), (*undoFunc) (RF_DagNode_t *);\n\tint     i, n, totalNumNodes;\n\tchar   *name;\n\n\tn = asmap->numStripeUnitsAccessed;\n\tdag_h->creator = \"NonredundantDAG\";\n\n\tRF_ASSERT(RF_IO_IS_R_OR_W(type));\n\tswitch (type) {\n\tcase RF_IO_TYPE_READ:\n\t\tdoFunc = rf_DiskReadFunc;\n\t\tundoFunc = rf_DiskReadUndoFunc;\n\t\tname = \"R  \";\n\t\tif (rf_dagDebug)\n\t\t\tprintf(\"[Creating non-redundant read DAG]\\n\");\n\t\tbreak;\n\tcase RF_IO_TYPE_WRITE:\n\t\tdoFunc = rf_DiskWriteFunc;\n\t\tundoFunc = rf_DiskWriteUndoFunc;\n\t\tname = \"W  \";\n\t\tif (rf_dagDebug)\n\t\t\tprintf(\"[Creating non-redundant write DAG]\\n\");\n\t\tbreak;\n\tdefault:\n\t\tRF_PANIC();\n\t}\n\n\t/*\n         * For reads, the dag can not commit until the block node is reached.\n         * for writes, the dag commits immediately.\n         */\n\tdag_h->numCommitNodes = 1;\n\tdag_h->numCommits = 0;\n\tdag_h->numSuccedents = 1;\n\n\t/*\n         * Node count:\n         * 1 block node\n         * n data reads (or writes)\n         * 1 commit node\n         * 1 terminator node\n         */\n\tRF_ASSERT(n > 0);\n\ttotalNumNodes = n + 3;\n\tRF_CallocAndAdd(nodes, totalNumNodes, sizeof(RF_DagNode_t),\n\t    (RF_DagNode_t *), allocList);\n\ti = 0;\n\tdiskNodes = &nodes[i];\n\ti += n;\n\tblockNode = &nodes[i];\n\ti += 1;\n\tcommitNode = &nodes[i];\n\ti += 1;\n\ttermNode = &nodes[i];\n\ti += 1;\n\tRF_ASSERT(i == totalNumNodes);\n\n\t/* initialize nodes */\n\tswitch (type) {\n\tcase RF_IO_TYPE_READ:\n\t\trf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc, rf_NullNodeUndoFunc,\n\t\t    NULL, n, 0, 0, 0, dag_h, \"Nil\", allocList);\n\t\trf_InitNode(commitNode, rf_wait, RF_TRUE, rf_NullNodeFunc, rf_NullNodeUndoFunc,\n\t\t    NULL, 1, n, 0, 0, dag_h, \"Cmt\", allocList);\n\t\trf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc, rf_TerminateUndoFunc,\n\t\t    NULL, 0, 1, 0, 0, dag_h, \"Trm\", allocList);\n\t\tbreak;\n\tcase RF_IO_TYPE_WRITE:\n\t\trf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc, rf_NullNodeUndoFunc,\n\t\t    NULL, 1, 0, 0, 0, dag_h, \"Nil\", allocList);\n\t\trf_InitNode(commitNode, rf_wait, RF_TRUE, rf_NullNodeFunc, rf_NullNodeUndoFunc,\n\t\t    NULL, n, 1, 0, 0, dag_h, \"Cmt\", allocList);\n\t\trf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc, rf_TerminateUndoFunc,\n\t\t    NULL, 0, n, 0, 0, dag_h, \"Trm\", allocList);\n\t\tbreak;\n\tdefault:\n\t\tRF_PANIC();\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\tRF_ASSERT(pda != NULL);\n\t\trf_InitNode(&diskNodes[i], rf_wait, RF_FALSE, doFunc, undoFunc, rf_GenericWakeupFunc,\n\t\t    1, 1, 4, 0, dag_h, name, allocList);\n\t\tdiskNodes[i].params[0].p = pda;\n\t\tdiskNodes[i].params[1].p = pda->bufPtr;\n\t\t/* parity stripe id is not necessary */\n\t\tdiskNodes[i].params[2].v = 0;\n\t\tdiskNodes[i].params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, 0);\n\t\tpda = pda->next;\n\t}\n\n\t/*\n         * Connect nodes.\n         */\n\n\t/* connect hdr to block node */\n\tRF_ASSERT(blockNode->numAntecedents == 0);\n\tdag_h->succedents[0] = blockNode;\n\n\tif (type == RF_IO_TYPE_READ) {\n\t\t/* connecting a nonredundant read DAG */\n\t\tRF_ASSERT(blockNode->numSuccedents == n);\n\t\tRF_ASSERT(commitNode->numAntecedents == n);\n\t\tfor (i = 0; i < n; i++) {\n\t\t\t/* connect block node to each read node */\n\t\t\tRF_ASSERT(diskNodes[i].numAntecedents == 1);\n\t\t\tblockNode->succedents[i] = &diskNodes[i];\n\t\t\tdiskNodes[i].antecedents[0] = blockNode;\n\t\t\tdiskNodes[i].antType[0] = rf_control;\n\n\t\t\t/* connect each read node to the commit node */\n\t\t\tRF_ASSERT(diskNodes[i].numSuccedents == 1);\n\t\t\tdiskNodes[i].succedents[0] = commitNode;\n\t\t\tcommitNode->antecedents[i] = &diskNodes[i];\n\t\t\tcommitNode->antType[i] = rf_control;\n\t\t}\n\t\t/* connect the commit node to the term node */\n\t\tRF_ASSERT(commitNode->numSuccedents == 1);\n\t\tRF_ASSERT(termNode->numAntecedents == 1);\n\t\tRF_ASSERT(termNode->numSuccedents == 0);\n\t\tcommitNode->succedents[0] = termNode;\n\t\ttermNode->antecedents[0] = commitNode;\n\t\ttermNode->antType[0] = rf_control;\n\t} else {\n\t\t/* connecting a nonredundant write DAG */\n\t\t/* connect the block node to the commit node */\n\t\tRF_ASSERT(blockNode->numSuccedents == 1);\n\t\tRF_ASSERT(commitNode->numAntecedents == 1);\n\t\tblockNode->succedents[0] = commitNode;\n\t\tcommitNode->antecedents[0] = blockNode;\n\t\tcommitNode->antType[0] = rf_control;\n\n\t\tRF_ASSERT(commitNode->numSuccedents == n);\n\t\tRF_ASSERT(termNode->numAntecedents == n);\n\t\tRF_ASSERT(termNode->numSuccedents == 0);\n\t\tfor (i = 0; i < n; i++) {\n\t\t\t/* connect the commit node to each write node */\n\t\t\tRF_ASSERT(diskNodes[i].numAntecedents == 1);\n\t\t\tcommitNode->succedents[i] = &diskNodes[i];\n\t\t\tdiskNodes[i].antecedents[0] = commitNode;\n\t\t\tdiskNodes[i].antType[0] = rf_control;\n\n\t\t\t/* connect each write node to the term node */\n\t\t\tRF_ASSERT(diskNodes[i].numSuccedents == 1);\n\t\t\tdiskNodes[i].succedents[0] = termNode;\n\t\t\ttermNode->antecedents[i] = &diskNodes[i];\n\t\t\ttermNode->antType[i] = rf_control;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "rf_CreateFaultFreeReadDAG",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagffrd.c",
    "lines": "74-85",
    "snippet": "void \nrf_CreateFaultFreeReadDAG(\n    RF_Raid_t * raidPtr,\n    RF_AccessStripeMap_t * asmap,\n    RF_DagHeader_t * dag_h,\n    void *bp,\n    RF_RaidAccessFlags_t flags,\n    RF_AllocListElem_t * allocList)\n{\n\trf_CreateNonredundantDAG(raidPtr, asmap, dag_h, bp, flags, allocList,\n\t    RF_IO_TYPE_READ);\n}",
    "includes": [
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_memchunk.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_CreateNonredundantDAG",
          "args": [
            "raidPtr",
            "asmap",
            "dag_h",
            "bp",
            "flags",
            "allocList",
            "RF_IO_TYPE_READ"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "rf_CreateNonredundantDAG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagffrd.c",
          "lines": "127-288",
          "snippet": "void \nrf_CreateNonredundantDAG(\n    RF_Raid_t * raidPtr,\n    RF_AccessStripeMap_t * asmap,\n    RF_DagHeader_t * dag_h,\n    void *bp,\n    RF_RaidAccessFlags_t flags,\n    RF_AllocListElem_t * allocList,\n    RF_IoType_t type)\n{\n\tRF_DagNode_t *nodes, *diskNodes, *blockNode, *commitNode, *termNode;\n\tRF_PhysDiskAddr_t *pda = asmap->physInfo;\n\tint     (*doFunc) (RF_DagNode_t *), (*undoFunc) (RF_DagNode_t *);\n\tint     i, n, totalNumNodes;\n\tchar   *name;\n\n\tn = asmap->numStripeUnitsAccessed;\n\tdag_h->creator = \"NonredundantDAG\";\n\n\tRF_ASSERT(RF_IO_IS_R_OR_W(type));\n\tswitch (type) {\n\tcase RF_IO_TYPE_READ:\n\t\tdoFunc = rf_DiskReadFunc;\n\t\tundoFunc = rf_DiskReadUndoFunc;\n\t\tname = \"R  \";\n\t\tif (rf_dagDebug)\n\t\t\tprintf(\"[Creating non-redundant read DAG]\\n\");\n\t\tbreak;\n\tcase RF_IO_TYPE_WRITE:\n\t\tdoFunc = rf_DiskWriteFunc;\n\t\tundoFunc = rf_DiskWriteUndoFunc;\n\t\tname = \"W  \";\n\t\tif (rf_dagDebug)\n\t\t\tprintf(\"[Creating non-redundant write DAG]\\n\");\n\t\tbreak;\n\tdefault:\n\t\tRF_PANIC();\n\t}\n\n\t/*\n         * For reads, the dag can not commit until the block node is reached.\n         * for writes, the dag commits immediately.\n         */\n\tdag_h->numCommitNodes = 1;\n\tdag_h->numCommits = 0;\n\tdag_h->numSuccedents = 1;\n\n\t/*\n         * Node count:\n         * 1 block node\n         * n data reads (or writes)\n         * 1 commit node\n         * 1 terminator node\n         */\n\tRF_ASSERT(n > 0);\n\ttotalNumNodes = n + 3;\n\tRF_CallocAndAdd(nodes, totalNumNodes, sizeof(RF_DagNode_t),\n\t    (RF_DagNode_t *), allocList);\n\ti = 0;\n\tdiskNodes = &nodes[i];\n\ti += n;\n\tblockNode = &nodes[i];\n\ti += 1;\n\tcommitNode = &nodes[i];\n\ti += 1;\n\ttermNode = &nodes[i];\n\ti += 1;\n\tRF_ASSERT(i == totalNumNodes);\n\n\t/* initialize nodes */\n\tswitch (type) {\n\tcase RF_IO_TYPE_READ:\n\t\trf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc, rf_NullNodeUndoFunc,\n\t\t    NULL, n, 0, 0, 0, dag_h, \"Nil\", allocList);\n\t\trf_InitNode(commitNode, rf_wait, RF_TRUE, rf_NullNodeFunc, rf_NullNodeUndoFunc,\n\t\t    NULL, 1, n, 0, 0, dag_h, \"Cmt\", allocList);\n\t\trf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc, rf_TerminateUndoFunc,\n\t\t    NULL, 0, 1, 0, 0, dag_h, \"Trm\", allocList);\n\t\tbreak;\n\tcase RF_IO_TYPE_WRITE:\n\t\trf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc, rf_NullNodeUndoFunc,\n\t\t    NULL, 1, 0, 0, 0, dag_h, \"Nil\", allocList);\n\t\trf_InitNode(commitNode, rf_wait, RF_TRUE, rf_NullNodeFunc, rf_NullNodeUndoFunc,\n\t\t    NULL, n, 1, 0, 0, dag_h, \"Cmt\", allocList);\n\t\trf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc, rf_TerminateUndoFunc,\n\t\t    NULL, 0, n, 0, 0, dag_h, \"Trm\", allocList);\n\t\tbreak;\n\tdefault:\n\t\tRF_PANIC();\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\tRF_ASSERT(pda != NULL);\n\t\trf_InitNode(&diskNodes[i], rf_wait, RF_FALSE, doFunc, undoFunc, rf_GenericWakeupFunc,\n\t\t    1, 1, 4, 0, dag_h, name, allocList);\n\t\tdiskNodes[i].params[0].p = pda;\n\t\tdiskNodes[i].params[1].p = pda->bufPtr;\n\t\t/* parity stripe id is not necessary */\n\t\tdiskNodes[i].params[2].v = 0;\n\t\tdiskNodes[i].params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, 0);\n\t\tpda = pda->next;\n\t}\n\n\t/*\n         * Connect nodes.\n         */\n\n\t/* connect hdr to block node */\n\tRF_ASSERT(blockNode->numAntecedents == 0);\n\tdag_h->succedents[0] = blockNode;\n\n\tif (type == RF_IO_TYPE_READ) {\n\t\t/* connecting a nonredundant read DAG */\n\t\tRF_ASSERT(blockNode->numSuccedents == n);\n\t\tRF_ASSERT(commitNode->numAntecedents == n);\n\t\tfor (i = 0; i < n; i++) {\n\t\t\t/* connect block node to each read node */\n\t\t\tRF_ASSERT(diskNodes[i].numAntecedents == 1);\n\t\t\tblockNode->succedents[i] = &diskNodes[i];\n\t\t\tdiskNodes[i].antecedents[0] = blockNode;\n\t\t\tdiskNodes[i].antType[0] = rf_control;\n\n\t\t\t/* connect each read node to the commit node */\n\t\t\tRF_ASSERT(diskNodes[i].numSuccedents == 1);\n\t\t\tdiskNodes[i].succedents[0] = commitNode;\n\t\t\tcommitNode->antecedents[i] = &diskNodes[i];\n\t\t\tcommitNode->antType[i] = rf_control;\n\t\t}\n\t\t/* connect the commit node to the term node */\n\t\tRF_ASSERT(commitNode->numSuccedents == 1);\n\t\tRF_ASSERT(termNode->numAntecedents == 1);\n\t\tRF_ASSERT(termNode->numSuccedents == 0);\n\t\tcommitNode->succedents[0] = termNode;\n\t\ttermNode->antecedents[0] = commitNode;\n\t\ttermNode->antType[0] = rf_control;\n\t} else {\n\t\t/* connecting a nonredundant write DAG */\n\t\t/* connect the block node to the commit node */\n\t\tRF_ASSERT(blockNode->numSuccedents == 1);\n\t\tRF_ASSERT(commitNode->numAntecedents == 1);\n\t\tblockNode->succedents[0] = commitNode;\n\t\tcommitNode->antecedents[0] = blockNode;\n\t\tcommitNode->antType[0] = rf_control;\n\n\t\tRF_ASSERT(commitNode->numSuccedents == n);\n\t\tRF_ASSERT(termNode->numAntecedents == n);\n\t\tRF_ASSERT(termNode->numSuccedents == 0);\n\t\tfor (i = 0; i < n; i++) {\n\t\t\t/* connect the commit node to each write node */\n\t\t\tRF_ASSERT(diskNodes[i].numAntecedents == 1);\n\t\t\tcommitNode->succedents[i] = &diskNodes[i];\n\t\t\tdiskNodes[i].antecedents[0] = commitNode;\n\t\t\tdiskNodes[i].antType[0] = rf_control;\n\n\t\t\t/* connect each write node to the term node */\n\t\t\tRF_ASSERT(diskNodes[i].numSuccedents == 1);\n\t\t\tdiskNodes[i].succedents[0] = termNode;\n\t\t\ttermNode->antecedents[i] = &diskNodes[i];\n\t\t\ttermNode->antType[i] = rf_control;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_memchunk.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_dagffrd.h\"\n#include \"rf_general.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_CreateNonredundantDAG(\n    RF_Raid_t * raidPtr,\n    RF_AccessStripeMap_t * asmap,\n    RF_DagHeader_t * dag_h,\n    void *bp,\n    RF_RaidAccessFlags_t flags,\n    RF_AllocListElem_t * allocList,\n    RF_IoType_t type)\n{\n\tRF_DagNode_t *nodes, *diskNodes, *blockNode, *commitNode, *termNode;\n\tRF_PhysDiskAddr_t *pda = asmap->physInfo;\n\tint     (*doFunc) (RF_DagNode_t *), (*undoFunc) (RF_DagNode_t *);\n\tint     i, n, totalNumNodes;\n\tchar   *name;\n\n\tn = asmap->numStripeUnitsAccessed;\n\tdag_h->creator = \"NonredundantDAG\";\n\n\tRF_ASSERT(RF_IO_IS_R_OR_W(type));\n\tswitch (type) {\n\tcase RF_IO_TYPE_READ:\n\t\tdoFunc = rf_DiskReadFunc;\n\t\tundoFunc = rf_DiskReadUndoFunc;\n\t\tname = \"R  \";\n\t\tif (rf_dagDebug)\n\t\t\tprintf(\"[Creating non-redundant read DAG]\\n\");\n\t\tbreak;\n\tcase RF_IO_TYPE_WRITE:\n\t\tdoFunc = rf_DiskWriteFunc;\n\t\tundoFunc = rf_DiskWriteUndoFunc;\n\t\tname = \"W  \";\n\t\tif (rf_dagDebug)\n\t\t\tprintf(\"[Creating non-redundant write DAG]\\n\");\n\t\tbreak;\n\tdefault:\n\t\tRF_PANIC();\n\t}\n\n\t/*\n         * For reads, the dag can not commit until the block node is reached.\n         * for writes, the dag commits immediately.\n         */\n\tdag_h->numCommitNodes = 1;\n\tdag_h->numCommits = 0;\n\tdag_h->numSuccedents = 1;\n\n\t/*\n         * Node count:\n         * 1 block node\n         * n data reads (or writes)\n         * 1 commit node\n         * 1 terminator node\n         */\n\tRF_ASSERT(n > 0);\n\ttotalNumNodes = n + 3;\n\tRF_CallocAndAdd(nodes, totalNumNodes, sizeof(RF_DagNode_t),\n\t    (RF_DagNode_t *), allocList);\n\ti = 0;\n\tdiskNodes = &nodes[i];\n\ti += n;\n\tblockNode = &nodes[i];\n\ti += 1;\n\tcommitNode = &nodes[i];\n\ti += 1;\n\ttermNode = &nodes[i];\n\ti += 1;\n\tRF_ASSERT(i == totalNumNodes);\n\n\t/* initialize nodes */\n\tswitch (type) {\n\tcase RF_IO_TYPE_READ:\n\t\trf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc, rf_NullNodeUndoFunc,\n\t\t    NULL, n, 0, 0, 0, dag_h, \"Nil\", allocList);\n\t\trf_InitNode(commitNode, rf_wait, RF_TRUE, rf_NullNodeFunc, rf_NullNodeUndoFunc,\n\t\t    NULL, 1, n, 0, 0, dag_h, \"Cmt\", allocList);\n\t\trf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc, rf_TerminateUndoFunc,\n\t\t    NULL, 0, 1, 0, 0, dag_h, \"Trm\", allocList);\n\t\tbreak;\n\tcase RF_IO_TYPE_WRITE:\n\t\trf_InitNode(blockNode, rf_wait, RF_FALSE, rf_NullNodeFunc, rf_NullNodeUndoFunc,\n\t\t    NULL, 1, 0, 0, 0, dag_h, \"Nil\", allocList);\n\t\trf_InitNode(commitNode, rf_wait, RF_TRUE, rf_NullNodeFunc, rf_NullNodeUndoFunc,\n\t\t    NULL, n, 1, 0, 0, dag_h, \"Cmt\", allocList);\n\t\trf_InitNode(termNode, rf_wait, RF_FALSE, rf_TerminateFunc, rf_TerminateUndoFunc,\n\t\t    NULL, 0, n, 0, 0, dag_h, \"Trm\", allocList);\n\t\tbreak;\n\tdefault:\n\t\tRF_PANIC();\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\tRF_ASSERT(pda != NULL);\n\t\trf_InitNode(&diskNodes[i], rf_wait, RF_FALSE, doFunc, undoFunc, rf_GenericWakeupFunc,\n\t\t    1, 1, 4, 0, dag_h, name, allocList);\n\t\tdiskNodes[i].params[0].p = pda;\n\t\tdiskNodes[i].params[1].p = pda->bufPtr;\n\t\t/* parity stripe id is not necessary */\n\t\tdiskNodes[i].params[2].v = 0;\n\t\tdiskNodes[i].params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, 0);\n\t\tpda = pda->next;\n\t}\n\n\t/*\n         * Connect nodes.\n         */\n\n\t/* connect hdr to block node */\n\tRF_ASSERT(blockNode->numAntecedents == 0);\n\tdag_h->succedents[0] = blockNode;\n\n\tif (type == RF_IO_TYPE_READ) {\n\t\t/* connecting a nonredundant read DAG */\n\t\tRF_ASSERT(blockNode->numSuccedents == n);\n\t\tRF_ASSERT(commitNode->numAntecedents == n);\n\t\tfor (i = 0; i < n; i++) {\n\t\t\t/* connect block node to each read node */\n\t\t\tRF_ASSERT(diskNodes[i].numAntecedents == 1);\n\t\t\tblockNode->succedents[i] = &diskNodes[i];\n\t\t\tdiskNodes[i].antecedents[0] = blockNode;\n\t\t\tdiskNodes[i].antType[0] = rf_control;\n\n\t\t\t/* connect each read node to the commit node */\n\t\t\tRF_ASSERT(diskNodes[i].numSuccedents == 1);\n\t\t\tdiskNodes[i].succedents[0] = commitNode;\n\t\t\tcommitNode->antecedents[i] = &diskNodes[i];\n\t\t\tcommitNode->antType[i] = rf_control;\n\t\t}\n\t\t/* connect the commit node to the term node */\n\t\tRF_ASSERT(commitNode->numSuccedents == 1);\n\t\tRF_ASSERT(termNode->numAntecedents == 1);\n\t\tRF_ASSERT(termNode->numSuccedents == 0);\n\t\tcommitNode->succedents[0] = termNode;\n\t\ttermNode->antecedents[0] = commitNode;\n\t\ttermNode->antType[0] = rf_control;\n\t} else {\n\t\t/* connecting a nonredundant write DAG */\n\t\t/* connect the block node to the commit node */\n\t\tRF_ASSERT(blockNode->numSuccedents == 1);\n\t\tRF_ASSERT(commitNode->numAntecedents == 1);\n\t\tblockNode->succedents[0] = commitNode;\n\t\tcommitNode->antecedents[0] = blockNode;\n\t\tcommitNode->antType[0] = rf_control;\n\n\t\tRF_ASSERT(commitNode->numSuccedents == n);\n\t\tRF_ASSERT(termNode->numAntecedents == n);\n\t\tRF_ASSERT(termNode->numSuccedents == 0);\n\t\tfor (i = 0; i < n; i++) {\n\t\t\t/* connect the commit node to each write node */\n\t\t\tRF_ASSERT(diskNodes[i].numAntecedents == 1);\n\t\t\tcommitNode->succedents[i] = &diskNodes[i];\n\t\t\tdiskNodes[i].antecedents[0] = commitNode;\n\t\t\tdiskNodes[i].antType[0] = rf_control;\n\n\t\t\t/* connect each write node to the term node */\n\t\t\tRF_ASSERT(diskNodes[i].numSuccedents == 1);\n\t\t\tdiskNodes[i].succedents[0] = termNode;\n\t\t\ttermNode->antecedents[i] = &diskNodes[i];\n\t\t\ttermNode->antType[i] = rf_control;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_dagffrd.h\"\n#include \"rf_general.h\"\n#include \"rf_memchunk.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_CreateFaultFreeReadDAG(\n    RF_Raid_t * raidPtr,\n    RF_AccessStripeMap_t * asmap,\n    RF_DagHeader_t * dag_h,\n    void *bp,\n    RF_RaidAccessFlags_t flags,\n    RF_AllocListElem_t * allocList)\n{\n\trf_CreateNonredundantDAG(raidPtr, asmap, dag_h, bp, flags, allocList,\n\t    RF_IO_TYPE_READ);\n}"
  }
]