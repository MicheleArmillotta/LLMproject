[
  {
    "function_name": "ipkdbprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ofw/ofnet.c",
    "lines": "435-470",
    "snippet": "static int\nipkdbprobe(match, aux)\n\tvoid *match, *aux;\n{\n\tstruct cfdata *cf = match;\n\tstruct ipkdb_if *kip = aux;\n\tstatic char name[256];\n\tint len;\n\tint phandle;\n\t\n\tkip->unit = cf->cf_unit + 1;\n\n\tif (!(kip->port = OF_open(\"net\")))\n\t\treturn -1;\n\tif ((len = OF_instance_to_path(kip->port, name, sizeof name - 1)) < 0\n\t    || len >= sizeof name)\n\t\treturn -1;\n\tname[len] = 0;\n\tif ((phandle = OF_instance_to_package(kip->port)) == -1)\n\t\treturn -1;\n\tif ( OF_getprop(phandle, \"local-mac-address\", kip->myenetaddr, sizeof kip->myenetaddr) &&\n\tOF_getprop(phandle, \"mac-address\", kip->myenetaddr, sizeof kip->myenetaddr)\n\t    < 0)\n\t\treturn -1;\n\t\n\tkip->flags |= IPKDB_MYHW;\n\tkip->name = name;\n\tkip->start = ipkdbofstart;\n\tkip->leave = ipkdbofleave;\n\tkip->receive = ipkdbofrcv;\n\tkip->send = ipkdbofsend;\n\n\tkifp = kip;\n\t\n\treturn 0;\n}",
    "includes": [
      "#include <machine/ipkdb.h>",
      "#include <ipkdb/ipkdb.h>",
      "#include <dev/ofw/openfirm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"ofnet.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "OF_getprop",
          "args": [
            "phandle",
            "\"mac-address\"",
            "kip->myenetaddr",
            "sizeof kip->myenetaddr"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OF_getprop",
          "args": [
            "phandle",
            "\"local-mac-address\"",
            "kip->myenetaddr",
            "sizeof kip->myenetaddr"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OF_instance_to_package",
          "args": [
            "kip->port"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OF_instance_to_path",
          "args": [
            "kip->port",
            "name",
            "sizeof name - 1"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OF_open",
          "args": [
            "\"net\""
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/ipkdb.h>\n#include <ipkdb/ipkdb.h>\n#include <dev/ofw/openfirm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ofnet.h\"\n\nstatic int\nipkdbprobe(match, aux)\n\tvoid *match, *aux;\n{\n\tstruct cfdata *cf = match;\n\tstruct ipkdb_if *kip = aux;\n\tstatic char name[256];\n\tint len;\n\tint phandle;\n\t\n\tkip->unit = cf->cf_unit + 1;\n\n\tif (!(kip->port = OF_open(\"net\")))\n\t\treturn -1;\n\tif ((len = OF_instance_to_path(kip->port, name, sizeof name - 1)) < 0\n\t    || len >= sizeof name)\n\t\treturn -1;\n\tname[len] = 0;\n\tif ((phandle = OF_instance_to_package(kip->port)) == -1)\n\t\treturn -1;\n\tif ( OF_getprop(phandle, \"local-mac-address\", kip->myenetaddr, sizeof kip->myenetaddr) &&\n\tOF_getprop(phandle, \"mac-address\", kip->myenetaddr, sizeof kip->myenetaddr)\n\t    < 0)\n\t\treturn -1;\n\t\n\tkip->flags |= IPKDB_MYHW;\n\tkip->name = name;\n\tkip->start = ipkdbofstart;\n\tkip->leave = ipkdbofleave;\n\tkip->receive = ipkdbofrcv;\n\tkip->send = ipkdbofsend;\n\n\tkifp = kip;\n\t\n\treturn 0;\n}"
  },
  {
    "function_name": "ipkdbofsend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ofw/ofnet.c",
    "lines": "426-433",
    "snippet": "static void\nipkdbofsend(kip, buf, l)\n\tstruct ipkdb_if *kip;\n\tu_char *buf;\n\tint l;\n{\n\tOF_write(kip->port, buf, l);\n}",
    "includes": [
      "#include <machine/ipkdb.h>",
      "#include <ipkdb/ipkdb.h>",
      "#include <dev/ofw/openfirm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"ofnet.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "OF_write",
          "args": [
            "kip->port",
            "buf",
            "l"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/ipkdb.h>\n#include <ipkdb/ipkdb.h>\n#include <dev/ofw/openfirm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ofnet.h\"\n\nstatic void\nipkdbofsend(kip, buf, l)\n\tstruct ipkdb_if *kip;\n\tu_char *buf;\n\tint l;\n{\n\tOF_write(kip->port, buf, l);\n}"
  },
  {
    "function_name": "ipkdbofrcv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ofw/ofnet.c",
    "lines": "410-424",
    "snippet": "static int\nipkdbofrcv(kip, buf, poll)\n\tstruct ipkdb_if *kip;\n\tu_char *buf;\n\tint poll;\n{\n\tint l;\n\t\n\tdo {\n\t\tl = OF_read(kip->port, buf, ETHERMTU);\n\t\tif (l < 0)\n\t\t\tl = 0;\n\t} while (!poll && !l);\n\treturn l;\n}",
    "includes": [
      "#include <machine/ipkdb.h>",
      "#include <ipkdb/ipkdb.h>",
      "#include <dev/ofw/openfirm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"ofnet.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "OF_read",
          "args": [
            "kip->port",
            "buf",
            "ETHERMTU"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/ipkdb.h>\n#include <ipkdb/ipkdb.h>\n#include <dev/ofw/openfirm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ofnet.h\"\n\nstatic int\nipkdbofrcv(kip, buf, poll)\n\tstruct ipkdb_if *kip;\n\tu_char *buf;\n\tint poll;\n{\n\tint l;\n\t\n\tdo {\n\t\tl = OF_read(kip->port, buf, ETHERMTU);\n\t\tif (l < 0)\n\t\t\tl = 0;\n\t} while (!poll && !l);\n\treturn l;\n}"
  },
  {
    "function_name": "ipkdbofleave",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ofw/ofnet.c",
    "lines": "404-408",
    "snippet": "static void\nipkdbofleave(kip)\n\tstruct ipkdb_if *kip;\n{\n}",
    "includes": [
      "#include <machine/ipkdb.h>",
      "#include <ipkdb/ipkdb.h>",
      "#include <dev/ofw/openfirm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"ofnet.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <machine/ipkdb.h>\n#include <ipkdb/ipkdb.h>\n#include <dev/ofw/openfirm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ofnet.h\"\n\nstatic void\nipkdbofleave(kip)\n\tstruct ipkdb_if *kip;\n{\n}"
  },
  {
    "function_name": "ipkdbofstart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ofw/ofnet.c",
    "lines": "394-402",
    "snippet": "static void\nipkdbofstart(kip)\n\tstruct ipkdb_if *kip;\n{\n\tint unit = kip->unit - 1;\n\t\n\tif (ipkdb_of)\n\t\tipkdbattach(kip, &ipkdb_of->sc_arpcom);\n}",
    "includes": [
      "#include <machine/ipkdb.h>",
      "#include <ipkdb/ipkdb.h>",
      "#include <dev/ofw/openfirm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"ofnet.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ipkdbattach",
          "args": [
            "kip",
            "&ipkdb_of->sc_arpcom"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/ipkdb.h>\n#include <ipkdb/ipkdb.h>\n#include <dev/ofw/openfirm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ofnet.h\"\n\nstatic void\nipkdbofstart(kip)\n\tstruct ipkdb_if *kip;\n{\n\tint unit = kip->unit - 1;\n\t\n\tif (ipkdb_of)\n\t\tipkdbattach(kip, &ipkdb_of->sc_arpcom);\n}"
  },
  {
    "function_name": "ofnwatchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ofw/ofnet.c",
    "lines": "380-390",
    "snippet": "static void\nofnwatchdog(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct ofn_softc *of = ifp->if_softc;\n\t\n\tlog(LOG_ERR, \"%s: device timeout\\n\", of->sc_dev.dv_xname);\n\tof->sc_arpcom.ac_if.if_oerrors++;\n\tofnstop(of);\n\tofninit(of);\n}",
    "includes": [
      "#include <machine/ipkdb.h>",
      "#include <ipkdb/ipkdb.h>",
      "#include <dev/ofw/openfirm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"ofnet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ofninit",
      "static void ofnstop",
      "static void ofnwatchdog"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ofninit",
          "args": [
            "of"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "ofninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ofw/ofnet.c",
          "lines": "260-274",
          "snippet": "static void\nofninit(of)\n\tstruct ofn_softc *of;\n{\n\tstruct ifnet *ifp = &of->sc_arpcom.ac_if;\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\treturn;\n\n\tifp->if_flags |= IFF_RUNNING;\n\t/* Start reading from interface */\n\tofntimer(of);\n\t/* Attempt to start output */\n\tofnstart(ifp);\n}",
          "includes": [
            "#include <machine/ipkdb.h>",
            "#include <ipkdb/ipkdb.h>",
            "#include <dev/ofw/openfirm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"ofnet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ofntimer",
            "static void ofninit",
            "static void ofnstart"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/ipkdb.h>\n#include <ipkdb/ipkdb.h>\n#include <dev/ofw/openfirm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ofnet.h\"\n\nstatic void ofntimer;\nstatic void ofninit;\nstatic void ofnstart;\n\nstatic void\nofninit(of)\n\tstruct ofn_softc *of;\n{\n\tstruct ifnet *ifp = &of->sc_arpcom.ac_if;\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\treturn;\n\n\tifp->if_flags |= IFF_RUNNING;\n\t/* Start reading from interface */\n\tofntimer(of);\n\t/* Attempt to start output */\n\tofnstart(ifp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ofnstop",
          "args": [
            "of"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "ofnstop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ofw/ofnet.c",
          "lines": "276-282",
          "snippet": "static void\nofnstop(of)\n\tstruct ofn_softc *of;\n{\n\tuntimeout(ofntimer, of);\n\tof->sc_arpcom.ac_if.if_flags &= ~IFF_RUNNING;\n}",
          "includes": [
            "#include <machine/ipkdb.h>",
            "#include <ipkdb/ipkdb.h>",
            "#include <dev/ofw/openfirm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"ofnet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ofntimer",
            "static void ofnstop"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/ipkdb.h>\n#include <ipkdb/ipkdb.h>\n#include <dev/ofw/openfirm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ofnet.h\"\n\nstatic void ofntimer;\nstatic void ofnstop;\n\nstatic void\nofnstop(of)\n\tstruct ofn_softc *of;\n{\n\tuntimeout(ofntimer, of);\n\tof->sc_arpcom.ac_if.if_flags &= ~IFF_RUNNING;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_ERR",
            "\"%s: device timeout\\n\"",
            "of->sc_dev.dv_xname"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_log_hard_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5909-5956",
          "snippet": "static void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "int\ti;",
            "ncb_p np = (struct ncb*) 0;",
            "int\ti;",
            "u_int8_t\tistat, dstat;",
            "u_int16_t\tsist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nint\ti;\nncb_p np = (struct ncb*) 0;\nint\ti;\nu_int8_t\tistat, dstat;\nu_int16_t\tsist;\n\nstatic void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/ipkdb.h>\n#include <ipkdb/ipkdb.h>\n#include <dev/ofw/openfirm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ofnet.h\"\n\nstatic void ofninit;\nstatic void ofnstop;\nstatic void ofnwatchdog;\n\nstatic void\nofnwatchdog(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct ofn_softc *of = ifp->if_softc;\n\t\n\tlog(LOG_ERR, \"%s: device timeout\\n\", of->sc_dev.dv_xname);\n\tof->sc_arpcom.ac_if.if_oerrors++;\n\tofnstop(of);\n\tofninit(of);\n}"
  },
  {
    "function_name": "ofnioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ofw/ofnet.c",
    "lines": "334-378",
    "snippet": "static int\nofnioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct ofn_softc *of = ifp->if_softc;\n\tstruct ifaddr *ifa = (struct ifaddr *)data;\n\tstruct ifreq *ifr = (struct ifreq *)data;\n\tint error = 0;\n\t\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\t\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef\tINET\n\t\tcase AF_INET:\n\t\t\tarp_ifinit(&of->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tofninit(of);\n\t\tbreak;\n\tcase SIOCSIFFLAGS:\n\t\tif (!(ifp->if_flags & IFF_UP)\n\t\t    && (ifp->if_flags & IFF_RUNNING)) {\n\t\t\t/* If interface is down, but running, stop it. */\n\t\t\tofnstop(of);\n\t\t} else if ((ifp->if_flags & IFF_UP)\n\t\t\t   && !(ifp->if_flags & IFF_RUNNING)) {\n\t\t\t/* If interface is up, but not running, start it. */\n\t\t\tofninit(of);\n\t\t} else {\n\t\t\t/* Other flags are ignored. */\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\treturn error;\n}",
    "includes": [
      "#include <machine/ipkdb.h>",
      "#include <ipkdb/ipkdb.h>",
      "#include <dev/ofw/openfirm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"ofnet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ofninit",
      "static void ofnstop",
      "static int ofnioctl"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ofninit",
          "args": [
            "of"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "ofninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ofw/ofnet.c",
          "lines": "260-274",
          "snippet": "static void\nofninit(of)\n\tstruct ofn_softc *of;\n{\n\tstruct ifnet *ifp = &of->sc_arpcom.ac_if;\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\treturn;\n\n\tifp->if_flags |= IFF_RUNNING;\n\t/* Start reading from interface */\n\tofntimer(of);\n\t/* Attempt to start output */\n\tofnstart(ifp);\n}",
          "includes": [
            "#include <machine/ipkdb.h>",
            "#include <ipkdb/ipkdb.h>",
            "#include <dev/ofw/openfirm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"ofnet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ofntimer",
            "static void ofninit",
            "static void ofnstart"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/ipkdb.h>\n#include <ipkdb/ipkdb.h>\n#include <dev/ofw/openfirm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ofnet.h\"\n\nstatic void ofntimer;\nstatic void ofninit;\nstatic void ofnstart;\n\nstatic void\nofninit(of)\n\tstruct ofn_softc *of;\n{\n\tstruct ifnet *ifp = &of->sc_arpcom.ac_if;\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\treturn;\n\n\tifp->if_flags |= IFF_RUNNING;\n\t/* Start reading from interface */\n\tofntimer(of);\n\t/* Attempt to start output */\n\tofnstart(ifp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ofnstop",
          "args": [
            "of"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "ofnstop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ofw/ofnet.c",
          "lines": "276-282",
          "snippet": "static void\nofnstop(of)\n\tstruct ofn_softc *of;\n{\n\tuntimeout(ofntimer, of);\n\tof->sc_arpcom.ac_if.if_flags &= ~IFF_RUNNING;\n}",
          "includes": [
            "#include <machine/ipkdb.h>",
            "#include <ipkdb/ipkdb.h>",
            "#include <dev/ofw/openfirm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"ofnet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ofntimer",
            "static void ofnstop"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/ipkdb.h>\n#include <ipkdb/ipkdb.h>\n#include <dev/ofw/openfirm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ofnet.h\"\n\nstatic void ofntimer;\nstatic void ofnstop;\n\nstatic void\nofnstop(of)\n\tstruct ofn_softc *of;\n{\n\tuntimeout(ofntimer, of);\n\tof->sc_arpcom.ac_if.if_flags &= ~IFF_RUNNING;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arp_ifinit",
          "args": [
            "&of->sc_arpcom",
            "ifa"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "arp_ifinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_devar.h",
          "lines": "929-936",
          "snippet": "static void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}",
          "includes": [
            "#include <sys/devconf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/devconf.h>\n\nstatic void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/ipkdb.h>\n#include <ipkdb/ipkdb.h>\n#include <dev/ofw/openfirm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ofnet.h\"\n\nstatic void ofninit;\nstatic void ofnstop;\nstatic int ofnioctl;\n\nstatic int\nofnioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct ofn_softc *of = ifp->if_softc;\n\tstruct ifaddr *ifa = (struct ifaddr *)data;\n\tstruct ifreq *ifr = (struct ifreq *)data;\n\tint error = 0;\n\t\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\t\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef\tINET\n\t\tcase AF_INET:\n\t\t\tarp_ifinit(&of->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tofninit(of);\n\t\tbreak;\n\tcase SIOCSIFFLAGS:\n\t\tif (!(ifp->if_flags & IFF_UP)\n\t\t    && (ifp->if_flags & IFF_RUNNING)) {\n\t\t\t/* If interface is down, but running, stop it. */\n\t\t\tofnstop(of);\n\t\t} else if ((ifp->if_flags & IFF_UP)\n\t\t\t   && !(ifp->if_flags & IFF_RUNNING)) {\n\t\t\t/* If interface is up, but not running, start it. */\n\t\t\tofninit(of);\n\t\t} else {\n\t\t\t/* Other flags are ignored. */\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "ofnstart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ofw/ofnet.c",
    "lines": "284-332",
    "snippet": "static void\nofnstart(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct ofn_softc *of = ifp->if_softc;\n\tstruct mbuf *m, *m0;\n\tchar *bufp;\n\tchar *buf;\n\tint len;\n\tbuf = of->dmabuf;\n\t\n\tif (!(ifp->if_flags & IFF_RUNNING))\n\t\treturn;\n\n\tfor (;;) {\n\t\t/* First try reading any packets */\n\t\tofnread(of);\n\t\t\n\t\t/* Now get the first packet on the queue */\n\t\tIF_DEQUEUE(&ifp->if_snd, m0);\n\t\tif (!m0)\n\t\t\treturn;\n\t\t\n\t\tif (!(m0->m_flags & M_PKTHDR))\n\t\t\tpanic(\"ofnstart: no header mbuf\");\n\t\tlen = m0->m_pkthdr.len;\n\t\t\n\t\tif (len > ETHERMTU + sizeof(struct ether_header)) {\n\t\t\t/* packet too large, toss it */\n\t\t\tifp->if_oerrors++;\n\t\t\tm_freem(m0);\n\t\t\tcontinue;\n\t\t}\n\n#if NPBFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtab(ifp->if_bpf, m0);\n#endif\n\t\tfor (bufp = buf; m = m0;) {\n\t\t\tbcopy(mtod(m, char *), bufp, m->m_len);\n\t\t\tbufp += m->m_len;\n\t\t\tMFREE(m, m0);\n\t\t}\n\t\tif (OF_write(of->sc_ihandle, buf, bufp - buf) != bufp - buf)\n\t\t\tifp->if_oerrors++;\n\t\telse\n\t\t\tifp->if_opackets++;\n\t}\n}",
    "includes": [
      "#include <machine/ipkdb.h>",
      "#include <ipkdb/ipkdb.h>",
      "#include <dev/ofw/openfirm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"ofnet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ofnread",
      "static void ofnstart"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "OF_write",
          "args": [
            "of->sc_ihandle",
            "buf",
            "bufp - buf"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MFREE",
          "args": [
            "m",
            "m0"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtab",
          "args": [
            "ifp->if_bpf",
            "m0"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m0"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ofnstart: no header mbuf\""
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "m0"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ofnread",
          "args": [
            "of"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/ipkdb.h>\n#include <ipkdb/ipkdb.h>\n#include <dev/ofw/openfirm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ofnet.h\"\n\nstatic void ofnread;\nstatic void ofnstart;\n\nstatic void\nofnstart(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct ofn_softc *of = ifp->if_softc;\n\tstruct mbuf *m, *m0;\n\tchar *bufp;\n\tchar *buf;\n\tint len;\n\tbuf = of->dmabuf;\n\t\n\tif (!(ifp->if_flags & IFF_RUNNING))\n\t\treturn;\n\n\tfor (;;) {\n\t\t/* First try reading any packets */\n\t\tofnread(of);\n\t\t\n\t\t/* Now get the first packet on the queue */\n\t\tIF_DEQUEUE(&ifp->if_snd, m0);\n\t\tif (!m0)\n\t\t\treturn;\n\t\t\n\t\tif (!(m0->m_flags & M_PKTHDR))\n\t\t\tpanic(\"ofnstart: no header mbuf\");\n\t\tlen = m0->m_pkthdr.len;\n\t\t\n\t\tif (len > ETHERMTU + sizeof(struct ether_header)) {\n\t\t\t/* packet too large, toss it */\n\t\t\tifp->if_oerrors++;\n\t\t\tm_freem(m0);\n\t\t\tcontinue;\n\t\t}\n\n#if NPBFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtab(ifp->if_bpf, m0);\n#endif\n\t\tfor (bufp = buf; m = m0;) {\n\t\t\tbcopy(mtod(m, char *), bufp, m->m_len);\n\t\t\tbufp += m->m_len;\n\t\t\tMFREE(m, m0);\n\t\t}\n\t\tif (OF_write(of->sc_ihandle, buf, bufp - buf) != bufp - buf)\n\t\t\tifp->if_oerrors++;\n\t\telse\n\t\t\tifp->if_opackets++;\n\t}\n}"
  },
  {
    "function_name": "ofnstop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ofw/ofnet.c",
    "lines": "276-282",
    "snippet": "static void\nofnstop(of)\n\tstruct ofn_softc *of;\n{\n\tuntimeout(ofntimer, of);\n\tof->sc_arpcom.ac_if.if_flags &= ~IFF_RUNNING;\n}",
    "includes": [
      "#include <machine/ipkdb.h>",
      "#include <ipkdb/ipkdb.h>",
      "#include <dev/ofw/openfirm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"ofnet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ofntimer",
      "static void ofnstop"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "ofntimer",
            "of"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/ipkdb.h>\n#include <ipkdb/ipkdb.h>\n#include <dev/ofw/openfirm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ofnet.h\"\n\nstatic void ofntimer;\nstatic void ofnstop;\n\nstatic void\nofnstop(of)\n\tstruct ofn_softc *of;\n{\n\tuntimeout(ofntimer, of);\n\tof->sc_arpcom.ac_if.if_flags &= ~IFF_RUNNING;\n}"
  },
  {
    "function_name": "ofninit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ofw/ofnet.c",
    "lines": "260-274",
    "snippet": "static void\nofninit(of)\n\tstruct ofn_softc *of;\n{\n\tstruct ifnet *ifp = &of->sc_arpcom.ac_if;\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\treturn;\n\n\tifp->if_flags |= IFF_RUNNING;\n\t/* Start reading from interface */\n\tofntimer(of);\n\t/* Attempt to start output */\n\tofnstart(ifp);\n}",
    "includes": [
      "#include <machine/ipkdb.h>",
      "#include <ipkdb/ipkdb.h>",
      "#include <dev/ofw/openfirm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"ofnet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ofntimer",
      "static void ofninit",
      "static void ofnstart"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ofnstart",
          "args": [
            "ifp"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "ofnstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ofw/ofnet.c",
          "lines": "284-332",
          "snippet": "static void\nofnstart(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct ofn_softc *of = ifp->if_softc;\n\tstruct mbuf *m, *m0;\n\tchar *bufp;\n\tchar *buf;\n\tint len;\n\tbuf = of->dmabuf;\n\t\n\tif (!(ifp->if_flags & IFF_RUNNING))\n\t\treturn;\n\n\tfor (;;) {\n\t\t/* First try reading any packets */\n\t\tofnread(of);\n\t\t\n\t\t/* Now get the first packet on the queue */\n\t\tIF_DEQUEUE(&ifp->if_snd, m0);\n\t\tif (!m0)\n\t\t\treturn;\n\t\t\n\t\tif (!(m0->m_flags & M_PKTHDR))\n\t\t\tpanic(\"ofnstart: no header mbuf\");\n\t\tlen = m0->m_pkthdr.len;\n\t\t\n\t\tif (len > ETHERMTU + sizeof(struct ether_header)) {\n\t\t\t/* packet too large, toss it */\n\t\t\tifp->if_oerrors++;\n\t\t\tm_freem(m0);\n\t\t\tcontinue;\n\t\t}\n\n#if NPBFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtab(ifp->if_bpf, m0);\n#endif\n\t\tfor (bufp = buf; m = m0;) {\n\t\t\tbcopy(mtod(m, char *), bufp, m->m_len);\n\t\t\tbufp += m->m_len;\n\t\t\tMFREE(m, m0);\n\t\t}\n\t\tif (OF_write(of->sc_ihandle, buf, bufp - buf) != bufp - buf)\n\t\t\tifp->if_oerrors++;\n\t\telse\n\t\t\tifp->if_opackets++;\n\t}\n}",
          "includes": [
            "#include <machine/ipkdb.h>",
            "#include <ipkdb/ipkdb.h>",
            "#include <dev/ofw/openfirm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"ofnet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ofnread",
            "static void ofnstart"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/ipkdb.h>\n#include <ipkdb/ipkdb.h>\n#include <dev/ofw/openfirm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ofnet.h\"\n\nstatic void ofnread;\nstatic void ofnstart;\n\nstatic void\nofnstart(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct ofn_softc *of = ifp->if_softc;\n\tstruct mbuf *m, *m0;\n\tchar *bufp;\n\tchar *buf;\n\tint len;\n\tbuf = of->dmabuf;\n\t\n\tif (!(ifp->if_flags & IFF_RUNNING))\n\t\treturn;\n\n\tfor (;;) {\n\t\t/* First try reading any packets */\n\t\tofnread(of);\n\t\t\n\t\t/* Now get the first packet on the queue */\n\t\tIF_DEQUEUE(&ifp->if_snd, m0);\n\t\tif (!m0)\n\t\t\treturn;\n\t\t\n\t\tif (!(m0->m_flags & M_PKTHDR))\n\t\t\tpanic(\"ofnstart: no header mbuf\");\n\t\tlen = m0->m_pkthdr.len;\n\t\t\n\t\tif (len > ETHERMTU + sizeof(struct ether_header)) {\n\t\t\t/* packet too large, toss it */\n\t\t\tifp->if_oerrors++;\n\t\t\tm_freem(m0);\n\t\t\tcontinue;\n\t\t}\n\n#if NPBFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtab(ifp->if_bpf, m0);\n#endif\n\t\tfor (bufp = buf; m = m0;) {\n\t\t\tbcopy(mtod(m, char *), bufp, m->m_len);\n\t\t\tbufp += m->m_len;\n\t\t\tMFREE(m, m0);\n\t\t}\n\t\tif (OF_write(of->sc_ihandle, buf, bufp - buf) != bufp - buf)\n\t\t\tifp->if_oerrors++;\n\t\telse\n\t\t\tifp->if_opackets++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ofntimer",
          "args": [
            "of"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "ofntimer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ofw/ofnet.c",
          "lines": "252-258",
          "snippet": "static void\nofntimer(of)\n\tstruct ofn_softc *of;\n{\n\tofnread(of);\n\ttimeout(ofntimer, of, 1);\n}",
          "includes": [
            "#include <machine/ipkdb.h>",
            "#include <ipkdb/ipkdb.h>",
            "#include <dev/ofw/openfirm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"ofnet.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ofnread",
            "static void ofntimer"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/ipkdb.h>\n#include <ipkdb/ipkdb.h>\n#include <dev/ofw/openfirm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ofnet.h\"\n\nstatic void ofnread;\nstatic void ofntimer;\n\nstatic void\nofntimer(of)\n\tstruct ofn_softc *of;\n{\n\tofnread(of);\n\ttimeout(ofntimer, of, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/ipkdb.h>\n#include <ipkdb/ipkdb.h>\n#include <dev/ofw/openfirm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ofnet.h\"\n\nstatic void ofntimer;\nstatic void ofninit;\nstatic void ofnstart;\n\nstatic void\nofninit(of)\n\tstruct ofn_softc *of;\n{\n\tstruct ifnet *ifp = &of->sc_arpcom.ac_if;\n\n\tif (ifp->if_flags & IFF_RUNNING)\n\t\treturn;\n\n\tifp->if_flags |= IFF_RUNNING;\n\t/* Start reading from interface */\n\tofntimer(of);\n\t/* Attempt to start output */\n\tofnstart(ifp);\n}"
  },
  {
    "function_name": "ofntimer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ofw/ofnet.c",
    "lines": "252-258",
    "snippet": "static void\nofntimer(of)\n\tstruct ofn_softc *of;\n{\n\tofnread(of);\n\ttimeout(ofntimer, of, 1);\n}",
    "includes": [
      "#include <machine/ipkdb.h>",
      "#include <ipkdb/ipkdb.h>",
      "#include <dev/ofw/openfirm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"ofnet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ofnread",
      "static void ofntimer"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "ofntimer",
            "of",
            "1"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "midi_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
          "lines": "478-486",
          "snippet": "void\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}",
          "includes": [
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\"",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nvoid\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ofnread",
          "args": [
            "of"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/ipkdb.h>\n#include <ipkdb/ipkdb.h>\n#include <dev/ofw/openfirm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ofnet.h\"\n\nstatic void ofnread;\nstatic void ofntimer;\n\nstatic void\nofntimer(of)\n\tstruct ofn_softc *of;\n{\n\tofnread(of);\n\ttimeout(ofntimer, of, 1);\n}"
  },
  {
    "function_name": "ofnattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ofw/ofnet.c",
    "lines": "118-174",
    "snippet": "static void\nofnattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct ofn_softc *of = (void *)self;\n\tstruct ifnet *ifp = &of->sc_arpcom.ac_if;\n\tstruct ofprobe *ofp = aux;\n\tchar path[256];\n\tint l;\n\t\n\tof->sc_phandle = ofp->phandle;\n#if NIPKDB_OFN > 0\n\tif (kifp\n\t    && kifp->unit - 1 == of->sc_dev.dv_unit\n\t    && OF_instance_to_package(kifp->port) == ofp->phandle)  {\n\t\tipkdb_of = of;\n\t\tof->sc_ihandle = kifp->port;\n\t} else\n#endif\n\tif ((l = OF_package_to_path(ofp->phandle, path, sizeof path - 1)) < 0\n\t    || l >= sizeof path\n\t    || (path[l] = 0, !(of->sc_ihandle = OF_open(path))))\n\t\tpanic(\"ofnattach: unable to open\");\nprintf(\"\\nethernet dev: path %s\\n\", path);\n\tOF_call_method(\"dma-alloc\", of->sc_ihandle, 1, 1, MAXPHYS,\n\t\t&(of->dmabuf));\n\tif (OF_getprop(ofp->phandle, \"mac-address\",\n\t\t       of->sc_arpcom.ac_enaddr, sizeof\n\t\t\t       (of->sc_arpcom.ac_enaddr)) < 0)\n\t{\n\t\tif (OF_getprop(ofp->phandle, \"local-mac-address\",\n\t\t\t       of->sc_arpcom.ac_enaddr, sizeof\n\t\t\t\t       (of->sc_arpcom.ac_enaddr)) < 0)\n\t\t{\n\t\t\tpanic(\"ofnattach: no mac-address\");\n\t\t}\n\t}\n\tprintf(\": address %s\\n\", ether_sprintf(of->sc_arpcom.ac_enaddr));\n\t\n\tbcopy(of->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = of;\n\tifp->if_start = ofnstart;\n\tifp->if_ioctl = ofnioctl;\n\tifp->if_watchdog = ofnwatchdog;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS;\n\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n#if NBPFILTER > 0\n\tbpfattach(&of->sc_arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,\n\t\t  sizeof(struct ether_header));\n#endif\n\n\tdk_establish(0, self);\t\t\t\t\t/* XXX */\n}",
    "includes": [
      "#include <machine/ipkdb.h>",
      "#include <ipkdb/ipkdb.h>",
      "#include <dev/ofw/openfirm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"ofnet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ofnattach",
      "static void ofnstart",
      "static int ofnioctl",
      "static void ofnwatchdog"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dk_establish",
          "args": [
            "0",
            "self"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpfattach",
          "args": [
            "&of->sc_arpcom.ac_if.if_bpf",
            "ifp",
            "DLT_EN10MB",
            "sizeof(struct ether_header)"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ifattach",
          "args": [
            "ifp"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_attach",
          "args": [
            "ifp"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "of->sc_dev.dv_xname",
            "ifp->if_xname",
            "IFNAMSIZ"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\": address %s\\n\"",
            "ether_sprintf(of->sc_arpcom.ac_enaddr)"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_sprintf",
          "args": [
            "of->sc_arpcom.ac_enaddr"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ofnattach: no mac-address\""
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OF_getprop",
          "args": [
            "ofp->phandle",
            "\"local-mac-address\"",
            "of->sc_arpcom.ac_enaddr",
            "sizeof\n\t\t\t\t       (of->sc_arpcom.ac_enaddr)"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OF_getprop",
          "args": [
            "ofp->phandle",
            "\"mac-address\"",
            "of->sc_arpcom.ac_enaddr",
            "sizeof\n\t\t\t       (of->sc_arpcom.ac_enaddr)"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OF_call_method",
          "args": [
            "\"dma-alloc\"",
            "of->sc_ihandle",
            "1",
            "1",
            "MAXPHYS",
            "&(of->dmabuf)"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ofnattach: unable to open\""
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OF_open",
          "args": [
            "path"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OF_package_to_path",
          "args": [
            "ofp->phandle",
            "path",
            "sizeof path - 1"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OF_instance_to_package",
          "args": [
            "kifp->port"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/ipkdb.h>\n#include <ipkdb/ipkdb.h>\n#include <dev/ofw/openfirm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ofnet.h\"\n\nstatic void ofnattach;\nstatic void ofnstart;\nstatic int ofnioctl;\nstatic void ofnwatchdog;\n\nstatic void\nofnattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct ofn_softc *of = (void *)self;\n\tstruct ifnet *ifp = &of->sc_arpcom.ac_if;\n\tstruct ofprobe *ofp = aux;\n\tchar path[256];\n\tint l;\n\t\n\tof->sc_phandle = ofp->phandle;\n#if NIPKDB_OFN > 0\n\tif (kifp\n\t    && kifp->unit - 1 == of->sc_dev.dv_unit\n\t    && OF_instance_to_package(kifp->port) == ofp->phandle)  {\n\t\tipkdb_of = of;\n\t\tof->sc_ihandle = kifp->port;\n\t} else\n#endif\n\tif ((l = OF_package_to_path(ofp->phandle, path, sizeof path - 1)) < 0\n\t    || l >= sizeof path\n\t    || (path[l] = 0, !(of->sc_ihandle = OF_open(path))))\n\t\tpanic(\"ofnattach: unable to open\");\nprintf(\"\\nethernet dev: path %s\\n\", path);\n\tOF_call_method(\"dma-alloc\", of->sc_ihandle, 1, 1, MAXPHYS,\n\t\t&(of->dmabuf));\n\tif (OF_getprop(ofp->phandle, \"mac-address\",\n\t\t       of->sc_arpcom.ac_enaddr, sizeof\n\t\t\t       (of->sc_arpcom.ac_enaddr)) < 0)\n\t{\n\t\tif (OF_getprop(ofp->phandle, \"local-mac-address\",\n\t\t\t       of->sc_arpcom.ac_enaddr, sizeof\n\t\t\t\t       (of->sc_arpcom.ac_enaddr)) < 0)\n\t\t{\n\t\t\tpanic(\"ofnattach: no mac-address\");\n\t\t}\n\t}\n\tprintf(\": address %s\\n\", ether_sprintf(of->sc_arpcom.ac_enaddr));\n\t\n\tbcopy(of->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = of;\n\tifp->if_start = ofnstart;\n\tifp->if_ioctl = ofnioctl;\n\tifp->if_watchdog = ofnwatchdog;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS;\n\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n#if NBPFILTER > 0\n\tbpfattach(&of->sc_arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,\n\t\t  sizeof(struct ether_header));\n#endif\n\n\tdk_establish(0, self);\t\t\t\t\t/* XXX */\n}"
  },
  {
    "function_name": "ofnprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ofw/ofnet.c",
    "lines": "95-116",
    "snippet": "static int\nofnprobe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct ofprobe *ofp = aux;\n\tchar type[32];\n\tint l;\n\t\n#if NIPKDB_OFN > 0\n\tif (!parent)\n\t\treturn ipkdbprobe(match, aux);\n#endif\n\tif ((l = OF_getprop(ofp->phandle, \"device_type\", type, sizeof type - 1)) < 0)\n\t\treturn 0;\n\tif (l >= sizeof type)\n\t\treturn 0;\n\ttype[l] = 0;\n\tif (strcmp(type, \"network\"))\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include <machine/ipkdb.h>",
      "#include <ipkdb/ipkdb.h>",
      "#include <dev/ofw/openfirm.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\"",
      "#include \"ofnet.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int ofnprobe"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"network\""
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OF_getprop",
          "args": [
            "ofp->phandle",
            "\"device_type\"",
            "type",
            "sizeof type - 1"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ipkdbprobe",
          "args": [
            "match",
            "aux"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "ipkdbprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ofw/ofnet.c",
          "lines": "435-470",
          "snippet": "static int\nipkdbprobe(match, aux)\n\tvoid *match, *aux;\n{\n\tstruct cfdata *cf = match;\n\tstruct ipkdb_if *kip = aux;\n\tstatic char name[256];\n\tint len;\n\tint phandle;\n\t\n\tkip->unit = cf->cf_unit + 1;\n\n\tif (!(kip->port = OF_open(\"net\")))\n\t\treturn -1;\n\tif ((len = OF_instance_to_path(kip->port, name, sizeof name - 1)) < 0\n\t    || len >= sizeof name)\n\t\treturn -1;\n\tname[len] = 0;\n\tif ((phandle = OF_instance_to_package(kip->port)) == -1)\n\t\treturn -1;\n\tif ( OF_getprop(phandle, \"local-mac-address\", kip->myenetaddr, sizeof kip->myenetaddr) &&\n\tOF_getprop(phandle, \"mac-address\", kip->myenetaddr, sizeof kip->myenetaddr)\n\t    < 0)\n\t\treturn -1;\n\t\n\tkip->flags |= IPKDB_MYHW;\n\tkip->name = name;\n\tkip->start = ipkdbofstart;\n\tkip->leave = ipkdbofleave;\n\tkip->receive = ipkdbofrcv;\n\tkip->send = ipkdbofsend;\n\n\tkifp = kip;\n\t\n\treturn 0;\n}",
          "includes": [
            "#include <machine/ipkdb.h>",
            "#include <ipkdb/ipkdb.h>",
            "#include <dev/ofw/openfirm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\"",
            "#include \"ofnet.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/ipkdb.h>\n#include <ipkdb/ipkdb.h>\n#include <dev/ofw/openfirm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ofnet.h\"\n\nstatic int\nipkdbprobe(match, aux)\n\tvoid *match, *aux;\n{\n\tstruct cfdata *cf = match;\n\tstruct ipkdb_if *kip = aux;\n\tstatic char name[256];\n\tint len;\n\tint phandle;\n\t\n\tkip->unit = cf->cf_unit + 1;\n\n\tif (!(kip->port = OF_open(\"net\")))\n\t\treturn -1;\n\tif ((len = OF_instance_to_path(kip->port, name, sizeof name - 1)) < 0\n\t    || len >= sizeof name)\n\t\treturn -1;\n\tname[len] = 0;\n\tif ((phandle = OF_instance_to_package(kip->port)) == -1)\n\t\treturn -1;\n\tif ( OF_getprop(phandle, \"local-mac-address\", kip->myenetaddr, sizeof kip->myenetaddr) &&\n\tOF_getprop(phandle, \"mac-address\", kip->myenetaddr, sizeof kip->myenetaddr)\n\t    < 0)\n\t\treturn -1;\n\t\n\tkip->flags |= IPKDB_MYHW;\n\tkip->name = name;\n\tkip->start = ipkdbofstart;\n\tkip->leave = ipkdbofleave;\n\tkip->receive = ipkdbofrcv;\n\tkip->send = ipkdbofsend;\n\n\tkifp = kip;\n\t\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/ipkdb.h>\n#include <ipkdb/ipkdb.h>\n#include <dev/ofw/openfirm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n#include \"ofnet.h\"\n\nstatic int ofnprobe;\n\nstatic int\nofnprobe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct ofprobe *ofp = aux;\n\tchar type[32];\n\tint l;\n\t\n#if NIPKDB_OFN > 0\n\tif (!parent)\n\t\treturn ipkdbprobe(match, aux);\n#endif\n\tif ((l = OF_getprop(ofp->phandle, \"device_type\", type, sizeof type - 1)) < 0)\n\t\treturn 0;\n\tif (l >= sizeof type)\n\t\treturn 0;\n\ttype[l] = 0;\n\tif (strcmp(type, \"network\"))\n\t\treturn 0;\n\treturn 1;\n}"
  }
]