[
  {
    "function_name": "ed_shared_readmem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
    "lines": "2997-3025",
    "snippet": "void\ned_shared_readmem(sc, card, to, len)\n\tstruct ed_softc *sc;\n\tcaddr_t to;\n\tint card, len;\n{\n\tbus_space_tag_t memt = sc->sc_memt;\n\tbus_space_handle_t memh = sc->sc_memh;\n\tu_int16_t word;\n\n\t/*\n\t * See comment above re. 16-bit cards.\n\t */\n\tif (sc->isa16bit) {\n\t\t/* XXX I think maybe a bus_space_read_raw_region is needed.  */\n\t\twhile (len > 1) {\n\t\t\tword = bus_space_read_2(memt, memh, card);\n\t\t\t*to++ = word & 0xff;\n\t\t\t*to++ = word >> 8 & 0xff;\n\t\t\tcard += 2;\n\t\t\tlen -= 2;\n\t\t}\n\t\tif (len == 1)\n\t\t\t*to = bus_space_read_2(memt, memh, card) & 0xff;\n\t} else {\n\t\twhile (len--)\n\t\t\t*to++ = bus_space_read_1(memt, memh, card++);\n\t}\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/isa/if_edreg.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"ed.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ed_shared_readmem",
      "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "memt",
            "memh",
            "card++"
          ],
          "line": 3023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "memt",
            "memh",
            "card"
          ],
          "line": 3020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "memt",
            "memh",
            "card"
          ],
          "line": 3013
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nvoid ed_shared_readmem;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nvoid\ned_shared_readmem(sc, card, to, len)\n\tstruct ed_softc *sc;\n\tcaddr_t to;\n\tint card, len;\n{\n\tbus_space_tag_t memt = sc->sc_memt;\n\tbus_space_handle_t memh = sc->sc_memh;\n\tu_int16_t word;\n\n\t/*\n\t * See comment above re. 16-bit cards.\n\t */\n\tif (sc->isa16bit) {\n\t\t/* XXX I think maybe a bus_space_read_raw_region is needed.  */\n\t\twhile (len > 1) {\n\t\t\tword = bus_space_read_2(memt, memh, card);\n\t\t\t*to++ = word & 0xff;\n\t\t\t*to++ = word >> 8 & 0xff;\n\t\t\tcard += 2;\n\t\t\tlen -= 2;\n\t\t}\n\t\tif (len == 1)\n\t\t\t*to = bus_space_read_2(memt, memh, card) & 0xff;\n\t} else {\n\t\twhile (len--)\n\t\t\t*to++ = bus_space_read_1(memt, memh, card++);\n\t}\n}"
  },
  {
    "function_name": "ed_shared_writemem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
    "lines": "2949-2995",
    "snippet": "void\ned_shared_writemem(sc, from, card, len)\n\tstruct ed_softc *sc;\n\tcaddr_t from;\n\tint card, len;\n{\n\tbus_space_tag_t memt = sc->sc_memt;\n\tbus_space_handle_t memh = sc->sc_memh;\n\tu_int16_t word;\n\n\t/*\n\t * For 16-bit cards, 16-bit memory access has already\n\t * been set up.  Note that some cards are really picky\n\t * about enforcing 16-bit access to memory, so we\n\t * have to be careful.\n\t */\n\tif (sc->isa16bit) {\n\t\t/*\n\t\t * If writing to an odd location, we need to align first.\n\t\t * This requires a read-modify-write cycle as we should\n\t\t * keep accesses 16-bit wide.\n\t\t */\n\t\tif (len > 0 && (card & 1)) {\n\t\t\tword = bus_space_read_2(memt, memh, card & ~1);\n\t\t\tword = (word & 0xff) | (*from << 8);\n\t\t\tbus_space_write_2(memt, memh, card & ~1, word);\n\t\t\tfrom++;\n\t\t\tcard++;\n\t\t\tlen--;\n\t\t}\n\t\t/* XXX I think maybe a bus_space_write_raw_region is needed. */\n\t\twhile (len > 1) {\n\t\t\tword = (u_int8_t)from[0] | (u_int8_t)from[1] << 8;\n\t\t\tbus_space_write_2(memt, memh, card, word);\n\t\t\tfrom += 2;\n\t\t\tcard += 2;\n\t\t\tlen -= 2;\n\t\t}\n\t\tif (len == 1) {\n\t\t\tword = *from;\n\t\t\tbus_space_write_2(memt, memh, card, word);\n\t\t}\n\t} else {\n\t\twhile (len--)\n\t\t\tbus_space_write_1(memt, memh, card++, *from++);\n\t}\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/isa/if_edreg.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"ed.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ed_shared_writemem",
      "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "memt",
            "memh",
            "card++",
            "*from++"
          ],
          "line": 2993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "memt",
            "memh",
            "card",
            "word"
          ],
          "line": 2989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "memt",
            "memh",
            "card",
            "word"
          ],
          "line": 2982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "memt",
            "memh",
            "card & ~1",
            "word"
          ],
          "line": 2974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "memt",
            "memh",
            "card & ~1"
          ],
          "line": 2972
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nvoid ed_shared_writemem;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nvoid\ned_shared_writemem(sc, from, card, len)\n\tstruct ed_softc *sc;\n\tcaddr_t from;\n\tint card, len;\n{\n\tbus_space_tag_t memt = sc->sc_memt;\n\tbus_space_handle_t memh = sc->sc_memh;\n\tu_int16_t word;\n\n\t/*\n\t * For 16-bit cards, 16-bit memory access has already\n\t * been set up.  Note that some cards are really picky\n\t * about enforcing 16-bit access to memory, so we\n\t * have to be careful.\n\t */\n\tif (sc->isa16bit) {\n\t\t/*\n\t\t * If writing to an odd location, we need to align first.\n\t\t * This requires a read-modify-write cycle as we should\n\t\t * keep accesses 16-bit wide.\n\t\t */\n\t\tif (len > 0 && (card & 1)) {\n\t\t\tword = bus_space_read_2(memt, memh, card & ~1);\n\t\t\tword = (word & 0xff) | (*from << 8);\n\t\t\tbus_space_write_2(memt, memh, card & ~1, word);\n\t\t\tfrom++;\n\t\t\tcard++;\n\t\t\tlen--;\n\t\t}\n\t\t/* XXX I think maybe a bus_space_write_raw_region is needed. */\n\t\twhile (len > 1) {\n\t\t\tword = (u_int8_t)from[0] | (u_int8_t)from[1] << 8;\n\t\t\tbus_space_write_2(memt, memh, card, word);\n\t\t\tfrom += 2;\n\t\t\tcard += 2;\n\t\t\tlen -= 2;\n\t\t}\n\t\tif (len == 1) {\n\t\t\tword = *from;\n\t\t\tbus_space_write_2(memt, memh, card, word);\n\t\t}\n\t} else {\n\t\twhile (len--)\n\t\t\tbus_space_write_1(memt, memh, card++, *from++);\n\t}\n}"
  },
  {
    "function_name": "ed_getmcaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
    "lines": "2880-2947",
    "snippet": "void\ned_getmcaf(ac, af)\n\tstruct arpcom *ac;\n\tu_int32_t *af;\n{\n\tstruct ifnet *ifp = &ac->ac_if;\n\tstruct ether_multi *enm;\n\tregister u_char *cp, c;\n\tregister u_int32_t crc;\n\tregister int i, len;\n\tstruct ether_multistep step;\n\n\t/*\n\t * Set up multicast address filter by passing all multicast addresses\n\t * through a crc generator, and then using the high order 6 bits as an\n\t * index into the 64 bit logical address filter.  The high order bit\n\t * selects the word, while the rest of the bits select the bit within\n\t * the word.\n\t */\n\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\taf[0] = af[1] = 0xffffffff;\n\t\treturn;\n\t}\n\n\taf[0] = af[1] = 0;\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi,\n\t\t    sizeof(enm->enm_addrlo)) != 0) {\n\t\t\t/*\n\t\t\t * We must listen to a range of multicast addresses.\n\t\t\t * For now, just accept all multicasts, rather than\n\t\t\t * trying to set only those filter bits needed to match\n\t\t\t * the range.  (At this time, the only use of address\n\t\t\t * ranges is for IP multicast routing, for which the\n\t\t\t * range is big enough to require all bits set.)\n\t\t\t */\n\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\taf[0] = af[1] = 0xffffffff;\n\t\t\treturn;\n\t\t}\n\n\t\tcp = enm->enm_addrlo;\n\t\tcrc = 0xffffffff;\n\t\tfor (len = sizeof(enm->enm_addrlo); --len >= 0;) {\n\t\t\tc = *cp++;\n\t\t\tfor (i = 8; --i >= 0;) {\n\t\t\t\tif (((crc & 0x80000000) ? 1 : 0)\n\t\t\t\t    ^ (c & 0x01)) {\n\t\t\t\t\tcrc <<= 1;\n\t\t\t\t\tcrc ^= 0x04c11db6 | 1;\n\t\t\t\t} else\n\t\t\t\t\tcrc <<= 1;\n\t\t\t\tc >>= 1;\n\t\t\t}\n\t\t}\n\t\t/* Just want the 6 most significant bits. */\n\t\tcrc >>= 26;\n\n\t\t/* Turn on the corresponding bit in the filter. */\n\t\taf[crc >> 5] |= 1 << ((crc & 0x1f) ^ 0);\n\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\tifp->if_flags &= ~IFF_ALLMULTI;\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/isa/if_edreg.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"ed.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ed_getmcaf"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ETHER_NEXT_MULTI",
          "args": [
            "step",
            "enm"
          ],
          "line": 2944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "enm->enm_addrlo",
            "enm->enm_addrhi",
            "sizeof(enm->enm_addrlo)"
          ],
          "line": 2909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ETHER_FIRST_MULTI",
          "args": [
            "step",
            "ac",
            "enm"
          ],
          "line": 2907
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nvoid ed_getmcaf;\n\nvoid\ned_getmcaf(ac, af)\n\tstruct arpcom *ac;\n\tu_int32_t *af;\n{\n\tstruct ifnet *ifp = &ac->ac_if;\n\tstruct ether_multi *enm;\n\tregister u_char *cp, c;\n\tregister u_int32_t crc;\n\tregister int i, len;\n\tstruct ether_multistep step;\n\n\t/*\n\t * Set up multicast address filter by passing all multicast addresses\n\t * through a crc generator, and then using the high order 6 bits as an\n\t * index into the 64 bit logical address filter.  The high order bit\n\t * selects the word, while the rest of the bits select the bit within\n\t * the word.\n\t */\n\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\taf[0] = af[1] = 0xffffffff;\n\t\treturn;\n\t}\n\n\taf[0] = af[1] = 0;\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi,\n\t\t    sizeof(enm->enm_addrlo)) != 0) {\n\t\t\t/*\n\t\t\t * We must listen to a range of multicast addresses.\n\t\t\t * For now, just accept all multicasts, rather than\n\t\t\t * trying to set only those filter bits needed to match\n\t\t\t * the range.  (At this time, the only use of address\n\t\t\t * ranges is for IP multicast routing, for which the\n\t\t\t * range is big enough to require all bits set.)\n\t\t\t */\n\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\taf[0] = af[1] = 0xffffffff;\n\t\t\treturn;\n\t\t}\n\n\t\tcp = enm->enm_addrlo;\n\t\tcrc = 0xffffffff;\n\t\tfor (len = sizeof(enm->enm_addrlo); --len >= 0;) {\n\t\t\tc = *cp++;\n\t\t\tfor (i = 8; --i >= 0;) {\n\t\t\t\tif (((crc & 0x80000000) ? 1 : 0)\n\t\t\t\t    ^ (c & 0x01)) {\n\t\t\t\t\tcrc <<= 1;\n\t\t\t\t\tcrc ^= 0x04c11db6 | 1;\n\t\t\t\t} else\n\t\t\t\t\tcrc <<= 1;\n\t\t\t\tc >>= 1;\n\t\t\t}\n\t\t}\n\t\t/* Just want the 6 most significant bits. */\n\t\tcrc >>= 26;\n\n\t\t/* Turn on the corresponding bit in the filter. */\n\t\taf[crc >> 5] |= 1 << ((crc & 0x1f) ^ 0);\n\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\tifp->if_flags &= ~IFF_ALLMULTI;\n}"
  },
  {
    "function_name": "ed_ring_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
    "lines": "2791-2821",
    "snippet": "static __inline int\ned_ring_copy(sc, src, dst, amount)\n\tstruct ed_softc *sc;\n\tint src;\n\tcaddr_t dst;\n\tu_int16_t amount;\n{\n\tu_int16_t tmp_amount;\n\n\t/* Does copy wrap to lower addr in ring buffer? */\n\tif (src + amount > sc->mem_end) {\n\t\ttmp_amount = sc->mem_end - src;\n\n\t\t/* Copy amount up to end of NIC memory. */\n\t\tif (sc->mem_shared)\n\t\t\ted_shared_readmem(sc, src, dst, tmp_amount);\n\t\telse\n\t\t\ted_pio_readmem(sc, (u_int16_t)src, dst, tmp_amount);\n\n\t\tamount -= tmp_amount;\n\t\tsrc = sc->mem_ring;\n\t\tdst += tmp_amount;\n\t}\n\n\tif (sc->mem_shared)\n\t\ted_shared_readmem(sc, src, dst, amount);\n\telse\n\t\ted_pio_readmem(sc, (u_int16_t)src, dst, amount);\n\n\treturn (src + amount);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/isa/if_edreg.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"ed.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ed_shared_readmem",
      "static __inline int ed_ring_copy",
      "void ed_pio_readmem",
      "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;",
      "int src;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ed_pio_readmem",
          "args": [
            "sc",
            "(u_int16_t)src",
            "dst",
            "amount"
          ],
          "line": 2818
        },
        "resolved": true,
        "details": {
          "function_name": "ed_pio_readmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
          "lines": "2584-2620",
          "snippet": "void\ned_pio_readmem(sc, src, dst, amount)\n\tstruct ed_softc *sc;\n\tu_int16_t src;\n\tcaddr_t dst;\n\tu_int16_t amount;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint nicbase = sc->nic_base;\n\n\t/* Select page 0 registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Round up to a word. */\n\tif (amount & 1)\n\t\t++amount;\n\n\t/* Set up DMA byte count. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR0, amount);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR1, amount >> 8);\n\n\t/* Set up source address in NIC mem. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RSAR0, src);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RSAR1, src >> 8);\n\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD0 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tif (sc->isa16bit)\n\t\tbus_space_read_raw_multi_2(iot, ioh,\n\t\t    sc->asic_base + ED_NOVELL_DATA, dst, amount);\n\telse\n\t\tbus_space_read_multi_1(iot, ioh,\n\t\t    sc->asic_base + ED_NOVELL_DATA, dst, amount);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/isa/if_edreg.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"ed.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ed_pio_readmem",
            "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;",
            "int src;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nvoid ed_pio_readmem;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\nint src;\n\nvoid\ned_pio_readmem(sc, src, dst, amount)\n\tstruct ed_softc *sc;\n\tu_int16_t src;\n\tcaddr_t dst;\n\tu_int16_t amount;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint nicbase = sc->nic_base;\n\n\t/* Select page 0 registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Round up to a word. */\n\tif (amount & 1)\n\t\t++amount;\n\n\t/* Set up DMA byte count. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR0, amount);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR1, amount >> 8);\n\n\t/* Set up source address in NIC mem. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RSAR0, src);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RSAR1, src >> 8);\n\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD0 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tif (sc->isa16bit)\n\t\tbus_space_read_raw_multi_2(iot, ioh,\n\t\t    sc->asic_base + ED_NOVELL_DATA, dst, amount);\n\telse\n\t\tbus_space_read_multi_1(iot, ioh,\n\t\t    sc->asic_base + ED_NOVELL_DATA, dst, amount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ed_shared_readmem",
          "args": [
            "sc",
            "src",
            "dst",
            "amount"
          ],
          "line": 2816
        },
        "resolved": true,
        "details": {
          "function_name": "ed_shared_readmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
          "lines": "2997-3025",
          "snippet": "void\ned_shared_readmem(sc, card, to, len)\n\tstruct ed_softc *sc;\n\tcaddr_t to;\n\tint card, len;\n{\n\tbus_space_tag_t memt = sc->sc_memt;\n\tbus_space_handle_t memh = sc->sc_memh;\n\tu_int16_t word;\n\n\t/*\n\t * See comment above re. 16-bit cards.\n\t */\n\tif (sc->isa16bit) {\n\t\t/* XXX I think maybe a bus_space_read_raw_region is needed.  */\n\t\twhile (len > 1) {\n\t\t\tword = bus_space_read_2(memt, memh, card);\n\t\t\t*to++ = word & 0xff;\n\t\t\t*to++ = word >> 8 & 0xff;\n\t\t\tcard += 2;\n\t\t\tlen -= 2;\n\t\t}\n\t\tif (len == 1)\n\t\t\t*to = bus_space_read_2(memt, memh, card) & 0xff;\n\t} else {\n\t\twhile (len--)\n\t\t\t*to++ = bus_space_read_1(memt, memh, card++);\n\t}\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/isa/if_edreg.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"ed.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ed_shared_readmem",
            "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nvoid ed_shared_readmem;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nvoid\ned_shared_readmem(sc, card, to, len)\n\tstruct ed_softc *sc;\n\tcaddr_t to;\n\tint card, len;\n{\n\tbus_space_tag_t memt = sc->sc_memt;\n\tbus_space_handle_t memh = sc->sc_memh;\n\tu_int16_t word;\n\n\t/*\n\t * See comment above re. 16-bit cards.\n\t */\n\tif (sc->isa16bit) {\n\t\t/* XXX I think maybe a bus_space_read_raw_region is needed.  */\n\t\twhile (len > 1) {\n\t\t\tword = bus_space_read_2(memt, memh, card);\n\t\t\t*to++ = word & 0xff;\n\t\t\t*to++ = word >> 8 & 0xff;\n\t\t\tcard += 2;\n\t\t\tlen -= 2;\n\t\t}\n\t\tif (len == 1)\n\t\t\t*to = bus_space_read_2(memt, memh, card) & 0xff;\n\t} else {\n\t\twhile (len--)\n\t\t\t*to++ = bus_space_read_1(memt, memh, card++);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nvoid ed_shared_readmem;\nstatic __inline int ed_ring_copy;\nvoid ed_pio_readmem;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\nint src;\n\nstatic __inline int\ned_ring_copy(sc, src, dst, amount)\n\tstruct ed_softc *sc;\n\tint src;\n\tcaddr_t dst;\n\tu_int16_t amount;\n{\n\tu_int16_t tmp_amount;\n\n\t/* Does copy wrap to lower addr in ring buffer? */\n\tif (src + amount > sc->mem_end) {\n\t\ttmp_amount = sc->mem_end - src;\n\n\t\t/* Copy amount up to end of NIC memory. */\n\t\tif (sc->mem_shared)\n\t\t\ted_shared_readmem(sc, src, dst, tmp_amount);\n\t\telse\n\t\t\ted_pio_readmem(sc, (u_int16_t)src, dst, tmp_amount);\n\n\t\tamount -= tmp_amount;\n\t\tsrc = sc->mem_ring;\n\t\tdst += tmp_amount;\n\t}\n\n\tif (sc->mem_shared)\n\t\ted_shared_readmem(sc, src, dst, amount);\n\telse\n\t\ted_pio_readmem(sc, (u_int16_t)src, dst, amount);\n\n\treturn (src + amount);\n}"
  },
  {
    "function_name": "ed_pio_write_mbufs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
    "lines": "2679-2785",
    "snippet": "u_int16_t\ned_pio_write_mbufs(sc, m, dst)\n\tstruct ed_softc *sc;\n\tstruct mbuf *m;\n\tu_int16_t dst;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint nicbase = sc->nic_base, asicbase = sc->asic_base;\n\tu_int16_t len;\n\tint maxwait = 100; /* about 120us */\n\n\tlen = m->m_pkthdr.len;\n\n\t/* Select page 0 registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Reset remote DMA complete flag. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_ISR, ED_ISR_RDC);\n\n\t/* Set up DMA byte count. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR0, len);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR1, len >> 8);\n\n\t/* Set up destination address in NIC mem. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RSAR0, dst);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RSAR1, dst >> 8);\n\n\t/* Set remote DMA write. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD1 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/*\n\t * Transfer the mbuf chain to the NIC memory.\n\t * 16-bit cards require that data be transferred as words, and only\n\t * words, so that case requires some extra code to patch over\n\t * odd-length mbufs.\n\t */\n\tif (!sc->isa16bit) {\n\t\t/* NE1000s are easy. */\n\t\tfor (; m != 0; m = m->m_next) {\n\t\t\tif (m->m_len) {\n\t\t\t\tbus_space_write_multi_1(iot, ioh,\n\t\t\t\t    asicbase + ED_NOVELL_DATA,\n\t\t\t\t    mtod(m, u_char *), m->m_len);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* NE2000s are a bit trickier. */\n\t\tu_int8_t *data, savebyte[2];\n\t\tint len, wantbyte;\n\n\t\twantbyte = 0;\n\t\tfor (; m != 0; m = m->m_next) {\n\t\t\tlen = m->m_len;\n\t\t\tif (len == 0)\n\t\t\t\tcontinue;\n\t\t\tdata = mtod(m, u_int8_t *);\n\t\t\t/* Finish the last word. */\n\t\t\tif (wantbyte) {\n\t\t\t\tsavebyte[1] = *data;\n\t\t\t\tbus_space_write_raw_multi_2(iot, ioh,\n\t\t\t\t    asicbase + ED_NOVELL_DATA, savebyte, 2);\n\t\t\t\tdata++;\n\t\t\t\tlen--;\n\t\t\t\twantbyte = 0;\n\t\t\t}\n\t\t\t/* Output contiguous words. */\n\t\t\tif (len > 1) {\n\t\t\t\tbus_space_write_raw_multi_2(iot, ioh,\n\t\t\t\t    asicbase + ED_NOVELL_DATA, data, len & ~1);\n\t\t\t}\n\t\t\t/* Save last byte, if necessary. */\n\t\t\tif (len & 1) {\n\t\t\t\tdata += len & ~1;\n\t\t\t\tsavebyte[0] = *data;\n\t\t\t\twantbyte = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (wantbyte) {\n\t\t\tsavebyte[1] = 0;\n\t\t\tbus_space_write_raw_multi_2(iot, ioh,\n\t\t\t    asicbase + ED_NOVELL_DATA, savebyte, 2);\n\t\t}\n\t}\n\n\t/*\n\t * Wait for remote DMA complete.  This is necessary because on the\n\t * transmit side, data is handled internally by the NIC in bursts and\n\t * we can't start another remote DMA until this one completes. \tNot\n\t * waiting causes really bad things to happen - like the NIC\n\t * irrecoverably jamming the ISA bus.\n\t */\n\twhile (((NIC_GET(iot, ioh, nicbase, ED_P0_ISR) & ED_ISR_RDC) !=\n\t    ED_ISR_RDC) && --maxwait);\n\n\tif (!maxwait) {\n\t\tlog(LOG_WARNING,\n\t\t    \"%s: remote transmit DMA failed to complete\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tedreset(sc);\n\t}\n\n\treturn (len);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/isa/if_edreg.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"ed.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void edreset",
      "u_int16_t ed_pio_write_mbufs",
      "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "edreset",
          "args": [
            "sc"
          ],
          "line": 2781
        },
        "resolved": true,
        "details": {
          "function_name": "edreset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
          "lines": "1732-1742",
          "snippet": "void\nedreset(sc)\n\tstruct ed_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tedstop(sc);\n\tedinit(sc);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/isa/if_edreg.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"ed.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void edreset",
            "void edinit",
            "void edstop",
            "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nvoid edreset;\nvoid edinit;\nvoid edstop;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nvoid\nedreset(sc)\n\tstruct ed_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tedstop(sc);\n\tedinit(sc);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_WARNING",
            "\"%s: remote transmit DMA failed to complete\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 2778
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_log_hard_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5909-5956",
          "snippet": "static void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "int\ti;",
            "ncb_p np = (struct ncb*) 0;",
            "int\ti;",
            "u_int8_t\tistat, dstat;",
            "u_int16_t\tsist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nint\ti;\nncb_p np = (struct ncb*) 0;\nint\ti;\nu_int8_t\tistat, dstat;\nu_int16_t\tsist;\n\nstatic void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "NIC_GET",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_ISR"
          ],
          "line": 2774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_raw_multi_2",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_NOVELL_DATA",
            "savebyte",
            "2"
          ],
          "line": 2762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_raw_multi_2",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_NOVELL_DATA",
            "data",
            "len & ~1"
          ],
          "line": 2749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_raw_multi_2",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_NOVELL_DATA",
            "savebyte",
            "2"
          ],
          "line": 2741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "u_int8_t*"
          ],
          "line": 2737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_multi_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_NOVELL_DATA",
            "mtod(m, u_char *)",
            "m->m_len"
          ],
          "line": 2722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "u_char*"
          ],
          "line": 2724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_CR",
            "ED_CR_RD1 | ED_CR_PAGE_0 | ED_CR_STA"
          ],
          "line": 2709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_RSAR1",
            "dst >> 8"
          ],
          "line": 2706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_RSAR0",
            "dst"
          ],
          "line": 2705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_RBCR1",
            "len >> 8"
          ],
          "line": 2702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_RBCR0",
            "len"
          ],
          "line": 2701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_ISR",
            "ED_ISR_RDC"
          ],
          "line": 2698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_CR",
            "ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA"
          ],
          "line": 2694
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nvoid edreset;\nu_int16_t ed_pio_write_mbufs;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nu_int16_t\ned_pio_write_mbufs(sc, m, dst)\n\tstruct ed_softc *sc;\n\tstruct mbuf *m;\n\tu_int16_t dst;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint nicbase = sc->nic_base, asicbase = sc->asic_base;\n\tu_int16_t len;\n\tint maxwait = 100; /* about 120us */\n\n\tlen = m->m_pkthdr.len;\n\n\t/* Select page 0 registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Reset remote DMA complete flag. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_ISR, ED_ISR_RDC);\n\n\t/* Set up DMA byte count. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR0, len);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR1, len >> 8);\n\n\t/* Set up destination address in NIC mem. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RSAR0, dst);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RSAR1, dst >> 8);\n\n\t/* Set remote DMA write. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD1 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/*\n\t * Transfer the mbuf chain to the NIC memory.\n\t * 16-bit cards require that data be transferred as words, and only\n\t * words, so that case requires some extra code to patch over\n\t * odd-length mbufs.\n\t */\n\tif (!sc->isa16bit) {\n\t\t/* NE1000s are easy. */\n\t\tfor (; m != 0; m = m->m_next) {\n\t\t\tif (m->m_len) {\n\t\t\t\tbus_space_write_multi_1(iot, ioh,\n\t\t\t\t    asicbase + ED_NOVELL_DATA,\n\t\t\t\t    mtod(m, u_char *), m->m_len);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* NE2000s are a bit trickier. */\n\t\tu_int8_t *data, savebyte[2];\n\t\tint len, wantbyte;\n\n\t\twantbyte = 0;\n\t\tfor (; m != 0; m = m->m_next) {\n\t\t\tlen = m->m_len;\n\t\t\tif (len == 0)\n\t\t\t\tcontinue;\n\t\t\tdata = mtod(m, u_int8_t *);\n\t\t\t/* Finish the last word. */\n\t\t\tif (wantbyte) {\n\t\t\t\tsavebyte[1] = *data;\n\t\t\t\tbus_space_write_raw_multi_2(iot, ioh,\n\t\t\t\t    asicbase + ED_NOVELL_DATA, savebyte, 2);\n\t\t\t\tdata++;\n\t\t\t\tlen--;\n\t\t\t\twantbyte = 0;\n\t\t\t}\n\t\t\t/* Output contiguous words. */\n\t\t\tif (len > 1) {\n\t\t\t\tbus_space_write_raw_multi_2(iot, ioh,\n\t\t\t\t    asicbase + ED_NOVELL_DATA, data, len & ~1);\n\t\t\t}\n\t\t\t/* Save last byte, if necessary. */\n\t\t\tif (len & 1) {\n\t\t\t\tdata += len & ~1;\n\t\t\t\tsavebyte[0] = *data;\n\t\t\t\twantbyte = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (wantbyte) {\n\t\t\tsavebyte[1] = 0;\n\t\t\tbus_space_write_raw_multi_2(iot, ioh,\n\t\t\t    asicbase + ED_NOVELL_DATA, savebyte, 2);\n\t\t}\n\t}\n\n\t/*\n\t * Wait for remote DMA complete.  This is necessary because on the\n\t * transmit side, data is handled internally by the NIC in bursts and\n\t * we can't start another remote DMA until this one completes. \tNot\n\t * waiting causes really bad things to happen - like the NIC\n\t * irrecoverably jamming the ISA bus.\n\t */\n\twhile (((NIC_GET(iot, ioh, nicbase, ED_P0_ISR) & ED_ISR_RDC) !=\n\t    ED_ISR_RDC) && --maxwait);\n\n\tif (!maxwait) {\n\t\tlog(LOG_WARNING,\n\t\t    \"%s: remote transmit DMA failed to complete\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tedreset(sc);\n\t}\n\n\treturn (len);\n}"
  },
  {
    "function_name": "ed_pio_writemem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
    "lines": "2626-2673",
    "snippet": "void\ned_pio_writemem(sc, src, dst, len)\n\tstruct ed_softc *sc;\n\tcaddr_t src;\n\tu_int16_t dst;\n\tu_int16_t len;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint nicbase = sc->nic_base;\n\tint maxwait = 100; /* about 120us */\n\n\t/* Select page 0 registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Reset remote DMA complete flag. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_ISR, ED_ISR_RDC);\n\n\t/* Set up DMA byte count. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR0, len);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR1, len >> 8);\n\n\t/* Set up destination address in NIC mem. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RSAR0, dst);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RSAR1, dst >> 8);\n\n\t/* Set remote DMA write. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD1 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tif (sc->isa16bit)\n\t\tbus_space_write_raw_multi_2(iot, ioh,\n\t\t    sc->asic_base + ED_NOVELL_DATA, src, len);\n\telse\n\t\tbus_space_write_multi_1(iot, ioh,\n\t\t    sc->asic_base + ED_NOVELL_DATA, src, len);\n\n\t/*\n\t * Wait for remote DMA complete.  This is necessary because on the\n\t * transmit side, data is handled internally by the NIC in bursts and\n\t * we can't start another remote DMA until this one completes.  Not\n\t * waiting causes really bad things to happen - like the NIC\n\t * irrecoverably jamming the ISA bus.\n\t */\n\twhile (((NIC_GET(iot, ioh, nicbase, ED_P0_ISR) & ED_ISR_RDC) !=\n\t    ED_ISR_RDC) && --maxwait);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/isa/if_edreg.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"ed.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ed_pio_writemem",
      "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;",
      "int src;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NIC_GET",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_ISR"
          ],
          "line": 2671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_multi_1",
          "args": [
            "iot",
            "ioh",
            "sc->asic_base + ED_NOVELL_DATA",
            "src",
            "len"
          ],
          "line": 2661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_raw_multi_2",
          "args": [
            "iot",
            "ioh",
            "sc->asic_base + ED_NOVELL_DATA",
            "src",
            "len"
          ],
          "line": 2658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_CR",
            "ED_CR_RD1 | ED_CR_PAGE_0 | ED_CR_STA"
          ],
          "line": 2654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_RSAR1",
            "dst >> 8"
          ],
          "line": 2651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_RSAR0",
            "dst"
          ],
          "line": 2650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_RBCR1",
            "len >> 8"
          ],
          "line": 2647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_RBCR0",
            "len"
          ],
          "line": 2646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_ISR",
            "ED_ISR_RDC"
          ],
          "line": 2643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_CR",
            "ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA"
          ],
          "line": 2639
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nvoid ed_pio_writemem;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\nint src;\n\nvoid\ned_pio_writemem(sc, src, dst, len)\n\tstruct ed_softc *sc;\n\tcaddr_t src;\n\tu_int16_t dst;\n\tu_int16_t len;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint nicbase = sc->nic_base;\n\tint maxwait = 100; /* about 120us */\n\n\t/* Select page 0 registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Reset remote DMA complete flag. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_ISR, ED_ISR_RDC);\n\n\t/* Set up DMA byte count. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR0, len);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR1, len >> 8);\n\n\t/* Set up destination address in NIC mem. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RSAR0, dst);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RSAR1, dst >> 8);\n\n\t/* Set remote DMA write. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD1 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tif (sc->isa16bit)\n\t\tbus_space_write_raw_multi_2(iot, ioh,\n\t\t    sc->asic_base + ED_NOVELL_DATA, src, len);\n\telse\n\t\tbus_space_write_multi_1(iot, ioh,\n\t\t    sc->asic_base + ED_NOVELL_DATA, src, len);\n\n\t/*\n\t * Wait for remote DMA complete.  This is necessary because on the\n\t * transmit side, data is handled internally by the NIC in bursts and\n\t * we can't start another remote DMA until this one completes.  Not\n\t * waiting causes really bad things to happen - like the NIC\n\t * irrecoverably jamming the ISA bus.\n\t */\n\twhile (((NIC_GET(iot, ioh, nicbase, ED_P0_ISR) & ED_ISR_RDC) !=\n\t    ED_ISR_RDC) && --maxwait);\n}"
  },
  {
    "function_name": "ed_pio_readmem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
    "lines": "2584-2620",
    "snippet": "void\ned_pio_readmem(sc, src, dst, amount)\n\tstruct ed_softc *sc;\n\tu_int16_t src;\n\tcaddr_t dst;\n\tu_int16_t amount;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint nicbase = sc->nic_base;\n\n\t/* Select page 0 registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Round up to a word. */\n\tif (amount & 1)\n\t\t++amount;\n\n\t/* Set up DMA byte count. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR0, amount);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR1, amount >> 8);\n\n\t/* Set up source address in NIC mem. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RSAR0, src);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RSAR1, src >> 8);\n\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD0 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tif (sc->isa16bit)\n\t\tbus_space_read_raw_multi_2(iot, ioh,\n\t\t    sc->asic_base + ED_NOVELL_DATA, dst, amount);\n\telse\n\t\tbus_space_read_multi_1(iot, ioh,\n\t\t    sc->asic_base + ED_NOVELL_DATA, dst, amount);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/isa/if_edreg.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"ed.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ed_pio_readmem",
      "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;",
      "int src;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_read_multi_1",
          "args": [
            "iot",
            "ioh",
            "sc->asic_base + ED_NOVELL_DATA",
            "dst",
            "amount"
          ],
          "line": 2618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_raw_multi_2",
          "args": [
            "iot",
            "ioh",
            "sc->asic_base + ED_NOVELL_DATA",
            "dst",
            "amount"
          ],
          "line": 2615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_CR",
            "ED_CR_RD0 | ED_CR_PAGE_0 | ED_CR_STA"
          ],
          "line": 2611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_RSAR1",
            "src >> 8"
          ],
          "line": 2609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_RSAR0",
            "src"
          ],
          "line": 2608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_RBCR1",
            "amount >> 8"
          ],
          "line": 2605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_RBCR0",
            "amount"
          ],
          "line": 2604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_CR",
            "ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA"
          ],
          "line": 2596
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nvoid ed_pio_readmem;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\nint src;\n\nvoid\ned_pio_readmem(sc, src, dst, amount)\n\tstruct ed_softc *sc;\n\tu_int16_t src;\n\tcaddr_t dst;\n\tu_int16_t amount;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint nicbase = sc->nic_base;\n\n\t/* Select page 0 registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Round up to a word. */\n\tif (amount & 1)\n\t\t++amount;\n\n\t/* Set up DMA byte count. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR0, amount);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR1, amount >> 8);\n\n\t/* Set up source address in NIC mem. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RSAR0, src);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RSAR1, src >> 8);\n\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD0 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tif (sc->isa16bit)\n\t\tbus_space_read_raw_multi_2(iot, ioh,\n\t\t    sc->asic_base + ED_NOVELL_DATA, dst, amount);\n\telse\n\t\tbus_space_read_multi_1(iot, ioh,\n\t\t    sc->asic_base + ED_NOVELL_DATA, dst, amount);\n}"
  },
  {
    "function_name": "edread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
    "lines": "2539-2572",
    "snippet": "void\nedread(sc, buf, len)\n\tstruct ed_softc *sc;\n\tint buf, len;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tstruct mbuf *m;\n\tstruct ether_header *eh;\n\n\t/* Pull packet off interface. */\n\tm = edget(sc, buf, len);\n\tif (m == 0) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\tifp->if_ipackets++;\n\n\t/* We assume that the header fit entirely in one mbuf. */\n\teh = mtod(m, struct ether_header *);\n\n#if NBPFILTER > 0\n\t/*\n\t * Check if there's a BPF listener on this interface.\n\t * If so, hand off the raw packet to BPF.\n\t */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t/* We assume that the header fit entirely in one mbuf. */\n\tm_adj(m, sizeof(struct ether_header));\n\tether_input(ifp, eh, m);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/isa/if_edreg.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"ed.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void edread",
      "struct mbuf *edget",
      "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ether_input",
          "args": [
            "ifp",
            "eh",
            "m"
          ],
          "line": 2571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_adj",
          "args": [
            "m",
            "sizeof(struct ether_header)"
          ],
          "line": 2570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "m"
          ],
          "line": 2566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "structether_header*"
          ],
          "line": 2558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "edget",
          "args": [
            "sc",
            "buf",
            "len"
          ],
          "line": 2549
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nvoid edread;\nstruct mbuf *edget;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nvoid\nedread(sc, buf, len)\n\tstruct ed_softc *sc;\n\tint buf, len;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tstruct mbuf *m;\n\tstruct ether_header *eh;\n\n\t/* Pull packet off interface. */\n\tm = edget(sc, buf, len);\n\tif (m == 0) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\tifp->if_ipackets++;\n\n\t/* We assume that the header fit entirely in one mbuf. */\n\teh = mtod(m, struct ether_header *);\n\n#if NBPFILTER > 0\n\t/*\n\t * Check if there's a BPF listener on this interface.\n\t * If so, hand off the raw packet to BPF.\n\t */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t/* We assume that the header fit entirely in one mbuf. */\n\tm_adj(m, sizeof(struct ether_header));\n\tether_input(ifp, eh, m);\n}"
  },
  {
    "function_name": "edioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
    "lines": "2440-2533",
    "snippet": "int\nedioctl(ifp, cmd, data)\n\tregister struct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct ed_softc *sc = ifp->if_softc;\n\tregister struct ifaddr *ifa = (struct ifaddr *)data;\n\tstruct ifreq *ifr = (struct ifreq *)data;\n\tint s, error = 0;\n\n\ts = splnet();\n\tif ((sc->spec_flags & ED_NOTPRESENT) != 0) {\n\t\tif_down(ifp);\n\t\tprintf(\"%s: device offline\\n\", sc->sc_dev.dv_xname);\n\t\tsplx(s);\n\t\treturn ENXIO;\t\t/* may be ignored, oh well. */\n\t}\n\n\tif ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {\n\t\tsplx(s);\n\t\treturn error;\n\t}\n\n\tswitch (cmd) {\n\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tedinit(sc);\n\t\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tedinit(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS:\n\t\tif ((ifp->if_flags & IFF_UP) == 0 &&\n\t\t    (ifp->if_flags & IFF_RUNNING) != 0) {\n\t\t\t/*\n\t\t\t * If interface is marked down and it is running, then\n\t\t\t * stop it.\n\t\t\t */\n\t\t\tedstop(sc);\n\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\t} else if ((ifp->if_flags & IFF_UP) != 0 &&\n\t\t    \t   (ifp->if_flags & IFF_RUNNING) == 0) {\n\t\t\t/*\n\t\t\t * If interface is marked up and it is stopped, then\n\t\t\t * start it.\n\t\t\t */\n\t\t\tedinit(sc);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Reset the interface to pick up changes in any other\n\t\t\t * flags that affect hardware registers.\n\t\t\t */\n\t\t\tedstop(sc);\n\t\t\tedinit(sc);\n\t\t}\n\t\tbreak;\n\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\t/* Update our multicast list. */\n\t\terror = (cmd == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->sc_arpcom) :\n\t\t    ether_delmulti(ifr, &sc->sc_arpcom);\n\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware filter\n\t\t\t * accordingly.\n\t\t\t */\n\t\t\tedstop(sc); /* XXX for ds_setmcaf? */\n\t\t\tedinit(sc);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\tsplx(s);\n\treturn (error);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/isa/if_edreg.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"ed.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define ED_NOTPRESENT \t0x0002\t/* card not present; do not allow\n\t\t\t\t   reconfiguration */"
    ],
    "globals_used": [
      "int edioctl",
      "void edinit",
      "void edstop",
      "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "edinit",
          "args": [
            "sc"
          ],
          "line": 2521
        },
        "resolved": true,
        "details": {
          "function_name": "edinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
          "lines": "1788-1937",
          "snippet": "void\nedinit(sc)\n\tstruct ed_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint nicbase = sc->nic_base, asicbase = sc->asic_base;\n\tint i;\n\tu_int32_t mcaf[2];\n\n\t/*\n\t * Initialize the NIC in the exact order outlined in the NS manual.\n\t * This init procedure is \"mandatory\"...don't change what or when\n\t * things happen.\n\t */\n\n\t/* Reset transmitter flags. */\n\tifp->if_timer = 0;\n\n\tsc->txb_inuse = 0;\n\tsc->txb_new = 0;\n\tsc->txb_next_tx = 0;\n\n\t/* Set interface for page 0, remote DMA complete, stopped. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\tif (sc->isa16bit) {\n\t\t/*\n\t\t * Set FIFO threshold to 8, No auto-init Remote DMA, byte\n\t\t * order=80x86, word-wide DMA xfers,\n\t\t */\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_DCR,\n\t\t    ED_DCR_FT1 | ED_DCR_WTS | ED_DCR_LS);\n\t} else {\n\t\t/* Same as above, but byte-wide DMA xfers. */\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_DCR, ED_DCR_FT1 | ED_DCR_LS);\n\t}\n\n\t/* Clear remote byte count registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR0, 0);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR1, 0);\n\n\t/* Tell RCR to do nothing for now. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RCR, ED_RCR_MON);\n\n\t/* Place NIC in internal loopback mode. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_TCR, ED_TCR_LB0);\n\n\t/* Set lower bits of byte addressable framing to 0. */\n\tif (sc->is790)\n\t\tNIC_PUT(iot, ioh, nicbase, 0x09, 0);\n\n\t/* Initialize receive buffer ring. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_BNRY, sc->rec_page_start);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTART, sc->rec_page_start);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTOP, sc->rec_page_stop);\n\n\t/*\n\t * Clear all interrupts.  A '1' in each bit position clears the\n\t * corresponding flag.\n\t */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_ISR, 0xff);\n\n\t/*\n\t * Enable the following interrupts: receive/transmit complete,\n\t * receive/transmit error, and Receiver OverWrite.\n\t *\n\t * Counter overflow and Remote DMA complete are *not* enabled.\n\t */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_IMR,\n\t    ED_IMR_PRXE | ED_IMR_PTXE | ED_IMR_RXEE | ED_IMR_TXEE |\n\t    ED_IMR_OVWE);\n\n\t/* Program command register for page 1. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_1 | ED_CR_STP);\n\n\t/* Copy out our station address. */\n\tfor (i = 0; i < ETHER_ADDR_LEN; ++i)\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P1_PAR0 + i,\n\t\t    sc->sc_arpcom.ac_enaddr[i]);\n\n\t/* Set multicast filter on chip. */\n\ted_getmcaf(&sc->sc_arpcom, mcaf);\n\tfor (i = 0; i < 8; i++)\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P1_MAR0 + i,\n\t\t    ((u_char *)mcaf)[i]);\n\n\t/*\n\t * Set current page pointer to one page after the boundary pointer, as\n\t * recommended in the National manual.\n\t */\n\tsc->next_packet = sc->rec_page_start + 1;\n\tNIC_PUT(iot, ioh, nicbase, ED_P1_CURR, sc->next_packet);\n\n\t/* Program command register for page 0. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P1_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\ti = ED_RCR_AB | ED_RCR_AM;\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\t/*\n\t\t * Set promiscuous mode.  Multicast filter was set earlier so\n\t\t * that we should receive all multicast packets.\n\t\t */\n\t\ti |= ED_RCR_PRO | ED_RCR_AR | ED_RCR_SEP;\n\t}\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RCR, i);\n\n\t/* Take interface out of loopback. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_TCR, 0);\n\n\t/*\n\t * If this is a 3Com board, the tranceiver must be software enabled\n\t * (there is no settable hardware default).\n\t */\n\tswitch (sc->vendor) {\n\t\tu_char x;\n\tcase ED_VENDOR_3COM:\n\t\tif (ifp->if_flags & IFF_LINK0)\n\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_CR, 0);\n\t\telse\n\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_CR,\n\t\t\t    ED_3COM_CR_XSEL);\n\t\tbreak;\n\tcase ED_VENDOR_WD_SMC:\n\t\tif ((sc->type & ED_WD_SOFTCONFIG) == 0)\n\t\t\tbreak;\n\t\tx = bus_space_read_1(iot, ioh, asicbase + ED_WD_IRR);\n\t\tif (ifp->if_flags & IFF_LINK0)\n\t\t\tx &= ~ED_WD_IRR_OUT2;\n\t\telse\n\t\t\tx |= ED_WD_IRR_OUT2;\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_IRR, x);\n\t\tbreak;\n\t}\n\n\t/* Fire up the interface. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Set 'running' flag, and clear output active flag. */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/* ...and attempt to start output. */\n\tedstart(ifp);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/isa/if_edreg.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"ed.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tETHER_ADDR_LEN\t6"
          ],
          "globals_used": [
            "void edstart",
            "void edinit",
            "void ed_getmcaf",
            "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\n#define\tETHER_ADDR_LEN\t6\n\nvoid edstart;\nvoid edinit;\nvoid ed_getmcaf;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nvoid\nedinit(sc)\n\tstruct ed_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint nicbase = sc->nic_base, asicbase = sc->asic_base;\n\tint i;\n\tu_int32_t mcaf[2];\n\n\t/*\n\t * Initialize the NIC in the exact order outlined in the NS manual.\n\t * This init procedure is \"mandatory\"...don't change what or when\n\t * things happen.\n\t */\n\n\t/* Reset transmitter flags. */\n\tifp->if_timer = 0;\n\n\tsc->txb_inuse = 0;\n\tsc->txb_new = 0;\n\tsc->txb_next_tx = 0;\n\n\t/* Set interface for page 0, remote DMA complete, stopped. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\tif (sc->isa16bit) {\n\t\t/*\n\t\t * Set FIFO threshold to 8, No auto-init Remote DMA, byte\n\t\t * order=80x86, word-wide DMA xfers,\n\t\t */\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_DCR,\n\t\t    ED_DCR_FT1 | ED_DCR_WTS | ED_DCR_LS);\n\t} else {\n\t\t/* Same as above, but byte-wide DMA xfers. */\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_DCR, ED_DCR_FT1 | ED_DCR_LS);\n\t}\n\n\t/* Clear remote byte count registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR0, 0);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR1, 0);\n\n\t/* Tell RCR to do nothing for now. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RCR, ED_RCR_MON);\n\n\t/* Place NIC in internal loopback mode. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_TCR, ED_TCR_LB0);\n\n\t/* Set lower bits of byte addressable framing to 0. */\n\tif (sc->is790)\n\t\tNIC_PUT(iot, ioh, nicbase, 0x09, 0);\n\n\t/* Initialize receive buffer ring. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_BNRY, sc->rec_page_start);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTART, sc->rec_page_start);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTOP, sc->rec_page_stop);\n\n\t/*\n\t * Clear all interrupts.  A '1' in each bit position clears the\n\t * corresponding flag.\n\t */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_ISR, 0xff);\n\n\t/*\n\t * Enable the following interrupts: receive/transmit complete,\n\t * receive/transmit error, and Receiver OverWrite.\n\t *\n\t * Counter overflow and Remote DMA complete are *not* enabled.\n\t */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_IMR,\n\t    ED_IMR_PRXE | ED_IMR_PTXE | ED_IMR_RXEE | ED_IMR_TXEE |\n\t    ED_IMR_OVWE);\n\n\t/* Program command register for page 1. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_1 | ED_CR_STP);\n\n\t/* Copy out our station address. */\n\tfor (i = 0; i < ETHER_ADDR_LEN; ++i)\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P1_PAR0 + i,\n\t\t    sc->sc_arpcom.ac_enaddr[i]);\n\n\t/* Set multicast filter on chip. */\n\ted_getmcaf(&sc->sc_arpcom, mcaf);\n\tfor (i = 0; i < 8; i++)\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P1_MAR0 + i,\n\t\t    ((u_char *)mcaf)[i]);\n\n\t/*\n\t * Set current page pointer to one page after the boundary pointer, as\n\t * recommended in the National manual.\n\t */\n\tsc->next_packet = sc->rec_page_start + 1;\n\tNIC_PUT(iot, ioh, nicbase, ED_P1_CURR, sc->next_packet);\n\n\t/* Program command register for page 0. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P1_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\ti = ED_RCR_AB | ED_RCR_AM;\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\t/*\n\t\t * Set promiscuous mode.  Multicast filter was set earlier so\n\t\t * that we should receive all multicast packets.\n\t\t */\n\t\ti |= ED_RCR_PRO | ED_RCR_AR | ED_RCR_SEP;\n\t}\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RCR, i);\n\n\t/* Take interface out of loopback. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_TCR, 0);\n\n\t/*\n\t * If this is a 3Com board, the tranceiver must be software enabled\n\t * (there is no settable hardware default).\n\t */\n\tswitch (sc->vendor) {\n\t\tu_char x;\n\tcase ED_VENDOR_3COM:\n\t\tif (ifp->if_flags & IFF_LINK0)\n\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_CR, 0);\n\t\telse\n\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_CR,\n\t\t\t    ED_3COM_CR_XSEL);\n\t\tbreak;\n\tcase ED_VENDOR_WD_SMC:\n\t\tif ((sc->type & ED_WD_SOFTCONFIG) == 0)\n\t\t\tbreak;\n\t\tx = bus_space_read_1(iot, ioh, asicbase + ED_WD_IRR);\n\t\tif (ifp->if_flags & IFF_LINK0)\n\t\t\tx &= ~ED_WD_IRR_OUT2;\n\t\telse\n\t\t\tx |= ED_WD_IRR_OUT2;\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_IRR, x);\n\t\tbreak;\n\t}\n\n\t/* Fire up the interface. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Set 'running' flag, and clear output active flag. */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/* ...and attempt to start output. */\n\tedstart(ifp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "edstop",
          "args": [
            "sc"
          ],
          "line": 2520
        },
        "resolved": true,
        "details": {
          "function_name": "edstop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
          "lines": "1747-1767",
          "snippet": "void\nedstop(sc)\n\tstruct ed_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint nicbase = sc->nic_base;\n\tint n = 5000;\n\n\t/* Stop everything on the interface, and select page 0 registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\t/*\n\t * Wait for interface to enter stopped state, but limit # of checks to\n\t * 'n' (about 5ms).  It shouldn't even take 5us on modern DS8390's, but\n\t * just in case it's an old one.\n\t */\n\twhile (((NIC_GET(iot, ioh, nicbase,\n\t    ED_P0_ISR) & ED_ISR_RST) == 0) && --n);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/isa/if_edreg.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"ed.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void edstop",
            "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nvoid edstop;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nvoid\nedstop(sc)\n\tstruct ed_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint nicbase = sc->nic_base;\n\tint n = 5000;\n\n\t/* Stop everything on the interface, and select page 0 registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\t/*\n\t * Wait for interface to enter stopped state, but limit # of checks to\n\t * 'n' (about 5ms).  It shouldn't even take 5us on modern DS8390's, but\n\t * just in case it's an old one.\n\t */\n\twhile (((NIC_GET(iot, ioh, nicbase,\n\t    ED_P0_ISR) & ED_ISR_RST) == 0) && --n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_delmulti",
          "args": [
            "ifr",
            "&sc->sc_arpcom"
          ],
          "line": 2513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_addmulti",
          "args": [
            "ifr",
            "&sc->sc_arpcom"
          ],
          "line": 2512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arp_ifinit",
          "args": [
            "&sc->sc_arpcom",
            "ifa"
          ],
          "line": 2473
        },
        "resolved": true,
        "details": {
          "function_name": "arp_ifinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_devar.h",
          "lines": "929-936",
          "snippet": "static void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}",
          "includes": [
            "#include <sys/devconf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/devconf.h>\n\nstatic void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ioctl",
          "args": [
            "ifp",
            "&sc->sc_arpcom",
            "cmd",
            "data"
          ],
          "line": 2459
        },
        "resolved": true,
        "details": {
          "function_name": "wx_ether_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "303-356",
          "snippet": "static int\nwx_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tIOCTL_CMD_TYPE cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tint error = 0;\n\twx_softc_t *sc = SOFTC_IFP(ifp);\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\terror = wx_init(sc);\n\t\tif (error) {\n\t\t\tifp->if_flags &= ~IFF_UP;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n#ifdef __OpenBSD__\n\t\t\tarp_ifinit(&sc->w.arpcom, ifa);\n#else\n\t\t\tarp_ifinit(ifp, ifa);\n#endif\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t{\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t break;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int wx_init",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic int wx_init;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic int\nwx_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tIOCTL_CMD_TYPE cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tint error = 0;\n\twx_softc_t *sc = SOFTC_IFP(ifp);\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\terror = wx_init(sc);\n\t\tif (error) {\n\t\t\tifp->if_flags &= ~IFF_UP;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n#ifdef __OpenBSD__\n\t\t\tarp_ifinit(&sc->w.arpcom, ifa);\n#else\n\t\t\tarp_ifinit(ifp, ifa);\n#endif\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t{\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t break;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: device offline\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 2454
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "if_down",
          "args": [
            "ifp"
          ],
          "line": 2453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 2451
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\n#define ED_NOTPRESENT \t0x0002\t/* card not present; do not allow\n\t\t\t\t   reconfiguration */\n\nint edioctl;\nvoid edinit;\nvoid edstop;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nint\nedioctl(ifp, cmd, data)\n\tregister struct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct ed_softc *sc = ifp->if_softc;\n\tregister struct ifaddr *ifa = (struct ifaddr *)data;\n\tstruct ifreq *ifr = (struct ifreq *)data;\n\tint s, error = 0;\n\n\ts = splnet();\n\tif ((sc->spec_flags & ED_NOTPRESENT) != 0) {\n\t\tif_down(ifp);\n\t\tprintf(\"%s: device offline\\n\", sc->sc_dev.dv_xname);\n\t\tsplx(s);\n\t\treturn ENXIO;\t\t/* may be ignored, oh well. */\n\t}\n\n\tif ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {\n\t\tsplx(s);\n\t\treturn error;\n\t}\n\n\tswitch (cmd) {\n\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tedinit(sc);\n\t\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tedinit(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS:\n\t\tif ((ifp->if_flags & IFF_UP) == 0 &&\n\t\t    (ifp->if_flags & IFF_RUNNING) != 0) {\n\t\t\t/*\n\t\t\t * If interface is marked down and it is running, then\n\t\t\t * stop it.\n\t\t\t */\n\t\t\tedstop(sc);\n\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\t} else if ((ifp->if_flags & IFF_UP) != 0 &&\n\t\t    \t   (ifp->if_flags & IFF_RUNNING) == 0) {\n\t\t\t/*\n\t\t\t * If interface is marked up and it is stopped, then\n\t\t\t * start it.\n\t\t\t */\n\t\t\tedinit(sc);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Reset the interface to pick up changes in any other\n\t\t\t * flags that affect hardware registers.\n\t\t\t */\n\t\t\tedstop(sc);\n\t\t\tedinit(sc);\n\t\t}\n\t\tbreak;\n\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\t/* Update our multicast list. */\n\t\terror = (cmd == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->sc_arpcom) :\n\t\t    ether_delmulti(ifr, &sc->sc_arpcom);\n\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware filter\n\t\t\t * accordingly.\n\t\t\t */\n\t\t\tedstop(sc); /* XXX for ds_setmcaf? */\n\t\t\tedinit(sc);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\tsplx(s);\n\treturn (error);\n}"
  },
  {
    "function_name": "edintr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
    "lines": "2229-2435",
    "snippet": "int\nedintr(arg)\n\tvoid *arg;\n{\n\tstruct ed_softc *sc = arg;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint nicbase = sc->nic_base, asicbase = sc->asic_base;\n\tu_char isr;\n\n\t/* Set NIC to page 0 registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tisr = NIC_GET(iot, ioh, nicbase, ED_P0_ISR);\n\tif (!isr)\n\t\treturn (0);\n\n\t/* Loop until there are no more new interrupts. */\n\tfor (;;) {\n\t\t/*\n\t\t * Reset all the bits that we are 'acknowledging' by writing a\n\t\t * '1' to each bit position that was set.\n\t\t * (Writing a '1' *clears* the bit.)\n\t\t */\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_ISR, isr);\n\n\t\t/*\n\t\t * Handle transmitter interrupts.  Handle these first because\n\t\t * the receiver will reset the board under some conditions.\n\t\t */\n\t\tif (isr & (ED_ISR_PTX | ED_ISR_TXE)) {\n\t\t\tu_char collisions = NIC_GET(iot, ioh, nicbase,\n\t\t\t    ED_P0_NCR) & 0x0f;\n\n\t\t\t/*\n\t\t\t * Check for transmit error.  If a TX completed with an\n\t\t\t * error, we end up throwing the packet away.  Really\n\t\t\t * the only error that is possible is excessive\n\t\t\t * collisions, and in this case it is best to allow the\n\t\t\t * automatic mechanisms of TCP to backoff the flow.  Of\n\t\t\t * course, with UDP we're screwed, but this is expected\n\t\t\t * when a network is heavily loaded.\n\t\t\t */\n\t\t\t(void) NIC_GET(iot, ioh, nicbase, ED_P0_TSR);\n\t\t\tif (isr & ED_ISR_TXE) {\n\t\t\t\t/*\n\t\t\t\t * Excessive collisions (16).\n\t\t\t\t */\n\t\t\t\tif ((NIC_GET(iot, ioh, nicbase, ED_P0_TSR) &\n\t\t\t\t    ED_TSR_ABT) && (collisions == 0)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * When collisions total 16, the P0_NCR\n\t\t\t\t\t * will indicate 0, and the TSR_ABT is\n\t\t\t\t\t * set.\n\t\t\t\t\t */\n\t\t\t\t\tcollisions = 16;\n\t\t\t\t}\n\n\t\t\t\t/* Update output errors counter. */\n\t\t\t\t++ifp->if_oerrors;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Update total number of successfully\n\t\t\t\t * transmitted packets.\n\t\t\t\t */\n\t\t\t\t++ifp->if_opackets;\n\t\t\t}\n\n\t\t\t/* Done with the buffer. */\n\t\t\tsc->txb_inuse--;\n\n\t\t\t/* Clear watchdog timer. */\n\t\t\tifp->if_timer = 0;\n\t\t\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t\t\t/*\n\t\t\t * Add in total number of collisions on last\n\t\t\t * transmission.\n\t\t\t */\n\t\t\tifp->if_collisions += collisions;\n\n\t\t\t/*\n\t\t\t * Decrement buffer in-use count if not zero (can only\n\t\t\t * be zero if a transmitter interrupt occured while not\n\t\t\t * actually transmitting).\n\t\t\t * If data is ready to transmit, start it transmitting,\n\t\t\t * otherwise defer until after handling receiver.\n\t\t\t */\n\t\t\tif (sc->txb_inuse > 0)\n\t\t\t\ted_xmit(sc);\n\t\t}\n\n\t\t/* Handle receiver interrupts. */\n\t\tif (isr & (ED_ISR_PRX | ED_ISR_RXE | ED_ISR_OVW)) {\n\t\t\t/*\n\t\t\t * Overwrite warning.  In order to make sure that a\n\t\t\t * lockup of the local DMA hasn't occurred, we reset\n\t\t\t * and re-init the NIC.  The NSC manual suggests only a\n\t\t\t * partial reset/re-init is necessary - but some chips\n\t\t\t * seem to want more.  The DMA lockup has been seen\n\t\t\t * only with early rev chips - Methinks this bug was\n\t\t\t * fixed in later revs.  -DG\n\t\t\t */\n\t\t\tif (isr & ED_ISR_OVW) {\n\t\t\t\t++ifp->if_ierrors;\n#ifdef DIAGNOSTIC\n\t\t\t\tlog(LOG_WARNING,\n\t\t\t\t    \"%s: warning - receiver ring buffer overrun\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n#endif\n\t\t\t\t/* Stop/reset/re-init NIC. */\n\t\t\t\tedreset(sc);\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Receiver Error.  One or more of: CRC error,\n\t\t\t\t * frame alignment error FIFO overrun, or\n\t\t\t\t * missed packet.\n\t\t\t\t */\n\t\t\t\tif (isr & ED_ISR_RXE) {\n\t\t\t\t\t++ifp->if_ierrors;\n#ifdef ED_DEBUG\n\t\t\t\t\tprintf(\"%s: receive error %x\\n\",\n\t\t\t\t\t    sc->sc_dev.dv_xname,\n\t\t\t\t\t    NIC_GET(iot,ioh,nicbase,ED_P0_RSR));\n#endif\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Go get the packet(s).\n\t\t\t\t * XXX - Doing this on an error is dubious\n\t\t\t\t * because there shouldn't be any data to get\n\t\t\t\t * (we've configured the interface to not\n\t\t\t\t * accept packets with errors).\n\t\t\t\t */\n\n\t\t\t\t/*\n\t\t\t\t * Enable 16bit access to shared memory first\n\t\t\t\t * on WD/SMC boards.\n\t\t\t\t */\n\t\t\t\tif (sc->vendor == ED_VENDOR_WD_SMC) {\n\t\t\t\t\tif (sc->isa16bit)\n\t\t\t\t\t\tbus_space_write_1(iot, ioh,\n\t\t\t\t\t\t    asicbase + ED_WD_LAAR,\n\t\t\t\t\t\t    sc->wd_laar_proto |\n\t\t\t\t\t\t    ED_WD_LAAR_M16EN);\n\t\t\t\t\tbus_space_write_1(iot, ioh,\n\t\t\t\t\t    asicbase + ED_WD_MSR,\n\t\t\t\t\t    sc->wd_msr_proto | ED_WD_MSR_MENB);\n\t\t\t\t\t(void) bus_space_read_1(iot,\n\t\t\t\t\t    sc->sc_delaybah, 0);\n\t\t\t\t\t(void) bus_space_read_1(iot,\n\t\t\t\t\t    sc->sc_delaybah, 0);\n\t\t\t\t}\n\n\t\t\t\ted_rint(sc);\n\n\t\t\t\t/* Disable 16-bit access. */\n\t\t\t\tif (sc->vendor == ED_VENDOR_WD_SMC) {\n\t\t\t\t\tbus_space_write_1(iot, ioh,\n\t\t\t\t\t    asicbase + ED_WD_MSR,\n\t\t\t\t\t    sc->wd_msr_proto);\n\t\t\t\t\tif (sc->isa16bit)\n\t\t\t\t\t\tbus_space_write_1(iot, ioh,\n\t\t\t\t\t\t    asicbase + ED_WD_LAAR,\n\t\t\t\t\t\t    sc->wd_laar_proto);\n\t\t\t\t\t(void) bus_space_read_1(iot,\n\t\t\t\t\t    sc->sc_delaybah, 0);\n\t\t\t\t\t(void) bus_space_read_1(iot,\n\t\t\t\t\t    sc->sc_delaybah, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If it looks like the transmitter can take more data,\tattempt\n\t\t * to start output on the interface.  This is done after\n\t\t * handling the receiver to give the receiver priority.\n\t\t */\n\t\tedstart(ifp);\n\n\t\t/*\n\t\t * Return NIC CR to standard state: page 0, remote DMA\n\t\t * complete, start (toggling the TXP bit off, even if was just\n\t\t * set in the transmit routine, is *okay* - it is 'edge'\n\t\t * triggered from low to high).\n\t\t */\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t\t/*\n\t\t * If the Network Talley Counters overflow, read them to reset\n\t\t * them.  It appears that old 8390's won't clear the ISR flag\n\t\t * otherwise - resulting in an infinite loop.\n\t\t */\n\t\tif (isr & ED_ISR_CNT) {\n\t\t\t(void) NIC_GET(iot, ioh, nicbase, ED_P0_CNTR0);\n\t\t\t(void) NIC_GET(iot, ioh, nicbase, ED_P0_CNTR1);\n\t\t\t(void) NIC_GET(iot, ioh, nicbase, ED_P0_CNTR2);\n\t\t}\n\n\t\tisr = NIC_GET(iot, ioh, nicbase, ED_P0_ISR);\n\t\tif (!isr)\n\t\t\treturn (1);\n\t}\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/isa/if_edreg.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"ed.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int edintr",
      "void edstart",
      "void edreset",
      "static __inline void ed_rint",
      "static __inline void ed_xmit",
      "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NIC_GET",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_ISR"
          ],
          "line": 2431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_GET",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_CNTR2"
          ],
          "line": 2428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_GET",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_CNTR1"
          ],
          "line": 2427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_GET",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_CNTR0"
          ],
          "line": 2426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_CR",
            "sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA"
          ],
          "line": 2417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "edstart",
          "args": [
            "ifp"
          ],
          "line": 2409
        },
        "resolved": true,
        "details": {
          "function_name": "edstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
          "lines": "1988-2100",
          "snippet": "void\nedstart(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct ed_softc *sc = ifp->if_softc;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct mbuf *m0, *m;\n\tint buffer;\n\tint asicbase = sc->asic_base;\n\tint len;\n\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\noutloop:\n\t/* See if there is room to put another packet in the buffer. */\n\tif (sc->txb_inuse == sc->txb_cnt) {\n\t\t/* No room.  Indicate this to the outside world and exit. */\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\tif (m0 == 0)\n\t\treturn;\n\n\t/* We need to use m->m_pkthdr.len, so require the header */\n\tif ((m0->m_flags & M_PKTHDR) == 0)\n\t\tpanic(\"edstart: no header mbuf\");\n\n#if NBPFILTER > 0\n\t/* Tap off here if there is a BPF listener. */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n\t/* txb_new points to next open buffer slot. */\n\tbuffer = sc->mem_start +\n\t    ((sc->txb_new * ED_TXBUF_SIZE) << ED_PAGE_SHIFT);\n\n\tif (sc->mem_shared) {\n\t\t/* Special case setup for 16 bit boards... */\n\t\tswitch (sc->vendor) {\n\t\t/*\n\t\t * For 16bit 3Com boards (which have 16k of memory), we\n\t\t * have the xmit buffers in a different page of memory\n\t\t * ('page 0') - so change pages.\n\t\t */\n\t\tcase ED_VENDOR_3COM:\n\t\t\tif (sc->isa16bit)\n\t\t\t\tbus_space_write_1(iot, ioh,\n\t\t\t\t    asicbase + ED_3COM_GACFR,\n\t\t\t\t    ED_3COM_GACFR_RSEL);\n\t\t\tbreak;\n\t\t/*\n\t\t * Enable 16bit access to shared memory on WD/SMC\n\t\t * boards.\n\t\t */\n\t\tcase ED_VENDOR_WD_SMC:\n\t\t\tif (sc->isa16bit)\n\t\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_LAAR,\n\t\t\t\t    sc->wd_laar_proto | ED_WD_LAAR_M16EN);\n\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR,\n\t\t\t    sc->wd_msr_proto | ED_WD_MSR_MENB);\n\t\t\t(void) bus_space_read_1(iot, sc->sc_delaybah, 0);\n\t\t\t(void) bus_space_read_1(iot, sc->sc_delaybah, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (m = m0; m != 0; m = m->m_next) {\n\t\t\ted_shared_writemem(sc, mtod(m, caddr_t), buffer,\n\t\t\t    m->m_len);\n\t\t\tbuffer += m->m_len;\n\t\t}\n\t\tlen = m0->m_pkthdr.len;\n\n\t\t/* Restore previous shared memory access. */\n\t\tswitch (sc->vendor) {\n\t\tcase ED_VENDOR_3COM:\n\t\t\tif (sc->isa16bit)\n\t\t\t\tbus_space_write_1(iot, ioh,\n\t\t\t\t    asicbase + ED_3COM_GACFR,\n\t\t\t\t    ED_3COM_GACFR_RSEL | ED_3COM_GACFR_MBS0);\n\t\t\tbreak;\n\t\tcase ED_VENDOR_WD_SMC:\n\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR,\n\t\t\t    sc->wd_msr_proto);\n\t\t\tif (sc->isa16bit)\n\t\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_LAAR,\n\t\t\t\t    sc->wd_laar_proto);\n\t\t\t(void) bus_space_read_1(iot, sc->sc_delaybah, 0);\n\t\t\t(void) bus_space_read_1(iot, sc->sc_delaybah, 0);\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tlen = ed_pio_write_mbufs(sc, m0, (u_int16_t)buffer);\n\n\tm_freem(m0);\n\tsc->txb_len[sc->txb_new] = max(len, ETHER_MIN_LEN);\n\n\t/* Start the first packet transmitting. */\n\tif (sc->txb_inuse == 0)\n\t\ted_xmit(sc);\n\n\t/* Point to next buffer slot and wrap if necessary. */\n\tif (++sc->txb_new == sc->txb_cnt)\n\t\tsc->txb_new = 0;\n\tsc->txb_inuse++;\n\n\t/* Loop back to the top to possibly buffer more packets. */\n\tgoto outloop;\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/isa/if_edreg.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"ed.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tETHER_MIN_LEN\t64"
          ],
          "globals_used": [
            "void edstart",
            "void ed_shared_writemem",
            "static __inline void ed_xmit",
            "u_int16_t ed_pio_write_mbufs",
            "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\n#define\tETHER_MIN_LEN\t64\n\nvoid edstart;\nvoid ed_shared_writemem;\nstatic __inline void ed_xmit;\nu_int16_t ed_pio_write_mbufs;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nvoid\nedstart(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct ed_softc *sc = ifp->if_softc;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct mbuf *m0, *m;\n\tint buffer;\n\tint asicbase = sc->asic_base;\n\tint len;\n\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\noutloop:\n\t/* See if there is room to put another packet in the buffer. */\n\tif (sc->txb_inuse == sc->txb_cnt) {\n\t\t/* No room.  Indicate this to the outside world and exit. */\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\tif (m0 == 0)\n\t\treturn;\n\n\t/* We need to use m->m_pkthdr.len, so require the header */\n\tif ((m0->m_flags & M_PKTHDR) == 0)\n\t\tpanic(\"edstart: no header mbuf\");\n\n#if NBPFILTER > 0\n\t/* Tap off here if there is a BPF listener. */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n\t/* txb_new points to next open buffer slot. */\n\tbuffer = sc->mem_start +\n\t    ((sc->txb_new * ED_TXBUF_SIZE) << ED_PAGE_SHIFT);\n\n\tif (sc->mem_shared) {\n\t\t/* Special case setup for 16 bit boards... */\n\t\tswitch (sc->vendor) {\n\t\t/*\n\t\t * For 16bit 3Com boards (which have 16k of memory), we\n\t\t * have the xmit buffers in a different page of memory\n\t\t * ('page 0') - so change pages.\n\t\t */\n\t\tcase ED_VENDOR_3COM:\n\t\t\tif (sc->isa16bit)\n\t\t\t\tbus_space_write_1(iot, ioh,\n\t\t\t\t    asicbase + ED_3COM_GACFR,\n\t\t\t\t    ED_3COM_GACFR_RSEL);\n\t\t\tbreak;\n\t\t/*\n\t\t * Enable 16bit access to shared memory on WD/SMC\n\t\t * boards.\n\t\t */\n\t\tcase ED_VENDOR_WD_SMC:\n\t\t\tif (sc->isa16bit)\n\t\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_LAAR,\n\t\t\t\t    sc->wd_laar_proto | ED_WD_LAAR_M16EN);\n\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR,\n\t\t\t    sc->wd_msr_proto | ED_WD_MSR_MENB);\n\t\t\t(void) bus_space_read_1(iot, sc->sc_delaybah, 0);\n\t\t\t(void) bus_space_read_1(iot, sc->sc_delaybah, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (m = m0; m != 0; m = m->m_next) {\n\t\t\ted_shared_writemem(sc, mtod(m, caddr_t), buffer,\n\t\t\t    m->m_len);\n\t\t\tbuffer += m->m_len;\n\t\t}\n\t\tlen = m0->m_pkthdr.len;\n\n\t\t/* Restore previous shared memory access. */\n\t\tswitch (sc->vendor) {\n\t\tcase ED_VENDOR_3COM:\n\t\t\tif (sc->isa16bit)\n\t\t\t\tbus_space_write_1(iot, ioh,\n\t\t\t\t    asicbase + ED_3COM_GACFR,\n\t\t\t\t    ED_3COM_GACFR_RSEL | ED_3COM_GACFR_MBS0);\n\t\t\tbreak;\n\t\tcase ED_VENDOR_WD_SMC:\n\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR,\n\t\t\t    sc->wd_msr_proto);\n\t\t\tif (sc->isa16bit)\n\t\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_LAAR,\n\t\t\t\t    sc->wd_laar_proto);\n\t\t\t(void) bus_space_read_1(iot, sc->sc_delaybah, 0);\n\t\t\t(void) bus_space_read_1(iot, sc->sc_delaybah, 0);\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tlen = ed_pio_write_mbufs(sc, m0, (u_int16_t)buffer);\n\n\tm_freem(m0);\n\tsc->txb_len[sc->txb_new] = max(len, ETHER_MIN_LEN);\n\n\t/* Start the first packet transmitting. */\n\tif (sc->txb_inuse == 0)\n\t\ted_xmit(sc);\n\n\t/* Point to next buffer slot and wrap if necessary. */\n\tif (++sc->txb_new == sc->txb_cnt)\n\t\tsc->txb_new = 0;\n\tsc->txb_inuse++;\n\n\t/* Loop back to the top to possibly buffer more packets. */\n\tgoto outloop;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "sc->sc_delaybah",
            "0"
          ],
          "line": 2398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "sc->sc_delaybah",
            "0"
          ],
          "line": 2396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_WD_LAAR",
            "sc->wd_laar_proto"
          ],
          "line": 2393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_WD_MSR",
            "sc->wd_msr_proto"
          ],
          "line": 2389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed_rint",
          "args": [
            "sc"
          ],
          "line": 2385
        },
        "resolved": true,
        "details": {
          "function_name": "ed_rint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
          "lines": "2105-2226",
          "snippet": "static __inline void\ned_rint(sc)\n\tstruct ed_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint nicbase = sc->nic_base;\n\tu_int8_t boundary, current;\n\tu_int16_t len;\n\tu_int8_t nlen;\n\tu_int8_t next_packet;\t\t/* pointer to next packet */\n\tu_int16_t count;\t\t/* bytes in packet (length + 4) */\n\tu_int8_t packet_hdr[ED_RING_HDRSZ];\n\tint packet_ptr;\n\nloop:\n\t/* Set NIC to page 1 registers to get 'current' pointer. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_1 | ED_CR_STA);\n\n\t/*\n\t * 'sc->next_packet' is the logical beginning of the ring-buffer - i.e.\n\t * it points to where new data has been buffered.  The 'CURR' (current)\n\t * register points to the logical end of the ring-buffer - i.e. it\n\t * points to where additional new data will be added.  We loop here\n\t * until the logical beginning equals the logical end (or in other\n\t * words, until the ring-buffer is empty).\n\t */\n\tcurrent = NIC_GET(iot, ioh, nicbase, ED_P1_CURR);\n\tif (sc->next_packet == current)\n\t\treturn;\n\n\t/* Set NIC to page 0 registers to update boundary register. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P1_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tdo {\n\t\t/* Get pointer to this buffer's header structure. */\n\t\tpacket_ptr = sc->mem_ring +\n\t\t    ((sc->next_packet - sc->rec_page_start) << ED_PAGE_SHIFT);\n\n\t\t/*\n\t\t * The byte count includes a 4 byte header that was added by\n\t\t * the NIC.\n\t\t */\n\t\tif (sc->mem_shared)\n\t\t\ted_shared_readmem(sc, packet_ptr, packet_hdr,\n\t\t\t    sizeof(packet_hdr));\n\t\telse\n\t\t\ted_pio_readmem(sc, (u_int16_t)packet_ptr, packet_hdr,\n\t\t\t    sizeof(packet_hdr));\n\t\tnext_packet = packet_hdr[ED_RING_NEXT_PACKET];\n\t\tlen = count = packet_hdr[ED_RING_COUNT] +\n\t\t    256 * packet_hdr[ED_RING_COUNT + 1];\n\n\t\t/*\n\t\t * Try do deal with old, buggy chips that sometimes duplicate\n\t\t * the low byte of the length into the high byte.  We do this\n\t\t * by simply ignoring the high byte of the length and always\n\t\t * recalculating it.\n\t\t *\n\t\t * NOTE: sc->next_packet is pointing at the current packet.\n\t\t */\n\t\tif (next_packet >= sc->next_packet)\n\t\t\tnlen = (next_packet - sc->next_packet);\n\t\telse\n\t\t\tnlen = ((next_packet - sc->rec_page_start) +\n\t\t\t\t(sc->rec_page_stop - sc->next_packet));\n\t\t--nlen;\n\t\tif ((len & ED_PAGE_MASK) + sizeof(packet_hdr) > ED_PAGE_SIZE)\n\t\t\t--nlen;\n\t\tlen = (len & ED_PAGE_MASK) | (nlen << ED_PAGE_SHIFT);\n#ifdef DIAGNOSTIC\n\t\tif (len != count) {\n\t\t\tprintf(\"%s: length does not match next packet pointer\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tprintf(\"%s: len %04x nlen %04x start %02x first %02x curr %02x next %02x stop %02x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, count, len,\n\t\t\t    sc->rec_page_start, sc->next_packet, current,\n\t\t\t    next_packet, sc->rec_page_stop);\n\t\t}\n#endif\n\n\t\t/*\n\t\t * Be fairly liberal about what we allow as a \"reasonable\"\n\t\t * length so that a [crufty] packet will make it to BPF (and\n\t\t * can thus be analyzed).  Note that all that is really\n\t\t * important is that we have a length that will fit into one\n\t\t * mbuf cluster or less; the upper layer protocols can then\n\t\t * figure out the length from their own length field(s).\n\t\t */\n\t\tif (len <= MCLBYTES &&\n\t\t    next_packet >= sc->rec_page_start &&\n\t\t    next_packet < sc->rec_page_stop) {\n\t\t\t/* Go get packet. */\n\t\t\tedread(sc, packet_ptr + ED_RING_HDRSZ,\n\t\t\t    len - ED_RING_HDRSZ);\n\t\t} else {\n\t\t\t/* Really BAD.  The ring pointers are corrupted. */\n\t\t\tlog(LOG_ERR,\n\t\t\t    \"%s: NIC memory corrupt - invalid packet length %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, len);\n\t\t\t++sc->sc_arpcom.ac_if.if_ierrors;\n\t\t\tedreset(sc);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Update next packet pointer. */\n\t\tsc->next_packet = next_packet;\n\n\t\t/*\n\t\t * Update NIC boundary pointer - being careful to keep it one\n\t\t * buffer behind (as recommended by NS databook).\n\t\t */\n\t\tboundary = sc->next_packet - 1;\n\t\tif (boundary < sc->rec_page_start)\n\t\t\tboundary = sc->rec_page_stop - 1;\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_BNRY, boundary);\n\t} while (sc->next_packet != current);\n\n\tgoto loop;\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/isa/if_edreg.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"ed.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void edreset",
            "void ed_shared_readmem",
            "void edread",
            "static __inline void ed_rint",
            "void ed_pio_readmem",
            "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nvoid edreset;\nvoid ed_shared_readmem;\nvoid edread;\nstatic __inline void ed_rint;\nvoid ed_pio_readmem;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nstatic __inline void\ned_rint(sc)\n\tstruct ed_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint nicbase = sc->nic_base;\n\tu_int8_t boundary, current;\n\tu_int16_t len;\n\tu_int8_t nlen;\n\tu_int8_t next_packet;\t\t/* pointer to next packet */\n\tu_int16_t count;\t\t/* bytes in packet (length + 4) */\n\tu_int8_t packet_hdr[ED_RING_HDRSZ];\n\tint packet_ptr;\n\nloop:\n\t/* Set NIC to page 1 registers to get 'current' pointer. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_1 | ED_CR_STA);\n\n\t/*\n\t * 'sc->next_packet' is the logical beginning of the ring-buffer - i.e.\n\t * it points to where new data has been buffered.  The 'CURR' (current)\n\t * register points to the logical end of the ring-buffer - i.e. it\n\t * points to where additional new data will be added.  We loop here\n\t * until the logical beginning equals the logical end (or in other\n\t * words, until the ring-buffer is empty).\n\t */\n\tcurrent = NIC_GET(iot, ioh, nicbase, ED_P1_CURR);\n\tif (sc->next_packet == current)\n\t\treturn;\n\n\t/* Set NIC to page 0 registers to update boundary register. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P1_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tdo {\n\t\t/* Get pointer to this buffer's header structure. */\n\t\tpacket_ptr = sc->mem_ring +\n\t\t    ((sc->next_packet - sc->rec_page_start) << ED_PAGE_SHIFT);\n\n\t\t/*\n\t\t * The byte count includes a 4 byte header that was added by\n\t\t * the NIC.\n\t\t */\n\t\tif (sc->mem_shared)\n\t\t\ted_shared_readmem(sc, packet_ptr, packet_hdr,\n\t\t\t    sizeof(packet_hdr));\n\t\telse\n\t\t\ted_pio_readmem(sc, (u_int16_t)packet_ptr, packet_hdr,\n\t\t\t    sizeof(packet_hdr));\n\t\tnext_packet = packet_hdr[ED_RING_NEXT_PACKET];\n\t\tlen = count = packet_hdr[ED_RING_COUNT] +\n\t\t    256 * packet_hdr[ED_RING_COUNT + 1];\n\n\t\t/*\n\t\t * Try do deal with old, buggy chips that sometimes duplicate\n\t\t * the low byte of the length into the high byte.  We do this\n\t\t * by simply ignoring the high byte of the length and always\n\t\t * recalculating it.\n\t\t *\n\t\t * NOTE: sc->next_packet is pointing at the current packet.\n\t\t */\n\t\tif (next_packet >= sc->next_packet)\n\t\t\tnlen = (next_packet - sc->next_packet);\n\t\telse\n\t\t\tnlen = ((next_packet - sc->rec_page_start) +\n\t\t\t\t(sc->rec_page_stop - sc->next_packet));\n\t\t--nlen;\n\t\tif ((len & ED_PAGE_MASK) + sizeof(packet_hdr) > ED_PAGE_SIZE)\n\t\t\t--nlen;\n\t\tlen = (len & ED_PAGE_MASK) | (nlen << ED_PAGE_SHIFT);\n#ifdef DIAGNOSTIC\n\t\tif (len != count) {\n\t\t\tprintf(\"%s: length does not match next packet pointer\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tprintf(\"%s: len %04x nlen %04x start %02x first %02x curr %02x next %02x stop %02x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, count, len,\n\t\t\t    sc->rec_page_start, sc->next_packet, current,\n\t\t\t    next_packet, sc->rec_page_stop);\n\t\t}\n#endif\n\n\t\t/*\n\t\t * Be fairly liberal about what we allow as a \"reasonable\"\n\t\t * length so that a [crufty] packet will make it to BPF (and\n\t\t * can thus be analyzed).  Note that all that is really\n\t\t * important is that we have a length that will fit into one\n\t\t * mbuf cluster or less; the upper layer protocols can then\n\t\t * figure out the length from their own length field(s).\n\t\t */\n\t\tif (len <= MCLBYTES &&\n\t\t    next_packet >= sc->rec_page_start &&\n\t\t    next_packet < sc->rec_page_stop) {\n\t\t\t/* Go get packet. */\n\t\t\tedread(sc, packet_ptr + ED_RING_HDRSZ,\n\t\t\t    len - ED_RING_HDRSZ);\n\t\t} else {\n\t\t\t/* Really BAD.  The ring pointers are corrupted. */\n\t\t\tlog(LOG_ERR,\n\t\t\t    \"%s: NIC memory corrupt - invalid packet length %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, len);\n\t\t\t++sc->sc_arpcom.ac_if.if_ierrors;\n\t\t\tedreset(sc);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Update next packet pointer. */\n\t\tsc->next_packet = next_packet;\n\n\t\t/*\n\t\t * Update NIC boundary pointer - being careful to keep it one\n\t\t * buffer behind (as recommended by NS databook).\n\t\t */\n\t\tboundary = sc->next_packet - 1;\n\t\tif (boundary < sc->rec_page_start)\n\t\t\tboundary = sc->rec_page_stop - 1;\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_BNRY, boundary);\n\t} while (sc->next_packet != current);\n\n\tgoto loop;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "sc->sc_delaybah",
            "0"
          ],
          "line": 2381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "sc->sc_delaybah",
            "0"
          ],
          "line": 2379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_WD_MSR",
            "sc->wd_msr_proto | ED_WD_MSR_MENB"
          ],
          "line": 2376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_WD_LAAR",
            "sc->wd_laar_proto |\n\t\t\t\t\t\t    ED_WD_LAAR_M16EN"
          ],
          "line": 2372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: receive error %x\\n\"",
            "sc->sc_dev.dv_xname",
            "NIC_GET(iot,ioh,nicbase,ED_P0_RSR)"
          ],
          "line": 2352
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NIC_GET",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_RSR"
          ],
          "line": 2354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "edreset",
          "args": [
            "sc"
          ],
          "line": 2342
        },
        "resolved": true,
        "details": {
          "function_name": "edreset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
          "lines": "1732-1742",
          "snippet": "void\nedreset(sc)\n\tstruct ed_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tedstop(sc);\n\tedinit(sc);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/isa/if_edreg.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"ed.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void edreset",
            "void edinit",
            "void edstop",
            "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nvoid edreset;\nvoid edinit;\nvoid edstop;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nvoid\nedreset(sc)\n\tstruct ed_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tedstop(sc);\n\tedinit(sc);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_WARNING",
            "\"%s: warning - receiver ring buffer overrun\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 2337
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_log_hard_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5909-5956",
          "snippet": "static void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "int\ti;",
            "ncb_p np = (struct ncb*) 0;",
            "int\ti;",
            "u_int8_t\tistat, dstat;",
            "u_int16_t\tsist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nint\ti;\nncb_p np = (struct ncb*) 0;\nint\ti;\nu_int8_t\tistat, dstat;\nu_int16_t\tsist;\n\nstatic void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ed_xmit",
          "args": [
            "sc"
          ],
          "line": 2320
        },
        "resolved": true,
        "details": {
          "function_name": "ed_xmit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
          "lines": "1942-1977",
          "snippet": "static __inline void\ned_xmit(sc)\n\tstruct ed_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint nicbase = sc->nic_base;\n\tu_int16_t len;\n\n\tlen = sc->txb_len[sc->txb_next_tx];\n\n\t/* Set NIC for page 0 register access. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Set TX buffer start page. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_TPSR, sc->tx_page_start +\n\t    sc->txb_next_tx * ED_TXBUF_SIZE);\n\n\t/* Set TX length. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_TBCR0, len);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_TBCR1, len >> 8);\n\n\t/* Set page 0, remote DMA complete, transmit packet, and *start*. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_TXP | ED_CR_STA);\n\n\t/* Point to next transmit buffer slot and wrap if necessary. */\n\tsc->txb_next_tx++;\n\tif (sc->txb_next_tx == sc->txb_cnt)\n\t\tsc->txb_next_tx = 0;\n\n\t/* Set a timer just in case we never hear from the board again. */\n\tifp->if_timer = 2;\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/isa/if_edreg.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"ed.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline void ed_xmit",
            "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nstatic __inline void ed_xmit;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nstatic __inline void\ned_xmit(sc)\n\tstruct ed_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint nicbase = sc->nic_base;\n\tu_int16_t len;\n\n\tlen = sc->txb_len[sc->txb_next_tx];\n\n\t/* Set NIC for page 0 register access. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Set TX buffer start page. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_TPSR, sc->tx_page_start +\n\t    sc->txb_next_tx * ED_TXBUF_SIZE);\n\n\t/* Set TX length. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_TBCR0, len);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_TBCR1, len >> 8);\n\n\t/* Set page 0, remote DMA complete, transmit packet, and *start*. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_TXP | ED_CR_STA);\n\n\t/* Point to next transmit buffer slot and wrap if necessary. */\n\tsc->txb_next_tx++;\n\tif (sc->txb_next_tx == sc->txb_cnt)\n\t\tsc->txb_next_tx = 0;\n\n\t/* Set a timer just in case we never hear from the board again. */\n\tifp->if_timer = 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NIC_GET",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_TSR"
          ],
          "line": 2279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_GET",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_TSR"
          ],
          "line": 2274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_GET",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_NCR"
          ],
          "line": 2262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_ISR",
            "isr"
          ],
          "line": 2255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_GET",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_ISR"
          ],
          "line": 2244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_CR",
            "sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA"
          ],
          "line": 2241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nint edintr;\nvoid edstart;\nvoid edreset;\nstatic __inline void ed_rint;\nstatic __inline void ed_xmit;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nint\nedintr(arg)\n\tvoid *arg;\n{\n\tstruct ed_softc *sc = arg;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint nicbase = sc->nic_base, asicbase = sc->asic_base;\n\tu_char isr;\n\n\t/* Set NIC to page 0 registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tisr = NIC_GET(iot, ioh, nicbase, ED_P0_ISR);\n\tif (!isr)\n\t\treturn (0);\n\n\t/* Loop until there are no more new interrupts. */\n\tfor (;;) {\n\t\t/*\n\t\t * Reset all the bits that we are 'acknowledging' by writing a\n\t\t * '1' to each bit position that was set.\n\t\t * (Writing a '1' *clears* the bit.)\n\t\t */\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_ISR, isr);\n\n\t\t/*\n\t\t * Handle transmitter interrupts.  Handle these first because\n\t\t * the receiver will reset the board under some conditions.\n\t\t */\n\t\tif (isr & (ED_ISR_PTX | ED_ISR_TXE)) {\n\t\t\tu_char collisions = NIC_GET(iot, ioh, nicbase,\n\t\t\t    ED_P0_NCR) & 0x0f;\n\n\t\t\t/*\n\t\t\t * Check for transmit error.  If a TX completed with an\n\t\t\t * error, we end up throwing the packet away.  Really\n\t\t\t * the only error that is possible is excessive\n\t\t\t * collisions, and in this case it is best to allow the\n\t\t\t * automatic mechanisms of TCP to backoff the flow.  Of\n\t\t\t * course, with UDP we're screwed, but this is expected\n\t\t\t * when a network is heavily loaded.\n\t\t\t */\n\t\t\t(void) NIC_GET(iot, ioh, nicbase, ED_P0_TSR);\n\t\t\tif (isr & ED_ISR_TXE) {\n\t\t\t\t/*\n\t\t\t\t * Excessive collisions (16).\n\t\t\t\t */\n\t\t\t\tif ((NIC_GET(iot, ioh, nicbase, ED_P0_TSR) &\n\t\t\t\t    ED_TSR_ABT) && (collisions == 0)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * When collisions total 16, the P0_NCR\n\t\t\t\t\t * will indicate 0, and the TSR_ABT is\n\t\t\t\t\t * set.\n\t\t\t\t\t */\n\t\t\t\t\tcollisions = 16;\n\t\t\t\t}\n\n\t\t\t\t/* Update output errors counter. */\n\t\t\t\t++ifp->if_oerrors;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Update total number of successfully\n\t\t\t\t * transmitted packets.\n\t\t\t\t */\n\t\t\t\t++ifp->if_opackets;\n\t\t\t}\n\n\t\t\t/* Done with the buffer. */\n\t\t\tsc->txb_inuse--;\n\n\t\t\t/* Clear watchdog timer. */\n\t\t\tifp->if_timer = 0;\n\t\t\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t\t\t/*\n\t\t\t * Add in total number of collisions on last\n\t\t\t * transmission.\n\t\t\t */\n\t\t\tifp->if_collisions += collisions;\n\n\t\t\t/*\n\t\t\t * Decrement buffer in-use count if not zero (can only\n\t\t\t * be zero if a transmitter interrupt occured while not\n\t\t\t * actually transmitting).\n\t\t\t * If data is ready to transmit, start it transmitting,\n\t\t\t * otherwise defer until after handling receiver.\n\t\t\t */\n\t\t\tif (sc->txb_inuse > 0)\n\t\t\t\ted_xmit(sc);\n\t\t}\n\n\t\t/* Handle receiver interrupts. */\n\t\tif (isr & (ED_ISR_PRX | ED_ISR_RXE | ED_ISR_OVW)) {\n\t\t\t/*\n\t\t\t * Overwrite warning.  In order to make sure that a\n\t\t\t * lockup of the local DMA hasn't occurred, we reset\n\t\t\t * and re-init the NIC.  The NSC manual suggests only a\n\t\t\t * partial reset/re-init is necessary - but some chips\n\t\t\t * seem to want more.  The DMA lockup has been seen\n\t\t\t * only with early rev chips - Methinks this bug was\n\t\t\t * fixed in later revs.  -DG\n\t\t\t */\n\t\t\tif (isr & ED_ISR_OVW) {\n\t\t\t\t++ifp->if_ierrors;\n#ifdef DIAGNOSTIC\n\t\t\t\tlog(LOG_WARNING,\n\t\t\t\t    \"%s: warning - receiver ring buffer overrun\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n#endif\n\t\t\t\t/* Stop/reset/re-init NIC. */\n\t\t\t\tedreset(sc);\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Receiver Error.  One or more of: CRC error,\n\t\t\t\t * frame alignment error FIFO overrun, or\n\t\t\t\t * missed packet.\n\t\t\t\t */\n\t\t\t\tif (isr & ED_ISR_RXE) {\n\t\t\t\t\t++ifp->if_ierrors;\n#ifdef ED_DEBUG\n\t\t\t\t\tprintf(\"%s: receive error %x\\n\",\n\t\t\t\t\t    sc->sc_dev.dv_xname,\n\t\t\t\t\t    NIC_GET(iot,ioh,nicbase,ED_P0_RSR));\n#endif\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Go get the packet(s).\n\t\t\t\t * XXX - Doing this on an error is dubious\n\t\t\t\t * because there shouldn't be any data to get\n\t\t\t\t * (we've configured the interface to not\n\t\t\t\t * accept packets with errors).\n\t\t\t\t */\n\n\t\t\t\t/*\n\t\t\t\t * Enable 16bit access to shared memory first\n\t\t\t\t * on WD/SMC boards.\n\t\t\t\t */\n\t\t\t\tif (sc->vendor == ED_VENDOR_WD_SMC) {\n\t\t\t\t\tif (sc->isa16bit)\n\t\t\t\t\t\tbus_space_write_1(iot, ioh,\n\t\t\t\t\t\t    asicbase + ED_WD_LAAR,\n\t\t\t\t\t\t    sc->wd_laar_proto |\n\t\t\t\t\t\t    ED_WD_LAAR_M16EN);\n\t\t\t\t\tbus_space_write_1(iot, ioh,\n\t\t\t\t\t    asicbase + ED_WD_MSR,\n\t\t\t\t\t    sc->wd_msr_proto | ED_WD_MSR_MENB);\n\t\t\t\t\t(void) bus_space_read_1(iot,\n\t\t\t\t\t    sc->sc_delaybah, 0);\n\t\t\t\t\t(void) bus_space_read_1(iot,\n\t\t\t\t\t    sc->sc_delaybah, 0);\n\t\t\t\t}\n\n\t\t\t\ted_rint(sc);\n\n\t\t\t\t/* Disable 16-bit access. */\n\t\t\t\tif (sc->vendor == ED_VENDOR_WD_SMC) {\n\t\t\t\t\tbus_space_write_1(iot, ioh,\n\t\t\t\t\t    asicbase + ED_WD_MSR,\n\t\t\t\t\t    sc->wd_msr_proto);\n\t\t\t\t\tif (sc->isa16bit)\n\t\t\t\t\t\tbus_space_write_1(iot, ioh,\n\t\t\t\t\t\t    asicbase + ED_WD_LAAR,\n\t\t\t\t\t\t    sc->wd_laar_proto);\n\t\t\t\t\t(void) bus_space_read_1(iot,\n\t\t\t\t\t    sc->sc_delaybah, 0);\n\t\t\t\t\t(void) bus_space_read_1(iot,\n\t\t\t\t\t    sc->sc_delaybah, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If it looks like the transmitter can take more data,\tattempt\n\t\t * to start output on the interface.  This is done after\n\t\t * handling the receiver to give the receiver priority.\n\t\t */\n\t\tedstart(ifp);\n\n\t\t/*\n\t\t * Return NIC CR to standard state: page 0, remote DMA\n\t\t * complete, start (toggling the TXP bit off, even if was just\n\t\t * set in the transmit routine, is *okay* - it is 'edge'\n\t\t * triggered from low to high).\n\t\t */\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t\t/*\n\t\t * If the Network Talley Counters overflow, read them to reset\n\t\t * them.  It appears that old 8390's won't clear the ISR flag\n\t\t * otherwise - resulting in an infinite loop.\n\t\t */\n\t\tif (isr & ED_ISR_CNT) {\n\t\t\t(void) NIC_GET(iot, ioh, nicbase, ED_P0_CNTR0);\n\t\t\t(void) NIC_GET(iot, ioh, nicbase, ED_P0_CNTR1);\n\t\t\t(void) NIC_GET(iot, ioh, nicbase, ED_P0_CNTR2);\n\t\t}\n\n\t\tisr = NIC_GET(iot, ioh, nicbase, ED_P0_ISR);\n\t\tif (!isr)\n\t\t\treturn (1);\n\t}\n}"
  },
  {
    "function_name": "ed_rint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
    "lines": "2105-2226",
    "snippet": "static __inline void\ned_rint(sc)\n\tstruct ed_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint nicbase = sc->nic_base;\n\tu_int8_t boundary, current;\n\tu_int16_t len;\n\tu_int8_t nlen;\n\tu_int8_t next_packet;\t\t/* pointer to next packet */\n\tu_int16_t count;\t\t/* bytes in packet (length + 4) */\n\tu_int8_t packet_hdr[ED_RING_HDRSZ];\n\tint packet_ptr;\n\nloop:\n\t/* Set NIC to page 1 registers to get 'current' pointer. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_1 | ED_CR_STA);\n\n\t/*\n\t * 'sc->next_packet' is the logical beginning of the ring-buffer - i.e.\n\t * it points to where new data has been buffered.  The 'CURR' (current)\n\t * register points to the logical end of the ring-buffer - i.e. it\n\t * points to where additional new data will be added.  We loop here\n\t * until the logical beginning equals the logical end (or in other\n\t * words, until the ring-buffer is empty).\n\t */\n\tcurrent = NIC_GET(iot, ioh, nicbase, ED_P1_CURR);\n\tif (sc->next_packet == current)\n\t\treturn;\n\n\t/* Set NIC to page 0 registers to update boundary register. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P1_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tdo {\n\t\t/* Get pointer to this buffer's header structure. */\n\t\tpacket_ptr = sc->mem_ring +\n\t\t    ((sc->next_packet - sc->rec_page_start) << ED_PAGE_SHIFT);\n\n\t\t/*\n\t\t * The byte count includes a 4 byte header that was added by\n\t\t * the NIC.\n\t\t */\n\t\tif (sc->mem_shared)\n\t\t\ted_shared_readmem(sc, packet_ptr, packet_hdr,\n\t\t\t    sizeof(packet_hdr));\n\t\telse\n\t\t\ted_pio_readmem(sc, (u_int16_t)packet_ptr, packet_hdr,\n\t\t\t    sizeof(packet_hdr));\n\t\tnext_packet = packet_hdr[ED_RING_NEXT_PACKET];\n\t\tlen = count = packet_hdr[ED_RING_COUNT] +\n\t\t    256 * packet_hdr[ED_RING_COUNT + 1];\n\n\t\t/*\n\t\t * Try do deal with old, buggy chips that sometimes duplicate\n\t\t * the low byte of the length into the high byte.  We do this\n\t\t * by simply ignoring the high byte of the length and always\n\t\t * recalculating it.\n\t\t *\n\t\t * NOTE: sc->next_packet is pointing at the current packet.\n\t\t */\n\t\tif (next_packet >= sc->next_packet)\n\t\t\tnlen = (next_packet - sc->next_packet);\n\t\telse\n\t\t\tnlen = ((next_packet - sc->rec_page_start) +\n\t\t\t\t(sc->rec_page_stop - sc->next_packet));\n\t\t--nlen;\n\t\tif ((len & ED_PAGE_MASK) + sizeof(packet_hdr) > ED_PAGE_SIZE)\n\t\t\t--nlen;\n\t\tlen = (len & ED_PAGE_MASK) | (nlen << ED_PAGE_SHIFT);\n#ifdef DIAGNOSTIC\n\t\tif (len != count) {\n\t\t\tprintf(\"%s: length does not match next packet pointer\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tprintf(\"%s: len %04x nlen %04x start %02x first %02x curr %02x next %02x stop %02x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, count, len,\n\t\t\t    sc->rec_page_start, sc->next_packet, current,\n\t\t\t    next_packet, sc->rec_page_stop);\n\t\t}\n#endif\n\n\t\t/*\n\t\t * Be fairly liberal about what we allow as a \"reasonable\"\n\t\t * length so that a [crufty] packet will make it to BPF (and\n\t\t * can thus be analyzed).  Note that all that is really\n\t\t * important is that we have a length that will fit into one\n\t\t * mbuf cluster or less; the upper layer protocols can then\n\t\t * figure out the length from their own length field(s).\n\t\t */\n\t\tif (len <= MCLBYTES &&\n\t\t    next_packet >= sc->rec_page_start &&\n\t\t    next_packet < sc->rec_page_stop) {\n\t\t\t/* Go get packet. */\n\t\t\tedread(sc, packet_ptr + ED_RING_HDRSZ,\n\t\t\t    len - ED_RING_HDRSZ);\n\t\t} else {\n\t\t\t/* Really BAD.  The ring pointers are corrupted. */\n\t\t\tlog(LOG_ERR,\n\t\t\t    \"%s: NIC memory corrupt - invalid packet length %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, len);\n\t\t\t++sc->sc_arpcom.ac_if.if_ierrors;\n\t\t\tedreset(sc);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Update next packet pointer. */\n\t\tsc->next_packet = next_packet;\n\n\t\t/*\n\t\t * Update NIC boundary pointer - being careful to keep it one\n\t\t * buffer behind (as recommended by NS databook).\n\t\t */\n\t\tboundary = sc->next_packet - 1;\n\t\tif (boundary < sc->rec_page_start)\n\t\t\tboundary = sc->rec_page_stop - 1;\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_BNRY, boundary);\n\t} while (sc->next_packet != current);\n\n\tgoto loop;\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/isa/if_edreg.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"ed.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void edreset",
      "void ed_shared_readmem",
      "void edread",
      "static __inline void ed_rint",
      "void ed_pio_readmem",
      "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_BNRY",
            "boundary"
          ],
          "line": 2222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "edreset",
          "args": [
            "sc"
          ],
          "line": 2208
        },
        "resolved": true,
        "details": {
          "function_name": "edreset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
          "lines": "1732-1742",
          "snippet": "void\nedreset(sc)\n\tstruct ed_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tedstop(sc);\n\tedinit(sc);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/isa/if_edreg.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"ed.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void edreset",
            "void edinit",
            "void edstop",
            "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nvoid edreset;\nvoid edinit;\nvoid edstop;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nvoid\nedreset(sc)\n\tstruct ed_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tedstop(sc);\n\tedinit(sc);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_ERR",
            "\"%s: NIC memory corrupt - invalid packet length %d\\n\"",
            "sc->sc_dev.dv_xname",
            "len"
          ],
          "line": 2204
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1387-1401",
          "snippet": "int\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "edread",
          "args": [
            "sc",
            "packet_ptr + ED_RING_HDRSZ",
            "len - ED_RING_HDRSZ"
          ],
          "line": 2200
        },
        "resolved": true,
        "details": {
          "function_name": "edread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
          "lines": "2539-2572",
          "snippet": "void\nedread(sc, buf, len)\n\tstruct ed_softc *sc;\n\tint buf, len;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tstruct mbuf *m;\n\tstruct ether_header *eh;\n\n\t/* Pull packet off interface. */\n\tm = edget(sc, buf, len);\n\tif (m == 0) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\tifp->if_ipackets++;\n\n\t/* We assume that the header fit entirely in one mbuf. */\n\teh = mtod(m, struct ether_header *);\n\n#if NBPFILTER > 0\n\t/*\n\t * Check if there's a BPF listener on this interface.\n\t * If so, hand off the raw packet to BPF.\n\t */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t/* We assume that the header fit entirely in one mbuf. */\n\tm_adj(m, sizeof(struct ether_header));\n\tether_input(ifp, eh, m);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/isa/if_edreg.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"ed.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void edread",
            "struct mbuf *edget",
            "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nvoid edread;\nstruct mbuf *edget;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nvoid\nedread(sc, buf, len)\n\tstruct ed_softc *sc;\n\tint buf, len;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tstruct mbuf *m;\n\tstruct ether_header *eh;\n\n\t/* Pull packet off interface. */\n\tm = edget(sc, buf, len);\n\tif (m == 0) {\n\t\tifp->if_ierrors++;\n\t\treturn;\n\t}\n\n\tifp->if_ipackets++;\n\n\t/* We assume that the header fit entirely in one mbuf. */\n\teh = mtod(m, struct ether_header *);\n\n#if NBPFILTER > 0\n\t/*\n\t * Check if there's a BPF listener on this interface.\n\t * If so, hand off the raw packet to BPF.\n\t */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\n\t/* We assume that the header fit entirely in one mbuf. */\n\tm_adj(m, sizeof(struct ether_header));\n\tether_input(ifp, eh, m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: len %04x nlen %04x start %02x first %02x curr %02x next %02x stop %02x\\n\"",
            "sc->sc_dev.dv_xname",
            "count",
            "len",
            "sc->rec_page_start",
            "sc->next_packet",
            "current",
            "next_packet",
            "sc->rec_page_stop"
          ],
          "line": 2181
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ed_pio_readmem",
          "args": [
            "sc",
            "(u_int16_t)packet_ptr",
            "packet_hdr",
            "sizeof(packet_hdr)"
          ],
          "line": 2154
        },
        "resolved": true,
        "details": {
          "function_name": "ed_pio_readmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
          "lines": "2584-2620",
          "snippet": "void\ned_pio_readmem(sc, src, dst, amount)\n\tstruct ed_softc *sc;\n\tu_int16_t src;\n\tcaddr_t dst;\n\tu_int16_t amount;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint nicbase = sc->nic_base;\n\n\t/* Select page 0 registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Round up to a word. */\n\tif (amount & 1)\n\t\t++amount;\n\n\t/* Set up DMA byte count. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR0, amount);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR1, amount >> 8);\n\n\t/* Set up source address in NIC mem. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RSAR0, src);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RSAR1, src >> 8);\n\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD0 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tif (sc->isa16bit)\n\t\tbus_space_read_raw_multi_2(iot, ioh,\n\t\t    sc->asic_base + ED_NOVELL_DATA, dst, amount);\n\telse\n\t\tbus_space_read_multi_1(iot, ioh,\n\t\t    sc->asic_base + ED_NOVELL_DATA, dst, amount);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/isa/if_edreg.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"ed.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ed_pio_readmem",
            "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;",
            "int src;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nvoid ed_pio_readmem;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\nint src;\n\nvoid\ned_pio_readmem(sc, src, dst, amount)\n\tstruct ed_softc *sc;\n\tu_int16_t src;\n\tcaddr_t dst;\n\tu_int16_t amount;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint nicbase = sc->nic_base;\n\n\t/* Select page 0 registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Round up to a word. */\n\tif (amount & 1)\n\t\t++amount;\n\n\t/* Set up DMA byte count. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR0, amount);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR1, amount >> 8);\n\n\t/* Set up source address in NIC mem. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RSAR0, src);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RSAR1, src >> 8);\n\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD0 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tif (sc->isa16bit)\n\t\tbus_space_read_raw_multi_2(iot, ioh,\n\t\t    sc->asic_base + ED_NOVELL_DATA, dst, amount);\n\telse\n\t\tbus_space_read_multi_1(iot, ioh,\n\t\t    sc->asic_base + ED_NOVELL_DATA, dst, amount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ed_shared_readmem",
          "args": [
            "sc",
            "packet_ptr",
            "packet_hdr",
            "sizeof(packet_hdr)"
          ],
          "line": 2151
        },
        "resolved": true,
        "details": {
          "function_name": "ed_shared_readmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
          "lines": "2997-3025",
          "snippet": "void\ned_shared_readmem(sc, card, to, len)\n\tstruct ed_softc *sc;\n\tcaddr_t to;\n\tint card, len;\n{\n\tbus_space_tag_t memt = sc->sc_memt;\n\tbus_space_handle_t memh = sc->sc_memh;\n\tu_int16_t word;\n\n\t/*\n\t * See comment above re. 16-bit cards.\n\t */\n\tif (sc->isa16bit) {\n\t\t/* XXX I think maybe a bus_space_read_raw_region is needed.  */\n\t\twhile (len > 1) {\n\t\t\tword = bus_space_read_2(memt, memh, card);\n\t\t\t*to++ = word & 0xff;\n\t\t\t*to++ = word >> 8 & 0xff;\n\t\t\tcard += 2;\n\t\t\tlen -= 2;\n\t\t}\n\t\tif (len == 1)\n\t\t\t*to = bus_space_read_2(memt, memh, card) & 0xff;\n\t} else {\n\t\twhile (len--)\n\t\t\t*to++ = bus_space_read_1(memt, memh, card++);\n\t}\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/isa/if_edreg.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"ed.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ed_shared_readmem",
            "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nvoid ed_shared_readmem;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nvoid\ned_shared_readmem(sc, card, to, len)\n\tstruct ed_softc *sc;\n\tcaddr_t to;\n\tint card, len;\n{\n\tbus_space_tag_t memt = sc->sc_memt;\n\tbus_space_handle_t memh = sc->sc_memh;\n\tu_int16_t word;\n\n\t/*\n\t * See comment above re. 16-bit cards.\n\t */\n\tif (sc->isa16bit) {\n\t\t/* XXX I think maybe a bus_space_read_raw_region is needed.  */\n\t\twhile (len > 1) {\n\t\t\tword = bus_space_read_2(memt, memh, card);\n\t\t\t*to++ = word & 0xff;\n\t\t\t*to++ = word >> 8 & 0xff;\n\t\t\tcard += 2;\n\t\t\tlen -= 2;\n\t\t}\n\t\tif (len == 1)\n\t\t\t*to = bus_space_read_2(memt, memh, card) & 0xff;\n\t} else {\n\t\twhile (len--)\n\t\t\t*to++ = bus_space_read_1(memt, memh, card++);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P1_CR",
            "sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA"
          ],
          "line": 2138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_GET",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P1_CURR"
          ],
          "line": 2133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_CR",
            "sc->cr_proto | ED_CR_PAGE_1 | ED_CR_STA"
          ],
          "line": 2122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nvoid edreset;\nvoid ed_shared_readmem;\nvoid edread;\nstatic __inline void ed_rint;\nvoid ed_pio_readmem;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nstatic __inline void\ned_rint(sc)\n\tstruct ed_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint nicbase = sc->nic_base;\n\tu_int8_t boundary, current;\n\tu_int16_t len;\n\tu_int8_t nlen;\n\tu_int8_t next_packet;\t\t/* pointer to next packet */\n\tu_int16_t count;\t\t/* bytes in packet (length + 4) */\n\tu_int8_t packet_hdr[ED_RING_HDRSZ];\n\tint packet_ptr;\n\nloop:\n\t/* Set NIC to page 1 registers to get 'current' pointer. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_1 | ED_CR_STA);\n\n\t/*\n\t * 'sc->next_packet' is the logical beginning of the ring-buffer - i.e.\n\t * it points to where new data has been buffered.  The 'CURR' (current)\n\t * register points to the logical end of the ring-buffer - i.e. it\n\t * points to where additional new data will be added.  We loop here\n\t * until the logical beginning equals the logical end (or in other\n\t * words, until the ring-buffer is empty).\n\t */\n\tcurrent = NIC_GET(iot, ioh, nicbase, ED_P1_CURR);\n\tif (sc->next_packet == current)\n\t\treturn;\n\n\t/* Set NIC to page 0 registers to update boundary register. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P1_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tdo {\n\t\t/* Get pointer to this buffer's header structure. */\n\t\tpacket_ptr = sc->mem_ring +\n\t\t    ((sc->next_packet - sc->rec_page_start) << ED_PAGE_SHIFT);\n\n\t\t/*\n\t\t * The byte count includes a 4 byte header that was added by\n\t\t * the NIC.\n\t\t */\n\t\tif (sc->mem_shared)\n\t\t\ted_shared_readmem(sc, packet_ptr, packet_hdr,\n\t\t\t    sizeof(packet_hdr));\n\t\telse\n\t\t\ted_pio_readmem(sc, (u_int16_t)packet_ptr, packet_hdr,\n\t\t\t    sizeof(packet_hdr));\n\t\tnext_packet = packet_hdr[ED_RING_NEXT_PACKET];\n\t\tlen = count = packet_hdr[ED_RING_COUNT] +\n\t\t    256 * packet_hdr[ED_RING_COUNT + 1];\n\n\t\t/*\n\t\t * Try do deal with old, buggy chips that sometimes duplicate\n\t\t * the low byte of the length into the high byte.  We do this\n\t\t * by simply ignoring the high byte of the length and always\n\t\t * recalculating it.\n\t\t *\n\t\t * NOTE: sc->next_packet is pointing at the current packet.\n\t\t */\n\t\tif (next_packet >= sc->next_packet)\n\t\t\tnlen = (next_packet - sc->next_packet);\n\t\telse\n\t\t\tnlen = ((next_packet - sc->rec_page_start) +\n\t\t\t\t(sc->rec_page_stop - sc->next_packet));\n\t\t--nlen;\n\t\tif ((len & ED_PAGE_MASK) + sizeof(packet_hdr) > ED_PAGE_SIZE)\n\t\t\t--nlen;\n\t\tlen = (len & ED_PAGE_MASK) | (nlen << ED_PAGE_SHIFT);\n#ifdef DIAGNOSTIC\n\t\tif (len != count) {\n\t\t\tprintf(\"%s: length does not match next packet pointer\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tprintf(\"%s: len %04x nlen %04x start %02x first %02x curr %02x next %02x stop %02x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, count, len,\n\t\t\t    sc->rec_page_start, sc->next_packet, current,\n\t\t\t    next_packet, sc->rec_page_stop);\n\t\t}\n#endif\n\n\t\t/*\n\t\t * Be fairly liberal about what we allow as a \"reasonable\"\n\t\t * length so that a [crufty] packet will make it to BPF (and\n\t\t * can thus be analyzed).  Note that all that is really\n\t\t * important is that we have a length that will fit into one\n\t\t * mbuf cluster or less; the upper layer protocols can then\n\t\t * figure out the length from their own length field(s).\n\t\t */\n\t\tif (len <= MCLBYTES &&\n\t\t    next_packet >= sc->rec_page_start &&\n\t\t    next_packet < sc->rec_page_stop) {\n\t\t\t/* Go get packet. */\n\t\t\tedread(sc, packet_ptr + ED_RING_HDRSZ,\n\t\t\t    len - ED_RING_HDRSZ);\n\t\t} else {\n\t\t\t/* Really BAD.  The ring pointers are corrupted. */\n\t\t\tlog(LOG_ERR,\n\t\t\t    \"%s: NIC memory corrupt - invalid packet length %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, len);\n\t\t\t++sc->sc_arpcom.ac_if.if_ierrors;\n\t\t\tedreset(sc);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Update next packet pointer. */\n\t\tsc->next_packet = next_packet;\n\n\t\t/*\n\t\t * Update NIC boundary pointer - being careful to keep it one\n\t\t * buffer behind (as recommended by NS databook).\n\t\t */\n\t\tboundary = sc->next_packet - 1;\n\t\tif (boundary < sc->rec_page_start)\n\t\t\tboundary = sc->rec_page_stop - 1;\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_BNRY, boundary);\n\t} while (sc->next_packet != current);\n\n\tgoto loop;\n}"
  },
  {
    "function_name": "edstart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
    "lines": "1988-2100",
    "snippet": "void\nedstart(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct ed_softc *sc = ifp->if_softc;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct mbuf *m0, *m;\n\tint buffer;\n\tint asicbase = sc->asic_base;\n\tint len;\n\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\noutloop:\n\t/* See if there is room to put another packet in the buffer. */\n\tif (sc->txb_inuse == sc->txb_cnt) {\n\t\t/* No room.  Indicate this to the outside world and exit. */\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\tif (m0 == 0)\n\t\treturn;\n\n\t/* We need to use m->m_pkthdr.len, so require the header */\n\tif ((m0->m_flags & M_PKTHDR) == 0)\n\t\tpanic(\"edstart: no header mbuf\");\n\n#if NBPFILTER > 0\n\t/* Tap off here if there is a BPF listener. */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n\t/* txb_new points to next open buffer slot. */\n\tbuffer = sc->mem_start +\n\t    ((sc->txb_new * ED_TXBUF_SIZE) << ED_PAGE_SHIFT);\n\n\tif (sc->mem_shared) {\n\t\t/* Special case setup for 16 bit boards... */\n\t\tswitch (sc->vendor) {\n\t\t/*\n\t\t * For 16bit 3Com boards (which have 16k of memory), we\n\t\t * have the xmit buffers in a different page of memory\n\t\t * ('page 0') - so change pages.\n\t\t */\n\t\tcase ED_VENDOR_3COM:\n\t\t\tif (sc->isa16bit)\n\t\t\t\tbus_space_write_1(iot, ioh,\n\t\t\t\t    asicbase + ED_3COM_GACFR,\n\t\t\t\t    ED_3COM_GACFR_RSEL);\n\t\t\tbreak;\n\t\t/*\n\t\t * Enable 16bit access to shared memory on WD/SMC\n\t\t * boards.\n\t\t */\n\t\tcase ED_VENDOR_WD_SMC:\n\t\t\tif (sc->isa16bit)\n\t\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_LAAR,\n\t\t\t\t    sc->wd_laar_proto | ED_WD_LAAR_M16EN);\n\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR,\n\t\t\t    sc->wd_msr_proto | ED_WD_MSR_MENB);\n\t\t\t(void) bus_space_read_1(iot, sc->sc_delaybah, 0);\n\t\t\t(void) bus_space_read_1(iot, sc->sc_delaybah, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (m = m0; m != 0; m = m->m_next) {\n\t\t\ted_shared_writemem(sc, mtod(m, caddr_t), buffer,\n\t\t\t    m->m_len);\n\t\t\tbuffer += m->m_len;\n\t\t}\n\t\tlen = m0->m_pkthdr.len;\n\n\t\t/* Restore previous shared memory access. */\n\t\tswitch (sc->vendor) {\n\t\tcase ED_VENDOR_3COM:\n\t\t\tif (sc->isa16bit)\n\t\t\t\tbus_space_write_1(iot, ioh,\n\t\t\t\t    asicbase + ED_3COM_GACFR,\n\t\t\t\t    ED_3COM_GACFR_RSEL | ED_3COM_GACFR_MBS0);\n\t\t\tbreak;\n\t\tcase ED_VENDOR_WD_SMC:\n\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR,\n\t\t\t    sc->wd_msr_proto);\n\t\t\tif (sc->isa16bit)\n\t\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_LAAR,\n\t\t\t\t    sc->wd_laar_proto);\n\t\t\t(void) bus_space_read_1(iot, sc->sc_delaybah, 0);\n\t\t\t(void) bus_space_read_1(iot, sc->sc_delaybah, 0);\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tlen = ed_pio_write_mbufs(sc, m0, (u_int16_t)buffer);\n\n\tm_freem(m0);\n\tsc->txb_len[sc->txb_new] = max(len, ETHER_MIN_LEN);\n\n\t/* Start the first packet transmitting. */\n\tif (sc->txb_inuse == 0)\n\t\ted_xmit(sc);\n\n\t/* Point to next buffer slot and wrap if necessary. */\n\tif (++sc->txb_new == sc->txb_cnt)\n\t\tsc->txb_new = 0;\n\tsc->txb_inuse++;\n\n\t/* Loop back to the top to possibly buffer more packets. */\n\tgoto outloop;\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/isa/if_edreg.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"ed.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define\tETHER_MIN_LEN\t64"
    ],
    "globals_used": [
      "void edstart",
      "void ed_shared_writemem",
      "static __inline void ed_xmit",
      "u_int16_t ed_pio_write_mbufs",
      "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ed_xmit",
          "args": [
            "sc"
          ],
          "line": 2091
        },
        "resolved": true,
        "details": {
          "function_name": "ed_xmit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
          "lines": "1942-1977",
          "snippet": "static __inline void\ned_xmit(sc)\n\tstruct ed_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint nicbase = sc->nic_base;\n\tu_int16_t len;\n\n\tlen = sc->txb_len[sc->txb_next_tx];\n\n\t/* Set NIC for page 0 register access. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Set TX buffer start page. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_TPSR, sc->tx_page_start +\n\t    sc->txb_next_tx * ED_TXBUF_SIZE);\n\n\t/* Set TX length. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_TBCR0, len);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_TBCR1, len >> 8);\n\n\t/* Set page 0, remote DMA complete, transmit packet, and *start*. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_TXP | ED_CR_STA);\n\n\t/* Point to next transmit buffer slot and wrap if necessary. */\n\tsc->txb_next_tx++;\n\tif (sc->txb_next_tx == sc->txb_cnt)\n\t\tsc->txb_next_tx = 0;\n\n\t/* Set a timer just in case we never hear from the board again. */\n\tifp->if_timer = 2;\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/isa/if_edreg.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"ed.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline void ed_xmit",
            "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nstatic __inline void ed_xmit;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nstatic __inline void\ned_xmit(sc)\n\tstruct ed_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint nicbase = sc->nic_base;\n\tu_int16_t len;\n\n\tlen = sc->txb_len[sc->txb_next_tx];\n\n\t/* Set NIC for page 0 register access. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Set TX buffer start page. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_TPSR, sc->tx_page_start +\n\t    sc->txb_next_tx * ED_TXBUF_SIZE);\n\n\t/* Set TX length. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_TBCR0, len);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_TBCR1, len >> 8);\n\n\t/* Set page 0, remote DMA complete, transmit packet, and *start*. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_TXP | ED_CR_STA);\n\n\t/* Point to next transmit buffer slot and wrap if necessary. */\n\tsc->txb_next_tx++;\n\tif (sc->txb_next_tx == sc->txb_cnt)\n\t\tsc->txb_next_tx = 0;\n\n\t/* Set a timer just in case we never hear from the board again. */\n\tifp->if_timer = 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "len",
            "ETHER_MIN_LEN"
          ],
          "line": 2087
        },
        "resolved": true,
        "details": {
          "function_name": "gusmax_mixer_query_devinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "2892-3092",
          "snippet": "int\ngusmax_mixer_query_devinfo(addr, dip)\n\tvoid *addr;\n\tmixer_devinfo_t *dip;\n{\n\tDPRINTF((\"gusmax_query_devinfo: index=%d\\n\", dip->index));\n\n\tswitch(dip->index) {\n#if 0\n    case GUSMAX_MIC_IN_LVL:\t/* Microphone */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_MIC_IN_MUTE;\n\tstrcpy(dip->label.name, AudioNmicrophone);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n#endif\n\n    case GUSMAX_MONO_LVL:\t/* mono/microphone mixer */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_MONO_MUTE;\n\tstrcpy(dip->label.name, AudioNmicrophone);\n\tdip->un.v.num_channels = 1;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_DAC_LVL:\t\t/*  dacout */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_DAC_MUTE;\n\tstrcpy(dip->label.name, AudioNdac);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_LINE_IN_LVL:\t/* line */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_LINE_IN_MUTE;\n\tstrcpy(dip->label.name, AudioNline);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_CD_LVL:\t\t/* cd */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_CD_MUTE;\n\tstrcpy(dip->label.name, AudioNcd);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n\n    case GUSMAX_MONITOR_LVL:\t/* monitor level */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_MONITOR_CLASS;\n\tdip->next = GUSMAX_MONITOR_MUTE;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNmonitor);\n\tdip->un.v.num_channels = 1;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_OUT_LVL:\t\t/* cs4231 output volume: not useful? */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_MONITOR_CLASS;\n\tdip->prev = dip->next = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNoutput);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_SPEAKER_LVL:\t\t/* fake speaker volume */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_MONITOR_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_SPEAKER_MUTE;\n\tstrcpy(dip->label.name, AudioNmaster);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_LINE_IN_MUTE:\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_LINE_IN_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\t\n    case GUSMAX_DAC_MUTE:\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_DAC_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\n    case GUSMAX_CD_MUTE:\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_CD_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\t\n    case GUSMAX_MONO_MUTE:\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_MONO_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\n    case GUSMAX_MONITOR_MUTE:\n\tdip->mixer_class = GUSMAX_OUTPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_MONITOR_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\n    case GUSMAX_SPEAKER_MUTE:\n\tdip->mixer_class = GUSMAX_OUTPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_SPEAKER_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n    mute:\n\tstrcpy(dip->label.name, AudioNmute);\n\tdip->un.e.num_mem = 2;\n\tstrcpy(dip->un.e.member[0].label.name, AudioNoff);\n\tdip->un.e.member[0].ord = 0;\n\tstrcpy(dip->un.e.member[1].label.name, AudioNon);\n\tdip->un.e.member[1].ord = 1;\n\tbreak;\n\t\n    case GUSMAX_REC_LVL:\t/* record level */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_RECORD_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_RECORD_SOURCE;\n\tstrcpy(dip->label.name, AudioNrecord);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_RECORD_SOURCE:\n\tdip->mixer_class = GUSMAX_RECORD_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_REC_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNsource);\n\tdip->un.e.num_mem = 4;\n\tstrcpy(dip->un.e.member[0].label.name, AudioNoutput);\n\tdip->un.e.member[0].ord = DAC_IN_PORT;\n\tstrcpy(dip->un.e.member[1].label.name, AudioNmicrophone);\n\tdip->un.e.member[1].ord = MIC_IN_PORT;\n\tstrcpy(dip->un.e.member[2].label.name, AudioNdac);\n\tdip->un.e.member[2].ord = AUX1_IN_PORT;\n\tstrcpy(dip->un.e.member[3].label.name, AudioNline);\n\tdip->un.e.member[3].ord = LINE_IN_PORT;\n\tbreak;\n\n    case GUSMAX_INPUT_CLASS:\t\t\t/* input class descriptor */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCinputs);\n\tbreak;\n\n    case GUSMAX_OUTPUT_CLASS:\t\t\t/* output class descriptor */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = GUSMAX_OUTPUT_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCoutputs);\n\tbreak;\n\n    case GUSMAX_MONITOR_CLASS:\t\t\t/* monitor class descriptor */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = GUSMAX_MONITOR_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCmonitor);\n\tbreak;\n\t    \n    case GUSMAX_RECORD_CLASS:\t\t\t/* record source class */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = GUSMAX_RECORD_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCrecord);\n\tbreak;\n\n    default:\n\treturn ENXIO;\n\t/*NOTREACHED*/\n    }\n    DPRINTF((\"AUDIO_MIXER_DEVINFO: name=%s\\n\", dip->label.name));\n\treturn 0;\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngusmax_mixer_query_devinfo(addr, dip)\n\tvoid *addr;\n\tmixer_devinfo_t *dip;\n{\n\tDPRINTF((\"gusmax_query_devinfo: index=%d\\n\", dip->index));\n\n\tswitch(dip->index) {\n#if 0\n    case GUSMAX_MIC_IN_LVL:\t/* Microphone */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_MIC_IN_MUTE;\n\tstrcpy(dip->label.name, AudioNmicrophone);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n#endif\n\n    case GUSMAX_MONO_LVL:\t/* mono/microphone mixer */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_MONO_MUTE;\n\tstrcpy(dip->label.name, AudioNmicrophone);\n\tdip->un.v.num_channels = 1;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_DAC_LVL:\t\t/*  dacout */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_DAC_MUTE;\n\tstrcpy(dip->label.name, AudioNdac);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_LINE_IN_LVL:\t/* line */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_LINE_IN_MUTE;\n\tstrcpy(dip->label.name, AudioNline);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_CD_LVL:\t\t/* cd */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_CD_MUTE;\n\tstrcpy(dip->label.name, AudioNcd);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n\n    case GUSMAX_MONITOR_LVL:\t/* monitor level */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_MONITOR_CLASS;\n\tdip->next = GUSMAX_MONITOR_MUTE;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNmonitor);\n\tdip->un.v.num_channels = 1;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_OUT_LVL:\t\t/* cs4231 output volume: not useful? */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_MONITOR_CLASS;\n\tdip->prev = dip->next = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNoutput);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_SPEAKER_LVL:\t\t/* fake speaker volume */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_MONITOR_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_SPEAKER_MUTE;\n\tstrcpy(dip->label.name, AudioNmaster);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_LINE_IN_MUTE:\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_LINE_IN_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\t\n    case GUSMAX_DAC_MUTE:\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_DAC_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\n    case GUSMAX_CD_MUTE:\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_CD_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\t\n    case GUSMAX_MONO_MUTE:\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_MONO_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\n    case GUSMAX_MONITOR_MUTE:\n\tdip->mixer_class = GUSMAX_OUTPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_MONITOR_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\n    case GUSMAX_SPEAKER_MUTE:\n\tdip->mixer_class = GUSMAX_OUTPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_SPEAKER_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n    mute:\n\tstrcpy(dip->label.name, AudioNmute);\n\tdip->un.e.num_mem = 2;\n\tstrcpy(dip->un.e.member[0].label.name, AudioNoff);\n\tdip->un.e.member[0].ord = 0;\n\tstrcpy(dip->un.e.member[1].label.name, AudioNon);\n\tdip->un.e.member[1].ord = 1;\n\tbreak;\n\t\n    case GUSMAX_REC_LVL:\t/* record level */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_RECORD_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_RECORD_SOURCE;\n\tstrcpy(dip->label.name, AudioNrecord);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_RECORD_SOURCE:\n\tdip->mixer_class = GUSMAX_RECORD_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_REC_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNsource);\n\tdip->un.e.num_mem = 4;\n\tstrcpy(dip->un.e.member[0].label.name, AudioNoutput);\n\tdip->un.e.member[0].ord = DAC_IN_PORT;\n\tstrcpy(dip->un.e.member[1].label.name, AudioNmicrophone);\n\tdip->un.e.member[1].ord = MIC_IN_PORT;\n\tstrcpy(dip->un.e.member[2].label.name, AudioNdac);\n\tdip->un.e.member[2].ord = AUX1_IN_PORT;\n\tstrcpy(dip->un.e.member[3].label.name, AudioNline);\n\tdip->un.e.member[3].ord = LINE_IN_PORT;\n\tbreak;\n\n    case GUSMAX_INPUT_CLASS:\t\t\t/* input class descriptor */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCinputs);\n\tbreak;\n\n    case GUSMAX_OUTPUT_CLASS:\t\t\t/* output class descriptor */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = GUSMAX_OUTPUT_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCoutputs);\n\tbreak;\n\n    case GUSMAX_MONITOR_CLASS:\t\t\t/* monitor class descriptor */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = GUSMAX_MONITOR_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCmonitor);\n\tbreak;\n\t    \n    case GUSMAX_RECORD_CLASS:\t\t\t/* record source class */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = GUSMAX_RECORD_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCrecord);\n\tbreak;\n\n    default:\n\treturn ENXIO;\n\t/*NOTREACHED*/\n    }\n    DPRINTF((\"AUDIO_MIXER_DEVINFO: name=%s\\n\", dip->label.name));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m0"
          ],
          "line": 2086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed_pio_write_mbufs",
          "args": [
            "sc",
            "m0",
            "(u_int16_t)buffer"
          ],
          "line": 2084
        },
        "resolved": true,
        "details": {
          "function_name": "ed_pio_write_mbufs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
          "lines": "2679-2785",
          "snippet": "u_int16_t\ned_pio_write_mbufs(sc, m, dst)\n\tstruct ed_softc *sc;\n\tstruct mbuf *m;\n\tu_int16_t dst;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint nicbase = sc->nic_base, asicbase = sc->asic_base;\n\tu_int16_t len;\n\tint maxwait = 100; /* about 120us */\n\n\tlen = m->m_pkthdr.len;\n\n\t/* Select page 0 registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Reset remote DMA complete flag. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_ISR, ED_ISR_RDC);\n\n\t/* Set up DMA byte count. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR0, len);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR1, len >> 8);\n\n\t/* Set up destination address in NIC mem. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RSAR0, dst);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RSAR1, dst >> 8);\n\n\t/* Set remote DMA write. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD1 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/*\n\t * Transfer the mbuf chain to the NIC memory.\n\t * 16-bit cards require that data be transferred as words, and only\n\t * words, so that case requires some extra code to patch over\n\t * odd-length mbufs.\n\t */\n\tif (!sc->isa16bit) {\n\t\t/* NE1000s are easy. */\n\t\tfor (; m != 0; m = m->m_next) {\n\t\t\tif (m->m_len) {\n\t\t\t\tbus_space_write_multi_1(iot, ioh,\n\t\t\t\t    asicbase + ED_NOVELL_DATA,\n\t\t\t\t    mtod(m, u_char *), m->m_len);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* NE2000s are a bit trickier. */\n\t\tu_int8_t *data, savebyte[2];\n\t\tint len, wantbyte;\n\n\t\twantbyte = 0;\n\t\tfor (; m != 0; m = m->m_next) {\n\t\t\tlen = m->m_len;\n\t\t\tif (len == 0)\n\t\t\t\tcontinue;\n\t\t\tdata = mtod(m, u_int8_t *);\n\t\t\t/* Finish the last word. */\n\t\t\tif (wantbyte) {\n\t\t\t\tsavebyte[1] = *data;\n\t\t\t\tbus_space_write_raw_multi_2(iot, ioh,\n\t\t\t\t    asicbase + ED_NOVELL_DATA, savebyte, 2);\n\t\t\t\tdata++;\n\t\t\t\tlen--;\n\t\t\t\twantbyte = 0;\n\t\t\t}\n\t\t\t/* Output contiguous words. */\n\t\t\tif (len > 1) {\n\t\t\t\tbus_space_write_raw_multi_2(iot, ioh,\n\t\t\t\t    asicbase + ED_NOVELL_DATA, data, len & ~1);\n\t\t\t}\n\t\t\t/* Save last byte, if necessary. */\n\t\t\tif (len & 1) {\n\t\t\t\tdata += len & ~1;\n\t\t\t\tsavebyte[0] = *data;\n\t\t\t\twantbyte = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (wantbyte) {\n\t\t\tsavebyte[1] = 0;\n\t\t\tbus_space_write_raw_multi_2(iot, ioh,\n\t\t\t    asicbase + ED_NOVELL_DATA, savebyte, 2);\n\t\t}\n\t}\n\n\t/*\n\t * Wait for remote DMA complete.  This is necessary because on the\n\t * transmit side, data is handled internally by the NIC in bursts and\n\t * we can't start another remote DMA until this one completes. \tNot\n\t * waiting causes really bad things to happen - like the NIC\n\t * irrecoverably jamming the ISA bus.\n\t */\n\twhile (((NIC_GET(iot, ioh, nicbase, ED_P0_ISR) & ED_ISR_RDC) !=\n\t    ED_ISR_RDC) && --maxwait);\n\n\tif (!maxwait) {\n\t\tlog(LOG_WARNING,\n\t\t    \"%s: remote transmit DMA failed to complete\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tedreset(sc);\n\t}\n\n\treturn (len);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/isa/if_edreg.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"ed.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void edreset",
            "u_int16_t ed_pio_write_mbufs",
            "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nvoid edreset;\nu_int16_t ed_pio_write_mbufs;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nu_int16_t\ned_pio_write_mbufs(sc, m, dst)\n\tstruct ed_softc *sc;\n\tstruct mbuf *m;\n\tu_int16_t dst;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint nicbase = sc->nic_base, asicbase = sc->asic_base;\n\tu_int16_t len;\n\tint maxwait = 100; /* about 120us */\n\n\tlen = m->m_pkthdr.len;\n\n\t/* Select page 0 registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Reset remote DMA complete flag. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_ISR, ED_ISR_RDC);\n\n\t/* Set up DMA byte count. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR0, len);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR1, len >> 8);\n\n\t/* Set up destination address in NIC mem. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RSAR0, dst);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RSAR1, dst >> 8);\n\n\t/* Set remote DMA write. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD1 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/*\n\t * Transfer the mbuf chain to the NIC memory.\n\t * 16-bit cards require that data be transferred as words, and only\n\t * words, so that case requires some extra code to patch over\n\t * odd-length mbufs.\n\t */\n\tif (!sc->isa16bit) {\n\t\t/* NE1000s are easy. */\n\t\tfor (; m != 0; m = m->m_next) {\n\t\t\tif (m->m_len) {\n\t\t\t\tbus_space_write_multi_1(iot, ioh,\n\t\t\t\t    asicbase + ED_NOVELL_DATA,\n\t\t\t\t    mtod(m, u_char *), m->m_len);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* NE2000s are a bit trickier. */\n\t\tu_int8_t *data, savebyte[2];\n\t\tint len, wantbyte;\n\n\t\twantbyte = 0;\n\t\tfor (; m != 0; m = m->m_next) {\n\t\t\tlen = m->m_len;\n\t\t\tif (len == 0)\n\t\t\t\tcontinue;\n\t\t\tdata = mtod(m, u_int8_t *);\n\t\t\t/* Finish the last word. */\n\t\t\tif (wantbyte) {\n\t\t\t\tsavebyte[1] = *data;\n\t\t\t\tbus_space_write_raw_multi_2(iot, ioh,\n\t\t\t\t    asicbase + ED_NOVELL_DATA, savebyte, 2);\n\t\t\t\tdata++;\n\t\t\t\tlen--;\n\t\t\t\twantbyte = 0;\n\t\t\t}\n\t\t\t/* Output contiguous words. */\n\t\t\tif (len > 1) {\n\t\t\t\tbus_space_write_raw_multi_2(iot, ioh,\n\t\t\t\t    asicbase + ED_NOVELL_DATA, data, len & ~1);\n\t\t\t}\n\t\t\t/* Save last byte, if necessary. */\n\t\t\tif (len & 1) {\n\t\t\t\tdata += len & ~1;\n\t\t\t\tsavebyte[0] = *data;\n\t\t\t\twantbyte = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (wantbyte) {\n\t\t\tsavebyte[1] = 0;\n\t\t\tbus_space_write_raw_multi_2(iot, ioh,\n\t\t\t    asicbase + ED_NOVELL_DATA, savebyte, 2);\n\t\t}\n\t}\n\n\t/*\n\t * Wait for remote DMA complete.  This is necessary because on the\n\t * transmit side, data is handled internally by the NIC in bursts and\n\t * we can't start another remote DMA until this one completes. \tNot\n\t * waiting causes really bad things to happen - like the NIC\n\t * irrecoverably jamming the ISA bus.\n\t */\n\twhile (((NIC_GET(iot, ioh, nicbase, ED_P0_ISR) & ED_ISR_RDC) !=\n\t    ED_ISR_RDC) && --maxwait);\n\n\tif (!maxwait) {\n\t\tlog(LOG_WARNING,\n\t\t    \"%s: remote transmit DMA failed to complete\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tedreset(sc);\n\t}\n\n\treturn (len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "sc->sc_delaybah",
            "0"
          ],
          "line": 2080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "sc->sc_delaybah",
            "0"
          ],
          "line": 2079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_WD_LAAR",
            "sc->wd_laar_proto"
          ],
          "line": 2077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_WD_MSR",
            "sc->wd_msr_proto"
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_3COM_GACFR",
            "ED_3COM_GACFR_RSEL | ED_3COM_GACFR_MBS0"
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed_shared_writemem",
          "args": [
            "sc",
            "mtod(m, caddr_t)",
            "buffer",
            "m->m_len"
          ],
          "line": 2059
        },
        "resolved": true,
        "details": {
          "function_name": "ed_shared_writemem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
          "lines": "2949-2995",
          "snippet": "void\ned_shared_writemem(sc, from, card, len)\n\tstruct ed_softc *sc;\n\tcaddr_t from;\n\tint card, len;\n{\n\tbus_space_tag_t memt = sc->sc_memt;\n\tbus_space_handle_t memh = sc->sc_memh;\n\tu_int16_t word;\n\n\t/*\n\t * For 16-bit cards, 16-bit memory access has already\n\t * been set up.  Note that some cards are really picky\n\t * about enforcing 16-bit access to memory, so we\n\t * have to be careful.\n\t */\n\tif (sc->isa16bit) {\n\t\t/*\n\t\t * If writing to an odd location, we need to align first.\n\t\t * This requires a read-modify-write cycle as we should\n\t\t * keep accesses 16-bit wide.\n\t\t */\n\t\tif (len > 0 && (card & 1)) {\n\t\t\tword = bus_space_read_2(memt, memh, card & ~1);\n\t\t\tword = (word & 0xff) | (*from << 8);\n\t\t\tbus_space_write_2(memt, memh, card & ~1, word);\n\t\t\tfrom++;\n\t\t\tcard++;\n\t\t\tlen--;\n\t\t}\n\t\t/* XXX I think maybe a bus_space_write_raw_region is needed. */\n\t\twhile (len > 1) {\n\t\t\tword = (u_int8_t)from[0] | (u_int8_t)from[1] << 8;\n\t\t\tbus_space_write_2(memt, memh, card, word);\n\t\t\tfrom += 2;\n\t\t\tcard += 2;\n\t\t\tlen -= 2;\n\t\t}\n\t\tif (len == 1) {\n\t\t\tword = *from;\n\t\t\tbus_space_write_2(memt, memh, card, word);\n\t\t}\n\t} else {\n\t\twhile (len--)\n\t\t\tbus_space_write_1(memt, memh, card++, *from++);\n\t}\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/isa/if_edreg.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"ed.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ed_shared_writemem",
            "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nvoid ed_shared_writemem;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nvoid\ned_shared_writemem(sc, from, card, len)\n\tstruct ed_softc *sc;\n\tcaddr_t from;\n\tint card, len;\n{\n\tbus_space_tag_t memt = sc->sc_memt;\n\tbus_space_handle_t memh = sc->sc_memh;\n\tu_int16_t word;\n\n\t/*\n\t * For 16-bit cards, 16-bit memory access has already\n\t * been set up.  Note that some cards are really picky\n\t * about enforcing 16-bit access to memory, so we\n\t * have to be careful.\n\t */\n\tif (sc->isa16bit) {\n\t\t/*\n\t\t * If writing to an odd location, we need to align first.\n\t\t * This requires a read-modify-write cycle as we should\n\t\t * keep accesses 16-bit wide.\n\t\t */\n\t\tif (len > 0 && (card & 1)) {\n\t\t\tword = bus_space_read_2(memt, memh, card & ~1);\n\t\t\tword = (word & 0xff) | (*from << 8);\n\t\t\tbus_space_write_2(memt, memh, card & ~1, word);\n\t\t\tfrom++;\n\t\t\tcard++;\n\t\t\tlen--;\n\t\t}\n\t\t/* XXX I think maybe a bus_space_write_raw_region is needed. */\n\t\twhile (len > 1) {\n\t\t\tword = (u_int8_t)from[0] | (u_int8_t)from[1] << 8;\n\t\t\tbus_space_write_2(memt, memh, card, word);\n\t\t\tfrom += 2;\n\t\t\tcard += 2;\n\t\t\tlen -= 2;\n\t\t}\n\t\tif (len == 1) {\n\t\t\tword = *from;\n\t\t\tbus_space_write_2(memt, memh, card, word);\n\t\t}\n\t} else {\n\t\twhile (len--)\n\t\t\tbus_space_write_1(memt, memh, card++, *from++);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "caddr_t"
          ],
          "line": 2059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "sc->sc_delaybah",
            "0"
          ],
          "line": 2054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "sc->sc_delaybah",
            "0"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_WD_MSR",
            "sc->wd_msr_proto | ED_WD_MSR_MENB"
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_WD_LAAR",
            "sc->wd_laar_proto | ED_WD_LAAR_M16EN"
          ],
          "line": 2049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_3COM_GACFR",
            "ED_3COM_GACFR_RSEL"
          ],
          "line": 2039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "m0"
          ],
          "line": 2022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"edstart: no header mbuf\""
          ],
          "line": 2017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "m0"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\n#define\tETHER_MIN_LEN\t64\n\nvoid edstart;\nvoid ed_shared_writemem;\nstatic __inline void ed_xmit;\nu_int16_t ed_pio_write_mbufs;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nvoid\nedstart(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct ed_softc *sc = ifp->if_softc;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct mbuf *m0, *m;\n\tint buffer;\n\tint asicbase = sc->asic_base;\n\tint len;\n\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\noutloop:\n\t/* See if there is room to put another packet in the buffer. */\n\tif (sc->txb_inuse == sc->txb_cnt) {\n\t\t/* No room.  Indicate this to the outside world and exit. */\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\tif (m0 == 0)\n\t\treturn;\n\n\t/* We need to use m->m_pkthdr.len, so require the header */\n\tif ((m0->m_flags & M_PKTHDR) == 0)\n\t\tpanic(\"edstart: no header mbuf\");\n\n#if NBPFILTER > 0\n\t/* Tap off here if there is a BPF listener. */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n\t/* txb_new points to next open buffer slot. */\n\tbuffer = sc->mem_start +\n\t    ((sc->txb_new * ED_TXBUF_SIZE) << ED_PAGE_SHIFT);\n\n\tif (sc->mem_shared) {\n\t\t/* Special case setup for 16 bit boards... */\n\t\tswitch (sc->vendor) {\n\t\t/*\n\t\t * For 16bit 3Com boards (which have 16k of memory), we\n\t\t * have the xmit buffers in a different page of memory\n\t\t * ('page 0') - so change pages.\n\t\t */\n\t\tcase ED_VENDOR_3COM:\n\t\t\tif (sc->isa16bit)\n\t\t\t\tbus_space_write_1(iot, ioh,\n\t\t\t\t    asicbase + ED_3COM_GACFR,\n\t\t\t\t    ED_3COM_GACFR_RSEL);\n\t\t\tbreak;\n\t\t/*\n\t\t * Enable 16bit access to shared memory on WD/SMC\n\t\t * boards.\n\t\t */\n\t\tcase ED_VENDOR_WD_SMC:\n\t\t\tif (sc->isa16bit)\n\t\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_LAAR,\n\t\t\t\t    sc->wd_laar_proto | ED_WD_LAAR_M16EN);\n\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR,\n\t\t\t    sc->wd_msr_proto | ED_WD_MSR_MENB);\n\t\t\t(void) bus_space_read_1(iot, sc->sc_delaybah, 0);\n\t\t\t(void) bus_space_read_1(iot, sc->sc_delaybah, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (m = m0; m != 0; m = m->m_next) {\n\t\t\ted_shared_writemem(sc, mtod(m, caddr_t), buffer,\n\t\t\t    m->m_len);\n\t\t\tbuffer += m->m_len;\n\t\t}\n\t\tlen = m0->m_pkthdr.len;\n\n\t\t/* Restore previous shared memory access. */\n\t\tswitch (sc->vendor) {\n\t\tcase ED_VENDOR_3COM:\n\t\t\tif (sc->isa16bit)\n\t\t\t\tbus_space_write_1(iot, ioh,\n\t\t\t\t    asicbase + ED_3COM_GACFR,\n\t\t\t\t    ED_3COM_GACFR_RSEL | ED_3COM_GACFR_MBS0);\n\t\t\tbreak;\n\t\tcase ED_VENDOR_WD_SMC:\n\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR,\n\t\t\t    sc->wd_msr_proto);\n\t\t\tif (sc->isa16bit)\n\t\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_LAAR,\n\t\t\t\t    sc->wd_laar_proto);\n\t\t\t(void) bus_space_read_1(iot, sc->sc_delaybah, 0);\n\t\t\t(void) bus_space_read_1(iot, sc->sc_delaybah, 0);\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tlen = ed_pio_write_mbufs(sc, m0, (u_int16_t)buffer);\n\n\tm_freem(m0);\n\tsc->txb_len[sc->txb_new] = max(len, ETHER_MIN_LEN);\n\n\t/* Start the first packet transmitting. */\n\tif (sc->txb_inuse == 0)\n\t\ted_xmit(sc);\n\n\t/* Point to next buffer slot and wrap if necessary. */\n\tif (++sc->txb_new == sc->txb_cnt)\n\t\tsc->txb_new = 0;\n\tsc->txb_inuse++;\n\n\t/* Loop back to the top to possibly buffer more packets. */\n\tgoto outloop;\n}"
  },
  {
    "function_name": "ed_xmit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
    "lines": "1942-1977",
    "snippet": "static __inline void\ned_xmit(sc)\n\tstruct ed_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint nicbase = sc->nic_base;\n\tu_int16_t len;\n\n\tlen = sc->txb_len[sc->txb_next_tx];\n\n\t/* Set NIC for page 0 register access. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Set TX buffer start page. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_TPSR, sc->tx_page_start +\n\t    sc->txb_next_tx * ED_TXBUF_SIZE);\n\n\t/* Set TX length. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_TBCR0, len);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_TBCR1, len >> 8);\n\n\t/* Set page 0, remote DMA complete, transmit packet, and *start*. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_TXP | ED_CR_STA);\n\n\t/* Point to next transmit buffer slot and wrap if necessary. */\n\tsc->txb_next_tx++;\n\tif (sc->txb_next_tx == sc->txb_cnt)\n\t\tsc->txb_next_tx = 0;\n\n\t/* Set a timer just in case we never hear from the board again. */\n\tifp->if_timer = 2;\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/isa/if_edreg.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"ed.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __inline void ed_xmit",
      "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_CR",
            "sc->cr_proto | ED_CR_PAGE_0 | ED_CR_TXP | ED_CR_STA"
          ],
          "line": 1967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_TBCR1",
            "len >> 8"
          ],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_TBCR0",
            "len"
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_TPSR",
            "sc->tx_page_start +\n\t    sc->txb_next_tx * ED_TXBUF_SIZE"
          ],
          "line": 1959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_CR",
            "sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA"
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nstatic __inline void ed_xmit;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nstatic __inline void\ned_xmit(sc)\n\tstruct ed_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint nicbase = sc->nic_base;\n\tu_int16_t len;\n\n\tlen = sc->txb_len[sc->txb_next_tx];\n\n\t/* Set NIC for page 0 register access. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Set TX buffer start page. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_TPSR, sc->tx_page_start +\n\t    sc->txb_next_tx * ED_TXBUF_SIZE);\n\n\t/* Set TX length. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_TBCR0, len);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_TBCR1, len >> 8);\n\n\t/* Set page 0, remote DMA complete, transmit packet, and *start*. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_TXP | ED_CR_STA);\n\n\t/* Point to next transmit buffer slot and wrap if necessary. */\n\tsc->txb_next_tx++;\n\tif (sc->txb_next_tx == sc->txb_cnt)\n\t\tsc->txb_next_tx = 0;\n\n\t/* Set a timer just in case we never hear from the board again. */\n\tifp->if_timer = 2;\n}"
  },
  {
    "function_name": "edinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
    "lines": "1788-1937",
    "snippet": "void\nedinit(sc)\n\tstruct ed_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint nicbase = sc->nic_base, asicbase = sc->asic_base;\n\tint i;\n\tu_int32_t mcaf[2];\n\n\t/*\n\t * Initialize the NIC in the exact order outlined in the NS manual.\n\t * This init procedure is \"mandatory\"...don't change what or when\n\t * things happen.\n\t */\n\n\t/* Reset transmitter flags. */\n\tifp->if_timer = 0;\n\n\tsc->txb_inuse = 0;\n\tsc->txb_new = 0;\n\tsc->txb_next_tx = 0;\n\n\t/* Set interface for page 0, remote DMA complete, stopped. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\tif (sc->isa16bit) {\n\t\t/*\n\t\t * Set FIFO threshold to 8, No auto-init Remote DMA, byte\n\t\t * order=80x86, word-wide DMA xfers,\n\t\t */\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_DCR,\n\t\t    ED_DCR_FT1 | ED_DCR_WTS | ED_DCR_LS);\n\t} else {\n\t\t/* Same as above, but byte-wide DMA xfers. */\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_DCR, ED_DCR_FT1 | ED_DCR_LS);\n\t}\n\n\t/* Clear remote byte count registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR0, 0);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR1, 0);\n\n\t/* Tell RCR to do nothing for now. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RCR, ED_RCR_MON);\n\n\t/* Place NIC in internal loopback mode. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_TCR, ED_TCR_LB0);\n\n\t/* Set lower bits of byte addressable framing to 0. */\n\tif (sc->is790)\n\t\tNIC_PUT(iot, ioh, nicbase, 0x09, 0);\n\n\t/* Initialize receive buffer ring. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_BNRY, sc->rec_page_start);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTART, sc->rec_page_start);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTOP, sc->rec_page_stop);\n\n\t/*\n\t * Clear all interrupts.  A '1' in each bit position clears the\n\t * corresponding flag.\n\t */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_ISR, 0xff);\n\n\t/*\n\t * Enable the following interrupts: receive/transmit complete,\n\t * receive/transmit error, and Receiver OverWrite.\n\t *\n\t * Counter overflow and Remote DMA complete are *not* enabled.\n\t */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_IMR,\n\t    ED_IMR_PRXE | ED_IMR_PTXE | ED_IMR_RXEE | ED_IMR_TXEE |\n\t    ED_IMR_OVWE);\n\n\t/* Program command register for page 1. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_1 | ED_CR_STP);\n\n\t/* Copy out our station address. */\n\tfor (i = 0; i < ETHER_ADDR_LEN; ++i)\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P1_PAR0 + i,\n\t\t    sc->sc_arpcom.ac_enaddr[i]);\n\n\t/* Set multicast filter on chip. */\n\ted_getmcaf(&sc->sc_arpcom, mcaf);\n\tfor (i = 0; i < 8; i++)\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P1_MAR0 + i,\n\t\t    ((u_char *)mcaf)[i]);\n\n\t/*\n\t * Set current page pointer to one page after the boundary pointer, as\n\t * recommended in the National manual.\n\t */\n\tsc->next_packet = sc->rec_page_start + 1;\n\tNIC_PUT(iot, ioh, nicbase, ED_P1_CURR, sc->next_packet);\n\n\t/* Program command register for page 0. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P1_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\ti = ED_RCR_AB | ED_RCR_AM;\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\t/*\n\t\t * Set promiscuous mode.  Multicast filter was set earlier so\n\t\t * that we should receive all multicast packets.\n\t\t */\n\t\ti |= ED_RCR_PRO | ED_RCR_AR | ED_RCR_SEP;\n\t}\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RCR, i);\n\n\t/* Take interface out of loopback. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_TCR, 0);\n\n\t/*\n\t * If this is a 3Com board, the tranceiver must be software enabled\n\t * (there is no settable hardware default).\n\t */\n\tswitch (sc->vendor) {\n\t\tu_char x;\n\tcase ED_VENDOR_3COM:\n\t\tif (ifp->if_flags & IFF_LINK0)\n\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_CR, 0);\n\t\telse\n\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_CR,\n\t\t\t    ED_3COM_CR_XSEL);\n\t\tbreak;\n\tcase ED_VENDOR_WD_SMC:\n\t\tif ((sc->type & ED_WD_SOFTCONFIG) == 0)\n\t\t\tbreak;\n\t\tx = bus_space_read_1(iot, ioh, asicbase + ED_WD_IRR);\n\t\tif (ifp->if_flags & IFF_LINK0)\n\t\t\tx &= ~ED_WD_IRR_OUT2;\n\t\telse\n\t\t\tx |= ED_WD_IRR_OUT2;\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_IRR, x);\n\t\tbreak;\n\t}\n\n\t/* Fire up the interface. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Set 'running' flag, and clear output active flag. */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/* ...and attempt to start output. */\n\tedstart(ifp);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/isa/if_edreg.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"ed.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define\tETHER_ADDR_LEN\t6"
    ],
    "globals_used": [
      "void edstart",
      "void edinit",
      "void ed_getmcaf",
      "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "edstart",
          "args": [
            "ifp"
          ],
          "line": 1936
        },
        "resolved": true,
        "details": {
          "function_name": "edstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
          "lines": "1988-2100",
          "snippet": "void\nedstart(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct ed_softc *sc = ifp->if_softc;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct mbuf *m0, *m;\n\tint buffer;\n\tint asicbase = sc->asic_base;\n\tint len;\n\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\noutloop:\n\t/* See if there is room to put another packet in the buffer. */\n\tif (sc->txb_inuse == sc->txb_cnt) {\n\t\t/* No room.  Indicate this to the outside world and exit. */\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\tif (m0 == 0)\n\t\treturn;\n\n\t/* We need to use m->m_pkthdr.len, so require the header */\n\tif ((m0->m_flags & M_PKTHDR) == 0)\n\t\tpanic(\"edstart: no header mbuf\");\n\n#if NBPFILTER > 0\n\t/* Tap off here if there is a BPF listener. */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n\t/* txb_new points to next open buffer slot. */\n\tbuffer = sc->mem_start +\n\t    ((sc->txb_new * ED_TXBUF_SIZE) << ED_PAGE_SHIFT);\n\n\tif (sc->mem_shared) {\n\t\t/* Special case setup for 16 bit boards... */\n\t\tswitch (sc->vendor) {\n\t\t/*\n\t\t * For 16bit 3Com boards (which have 16k of memory), we\n\t\t * have the xmit buffers in a different page of memory\n\t\t * ('page 0') - so change pages.\n\t\t */\n\t\tcase ED_VENDOR_3COM:\n\t\t\tif (sc->isa16bit)\n\t\t\t\tbus_space_write_1(iot, ioh,\n\t\t\t\t    asicbase + ED_3COM_GACFR,\n\t\t\t\t    ED_3COM_GACFR_RSEL);\n\t\t\tbreak;\n\t\t/*\n\t\t * Enable 16bit access to shared memory on WD/SMC\n\t\t * boards.\n\t\t */\n\t\tcase ED_VENDOR_WD_SMC:\n\t\t\tif (sc->isa16bit)\n\t\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_LAAR,\n\t\t\t\t    sc->wd_laar_proto | ED_WD_LAAR_M16EN);\n\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR,\n\t\t\t    sc->wd_msr_proto | ED_WD_MSR_MENB);\n\t\t\t(void) bus_space_read_1(iot, sc->sc_delaybah, 0);\n\t\t\t(void) bus_space_read_1(iot, sc->sc_delaybah, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (m = m0; m != 0; m = m->m_next) {\n\t\t\ted_shared_writemem(sc, mtod(m, caddr_t), buffer,\n\t\t\t    m->m_len);\n\t\t\tbuffer += m->m_len;\n\t\t}\n\t\tlen = m0->m_pkthdr.len;\n\n\t\t/* Restore previous shared memory access. */\n\t\tswitch (sc->vendor) {\n\t\tcase ED_VENDOR_3COM:\n\t\t\tif (sc->isa16bit)\n\t\t\t\tbus_space_write_1(iot, ioh,\n\t\t\t\t    asicbase + ED_3COM_GACFR,\n\t\t\t\t    ED_3COM_GACFR_RSEL | ED_3COM_GACFR_MBS0);\n\t\t\tbreak;\n\t\tcase ED_VENDOR_WD_SMC:\n\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR,\n\t\t\t    sc->wd_msr_proto);\n\t\t\tif (sc->isa16bit)\n\t\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_LAAR,\n\t\t\t\t    sc->wd_laar_proto);\n\t\t\t(void) bus_space_read_1(iot, sc->sc_delaybah, 0);\n\t\t\t(void) bus_space_read_1(iot, sc->sc_delaybah, 0);\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tlen = ed_pio_write_mbufs(sc, m0, (u_int16_t)buffer);\n\n\tm_freem(m0);\n\tsc->txb_len[sc->txb_new] = max(len, ETHER_MIN_LEN);\n\n\t/* Start the first packet transmitting. */\n\tif (sc->txb_inuse == 0)\n\t\ted_xmit(sc);\n\n\t/* Point to next buffer slot and wrap if necessary. */\n\tif (++sc->txb_new == sc->txb_cnt)\n\t\tsc->txb_new = 0;\n\tsc->txb_inuse++;\n\n\t/* Loop back to the top to possibly buffer more packets. */\n\tgoto outloop;\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/isa/if_edreg.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"ed.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tETHER_MIN_LEN\t64"
          ],
          "globals_used": [
            "void edstart",
            "void ed_shared_writemem",
            "static __inline void ed_xmit",
            "u_int16_t ed_pio_write_mbufs",
            "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\n#define\tETHER_MIN_LEN\t64\n\nvoid edstart;\nvoid ed_shared_writemem;\nstatic __inline void ed_xmit;\nu_int16_t ed_pio_write_mbufs;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nvoid\nedstart(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct ed_softc *sc = ifp->if_softc;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct mbuf *m0, *m;\n\tint buffer;\n\tint asicbase = sc->asic_base;\n\tint len;\n\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n\t\treturn;\n\noutloop:\n\t/* See if there is room to put another packet in the buffer. */\n\tif (sc->txb_inuse == sc->txb_cnt) {\n\t\t/* No room.  Indicate this to the outside world and exit. */\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\n\tIF_DEQUEUE(&ifp->if_snd, m0);\n\tif (m0 == 0)\n\t\treturn;\n\n\t/* We need to use m->m_pkthdr.len, so require the header */\n\tif ((m0->m_flags & M_PKTHDR) == 0)\n\t\tpanic(\"edstart: no header mbuf\");\n\n#if NBPFILTER > 0\n\t/* Tap off here if there is a BPF listener. */\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n\t/* txb_new points to next open buffer slot. */\n\tbuffer = sc->mem_start +\n\t    ((sc->txb_new * ED_TXBUF_SIZE) << ED_PAGE_SHIFT);\n\n\tif (sc->mem_shared) {\n\t\t/* Special case setup for 16 bit boards... */\n\t\tswitch (sc->vendor) {\n\t\t/*\n\t\t * For 16bit 3Com boards (which have 16k of memory), we\n\t\t * have the xmit buffers in a different page of memory\n\t\t * ('page 0') - so change pages.\n\t\t */\n\t\tcase ED_VENDOR_3COM:\n\t\t\tif (sc->isa16bit)\n\t\t\t\tbus_space_write_1(iot, ioh,\n\t\t\t\t    asicbase + ED_3COM_GACFR,\n\t\t\t\t    ED_3COM_GACFR_RSEL);\n\t\t\tbreak;\n\t\t/*\n\t\t * Enable 16bit access to shared memory on WD/SMC\n\t\t * boards.\n\t\t */\n\t\tcase ED_VENDOR_WD_SMC:\n\t\t\tif (sc->isa16bit)\n\t\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_LAAR,\n\t\t\t\t    sc->wd_laar_proto | ED_WD_LAAR_M16EN);\n\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR,\n\t\t\t    sc->wd_msr_proto | ED_WD_MSR_MENB);\n\t\t\t(void) bus_space_read_1(iot, sc->sc_delaybah, 0);\n\t\t\t(void) bus_space_read_1(iot, sc->sc_delaybah, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (m = m0; m != 0; m = m->m_next) {\n\t\t\ted_shared_writemem(sc, mtod(m, caddr_t), buffer,\n\t\t\t    m->m_len);\n\t\t\tbuffer += m->m_len;\n\t\t}\n\t\tlen = m0->m_pkthdr.len;\n\n\t\t/* Restore previous shared memory access. */\n\t\tswitch (sc->vendor) {\n\t\tcase ED_VENDOR_3COM:\n\t\t\tif (sc->isa16bit)\n\t\t\t\tbus_space_write_1(iot, ioh,\n\t\t\t\t    asicbase + ED_3COM_GACFR,\n\t\t\t\t    ED_3COM_GACFR_RSEL | ED_3COM_GACFR_MBS0);\n\t\t\tbreak;\n\t\tcase ED_VENDOR_WD_SMC:\n\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR,\n\t\t\t    sc->wd_msr_proto);\n\t\t\tif (sc->isa16bit)\n\t\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_LAAR,\n\t\t\t\t    sc->wd_laar_proto);\n\t\t\t(void) bus_space_read_1(iot, sc->sc_delaybah, 0);\n\t\t\t(void) bus_space_read_1(iot, sc->sc_delaybah, 0);\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tlen = ed_pio_write_mbufs(sc, m0, (u_int16_t)buffer);\n\n\tm_freem(m0);\n\tsc->txb_len[sc->txb_new] = max(len, ETHER_MIN_LEN);\n\n\t/* Start the first packet transmitting. */\n\tif (sc->txb_inuse == 0)\n\t\ted_xmit(sc);\n\n\t/* Point to next buffer slot and wrap if necessary. */\n\tif (++sc->txb_new == sc->txb_cnt)\n\t\tsc->txb_new = 0;\n\tsc->txb_inuse++;\n\n\t/* Loop back to the top to possibly buffer more packets. */\n\tgoto outloop;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_CR",
            "sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA"
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_WD_IRR",
            "x"
          ],
          "line": 1923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_WD_IRR"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_3COM_CR",
            "ED_3COM_CR_XSEL"
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_3COM_CR",
            "0"
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_TCR",
            "0"
          ],
          "line": 1900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_RCR",
            "i"
          ],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P1_CR",
            "sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP"
          ],
          "line": 1886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P1_CURR",
            "sc->next_packet"
          ],
          "line": 1883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P1_MAR0 + i",
            "((u_char *)mcaf)[i]"
          ],
          "line": 1875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed_getmcaf",
          "args": [
            "&sc->sc_arpcom",
            "mcaf"
          ],
          "line": 1873
        },
        "resolved": true,
        "details": {
          "function_name": "ed_getmcaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
          "lines": "2880-2947",
          "snippet": "void\ned_getmcaf(ac, af)\n\tstruct arpcom *ac;\n\tu_int32_t *af;\n{\n\tstruct ifnet *ifp = &ac->ac_if;\n\tstruct ether_multi *enm;\n\tregister u_char *cp, c;\n\tregister u_int32_t crc;\n\tregister int i, len;\n\tstruct ether_multistep step;\n\n\t/*\n\t * Set up multicast address filter by passing all multicast addresses\n\t * through a crc generator, and then using the high order 6 bits as an\n\t * index into the 64 bit logical address filter.  The high order bit\n\t * selects the word, while the rest of the bits select the bit within\n\t * the word.\n\t */\n\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\taf[0] = af[1] = 0xffffffff;\n\t\treturn;\n\t}\n\n\taf[0] = af[1] = 0;\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi,\n\t\t    sizeof(enm->enm_addrlo)) != 0) {\n\t\t\t/*\n\t\t\t * We must listen to a range of multicast addresses.\n\t\t\t * For now, just accept all multicasts, rather than\n\t\t\t * trying to set only those filter bits needed to match\n\t\t\t * the range.  (At this time, the only use of address\n\t\t\t * ranges is for IP multicast routing, for which the\n\t\t\t * range is big enough to require all bits set.)\n\t\t\t */\n\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\taf[0] = af[1] = 0xffffffff;\n\t\t\treturn;\n\t\t}\n\n\t\tcp = enm->enm_addrlo;\n\t\tcrc = 0xffffffff;\n\t\tfor (len = sizeof(enm->enm_addrlo); --len >= 0;) {\n\t\t\tc = *cp++;\n\t\t\tfor (i = 8; --i >= 0;) {\n\t\t\t\tif (((crc & 0x80000000) ? 1 : 0)\n\t\t\t\t    ^ (c & 0x01)) {\n\t\t\t\t\tcrc <<= 1;\n\t\t\t\t\tcrc ^= 0x04c11db6 | 1;\n\t\t\t\t} else\n\t\t\t\t\tcrc <<= 1;\n\t\t\t\tc >>= 1;\n\t\t\t}\n\t\t}\n\t\t/* Just want the 6 most significant bits. */\n\t\tcrc >>= 26;\n\n\t\t/* Turn on the corresponding bit in the filter. */\n\t\taf[crc >> 5] |= 1 << ((crc & 0x1f) ^ 0);\n\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\tifp->if_flags &= ~IFF_ALLMULTI;\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/isa/if_edreg.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"ed.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ed_getmcaf"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nvoid ed_getmcaf;\n\nvoid\ned_getmcaf(ac, af)\n\tstruct arpcom *ac;\n\tu_int32_t *af;\n{\n\tstruct ifnet *ifp = &ac->ac_if;\n\tstruct ether_multi *enm;\n\tregister u_char *cp, c;\n\tregister u_int32_t crc;\n\tregister int i, len;\n\tstruct ether_multistep step;\n\n\t/*\n\t * Set up multicast address filter by passing all multicast addresses\n\t * through a crc generator, and then using the high order 6 bits as an\n\t * index into the 64 bit logical address filter.  The high order bit\n\t * selects the word, while the rest of the bits select the bit within\n\t * the word.\n\t */\n\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\taf[0] = af[1] = 0xffffffff;\n\t\treturn;\n\t}\n\n\taf[0] = af[1] = 0;\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi,\n\t\t    sizeof(enm->enm_addrlo)) != 0) {\n\t\t\t/*\n\t\t\t * We must listen to a range of multicast addresses.\n\t\t\t * For now, just accept all multicasts, rather than\n\t\t\t * trying to set only those filter bits needed to match\n\t\t\t * the range.  (At this time, the only use of address\n\t\t\t * ranges is for IP multicast routing, for which the\n\t\t\t * range is big enough to require all bits set.)\n\t\t\t */\n\t\t\tifp->if_flags |= IFF_ALLMULTI;\n\t\t\taf[0] = af[1] = 0xffffffff;\n\t\t\treturn;\n\t\t}\n\n\t\tcp = enm->enm_addrlo;\n\t\tcrc = 0xffffffff;\n\t\tfor (len = sizeof(enm->enm_addrlo); --len >= 0;) {\n\t\t\tc = *cp++;\n\t\t\tfor (i = 8; --i >= 0;) {\n\t\t\t\tif (((crc & 0x80000000) ? 1 : 0)\n\t\t\t\t    ^ (c & 0x01)) {\n\t\t\t\t\tcrc <<= 1;\n\t\t\t\t\tcrc ^= 0x04c11db6 | 1;\n\t\t\t\t} else\n\t\t\t\t\tcrc <<= 1;\n\t\t\t\tc >>= 1;\n\t\t\t}\n\t\t}\n\t\t/* Just want the 6 most significant bits. */\n\t\tcrc >>= 26;\n\n\t\t/* Turn on the corresponding bit in the filter. */\n\t\taf[crc >> 5] |= 1 << ((crc & 0x1f) ^ 0);\n\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\tifp->if_flags &= ~IFF_ALLMULTI;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P1_PAR0 + i",
            "sc->sc_arpcom.ac_enaddr[i]"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_CR",
            "sc->cr_proto | ED_CR_PAGE_1 | ED_CR_STP"
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_IMR",
            "ED_IMR_PRXE | ED_IMR_PTXE | ED_IMR_RXEE | ED_IMR_TXEE |\n\t    ED_IMR_OVWE"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_ISR",
            "0xff"
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_PSTOP",
            "sc->rec_page_stop"
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_PSTART",
            "sc->rec_page_start"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_BNRY",
            "sc->rec_page_start"
          ],
          "line": 1843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "0x09",
            "0"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_TCR",
            "ED_TCR_LB0"
          ],
          "line": 1836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_RCR",
            "ED_RCR_MON"
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_RBCR1",
            "0"
          ],
          "line": 1830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_RBCR0",
            "0"
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_DCR",
            "ED_DCR_FT1 | ED_DCR_LS"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_DCR",
            "ED_DCR_FT1 | ED_DCR_WTS | ED_DCR_LS"
          ],
          "line": 1821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_CR",
            "sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP"
          ],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\n#define\tETHER_ADDR_LEN\t6\n\nvoid edstart;\nvoid edinit;\nvoid ed_getmcaf;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nvoid\nedinit(sc)\n\tstruct ed_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint nicbase = sc->nic_base, asicbase = sc->asic_base;\n\tint i;\n\tu_int32_t mcaf[2];\n\n\t/*\n\t * Initialize the NIC in the exact order outlined in the NS manual.\n\t * This init procedure is \"mandatory\"...don't change what or when\n\t * things happen.\n\t */\n\n\t/* Reset transmitter flags. */\n\tifp->if_timer = 0;\n\n\tsc->txb_inuse = 0;\n\tsc->txb_new = 0;\n\tsc->txb_next_tx = 0;\n\n\t/* Set interface for page 0, remote DMA complete, stopped. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\tif (sc->isa16bit) {\n\t\t/*\n\t\t * Set FIFO threshold to 8, No auto-init Remote DMA, byte\n\t\t * order=80x86, word-wide DMA xfers,\n\t\t */\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_DCR,\n\t\t    ED_DCR_FT1 | ED_DCR_WTS | ED_DCR_LS);\n\t} else {\n\t\t/* Same as above, but byte-wide DMA xfers. */\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_DCR, ED_DCR_FT1 | ED_DCR_LS);\n\t}\n\n\t/* Clear remote byte count registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR0, 0);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR1, 0);\n\n\t/* Tell RCR to do nothing for now. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RCR, ED_RCR_MON);\n\n\t/* Place NIC in internal loopback mode. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_TCR, ED_TCR_LB0);\n\n\t/* Set lower bits of byte addressable framing to 0. */\n\tif (sc->is790)\n\t\tNIC_PUT(iot, ioh, nicbase, 0x09, 0);\n\n\t/* Initialize receive buffer ring. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_BNRY, sc->rec_page_start);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTART, sc->rec_page_start);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTOP, sc->rec_page_stop);\n\n\t/*\n\t * Clear all interrupts.  A '1' in each bit position clears the\n\t * corresponding flag.\n\t */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_ISR, 0xff);\n\n\t/*\n\t * Enable the following interrupts: receive/transmit complete,\n\t * receive/transmit error, and Receiver OverWrite.\n\t *\n\t * Counter overflow and Remote DMA complete are *not* enabled.\n\t */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_IMR,\n\t    ED_IMR_PRXE | ED_IMR_PTXE | ED_IMR_RXEE | ED_IMR_TXEE |\n\t    ED_IMR_OVWE);\n\n\t/* Program command register for page 1. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_1 | ED_CR_STP);\n\n\t/* Copy out our station address. */\n\tfor (i = 0; i < ETHER_ADDR_LEN; ++i)\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P1_PAR0 + i,\n\t\t    sc->sc_arpcom.ac_enaddr[i]);\n\n\t/* Set multicast filter on chip. */\n\ted_getmcaf(&sc->sc_arpcom, mcaf);\n\tfor (i = 0; i < 8; i++)\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P1_MAR0 + i,\n\t\t    ((u_char *)mcaf)[i]);\n\n\t/*\n\t * Set current page pointer to one page after the boundary pointer, as\n\t * recommended in the National manual.\n\t */\n\tsc->next_packet = sc->rec_page_start + 1;\n\tNIC_PUT(iot, ioh, nicbase, ED_P1_CURR, sc->next_packet);\n\n\t/* Program command register for page 0. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P1_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\ti = ED_RCR_AB | ED_RCR_AM;\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\t/*\n\t\t * Set promiscuous mode.  Multicast filter was set earlier so\n\t\t * that we should receive all multicast packets.\n\t\t */\n\t\ti |= ED_RCR_PRO | ED_RCR_AR | ED_RCR_SEP;\n\t}\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RCR, i);\n\n\t/* Take interface out of loopback. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_TCR, 0);\n\n\t/*\n\t * If this is a 3Com board, the tranceiver must be software enabled\n\t * (there is no settable hardware default).\n\t */\n\tswitch (sc->vendor) {\n\t\tu_char x;\n\tcase ED_VENDOR_3COM:\n\t\tif (ifp->if_flags & IFF_LINK0)\n\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_CR, 0);\n\t\telse\n\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_CR,\n\t\t\t    ED_3COM_CR_XSEL);\n\t\tbreak;\n\tcase ED_VENDOR_WD_SMC:\n\t\tif ((sc->type & ED_WD_SOFTCONFIG) == 0)\n\t\t\tbreak;\n\t\tx = bus_space_read_1(iot, ioh, asicbase + ED_WD_IRR);\n\t\tif (ifp->if_flags & IFF_LINK0)\n\t\t\tx &= ~ED_WD_IRR_OUT2;\n\t\telse\n\t\t\tx |= ED_WD_IRR_OUT2;\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_IRR, x);\n\t\tbreak;\n\t}\n\n\t/* Fire up the interface. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Set 'running' flag, and clear output active flag. */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/* ...and attempt to start output. */\n\tedstart(ifp);\n}"
  },
  {
    "function_name": "edwatchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
    "lines": "1773-1783",
    "snippet": "void\nedwatchdog(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct ed_softc *sc = ifp->if_softc;\n\n\tlog(LOG_ERR, \"%s: device timeout\\n\", sc->sc_dev.dv_xname);\n\t++sc->sc_arpcom.ac_if.if_oerrors;\n\n\tedreset(sc);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/isa/if_edreg.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"ed.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void edwatchdog",
      "void edreset",
      "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "edreset",
          "args": [
            "sc"
          ],
          "line": 1782
        },
        "resolved": true,
        "details": {
          "function_name": "edreset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
          "lines": "1732-1742",
          "snippet": "void\nedreset(sc)\n\tstruct ed_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tedstop(sc);\n\tedinit(sc);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/isa/if_edreg.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"ed.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void edreset",
            "void edinit",
            "void edstop",
            "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nvoid edreset;\nvoid edinit;\nvoid edstop;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nvoid\nedreset(sc)\n\tstruct ed_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tedstop(sc);\n\tedinit(sc);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_ERR",
            "\"%s: device timeout\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1779
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_log_hard_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5909-5956",
          "snippet": "static void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "int\ti;",
            "ncb_p np = (struct ncb*) 0;",
            "int\ti;",
            "u_int8_t\tistat, dstat;",
            "u_int16_t\tsist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nint\ti;\nncb_p np = (struct ncb*) 0;\nint\ti;\nu_int8_t\tistat, dstat;\nu_int16_t\tsist;\n\nstatic void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nvoid edwatchdog;\nvoid edreset;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nvoid\nedwatchdog(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct ed_softc *sc = ifp->if_softc;\n\n\tlog(LOG_ERR, \"%s: device timeout\\n\", sc->sc_dev.dv_xname);\n\t++sc->sc_arpcom.ac_if.if_oerrors;\n\n\tedreset(sc);\n}"
  },
  {
    "function_name": "edstop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
    "lines": "1747-1767",
    "snippet": "void\nedstop(sc)\n\tstruct ed_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint nicbase = sc->nic_base;\n\tint n = 5000;\n\n\t/* Stop everything on the interface, and select page 0 registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\t/*\n\t * Wait for interface to enter stopped state, but limit # of checks to\n\t * 'n' (about 5ms).  It shouldn't even take 5us on modern DS8390's, but\n\t * just in case it's an old one.\n\t */\n\twhile (((NIC_GET(iot, ioh, nicbase,\n\t    ED_P0_ISR) & ED_ISR_RST) == 0) && --n);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/isa/if_edreg.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"ed.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void edstop",
      "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NIC_GET",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_ISR"
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_CR",
            "sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP"
          ],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nvoid edstop;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nvoid\nedstop(sc)\n\tstruct ed_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint nicbase = sc->nic_base;\n\tint n = 5000;\n\n\t/* Stop everything on the interface, and select page 0 registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\t/*\n\t * Wait for interface to enter stopped state, but limit # of checks to\n\t * 'n' (about 5ms).  It shouldn't even take 5us on modern DS8390's, but\n\t * just in case it's an old one.\n\t */\n\twhile (((NIC_GET(iot, ioh, nicbase,\n\t    ED_P0_ISR) & ED_ISR_RST) == 0) && --n);\n}"
  },
  {
    "function_name": "edreset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
    "lines": "1732-1742",
    "snippet": "void\nedreset(sc)\n\tstruct ed_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tedstop(sc);\n\tedinit(sc);\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/isa/if_edreg.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"ed.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void edreset",
      "void edinit",
      "void edstop",
      "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "edinit",
          "args": [
            "sc"
          ],
          "line": 1740
        },
        "resolved": true,
        "details": {
          "function_name": "edinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
          "lines": "1788-1937",
          "snippet": "void\nedinit(sc)\n\tstruct ed_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint nicbase = sc->nic_base, asicbase = sc->asic_base;\n\tint i;\n\tu_int32_t mcaf[2];\n\n\t/*\n\t * Initialize the NIC in the exact order outlined in the NS manual.\n\t * This init procedure is \"mandatory\"...don't change what or when\n\t * things happen.\n\t */\n\n\t/* Reset transmitter flags. */\n\tifp->if_timer = 0;\n\n\tsc->txb_inuse = 0;\n\tsc->txb_new = 0;\n\tsc->txb_next_tx = 0;\n\n\t/* Set interface for page 0, remote DMA complete, stopped. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\tif (sc->isa16bit) {\n\t\t/*\n\t\t * Set FIFO threshold to 8, No auto-init Remote DMA, byte\n\t\t * order=80x86, word-wide DMA xfers,\n\t\t */\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_DCR,\n\t\t    ED_DCR_FT1 | ED_DCR_WTS | ED_DCR_LS);\n\t} else {\n\t\t/* Same as above, but byte-wide DMA xfers. */\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_DCR, ED_DCR_FT1 | ED_DCR_LS);\n\t}\n\n\t/* Clear remote byte count registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR0, 0);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR1, 0);\n\n\t/* Tell RCR to do nothing for now. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RCR, ED_RCR_MON);\n\n\t/* Place NIC in internal loopback mode. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_TCR, ED_TCR_LB0);\n\n\t/* Set lower bits of byte addressable framing to 0. */\n\tif (sc->is790)\n\t\tNIC_PUT(iot, ioh, nicbase, 0x09, 0);\n\n\t/* Initialize receive buffer ring. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_BNRY, sc->rec_page_start);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTART, sc->rec_page_start);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTOP, sc->rec_page_stop);\n\n\t/*\n\t * Clear all interrupts.  A '1' in each bit position clears the\n\t * corresponding flag.\n\t */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_ISR, 0xff);\n\n\t/*\n\t * Enable the following interrupts: receive/transmit complete,\n\t * receive/transmit error, and Receiver OverWrite.\n\t *\n\t * Counter overflow and Remote DMA complete are *not* enabled.\n\t */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_IMR,\n\t    ED_IMR_PRXE | ED_IMR_PTXE | ED_IMR_RXEE | ED_IMR_TXEE |\n\t    ED_IMR_OVWE);\n\n\t/* Program command register for page 1. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_1 | ED_CR_STP);\n\n\t/* Copy out our station address. */\n\tfor (i = 0; i < ETHER_ADDR_LEN; ++i)\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P1_PAR0 + i,\n\t\t    sc->sc_arpcom.ac_enaddr[i]);\n\n\t/* Set multicast filter on chip. */\n\ted_getmcaf(&sc->sc_arpcom, mcaf);\n\tfor (i = 0; i < 8; i++)\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P1_MAR0 + i,\n\t\t    ((u_char *)mcaf)[i]);\n\n\t/*\n\t * Set current page pointer to one page after the boundary pointer, as\n\t * recommended in the National manual.\n\t */\n\tsc->next_packet = sc->rec_page_start + 1;\n\tNIC_PUT(iot, ioh, nicbase, ED_P1_CURR, sc->next_packet);\n\n\t/* Program command register for page 0. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P1_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\ti = ED_RCR_AB | ED_RCR_AM;\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\t/*\n\t\t * Set promiscuous mode.  Multicast filter was set earlier so\n\t\t * that we should receive all multicast packets.\n\t\t */\n\t\ti |= ED_RCR_PRO | ED_RCR_AR | ED_RCR_SEP;\n\t}\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RCR, i);\n\n\t/* Take interface out of loopback. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_TCR, 0);\n\n\t/*\n\t * If this is a 3Com board, the tranceiver must be software enabled\n\t * (there is no settable hardware default).\n\t */\n\tswitch (sc->vendor) {\n\t\tu_char x;\n\tcase ED_VENDOR_3COM:\n\t\tif (ifp->if_flags & IFF_LINK0)\n\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_CR, 0);\n\t\telse\n\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_CR,\n\t\t\t    ED_3COM_CR_XSEL);\n\t\tbreak;\n\tcase ED_VENDOR_WD_SMC:\n\t\tif ((sc->type & ED_WD_SOFTCONFIG) == 0)\n\t\t\tbreak;\n\t\tx = bus_space_read_1(iot, ioh, asicbase + ED_WD_IRR);\n\t\tif (ifp->if_flags & IFF_LINK0)\n\t\t\tx &= ~ED_WD_IRR_OUT2;\n\t\telse\n\t\t\tx |= ED_WD_IRR_OUT2;\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_IRR, x);\n\t\tbreak;\n\t}\n\n\t/* Fire up the interface. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Set 'running' flag, and clear output active flag. */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/* ...and attempt to start output. */\n\tedstart(ifp);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/isa/if_edreg.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"ed.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tETHER_ADDR_LEN\t6"
          ],
          "globals_used": [
            "void edstart",
            "void edinit",
            "void ed_getmcaf",
            "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\n#define\tETHER_ADDR_LEN\t6\n\nvoid edstart;\nvoid edinit;\nvoid ed_getmcaf;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nvoid\nedinit(sc)\n\tstruct ed_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint nicbase = sc->nic_base, asicbase = sc->asic_base;\n\tint i;\n\tu_int32_t mcaf[2];\n\n\t/*\n\t * Initialize the NIC in the exact order outlined in the NS manual.\n\t * This init procedure is \"mandatory\"...don't change what or when\n\t * things happen.\n\t */\n\n\t/* Reset transmitter flags. */\n\tifp->if_timer = 0;\n\n\tsc->txb_inuse = 0;\n\tsc->txb_new = 0;\n\tsc->txb_next_tx = 0;\n\n\t/* Set interface for page 0, remote DMA complete, stopped. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\tif (sc->isa16bit) {\n\t\t/*\n\t\t * Set FIFO threshold to 8, No auto-init Remote DMA, byte\n\t\t * order=80x86, word-wide DMA xfers,\n\t\t */\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_DCR,\n\t\t    ED_DCR_FT1 | ED_DCR_WTS | ED_DCR_LS);\n\t} else {\n\t\t/* Same as above, but byte-wide DMA xfers. */\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_DCR, ED_DCR_FT1 | ED_DCR_LS);\n\t}\n\n\t/* Clear remote byte count registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR0, 0);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR1, 0);\n\n\t/* Tell RCR to do nothing for now. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RCR, ED_RCR_MON);\n\n\t/* Place NIC in internal loopback mode. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_TCR, ED_TCR_LB0);\n\n\t/* Set lower bits of byte addressable framing to 0. */\n\tif (sc->is790)\n\t\tNIC_PUT(iot, ioh, nicbase, 0x09, 0);\n\n\t/* Initialize receive buffer ring. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_BNRY, sc->rec_page_start);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTART, sc->rec_page_start);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTOP, sc->rec_page_stop);\n\n\t/*\n\t * Clear all interrupts.  A '1' in each bit position clears the\n\t * corresponding flag.\n\t */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_ISR, 0xff);\n\n\t/*\n\t * Enable the following interrupts: receive/transmit complete,\n\t * receive/transmit error, and Receiver OverWrite.\n\t *\n\t * Counter overflow and Remote DMA complete are *not* enabled.\n\t */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_IMR,\n\t    ED_IMR_PRXE | ED_IMR_PTXE | ED_IMR_RXEE | ED_IMR_TXEE |\n\t    ED_IMR_OVWE);\n\n\t/* Program command register for page 1. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_1 | ED_CR_STP);\n\n\t/* Copy out our station address. */\n\tfor (i = 0; i < ETHER_ADDR_LEN; ++i)\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P1_PAR0 + i,\n\t\t    sc->sc_arpcom.ac_enaddr[i]);\n\n\t/* Set multicast filter on chip. */\n\ted_getmcaf(&sc->sc_arpcom, mcaf);\n\tfor (i = 0; i < 8; i++)\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P1_MAR0 + i,\n\t\t    ((u_char *)mcaf)[i]);\n\n\t/*\n\t * Set current page pointer to one page after the boundary pointer, as\n\t * recommended in the National manual.\n\t */\n\tsc->next_packet = sc->rec_page_start + 1;\n\tNIC_PUT(iot, ioh, nicbase, ED_P1_CURR, sc->next_packet);\n\n\t/* Program command register for page 0. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P1_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\ti = ED_RCR_AB | ED_RCR_AM;\n\tif (ifp->if_flags & IFF_PROMISC) {\n\t\t/*\n\t\t * Set promiscuous mode.  Multicast filter was set earlier so\n\t\t * that we should receive all multicast packets.\n\t\t */\n\t\ti |= ED_RCR_PRO | ED_RCR_AR | ED_RCR_SEP;\n\t}\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RCR, i);\n\n\t/* Take interface out of loopback. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_TCR, 0);\n\n\t/*\n\t * If this is a 3Com board, the tranceiver must be software enabled\n\t * (there is no settable hardware default).\n\t */\n\tswitch (sc->vendor) {\n\t\tu_char x;\n\tcase ED_VENDOR_3COM:\n\t\tif (ifp->if_flags & IFF_LINK0)\n\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_CR, 0);\n\t\telse\n\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_CR,\n\t\t\t    ED_3COM_CR_XSEL);\n\t\tbreak;\n\tcase ED_VENDOR_WD_SMC:\n\t\tif ((sc->type & ED_WD_SOFTCONFIG) == 0)\n\t\t\tbreak;\n\t\tx = bus_space_read_1(iot, ioh, asicbase + ED_WD_IRR);\n\t\tif (ifp->if_flags & IFF_LINK0)\n\t\t\tx &= ~ED_WD_IRR_OUT2;\n\t\telse\n\t\t\tx |= ED_WD_IRR_OUT2;\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_IRR, x);\n\t\tbreak;\n\t}\n\n\t/* Fire up the interface. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Set 'running' flag, and clear output active flag. */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t/* ...and attempt to start output. */\n\tedstart(ifp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "edstop",
          "args": [
            "sc"
          ],
          "line": 1739
        },
        "resolved": true,
        "details": {
          "function_name": "edstop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
          "lines": "1747-1767",
          "snippet": "void\nedstop(sc)\n\tstruct ed_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint nicbase = sc->nic_base;\n\tint n = 5000;\n\n\t/* Stop everything on the interface, and select page 0 registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\t/*\n\t * Wait for interface to enter stopped state, but limit # of checks to\n\t * 'n' (about 5ms).  It shouldn't even take 5us on modern DS8390's, but\n\t * just in case it's an old one.\n\t */\n\twhile (((NIC_GET(iot, ioh, nicbase,\n\t    ED_P0_ISR) & ED_ISR_RST) == 0) && --n);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/isa/if_edreg.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"ed.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void edstop",
            "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nvoid edstop;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nvoid\nedstop(sc)\n\tstruct ed_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint nicbase = sc->nic_base;\n\tint n = 5000;\n\n\t/* Stop everything on the interface, and select page 0 registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\t/*\n\t * Wait for interface to enter stopped state, but limit # of checks to\n\t * 'n' (about 5ms).  It shouldn't even take 5us on modern DS8390's, but\n\t * just in case it's an old one.\n\t */\n\twhile (((NIC_GET(iot, ioh, nicbase,\n\t    ED_P0_ISR) & ED_ISR_RST) == 0) && --n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 1738
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nvoid edreset;\nvoid edinit;\nvoid edstop;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nvoid\nedreset(sc)\n\tstruct ed_softc *sc;\n{\n\tint s;\n\n\ts = splnet();\n\tedstop(sc);\n\tedinit(sc);\n\tsplx(s);\n}"
  },
  {
    "function_name": "edattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
    "lines": "1634-1727",
    "snippet": "void\nedattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tstruct ed_softc *sc = (void *)self;\n\tstruct isa_attach_args *ia = aux;\n\tstruct cfdata *cf = sc->sc_dev.dv_cfdata;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint asicbase;\n\n\t/*\n\t * XXX Should re-map io and mem, but can't\n\t * XXX until we squish \"indirect\" brokenness.\n\t */\n\tiot = sc->sc_iot;\t\t/* XXX */\n\tioh = sc->sc_ioh;\t\t/* XXX */\n\n\tasicbase = sc->asic_base;\n\tsc->sc_delaybah = ia->ia_delaybah;\n\n\t/* Set interface to stopped condition (reset). */\n\tedstop(sc);\n\n\t/* Initialize ifnet structure. */\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_start = edstart;\n\tifp->if_ioctl = edioctl;\n\tifp->if_watchdog = edwatchdog;\n\tifp->if_flags =\n\t    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;\n\n\t/*\n\t * Set default state for LINK0 flag (used to disable the tranceiver\n\t * for AUI operation), based on compile-time config option.\n\t */\n\tswitch (sc->vendor) {\n\tcase ED_VENDOR_3COM:\n\t\tif (cf->cf_flags & ED_FLAGS_DISABLE_TRANCEIVER)\n\t\t\tifp->if_flags |= IFF_LINK0;\n\t\tbreak;\n\tcase ED_VENDOR_WD_SMC:\n\t\tif ((sc->type & ED_WD_SOFTCONFIG) == 0)\n\t\t\tbreak;\n\t\tif ((bus_space_read_1(iot, ioh, asicbase + ED_WD_IRR) &\n\t\t    ED_WD_IRR_OUT2) == 0)\n\t\t\tifp->if_flags |= IFF_LINK0;\n\t\tbreak;\n\t}\n\n\t/* Attach the interface. */\n\tif ((sc->spec_flags & ED_REATTACH) == 0) {\n\t\tif_attach(ifp);\n\t\tether_ifattach(ifp);\n\t}\n\tether_ifattach(ifp);\n\n\t/* Print additional info when attached. */\n\tprintf(\": address %s, \", ether_sprintf(sc->sc_arpcom.ac_enaddr));\n\n\tif (sc->type_str)\n\t\tprintf(\"type %s \", sc->type_str);\n\telse\n\t\tprintf(\"type unknown (0x%x) \", sc->type);\n\n\tprintf(\"%s\", sc->isa16bit ? \"(16-bit)\" : \"(8-bit)\");\n\n\tswitch (sc->vendor) {\n\tcase ED_VENDOR_WD_SMC:\n\t\tif ((sc->type & ED_WD_SOFTCONFIG) == 0)\n\t\t\tbreak;\n\tcase ED_VENDOR_3COM:\n\t\tif (ifp->if_flags & IFF_LINK0)\n\t\t\tprintf(\" aui\");\n\t\telse\n\t\t\tprintf(\" bnc\");\n\t\tbreak;\n\t}\n\n\tprintf(\"\\n\");\n\n#if NBPFILTER > 0\n\tif ((sc->spec_flags & ED_REATTACH) == 0)\n\t\tbpfattach(&ifp->if_bpf, ifp, DLT_EN10MB,\n\t\t\t  sizeof(struct ether_header));\n#endif\n\n\tsc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,\n\t    IPL_NET, edintr, sc, sc->sc_dev.dv_xname);\n\tsc->sc_sh = shutdownhook_establish((void (*)(void *))edstop, sc);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/isa/if_edreg.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"ed.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define ED_REATTACH\t0x0001\t/* Reattach */"
    ],
    "globals_used": [
      "void edattach",
      "int edintr",
      "int edioctl",
      "void edstart",
      "void edwatchdog",
      "void edstop",
      "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "shutdownhook_establish",
          "args": [
            "(void (*)(void *))edstop",
            "sc"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isa_intr_establish",
          "args": [
            "ia->ia_ic",
            "ia->ia_irq",
            "IST_EDGE",
            "IPL_NET",
            "edintr",
            "sc",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpfattach",
          "args": [
            "&ifp->if_bpf",
            "ifp",
            "DLT_EN10MB",
            "sizeof(struct ether_header)"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 1716
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_sprintf",
          "args": [
            "sc->sc_arpcom.ac_enaddr"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ifattach",
          "args": [
            "ifp"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ifattach",
          "args": [
            "ifp"
          ],
          "line": 1690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_attach",
          "args": [
            "ifp"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_WD_IRR"
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "sc->sc_dev.dv_xname",
            "ifp->if_xname",
            "IFNAMSIZ"
          ],
          "line": 1661
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "edstop",
          "args": [
            "sc"
          ],
          "line": 1658
        },
        "resolved": true,
        "details": {
          "function_name": "edstop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
          "lines": "1747-1767",
          "snippet": "void\nedstop(sc)\n\tstruct ed_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint nicbase = sc->nic_base;\n\tint n = 5000;\n\n\t/* Stop everything on the interface, and select page 0 registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\t/*\n\t * Wait for interface to enter stopped state, but limit # of checks to\n\t * 'n' (about 5ms).  It shouldn't even take 5us on modern DS8390's, but\n\t * just in case it's an old one.\n\t */\n\twhile (((NIC_GET(iot, ioh, nicbase,\n\t    ED_P0_ISR) & ED_ISR_RST) == 0) && --n);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/isa/if_edreg.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"ed.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void edstop",
            "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nvoid edstop;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nvoid\nedstop(sc)\n\tstruct ed_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint nicbase = sc->nic_base;\n\tint n = 5000;\n\n\t/* Stop everything on the interface, and select page 0 registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\t/*\n\t * Wait for interface to enter stopped state, but limit # of checks to\n\t * 'n' (about 5ms).  It shouldn't even take 5us on modern DS8390's, but\n\t * just in case it's an old one.\n\t */\n\twhile (((NIC_GET(iot, ioh, nicbase,\n\t    ED_P0_ISR) & ED_ISR_RST) == 0) && --n);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\n#define ED_REATTACH\t0x0001\t/* Reattach */\n\nvoid edattach;\nint edintr;\nint edioctl;\nvoid edstart;\nvoid edwatchdog;\nvoid edstop;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nvoid\nedattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tstruct ed_softc *sc = (void *)self;\n\tstruct isa_attach_args *ia = aux;\n\tstruct cfdata *cf = sc->sc_dev.dv_cfdata;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tint asicbase;\n\n\t/*\n\t * XXX Should re-map io and mem, but can't\n\t * XXX until we squish \"indirect\" brokenness.\n\t */\n\tiot = sc->sc_iot;\t\t/* XXX */\n\tioh = sc->sc_ioh;\t\t/* XXX */\n\n\tasicbase = sc->asic_base;\n\tsc->sc_delaybah = ia->ia_delaybah;\n\n\t/* Set interface to stopped condition (reset). */\n\tedstop(sc);\n\n\t/* Initialize ifnet structure. */\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_start = edstart;\n\tifp->if_ioctl = edioctl;\n\tifp->if_watchdog = edwatchdog;\n\tifp->if_flags =\n\t    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;\n\n\t/*\n\t * Set default state for LINK0 flag (used to disable the tranceiver\n\t * for AUI operation), based on compile-time config option.\n\t */\n\tswitch (sc->vendor) {\n\tcase ED_VENDOR_3COM:\n\t\tif (cf->cf_flags & ED_FLAGS_DISABLE_TRANCEIVER)\n\t\t\tifp->if_flags |= IFF_LINK0;\n\t\tbreak;\n\tcase ED_VENDOR_WD_SMC:\n\t\tif ((sc->type & ED_WD_SOFTCONFIG) == 0)\n\t\t\tbreak;\n\t\tif ((bus_space_read_1(iot, ioh, asicbase + ED_WD_IRR) &\n\t\t    ED_WD_IRR_OUT2) == 0)\n\t\t\tifp->if_flags |= IFF_LINK0;\n\t\tbreak;\n\t}\n\n\t/* Attach the interface. */\n\tif ((sc->spec_flags & ED_REATTACH) == 0) {\n\t\tif_attach(ifp);\n\t\tether_ifattach(ifp);\n\t}\n\tether_ifattach(ifp);\n\n\t/* Print additional info when attached. */\n\tprintf(\": address %s, \", ether_sprintf(sc->sc_arpcom.ac_enaddr));\n\n\tif (sc->type_str)\n\t\tprintf(\"type %s \", sc->type_str);\n\telse\n\t\tprintf(\"type unknown (0x%x) \", sc->type);\n\n\tprintf(\"%s\", sc->isa16bit ? \"(16-bit)\" : \"(8-bit)\");\n\n\tswitch (sc->vendor) {\n\tcase ED_VENDOR_WD_SMC:\n\t\tif ((sc->type & ED_WD_SOFTCONFIG) == 0)\n\t\t\tbreak;\n\tcase ED_VENDOR_3COM:\n\t\tif (ifp->if_flags & IFF_LINK0)\n\t\t\tprintf(\" aui\");\n\t\telse\n\t\t\tprintf(\" bnc\");\n\t\tbreak;\n\t}\n\n\tprintf(\"\\n\");\n\n#if NBPFILTER > 0\n\tif ((sc->spec_flags & ED_REATTACH) == 0)\n\t\tbpfattach(&ifp->if_bpf, ifp, DLT_EN10MB,\n\t\t\t  sizeof(struct ether_header));\n#endif\n\n\tsc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,\n\t    IPL_NET, edintr, sc, sc->sc_dev.dv_xname);\n\tsc->sc_sh = shutdownhook_establish((void (*)(void *))edstop, sc);\n}"
  },
  {
    "function_name": "ed_find_Novell",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
    "lines": "1387-1629",
    "snippet": "int\ned_find_Novell(sc, cf, ia)\n\tstruct ed_softc *sc;\n\tstruct cfdata *cf;\n\tstruct isa_attach_args *ia;\n{\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tu_int memsize, n;\n\tu_char romdata[16], tmp;\n\tstatic u_char test_pattern[32] = \"THIS is A memory TEST pattern\";\n\tu_char test_buffer[32];\n\tint asicbase, nicbase;\n\n\tiot = ia->ia_iot;\n\n\tif (bus_space_map(iot, ia->ia_iobase, ED_NOVELL_IO_PORTS, 0, &ioh))\n\t\treturn (0);\n\n\tsc->asic_base = asicbase = ED_NOVELL_ASIC_OFFSET;\n\tsc->nic_base = nicbase = ED_NOVELL_NIC_OFFSET;\n\n\t/* XXX - do Novell-specific probe here */\n\n\t/* Reset the board. */\n#ifdef GWETHER\n\tbus_space_write_1(iot, ioh, asicbase + ED_NOVELL_RESET, 0);\n\tdelay(200);\n#endif /* GWETHER */\n\ttmp = bus_space_read_1(iot, ioh, asicbase + ED_NOVELL_RESET);\n\n\t/*\n\t * I don't know if this is necessary; probably cruft leftover from\n\t * Clarkson packet driver code. Doesn't do a thing on the boards I've\n\t * tested. -DG [note that a outb(0x84, 0) seems to work here, and is\n\t * non-invasive...but some boards don't seem to reset and I don't have\n\t * complete documentation on what the 'right' thing to do is...so we do\n\t * the invasive thing for now.  Yuck.]\n\t */\n\tbus_space_write_1(iot, ioh, asicbase + ED_NOVELL_RESET, tmp);\n\tdelay(5000);\n\n\t/*\n\t * This is needed because some NE clones apparently don't reset the NIC\n\t * properly (or the NIC chip doesn't reset fully on power-up)\n\t * XXX - this makes the probe invasive! ...Done against my better\n\t * judgement.  -DLG\n\t */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STP);\n\n\tdelay(5000);\n\n\t/* Make sure that we really have an 8390 based board. */\n\tif (!ed_probe_generic8390(iot, ioh, nicbase))\n\t\tgoto out;\n\n\tsc->vendor = ED_VENDOR_NOVELL;\n\tsc->mem_shared = 0;\n\tsc->cr_proto = ED_CR_RD2;\n\tia->ia_msize = 0;\n\n\t/*\n\t * Test the ability to read and write to the NIC memory.  This has the\n\t * side affect of determining if this is an NE1000 or an NE2000.\n\t */\n\n\t/*\n\t * This prevents packets from being stored in the NIC memory when the\n\t * readmem routine turns on the start bit in the CR.\n\t */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RCR, ED_RCR_MON);\n\n\t/* Temporarily initialize DCR for byte operations. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_DCR, ED_DCR_FT1 | ED_DCR_LS);\n\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTART, 8192 >> ED_PAGE_SHIFT);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTOP, 16384 >> ED_PAGE_SHIFT);\n\n\tsc->isa16bit = 0;\n\n\t/*\n\t * XXX indirect brokenness, used by ed_pio{read,write}mem()\n\t */\n\tsc->sc_iot = iot;\n\tsc->sc_ioh = ioh;\n\n\t/*\n\t * Write a test pattern in byte mode.  If this fails, then there\n\t * probably isn't any memory at 8k - which likely means that the board\n\t * is an NE2000.\n\t */\n\ted_pio_writemem(sc, test_pattern, 8192, sizeof(test_pattern));\n\ted_pio_readmem(sc, 8192, test_buffer, sizeof(test_pattern));\n\n\tif (bcmp(test_pattern, test_buffer, sizeof(test_pattern))) {\n\t\t/* not an NE1000 - try NE2000 */\n\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_DCR,\n\t\t    ED_DCR_WTS | ED_DCR_FT1 | ED_DCR_LS);\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTART, 16384 >> ED_PAGE_SHIFT);\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTOP, 32768 >> ED_PAGE_SHIFT);\n\n\t\tsc->isa16bit = 1;\n\n\t\t/*\n\t\t * Write a test pattern in word mode.  If this also fails, then\n\t\t * we don't know what this board is.\n\t\t */\n\t\ted_pio_writemem(sc, test_pattern, 16384, sizeof(test_pattern));\n\t\ted_pio_readmem(sc, 16384, test_buffer, sizeof(test_pattern));\n\n\t\tif (bcmp(test_pattern, test_buffer, sizeof(test_pattern)))\n\t\t\tgoto out; /* not an NE2000 either */\n\n\t\tsc->type = ED_TYPE_NE2000;\n\t\tsc->type_str = \"NE2000\";\n\t} else {\n\t\tsc->type = ED_TYPE_NE1000;\n\t\tsc->type_str = \"NE1000\";\n\t}\n\n\tif (ia->ia_irq == IRQUNK) {\n\t\tprintf(\"%s: %s does not have soft configuration\\n\",\n\t\t    sc->sc_dev.dv_xname, sc->type_str);\n\t\tgoto out;\n\t}\n\n\t/* 8k of memory plus an additional 8k if 16-bit. */\n\tmemsize = 8192 + sc->isa16bit * 8192;\n\n#if 0 /* probably not useful - NE boards only come two ways */\n\t/* Allow kernel config file overrides. */\n\tif (ia->ia_msize)\n\t\tmemsize = ia->ia_msize;\n#endif\n\n\t/* NIC memory doesn't start at zero on an NE board. */\n\t/* The start address is tied to the bus width. */\n\tsc->mem_start = (8192 + sc->isa16bit * 8192);\n\tsc->tx_page_start = memsize >> ED_PAGE_SHIFT;\n\n#ifdef GWETHER\n\t{\n\t\tint x, i, mstart = 0;\n\t\tchar pbuf0[ED_PAGE_SIZE], pbuf[ED_PAGE_SIZE], tbuf[ED_PAGE_SIZE];\n\n\t\tfor (i = 0; i < ED_PAGE_SIZE; i++)\n\t\t\tpbuf0[i] = 0;\n\n\t\t/* Search for the start of RAM. */\n\t\tfor (x = 1; x < 256; x++) {\n\t\t\ted_pio_writemem(sc, pbuf0, x << ED_PAGE_SHIFT, ED_PAGE_SIZE);\n\t\t\ted_pio_readmem(sc, x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE);\n\t\t\tif (!bcmp(pbuf0, tbuf, ED_PAGE_SIZE)) {\n\t\t\t\tfor (i = 0; i < ED_PAGE_SIZE; i++)\n\t\t\t\t\tpbuf[i] = 255 - x;\n\t\t\t\ted_pio_writemem(sc, pbuf, x << ED_PAGE_SHIFT, ED_PAGE_SIZE);\n\t\t\t\ted_pio_readmem(sc, x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE);\n\t\t\t\tif (!bcmp(pbuf, tbuf, ED_PAGE_SIZE)) {\n\t\t\t\t\tmstart = x << ED_PAGE_SHIFT;\n\t\t\t\t\tmemsize = ED_PAGE_SIZE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (mstart == 0) {\n\t\t\tprintf(\"%s: cannot find start of RAM\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* Search for the end of RAM. */\n\t\tfor (++x; x < 256; x++) {\n\t\t\ted_pio_writemem(sc, pbuf0, x << ED_PAGE_SHIFT, ED_PAGE_SIZE);\n\t\t\ted_pio_readmem(sc, x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE);\n\t\t\tif (!bcmp(pbuf0, tbuf, ED_PAGE_SIZE)) {\n\t\t\t\tfor (i = 0; i < ED_PAGE_SIZE; i++)\n\t\t\t\t\tpbuf[i] = 255 - x;\n\t\t\t\ted_pio_writemem(sc, pbuf, x << ED_PAGE_SHIFT, ED_PAGE_SIZE);\n\t\t\t\ted_pio_readmem(sc, x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE);\n\t\t\t\tif (!bcmp(pbuf, tbuf, ED_PAGE_SIZE))\n\t\t\t\t\tmemsize += ED_PAGE_SIZE;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\n\t\tprintf(\"%s: RAM start %x, size %d\\n\",\n\t\t    sc->sc_dev.dv_xname, mstart, memsize);\n\n\t\tsc->mem_start = (caddr_t)mstart;\n\t\tsc->tx_page_start = mstart >> ED_PAGE_SHIFT;\n\t}\n#endif /* GWETHER */\n\n\tsc->mem_size = memsize;\n\tsc->mem_end = sc->mem_start + memsize;\n\n\t/*\n\t * Use one xmit buffer if < 16k, two buffers otherwise (if not told\n\t * otherwise).\n\t */\n\tif ((memsize < 16384) || (cf->cf_flags & ED_FLAGS_NO_MULTI_BUFFERING))\n\t\tsc->txb_cnt = 1;\n\telse\n\t\tsc->txb_cnt = 2;\n\n\tsc->rec_page_start = sc->tx_page_start + sc->txb_cnt * ED_TXBUF_SIZE;\n\tsc->rec_page_stop = sc->tx_page_start + (memsize >> ED_PAGE_SHIFT);\n\n\tsc->mem_ring =\n\t    sc->mem_start + ((sc->txb_cnt * ED_TXBUF_SIZE) << ED_PAGE_SHIFT);\n\n\ted_pio_readmem(sc, 0, romdata, 16);\n\tfor (n = 0; n < ETHER_ADDR_LEN; n++)\n\t\tsc->sc_arpcom.ac_enaddr[n] = romdata[n*(sc->isa16bit+1)];\n\n#ifdef GWETHER\n\tif (sc->arpcom.ac_enaddr[2] == 0x86)\n\t\tsc->type_str = \"Gateway AT\";\n#endif /* GWETHER */\n\n\t/* Clear any pending interrupts that might have occurred above. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_ISR, 0xff);\n\n\tia->ia_iosize = ED_NOVELL_IO_PORTS;\n\n\t/*\n\t * XXX Sould always unmap, but we can't yet.\n\t * XXX Need to squish \"indirect\" first.\n\t */\n\tsc->sc_iot = iot;\n\tsc->sc_ioh = ioh;\n\t/* sc_memh is not used by this driver */\n\treturn 1;\n out:\n\tbus_space_unmap(iot, ioh, ED_NOVELL_IO_PORTS);\n\n\treturn 0;\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/isa/if_edreg.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"ed.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define\tETHER_ADDR_LEN\t6"
    ],
    "globals_used": [
      "int ed_probe_generic8390",
      "int ed_find_Novell",
      "void ed_pio_readmem",
      "void ed_pio_writemem",
      "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "iot",
            "ioh",
            "ED_NOVELL_IO_PORTS"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_ISR",
            "0xff"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed_pio_readmem",
          "args": [
            "sc",
            "0",
            "romdata",
            "16"
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "ed_pio_readmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
          "lines": "2584-2620",
          "snippet": "void\ned_pio_readmem(sc, src, dst, amount)\n\tstruct ed_softc *sc;\n\tu_int16_t src;\n\tcaddr_t dst;\n\tu_int16_t amount;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint nicbase = sc->nic_base;\n\n\t/* Select page 0 registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Round up to a word. */\n\tif (amount & 1)\n\t\t++amount;\n\n\t/* Set up DMA byte count. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR0, amount);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR1, amount >> 8);\n\n\t/* Set up source address in NIC mem. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RSAR0, src);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RSAR1, src >> 8);\n\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD0 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tif (sc->isa16bit)\n\t\tbus_space_read_raw_multi_2(iot, ioh,\n\t\t    sc->asic_base + ED_NOVELL_DATA, dst, amount);\n\telse\n\t\tbus_space_read_multi_1(iot, ioh,\n\t\t    sc->asic_base + ED_NOVELL_DATA, dst, amount);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/isa/if_edreg.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"ed.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ed_pio_readmem",
            "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;",
            "int src;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nvoid ed_pio_readmem;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\nint src;\n\nvoid\ned_pio_readmem(sc, src, dst, amount)\n\tstruct ed_softc *sc;\n\tu_int16_t src;\n\tcaddr_t dst;\n\tu_int16_t amount;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint nicbase = sc->nic_base;\n\n\t/* Select page 0 registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Round up to a word. */\n\tif (amount & 1)\n\t\t++amount;\n\n\t/* Set up DMA byte count. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR0, amount);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR1, amount >> 8);\n\n\t/* Set up source address in NIC mem. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RSAR0, src);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RSAR1, src >> 8);\n\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD0 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tif (sc->isa16bit)\n\t\tbus_space_read_raw_multi_2(iot, ioh,\n\t\t    sc->asic_base + ED_NOVELL_DATA, dst, amount);\n\telse\n\t\tbus_space_read_multi_1(iot, ioh,\n\t\t    sc->asic_base + ED_NOVELL_DATA, dst, amount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: RAM start %x, size %d\\n\"",
            "sc->sc_dev.dv_xname",
            "mstart",
            "memsize"
          ],
          "line": 1577
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "pbuf",
            "tbuf",
            "ED_PAGE_SIZE"
          ],
          "line": 1569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed_pio_writemem",
          "args": [
            "sc",
            "pbuf",
            "x << ED_PAGE_SHIFT",
            "ED_PAGE_SIZE"
          ],
          "line": 1567
        },
        "resolved": true,
        "details": {
          "function_name": "ed_pio_writemem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
          "lines": "2626-2673",
          "snippet": "void\ned_pio_writemem(sc, src, dst, len)\n\tstruct ed_softc *sc;\n\tcaddr_t src;\n\tu_int16_t dst;\n\tu_int16_t len;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint nicbase = sc->nic_base;\n\tint maxwait = 100; /* about 120us */\n\n\t/* Select page 0 registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Reset remote DMA complete flag. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_ISR, ED_ISR_RDC);\n\n\t/* Set up DMA byte count. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR0, len);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR1, len >> 8);\n\n\t/* Set up destination address in NIC mem. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RSAR0, dst);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RSAR1, dst >> 8);\n\n\t/* Set remote DMA write. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD1 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tif (sc->isa16bit)\n\t\tbus_space_write_raw_multi_2(iot, ioh,\n\t\t    sc->asic_base + ED_NOVELL_DATA, src, len);\n\telse\n\t\tbus_space_write_multi_1(iot, ioh,\n\t\t    sc->asic_base + ED_NOVELL_DATA, src, len);\n\n\t/*\n\t * Wait for remote DMA complete.  This is necessary because on the\n\t * transmit side, data is handled internally by the NIC in bursts and\n\t * we can't start another remote DMA until this one completes.  Not\n\t * waiting causes really bad things to happen - like the NIC\n\t * irrecoverably jamming the ISA bus.\n\t */\n\twhile (((NIC_GET(iot, ioh, nicbase, ED_P0_ISR) & ED_ISR_RDC) !=\n\t    ED_ISR_RDC) && --maxwait);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/isa/if_edreg.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"ed.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ed_pio_writemem",
            "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;",
            "int src;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nvoid ed_pio_writemem;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\nint src;\n\nvoid\ned_pio_writemem(sc, src, dst, len)\n\tstruct ed_softc *sc;\n\tcaddr_t src;\n\tu_int16_t dst;\n\tu_int16_t len;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint nicbase = sc->nic_base;\n\tint maxwait = 100; /* about 120us */\n\n\t/* Select page 0 registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Reset remote DMA complete flag. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_ISR, ED_ISR_RDC);\n\n\t/* Set up DMA byte count. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR0, len);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR1, len >> 8);\n\n\t/* Set up destination address in NIC mem. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RSAR0, dst);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RSAR1, dst >> 8);\n\n\t/* Set remote DMA write. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD1 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tif (sc->isa16bit)\n\t\tbus_space_write_raw_multi_2(iot, ioh,\n\t\t    sc->asic_base + ED_NOVELL_DATA, src, len);\n\telse\n\t\tbus_space_write_multi_1(iot, ioh,\n\t\t    sc->asic_base + ED_NOVELL_DATA, src, len);\n\n\t/*\n\t * Wait for remote DMA complete.  This is necessary because on the\n\t * transmit side, data is handled internally by the NIC in bursts and\n\t * we can't start another remote DMA until this one completes.  Not\n\t * waiting causes really bad things to happen - like the NIC\n\t * irrecoverably jamming the ISA bus.\n\t */\n\twhile (((NIC_GET(iot, ioh, nicbase, ED_P0_ISR) & ED_ISR_RDC) !=\n\t    ED_ISR_RDC) && --maxwait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "pbuf0",
            "tbuf",
            "ED_PAGE_SIZE"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "pbuf",
            "tbuf",
            "ED_PAGE_SIZE"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "pbuf0",
            "tbuf",
            "ED_PAGE_SIZE"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "test_pattern",
            "test_buffer",
            "sizeof(test_pattern)"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_PSTOP",
            "32768 >> ED_PAGE_SHIFT"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_PSTART",
            "16384 >> ED_PAGE_SHIFT"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_DCR",
            "ED_DCR_WTS | ED_DCR_FT1 | ED_DCR_LS"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "test_pattern",
            "test_buffer",
            "sizeof(test_pattern)"
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_PSTOP",
            "16384 >> ED_PAGE_SHIFT"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_PSTART",
            "8192 >> ED_PAGE_SHIFT"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_DCR",
            "ED_DCR_FT1 | ED_DCR_LS"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_RCR",
            "ED_RCR_MON"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed_probe_generic8390",
          "args": [
            "iot",
            "ioh",
            "nicbase"
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "ed_probe_generic8390",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
          "lines": "603-618",
          "snippet": "int\ned_probe_generic8390(t, bah, nicbase)\n\tbus_space_tag_t t;\n\tbus_space_handle_t bah;\n\tint nicbase;\n{\n\n\tif ((NIC_GET(t, bah, nicbase, ED_P0_CR) &\n\t     (ED_CR_RD2 | ED_CR_TXP | ED_CR_STA | ED_CR_STP)) !=\n\t    (ED_CR_RD2 | ED_CR_STP))\n\t\treturn (0);\n\tif ((NIC_GET(t, bah, nicbase, ED_P0_ISR) & ED_ISR_RST) != ED_ISR_RST)\n\t\treturn (0);\n\n\treturn (1);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/isa/if_edreg.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"ed.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int ed_probe_generic8390"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nint ed_probe_generic8390;\n\nint\ned_probe_generic8390(t, bah, nicbase)\n\tbus_space_tag_t t;\n\tbus_space_handle_t bah;\n\tint nicbase;\n{\n\n\tif ((NIC_GET(t, bah, nicbase, ED_P0_CR) &\n\t     (ED_CR_RD2 | ED_CR_TXP | ED_CR_STA | ED_CR_STP)) !=\n\t    (ED_CR_RD2 | ED_CR_STP))\n\t\treturn (0);\n\tif ((NIC_GET(t, bah, nicbase, ED_P0_ISR) & ED_ISR_RST) != ED_ISR_RST)\n\t\treturn (0);\n\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "5000"
          ],
          "line": 1438
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_CR",
            "ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STP"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_NOVELL_RESET",
            "tmp"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_NOVELL_RESET"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_NOVELL_RESET",
            "0"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "iot",
            "ia->ia_iobase",
            "ED_NOVELL_IO_PORTS",
            "0",
            "&ioh"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\n#define\tETHER_ADDR_LEN\t6\n\nint ed_probe_generic8390;\nint ed_find_Novell;\nvoid ed_pio_readmem;\nvoid ed_pio_writemem;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nint\ned_find_Novell(sc, cf, ia)\n\tstruct ed_softc *sc;\n\tstruct cfdata *cf;\n\tstruct isa_attach_args *ia;\n{\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tu_int memsize, n;\n\tu_char romdata[16], tmp;\n\tstatic u_char test_pattern[32] = \"THIS is A memory TEST pattern\";\n\tu_char test_buffer[32];\n\tint asicbase, nicbase;\n\n\tiot = ia->ia_iot;\n\n\tif (bus_space_map(iot, ia->ia_iobase, ED_NOVELL_IO_PORTS, 0, &ioh))\n\t\treturn (0);\n\n\tsc->asic_base = asicbase = ED_NOVELL_ASIC_OFFSET;\n\tsc->nic_base = nicbase = ED_NOVELL_NIC_OFFSET;\n\n\t/* XXX - do Novell-specific probe here */\n\n\t/* Reset the board. */\n#ifdef GWETHER\n\tbus_space_write_1(iot, ioh, asicbase + ED_NOVELL_RESET, 0);\n\tdelay(200);\n#endif /* GWETHER */\n\ttmp = bus_space_read_1(iot, ioh, asicbase + ED_NOVELL_RESET);\n\n\t/*\n\t * I don't know if this is necessary; probably cruft leftover from\n\t * Clarkson packet driver code. Doesn't do a thing on the boards I've\n\t * tested. -DG [note that a outb(0x84, 0) seems to work here, and is\n\t * non-invasive...but some boards don't seem to reset and I don't have\n\t * complete documentation on what the 'right' thing to do is...so we do\n\t * the invasive thing for now.  Yuck.]\n\t */\n\tbus_space_write_1(iot, ioh, asicbase + ED_NOVELL_RESET, tmp);\n\tdelay(5000);\n\n\t/*\n\t * This is needed because some NE clones apparently don't reset the NIC\n\t * properly (or the NIC chip doesn't reset fully on power-up)\n\t * XXX - this makes the probe invasive! ...Done against my better\n\t * judgement.  -DLG\n\t */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STP);\n\n\tdelay(5000);\n\n\t/* Make sure that we really have an 8390 based board. */\n\tif (!ed_probe_generic8390(iot, ioh, nicbase))\n\t\tgoto out;\n\n\tsc->vendor = ED_VENDOR_NOVELL;\n\tsc->mem_shared = 0;\n\tsc->cr_proto = ED_CR_RD2;\n\tia->ia_msize = 0;\n\n\t/*\n\t * Test the ability to read and write to the NIC memory.  This has the\n\t * side affect of determining if this is an NE1000 or an NE2000.\n\t */\n\n\t/*\n\t * This prevents packets from being stored in the NIC memory when the\n\t * readmem routine turns on the start bit in the CR.\n\t */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RCR, ED_RCR_MON);\n\n\t/* Temporarily initialize DCR for byte operations. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_DCR, ED_DCR_FT1 | ED_DCR_LS);\n\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTART, 8192 >> ED_PAGE_SHIFT);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTOP, 16384 >> ED_PAGE_SHIFT);\n\n\tsc->isa16bit = 0;\n\n\t/*\n\t * XXX indirect brokenness, used by ed_pio{read,write}mem()\n\t */\n\tsc->sc_iot = iot;\n\tsc->sc_ioh = ioh;\n\n\t/*\n\t * Write a test pattern in byte mode.  If this fails, then there\n\t * probably isn't any memory at 8k - which likely means that the board\n\t * is an NE2000.\n\t */\n\ted_pio_writemem(sc, test_pattern, 8192, sizeof(test_pattern));\n\ted_pio_readmem(sc, 8192, test_buffer, sizeof(test_pattern));\n\n\tif (bcmp(test_pattern, test_buffer, sizeof(test_pattern))) {\n\t\t/* not an NE1000 - try NE2000 */\n\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_DCR,\n\t\t    ED_DCR_WTS | ED_DCR_FT1 | ED_DCR_LS);\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTART, 16384 >> ED_PAGE_SHIFT);\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTOP, 32768 >> ED_PAGE_SHIFT);\n\n\t\tsc->isa16bit = 1;\n\n\t\t/*\n\t\t * Write a test pattern in word mode.  If this also fails, then\n\t\t * we don't know what this board is.\n\t\t */\n\t\ted_pio_writemem(sc, test_pattern, 16384, sizeof(test_pattern));\n\t\ted_pio_readmem(sc, 16384, test_buffer, sizeof(test_pattern));\n\n\t\tif (bcmp(test_pattern, test_buffer, sizeof(test_pattern)))\n\t\t\tgoto out; /* not an NE2000 either */\n\n\t\tsc->type = ED_TYPE_NE2000;\n\t\tsc->type_str = \"NE2000\";\n\t} else {\n\t\tsc->type = ED_TYPE_NE1000;\n\t\tsc->type_str = \"NE1000\";\n\t}\n\n\tif (ia->ia_irq == IRQUNK) {\n\t\tprintf(\"%s: %s does not have soft configuration\\n\",\n\t\t    sc->sc_dev.dv_xname, sc->type_str);\n\t\tgoto out;\n\t}\n\n\t/* 8k of memory plus an additional 8k if 16-bit. */\n\tmemsize = 8192 + sc->isa16bit * 8192;\n\n#if 0 /* probably not useful - NE boards only come two ways */\n\t/* Allow kernel config file overrides. */\n\tif (ia->ia_msize)\n\t\tmemsize = ia->ia_msize;\n#endif\n\n\t/* NIC memory doesn't start at zero on an NE board. */\n\t/* The start address is tied to the bus width. */\n\tsc->mem_start = (8192 + sc->isa16bit * 8192);\n\tsc->tx_page_start = memsize >> ED_PAGE_SHIFT;\n\n#ifdef GWETHER\n\t{\n\t\tint x, i, mstart = 0;\n\t\tchar pbuf0[ED_PAGE_SIZE], pbuf[ED_PAGE_SIZE], tbuf[ED_PAGE_SIZE];\n\n\t\tfor (i = 0; i < ED_PAGE_SIZE; i++)\n\t\t\tpbuf0[i] = 0;\n\n\t\t/* Search for the start of RAM. */\n\t\tfor (x = 1; x < 256; x++) {\n\t\t\ted_pio_writemem(sc, pbuf0, x << ED_PAGE_SHIFT, ED_PAGE_SIZE);\n\t\t\ted_pio_readmem(sc, x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE);\n\t\t\tif (!bcmp(pbuf0, tbuf, ED_PAGE_SIZE)) {\n\t\t\t\tfor (i = 0; i < ED_PAGE_SIZE; i++)\n\t\t\t\t\tpbuf[i] = 255 - x;\n\t\t\t\ted_pio_writemem(sc, pbuf, x << ED_PAGE_SHIFT, ED_PAGE_SIZE);\n\t\t\t\ted_pio_readmem(sc, x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE);\n\t\t\t\tif (!bcmp(pbuf, tbuf, ED_PAGE_SIZE)) {\n\t\t\t\t\tmstart = x << ED_PAGE_SHIFT;\n\t\t\t\t\tmemsize = ED_PAGE_SIZE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (mstart == 0) {\n\t\t\tprintf(\"%s: cannot find start of RAM\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* Search for the end of RAM. */\n\t\tfor (++x; x < 256; x++) {\n\t\t\ted_pio_writemem(sc, pbuf0, x << ED_PAGE_SHIFT, ED_PAGE_SIZE);\n\t\t\ted_pio_readmem(sc, x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE);\n\t\t\tif (!bcmp(pbuf0, tbuf, ED_PAGE_SIZE)) {\n\t\t\t\tfor (i = 0; i < ED_PAGE_SIZE; i++)\n\t\t\t\t\tpbuf[i] = 255 - x;\n\t\t\t\ted_pio_writemem(sc, pbuf, x << ED_PAGE_SHIFT, ED_PAGE_SIZE);\n\t\t\t\ted_pio_readmem(sc, x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE);\n\t\t\t\tif (!bcmp(pbuf, tbuf, ED_PAGE_SIZE))\n\t\t\t\t\tmemsize += ED_PAGE_SIZE;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\n\t\tprintf(\"%s: RAM start %x, size %d\\n\",\n\t\t    sc->sc_dev.dv_xname, mstart, memsize);\n\n\t\tsc->mem_start = (caddr_t)mstart;\n\t\tsc->tx_page_start = mstart >> ED_PAGE_SHIFT;\n\t}\n#endif /* GWETHER */\n\n\tsc->mem_size = memsize;\n\tsc->mem_end = sc->mem_start + memsize;\n\n\t/*\n\t * Use one xmit buffer if < 16k, two buffers otherwise (if not told\n\t * otherwise).\n\t */\n\tif ((memsize < 16384) || (cf->cf_flags & ED_FLAGS_NO_MULTI_BUFFERING))\n\t\tsc->txb_cnt = 1;\n\telse\n\t\tsc->txb_cnt = 2;\n\n\tsc->rec_page_start = sc->tx_page_start + sc->txb_cnt * ED_TXBUF_SIZE;\n\tsc->rec_page_stop = sc->tx_page_start + (memsize >> ED_PAGE_SHIFT);\n\n\tsc->mem_ring =\n\t    sc->mem_start + ((sc->txb_cnt * ED_TXBUF_SIZE) << ED_PAGE_SHIFT);\n\n\ted_pio_readmem(sc, 0, romdata, 16);\n\tfor (n = 0; n < ETHER_ADDR_LEN; n++)\n\t\tsc->sc_arpcom.ac_enaddr[n] = romdata[n*(sc->isa16bit+1)];\n\n#ifdef GWETHER\n\tif (sc->arpcom.ac_enaddr[2] == 0x86)\n\t\tsc->type_str = \"Gateway AT\";\n#endif /* GWETHER */\n\n\t/* Clear any pending interrupts that might have occurred above. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_ISR, 0xff);\n\n\tia->ia_iosize = ED_NOVELL_IO_PORTS;\n\n\t/*\n\t * XXX Sould always unmap, but we can't yet.\n\t * XXX Need to squish \"indirect\" first.\n\t */\n\tsc->sc_iot = iot;\n\tsc->sc_ioh = ioh;\n\t/* sc_memh is not used by this driver */\n\treturn 1;\n out:\n\tbus_space_unmap(iot, ioh, ED_NOVELL_IO_PORTS);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ed_find_3Com",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
    "lines": "1084-1382",
    "snippet": "int\ned_find_3Com(sc, cf, ia)\n\tstruct ed_softc *sc;\n\tstruct cfdata *cf;\n\tstruct isa_attach_args *ia;\n{\n\tbus_space_tag_t iot;\n\tbus_space_tag_t memt;\n\tbus_space_handle_t ioh;\n\tbus_space_handle_t memh;\n\tint i;\n\tu_int memsize, memfail;\n\tu_char isa16bit, x;\n\tint ptr, asicbase, nicbase;\n\n\t/*\n\t * Hmmm...a 16bit 3Com board has 16k of memory, but only an 8k window\n\t * to it.\n\t */\n\tmemsize = 8192;\n\n\tiot = ia->ia_iot;\n\tmemt = ia->ia_memt;\n\n\tif (bus_space_map(iot, ia->ia_iobase, ED_3COM_IO_PORTS, 0, &ioh))\n\t\treturn (0);\n\n\tsc->asic_base = asicbase = ED_3COM_ASIC_OFFSET;\n\tsc->nic_base = nicbase = ED_3COM_NIC_OFFSET;\n\n\t/*\n\t * Verify that the kernel configured I/O address matches the board\n\t * configured address.\n\t *\n\t * This is really only useful to see if something that looks like the\n\t * board is there; after all, we are already talking it at that\n\t * address.\n\t */\n\tx = bus_space_read_1(iot, ioh, asicbase + ED_3COM_BCFR);\n\tif (x == 0 || (x & (x - 1)) != 0)\n\t\tgoto err;\n\tptr = ffs(x) - 1;\n\tif (ia->ia_iobase != IOBASEUNK) {\n\t\tif (ia->ia_iobase != ed_3com_iobase[ptr]) {\n\t\t\tprintf(\"%s: %s mismatch; kernel configured %x != board configured %x\\n\",\n\t\t\t    \"iobase\", sc->sc_dev.dv_xname, ia->ia_iobase,\n\t\t\t    ed_3com_iobase[ptr]);\n\t\t\tgoto err;\n\t\t}\n\t} else\n\t\tia->ia_iobase = ed_3com_iobase[ptr];\t/* XXX --thorpej */\n\n\tx = bus_space_read_1(iot, ioh, asicbase + ED_3COM_PCFR);\n\tif (x == 0 || (x & (x - 1)) != 0) {\n\t\tprintf(\"%s: The 3c503 is not currently supported with memory \"\n\t\t       \"mapping disabled.\\n%s: Reconfigure the card to \"\n\t\t       \"enable memory mapping.\\n\",\n\t\t       sc->sc_dev.dv_xname, sc->sc_dev.dv_xname);\n\t\tgoto err;\n\t}\n\tptr = ffs(x) - 1;\n\tif (ia->ia_maddr != MADDRUNK) {\n\t\tif (ia->ia_maddr != ed_3com_maddr[ptr]) {\n\t\t\tprintf(\"%s: %s mismatch; kernel configured %x != board configured %x\\n\",\n\t\t\t    \"maddr\", sc->sc_dev.dv_xname, ia->ia_maddr,\n\t\t\t    ed_3com_maddr[ptr]);\n\t\t\tgoto err;\n\t\t}\n\t} else\n\t\tia->ia_maddr = ed_3com_maddr[ptr];\n\n#if 0\n\tx = bus_space_read_1(iot, ioh, asicbase + ED_3COM_IDCFR) &\n\t    ED_3COM_IDCFR_IRQ;\n\tif (x == 0 || (x & (x - 1)) != 0)\n\t\tgoto out;\n\tptr = ffs(x) - 1;\n\tif (ia->ia_irq != IRQUNK) {\n\t\tif (ia->ia_irq != ed_3com_irq[ptr]) {\n\t\t\tprintf(\"%s: irq mismatch; kernel configured %d != board configured %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, ia->ia_irq,\n\t\t\t    ed_3com_irq[ptr]);\n\t\t\tgoto err;\n\t\t}\n\t} else\n\t\tia->ia_irq = ed_3com_irq[ptr];\n#endif\n\n\t/*\n\t * Reset NIC and ASIC.  Enable on-board transceiver throughout reset\n\t * sequence because it'll lock up if the cable isn't connected if we\n\t * don't.\n\t */\n\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_CR,\n\t    ED_3COM_CR_RST | ED_3COM_CR_XSEL);\n\n\t/* Wait for a while, then un-reset it. */\n\tdelay(50);\n\n\t/*\n\t * The 3Com ASIC defaults to rather strange settings for the CR after a\n\t * reset - it's important to set it again after the following outb\n\t * (this is done when we map the PROM below).\n\t */\n\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_CR, ED_3COM_CR_XSEL);\n\n\t/* Wait a bit for the NIC to recover from the reset. */\n\tdelay(5000);\n\n\tsc->vendor = ED_VENDOR_3COM;\n\tsc->type_str = \"3c503\";\n\tsc->mem_shared = 1;\n\tsc->cr_proto = ED_CR_RD2;\n\n\t/*\n\t * Get station address from on-board ROM.\n\t *\n\t * First, map ethernet address PROM over the top of where the NIC\n\t * registers normally appear.\n\t */\n\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_CR,\n\t    ED_3COM_CR_EALO | ED_3COM_CR_XSEL);\n\n\tfor (i = 0; i < ETHER_ADDR_LEN; ++i)\n\t\tsc->sc_arpcom.ac_enaddr[i] = NIC_GET(iot, ioh, nicbase, i);\n\n\t/*\n\t * Unmap PROM - select NIC registers.  The proper setting of the\n\t * tranceiver is set in edinit so that the attach code is given a\n\t * chance to set the default based on a compile-time config option.\n\t */\n\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_CR, ED_3COM_CR_XSEL);\n\n\t/* Determine if this is an 8bit or 16bit board. */\n\n\t/* Select page 0 registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STP);\n\n\t/*\n\t * Attempt to clear WTS bit.  If it doesn't clear, then this is a\n\t * 16-bit board.\n\t */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_DCR, 0);\n\n\t/* Select page 2 registers. */\n\tNIC_PUT(iot, ioh, nicbase,\n\t    ED_P0_CR, ED_CR_RD2 | ED_CR_PAGE_2 | ED_CR_STP);\n\n\t/* The 3c503 forces the WTS bit to a one if this is a 16bit board. */\n\tif (NIC_GET(iot, ioh, nicbase, ED_P2_DCR) & ED_DCR_WTS)\n\t\tisa16bit = 1;\n\telse\n\t\tisa16bit = 0;\n\n\t/* Select page 0 registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P2_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STP);\n\n\tif (bus_space_map(memt, ia->ia_maddr, memsize, 0, &memh))\n\t\tgoto err;\n\tsc->mem_start = 0;\t\t/* offset */\n\tsc->mem_size = memsize;\n\tsc->mem_end = sc->mem_start + memsize;\n\n\t/*\n\t * We have an entire 8k window to put the transmit buffers on the\n\t * 16-bit boards.  But since the 16bit 3c503's shared memory is only\n\t * fast enough to overlap the loading of one full-size packet, trying\n\t * to load more than 2 buffers can actually leave the transmitter idle\n\t * during the load.  So 2 seems the best value.  (Although a mix of\n\t * variable-sized packets might change this assumption.  Nonetheless,\n\t * we optimize for linear transfers of same-size packets.)\n\t */\n\tif (isa16bit) {\n \t\tif (cf->cf_flags & ED_FLAGS_NO_MULTI_BUFFERING)\n\t\t\tsc->txb_cnt = 1;\n\t\telse\n\t\t\tsc->txb_cnt = 2;\n\n\t\tsc->tx_page_start = ED_3COM_TX_PAGE_OFFSET_16BIT;\n\t\tsc->rec_page_start = ED_3COM_RX_PAGE_OFFSET_16BIT;\n\t\tsc->rec_page_stop =\n\t\t    (memsize >> ED_PAGE_SHIFT) + ED_3COM_RX_PAGE_OFFSET_16BIT;\n\t\tsc->mem_ring = sc->mem_start;\n\t} else {\n\t\tsc->txb_cnt = 1;\n\t\tsc->tx_page_start = ED_3COM_TX_PAGE_OFFSET_8BIT;\n\t\tsc->rec_page_start =\n\t\t    ED_TXBUF_SIZE + ED_3COM_TX_PAGE_OFFSET_8BIT;\n\t\tsc->rec_page_stop =\n\t\t    (memsize >> ED_PAGE_SHIFT) + ED_3COM_TX_PAGE_OFFSET_8BIT;\n\t\tsc->mem_ring =\n\t\t    sc->mem_start + (ED_TXBUF_SIZE << ED_PAGE_SHIFT);\n\t}\n\n\tsc->isa16bit = isa16bit;\n\n\t/*\n\t * Initialize GA page start/stop registers.  Probably only needed if\n\t * doing DMA, but what the Hell.\n\t */\n\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_PSTR, sc->rec_page_start);\n\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_PSPR, sc->rec_page_stop);\n\n\t/* Set IRQ.  3c503 only allows a choice of irq 3-5 or 9. */\n\tswitch (ia->ia_irq) {\n\tcase 9:\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_IDCFR,\n\t\t    ED_3COM_IDCFR_IRQ2);\n\t\tbreak;\n\tcase 3:\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_IDCFR,\n\t\t    ED_3COM_IDCFR_IRQ3);\n\t\tbreak;\n\tcase 4:\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_IDCFR,\n\t\t    ED_3COM_IDCFR_IRQ4);\n\t\tbreak;\n\tcase 5:\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_IDCFR,\n\t\t    ED_3COM_IDCFR_IRQ5);\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: invalid irq configuration (%d) must be 3-5 or 9 for 3c503\\n\",\n\t\t    sc->sc_dev.dv_xname, ia->ia_irq);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Initialize GA configuration register.  Set bank and enable shared\n\t * mem.\n\t */\n\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_GACFR,\n\t    ED_3COM_GACFR_RSEL | ED_3COM_GACFR_MBS0);\n\n\t/*\n\t * Initialize \"Vector Pointer\" registers. These gawd-awful things are\n\t * compared to 20 bits of the address on ISA, and if they match, the\n\t * shared memory is disabled. We set them to 0xffff0...allegedly the\n\t * reset vector.\n\t */\n\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_VPTR2, 0xff);\n\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_VPTR1, 0xff);\n\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_VPTR0, 0x00);\n\n\t/* Now zero memory and verify that it is clear. */\n\tif (isa16bit) {\n\t\tfor (i = 0; i < memsize; i += 2)\n\t\t\tbus_space_write_2(memt, memh, sc->mem_start + i, 0);\n\t} else {\n\t\tfor (i = 0; i < memsize; ++i)\n\t\t\tbus_space_write_1(memt, memh, sc->mem_start + i, 0);\n\t}\n\n\tmemfail = 0;\n\tif (isa16bit) {\n\t\tfor (i = 0; i < memsize; i += 2) {\n\t\t\tif (bus_space_read_2(memt, memh, sc->mem_start + i)) {\n\t\t\t\tmemfail = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < memsize; ++i) {\n\t\t\tif (bus_space_read_1(memt, memh, sc->mem_start + i)) {\n\t\t\t\tmemfail = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (memfail) {\n\t\tprintf(\"%s: failed to clear shared memory at %x - \"\n\t\t    \"check configuration\\n\",\n\t\t    sc->sc_dev.dv_xname,\n\t\t    (ia->ia_maddr + sc->mem_start + i));\n\t\tgoto out;\n\t}\n\n\tia->ia_msize = memsize;\n\tia->ia_iosize = ED_3COM_IO_PORTS;\n\n\t/*\n\t * XXX Sould always unmap, but we can't yet.\n\t * XXX Need to squish \"indirect\" first.\n\t */\n\tsc->sc_iot = iot;\n\tsc->sc_memt = memt;\n\tsc->sc_ioh = ioh;\n\tsc->sc_memh = memh;\n\treturn 1;\n\n out:\n\tbus_space_unmap(memt, memh, memsize);\n err:\n\tbus_space_unmap(iot, ioh, ED_3COM_IO_PORTS);\n\treturn 0;\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/isa/if_edreg.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"ed.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define\tETHER_ADDR_LEN\t6"
    ],
    "globals_used": [
      "int ed_find_3Com",
      "void edinit",
      "int ed_3com_iobase[] =\n    {0x2e0, 0x2a0, 0x280, 0x250, 0x350, 0x330, 0x310, 0x300};",
      "int ed_3com_maddr[] = {\n    MADDRUNK, MADDRUNK, MADDRUNK, MADDRUNK, 0xc8000, 0xcc000, 0xd8000, 0xdc000\n};",
      "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "iot",
            "ioh",
            "ED_3COM_IO_PORTS"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "memt",
            "memh",
            "memsize"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: failed to clear shared memory at %x - \"\n\t\t    \"check configuration\\n\"",
            "sc->sc_dev.dv_xname",
            "(ia->ia_maddr + sc->mem_start + i)"
          ],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "memt",
            "memh",
            "sc->mem_start + i"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "memt",
            "memh",
            "sc->mem_start + i"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "memt",
            "memh",
            "sc->mem_start + i",
            "0"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "memt",
            "memh",
            "sc->mem_start + i",
            "0"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_3COM_VPTR0",
            "0x00"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_3COM_VPTR1",
            "0xff"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_3COM_VPTR2",
            "0xff"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_3COM_GACFR",
            "ED_3COM_GACFR_RSEL | ED_3COM_GACFR_MBS0"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_3COM_IDCFR",
            "ED_3COM_IDCFR_IRQ5"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_3COM_IDCFR",
            "ED_3COM_IDCFR_IRQ4"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_3COM_IDCFR",
            "ED_3COM_IDCFR_IRQ3"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_3COM_IDCFR",
            "ED_3COM_IDCFR_IRQ2"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_3COM_PSPR",
            "sc->rec_page_stop"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_3COM_PSTR",
            "sc->rec_page_start"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "memt",
            "ia->ia_maddr",
            "memsize",
            "0",
            "&memh"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P2_CR",
            "ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STP"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_GET",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P2_DCR"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_CR",
            "ED_CR_RD2 | ED_CR_PAGE_2 | ED_CR_STP"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_DCR",
            "0"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_CR",
            "ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STP"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_3COM_CR",
            "ED_3COM_CR_XSEL"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_GET",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "i"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_3COM_CR",
            "ED_3COM_CR_EALO | ED_3COM_CR_XSEL"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "5000"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_3COM_CR",
            "ED_3COM_CR_XSEL"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_3COM_CR",
            "ED_3COM_CR_RST | ED_3COM_CR_XSEL"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs",
          "args": [
            "x"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "ahc_validate_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/aic7xxx.c",
          "lines": "1227-1248",
          "snippet": "STATIC void\nahc_validate_offset(ahc, syncrate, offset, wide)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_syncrate *syncrate;\n\tu_int *offset;\n\tint wide;\n{\n\tu_int maxoffset;\n\n\t/* Limit offset to what we can do */\n\tif (syncrate == NULL) {\n\t\tmaxoffset = 0;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tmaxoffset = MAX_OFFSET_ULTRA2;\n\t} else {\n\t\tif (wide)\n\t\t\tmaxoffset = MAX_OFFSET_16BIT;\n\t\telse\n\t\t\tmaxoffset = MAX_OFFSET_8BIT;\n\t}\n\t*offset = MIN(*offset, maxoffset);\n}",
          "includes": [
            "#include <sys/kernel.h>",
            "#include \"pci.h\"",
            "#include <dev/microcode/aic7xxx/sequencer.h>",
            "#include <dev/microcode/aic7xxx/aic7xxx_seq.h>",
            "#include <dev/ic/aic7xxxvar.h>",
            "#include <dev/ic/aic7xxxreg.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define STATIC\tstatic",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int\tahcinitscbdata(struct ahc_softc *ahc);",
            "STATIC void\tahcfiniscbdata(struct ahc_softc *ahc);",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahcallocscbs __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC u_int",
            "STATIC void",
            "STATIC struct",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "ahc_clear_msg_state __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_loadseq __P((struct ahc_softc *ahc));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC u_int",
            "STATIC void",
            "ahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_clear_intstat __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_reset_current_bus __P((struct ahc_softc *ahc));",
            "STATIC struct",
            "STATIC struct",
            "STATIC u_int",
            "STATIC void",
            "ahc_validate_offset __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct ahc_syncrate *syncrate,\n\t\t\t\t\t u_int *offset, int wide));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "STATIC void",
            "ahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "ahc_update_pending_syncrates __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "restart_sequencer __P((struct ahc_softc *ahc));",
            "STATIC void",
            "ahc_run_qoutfifo __P((struct ahc_softc *ahc));",
            "STATIC void",
            "STATIC void",
            "STATIC void",
            "static __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;",
            "static __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "ahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;",
            "STATIC struct",
            "tmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;",
            "struct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/kernel.h>\n#include \"pci.h\"\n#include <dev/microcode/aic7xxx/sequencer.h>\n#include <dev/microcode/aic7xxx/aic7xxx_seq.h>\n#include <dev/ic/aic7xxxvar.h>\n#include <dev/ic/aic7xxxreg.h>\n#include <vm/pmap.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_all.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define STATIC\tstatic\n#define STATIC\n\nSTATIC int\tahcinitscbdata(struct ahc_softc *ahc);\nSTATIC void\tahcfiniscbdata(struct ahc_softc *ahc);\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahcallocscbs __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC u_int;\nSTATIC void;\nSTATIC struct;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nahc_clear_msg_state __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_loadseq __P((struct ahc_softc *ahc));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC u_int;\nSTATIC void;\nahc_add_curscb_to_free_list __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_clear_intstat __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_reset_current_bus __P((struct ahc_softc *ahc));\nSTATIC struct;\nSTATIC struct;\nSTATIC u_int;\nSTATIC void;\nahc_validate_offset __P((struct ahc_softc *ahc,\n\t\t\t\t\t struct ahc_syncrate *syncrate,\n\t\t\t\t\t u_int *offset, int wide));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC void;\nSTATIC int;\nSTATIC void;\nSTATIC void;\nahc_construct_sdtr __P((struct ahc_softc *ahc,\n\t\t\t\t   u_int period, u_int offset));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nahc_update_pending_syncrates __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nrestart_sequencer __P((struct ahc_softc *ahc));\nSTATIC void;\nahc_run_qoutfifo __P((struct ahc_softc *ahc));\nSTATIC void;\nSTATIC void;\nSTATIC void;\nstatic __inline struct ahc_initiator_tinfo *\nahc_fetch_transinfo(ahc, channel, our_id, remote_id, tstate)\n\tstruct ahc_softc *ahc;\nstatic __inline struct scb *\nahcgetscb(ahc)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_devlimited_syncrate(ahc, period)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\nahc_syncrate *\nahc_find_syncrate(ahc, period, maxsync)\n\tstruct ahc_softc *ahc;\nSTATIC struct;\ntmode_tstate *\nahc_alloc_tstate(ahc, scsi_id, channel)\n\tstruct ahc_softc *ahc;\nstruct scsi_xfer *\nahc_list_next(ahc, xs)\n\tstruct ahc_softc *ahc;\n\nSTATIC void\nahc_validate_offset(ahc, syncrate, offset, wide)\n\tstruct ahc_softc *ahc;\n\tstruct ahc_syncrate *syncrate;\n\tu_int *offset;\n\tint wide;\n{\n\tu_int maxoffset;\n\n\t/* Limit offset to what we can do */\n\tif (syncrate == NULL) {\n\t\tmaxoffset = 0;\n\t} else if ((ahc->features & AHC_ULTRA2) != 0) {\n\t\tmaxoffset = MAX_OFFSET_ULTRA2;\n\t} else {\n\t\tif (wide)\n\t\t\tmaxoffset = MAX_OFFSET_16BIT;\n\t\telse\n\t\t\tmaxoffset = MAX_OFFSET_8BIT;\n\t}\n\t*offset = MIN(*offset, maxoffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_3COM_IDCFR"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_3COM_PCFR"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_3COM_BCFR"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "iot",
            "ia->ia_iobase",
            "ED_3COM_IO_PORTS",
            "0",
            "&ioh"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\n#define\tETHER_ADDR_LEN\t6\n\nint ed_find_3Com;\nvoid edinit;\nint ed_3com_iobase[] =\n    {0x2e0, 0x2a0, 0x280, 0x250, 0x350, 0x330, 0x310, 0x300};\nint ed_3com_maddr[] = {\n    MADDRUNK, MADDRUNK, MADDRUNK, MADDRUNK, 0xc8000, 0xcc000, 0xd8000, 0xdc000\n};\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nint\ned_find_3Com(sc, cf, ia)\n\tstruct ed_softc *sc;\n\tstruct cfdata *cf;\n\tstruct isa_attach_args *ia;\n{\n\tbus_space_tag_t iot;\n\tbus_space_tag_t memt;\n\tbus_space_handle_t ioh;\n\tbus_space_handle_t memh;\n\tint i;\n\tu_int memsize, memfail;\n\tu_char isa16bit, x;\n\tint ptr, asicbase, nicbase;\n\n\t/*\n\t * Hmmm...a 16bit 3Com board has 16k of memory, but only an 8k window\n\t * to it.\n\t */\n\tmemsize = 8192;\n\n\tiot = ia->ia_iot;\n\tmemt = ia->ia_memt;\n\n\tif (bus_space_map(iot, ia->ia_iobase, ED_3COM_IO_PORTS, 0, &ioh))\n\t\treturn (0);\n\n\tsc->asic_base = asicbase = ED_3COM_ASIC_OFFSET;\n\tsc->nic_base = nicbase = ED_3COM_NIC_OFFSET;\n\n\t/*\n\t * Verify that the kernel configured I/O address matches the board\n\t * configured address.\n\t *\n\t * This is really only useful to see if something that looks like the\n\t * board is there; after all, we are already talking it at that\n\t * address.\n\t */\n\tx = bus_space_read_1(iot, ioh, asicbase + ED_3COM_BCFR);\n\tif (x == 0 || (x & (x - 1)) != 0)\n\t\tgoto err;\n\tptr = ffs(x) - 1;\n\tif (ia->ia_iobase != IOBASEUNK) {\n\t\tif (ia->ia_iobase != ed_3com_iobase[ptr]) {\n\t\t\tprintf(\"%s: %s mismatch; kernel configured %x != board configured %x\\n\",\n\t\t\t    \"iobase\", sc->sc_dev.dv_xname, ia->ia_iobase,\n\t\t\t    ed_3com_iobase[ptr]);\n\t\t\tgoto err;\n\t\t}\n\t} else\n\t\tia->ia_iobase = ed_3com_iobase[ptr];\t/* XXX --thorpej */\n\n\tx = bus_space_read_1(iot, ioh, asicbase + ED_3COM_PCFR);\n\tif (x == 0 || (x & (x - 1)) != 0) {\n\t\tprintf(\"%s: The 3c503 is not currently supported with memory \"\n\t\t       \"mapping disabled.\\n%s: Reconfigure the card to \"\n\t\t       \"enable memory mapping.\\n\",\n\t\t       sc->sc_dev.dv_xname, sc->sc_dev.dv_xname);\n\t\tgoto err;\n\t}\n\tptr = ffs(x) - 1;\n\tif (ia->ia_maddr != MADDRUNK) {\n\t\tif (ia->ia_maddr != ed_3com_maddr[ptr]) {\n\t\t\tprintf(\"%s: %s mismatch; kernel configured %x != board configured %x\\n\",\n\t\t\t    \"maddr\", sc->sc_dev.dv_xname, ia->ia_maddr,\n\t\t\t    ed_3com_maddr[ptr]);\n\t\t\tgoto err;\n\t\t}\n\t} else\n\t\tia->ia_maddr = ed_3com_maddr[ptr];\n\n#if 0\n\tx = bus_space_read_1(iot, ioh, asicbase + ED_3COM_IDCFR) &\n\t    ED_3COM_IDCFR_IRQ;\n\tif (x == 0 || (x & (x - 1)) != 0)\n\t\tgoto out;\n\tptr = ffs(x) - 1;\n\tif (ia->ia_irq != IRQUNK) {\n\t\tif (ia->ia_irq != ed_3com_irq[ptr]) {\n\t\t\tprintf(\"%s: irq mismatch; kernel configured %d != board configured %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, ia->ia_irq,\n\t\t\t    ed_3com_irq[ptr]);\n\t\t\tgoto err;\n\t\t}\n\t} else\n\t\tia->ia_irq = ed_3com_irq[ptr];\n#endif\n\n\t/*\n\t * Reset NIC and ASIC.  Enable on-board transceiver throughout reset\n\t * sequence because it'll lock up if the cable isn't connected if we\n\t * don't.\n\t */\n\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_CR,\n\t    ED_3COM_CR_RST | ED_3COM_CR_XSEL);\n\n\t/* Wait for a while, then un-reset it. */\n\tdelay(50);\n\n\t/*\n\t * The 3Com ASIC defaults to rather strange settings for the CR after a\n\t * reset - it's important to set it again after the following outb\n\t * (this is done when we map the PROM below).\n\t */\n\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_CR, ED_3COM_CR_XSEL);\n\n\t/* Wait a bit for the NIC to recover from the reset. */\n\tdelay(5000);\n\n\tsc->vendor = ED_VENDOR_3COM;\n\tsc->type_str = \"3c503\";\n\tsc->mem_shared = 1;\n\tsc->cr_proto = ED_CR_RD2;\n\n\t/*\n\t * Get station address from on-board ROM.\n\t *\n\t * First, map ethernet address PROM over the top of where the NIC\n\t * registers normally appear.\n\t */\n\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_CR,\n\t    ED_3COM_CR_EALO | ED_3COM_CR_XSEL);\n\n\tfor (i = 0; i < ETHER_ADDR_LEN; ++i)\n\t\tsc->sc_arpcom.ac_enaddr[i] = NIC_GET(iot, ioh, nicbase, i);\n\n\t/*\n\t * Unmap PROM - select NIC registers.  The proper setting of the\n\t * tranceiver is set in edinit so that the attach code is given a\n\t * chance to set the default based on a compile-time config option.\n\t */\n\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_CR, ED_3COM_CR_XSEL);\n\n\t/* Determine if this is an 8bit or 16bit board. */\n\n\t/* Select page 0 registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STP);\n\n\t/*\n\t * Attempt to clear WTS bit.  If it doesn't clear, then this is a\n\t * 16-bit board.\n\t */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_DCR, 0);\n\n\t/* Select page 2 registers. */\n\tNIC_PUT(iot, ioh, nicbase,\n\t    ED_P0_CR, ED_CR_RD2 | ED_CR_PAGE_2 | ED_CR_STP);\n\n\t/* The 3c503 forces the WTS bit to a one if this is a 16bit board. */\n\tif (NIC_GET(iot, ioh, nicbase, ED_P2_DCR) & ED_DCR_WTS)\n\t\tisa16bit = 1;\n\telse\n\t\tisa16bit = 0;\n\n\t/* Select page 0 registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P2_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STP);\n\n\tif (bus_space_map(memt, ia->ia_maddr, memsize, 0, &memh))\n\t\tgoto err;\n\tsc->mem_start = 0;\t\t/* offset */\n\tsc->mem_size = memsize;\n\tsc->mem_end = sc->mem_start + memsize;\n\n\t/*\n\t * We have an entire 8k window to put the transmit buffers on the\n\t * 16-bit boards.  But since the 16bit 3c503's shared memory is only\n\t * fast enough to overlap the loading of one full-size packet, trying\n\t * to load more than 2 buffers can actually leave the transmitter idle\n\t * during the load.  So 2 seems the best value.  (Although a mix of\n\t * variable-sized packets might change this assumption.  Nonetheless,\n\t * we optimize for linear transfers of same-size packets.)\n\t */\n\tif (isa16bit) {\n \t\tif (cf->cf_flags & ED_FLAGS_NO_MULTI_BUFFERING)\n\t\t\tsc->txb_cnt = 1;\n\t\telse\n\t\t\tsc->txb_cnt = 2;\n\n\t\tsc->tx_page_start = ED_3COM_TX_PAGE_OFFSET_16BIT;\n\t\tsc->rec_page_start = ED_3COM_RX_PAGE_OFFSET_16BIT;\n\t\tsc->rec_page_stop =\n\t\t    (memsize >> ED_PAGE_SHIFT) + ED_3COM_RX_PAGE_OFFSET_16BIT;\n\t\tsc->mem_ring = sc->mem_start;\n\t} else {\n\t\tsc->txb_cnt = 1;\n\t\tsc->tx_page_start = ED_3COM_TX_PAGE_OFFSET_8BIT;\n\t\tsc->rec_page_start =\n\t\t    ED_TXBUF_SIZE + ED_3COM_TX_PAGE_OFFSET_8BIT;\n\t\tsc->rec_page_stop =\n\t\t    (memsize >> ED_PAGE_SHIFT) + ED_3COM_TX_PAGE_OFFSET_8BIT;\n\t\tsc->mem_ring =\n\t\t    sc->mem_start + (ED_TXBUF_SIZE << ED_PAGE_SHIFT);\n\t}\n\n\tsc->isa16bit = isa16bit;\n\n\t/*\n\t * Initialize GA page start/stop registers.  Probably only needed if\n\t * doing DMA, but what the Hell.\n\t */\n\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_PSTR, sc->rec_page_start);\n\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_PSPR, sc->rec_page_stop);\n\n\t/* Set IRQ.  3c503 only allows a choice of irq 3-5 or 9. */\n\tswitch (ia->ia_irq) {\n\tcase 9:\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_IDCFR,\n\t\t    ED_3COM_IDCFR_IRQ2);\n\t\tbreak;\n\tcase 3:\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_IDCFR,\n\t\t    ED_3COM_IDCFR_IRQ3);\n\t\tbreak;\n\tcase 4:\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_IDCFR,\n\t\t    ED_3COM_IDCFR_IRQ4);\n\t\tbreak;\n\tcase 5:\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_IDCFR,\n\t\t    ED_3COM_IDCFR_IRQ5);\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: invalid irq configuration (%d) must be 3-5 or 9 for 3c503\\n\",\n\t\t    sc->sc_dev.dv_xname, ia->ia_irq);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Initialize GA configuration register.  Set bank and enable shared\n\t * mem.\n\t */\n\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_GACFR,\n\t    ED_3COM_GACFR_RSEL | ED_3COM_GACFR_MBS0);\n\n\t/*\n\t * Initialize \"Vector Pointer\" registers. These gawd-awful things are\n\t * compared to 20 bits of the address on ISA, and if they match, the\n\t * shared memory is disabled. We set them to 0xffff0...allegedly the\n\t * reset vector.\n\t */\n\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_VPTR2, 0xff);\n\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_VPTR1, 0xff);\n\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_VPTR0, 0x00);\n\n\t/* Now zero memory and verify that it is clear. */\n\tif (isa16bit) {\n\t\tfor (i = 0; i < memsize; i += 2)\n\t\t\tbus_space_write_2(memt, memh, sc->mem_start + i, 0);\n\t} else {\n\t\tfor (i = 0; i < memsize; ++i)\n\t\t\tbus_space_write_1(memt, memh, sc->mem_start + i, 0);\n\t}\n\n\tmemfail = 0;\n\tif (isa16bit) {\n\t\tfor (i = 0; i < memsize; i += 2) {\n\t\t\tif (bus_space_read_2(memt, memh, sc->mem_start + i)) {\n\t\t\t\tmemfail = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < memsize; ++i) {\n\t\t\tif (bus_space_read_1(memt, memh, sc->mem_start + i)) {\n\t\t\t\tmemfail = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (memfail) {\n\t\tprintf(\"%s: failed to clear shared memory at %x - \"\n\t\t    \"check configuration\\n\",\n\t\t    sc->sc_dev.dv_xname,\n\t\t    (ia->ia_maddr + sc->mem_start + i));\n\t\tgoto out;\n\t}\n\n\tia->ia_msize = memsize;\n\tia->ia_iosize = ED_3COM_IO_PORTS;\n\n\t/*\n\t * XXX Sould always unmap, but we can't yet.\n\t * XXX Need to squish \"indirect\" first.\n\t */\n\tsc->sc_iot = iot;\n\tsc->sc_memt = memt;\n\tsc->sc_ioh = ioh;\n\tsc->sc_memh = memh;\n\treturn 1;\n\n out:\n\tbus_space_unmap(memt, memh, memsize);\n err:\n\tbus_space_unmap(iot, ioh, ED_3COM_IO_PORTS);\n\treturn 0;\n}"
  },
  {
    "function_name": "ed_find_WD80x3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
    "lines": "626-1070",
    "snippet": "int\ned_find_WD80x3(sc, cf, ia)\n\tstruct ed_softc *sc;\n\tstruct cfdata *cf;\n\tstruct isa_attach_args *ia;\n{\n\tbus_space_tag_t iot;\n\tbus_space_tag_t memt;\n\tbus_space_handle_t ioh;\n\tbus_space_handle_t delaybah = ia->ia_delaybah;\n\tbus_space_handle_t memh;\n\tu_int memsize;\n\tu_char iptr, isa16bit, sum, wd790rev;\n\tint i, rv, memfail, mapped_mem = 0;\n\tint asicbase, nicbase;\n\n\tiot = ia->ia_iot;\n\tmemt = ia->ia_memt;\n\trv = 0;\n\n\t/* Set initial values for width/size. */\n\tmemsize = 8192;\n\tisa16bit = 0;\n\n\tif (bus_space_map(iot, ia->ia_iobase, ED_WD_IO_PORTS, 0, &ioh))\n\t\treturn (0);\n\n\tsc->asic_base = asicbase = 0;\n\tsc->nic_base = nicbase = asicbase + ED_WD_NIC_OFFSET;\n\tsc->is790 = 0;\n\n#ifdef TOSH_ETHER\n\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR, ED_WD_MSR_POW);\n\tdelay(10000);\n#endif\n\n\t/*\n\t * Attempt to do a checksum over the station address PROM.  If it\n\t * fails, it's probably not a SMC/WD board.  There is a problem with\n\t * this, though: some clone WD boards don't pass the checksum test.\n\t * Danpex boards for one.\n\t */\n\tfor (sum = 0, i = 0; i < 8; ++i)\n\t\tsum += bus_space_read_1(iot, ioh, asicbase + ED_WD_PROM + i);\n\n\tif (sum != ED_WD_ROM_CHECKSUM_TOTAL) {\n\t\t/*\n\t\t * Checksum is invalid.  This often happens with cheap WD8003E\n\t\t * clones.  In this case, the checksum byte (the eighth byte)\n\t\t * seems to always be zero.\n\t\t */\n\t\tif (bus_space_read_1(iot, ioh, asicbase + ED_WD_CARD_ID) !=\n\t\t    ED_TYPE_WD8003E ||\n\t\t    bus_space_read_1(iot, ioh, asicbase + ED_WD_PROM + 7) != 0)\n\t\t\tgoto out;\n\t}\n\n\t/* Reset card to force it into a known state. */\n#ifdef TOSH_ETHER\n\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR,\n\t    ED_WD_MSR_RST | ED_WD_MSR_POW);\n#else\n\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR, ED_WD_MSR_RST);\n#endif\n\tdelay(100);\n\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR,\n\t    bus_space_read_1(iot, ioh, asicbase + ED_WD_MSR) & ~ED_WD_MSR_RST);\n\t/* Wait in the case this card is reading it's EEROM. */\n\tdelay(5000);\n\n\tsc->vendor = ED_VENDOR_WD_SMC;\n\tsc->type = bus_space_read_1(iot, ioh, asicbase + ED_WD_CARD_ID);\n\n\tswitch (sc->type) {\n\tcase ED_TYPE_WD8003S:\n\t\tsc->type_str = \"WD8003S\";\n\t\tbreak;\n\tcase ED_TYPE_WD8003E:\n\t\tsc->type_str = \"WD8003E\";\n\t\tbreak;\n\tcase ED_TYPE_WD8003EB:\n\t\tsc->type_str = \"WD8003EB\";\n\t\tbreak;\n\tcase ED_TYPE_WD8003W:\n\t\tsc->type_str = \"WD8003W\";\n\t\tbreak;\n\tcase ED_TYPE_WD8013EBT:\n\t\tsc->type_str = \"WD8013EBT\";\n\t\tmemsize = 16384;\n\t\tisa16bit = 1;\n\t\tbreak;\n\tcase ED_TYPE_WD8013W:\n\t\tsc->type_str = \"WD8013W\";\n\t\tmemsize = 16384;\n\t\tisa16bit = 1;\n\t\tbreak;\n\tcase ED_TYPE_WD8013EP:\t\t/* also WD8003EP */\n\t\tif (bus_space_read_1(iot, ioh, asicbase + ED_WD_ICR)\n\t\t    & ED_WD_ICR_16BIT) {\n\t\t\tisa16bit = 1;\n\t\t\tmemsize = 16384;\n\t\t\tsc->type_str = \"WD8013EP\";\n\t\t} else\n\t\t\tsc->type_str = \"WD8003EP\";\n\t\tbreak;\n\tcase ED_TYPE_WD8013WC:\n\t\tsc->type_str = \"WD8013WC\";\n\t\tmemsize = 16384;\n\t\tisa16bit = 1;\n\t\tbreak;\n\tcase ED_TYPE_WD8013EBP:\n\t\tsc->type_str = \"WD8013EBP\";\n\t\tmemsize = 16384;\n\t\tisa16bit = 1;\n\t\tbreak;\n\tcase ED_TYPE_WD8013EPC:\n\t\tsc->type_str = \"WD8013EPC\";\n\t\tmemsize = 16384;\n\t\tisa16bit = 1;\n\t\tbreak;\n\tcase ED_TYPE_SMC8216C:\n\tcase ED_TYPE_SMC8216T:\n\t\twd790rev = bus_space_read_1(iot, ioh, asicbase + ED_WD790_REV);\n\t\tif (wd790rev < ED_WD795)\n\t\t\tsc->type_str = (sc->type == ED_TYPE_SMC8216C) ?\n\t\t\t    \"SMC8216/SMC8216C\" : \"SMC8216T\";\n\t\telse {\n\t\t\tsc->type_str = \"SMC8416C/SMC8416BT\";\n\t\t\tif (bus_space_read_1(iot, ioh,\n\t\t\t\t\t     asicbase + ED_WD795_PIO)) {\n\t\t\t\tprintf (\"%s: detected SMC8416 in PIO mode, unsupported hardware configuration.\\n\", sc->sc_dev.dv_xname);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD790_HWR,\n\t\t    bus_space_read_1(iot, ioh, asicbase + ED_WD790_HWR)\n\t\t    | ED_WD790_HWR_SWH);\n\t\tswitch (bus_space_read_1(iot, ioh, asicbase + ED_WD790_RAR) &\n\t\t    ED_WD790_RAR_SZ64) {\n\t\tcase ED_WD790_RAR_SZ64:\n\t\t\tmemsize = 65536;\n\t\t\tbreak;\n\t\tcase ED_WD790_RAR_SZ32:\n\t\t\tmemsize = 32768;\n\t\t\tbreak;\n\t\tcase ED_WD790_RAR_SZ16:\n\t\t\tmemsize = 16384;\n\t\t\tbreak;\n\t\tcase ED_WD790_RAR_SZ8:\n\t\t\tmemsize = 8192;\n\t\t\tbreak;\n\t\t}\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD790_HWR,\n\t\t    bus_space_read_1(iot, ioh, asicbase + ED_WD790_HWR) &\n\t\t    ~ED_WD790_HWR_SWH);\n\n\t\tisa16bit = 1;\n\t\tsc->is790 = 1;\n\t\tbreak;\n#ifdef TOSH_ETHER\n\tcase ED_TYPE_TOSHIBA1:\n\t\tsc->type_str = \"Toshiba1\";\n\t\tmemsize = 32768;\n\t\tisa16bit = 1;\n\t\tbreak;\n\tcase ED_TYPE_TOSHIBA4:\n\t\tsc->type_str = \"Toshiba4\";\n\t\tmemsize = 32768;\n\t\tisa16bit = 1;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tsc->type_str = NULL;\n\t\tbreak;\n\t}\n\t/*\n\t * Make some adjustments to initial values depending on what is found\n\t * in the ICR.\n\t */\n\tif (isa16bit && (sc->type != ED_TYPE_WD8013EBT) &&\n#ifdef TOSH_ETHER\n\t    (sc->type != ED_TYPE_TOSHIBA1) && (sc->type != ED_TYPE_TOSHIBA4) &&\n#endif\n\t    ((bus_space_read_1(iot, ioh, asicbase + ED_WD_ICR) &\n\t    ED_WD_ICR_16BIT) == 0)) {\n\t\tisa16bit = 0;\n\t\tmemsize = 8192;\n\t}\n\n#ifdef ED_DEBUG\n\tprintf(\"type=%x type_str=%s isa16bit=%d memsize=%d id_msize=%d\\n\",\n\t    sc->type, sc->type_str ?: \"unknown\", isa16bit, memsize,\n\t    ia->ia_msize);\n\tfor (i = 0; i < 8; i++)\n\t\tprintf(\"%x -> %x\\n\", i, bus_space_read_1(iot, ioh,\n\t\t    asicbase + i));\n#endif\n\t/* Allow the user to override the autoconfiguration. */\n\tif (ia->ia_msize)\n\t\tmemsize = ia->ia_msize;\n\t/*\n\t * (Note that if the user specifies both of the following flags that\n\t * '8-bit' mode intentionally has precedence.)\n\t */\n\tif (cf->cf_flags & ED_FLAGS_FORCE_16BIT_MODE)\n\t\tisa16bit = 1;\n\tif (cf->cf_flags & ED_FLAGS_FORCE_8BIT_MODE)\n\t\tisa16bit = 0;\n\n\t/*\n\t * If possible, get the assigned interrupt number from the card and\n\t * use it.\n\t */\n\tif (sc->is790) {\n\t\tu_char x;\n\n\t\t/* Assemble together the encoded interrupt number. */\n\t\tbus_space_write_1(iot, ioh, ED_WD790_HWR,\n\t\t    bus_space_read_1(iot, ioh, ED_WD790_HWR) |\n\t\t    ED_WD790_HWR_SWH);\n\t\tx = bus_space_read_1(iot, ioh, ED_WD790_GCR);\n\t\tiptr = ((x & ED_WD790_GCR_IR2) >> 4) |\n\t\t    ((x & (ED_WD790_GCR_IR1|ED_WD790_GCR_IR0)) >> 2);\n\t\tbus_space_write_1(iot, ioh, ED_WD790_HWR,\n\t\t    bus_space_read_1(iot, ioh, ED_WD790_HWR) &\n\t\t    ~ED_WD790_HWR_SWH);\n\t\t/*\n\t\t * Translate it using translation table, and check for\n\t\t * correctness.\n\t\t */\n\t\tif (ia->ia_irq != IRQUNK) {\n\t\t\tif (ia->ia_irq != ed_wd790_irq[iptr]) {\n\t\t\t\tprintf(\"%s: irq mismatch; kernel configured %d != board configured %d\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, ia->ia_irq,\n\t\t\t\t    ed_wd790_irq[iptr]);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else\n\t\t\tia->ia_irq = ed_wd790_irq[iptr];\n\t\t/* Enable the interrupt. */\n\t\tbus_space_write_1(iot, ioh, ED_WD790_ICR,\n\t\t    bus_space_read_1(iot, ioh, ED_WD790_ICR) |\n\t\t    ED_WD790_ICR_EIL);\n\t} else if (sc->type & ED_WD_SOFTCONFIG) {\n\t\t/* Assemble together the encoded interrupt number. */\n\t\tiptr = (bus_space_read_1(iot, ioh, ED_WD_ICR) &\n\t\t    ED_WD_ICR_IR2) |\n\t\t    ((bus_space_read_1(iot, ioh, ED_WD_IRR) &\n\t\t      (ED_WD_IRR_IR0 | ED_WD_IRR_IR1)) >> 5);\n\t\t/*\n\t\t * Translate it using translation table, and check for\n\t\t * correctness.\n\t\t */\n\t\tif (ia->ia_irq != IRQUNK) {\n\t\t\tif (ia->ia_irq != ed_wd584_irq[iptr]) {\n\t\t\t\tprintf(\"%s: irq mismatch; kernel configured %d != board configured %d\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, ia->ia_irq,\n\t\t\t\t    ed_wd584_irq[iptr]);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else\n\t\t\tia->ia_irq = ed_wd584_irq[iptr];\n\t\t/* Enable the interrupt. */\n\t\tbus_space_write_1(iot, ioh, ED_WD_IRR,\n\t\t    bus_space_read_1(iot, ioh, ED_WD_IRR) | ED_WD_IRR_IEN);\n\t} else {\n\t\tif (ia->ia_irq == IRQUNK) {\n\t\t\tprintf(\"%s: %s does not have soft configuration\\n\",\n\t\t\t    sc->sc_dev.dv_xname, sc->type_str);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* XXX Figure out the shared memory address. */\n\n\tif (ia->ia_maddr == MADDRUNK)\n\t\tgoto out;\n\tsc->isa16bit = isa16bit;\n\tsc->mem_shared = 1;\n\tia->ia_msize = memsize;\n\tif (bus_space_map(memt, ia->ia_maddr, memsize, 0, &memh))\n\t\tgoto out;\n\tmapped_mem = 1;\n\tsc->mem_start = 0;\t/* offset */\n\n\t/* Allocate one xmit buffer if < 16k, two buffers otherwise. */\n\tif ((memsize < 16384) || (cf->cf_flags & ED_FLAGS_NO_MULTI_BUFFERING))\n\t\tsc->txb_cnt = 1;\n\telse\n\t\tsc->txb_cnt = 2;\n\n\tsc->tx_page_start = ED_WD_PAGE_OFFSET;\n\tsc->rec_page_start = sc->tx_page_start + sc->txb_cnt * ED_TXBUF_SIZE;\n\tsc->rec_page_stop = sc->tx_page_start + (memsize >> ED_PAGE_SHIFT);\n\tsc->mem_ring = sc->mem_start + (sc->rec_page_start << ED_PAGE_SHIFT);\n\tsc->mem_size = memsize;\n\tsc->mem_end = sc->mem_start + memsize;\n\n\t/* Get station address from on-board ROM. */\n\tfor (i = 0; i < ETHER_ADDR_LEN; ++i)\n\t\tsc->sc_arpcom.ac_enaddr[i] =\n\t\t    bus_space_read_1(iot, ioh, asicbase + ED_WD_PROM + i);\n\n\t/*\n\t * Set upper address bits and 8/16 bit access to shared memory.\n\t */\n\tif (isa16bit) {\n\t\tif (sc->is790) {\n\t\t\tsc->wd_laar_proto =\n\t\t\t    bus_space_read_1(iot, ioh, asicbase + ED_WD_LAAR) &\n\t\t\t    ~ED_WD_LAAR_M16EN;\n\t\t} else {\n\t\t\tsc->wd_laar_proto = ED_WD_LAAR_L16EN |\n\t\t\t    ((ia->ia_maddr >> 19) & ED_WD_LAAR_ADDRHI);\n\t\t}\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_LAAR,\n\t\t    sc->wd_laar_proto | ED_WD_LAAR_M16EN);\n\t} else  {\n\t\tif ((sc->type & ED_WD_SOFTCONFIG) ||\n#ifdef TOSH_ETHER\n\t\t    (sc->type == ED_TYPE_TOSHIBA1) ||\n\t\t    (sc->type == ED_TYPE_TOSHIBA4) ||\n#endif\n\t\t    ((sc->type == ED_TYPE_WD8013EBT) && !sc->is790)) {\n\t\t\tsc->wd_laar_proto =\n\t\t\t    ((ia->ia_maddr >> 19) &\n\t\t\t    ED_WD_LAAR_ADDRHI);\n\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_LAAR,\n\t\t\t    sc->wd_laar_proto);\n\t\t}\n\t}\n\n\t/*\n\t * Set address and enable interface shared memory.\n\t */\n\tif (!sc->is790) {\n#ifdef TOSH_ETHER\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR + 1,\n\t\t    ((ia->ia_maddr >> 8) & 0xe0) | 4);\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR + 2,\n\t\t    ((ia->ia_maddr >> 16) & 0x0f));\n\t\tsc->wd_msr_proto = ED_WD_MSR_POW;\n#else\n\t\tsc->wd_msr_proto =\n\t\t    (ia->ia_maddr >> 13) & ED_WD_MSR_ADDR;\n#endif\n\t\tsc->cr_proto = ED_CR_RD2;\n\t} else {\n\t\tbus_space_write_1(iot, ioh, asicbase + 0x04,\n\t\t    bus_space_read_1(iot, ioh, asicbase + 0x04) | 0x80);\n\t\tbus_space_write_1(iot, ioh, asicbase + 0x0b,\n\t\t    ((ia->ia_maddr >> 13) & 0x0f) |\n\t\t    ((ia->ia_maddr >> 11) & 0x40) |\n\t\t    (bus_space_read_1(iot, ioh, asicbase + 0x0b) & 0xb0));\n\t\tbus_space_write_1(iot, ioh, asicbase + 0x04,\n\t\t    bus_space_read_1(iot, ioh, asicbase + 0x04) & ~0x80);\n\t\tsc->wd_msr_proto = 0x00;\n\t\tsc->cr_proto = 0;\n\t}\n\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR,\n\t    sc->wd_msr_proto | ED_WD_MSR_MENB);\n\n\t(void) bus_space_read_1(iot, delaybah, 0);\n\t(void) bus_space_read_1(iot, delaybah, 0);\n\n\t/* Now zero memory and verify that it is clear. */\n\tif (isa16bit) {\n\t\tfor (i = 0; i < memsize; i += 2)\n\t\t\tbus_space_write_2(memt, memh, sc->mem_start + i, 0);\n\t} else {\n\t\tfor (i = 0; i < memsize; ++i)\n\t\t\tbus_space_write_1(memt, memh, sc->mem_start + i, 0);\n\t}\n\n\tmemfail = 0;\n\tif (isa16bit) {\n\t\tfor (i = 0; i < memsize; i += 2) {\n\t\t\tif (bus_space_read_2(memt, memh, sc->mem_start + i)) {\n\t\t\t\tmemfail = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < memsize; ++i) {\n\t\t\tif (bus_space_read_1(memt, memh, sc->mem_start + i)) {\n\t\t\t\tmemfail = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (memfail) {\n\t\tprintf(\"%s: failed to clear shared memory at %x - \"\n\t\t    \"check configuration\\n\",\n\t\t    sc->sc_dev.dv_xname,\n\t\t    (ia->ia_maddr + sc->mem_start + i));\n\n\t\t/* Disable 16 bit access to shared memory. */\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR,\n\t\t    sc->wd_msr_proto);\n\t\tif (isa16bit)\n\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_LAAR,\n\t\t\t    sc->wd_laar_proto);\n\t\t(void) bus_space_read_1(iot, delaybah, 0);\n\t\t(void) bus_space_read_1(iot, delaybah, 0);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Disable 16bit access to shared memory - we leave it disabled\n\t * so that 1) machines reboot properly when the board is set 16\n\t * 16 bit mode and there are conflicting 8bit devices/ROMS in\n\t * the same 128k address space as this boards shared memory,\n\t * and 2) so that other 8 bit devices with shared memory can be\n\t * used in this 128k region, too.\n\t */\n\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR, sc->wd_msr_proto);\n\tif (isa16bit)\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_LAAR,\n\t\t    sc->wd_laar_proto);\n\t(void) bus_space_read_1(iot, delaybah, 0);\n\t(void) bus_space_read_1(iot, delaybah, 0);\n\n\tia->ia_iosize = ED_WD_IO_PORTS;\n\trv = 1;\n\n out:\n\t/*\n\t * XXX Should always unmap, but we can't yet.\n\t * XXX Need to squish \"indirect\" first.\n\t */\n\tif (rv == 0) {\n\t\tbus_space_unmap(iot, ioh, ED_WD_IO_PORTS);\n\t\tif (mapped_mem)\n\t\t\tbus_space_unmap(memt, memh, memsize);\n\t} else {\n\t\t/* XXX this is all \"indirect\" brokenness */\n\t\tsc->sc_iot = iot;\n\t\tsc->sc_memt = memt;\n\t\tsc->sc_ioh = ioh;\n\t\tsc->sc_memh = memh;\n\t}\n\treturn (rv);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/isa/if_edreg.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"ed.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define\tETHER_ADDR_LEN\t6"
    ],
    "globals_used": [
      "int ed_find_WD80x3",
      "int ed_wd584_irq[] = { 9, 3, 5, 7, 10, 11, 15, 4 };",
      "int ed_wd790_irq[] = { IRQUNK, 9, 3, 5, 7, 10, 11, 15 };",
      "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "memt",
            "memh",
            "memsize"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "iot",
            "ioh",
            "ED_WD_IO_PORTS"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "delaybah",
            "0"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "delaybah",
            "0"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_WD_LAAR",
            "sc->wd_laar_proto"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_WD_MSR",
            "sc->wd_msr_proto"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "delaybah",
            "0"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "delaybah",
            "0"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_WD_LAAR",
            "sc->wd_laar_proto"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_WD_MSR",
            "sc->wd_msr_proto"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: failed to clear shared memory at %x - \"\n\t\t    \"check configuration\\n\"",
            "sc->sc_dev.dv_xname",
            "(ia->ia_maddr + sc->mem_start + i)"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "memt",
            "memh",
            "sc->mem_start + i"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "memt",
            "memh",
            "sc->mem_start + i"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "memt",
            "memh",
            "sc->mem_start + i",
            "0"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "memt",
            "memh",
            "sc->mem_start + i",
            "0"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "delaybah",
            "0"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "delaybah",
            "0"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_WD_MSR",
            "sc->wd_msr_proto | ED_WD_MSR_MENB"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + 0x04",
            "bus_space_read_1(iot, ioh, asicbase + 0x04) & ~0x80"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + 0x04"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + 0x0b",
            "((ia->ia_maddr >> 13) & 0x0f) |\n\t\t    ((ia->ia_maddr >> 11) & 0x40) |\n\t\t    (bus_space_read_1(iot, ioh, asicbase + 0x0b) & 0xb0)"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + 0x0b"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + 0x04",
            "bus_space_read_1(iot, ioh, asicbase + 0x04) | 0x80"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + 0x04"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_WD_MSR + 2",
            "((ia->ia_maddr >> 16) & 0x0f)"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_WD_MSR + 1",
            "((ia->ia_maddr >> 8) & 0xe0) | 4"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_WD_LAAR",
            "sc->wd_laar_proto"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TOSH_ETHER",
          "args": [
            "sc->type == ED_TYPE_TOSHIBA1"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_WD_LAAR",
            "sc->wd_laar_proto | ED_WD_LAAR_M16EN"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_WD_LAAR"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_WD_PROM + i"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "memt",
            "ia->ia_maddr",
            "memsize",
            "0",
            "&memh"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "ED_WD_IRR",
            "bus_space_read_1(iot, ioh, ED_WD_IRR) | ED_WD_IRR_IEN"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "ED_WD_IRR"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "ED_WD_IRR"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "ED_WD_ICR"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "ED_WD790_ICR",
            "bus_space_read_1(iot, ioh, ED_WD790_ICR) |\n\t\t    ED_WD790_ICR_EIL"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "ED_WD790_ICR"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "ED_WD790_HWR",
            "bus_space_read_1(iot, ioh, ED_WD790_HWR) &\n\t\t    ~ED_WD790_HWR_SWH"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "ED_WD790_HWR"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "ED_WD790_GCR"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "ED_WD790_HWR",
            "bus_space_read_1(iot, ioh, ED_WD790_HWR) |\n\t\t    ED_WD790_HWR_SWH"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "ED_WD790_HWR"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + i"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_WD_ICR"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TOSH_ETHER",
          "args": [
            "sc->type != ED_TYPE_TOSHIBA1"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_WD790_HWR",
            "bus_space_read_1(iot, ioh, asicbase + ED_WD790_HWR) &\n\t\t    ~ED_WD790_HWR_SWH"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_WD790_HWR"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_WD790_RAR"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_WD790_HWR",
            "bus_space_read_1(iot, ioh, asicbase + ED_WD790_HWR)\n\t\t    | ED_WD790_HWR_SWH"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_WD790_HWR"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_WD795_PIO"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_WD790_REV"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_WD_ICR"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_WD_CARD_ID"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "5000"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_WD_MSR",
            "bus_space_read_1(iot, ioh, asicbase + ED_WD_MSR) & ~ED_WD_MSR_RST"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_WD_MSR"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_WD_MSR",
            "ED_WD_MSR_RST"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_WD_MSR",
            "ED_WD_MSR_RST | ED_WD_MSR_POW"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_WD_PROM + 7"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_WD_CARD_ID"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_WD_PROM + i"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_WD_MSR",
            "ED_WD_MSR_POW"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "iot",
            "ia->ia_iobase",
            "ED_WD_IO_PORTS",
            "0",
            "&ioh"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\n#define\tETHER_ADDR_LEN\t6\n\nint ed_find_WD80x3;\nint ed_wd584_irq[] = { 9, 3, 5, 7, 10, 11, 15, 4 };\nint ed_wd790_irq[] = { IRQUNK, 9, 3, 5, 7, 10, 11, 15 };\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nint\ned_find_WD80x3(sc, cf, ia)\n\tstruct ed_softc *sc;\n\tstruct cfdata *cf;\n\tstruct isa_attach_args *ia;\n{\n\tbus_space_tag_t iot;\n\tbus_space_tag_t memt;\n\tbus_space_handle_t ioh;\n\tbus_space_handle_t delaybah = ia->ia_delaybah;\n\tbus_space_handle_t memh;\n\tu_int memsize;\n\tu_char iptr, isa16bit, sum, wd790rev;\n\tint i, rv, memfail, mapped_mem = 0;\n\tint asicbase, nicbase;\n\n\tiot = ia->ia_iot;\n\tmemt = ia->ia_memt;\n\trv = 0;\n\n\t/* Set initial values for width/size. */\n\tmemsize = 8192;\n\tisa16bit = 0;\n\n\tif (bus_space_map(iot, ia->ia_iobase, ED_WD_IO_PORTS, 0, &ioh))\n\t\treturn (0);\n\n\tsc->asic_base = asicbase = 0;\n\tsc->nic_base = nicbase = asicbase + ED_WD_NIC_OFFSET;\n\tsc->is790 = 0;\n\n#ifdef TOSH_ETHER\n\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR, ED_WD_MSR_POW);\n\tdelay(10000);\n#endif\n\n\t/*\n\t * Attempt to do a checksum over the station address PROM.  If it\n\t * fails, it's probably not a SMC/WD board.  There is a problem with\n\t * this, though: some clone WD boards don't pass the checksum test.\n\t * Danpex boards for one.\n\t */\n\tfor (sum = 0, i = 0; i < 8; ++i)\n\t\tsum += bus_space_read_1(iot, ioh, asicbase + ED_WD_PROM + i);\n\n\tif (sum != ED_WD_ROM_CHECKSUM_TOTAL) {\n\t\t/*\n\t\t * Checksum is invalid.  This often happens with cheap WD8003E\n\t\t * clones.  In this case, the checksum byte (the eighth byte)\n\t\t * seems to always be zero.\n\t\t */\n\t\tif (bus_space_read_1(iot, ioh, asicbase + ED_WD_CARD_ID) !=\n\t\t    ED_TYPE_WD8003E ||\n\t\t    bus_space_read_1(iot, ioh, asicbase + ED_WD_PROM + 7) != 0)\n\t\t\tgoto out;\n\t}\n\n\t/* Reset card to force it into a known state. */\n#ifdef TOSH_ETHER\n\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR,\n\t    ED_WD_MSR_RST | ED_WD_MSR_POW);\n#else\n\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR, ED_WD_MSR_RST);\n#endif\n\tdelay(100);\n\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR,\n\t    bus_space_read_1(iot, ioh, asicbase + ED_WD_MSR) & ~ED_WD_MSR_RST);\n\t/* Wait in the case this card is reading it's EEROM. */\n\tdelay(5000);\n\n\tsc->vendor = ED_VENDOR_WD_SMC;\n\tsc->type = bus_space_read_1(iot, ioh, asicbase + ED_WD_CARD_ID);\n\n\tswitch (sc->type) {\n\tcase ED_TYPE_WD8003S:\n\t\tsc->type_str = \"WD8003S\";\n\t\tbreak;\n\tcase ED_TYPE_WD8003E:\n\t\tsc->type_str = \"WD8003E\";\n\t\tbreak;\n\tcase ED_TYPE_WD8003EB:\n\t\tsc->type_str = \"WD8003EB\";\n\t\tbreak;\n\tcase ED_TYPE_WD8003W:\n\t\tsc->type_str = \"WD8003W\";\n\t\tbreak;\n\tcase ED_TYPE_WD8013EBT:\n\t\tsc->type_str = \"WD8013EBT\";\n\t\tmemsize = 16384;\n\t\tisa16bit = 1;\n\t\tbreak;\n\tcase ED_TYPE_WD8013W:\n\t\tsc->type_str = \"WD8013W\";\n\t\tmemsize = 16384;\n\t\tisa16bit = 1;\n\t\tbreak;\n\tcase ED_TYPE_WD8013EP:\t\t/* also WD8003EP */\n\t\tif (bus_space_read_1(iot, ioh, asicbase + ED_WD_ICR)\n\t\t    & ED_WD_ICR_16BIT) {\n\t\t\tisa16bit = 1;\n\t\t\tmemsize = 16384;\n\t\t\tsc->type_str = \"WD8013EP\";\n\t\t} else\n\t\t\tsc->type_str = \"WD8003EP\";\n\t\tbreak;\n\tcase ED_TYPE_WD8013WC:\n\t\tsc->type_str = \"WD8013WC\";\n\t\tmemsize = 16384;\n\t\tisa16bit = 1;\n\t\tbreak;\n\tcase ED_TYPE_WD8013EBP:\n\t\tsc->type_str = \"WD8013EBP\";\n\t\tmemsize = 16384;\n\t\tisa16bit = 1;\n\t\tbreak;\n\tcase ED_TYPE_WD8013EPC:\n\t\tsc->type_str = \"WD8013EPC\";\n\t\tmemsize = 16384;\n\t\tisa16bit = 1;\n\t\tbreak;\n\tcase ED_TYPE_SMC8216C:\n\tcase ED_TYPE_SMC8216T:\n\t\twd790rev = bus_space_read_1(iot, ioh, asicbase + ED_WD790_REV);\n\t\tif (wd790rev < ED_WD795)\n\t\t\tsc->type_str = (sc->type == ED_TYPE_SMC8216C) ?\n\t\t\t    \"SMC8216/SMC8216C\" : \"SMC8216T\";\n\t\telse {\n\t\t\tsc->type_str = \"SMC8416C/SMC8416BT\";\n\t\t\tif (bus_space_read_1(iot, ioh,\n\t\t\t\t\t     asicbase + ED_WD795_PIO)) {\n\t\t\t\tprintf (\"%s: detected SMC8416 in PIO mode, unsupported hardware configuration.\\n\", sc->sc_dev.dv_xname);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD790_HWR,\n\t\t    bus_space_read_1(iot, ioh, asicbase + ED_WD790_HWR)\n\t\t    | ED_WD790_HWR_SWH);\n\t\tswitch (bus_space_read_1(iot, ioh, asicbase + ED_WD790_RAR) &\n\t\t    ED_WD790_RAR_SZ64) {\n\t\tcase ED_WD790_RAR_SZ64:\n\t\t\tmemsize = 65536;\n\t\t\tbreak;\n\t\tcase ED_WD790_RAR_SZ32:\n\t\t\tmemsize = 32768;\n\t\t\tbreak;\n\t\tcase ED_WD790_RAR_SZ16:\n\t\t\tmemsize = 16384;\n\t\t\tbreak;\n\t\tcase ED_WD790_RAR_SZ8:\n\t\t\tmemsize = 8192;\n\t\t\tbreak;\n\t\t}\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD790_HWR,\n\t\t    bus_space_read_1(iot, ioh, asicbase + ED_WD790_HWR) &\n\t\t    ~ED_WD790_HWR_SWH);\n\n\t\tisa16bit = 1;\n\t\tsc->is790 = 1;\n\t\tbreak;\n#ifdef TOSH_ETHER\n\tcase ED_TYPE_TOSHIBA1:\n\t\tsc->type_str = \"Toshiba1\";\n\t\tmemsize = 32768;\n\t\tisa16bit = 1;\n\t\tbreak;\n\tcase ED_TYPE_TOSHIBA4:\n\t\tsc->type_str = \"Toshiba4\";\n\t\tmemsize = 32768;\n\t\tisa16bit = 1;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tsc->type_str = NULL;\n\t\tbreak;\n\t}\n\t/*\n\t * Make some adjustments to initial values depending on what is found\n\t * in the ICR.\n\t */\n\tif (isa16bit && (sc->type != ED_TYPE_WD8013EBT) &&\n#ifdef TOSH_ETHER\n\t    (sc->type != ED_TYPE_TOSHIBA1) && (sc->type != ED_TYPE_TOSHIBA4) &&\n#endif\n\t    ((bus_space_read_1(iot, ioh, asicbase + ED_WD_ICR) &\n\t    ED_WD_ICR_16BIT) == 0)) {\n\t\tisa16bit = 0;\n\t\tmemsize = 8192;\n\t}\n\n#ifdef ED_DEBUG\n\tprintf(\"type=%x type_str=%s isa16bit=%d memsize=%d id_msize=%d\\n\",\n\t    sc->type, sc->type_str ?: \"unknown\", isa16bit, memsize,\n\t    ia->ia_msize);\n\tfor (i = 0; i < 8; i++)\n\t\tprintf(\"%x -> %x\\n\", i, bus_space_read_1(iot, ioh,\n\t\t    asicbase + i));\n#endif\n\t/* Allow the user to override the autoconfiguration. */\n\tif (ia->ia_msize)\n\t\tmemsize = ia->ia_msize;\n\t/*\n\t * (Note that if the user specifies both of the following flags that\n\t * '8-bit' mode intentionally has precedence.)\n\t */\n\tif (cf->cf_flags & ED_FLAGS_FORCE_16BIT_MODE)\n\t\tisa16bit = 1;\n\tif (cf->cf_flags & ED_FLAGS_FORCE_8BIT_MODE)\n\t\tisa16bit = 0;\n\n\t/*\n\t * If possible, get the assigned interrupt number from the card and\n\t * use it.\n\t */\n\tif (sc->is790) {\n\t\tu_char x;\n\n\t\t/* Assemble together the encoded interrupt number. */\n\t\tbus_space_write_1(iot, ioh, ED_WD790_HWR,\n\t\t    bus_space_read_1(iot, ioh, ED_WD790_HWR) |\n\t\t    ED_WD790_HWR_SWH);\n\t\tx = bus_space_read_1(iot, ioh, ED_WD790_GCR);\n\t\tiptr = ((x & ED_WD790_GCR_IR2) >> 4) |\n\t\t    ((x & (ED_WD790_GCR_IR1|ED_WD790_GCR_IR0)) >> 2);\n\t\tbus_space_write_1(iot, ioh, ED_WD790_HWR,\n\t\t    bus_space_read_1(iot, ioh, ED_WD790_HWR) &\n\t\t    ~ED_WD790_HWR_SWH);\n\t\t/*\n\t\t * Translate it using translation table, and check for\n\t\t * correctness.\n\t\t */\n\t\tif (ia->ia_irq != IRQUNK) {\n\t\t\tif (ia->ia_irq != ed_wd790_irq[iptr]) {\n\t\t\t\tprintf(\"%s: irq mismatch; kernel configured %d != board configured %d\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, ia->ia_irq,\n\t\t\t\t    ed_wd790_irq[iptr]);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else\n\t\t\tia->ia_irq = ed_wd790_irq[iptr];\n\t\t/* Enable the interrupt. */\n\t\tbus_space_write_1(iot, ioh, ED_WD790_ICR,\n\t\t    bus_space_read_1(iot, ioh, ED_WD790_ICR) |\n\t\t    ED_WD790_ICR_EIL);\n\t} else if (sc->type & ED_WD_SOFTCONFIG) {\n\t\t/* Assemble together the encoded interrupt number. */\n\t\tiptr = (bus_space_read_1(iot, ioh, ED_WD_ICR) &\n\t\t    ED_WD_ICR_IR2) |\n\t\t    ((bus_space_read_1(iot, ioh, ED_WD_IRR) &\n\t\t      (ED_WD_IRR_IR0 | ED_WD_IRR_IR1)) >> 5);\n\t\t/*\n\t\t * Translate it using translation table, and check for\n\t\t * correctness.\n\t\t */\n\t\tif (ia->ia_irq != IRQUNK) {\n\t\t\tif (ia->ia_irq != ed_wd584_irq[iptr]) {\n\t\t\t\tprintf(\"%s: irq mismatch; kernel configured %d != board configured %d\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, ia->ia_irq,\n\t\t\t\t    ed_wd584_irq[iptr]);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else\n\t\t\tia->ia_irq = ed_wd584_irq[iptr];\n\t\t/* Enable the interrupt. */\n\t\tbus_space_write_1(iot, ioh, ED_WD_IRR,\n\t\t    bus_space_read_1(iot, ioh, ED_WD_IRR) | ED_WD_IRR_IEN);\n\t} else {\n\t\tif (ia->ia_irq == IRQUNK) {\n\t\t\tprintf(\"%s: %s does not have soft configuration\\n\",\n\t\t\t    sc->sc_dev.dv_xname, sc->type_str);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* XXX Figure out the shared memory address. */\n\n\tif (ia->ia_maddr == MADDRUNK)\n\t\tgoto out;\n\tsc->isa16bit = isa16bit;\n\tsc->mem_shared = 1;\n\tia->ia_msize = memsize;\n\tif (bus_space_map(memt, ia->ia_maddr, memsize, 0, &memh))\n\t\tgoto out;\n\tmapped_mem = 1;\n\tsc->mem_start = 0;\t/* offset */\n\n\t/* Allocate one xmit buffer if < 16k, two buffers otherwise. */\n\tif ((memsize < 16384) || (cf->cf_flags & ED_FLAGS_NO_MULTI_BUFFERING))\n\t\tsc->txb_cnt = 1;\n\telse\n\t\tsc->txb_cnt = 2;\n\n\tsc->tx_page_start = ED_WD_PAGE_OFFSET;\n\tsc->rec_page_start = sc->tx_page_start + sc->txb_cnt * ED_TXBUF_SIZE;\n\tsc->rec_page_stop = sc->tx_page_start + (memsize >> ED_PAGE_SHIFT);\n\tsc->mem_ring = sc->mem_start + (sc->rec_page_start << ED_PAGE_SHIFT);\n\tsc->mem_size = memsize;\n\tsc->mem_end = sc->mem_start + memsize;\n\n\t/* Get station address from on-board ROM. */\n\tfor (i = 0; i < ETHER_ADDR_LEN; ++i)\n\t\tsc->sc_arpcom.ac_enaddr[i] =\n\t\t    bus_space_read_1(iot, ioh, asicbase + ED_WD_PROM + i);\n\n\t/*\n\t * Set upper address bits and 8/16 bit access to shared memory.\n\t */\n\tif (isa16bit) {\n\t\tif (sc->is790) {\n\t\t\tsc->wd_laar_proto =\n\t\t\t    bus_space_read_1(iot, ioh, asicbase + ED_WD_LAAR) &\n\t\t\t    ~ED_WD_LAAR_M16EN;\n\t\t} else {\n\t\t\tsc->wd_laar_proto = ED_WD_LAAR_L16EN |\n\t\t\t    ((ia->ia_maddr >> 19) & ED_WD_LAAR_ADDRHI);\n\t\t}\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_LAAR,\n\t\t    sc->wd_laar_proto | ED_WD_LAAR_M16EN);\n\t} else  {\n\t\tif ((sc->type & ED_WD_SOFTCONFIG) ||\n#ifdef TOSH_ETHER\n\t\t    (sc->type == ED_TYPE_TOSHIBA1) ||\n\t\t    (sc->type == ED_TYPE_TOSHIBA4) ||\n#endif\n\t\t    ((sc->type == ED_TYPE_WD8013EBT) && !sc->is790)) {\n\t\t\tsc->wd_laar_proto =\n\t\t\t    ((ia->ia_maddr >> 19) &\n\t\t\t    ED_WD_LAAR_ADDRHI);\n\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_LAAR,\n\t\t\t    sc->wd_laar_proto);\n\t\t}\n\t}\n\n\t/*\n\t * Set address and enable interface shared memory.\n\t */\n\tif (!sc->is790) {\n#ifdef TOSH_ETHER\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR + 1,\n\t\t    ((ia->ia_maddr >> 8) & 0xe0) | 4);\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR + 2,\n\t\t    ((ia->ia_maddr >> 16) & 0x0f));\n\t\tsc->wd_msr_proto = ED_WD_MSR_POW;\n#else\n\t\tsc->wd_msr_proto =\n\t\t    (ia->ia_maddr >> 13) & ED_WD_MSR_ADDR;\n#endif\n\t\tsc->cr_proto = ED_CR_RD2;\n\t} else {\n\t\tbus_space_write_1(iot, ioh, asicbase + 0x04,\n\t\t    bus_space_read_1(iot, ioh, asicbase + 0x04) | 0x80);\n\t\tbus_space_write_1(iot, ioh, asicbase + 0x0b,\n\t\t    ((ia->ia_maddr >> 13) & 0x0f) |\n\t\t    ((ia->ia_maddr >> 11) & 0x40) |\n\t\t    (bus_space_read_1(iot, ioh, asicbase + 0x0b) & 0xb0));\n\t\tbus_space_write_1(iot, ioh, asicbase + 0x04,\n\t\t    bus_space_read_1(iot, ioh, asicbase + 0x04) & ~0x80);\n\t\tsc->wd_msr_proto = 0x00;\n\t\tsc->cr_proto = 0;\n\t}\n\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR,\n\t    sc->wd_msr_proto | ED_WD_MSR_MENB);\n\n\t(void) bus_space_read_1(iot, delaybah, 0);\n\t(void) bus_space_read_1(iot, delaybah, 0);\n\n\t/* Now zero memory and verify that it is clear. */\n\tif (isa16bit) {\n\t\tfor (i = 0; i < memsize; i += 2)\n\t\t\tbus_space_write_2(memt, memh, sc->mem_start + i, 0);\n\t} else {\n\t\tfor (i = 0; i < memsize; ++i)\n\t\t\tbus_space_write_1(memt, memh, sc->mem_start + i, 0);\n\t}\n\n\tmemfail = 0;\n\tif (isa16bit) {\n\t\tfor (i = 0; i < memsize; i += 2) {\n\t\t\tif (bus_space_read_2(memt, memh, sc->mem_start + i)) {\n\t\t\t\tmemfail = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < memsize; ++i) {\n\t\t\tif (bus_space_read_1(memt, memh, sc->mem_start + i)) {\n\t\t\t\tmemfail = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (memfail) {\n\t\tprintf(\"%s: failed to clear shared memory at %x - \"\n\t\t    \"check configuration\\n\",\n\t\t    sc->sc_dev.dv_xname,\n\t\t    (ia->ia_maddr + sc->mem_start + i));\n\n\t\t/* Disable 16 bit access to shared memory. */\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR,\n\t\t    sc->wd_msr_proto);\n\t\tif (isa16bit)\n\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_LAAR,\n\t\t\t    sc->wd_laar_proto);\n\t\t(void) bus_space_read_1(iot, delaybah, 0);\n\t\t(void) bus_space_read_1(iot, delaybah, 0);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Disable 16bit access to shared memory - we leave it disabled\n\t * so that 1) machines reboot properly when the board is set 16\n\t * 16 bit mode and there are conflicting 8bit devices/ROMS in\n\t * the same 128k address space as this boards shared memory,\n\t * and 2) so that other 8 bit devices with shared memory can be\n\t * used in this 128k region, too.\n\t */\n\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR, sc->wd_msr_proto);\n\tif (isa16bit)\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_LAAR,\n\t\t    sc->wd_laar_proto);\n\t(void) bus_space_read_1(iot, delaybah, 0);\n\t(void) bus_space_read_1(iot, delaybah, 0);\n\n\tia->ia_iosize = ED_WD_IO_PORTS;\n\trv = 1;\n\n out:\n\t/*\n\t * XXX Should always unmap, but we can't yet.\n\t * XXX Need to squish \"indirect\" first.\n\t */\n\tif (rv == 0) {\n\t\tbus_space_unmap(iot, ioh, ED_WD_IO_PORTS);\n\t\tif (mapped_mem)\n\t\t\tbus_space_unmap(memt, memh, memsize);\n\t} else {\n\t\t/* XXX this is all \"indirect\" brokenness */\n\t\tsc->sc_iot = iot;\n\t\tsc->sc_memt = memt;\n\t\tsc->sc_ioh = ioh;\n\t\tsc->sc_memh = memh;\n\t}\n\treturn (rv);\n}"
  },
  {
    "function_name": "ed_probe_generic8390",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
    "lines": "603-618",
    "snippet": "int\ned_probe_generic8390(t, bah, nicbase)\n\tbus_space_tag_t t;\n\tbus_space_handle_t bah;\n\tint nicbase;\n{\n\n\tif ((NIC_GET(t, bah, nicbase, ED_P0_CR) &\n\t     (ED_CR_RD2 | ED_CR_TXP | ED_CR_STA | ED_CR_STP)) !=\n\t    (ED_CR_RD2 | ED_CR_STP))\n\t\treturn (0);\n\tif ((NIC_GET(t, bah, nicbase, ED_P0_ISR) & ED_ISR_RST) != ED_ISR_RST)\n\t\treturn (0);\n\n\treturn (1);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/isa/if_edreg.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"ed.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int ed_probe_generic8390"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NIC_GET",
          "args": [
            "t",
            "bah",
            "nicbase",
            "ED_P0_ISR"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_GET",
          "args": [
            "t",
            "bah",
            "nicbase",
            "ED_P0_CR"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nint ed_probe_generic8390;\n\nint\ned_probe_generic8390(t, bah, nicbase)\n\tbus_space_tag_t t;\n\tbus_space_handle_t bah;\n\tint nicbase;\n{\n\n\tif ((NIC_GET(t, bah, nicbase, ED_P0_CR) &\n\t     (ED_CR_RD2 | ED_CR_TXP | ED_CR_STA | ED_CR_STP)) !=\n\t    (ED_CR_RD2 | ED_CR_STP))\n\t\treturn (0);\n\tif ((NIC_GET(t, bah, nicbase, ED_P0_ISR) & ED_ISR_RST) != ED_ISR_RST)\n\t\treturn (0);\n\n\treturn (1);\n}"
  },
  {
    "function_name": "ed_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
    "lines": "566-580",
    "snippet": "int\ned_find(sc, cf, ia)\n\tstruct ed_softc *sc;\n\tstruct cfdata *cf;\n\tstruct isa_attach_args *ia;\n{\n\n\tif (ed_find_WD80x3(sc, cf, ia))\n\t\treturn (1);\n\tif (ed_find_3Com(sc, cf, ia))\n\t\treturn (1);\n\tif (ed_find_Novell(sc, cf, ia))\n\t\treturn (1);\n\treturn (0);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/isa/if_edreg.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"ed.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int ed_find",
      "int ed_find_WD80x3",
      "int ed_find_3Com",
      "int ed_find_Novell",
      "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ed_find_Novell",
          "args": [
            "sc",
            "cf",
            "ia"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "ed_find_Novell",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
          "lines": "1387-1629",
          "snippet": "int\ned_find_Novell(sc, cf, ia)\n\tstruct ed_softc *sc;\n\tstruct cfdata *cf;\n\tstruct isa_attach_args *ia;\n{\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tu_int memsize, n;\n\tu_char romdata[16], tmp;\n\tstatic u_char test_pattern[32] = \"THIS is A memory TEST pattern\";\n\tu_char test_buffer[32];\n\tint asicbase, nicbase;\n\n\tiot = ia->ia_iot;\n\n\tif (bus_space_map(iot, ia->ia_iobase, ED_NOVELL_IO_PORTS, 0, &ioh))\n\t\treturn (0);\n\n\tsc->asic_base = asicbase = ED_NOVELL_ASIC_OFFSET;\n\tsc->nic_base = nicbase = ED_NOVELL_NIC_OFFSET;\n\n\t/* XXX - do Novell-specific probe here */\n\n\t/* Reset the board. */\n#ifdef GWETHER\n\tbus_space_write_1(iot, ioh, asicbase + ED_NOVELL_RESET, 0);\n\tdelay(200);\n#endif /* GWETHER */\n\ttmp = bus_space_read_1(iot, ioh, asicbase + ED_NOVELL_RESET);\n\n\t/*\n\t * I don't know if this is necessary; probably cruft leftover from\n\t * Clarkson packet driver code. Doesn't do a thing on the boards I've\n\t * tested. -DG [note that a outb(0x84, 0) seems to work here, and is\n\t * non-invasive...but some boards don't seem to reset and I don't have\n\t * complete documentation on what the 'right' thing to do is...so we do\n\t * the invasive thing for now.  Yuck.]\n\t */\n\tbus_space_write_1(iot, ioh, asicbase + ED_NOVELL_RESET, tmp);\n\tdelay(5000);\n\n\t/*\n\t * This is needed because some NE clones apparently don't reset the NIC\n\t * properly (or the NIC chip doesn't reset fully on power-up)\n\t * XXX - this makes the probe invasive! ...Done against my better\n\t * judgement.  -DLG\n\t */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STP);\n\n\tdelay(5000);\n\n\t/* Make sure that we really have an 8390 based board. */\n\tif (!ed_probe_generic8390(iot, ioh, nicbase))\n\t\tgoto out;\n\n\tsc->vendor = ED_VENDOR_NOVELL;\n\tsc->mem_shared = 0;\n\tsc->cr_proto = ED_CR_RD2;\n\tia->ia_msize = 0;\n\n\t/*\n\t * Test the ability to read and write to the NIC memory.  This has the\n\t * side affect of determining if this is an NE1000 or an NE2000.\n\t */\n\n\t/*\n\t * This prevents packets from being stored in the NIC memory when the\n\t * readmem routine turns on the start bit in the CR.\n\t */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RCR, ED_RCR_MON);\n\n\t/* Temporarily initialize DCR for byte operations. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_DCR, ED_DCR_FT1 | ED_DCR_LS);\n\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTART, 8192 >> ED_PAGE_SHIFT);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTOP, 16384 >> ED_PAGE_SHIFT);\n\n\tsc->isa16bit = 0;\n\n\t/*\n\t * XXX indirect brokenness, used by ed_pio{read,write}mem()\n\t */\n\tsc->sc_iot = iot;\n\tsc->sc_ioh = ioh;\n\n\t/*\n\t * Write a test pattern in byte mode.  If this fails, then there\n\t * probably isn't any memory at 8k - which likely means that the board\n\t * is an NE2000.\n\t */\n\ted_pio_writemem(sc, test_pattern, 8192, sizeof(test_pattern));\n\ted_pio_readmem(sc, 8192, test_buffer, sizeof(test_pattern));\n\n\tif (bcmp(test_pattern, test_buffer, sizeof(test_pattern))) {\n\t\t/* not an NE1000 - try NE2000 */\n\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_DCR,\n\t\t    ED_DCR_WTS | ED_DCR_FT1 | ED_DCR_LS);\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTART, 16384 >> ED_PAGE_SHIFT);\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTOP, 32768 >> ED_PAGE_SHIFT);\n\n\t\tsc->isa16bit = 1;\n\n\t\t/*\n\t\t * Write a test pattern in word mode.  If this also fails, then\n\t\t * we don't know what this board is.\n\t\t */\n\t\ted_pio_writemem(sc, test_pattern, 16384, sizeof(test_pattern));\n\t\ted_pio_readmem(sc, 16384, test_buffer, sizeof(test_pattern));\n\n\t\tif (bcmp(test_pattern, test_buffer, sizeof(test_pattern)))\n\t\t\tgoto out; /* not an NE2000 either */\n\n\t\tsc->type = ED_TYPE_NE2000;\n\t\tsc->type_str = \"NE2000\";\n\t} else {\n\t\tsc->type = ED_TYPE_NE1000;\n\t\tsc->type_str = \"NE1000\";\n\t}\n\n\tif (ia->ia_irq == IRQUNK) {\n\t\tprintf(\"%s: %s does not have soft configuration\\n\",\n\t\t    sc->sc_dev.dv_xname, sc->type_str);\n\t\tgoto out;\n\t}\n\n\t/* 8k of memory plus an additional 8k if 16-bit. */\n\tmemsize = 8192 + sc->isa16bit * 8192;\n\n#if 0 /* probably not useful - NE boards only come two ways */\n\t/* Allow kernel config file overrides. */\n\tif (ia->ia_msize)\n\t\tmemsize = ia->ia_msize;\n#endif\n\n\t/* NIC memory doesn't start at zero on an NE board. */\n\t/* The start address is tied to the bus width. */\n\tsc->mem_start = (8192 + sc->isa16bit * 8192);\n\tsc->tx_page_start = memsize >> ED_PAGE_SHIFT;\n\n#ifdef GWETHER\n\t{\n\t\tint x, i, mstart = 0;\n\t\tchar pbuf0[ED_PAGE_SIZE], pbuf[ED_PAGE_SIZE], tbuf[ED_PAGE_SIZE];\n\n\t\tfor (i = 0; i < ED_PAGE_SIZE; i++)\n\t\t\tpbuf0[i] = 0;\n\n\t\t/* Search for the start of RAM. */\n\t\tfor (x = 1; x < 256; x++) {\n\t\t\ted_pio_writemem(sc, pbuf0, x << ED_PAGE_SHIFT, ED_PAGE_SIZE);\n\t\t\ted_pio_readmem(sc, x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE);\n\t\t\tif (!bcmp(pbuf0, tbuf, ED_PAGE_SIZE)) {\n\t\t\t\tfor (i = 0; i < ED_PAGE_SIZE; i++)\n\t\t\t\t\tpbuf[i] = 255 - x;\n\t\t\t\ted_pio_writemem(sc, pbuf, x << ED_PAGE_SHIFT, ED_PAGE_SIZE);\n\t\t\t\ted_pio_readmem(sc, x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE);\n\t\t\t\tif (!bcmp(pbuf, tbuf, ED_PAGE_SIZE)) {\n\t\t\t\t\tmstart = x << ED_PAGE_SHIFT;\n\t\t\t\t\tmemsize = ED_PAGE_SIZE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (mstart == 0) {\n\t\t\tprintf(\"%s: cannot find start of RAM\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* Search for the end of RAM. */\n\t\tfor (++x; x < 256; x++) {\n\t\t\ted_pio_writemem(sc, pbuf0, x << ED_PAGE_SHIFT, ED_PAGE_SIZE);\n\t\t\ted_pio_readmem(sc, x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE);\n\t\t\tif (!bcmp(pbuf0, tbuf, ED_PAGE_SIZE)) {\n\t\t\t\tfor (i = 0; i < ED_PAGE_SIZE; i++)\n\t\t\t\t\tpbuf[i] = 255 - x;\n\t\t\t\ted_pio_writemem(sc, pbuf, x << ED_PAGE_SHIFT, ED_PAGE_SIZE);\n\t\t\t\ted_pio_readmem(sc, x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE);\n\t\t\t\tif (!bcmp(pbuf, tbuf, ED_PAGE_SIZE))\n\t\t\t\t\tmemsize += ED_PAGE_SIZE;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\n\t\tprintf(\"%s: RAM start %x, size %d\\n\",\n\t\t    sc->sc_dev.dv_xname, mstart, memsize);\n\n\t\tsc->mem_start = (caddr_t)mstart;\n\t\tsc->tx_page_start = mstart >> ED_PAGE_SHIFT;\n\t}\n#endif /* GWETHER */\n\n\tsc->mem_size = memsize;\n\tsc->mem_end = sc->mem_start + memsize;\n\n\t/*\n\t * Use one xmit buffer if < 16k, two buffers otherwise (if not told\n\t * otherwise).\n\t */\n\tif ((memsize < 16384) || (cf->cf_flags & ED_FLAGS_NO_MULTI_BUFFERING))\n\t\tsc->txb_cnt = 1;\n\telse\n\t\tsc->txb_cnt = 2;\n\n\tsc->rec_page_start = sc->tx_page_start + sc->txb_cnt * ED_TXBUF_SIZE;\n\tsc->rec_page_stop = sc->tx_page_start + (memsize >> ED_PAGE_SHIFT);\n\n\tsc->mem_ring =\n\t    sc->mem_start + ((sc->txb_cnt * ED_TXBUF_SIZE) << ED_PAGE_SHIFT);\n\n\ted_pio_readmem(sc, 0, romdata, 16);\n\tfor (n = 0; n < ETHER_ADDR_LEN; n++)\n\t\tsc->sc_arpcom.ac_enaddr[n] = romdata[n*(sc->isa16bit+1)];\n\n#ifdef GWETHER\n\tif (sc->arpcom.ac_enaddr[2] == 0x86)\n\t\tsc->type_str = \"Gateway AT\";\n#endif /* GWETHER */\n\n\t/* Clear any pending interrupts that might have occurred above. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_ISR, 0xff);\n\n\tia->ia_iosize = ED_NOVELL_IO_PORTS;\n\n\t/*\n\t * XXX Sould always unmap, but we can't yet.\n\t * XXX Need to squish \"indirect\" first.\n\t */\n\tsc->sc_iot = iot;\n\tsc->sc_ioh = ioh;\n\t/* sc_memh is not used by this driver */\n\treturn 1;\n out:\n\tbus_space_unmap(iot, ioh, ED_NOVELL_IO_PORTS);\n\n\treturn 0;\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/isa/if_edreg.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"ed.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tETHER_ADDR_LEN\t6"
          ],
          "globals_used": [
            "int ed_probe_generic8390",
            "int ed_find_Novell",
            "void ed_pio_readmem",
            "void ed_pio_writemem",
            "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\n#define\tETHER_ADDR_LEN\t6\n\nint ed_probe_generic8390;\nint ed_find_Novell;\nvoid ed_pio_readmem;\nvoid ed_pio_writemem;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nint\ned_find_Novell(sc, cf, ia)\n\tstruct ed_softc *sc;\n\tstruct cfdata *cf;\n\tstruct isa_attach_args *ia;\n{\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tu_int memsize, n;\n\tu_char romdata[16], tmp;\n\tstatic u_char test_pattern[32] = \"THIS is A memory TEST pattern\";\n\tu_char test_buffer[32];\n\tint asicbase, nicbase;\n\n\tiot = ia->ia_iot;\n\n\tif (bus_space_map(iot, ia->ia_iobase, ED_NOVELL_IO_PORTS, 0, &ioh))\n\t\treturn (0);\n\n\tsc->asic_base = asicbase = ED_NOVELL_ASIC_OFFSET;\n\tsc->nic_base = nicbase = ED_NOVELL_NIC_OFFSET;\n\n\t/* XXX - do Novell-specific probe here */\n\n\t/* Reset the board. */\n#ifdef GWETHER\n\tbus_space_write_1(iot, ioh, asicbase + ED_NOVELL_RESET, 0);\n\tdelay(200);\n#endif /* GWETHER */\n\ttmp = bus_space_read_1(iot, ioh, asicbase + ED_NOVELL_RESET);\n\n\t/*\n\t * I don't know if this is necessary; probably cruft leftover from\n\t * Clarkson packet driver code. Doesn't do a thing on the boards I've\n\t * tested. -DG [note that a outb(0x84, 0) seems to work here, and is\n\t * non-invasive...but some boards don't seem to reset and I don't have\n\t * complete documentation on what the 'right' thing to do is...so we do\n\t * the invasive thing for now.  Yuck.]\n\t */\n\tbus_space_write_1(iot, ioh, asicbase + ED_NOVELL_RESET, tmp);\n\tdelay(5000);\n\n\t/*\n\t * This is needed because some NE clones apparently don't reset the NIC\n\t * properly (or the NIC chip doesn't reset fully on power-up)\n\t * XXX - this makes the probe invasive! ...Done against my better\n\t * judgement.  -DLG\n\t */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STP);\n\n\tdelay(5000);\n\n\t/* Make sure that we really have an 8390 based board. */\n\tif (!ed_probe_generic8390(iot, ioh, nicbase))\n\t\tgoto out;\n\n\tsc->vendor = ED_VENDOR_NOVELL;\n\tsc->mem_shared = 0;\n\tsc->cr_proto = ED_CR_RD2;\n\tia->ia_msize = 0;\n\n\t/*\n\t * Test the ability to read and write to the NIC memory.  This has the\n\t * side affect of determining if this is an NE1000 or an NE2000.\n\t */\n\n\t/*\n\t * This prevents packets from being stored in the NIC memory when the\n\t * readmem routine turns on the start bit in the CR.\n\t */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RCR, ED_RCR_MON);\n\n\t/* Temporarily initialize DCR for byte operations. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_DCR, ED_DCR_FT1 | ED_DCR_LS);\n\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTART, 8192 >> ED_PAGE_SHIFT);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTOP, 16384 >> ED_PAGE_SHIFT);\n\n\tsc->isa16bit = 0;\n\n\t/*\n\t * XXX indirect brokenness, used by ed_pio{read,write}mem()\n\t */\n\tsc->sc_iot = iot;\n\tsc->sc_ioh = ioh;\n\n\t/*\n\t * Write a test pattern in byte mode.  If this fails, then there\n\t * probably isn't any memory at 8k - which likely means that the board\n\t * is an NE2000.\n\t */\n\ted_pio_writemem(sc, test_pattern, 8192, sizeof(test_pattern));\n\ted_pio_readmem(sc, 8192, test_buffer, sizeof(test_pattern));\n\n\tif (bcmp(test_pattern, test_buffer, sizeof(test_pattern))) {\n\t\t/* not an NE1000 - try NE2000 */\n\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_DCR,\n\t\t    ED_DCR_WTS | ED_DCR_FT1 | ED_DCR_LS);\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTART, 16384 >> ED_PAGE_SHIFT);\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTOP, 32768 >> ED_PAGE_SHIFT);\n\n\t\tsc->isa16bit = 1;\n\n\t\t/*\n\t\t * Write a test pattern in word mode.  If this also fails, then\n\t\t * we don't know what this board is.\n\t\t */\n\t\ted_pio_writemem(sc, test_pattern, 16384, sizeof(test_pattern));\n\t\ted_pio_readmem(sc, 16384, test_buffer, sizeof(test_pattern));\n\n\t\tif (bcmp(test_pattern, test_buffer, sizeof(test_pattern)))\n\t\t\tgoto out; /* not an NE2000 either */\n\n\t\tsc->type = ED_TYPE_NE2000;\n\t\tsc->type_str = \"NE2000\";\n\t} else {\n\t\tsc->type = ED_TYPE_NE1000;\n\t\tsc->type_str = \"NE1000\";\n\t}\n\n\tif (ia->ia_irq == IRQUNK) {\n\t\tprintf(\"%s: %s does not have soft configuration\\n\",\n\t\t    sc->sc_dev.dv_xname, sc->type_str);\n\t\tgoto out;\n\t}\n\n\t/* 8k of memory plus an additional 8k if 16-bit. */\n\tmemsize = 8192 + sc->isa16bit * 8192;\n\n#if 0 /* probably not useful - NE boards only come two ways */\n\t/* Allow kernel config file overrides. */\n\tif (ia->ia_msize)\n\t\tmemsize = ia->ia_msize;\n#endif\n\n\t/* NIC memory doesn't start at zero on an NE board. */\n\t/* The start address is tied to the bus width. */\n\tsc->mem_start = (8192 + sc->isa16bit * 8192);\n\tsc->tx_page_start = memsize >> ED_PAGE_SHIFT;\n\n#ifdef GWETHER\n\t{\n\t\tint x, i, mstart = 0;\n\t\tchar pbuf0[ED_PAGE_SIZE], pbuf[ED_PAGE_SIZE], tbuf[ED_PAGE_SIZE];\n\n\t\tfor (i = 0; i < ED_PAGE_SIZE; i++)\n\t\t\tpbuf0[i] = 0;\n\n\t\t/* Search for the start of RAM. */\n\t\tfor (x = 1; x < 256; x++) {\n\t\t\ted_pio_writemem(sc, pbuf0, x << ED_PAGE_SHIFT, ED_PAGE_SIZE);\n\t\t\ted_pio_readmem(sc, x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE);\n\t\t\tif (!bcmp(pbuf0, tbuf, ED_PAGE_SIZE)) {\n\t\t\t\tfor (i = 0; i < ED_PAGE_SIZE; i++)\n\t\t\t\t\tpbuf[i] = 255 - x;\n\t\t\t\ted_pio_writemem(sc, pbuf, x << ED_PAGE_SHIFT, ED_PAGE_SIZE);\n\t\t\t\ted_pio_readmem(sc, x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE);\n\t\t\t\tif (!bcmp(pbuf, tbuf, ED_PAGE_SIZE)) {\n\t\t\t\t\tmstart = x << ED_PAGE_SHIFT;\n\t\t\t\t\tmemsize = ED_PAGE_SIZE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (mstart == 0) {\n\t\t\tprintf(\"%s: cannot find start of RAM\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* Search for the end of RAM. */\n\t\tfor (++x; x < 256; x++) {\n\t\t\ted_pio_writemem(sc, pbuf0, x << ED_PAGE_SHIFT, ED_PAGE_SIZE);\n\t\t\ted_pio_readmem(sc, x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE);\n\t\t\tif (!bcmp(pbuf0, tbuf, ED_PAGE_SIZE)) {\n\t\t\t\tfor (i = 0; i < ED_PAGE_SIZE; i++)\n\t\t\t\t\tpbuf[i] = 255 - x;\n\t\t\t\ted_pio_writemem(sc, pbuf, x << ED_PAGE_SHIFT, ED_PAGE_SIZE);\n\t\t\t\ted_pio_readmem(sc, x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE);\n\t\t\t\tif (!bcmp(pbuf, tbuf, ED_PAGE_SIZE))\n\t\t\t\t\tmemsize += ED_PAGE_SIZE;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\n\t\tprintf(\"%s: RAM start %x, size %d\\n\",\n\t\t    sc->sc_dev.dv_xname, mstart, memsize);\n\n\t\tsc->mem_start = (caddr_t)mstart;\n\t\tsc->tx_page_start = mstart >> ED_PAGE_SHIFT;\n\t}\n#endif /* GWETHER */\n\n\tsc->mem_size = memsize;\n\tsc->mem_end = sc->mem_start + memsize;\n\n\t/*\n\t * Use one xmit buffer if < 16k, two buffers otherwise (if not told\n\t * otherwise).\n\t */\n\tif ((memsize < 16384) || (cf->cf_flags & ED_FLAGS_NO_MULTI_BUFFERING))\n\t\tsc->txb_cnt = 1;\n\telse\n\t\tsc->txb_cnt = 2;\n\n\tsc->rec_page_start = sc->tx_page_start + sc->txb_cnt * ED_TXBUF_SIZE;\n\tsc->rec_page_stop = sc->tx_page_start + (memsize >> ED_PAGE_SHIFT);\n\n\tsc->mem_ring =\n\t    sc->mem_start + ((sc->txb_cnt * ED_TXBUF_SIZE) << ED_PAGE_SHIFT);\n\n\ted_pio_readmem(sc, 0, romdata, 16);\n\tfor (n = 0; n < ETHER_ADDR_LEN; n++)\n\t\tsc->sc_arpcom.ac_enaddr[n] = romdata[n*(sc->isa16bit+1)];\n\n#ifdef GWETHER\n\tif (sc->arpcom.ac_enaddr[2] == 0x86)\n\t\tsc->type_str = \"Gateway AT\";\n#endif /* GWETHER */\n\n\t/* Clear any pending interrupts that might have occurred above. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_ISR, 0xff);\n\n\tia->ia_iosize = ED_NOVELL_IO_PORTS;\n\n\t/*\n\t * XXX Sould always unmap, but we can't yet.\n\t * XXX Need to squish \"indirect\" first.\n\t */\n\tsc->sc_iot = iot;\n\tsc->sc_ioh = ioh;\n\t/* sc_memh is not used by this driver */\n\treturn 1;\n out:\n\tbus_space_unmap(iot, ioh, ED_NOVELL_IO_PORTS);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ed_find_3Com",
          "args": [
            "sc",
            "cf",
            "ia"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "ed_find_3Com",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
          "lines": "1084-1382",
          "snippet": "int\ned_find_3Com(sc, cf, ia)\n\tstruct ed_softc *sc;\n\tstruct cfdata *cf;\n\tstruct isa_attach_args *ia;\n{\n\tbus_space_tag_t iot;\n\tbus_space_tag_t memt;\n\tbus_space_handle_t ioh;\n\tbus_space_handle_t memh;\n\tint i;\n\tu_int memsize, memfail;\n\tu_char isa16bit, x;\n\tint ptr, asicbase, nicbase;\n\n\t/*\n\t * Hmmm...a 16bit 3Com board has 16k of memory, but only an 8k window\n\t * to it.\n\t */\n\tmemsize = 8192;\n\n\tiot = ia->ia_iot;\n\tmemt = ia->ia_memt;\n\n\tif (bus_space_map(iot, ia->ia_iobase, ED_3COM_IO_PORTS, 0, &ioh))\n\t\treturn (0);\n\n\tsc->asic_base = asicbase = ED_3COM_ASIC_OFFSET;\n\tsc->nic_base = nicbase = ED_3COM_NIC_OFFSET;\n\n\t/*\n\t * Verify that the kernel configured I/O address matches the board\n\t * configured address.\n\t *\n\t * This is really only useful to see if something that looks like the\n\t * board is there; after all, we are already talking it at that\n\t * address.\n\t */\n\tx = bus_space_read_1(iot, ioh, asicbase + ED_3COM_BCFR);\n\tif (x == 0 || (x & (x - 1)) != 0)\n\t\tgoto err;\n\tptr = ffs(x) - 1;\n\tif (ia->ia_iobase != IOBASEUNK) {\n\t\tif (ia->ia_iobase != ed_3com_iobase[ptr]) {\n\t\t\tprintf(\"%s: %s mismatch; kernel configured %x != board configured %x\\n\",\n\t\t\t    \"iobase\", sc->sc_dev.dv_xname, ia->ia_iobase,\n\t\t\t    ed_3com_iobase[ptr]);\n\t\t\tgoto err;\n\t\t}\n\t} else\n\t\tia->ia_iobase = ed_3com_iobase[ptr];\t/* XXX --thorpej */\n\n\tx = bus_space_read_1(iot, ioh, asicbase + ED_3COM_PCFR);\n\tif (x == 0 || (x & (x - 1)) != 0) {\n\t\tprintf(\"%s: The 3c503 is not currently supported with memory \"\n\t\t       \"mapping disabled.\\n%s: Reconfigure the card to \"\n\t\t       \"enable memory mapping.\\n\",\n\t\t       sc->sc_dev.dv_xname, sc->sc_dev.dv_xname);\n\t\tgoto err;\n\t}\n\tptr = ffs(x) - 1;\n\tif (ia->ia_maddr != MADDRUNK) {\n\t\tif (ia->ia_maddr != ed_3com_maddr[ptr]) {\n\t\t\tprintf(\"%s: %s mismatch; kernel configured %x != board configured %x\\n\",\n\t\t\t    \"maddr\", sc->sc_dev.dv_xname, ia->ia_maddr,\n\t\t\t    ed_3com_maddr[ptr]);\n\t\t\tgoto err;\n\t\t}\n\t} else\n\t\tia->ia_maddr = ed_3com_maddr[ptr];\n\n#if 0\n\tx = bus_space_read_1(iot, ioh, asicbase + ED_3COM_IDCFR) &\n\t    ED_3COM_IDCFR_IRQ;\n\tif (x == 0 || (x & (x - 1)) != 0)\n\t\tgoto out;\n\tptr = ffs(x) - 1;\n\tif (ia->ia_irq != IRQUNK) {\n\t\tif (ia->ia_irq != ed_3com_irq[ptr]) {\n\t\t\tprintf(\"%s: irq mismatch; kernel configured %d != board configured %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, ia->ia_irq,\n\t\t\t    ed_3com_irq[ptr]);\n\t\t\tgoto err;\n\t\t}\n\t} else\n\t\tia->ia_irq = ed_3com_irq[ptr];\n#endif\n\n\t/*\n\t * Reset NIC and ASIC.  Enable on-board transceiver throughout reset\n\t * sequence because it'll lock up if the cable isn't connected if we\n\t * don't.\n\t */\n\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_CR,\n\t    ED_3COM_CR_RST | ED_3COM_CR_XSEL);\n\n\t/* Wait for a while, then un-reset it. */\n\tdelay(50);\n\n\t/*\n\t * The 3Com ASIC defaults to rather strange settings for the CR after a\n\t * reset - it's important to set it again after the following outb\n\t * (this is done when we map the PROM below).\n\t */\n\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_CR, ED_3COM_CR_XSEL);\n\n\t/* Wait a bit for the NIC to recover from the reset. */\n\tdelay(5000);\n\n\tsc->vendor = ED_VENDOR_3COM;\n\tsc->type_str = \"3c503\";\n\tsc->mem_shared = 1;\n\tsc->cr_proto = ED_CR_RD2;\n\n\t/*\n\t * Get station address from on-board ROM.\n\t *\n\t * First, map ethernet address PROM over the top of where the NIC\n\t * registers normally appear.\n\t */\n\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_CR,\n\t    ED_3COM_CR_EALO | ED_3COM_CR_XSEL);\n\n\tfor (i = 0; i < ETHER_ADDR_LEN; ++i)\n\t\tsc->sc_arpcom.ac_enaddr[i] = NIC_GET(iot, ioh, nicbase, i);\n\n\t/*\n\t * Unmap PROM - select NIC registers.  The proper setting of the\n\t * tranceiver is set in edinit so that the attach code is given a\n\t * chance to set the default based on a compile-time config option.\n\t */\n\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_CR, ED_3COM_CR_XSEL);\n\n\t/* Determine if this is an 8bit or 16bit board. */\n\n\t/* Select page 0 registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STP);\n\n\t/*\n\t * Attempt to clear WTS bit.  If it doesn't clear, then this is a\n\t * 16-bit board.\n\t */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_DCR, 0);\n\n\t/* Select page 2 registers. */\n\tNIC_PUT(iot, ioh, nicbase,\n\t    ED_P0_CR, ED_CR_RD2 | ED_CR_PAGE_2 | ED_CR_STP);\n\n\t/* The 3c503 forces the WTS bit to a one if this is a 16bit board. */\n\tif (NIC_GET(iot, ioh, nicbase, ED_P2_DCR) & ED_DCR_WTS)\n\t\tisa16bit = 1;\n\telse\n\t\tisa16bit = 0;\n\n\t/* Select page 0 registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P2_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STP);\n\n\tif (bus_space_map(memt, ia->ia_maddr, memsize, 0, &memh))\n\t\tgoto err;\n\tsc->mem_start = 0;\t\t/* offset */\n\tsc->mem_size = memsize;\n\tsc->mem_end = sc->mem_start + memsize;\n\n\t/*\n\t * We have an entire 8k window to put the transmit buffers on the\n\t * 16-bit boards.  But since the 16bit 3c503's shared memory is only\n\t * fast enough to overlap the loading of one full-size packet, trying\n\t * to load more than 2 buffers can actually leave the transmitter idle\n\t * during the load.  So 2 seems the best value.  (Although a mix of\n\t * variable-sized packets might change this assumption.  Nonetheless,\n\t * we optimize for linear transfers of same-size packets.)\n\t */\n\tif (isa16bit) {\n \t\tif (cf->cf_flags & ED_FLAGS_NO_MULTI_BUFFERING)\n\t\t\tsc->txb_cnt = 1;\n\t\telse\n\t\t\tsc->txb_cnt = 2;\n\n\t\tsc->tx_page_start = ED_3COM_TX_PAGE_OFFSET_16BIT;\n\t\tsc->rec_page_start = ED_3COM_RX_PAGE_OFFSET_16BIT;\n\t\tsc->rec_page_stop =\n\t\t    (memsize >> ED_PAGE_SHIFT) + ED_3COM_RX_PAGE_OFFSET_16BIT;\n\t\tsc->mem_ring = sc->mem_start;\n\t} else {\n\t\tsc->txb_cnt = 1;\n\t\tsc->tx_page_start = ED_3COM_TX_PAGE_OFFSET_8BIT;\n\t\tsc->rec_page_start =\n\t\t    ED_TXBUF_SIZE + ED_3COM_TX_PAGE_OFFSET_8BIT;\n\t\tsc->rec_page_stop =\n\t\t    (memsize >> ED_PAGE_SHIFT) + ED_3COM_TX_PAGE_OFFSET_8BIT;\n\t\tsc->mem_ring =\n\t\t    sc->mem_start + (ED_TXBUF_SIZE << ED_PAGE_SHIFT);\n\t}\n\n\tsc->isa16bit = isa16bit;\n\n\t/*\n\t * Initialize GA page start/stop registers.  Probably only needed if\n\t * doing DMA, but what the Hell.\n\t */\n\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_PSTR, sc->rec_page_start);\n\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_PSPR, sc->rec_page_stop);\n\n\t/* Set IRQ.  3c503 only allows a choice of irq 3-5 or 9. */\n\tswitch (ia->ia_irq) {\n\tcase 9:\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_IDCFR,\n\t\t    ED_3COM_IDCFR_IRQ2);\n\t\tbreak;\n\tcase 3:\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_IDCFR,\n\t\t    ED_3COM_IDCFR_IRQ3);\n\t\tbreak;\n\tcase 4:\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_IDCFR,\n\t\t    ED_3COM_IDCFR_IRQ4);\n\t\tbreak;\n\tcase 5:\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_IDCFR,\n\t\t    ED_3COM_IDCFR_IRQ5);\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: invalid irq configuration (%d) must be 3-5 or 9 for 3c503\\n\",\n\t\t    sc->sc_dev.dv_xname, ia->ia_irq);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Initialize GA configuration register.  Set bank and enable shared\n\t * mem.\n\t */\n\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_GACFR,\n\t    ED_3COM_GACFR_RSEL | ED_3COM_GACFR_MBS0);\n\n\t/*\n\t * Initialize \"Vector Pointer\" registers. These gawd-awful things are\n\t * compared to 20 bits of the address on ISA, and if they match, the\n\t * shared memory is disabled. We set them to 0xffff0...allegedly the\n\t * reset vector.\n\t */\n\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_VPTR2, 0xff);\n\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_VPTR1, 0xff);\n\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_VPTR0, 0x00);\n\n\t/* Now zero memory and verify that it is clear. */\n\tif (isa16bit) {\n\t\tfor (i = 0; i < memsize; i += 2)\n\t\t\tbus_space_write_2(memt, memh, sc->mem_start + i, 0);\n\t} else {\n\t\tfor (i = 0; i < memsize; ++i)\n\t\t\tbus_space_write_1(memt, memh, sc->mem_start + i, 0);\n\t}\n\n\tmemfail = 0;\n\tif (isa16bit) {\n\t\tfor (i = 0; i < memsize; i += 2) {\n\t\t\tif (bus_space_read_2(memt, memh, sc->mem_start + i)) {\n\t\t\t\tmemfail = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < memsize; ++i) {\n\t\t\tif (bus_space_read_1(memt, memh, sc->mem_start + i)) {\n\t\t\t\tmemfail = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (memfail) {\n\t\tprintf(\"%s: failed to clear shared memory at %x - \"\n\t\t    \"check configuration\\n\",\n\t\t    sc->sc_dev.dv_xname,\n\t\t    (ia->ia_maddr + sc->mem_start + i));\n\t\tgoto out;\n\t}\n\n\tia->ia_msize = memsize;\n\tia->ia_iosize = ED_3COM_IO_PORTS;\n\n\t/*\n\t * XXX Sould always unmap, but we can't yet.\n\t * XXX Need to squish \"indirect\" first.\n\t */\n\tsc->sc_iot = iot;\n\tsc->sc_memt = memt;\n\tsc->sc_ioh = ioh;\n\tsc->sc_memh = memh;\n\treturn 1;\n\n out:\n\tbus_space_unmap(memt, memh, memsize);\n err:\n\tbus_space_unmap(iot, ioh, ED_3COM_IO_PORTS);\n\treturn 0;\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/isa/if_edreg.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"ed.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tETHER_ADDR_LEN\t6"
          ],
          "globals_used": [
            "int ed_find_3Com",
            "void edinit",
            "int ed_3com_iobase[] =\n    {0x2e0, 0x2a0, 0x280, 0x250, 0x350, 0x330, 0x310, 0x300};",
            "int ed_3com_maddr[] = {\n    MADDRUNK, MADDRUNK, MADDRUNK, MADDRUNK, 0xc8000, 0xcc000, 0xd8000, 0xdc000\n};",
            "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\n#define\tETHER_ADDR_LEN\t6\n\nint ed_find_3Com;\nvoid edinit;\nint ed_3com_iobase[] =\n    {0x2e0, 0x2a0, 0x280, 0x250, 0x350, 0x330, 0x310, 0x300};\nint ed_3com_maddr[] = {\n    MADDRUNK, MADDRUNK, MADDRUNK, MADDRUNK, 0xc8000, 0xcc000, 0xd8000, 0xdc000\n};\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nint\ned_find_3Com(sc, cf, ia)\n\tstruct ed_softc *sc;\n\tstruct cfdata *cf;\n\tstruct isa_attach_args *ia;\n{\n\tbus_space_tag_t iot;\n\tbus_space_tag_t memt;\n\tbus_space_handle_t ioh;\n\tbus_space_handle_t memh;\n\tint i;\n\tu_int memsize, memfail;\n\tu_char isa16bit, x;\n\tint ptr, asicbase, nicbase;\n\n\t/*\n\t * Hmmm...a 16bit 3Com board has 16k of memory, but only an 8k window\n\t * to it.\n\t */\n\tmemsize = 8192;\n\n\tiot = ia->ia_iot;\n\tmemt = ia->ia_memt;\n\n\tif (bus_space_map(iot, ia->ia_iobase, ED_3COM_IO_PORTS, 0, &ioh))\n\t\treturn (0);\n\n\tsc->asic_base = asicbase = ED_3COM_ASIC_OFFSET;\n\tsc->nic_base = nicbase = ED_3COM_NIC_OFFSET;\n\n\t/*\n\t * Verify that the kernel configured I/O address matches the board\n\t * configured address.\n\t *\n\t * This is really only useful to see if something that looks like the\n\t * board is there; after all, we are already talking it at that\n\t * address.\n\t */\n\tx = bus_space_read_1(iot, ioh, asicbase + ED_3COM_BCFR);\n\tif (x == 0 || (x & (x - 1)) != 0)\n\t\tgoto err;\n\tptr = ffs(x) - 1;\n\tif (ia->ia_iobase != IOBASEUNK) {\n\t\tif (ia->ia_iobase != ed_3com_iobase[ptr]) {\n\t\t\tprintf(\"%s: %s mismatch; kernel configured %x != board configured %x\\n\",\n\t\t\t    \"iobase\", sc->sc_dev.dv_xname, ia->ia_iobase,\n\t\t\t    ed_3com_iobase[ptr]);\n\t\t\tgoto err;\n\t\t}\n\t} else\n\t\tia->ia_iobase = ed_3com_iobase[ptr];\t/* XXX --thorpej */\n\n\tx = bus_space_read_1(iot, ioh, asicbase + ED_3COM_PCFR);\n\tif (x == 0 || (x & (x - 1)) != 0) {\n\t\tprintf(\"%s: The 3c503 is not currently supported with memory \"\n\t\t       \"mapping disabled.\\n%s: Reconfigure the card to \"\n\t\t       \"enable memory mapping.\\n\",\n\t\t       sc->sc_dev.dv_xname, sc->sc_dev.dv_xname);\n\t\tgoto err;\n\t}\n\tptr = ffs(x) - 1;\n\tif (ia->ia_maddr != MADDRUNK) {\n\t\tif (ia->ia_maddr != ed_3com_maddr[ptr]) {\n\t\t\tprintf(\"%s: %s mismatch; kernel configured %x != board configured %x\\n\",\n\t\t\t    \"maddr\", sc->sc_dev.dv_xname, ia->ia_maddr,\n\t\t\t    ed_3com_maddr[ptr]);\n\t\t\tgoto err;\n\t\t}\n\t} else\n\t\tia->ia_maddr = ed_3com_maddr[ptr];\n\n#if 0\n\tx = bus_space_read_1(iot, ioh, asicbase + ED_3COM_IDCFR) &\n\t    ED_3COM_IDCFR_IRQ;\n\tif (x == 0 || (x & (x - 1)) != 0)\n\t\tgoto out;\n\tptr = ffs(x) - 1;\n\tif (ia->ia_irq != IRQUNK) {\n\t\tif (ia->ia_irq != ed_3com_irq[ptr]) {\n\t\t\tprintf(\"%s: irq mismatch; kernel configured %d != board configured %d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, ia->ia_irq,\n\t\t\t    ed_3com_irq[ptr]);\n\t\t\tgoto err;\n\t\t}\n\t} else\n\t\tia->ia_irq = ed_3com_irq[ptr];\n#endif\n\n\t/*\n\t * Reset NIC and ASIC.  Enable on-board transceiver throughout reset\n\t * sequence because it'll lock up if the cable isn't connected if we\n\t * don't.\n\t */\n\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_CR,\n\t    ED_3COM_CR_RST | ED_3COM_CR_XSEL);\n\n\t/* Wait for a while, then un-reset it. */\n\tdelay(50);\n\n\t/*\n\t * The 3Com ASIC defaults to rather strange settings for the CR after a\n\t * reset - it's important to set it again after the following outb\n\t * (this is done when we map the PROM below).\n\t */\n\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_CR, ED_3COM_CR_XSEL);\n\n\t/* Wait a bit for the NIC to recover from the reset. */\n\tdelay(5000);\n\n\tsc->vendor = ED_VENDOR_3COM;\n\tsc->type_str = \"3c503\";\n\tsc->mem_shared = 1;\n\tsc->cr_proto = ED_CR_RD2;\n\n\t/*\n\t * Get station address from on-board ROM.\n\t *\n\t * First, map ethernet address PROM over the top of where the NIC\n\t * registers normally appear.\n\t */\n\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_CR,\n\t    ED_3COM_CR_EALO | ED_3COM_CR_XSEL);\n\n\tfor (i = 0; i < ETHER_ADDR_LEN; ++i)\n\t\tsc->sc_arpcom.ac_enaddr[i] = NIC_GET(iot, ioh, nicbase, i);\n\n\t/*\n\t * Unmap PROM - select NIC registers.  The proper setting of the\n\t * tranceiver is set in edinit so that the attach code is given a\n\t * chance to set the default based on a compile-time config option.\n\t */\n\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_CR, ED_3COM_CR_XSEL);\n\n\t/* Determine if this is an 8bit or 16bit board. */\n\n\t/* Select page 0 registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STP);\n\n\t/*\n\t * Attempt to clear WTS bit.  If it doesn't clear, then this is a\n\t * 16-bit board.\n\t */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_DCR, 0);\n\n\t/* Select page 2 registers. */\n\tNIC_PUT(iot, ioh, nicbase,\n\t    ED_P0_CR, ED_CR_RD2 | ED_CR_PAGE_2 | ED_CR_STP);\n\n\t/* The 3c503 forces the WTS bit to a one if this is a 16bit board. */\n\tif (NIC_GET(iot, ioh, nicbase, ED_P2_DCR) & ED_DCR_WTS)\n\t\tisa16bit = 1;\n\telse\n\t\tisa16bit = 0;\n\n\t/* Select page 0 registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P2_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STP);\n\n\tif (bus_space_map(memt, ia->ia_maddr, memsize, 0, &memh))\n\t\tgoto err;\n\tsc->mem_start = 0;\t\t/* offset */\n\tsc->mem_size = memsize;\n\tsc->mem_end = sc->mem_start + memsize;\n\n\t/*\n\t * We have an entire 8k window to put the transmit buffers on the\n\t * 16-bit boards.  But since the 16bit 3c503's shared memory is only\n\t * fast enough to overlap the loading of one full-size packet, trying\n\t * to load more than 2 buffers can actually leave the transmitter idle\n\t * during the load.  So 2 seems the best value.  (Although a mix of\n\t * variable-sized packets might change this assumption.  Nonetheless,\n\t * we optimize for linear transfers of same-size packets.)\n\t */\n\tif (isa16bit) {\n \t\tif (cf->cf_flags & ED_FLAGS_NO_MULTI_BUFFERING)\n\t\t\tsc->txb_cnt = 1;\n\t\telse\n\t\t\tsc->txb_cnt = 2;\n\n\t\tsc->tx_page_start = ED_3COM_TX_PAGE_OFFSET_16BIT;\n\t\tsc->rec_page_start = ED_3COM_RX_PAGE_OFFSET_16BIT;\n\t\tsc->rec_page_stop =\n\t\t    (memsize >> ED_PAGE_SHIFT) + ED_3COM_RX_PAGE_OFFSET_16BIT;\n\t\tsc->mem_ring = sc->mem_start;\n\t} else {\n\t\tsc->txb_cnt = 1;\n\t\tsc->tx_page_start = ED_3COM_TX_PAGE_OFFSET_8BIT;\n\t\tsc->rec_page_start =\n\t\t    ED_TXBUF_SIZE + ED_3COM_TX_PAGE_OFFSET_8BIT;\n\t\tsc->rec_page_stop =\n\t\t    (memsize >> ED_PAGE_SHIFT) + ED_3COM_TX_PAGE_OFFSET_8BIT;\n\t\tsc->mem_ring =\n\t\t    sc->mem_start + (ED_TXBUF_SIZE << ED_PAGE_SHIFT);\n\t}\n\n\tsc->isa16bit = isa16bit;\n\n\t/*\n\t * Initialize GA page start/stop registers.  Probably only needed if\n\t * doing DMA, but what the Hell.\n\t */\n\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_PSTR, sc->rec_page_start);\n\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_PSPR, sc->rec_page_stop);\n\n\t/* Set IRQ.  3c503 only allows a choice of irq 3-5 or 9. */\n\tswitch (ia->ia_irq) {\n\tcase 9:\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_IDCFR,\n\t\t    ED_3COM_IDCFR_IRQ2);\n\t\tbreak;\n\tcase 3:\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_IDCFR,\n\t\t    ED_3COM_IDCFR_IRQ3);\n\t\tbreak;\n\tcase 4:\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_IDCFR,\n\t\t    ED_3COM_IDCFR_IRQ4);\n\t\tbreak;\n\tcase 5:\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_IDCFR,\n\t\t    ED_3COM_IDCFR_IRQ5);\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: invalid irq configuration (%d) must be 3-5 or 9 for 3c503\\n\",\n\t\t    sc->sc_dev.dv_xname, ia->ia_irq);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Initialize GA configuration register.  Set bank and enable shared\n\t * mem.\n\t */\n\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_GACFR,\n\t    ED_3COM_GACFR_RSEL | ED_3COM_GACFR_MBS0);\n\n\t/*\n\t * Initialize \"Vector Pointer\" registers. These gawd-awful things are\n\t * compared to 20 bits of the address on ISA, and if they match, the\n\t * shared memory is disabled. We set them to 0xffff0...allegedly the\n\t * reset vector.\n\t */\n\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_VPTR2, 0xff);\n\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_VPTR1, 0xff);\n\tbus_space_write_1(iot, ioh, asicbase + ED_3COM_VPTR0, 0x00);\n\n\t/* Now zero memory and verify that it is clear. */\n\tif (isa16bit) {\n\t\tfor (i = 0; i < memsize; i += 2)\n\t\t\tbus_space_write_2(memt, memh, sc->mem_start + i, 0);\n\t} else {\n\t\tfor (i = 0; i < memsize; ++i)\n\t\t\tbus_space_write_1(memt, memh, sc->mem_start + i, 0);\n\t}\n\n\tmemfail = 0;\n\tif (isa16bit) {\n\t\tfor (i = 0; i < memsize; i += 2) {\n\t\t\tif (bus_space_read_2(memt, memh, sc->mem_start + i)) {\n\t\t\t\tmemfail = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < memsize; ++i) {\n\t\t\tif (bus_space_read_1(memt, memh, sc->mem_start + i)) {\n\t\t\t\tmemfail = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (memfail) {\n\t\tprintf(\"%s: failed to clear shared memory at %x - \"\n\t\t    \"check configuration\\n\",\n\t\t    sc->sc_dev.dv_xname,\n\t\t    (ia->ia_maddr + sc->mem_start + i));\n\t\tgoto out;\n\t}\n\n\tia->ia_msize = memsize;\n\tia->ia_iosize = ED_3COM_IO_PORTS;\n\n\t/*\n\t * XXX Sould always unmap, but we can't yet.\n\t * XXX Need to squish \"indirect\" first.\n\t */\n\tsc->sc_iot = iot;\n\tsc->sc_memt = memt;\n\tsc->sc_ioh = ioh;\n\tsc->sc_memh = memh;\n\treturn 1;\n\n out:\n\tbus_space_unmap(memt, memh, memsize);\n err:\n\tbus_space_unmap(iot, ioh, ED_3COM_IO_PORTS);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ed_find_WD80x3",
          "args": [
            "sc",
            "cf",
            "ia"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "ed_find_WD80x3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
          "lines": "626-1070",
          "snippet": "int\ned_find_WD80x3(sc, cf, ia)\n\tstruct ed_softc *sc;\n\tstruct cfdata *cf;\n\tstruct isa_attach_args *ia;\n{\n\tbus_space_tag_t iot;\n\tbus_space_tag_t memt;\n\tbus_space_handle_t ioh;\n\tbus_space_handle_t delaybah = ia->ia_delaybah;\n\tbus_space_handle_t memh;\n\tu_int memsize;\n\tu_char iptr, isa16bit, sum, wd790rev;\n\tint i, rv, memfail, mapped_mem = 0;\n\tint asicbase, nicbase;\n\n\tiot = ia->ia_iot;\n\tmemt = ia->ia_memt;\n\trv = 0;\n\n\t/* Set initial values for width/size. */\n\tmemsize = 8192;\n\tisa16bit = 0;\n\n\tif (bus_space_map(iot, ia->ia_iobase, ED_WD_IO_PORTS, 0, &ioh))\n\t\treturn (0);\n\n\tsc->asic_base = asicbase = 0;\n\tsc->nic_base = nicbase = asicbase + ED_WD_NIC_OFFSET;\n\tsc->is790 = 0;\n\n#ifdef TOSH_ETHER\n\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR, ED_WD_MSR_POW);\n\tdelay(10000);\n#endif\n\n\t/*\n\t * Attempt to do a checksum over the station address PROM.  If it\n\t * fails, it's probably not a SMC/WD board.  There is a problem with\n\t * this, though: some clone WD boards don't pass the checksum test.\n\t * Danpex boards for one.\n\t */\n\tfor (sum = 0, i = 0; i < 8; ++i)\n\t\tsum += bus_space_read_1(iot, ioh, asicbase + ED_WD_PROM + i);\n\n\tif (sum != ED_WD_ROM_CHECKSUM_TOTAL) {\n\t\t/*\n\t\t * Checksum is invalid.  This often happens with cheap WD8003E\n\t\t * clones.  In this case, the checksum byte (the eighth byte)\n\t\t * seems to always be zero.\n\t\t */\n\t\tif (bus_space_read_1(iot, ioh, asicbase + ED_WD_CARD_ID) !=\n\t\t    ED_TYPE_WD8003E ||\n\t\t    bus_space_read_1(iot, ioh, asicbase + ED_WD_PROM + 7) != 0)\n\t\t\tgoto out;\n\t}\n\n\t/* Reset card to force it into a known state. */\n#ifdef TOSH_ETHER\n\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR,\n\t    ED_WD_MSR_RST | ED_WD_MSR_POW);\n#else\n\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR, ED_WD_MSR_RST);\n#endif\n\tdelay(100);\n\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR,\n\t    bus_space_read_1(iot, ioh, asicbase + ED_WD_MSR) & ~ED_WD_MSR_RST);\n\t/* Wait in the case this card is reading it's EEROM. */\n\tdelay(5000);\n\n\tsc->vendor = ED_VENDOR_WD_SMC;\n\tsc->type = bus_space_read_1(iot, ioh, asicbase + ED_WD_CARD_ID);\n\n\tswitch (sc->type) {\n\tcase ED_TYPE_WD8003S:\n\t\tsc->type_str = \"WD8003S\";\n\t\tbreak;\n\tcase ED_TYPE_WD8003E:\n\t\tsc->type_str = \"WD8003E\";\n\t\tbreak;\n\tcase ED_TYPE_WD8003EB:\n\t\tsc->type_str = \"WD8003EB\";\n\t\tbreak;\n\tcase ED_TYPE_WD8003W:\n\t\tsc->type_str = \"WD8003W\";\n\t\tbreak;\n\tcase ED_TYPE_WD8013EBT:\n\t\tsc->type_str = \"WD8013EBT\";\n\t\tmemsize = 16384;\n\t\tisa16bit = 1;\n\t\tbreak;\n\tcase ED_TYPE_WD8013W:\n\t\tsc->type_str = \"WD8013W\";\n\t\tmemsize = 16384;\n\t\tisa16bit = 1;\n\t\tbreak;\n\tcase ED_TYPE_WD8013EP:\t\t/* also WD8003EP */\n\t\tif (bus_space_read_1(iot, ioh, asicbase + ED_WD_ICR)\n\t\t    & ED_WD_ICR_16BIT) {\n\t\t\tisa16bit = 1;\n\t\t\tmemsize = 16384;\n\t\t\tsc->type_str = \"WD8013EP\";\n\t\t} else\n\t\t\tsc->type_str = \"WD8003EP\";\n\t\tbreak;\n\tcase ED_TYPE_WD8013WC:\n\t\tsc->type_str = \"WD8013WC\";\n\t\tmemsize = 16384;\n\t\tisa16bit = 1;\n\t\tbreak;\n\tcase ED_TYPE_WD8013EBP:\n\t\tsc->type_str = \"WD8013EBP\";\n\t\tmemsize = 16384;\n\t\tisa16bit = 1;\n\t\tbreak;\n\tcase ED_TYPE_WD8013EPC:\n\t\tsc->type_str = \"WD8013EPC\";\n\t\tmemsize = 16384;\n\t\tisa16bit = 1;\n\t\tbreak;\n\tcase ED_TYPE_SMC8216C:\n\tcase ED_TYPE_SMC8216T:\n\t\twd790rev = bus_space_read_1(iot, ioh, asicbase + ED_WD790_REV);\n\t\tif (wd790rev < ED_WD795)\n\t\t\tsc->type_str = (sc->type == ED_TYPE_SMC8216C) ?\n\t\t\t    \"SMC8216/SMC8216C\" : \"SMC8216T\";\n\t\telse {\n\t\t\tsc->type_str = \"SMC8416C/SMC8416BT\";\n\t\t\tif (bus_space_read_1(iot, ioh,\n\t\t\t\t\t     asicbase + ED_WD795_PIO)) {\n\t\t\t\tprintf (\"%s: detected SMC8416 in PIO mode, unsupported hardware configuration.\\n\", sc->sc_dev.dv_xname);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD790_HWR,\n\t\t    bus_space_read_1(iot, ioh, asicbase + ED_WD790_HWR)\n\t\t    | ED_WD790_HWR_SWH);\n\t\tswitch (bus_space_read_1(iot, ioh, asicbase + ED_WD790_RAR) &\n\t\t    ED_WD790_RAR_SZ64) {\n\t\tcase ED_WD790_RAR_SZ64:\n\t\t\tmemsize = 65536;\n\t\t\tbreak;\n\t\tcase ED_WD790_RAR_SZ32:\n\t\t\tmemsize = 32768;\n\t\t\tbreak;\n\t\tcase ED_WD790_RAR_SZ16:\n\t\t\tmemsize = 16384;\n\t\t\tbreak;\n\t\tcase ED_WD790_RAR_SZ8:\n\t\t\tmemsize = 8192;\n\t\t\tbreak;\n\t\t}\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD790_HWR,\n\t\t    bus_space_read_1(iot, ioh, asicbase + ED_WD790_HWR) &\n\t\t    ~ED_WD790_HWR_SWH);\n\n\t\tisa16bit = 1;\n\t\tsc->is790 = 1;\n\t\tbreak;\n#ifdef TOSH_ETHER\n\tcase ED_TYPE_TOSHIBA1:\n\t\tsc->type_str = \"Toshiba1\";\n\t\tmemsize = 32768;\n\t\tisa16bit = 1;\n\t\tbreak;\n\tcase ED_TYPE_TOSHIBA4:\n\t\tsc->type_str = \"Toshiba4\";\n\t\tmemsize = 32768;\n\t\tisa16bit = 1;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tsc->type_str = NULL;\n\t\tbreak;\n\t}\n\t/*\n\t * Make some adjustments to initial values depending on what is found\n\t * in the ICR.\n\t */\n\tif (isa16bit && (sc->type != ED_TYPE_WD8013EBT) &&\n#ifdef TOSH_ETHER\n\t    (sc->type != ED_TYPE_TOSHIBA1) && (sc->type != ED_TYPE_TOSHIBA4) &&\n#endif\n\t    ((bus_space_read_1(iot, ioh, asicbase + ED_WD_ICR) &\n\t    ED_WD_ICR_16BIT) == 0)) {\n\t\tisa16bit = 0;\n\t\tmemsize = 8192;\n\t}\n\n#ifdef ED_DEBUG\n\tprintf(\"type=%x type_str=%s isa16bit=%d memsize=%d id_msize=%d\\n\",\n\t    sc->type, sc->type_str ?: \"unknown\", isa16bit, memsize,\n\t    ia->ia_msize);\n\tfor (i = 0; i < 8; i++)\n\t\tprintf(\"%x -> %x\\n\", i, bus_space_read_1(iot, ioh,\n\t\t    asicbase + i));\n#endif\n\t/* Allow the user to override the autoconfiguration. */\n\tif (ia->ia_msize)\n\t\tmemsize = ia->ia_msize;\n\t/*\n\t * (Note that if the user specifies both of the following flags that\n\t * '8-bit' mode intentionally has precedence.)\n\t */\n\tif (cf->cf_flags & ED_FLAGS_FORCE_16BIT_MODE)\n\t\tisa16bit = 1;\n\tif (cf->cf_flags & ED_FLAGS_FORCE_8BIT_MODE)\n\t\tisa16bit = 0;\n\n\t/*\n\t * If possible, get the assigned interrupt number from the card and\n\t * use it.\n\t */\n\tif (sc->is790) {\n\t\tu_char x;\n\n\t\t/* Assemble together the encoded interrupt number. */\n\t\tbus_space_write_1(iot, ioh, ED_WD790_HWR,\n\t\t    bus_space_read_1(iot, ioh, ED_WD790_HWR) |\n\t\t    ED_WD790_HWR_SWH);\n\t\tx = bus_space_read_1(iot, ioh, ED_WD790_GCR);\n\t\tiptr = ((x & ED_WD790_GCR_IR2) >> 4) |\n\t\t    ((x & (ED_WD790_GCR_IR1|ED_WD790_GCR_IR0)) >> 2);\n\t\tbus_space_write_1(iot, ioh, ED_WD790_HWR,\n\t\t    bus_space_read_1(iot, ioh, ED_WD790_HWR) &\n\t\t    ~ED_WD790_HWR_SWH);\n\t\t/*\n\t\t * Translate it using translation table, and check for\n\t\t * correctness.\n\t\t */\n\t\tif (ia->ia_irq != IRQUNK) {\n\t\t\tif (ia->ia_irq != ed_wd790_irq[iptr]) {\n\t\t\t\tprintf(\"%s: irq mismatch; kernel configured %d != board configured %d\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, ia->ia_irq,\n\t\t\t\t    ed_wd790_irq[iptr]);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else\n\t\t\tia->ia_irq = ed_wd790_irq[iptr];\n\t\t/* Enable the interrupt. */\n\t\tbus_space_write_1(iot, ioh, ED_WD790_ICR,\n\t\t    bus_space_read_1(iot, ioh, ED_WD790_ICR) |\n\t\t    ED_WD790_ICR_EIL);\n\t} else if (sc->type & ED_WD_SOFTCONFIG) {\n\t\t/* Assemble together the encoded interrupt number. */\n\t\tiptr = (bus_space_read_1(iot, ioh, ED_WD_ICR) &\n\t\t    ED_WD_ICR_IR2) |\n\t\t    ((bus_space_read_1(iot, ioh, ED_WD_IRR) &\n\t\t      (ED_WD_IRR_IR0 | ED_WD_IRR_IR1)) >> 5);\n\t\t/*\n\t\t * Translate it using translation table, and check for\n\t\t * correctness.\n\t\t */\n\t\tif (ia->ia_irq != IRQUNK) {\n\t\t\tif (ia->ia_irq != ed_wd584_irq[iptr]) {\n\t\t\t\tprintf(\"%s: irq mismatch; kernel configured %d != board configured %d\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, ia->ia_irq,\n\t\t\t\t    ed_wd584_irq[iptr]);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else\n\t\t\tia->ia_irq = ed_wd584_irq[iptr];\n\t\t/* Enable the interrupt. */\n\t\tbus_space_write_1(iot, ioh, ED_WD_IRR,\n\t\t    bus_space_read_1(iot, ioh, ED_WD_IRR) | ED_WD_IRR_IEN);\n\t} else {\n\t\tif (ia->ia_irq == IRQUNK) {\n\t\t\tprintf(\"%s: %s does not have soft configuration\\n\",\n\t\t\t    sc->sc_dev.dv_xname, sc->type_str);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* XXX Figure out the shared memory address. */\n\n\tif (ia->ia_maddr == MADDRUNK)\n\t\tgoto out;\n\tsc->isa16bit = isa16bit;\n\tsc->mem_shared = 1;\n\tia->ia_msize = memsize;\n\tif (bus_space_map(memt, ia->ia_maddr, memsize, 0, &memh))\n\t\tgoto out;\n\tmapped_mem = 1;\n\tsc->mem_start = 0;\t/* offset */\n\n\t/* Allocate one xmit buffer if < 16k, two buffers otherwise. */\n\tif ((memsize < 16384) || (cf->cf_flags & ED_FLAGS_NO_MULTI_BUFFERING))\n\t\tsc->txb_cnt = 1;\n\telse\n\t\tsc->txb_cnt = 2;\n\n\tsc->tx_page_start = ED_WD_PAGE_OFFSET;\n\tsc->rec_page_start = sc->tx_page_start + sc->txb_cnt * ED_TXBUF_SIZE;\n\tsc->rec_page_stop = sc->tx_page_start + (memsize >> ED_PAGE_SHIFT);\n\tsc->mem_ring = sc->mem_start + (sc->rec_page_start << ED_PAGE_SHIFT);\n\tsc->mem_size = memsize;\n\tsc->mem_end = sc->mem_start + memsize;\n\n\t/* Get station address from on-board ROM. */\n\tfor (i = 0; i < ETHER_ADDR_LEN; ++i)\n\t\tsc->sc_arpcom.ac_enaddr[i] =\n\t\t    bus_space_read_1(iot, ioh, asicbase + ED_WD_PROM + i);\n\n\t/*\n\t * Set upper address bits and 8/16 bit access to shared memory.\n\t */\n\tif (isa16bit) {\n\t\tif (sc->is790) {\n\t\t\tsc->wd_laar_proto =\n\t\t\t    bus_space_read_1(iot, ioh, asicbase + ED_WD_LAAR) &\n\t\t\t    ~ED_WD_LAAR_M16EN;\n\t\t} else {\n\t\t\tsc->wd_laar_proto = ED_WD_LAAR_L16EN |\n\t\t\t    ((ia->ia_maddr >> 19) & ED_WD_LAAR_ADDRHI);\n\t\t}\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_LAAR,\n\t\t    sc->wd_laar_proto | ED_WD_LAAR_M16EN);\n\t} else  {\n\t\tif ((sc->type & ED_WD_SOFTCONFIG) ||\n#ifdef TOSH_ETHER\n\t\t    (sc->type == ED_TYPE_TOSHIBA1) ||\n\t\t    (sc->type == ED_TYPE_TOSHIBA4) ||\n#endif\n\t\t    ((sc->type == ED_TYPE_WD8013EBT) && !sc->is790)) {\n\t\t\tsc->wd_laar_proto =\n\t\t\t    ((ia->ia_maddr >> 19) &\n\t\t\t    ED_WD_LAAR_ADDRHI);\n\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_LAAR,\n\t\t\t    sc->wd_laar_proto);\n\t\t}\n\t}\n\n\t/*\n\t * Set address and enable interface shared memory.\n\t */\n\tif (!sc->is790) {\n#ifdef TOSH_ETHER\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR + 1,\n\t\t    ((ia->ia_maddr >> 8) & 0xe0) | 4);\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR + 2,\n\t\t    ((ia->ia_maddr >> 16) & 0x0f));\n\t\tsc->wd_msr_proto = ED_WD_MSR_POW;\n#else\n\t\tsc->wd_msr_proto =\n\t\t    (ia->ia_maddr >> 13) & ED_WD_MSR_ADDR;\n#endif\n\t\tsc->cr_proto = ED_CR_RD2;\n\t} else {\n\t\tbus_space_write_1(iot, ioh, asicbase + 0x04,\n\t\t    bus_space_read_1(iot, ioh, asicbase + 0x04) | 0x80);\n\t\tbus_space_write_1(iot, ioh, asicbase + 0x0b,\n\t\t    ((ia->ia_maddr >> 13) & 0x0f) |\n\t\t    ((ia->ia_maddr >> 11) & 0x40) |\n\t\t    (bus_space_read_1(iot, ioh, asicbase + 0x0b) & 0xb0));\n\t\tbus_space_write_1(iot, ioh, asicbase + 0x04,\n\t\t    bus_space_read_1(iot, ioh, asicbase + 0x04) & ~0x80);\n\t\tsc->wd_msr_proto = 0x00;\n\t\tsc->cr_proto = 0;\n\t}\n\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR,\n\t    sc->wd_msr_proto | ED_WD_MSR_MENB);\n\n\t(void) bus_space_read_1(iot, delaybah, 0);\n\t(void) bus_space_read_1(iot, delaybah, 0);\n\n\t/* Now zero memory and verify that it is clear. */\n\tif (isa16bit) {\n\t\tfor (i = 0; i < memsize; i += 2)\n\t\t\tbus_space_write_2(memt, memh, sc->mem_start + i, 0);\n\t} else {\n\t\tfor (i = 0; i < memsize; ++i)\n\t\t\tbus_space_write_1(memt, memh, sc->mem_start + i, 0);\n\t}\n\n\tmemfail = 0;\n\tif (isa16bit) {\n\t\tfor (i = 0; i < memsize; i += 2) {\n\t\t\tif (bus_space_read_2(memt, memh, sc->mem_start + i)) {\n\t\t\t\tmemfail = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < memsize; ++i) {\n\t\t\tif (bus_space_read_1(memt, memh, sc->mem_start + i)) {\n\t\t\t\tmemfail = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (memfail) {\n\t\tprintf(\"%s: failed to clear shared memory at %x - \"\n\t\t    \"check configuration\\n\",\n\t\t    sc->sc_dev.dv_xname,\n\t\t    (ia->ia_maddr + sc->mem_start + i));\n\n\t\t/* Disable 16 bit access to shared memory. */\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR,\n\t\t    sc->wd_msr_proto);\n\t\tif (isa16bit)\n\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_LAAR,\n\t\t\t    sc->wd_laar_proto);\n\t\t(void) bus_space_read_1(iot, delaybah, 0);\n\t\t(void) bus_space_read_1(iot, delaybah, 0);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Disable 16bit access to shared memory - we leave it disabled\n\t * so that 1) machines reboot properly when the board is set 16\n\t * 16 bit mode and there are conflicting 8bit devices/ROMS in\n\t * the same 128k address space as this boards shared memory,\n\t * and 2) so that other 8 bit devices with shared memory can be\n\t * used in this 128k region, too.\n\t */\n\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR, sc->wd_msr_proto);\n\tif (isa16bit)\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_LAAR,\n\t\t    sc->wd_laar_proto);\n\t(void) bus_space_read_1(iot, delaybah, 0);\n\t(void) bus_space_read_1(iot, delaybah, 0);\n\n\tia->ia_iosize = ED_WD_IO_PORTS;\n\trv = 1;\n\n out:\n\t/*\n\t * XXX Should always unmap, but we can't yet.\n\t * XXX Need to squish \"indirect\" first.\n\t */\n\tif (rv == 0) {\n\t\tbus_space_unmap(iot, ioh, ED_WD_IO_PORTS);\n\t\tif (mapped_mem)\n\t\t\tbus_space_unmap(memt, memh, memsize);\n\t} else {\n\t\t/* XXX this is all \"indirect\" brokenness */\n\t\tsc->sc_iot = iot;\n\t\tsc->sc_memt = memt;\n\t\tsc->sc_ioh = ioh;\n\t\tsc->sc_memh = memh;\n\t}\n\treturn (rv);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/isa/if_edreg.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"ed.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tETHER_ADDR_LEN\t6"
          ],
          "globals_used": [
            "int ed_find_WD80x3",
            "int ed_wd584_irq[] = { 9, 3, 5, 7, 10, 11, 15, 4 };",
            "int ed_wd790_irq[] = { IRQUNK, 9, 3, 5, 7, 10, 11, 15 };",
            "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\n#define\tETHER_ADDR_LEN\t6\n\nint ed_find_WD80x3;\nint ed_wd584_irq[] = { 9, 3, 5, 7, 10, 11, 15, 4 };\nint ed_wd790_irq[] = { IRQUNK, 9, 3, 5, 7, 10, 11, 15 };\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nint\ned_find_WD80x3(sc, cf, ia)\n\tstruct ed_softc *sc;\n\tstruct cfdata *cf;\n\tstruct isa_attach_args *ia;\n{\n\tbus_space_tag_t iot;\n\tbus_space_tag_t memt;\n\tbus_space_handle_t ioh;\n\tbus_space_handle_t delaybah = ia->ia_delaybah;\n\tbus_space_handle_t memh;\n\tu_int memsize;\n\tu_char iptr, isa16bit, sum, wd790rev;\n\tint i, rv, memfail, mapped_mem = 0;\n\tint asicbase, nicbase;\n\n\tiot = ia->ia_iot;\n\tmemt = ia->ia_memt;\n\trv = 0;\n\n\t/* Set initial values for width/size. */\n\tmemsize = 8192;\n\tisa16bit = 0;\n\n\tif (bus_space_map(iot, ia->ia_iobase, ED_WD_IO_PORTS, 0, &ioh))\n\t\treturn (0);\n\n\tsc->asic_base = asicbase = 0;\n\tsc->nic_base = nicbase = asicbase + ED_WD_NIC_OFFSET;\n\tsc->is790 = 0;\n\n#ifdef TOSH_ETHER\n\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR, ED_WD_MSR_POW);\n\tdelay(10000);\n#endif\n\n\t/*\n\t * Attempt to do a checksum over the station address PROM.  If it\n\t * fails, it's probably not a SMC/WD board.  There is a problem with\n\t * this, though: some clone WD boards don't pass the checksum test.\n\t * Danpex boards for one.\n\t */\n\tfor (sum = 0, i = 0; i < 8; ++i)\n\t\tsum += bus_space_read_1(iot, ioh, asicbase + ED_WD_PROM + i);\n\n\tif (sum != ED_WD_ROM_CHECKSUM_TOTAL) {\n\t\t/*\n\t\t * Checksum is invalid.  This often happens with cheap WD8003E\n\t\t * clones.  In this case, the checksum byte (the eighth byte)\n\t\t * seems to always be zero.\n\t\t */\n\t\tif (bus_space_read_1(iot, ioh, asicbase + ED_WD_CARD_ID) !=\n\t\t    ED_TYPE_WD8003E ||\n\t\t    bus_space_read_1(iot, ioh, asicbase + ED_WD_PROM + 7) != 0)\n\t\t\tgoto out;\n\t}\n\n\t/* Reset card to force it into a known state. */\n#ifdef TOSH_ETHER\n\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR,\n\t    ED_WD_MSR_RST | ED_WD_MSR_POW);\n#else\n\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR, ED_WD_MSR_RST);\n#endif\n\tdelay(100);\n\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR,\n\t    bus_space_read_1(iot, ioh, asicbase + ED_WD_MSR) & ~ED_WD_MSR_RST);\n\t/* Wait in the case this card is reading it's EEROM. */\n\tdelay(5000);\n\n\tsc->vendor = ED_VENDOR_WD_SMC;\n\tsc->type = bus_space_read_1(iot, ioh, asicbase + ED_WD_CARD_ID);\n\n\tswitch (sc->type) {\n\tcase ED_TYPE_WD8003S:\n\t\tsc->type_str = \"WD8003S\";\n\t\tbreak;\n\tcase ED_TYPE_WD8003E:\n\t\tsc->type_str = \"WD8003E\";\n\t\tbreak;\n\tcase ED_TYPE_WD8003EB:\n\t\tsc->type_str = \"WD8003EB\";\n\t\tbreak;\n\tcase ED_TYPE_WD8003W:\n\t\tsc->type_str = \"WD8003W\";\n\t\tbreak;\n\tcase ED_TYPE_WD8013EBT:\n\t\tsc->type_str = \"WD8013EBT\";\n\t\tmemsize = 16384;\n\t\tisa16bit = 1;\n\t\tbreak;\n\tcase ED_TYPE_WD8013W:\n\t\tsc->type_str = \"WD8013W\";\n\t\tmemsize = 16384;\n\t\tisa16bit = 1;\n\t\tbreak;\n\tcase ED_TYPE_WD8013EP:\t\t/* also WD8003EP */\n\t\tif (bus_space_read_1(iot, ioh, asicbase + ED_WD_ICR)\n\t\t    & ED_WD_ICR_16BIT) {\n\t\t\tisa16bit = 1;\n\t\t\tmemsize = 16384;\n\t\t\tsc->type_str = \"WD8013EP\";\n\t\t} else\n\t\t\tsc->type_str = \"WD8003EP\";\n\t\tbreak;\n\tcase ED_TYPE_WD8013WC:\n\t\tsc->type_str = \"WD8013WC\";\n\t\tmemsize = 16384;\n\t\tisa16bit = 1;\n\t\tbreak;\n\tcase ED_TYPE_WD8013EBP:\n\t\tsc->type_str = \"WD8013EBP\";\n\t\tmemsize = 16384;\n\t\tisa16bit = 1;\n\t\tbreak;\n\tcase ED_TYPE_WD8013EPC:\n\t\tsc->type_str = \"WD8013EPC\";\n\t\tmemsize = 16384;\n\t\tisa16bit = 1;\n\t\tbreak;\n\tcase ED_TYPE_SMC8216C:\n\tcase ED_TYPE_SMC8216T:\n\t\twd790rev = bus_space_read_1(iot, ioh, asicbase + ED_WD790_REV);\n\t\tif (wd790rev < ED_WD795)\n\t\t\tsc->type_str = (sc->type == ED_TYPE_SMC8216C) ?\n\t\t\t    \"SMC8216/SMC8216C\" : \"SMC8216T\";\n\t\telse {\n\t\t\tsc->type_str = \"SMC8416C/SMC8416BT\";\n\t\t\tif (bus_space_read_1(iot, ioh,\n\t\t\t\t\t     asicbase + ED_WD795_PIO)) {\n\t\t\t\tprintf (\"%s: detected SMC8416 in PIO mode, unsupported hardware configuration.\\n\", sc->sc_dev.dv_xname);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD790_HWR,\n\t\t    bus_space_read_1(iot, ioh, asicbase + ED_WD790_HWR)\n\t\t    | ED_WD790_HWR_SWH);\n\t\tswitch (bus_space_read_1(iot, ioh, asicbase + ED_WD790_RAR) &\n\t\t    ED_WD790_RAR_SZ64) {\n\t\tcase ED_WD790_RAR_SZ64:\n\t\t\tmemsize = 65536;\n\t\t\tbreak;\n\t\tcase ED_WD790_RAR_SZ32:\n\t\t\tmemsize = 32768;\n\t\t\tbreak;\n\t\tcase ED_WD790_RAR_SZ16:\n\t\t\tmemsize = 16384;\n\t\t\tbreak;\n\t\tcase ED_WD790_RAR_SZ8:\n\t\t\tmemsize = 8192;\n\t\t\tbreak;\n\t\t}\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD790_HWR,\n\t\t    bus_space_read_1(iot, ioh, asicbase + ED_WD790_HWR) &\n\t\t    ~ED_WD790_HWR_SWH);\n\n\t\tisa16bit = 1;\n\t\tsc->is790 = 1;\n\t\tbreak;\n#ifdef TOSH_ETHER\n\tcase ED_TYPE_TOSHIBA1:\n\t\tsc->type_str = \"Toshiba1\";\n\t\tmemsize = 32768;\n\t\tisa16bit = 1;\n\t\tbreak;\n\tcase ED_TYPE_TOSHIBA4:\n\t\tsc->type_str = \"Toshiba4\";\n\t\tmemsize = 32768;\n\t\tisa16bit = 1;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tsc->type_str = NULL;\n\t\tbreak;\n\t}\n\t/*\n\t * Make some adjustments to initial values depending on what is found\n\t * in the ICR.\n\t */\n\tif (isa16bit && (sc->type != ED_TYPE_WD8013EBT) &&\n#ifdef TOSH_ETHER\n\t    (sc->type != ED_TYPE_TOSHIBA1) && (sc->type != ED_TYPE_TOSHIBA4) &&\n#endif\n\t    ((bus_space_read_1(iot, ioh, asicbase + ED_WD_ICR) &\n\t    ED_WD_ICR_16BIT) == 0)) {\n\t\tisa16bit = 0;\n\t\tmemsize = 8192;\n\t}\n\n#ifdef ED_DEBUG\n\tprintf(\"type=%x type_str=%s isa16bit=%d memsize=%d id_msize=%d\\n\",\n\t    sc->type, sc->type_str ?: \"unknown\", isa16bit, memsize,\n\t    ia->ia_msize);\n\tfor (i = 0; i < 8; i++)\n\t\tprintf(\"%x -> %x\\n\", i, bus_space_read_1(iot, ioh,\n\t\t    asicbase + i));\n#endif\n\t/* Allow the user to override the autoconfiguration. */\n\tif (ia->ia_msize)\n\t\tmemsize = ia->ia_msize;\n\t/*\n\t * (Note that if the user specifies both of the following flags that\n\t * '8-bit' mode intentionally has precedence.)\n\t */\n\tif (cf->cf_flags & ED_FLAGS_FORCE_16BIT_MODE)\n\t\tisa16bit = 1;\n\tif (cf->cf_flags & ED_FLAGS_FORCE_8BIT_MODE)\n\t\tisa16bit = 0;\n\n\t/*\n\t * If possible, get the assigned interrupt number from the card and\n\t * use it.\n\t */\n\tif (sc->is790) {\n\t\tu_char x;\n\n\t\t/* Assemble together the encoded interrupt number. */\n\t\tbus_space_write_1(iot, ioh, ED_WD790_HWR,\n\t\t    bus_space_read_1(iot, ioh, ED_WD790_HWR) |\n\t\t    ED_WD790_HWR_SWH);\n\t\tx = bus_space_read_1(iot, ioh, ED_WD790_GCR);\n\t\tiptr = ((x & ED_WD790_GCR_IR2) >> 4) |\n\t\t    ((x & (ED_WD790_GCR_IR1|ED_WD790_GCR_IR0)) >> 2);\n\t\tbus_space_write_1(iot, ioh, ED_WD790_HWR,\n\t\t    bus_space_read_1(iot, ioh, ED_WD790_HWR) &\n\t\t    ~ED_WD790_HWR_SWH);\n\t\t/*\n\t\t * Translate it using translation table, and check for\n\t\t * correctness.\n\t\t */\n\t\tif (ia->ia_irq != IRQUNK) {\n\t\t\tif (ia->ia_irq != ed_wd790_irq[iptr]) {\n\t\t\t\tprintf(\"%s: irq mismatch; kernel configured %d != board configured %d\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, ia->ia_irq,\n\t\t\t\t    ed_wd790_irq[iptr]);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else\n\t\t\tia->ia_irq = ed_wd790_irq[iptr];\n\t\t/* Enable the interrupt. */\n\t\tbus_space_write_1(iot, ioh, ED_WD790_ICR,\n\t\t    bus_space_read_1(iot, ioh, ED_WD790_ICR) |\n\t\t    ED_WD790_ICR_EIL);\n\t} else if (sc->type & ED_WD_SOFTCONFIG) {\n\t\t/* Assemble together the encoded interrupt number. */\n\t\tiptr = (bus_space_read_1(iot, ioh, ED_WD_ICR) &\n\t\t    ED_WD_ICR_IR2) |\n\t\t    ((bus_space_read_1(iot, ioh, ED_WD_IRR) &\n\t\t      (ED_WD_IRR_IR0 | ED_WD_IRR_IR1)) >> 5);\n\t\t/*\n\t\t * Translate it using translation table, and check for\n\t\t * correctness.\n\t\t */\n\t\tif (ia->ia_irq != IRQUNK) {\n\t\t\tif (ia->ia_irq != ed_wd584_irq[iptr]) {\n\t\t\t\tprintf(\"%s: irq mismatch; kernel configured %d != board configured %d\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname, ia->ia_irq,\n\t\t\t\t    ed_wd584_irq[iptr]);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else\n\t\t\tia->ia_irq = ed_wd584_irq[iptr];\n\t\t/* Enable the interrupt. */\n\t\tbus_space_write_1(iot, ioh, ED_WD_IRR,\n\t\t    bus_space_read_1(iot, ioh, ED_WD_IRR) | ED_WD_IRR_IEN);\n\t} else {\n\t\tif (ia->ia_irq == IRQUNK) {\n\t\t\tprintf(\"%s: %s does not have soft configuration\\n\",\n\t\t\t    sc->sc_dev.dv_xname, sc->type_str);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* XXX Figure out the shared memory address. */\n\n\tif (ia->ia_maddr == MADDRUNK)\n\t\tgoto out;\n\tsc->isa16bit = isa16bit;\n\tsc->mem_shared = 1;\n\tia->ia_msize = memsize;\n\tif (bus_space_map(memt, ia->ia_maddr, memsize, 0, &memh))\n\t\tgoto out;\n\tmapped_mem = 1;\n\tsc->mem_start = 0;\t/* offset */\n\n\t/* Allocate one xmit buffer if < 16k, two buffers otherwise. */\n\tif ((memsize < 16384) || (cf->cf_flags & ED_FLAGS_NO_MULTI_BUFFERING))\n\t\tsc->txb_cnt = 1;\n\telse\n\t\tsc->txb_cnt = 2;\n\n\tsc->tx_page_start = ED_WD_PAGE_OFFSET;\n\tsc->rec_page_start = sc->tx_page_start + sc->txb_cnt * ED_TXBUF_SIZE;\n\tsc->rec_page_stop = sc->tx_page_start + (memsize >> ED_PAGE_SHIFT);\n\tsc->mem_ring = sc->mem_start + (sc->rec_page_start << ED_PAGE_SHIFT);\n\tsc->mem_size = memsize;\n\tsc->mem_end = sc->mem_start + memsize;\n\n\t/* Get station address from on-board ROM. */\n\tfor (i = 0; i < ETHER_ADDR_LEN; ++i)\n\t\tsc->sc_arpcom.ac_enaddr[i] =\n\t\t    bus_space_read_1(iot, ioh, asicbase + ED_WD_PROM + i);\n\n\t/*\n\t * Set upper address bits and 8/16 bit access to shared memory.\n\t */\n\tif (isa16bit) {\n\t\tif (sc->is790) {\n\t\t\tsc->wd_laar_proto =\n\t\t\t    bus_space_read_1(iot, ioh, asicbase + ED_WD_LAAR) &\n\t\t\t    ~ED_WD_LAAR_M16EN;\n\t\t} else {\n\t\t\tsc->wd_laar_proto = ED_WD_LAAR_L16EN |\n\t\t\t    ((ia->ia_maddr >> 19) & ED_WD_LAAR_ADDRHI);\n\t\t}\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_LAAR,\n\t\t    sc->wd_laar_proto | ED_WD_LAAR_M16EN);\n\t} else  {\n\t\tif ((sc->type & ED_WD_SOFTCONFIG) ||\n#ifdef TOSH_ETHER\n\t\t    (sc->type == ED_TYPE_TOSHIBA1) ||\n\t\t    (sc->type == ED_TYPE_TOSHIBA4) ||\n#endif\n\t\t    ((sc->type == ED_TYPE_WD8013EBT) && !sc->is790)) {\n\t\t\tsc->wd_laar_proto =\n\t\t\t    ((ia->ia_maddr >> 19) &\n\t\t\t    ED_WD_LAAR_ADDRHI);\n\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_LAAR,\n\t\t\t    sc->wd_laar_proto);\n\t\t}\n\t}\n\n\t/*\n\t * Set address and enable interface shared memory.\n\t */\n\tif (!sc->is790) {\n#ifdef TOSH_ETHER\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR + 1,\n\t\t    ((ia->ia_maddr >> 8) & 0xe0) | 4);\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR + 2,\n\t\t    ((ia->ia_maddr >> 16) & 0x0f));\n\t\tsc->wd_msr_proto = ED_WD_MSR_POW;\n#else\n\t\tsc->wd_msr_proto =\n\t\t    (ia->ia_maddr >> 13) & ED_WD_MSR_ADDR;\n#endif\n\t\tsc->cr_proto = ED_CR_RD2;\n\t} else {\n\t\tbus_space_write_1(iot, ioh, asicbase + 0x04,\n\t\t    bus_space_read_1(iot, ioh, asicbase + 0x04) | 0x80);\n\t\tbus_space_write_1(iot, ioh, asicbase + 0x0b,\n\t\t    ((ia->ia_maddr >> 13) & 0x0f) |\n\t\t    ((ia->ia_maddr >> 11) & 0x40) |\n\t\t    (bus_space_read_1(iot, ioh, asicbase + 0x0b) & 0xb0));\n\t\tbus_space_write_1(iot, ioh, asicbase + 0x04,\n\t\t    bus_space_read_1(iot, ioh, asicbase + 0x04) & ~0x80);\n\t\tsc->wd_msr_proto = 0x00;\n\t\tsc->cr_proto = 0;\n\t}\n\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR,\n\t    sc->wd_msr_proto | ED_WD_MSR_MENB);\n\n\t(void) bus_space_read_1(iot, delaybah, 0);\n\t(void) bus_space_read_1(iot, delaybah, 0);\n\n\t/* Now zero memory and verify that it is clear. */\n\tif (isa16bit) {\n\t\tfor (i = 0; i < memsize; i += 2)\n\t\t\tbus_space_write_2(memt, memh, sc->mem_start + i, 0);\n\t} else {\n\t\tfor (i = 0; i < memsize; ++i)\n\t\t\tbus_space_write_1(memt, memh, sc->mem_start + i, 0);\n\t}\n\n\tmemfail = 0;\n\tif (isa16bit) {\n\t\tfor (i = 0; i < memsize; i += 2) {\n\t\t\tif (bus_space_read_2(memt, memh, sc->mem_start + i)) {\n\t\t\t\tmemfail = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < memsize; ++i) {\n\t\t\tif (bus_space_read_1(memt, memh, sc->mem_start + i)) {\n\t\t\t\tmemfail = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (memfail) {\n\t\tprintf(\"%s: failed to clear shared memory at %x - \"\n\t\t    \"check configuration\\n\",\n\t\t    sc->sc_dev.dv_xname,\n\t\t    (ia->ia_maddr + sc->mem_start + i));\n\n\t\t/* Disable 16 bit access to shared memory. */\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR,\n\t\t    sc->wd_msr_proto);\n\t\tif (isa16bit)\n\t\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_LAAR,\n\t\t\t    sc->wd_laar_proto);\n\t\t(void) bus_space_read_1(iot, delaybah, 0);\n\t\t(void) bus_space_read_1(iot, delaybah, 0);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Disable 16bit access to shared memory - we leave it disabled\n\t * so that 1) machines reboot properly when the board is set 16\n\t * 16 bit mode and there are conflicting 8bit devices/ROMS in\n\t * the same 128k address space as this boards shared memory,\n\t * and 2) so that other 8 bit devices with shared memory can be\n\t * used in this 128k region, too.\n\t */\n\tbus_space_write_1(iot, ioh, asicbase + ED_WD_MSR, sc->wd_msr_proto);\n\tif (isa16bit)\n\t\tbus_space_write_1(iot, ioh, asicbase + ED_WD_LAAR,\n\t\t    sc->wd_laar_proto);\n\t(void) bus_space_read_1(iot, delaybah, 0);\n\t(void) bus_space_read_1(iot, delaybah, 0);\n\n\tia->ia_iosize = ED_WD_IO_PORTS;\n\trv = 1;\n\n out:\n\t/*\n\t * XXX Should always unmap, but we can't yet.\n\t * XXX Need to squish \"indirect\" first.\n\t */\n\tif (rv == 0) {\n\t\tbus_space_unmap(iot, ioh, ED_WD_IO_PORTS);\n\t\tif (mapped_mem)\n\t\t\tbus_space_unmap(memt, memh, memsize);\n\t} else {\n\t\t/* XXX this is all \"indirect\" brokenness */\n\t\tsc->sc_iot = iot;\n\t\tsc->sc_memt = memt;\n\t\tsc->sc_ioh = ioh;\n\t\tsc->sc_memh = memh;\n\t}\n\treturn (rv);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nint ed_find;\nint ed_find_WD80x3;\nint ed_find_3Com;\nint ed_find_Novell;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nint\ned_find(sc, cf, ia)\n\tstruct ed_softc *sc;\n\tstruct cfdata *cf;\n\tstruct isa_attach_args *ia;\n{\n\n\tif (ed_find_WD80x3(sc, cf, ia))\n\t\treturn (1);\n\tif (ed_find_3Com(sc, cf, ia))\n\t\treturn (1);\n\tif (ed_find_Novell(sc, cf, ia))\n\t\treturn (1);\n\treturn (0);\n}"
  },
  {
    "function_name": "edprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
    "lines": "552-560",
    "snippet": "int\nedprobe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct ed_softc *sc = match;\n\n\treturn (ed_find(match, sc->sc_dev.dv_cfdata, aux));\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/isa/if_edreg.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"ed.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int edprobe",
      "int ed_find",
      "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ed_find",
          "args": [
            "match",
            "sc->sc_dev.dv_cfdata",
            "aux"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "ed_find_Novell",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
          "lines": "1387-1629",
          "snippet": "int\ned_find_Novell(sc, cf, ia)\n\tstruct ed_softc *sc;\n\tstruct cfdata *cf;\n\tstruct isa_attach_args *ia;\n{\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tu_int memsize, n;\n\tu_char romdata[16], tmp;\n\tstatic u_char test_pattern[32] = \"THIS is A memory TEST pattern\";\n\tu_char test_buffer[32];\n\tint asicbase, nicbase;\n\n\tiot = ia->ia_iot;\n\n\tif (bus_space_map(iot, ia->ia_iobase, ED_NOVELL_IO_PORTS, 0, &ioh))\n\t\treturn (0);\n\n\tsc->asic_base = asicbase = ED_NOVELL_ASIC_OFFSET;\n\tsc->nic_base = nicbase = ED_NOVELL_NIC_OFFSET;\n\n\t/* XXX - do Novell-specific probe here */\n\n\t/* Reset the board. */\n#ifdef GWETHER\n\tbus_space_write_1(iot, ioh, asicbase + ED_NOVELL_RESET, 0);\n\tdelay(200);\n#endif /* GWETHER */\n\ttmp = bus_space_read_1(iot, ioh, asicbase + ED_NOVELL_RESET);\n\n\t/*\n\t * I don't know if this is necessary; probably cruft leftover from\n\t * Clarkson packet driver code. Doesn't do a thing on the boards I've\n\t * tested. -DG [note that a outb(0x84, 0) seems to work here, and is\n\t * non-invasive...but some boards don't seem to reset and I don't have\n\t * complete documentation on what the 'right' thing to do is...so we do\n\t * the invasive thing for now.  Yuck.]\n\t */\n\tbus_space_write_1(iot, ioh, asicbase + ED_NOVELL_RESET, tmp);\n\tdelay(5000);\n\n\t/*\n\t * This is needed because some NE clones apparently don't reset the NIC\n\t * properly (or the NIC chip doesn't reset fully on power-up)\n\t * XXX - this makes the probe invasive! ...Done against my better\n\t * judgement.  -DLG\n\t */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STP);\n\n\tdelay(5000);\n\n\t/* Make sure that we really have an 8390 based board. */\n\tif (!ed_probe_generic8390(iot, ioh, nicbase))\n\t\tgoto out;\n\n\tsc->vendor = ED_VENDOR_NOVELL;\n\tsc->mem_shared = 0;\n\tsc->cr_proto = ED_CR_RD2;\n\tia->ia_msize = 0;\n\n\t/*\n\t * Test the ability to read and write to the NIC memory.  This has the\n\t * side affect of determining if this is an NE1000 or an NE2000.\n\t */\n\n\t/*\n\t * This prevents packets from being stored in the NIC memory when the\n\t * readmem routine turns on the start bit in the CR.\n\t */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RCR, ED_RCR_MON);\n\n\t/* Temporarily initialize DCR for byte operations. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_DCR, ED_DCR_FT1 | ED_DCR_LS);\n\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTART, 8192 >> ED_PAGE_SHIFT);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTOP, 16384 >> ED_PAGE_SHIFT);\n\n\tsc->isa16bit = 0;\n\n\t/*\n\t * XXX indirect brokenness, used by ed_pio{read,write}mem()\n\t */\n\tsc->sc_iot = iot;\n\tsc->sc_ioh = ioh;\n\n\t/*\n\t * Write a test pattern in byte mode.  If this fails, then there\n\t * probably isn't any memory at 8k - which likely means that the board\n\t * is an NE2000.\n\t */\n\ted_pio_writemem(sc, test_pattern, 8192, sizeof(test_pattern));\n\ted_pio_readmem(sc, 8192, test_buffer, sizeof(test_pattern));\n\n\tif (bcmp(test_pattern, test_buffer, sizeof(test_pattern))) {\n\t\t/* not an NE1000 - try NE2000 */\n\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_DCR,\n\t\t    ED_DCR_WTS | ED_DCR_FT1 | ED_DCR_LS);\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTART, 16384 >> ED_PAGE_SHIFT);\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTOP, 32768 >> ED_PAGE_SHIFT);\n\n\t\tsc->isa16bit = 1;\n\n\t\t/*\n\t\t * Write a test pattern in word mode.  If this also fails, then\n\t\t * we don't know what this board is.\n\t\t */\n\t\ted_pio_writemem(sc, test_pattern, 16384, sizeof(test_pattern));\n\t\ted_pio_readmem(sc, 16384, test_buffer, sizeof(test_pattern));\n\n\t\tif (bcmp(test_pattern, test_buffer, sizeof(test_pattern)))\n\t\t\tgoto out; /* not an NE2000 either */\n\n\t\tsc->type = ED_TYPE_NE2000;\n\t\tsc->type_str = \"NE2000\";\n\t} else {\n\t\tsc->type = ED_TYPE_NE1000;\n\t\tsc->type_str = \"NE1000\";\n\t}\n\n\tif (ia->ia_irq == IRQUNK) {\n\t\tprintf(\"%s: %s does not have soft configuration\\n\",\n\t\t    sc->sc_dev.dv_xname, sc->type_str);\n\t\tgoto out;\n\t}\n\n\t/* 8k of memory plus an additional 8k if 16-bit. */\n\tmemsize = 8192 + sc->isa16bit * 8192;\n\n#if 0 /* probably not useful - NE boards only come two ways */\n\t/* Allow kernel config file overrides. */\n\tif (ia->ia_msize)\n\t\tmemsize = ia->ia_msize;\n#endif\n\n\t/* NIC memory doesn't start at zero on an NE board. */\n\t/* The start address is tied to the bus width. */\n\tsc->mem_start = (8192 + sc->isa16bit * 8192);\n\tsc->tx_page_start = memsize >> ED_PAGE_SHIFT;\n\n#ifdef GWETHER\n\t{\n\t\tint x, i, mstart = 0;\n\t\tchar pbuf0[ED_PAGE_SIZE], pbuf[ED_PAGE_SIZE], tbuf[ED_PAGE_SIZE];\n\n\t\tfor (i = 0; i < ED_PAGE_SIZE; i++)\n\t\t\tpbuf0[i] = 0;\n\n\t\t/* Search for the start of RAM. */\n\t\tfor (x = 1; x < 256; x++) {\n\t\t\ted_pio_writemem(sc, pbuf0, x << ED_PAGE_SHIFT, ED_PAGE_SIZE);\n\t\t\ted_pio_readmem(sc, x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE);\n\t\t\tif (!bcmp(pbuf0, tbuf, ED_PAGE_SIZE)) {\n\t\t\t\tfor (i = 0; i < ED_PAGE_SIZE; i++)\n\t\t\t\t\tpbuf[i] = 255 - x;\n\t\t\t\ted_pio_writemem(sc, pbuf, x << ED_PAGE_SHIFT, ED_PAGE_SIZE);\n\t\t\t\ted_pio_readmem(sc, x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE);\n\t\t\t\tif (!bcmp(pbuf, tbuf, ED_PAGE_SIZE)) {\n\t\t\t\t\tmstart = x << ED_PAGE_SHIFT;\n\t\t\t\t\tmemsize = ED_PAGE_SIZE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (mstart == 0) {\n\t\t\tprintf(\"%s: cannot find start of RAM\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* Search for the end of RAM. */\n\t\tfor (++x; x < 256; x++) {\n\t\t\ted_pio_writemem(sc, pbuf0, x << ED_PAGE_SHIFT, ED_PAGE_SIZE);\n\t\t\ted_pio_readmem(sc, x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE);\n\t\t\tif (!bcmp(pbuf0, tbuf, ED_PAGE_SIZE)) {\n\t\t\t\tfor (i = 0; i < ED_PAGE_SIZE; i++)\n\t\t\t\t\tpbuf[i] = 255 - x;\n\t\t\t\ted_pio_writemem(sc, pbuf, x << ED_PAGE_SHIFT, ED_PAGE_SIZE);\n\t\t\t\ted_pio_readmem(sc, x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE);\n\t\t\t\tif (!bcmp(pbuf, tbuf, ED_PAGE_SIZE))\n\t\t\t\t\tmemsize += ED_PAGE_SIZE;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\n\t\tprintf(\"%s: RAM start %x, size %d\\n\",\n\t\t    sc->sc_dev.dv_xname, mstart, memsize);\n\n\t\tsc->mem_start = (caddr_t)mstart;\n\t\tsc->tx_page_start = mstart >> ED_PAGE_SHIFT;\n\t}\n#endif /* GWETHER */\n\n\tsc->mem_size = memsize;\n\tsc->mem_end = sc->mem_start + memsize;\n\n\t/*\n\t * Use one xmit buffer if < 16k, two buffers otherwise (if not told\n\t * otherwise).\n\t */\n\tif ((memsize < 16384) || (cf->cf_flags & ED_FLAGS_NO_MULTI_BUFFERING))\n\t\tsc->txb_cnt = 1;\n\telse\n\t\tsc->txb_cnt = 2;\n\n\tsc->rec_page_start = sc->tx_page_start + sc->txb_cnt * ED_TXBUF_SIZE;\n\tsc->rec_page_stop = sc->tx_page_start + (memsize >> ED_PAGE_SHIFT);\n\n\tsc->mem_ring =\n\t    sc->mem_start + ((sc->txb_cnt * ED_TXBUF_SIZE) << ED_PAGE_SHIFT);\n\n\ted_pio_readmem(sc, 0, romdata, 16);\n\tfor (n = 0; n < ETHER_ADDR_LEN; n++)\n\t\tsc->sc_arpcom.ac_enaddr[n] = romdata[n*(sc->isa16bit+1)];\n\n#ifdef GWETHER\n\tif (sc->arpcom.ac_enaddr[2] == 0x86)\n\t\tsc->type_str = \"Gateway AT\";\n#endif /* GWETHER */\n\n\t/* Clear any pending interrupts that might have occurred above. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_ISR, 0xff);\n\n\tia->ia_iosize = ED_NOVELL_IO_PORTS;\n\n\t/*\n\t * XXX Sould always unmap, but we can't yet.\n\t * XXX Need to squish \"indirect\" first.\n\t */\n\tsc->sc_iot = iot;\n\tsc->sc_ioh = ioh;\n\t/* sc_memh is not used by this driver */\n\treturn 1;\n out:\n\tbus_space_unmap(iot, ioh, ED_NOVELL_IO_PORTS);\n\n\treturn 0;\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/isa/if_edreg.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"ed.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tETHER_ADDR_LEN\t6"
          ],
          "globals_used": [
            "int ed_probe_generic8390",
            "int ed_find_Novell",
            "void ed_pio_readmem",
            "void ed_pio_writemem",
            "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\n#define\tETHER_ADDR_LEN\t6\n\nint ed_probe_generic8390;\nint ed_find_Novell;\nvoid ed_pio_readmem;\nvoid ed_pio_writemem;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nint\ned_find_Novell(sc, cf, ia)\n\tstruct ed_softc *sc;\n\tstruct cfdata *cf;\n\tstruct isa_attach_args *ia;\n{\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tu_int memsize, n;\n\tu_char romdata[16], tmp;\n\tstatic u_char test_pattern[32] = \"THIS is A memory TEST pattern\";\n\tu_char test_buffer[32];\n\tint asicbase, nicbase;\n\n\tiot = ia->ia_iot;\n\n\tif (bus_space_map(iot, ia->ia_iobase, ED_NOVELL_IO_PORTS, 0, &ioh))\n\t\treturn (0);\n\n\tsc->asic_base = asicbase = ED_NOVELL_ASIC_OFFSET;\n\tsc->nic_base = nicbase = ED_NOVELL_NIC_OFFSET;\n\n\t/* XXX - do Novell-specific probe here */\n\n\t/* Reset the board. */\n#ifdef GWETHER\n\tbus_space_write_1(iot, ioh, asicbase + ED_NOVELL_RESET, 0);\n\tdelay(200);\n#endif /* GWETHER */\n\ttmp = bus_space_read_1(iot, ioh, asicbase + ED_NOVELL_RESET);\n\n\t/*\n\t * I don't know if this is necessary; probably cruft leftover from\n\t * Clarkson packet driver code. Doesn't do a thing on the boards I've\n\t * tested. -DG [note that a outb(0x84, 0) seems to work here, and is\n\t * non-invasive...but some boards don't seem to reset and I don't have\n\t * complete documentation on what the 'right' thing to do is...so we do\n\t * the invasive thing for now.  Yuck.]\n\t */\n\tbus_space_write_1(iot, ioh, asicbase + ED_NOVELL_RESET, tmp);\n\tdelay(5000);\n\n\t/*\n\t * This is needed because some NE clones apparently don't reset the NIC\n\t * properly (or the NIC chip doesn't reset fully on power-up)\n\t * XXX - this makes the probe invasive! ...Done against my better\n\t * judgement.  -DLG\n\t */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STP);\n\n\tdelay(5000);\n\n\t/* Make sure that we really have an 8390 based board. */\n\tif (!ed_probe_generic8390(iot, ioh, nicbase))\n\t\tgoto out;\n\n\tsc->vendor = ED_VENDOR_NOVELL;\n\tsc->mem_shared = 0;\n\tsc->cr_proto = ED_CR_RD2;\n\tia->ia_msize = 0;\n\n\t/*\n\t * Test the ability to read and write to the NIC memory.  This has the\n\t * side affect of determining if this is an NE1000 or an NE2000.\n\t */\n\n\t/*\n\t * This prevents packets from being stored in the NIC memory when the\n\t * readmem routine turns on the start bit in the CR.\n\t */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RCR, ED_RCR_MON);\n\n\t/* Temporarily initialize DCR for byte operations. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_DCR, ED_DCR_FT1 | ED_DCR_LS);\n\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTART, 8192 >> ED_PAGE_SHIFT);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTOP, 16384 >> ED_PAGE_SHIFT);\n\n\tsc->isa16bit = 0;\n\n\t/*\n\t * XXX indirect brokenness, used by ed_pio{read,write}mem()\n\t */\n\tsc->sc_iot = iot;\n\tsc->sc_ioh = ioh;\n\n\t/*\n\t * Write a test pattern in byte mode.  If this fails, then there\n\t * probably isn't any memory at 8k - which likely means that the board\n\t * is an NE2000.\n\t */\n\ted_pio_writemem(sc, test_pattern, 8192, sizeof(test_pattern));\n\ted_pio_readmem(sc, 8192, test_buffer, sizeof(test_pattern));\n\n\tif (bcmp(test_pattern, test_buffer, sizeof(test_pattern))) {\n\t\t/* not an NE1000 - try NE2000 */\n\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_DCR,\n\t\t    ED_DCR_WTS | ED_DCR_FT1 | ED_DCR_LS);\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTART, 16384 >> ED_PAGE_SHIFT);\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTOP, 32768 >> ED_PAGE_SHIFT);\n\n\t\tsc->isa16bit = 1;\n\n\t\t/*\n\t\t * Write a test pattern in word mode.  If this also fails, then\n\t\t * we don't know what this board is.\n\t\t */\n\t\ted_pio_writemem(sc, test_pattern, 16384, sizeof(test_pattern));\n\t\ted_pio_readmem(sc, 16384, test_buffer, sizeof(test_pattern));\n\n\t\tif (bcmp(test_pattern, test_buffer, sizeof(test_pattern)))\n\t\t\tgoto out; /* not an NE2000 either */\n\n\t\tsc->type = ED_TYPE_NE2000;\n\t\tsc->type_str = \"NE2000\";\n\t} else {\n\t\tsc->type = ED_TYPE_NE1000;\n\t\tsc->type_str = \"NE1000\";\n\t}\n\n\tif (ia->ia_irq == IRQUNK) {\n\t\tprintf(\"%s: %s does not have soft configuration\\n\",\n\t\t    sc->sc_dev.dv_xname, sc->type_str);\n\t\tgoto out;\n\t}\n\n\t/* 8k of memory plus an additional 8k if 16-bit. */\n\tmemsize = 8192 + sc->isa16bit * 8192;\n\n#if 0 /* probably not useful - NE boards only come two ways */\n\t/* Allow kernel config file overrides. */\n\tif (ia->ia_msize)\n\t\tmemsize = ia->ia_msize;\n#endif\n\n\t/* NIC memory doesn't start at zero on an NE board. */\n\t/* The start address is tied to the bus width. */\n\tsc->mem_start = (8192 + sc->isa16bit * 8192);\n\tsc->tx_page_start = memsize >> ED_PAGE_SHIFT;\n\n#ifdef GWETHER\n\t{\n\t\tint x, i, mstart = 0;\n\t\tchar pbuf0[ED_PAGE_SIZE], pbuf[ED_PAGE_SIZE], tbuf[ED_PAGE_SIZE];\n\n\t\tfor (i = 0; i < ED_PAGE_SIZE; i++)\n\t\t\tpbuf0[i] = 0;\n\n\t\t/* Search for the start of RAM. */\n\t\tfor (x = 1; x < 256; x++) {\n\t\t\ted_pio_writemem(sc, pbuf0, x << ED_PAGE_SHIFT, ED_PAGE_SIZE);\n\t\t\ted_pio_readmem(sc, x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE);\n\t\t\tif (!bcmp(pbuf0, tbuf, ED_PAGE_SIZE)) {\n\t\t\t\tfor (i = 0; i < ED_PAGE_SIZE; i++)\n\t\t\t\t\tpbuf[i] = 255 - x;\n\t\t\t\ted_pio_writemem(sc, pbuf, x << ED_PAGE_SHIFT, ED_PAGE_SIZE);\n\t\t\t\ted_pio_readmem(sc, x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE);\n\t\t\t\tif (!bcmp(pbuf, tbuf, ED_PAGE_SIZE)) {\n\t\t\t\t\tmstart = x << ED_PAGE_SHIFT;\n\t\t\t\t\tmemsize = ED_PAGE_SIZE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (mstart == 0) {\n\t\t\tprintf(\"%s: cannot find start of RAM\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* Search for the end of RAM. */\n\t\tfor (++x; x < 256; x++) {\n\t\t\ted_pio_writemem(sc, pbuf0, x << ED_PAGE_SHIFT, ED_PAGE_SIZE);\n\t\t\ted_pio_readmem(sc, x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE);\n\t\t\tif (!bcmp(pbuf0, tbuf, ED_PAGE_SIZE)) {\n\t\t\t\tfor (i = 0; i < ED_PAGE_SIZE; i++)\n\t\t\t\t\tpbuf[i] = 255 - x;\n\t\t\t\ted_pio_writemem(sc, pbuf, x << ED_PAGE_SHIFT, ED_PAGE_SIZE);\n\t\t\t\ted_pio_readmem(sc, x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE);\n\t\t\t\tif (!bcmp(pbuf, tbuf, ED_PAGE_SIZE))\n\t\t\t\t\tmemsize += ED_PAGE_SIZE;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\n\t\tprintf(\"%s: RAM start %x, size %d\\n\",\n\t\t    sc->sc_dev.dv_xname, mstart, memsize);\n\n\t\tsc->mem_start = (caddr_t)mstart;\n\t\tsc->tx_page_start = mstart >> ED_PAGE_SHIFT;\n\t}\n#endif /* GWETHER */\n\n\tsc->mem_size = memsize;\n\tsc->mem_end = sc->mem_start + memsize;\n\n\t/*\n\t * Use one xmit buffer if < 16k, two buffers otherwise (if not told\n\t * otherwise).\n\t */\n\tif ((memsize < 16384) || (cf->cf_flags & ED_FLAGS_NO_MULTI_BUFFERING))\n\t\tsc->txb_cnt = 1;\n\telse\n\t\tsc->txb_cnt = 2;\n\n\tsc->rec_page_start = sc->tx_page_start + sc->txb_cnt * ED_TXBUF_SIZE;\n\tsc->rec_page_stop = sc->tx_page_start + (memsize >> ED_PAGE_SHIFT);\n\n\tsc->mem_ring =\n\t    sc->mem_start + ((sc->txb_cnt * ED_TXBUF_SIZE) << ED_PAGE_SHIFT);\n\n\ted_pio_readmem(sc, 0, romdata, 16);\n\tfor (n = 0; n < ETHER_ADDR_LEN; n++)\n\t\tsc->sc_arpcom.ac_enaddr[n] = romdata[n*(sc->isa16bit+1)];\n\n#ifdef GWETHER\n\tif (sc->arpcom.ac_enaddr[2] == 0x86)\n\t\tsc->type_str = \"Gateway AT\";\n#endif /* GWETHER */\n\n\t/* Clear any pending interrupts that might have occurred above. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_ISR, 0xff);\n\n\tia->ia_iosize = ED_NOVELL_IO_PORTS;\n\n\t/*\n\t * XXX Sould always unmap, but we can't yet.\n\t * XXX Need to squish \"indirect\" first.\n\t */\n\tsc->sc_iot = iot;\n\tsc->sc_ioh = ioh;\n\t/* sc_memh is not used by this driver */\n\treturn 1;\n out:\n\tbus_space_unmap(iot, ioh, ED_NOVELL_IO_PORTS);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nint edprobe;\nint ed_find;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nint\nedprobe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct ed_softc *sc = match;\n\n\treturn (ed_find(match, sc->sc_dev.dv_cfdata, aux));\n}"
  },
  {
    "function_name": "ed_pci_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
    "lines": "420-545",
    "snippet": "void\ned_pci_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct ed_softc *sc = (void *)self;\n\tstruct pci_attach_args *pa = aux;\n\tpci_chipset_tag_t pc = pa->pa_pc;\n\tpci_intr_handle_t ih;\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tbus_addr_t iobase;\n\tbus_size_t iosize, asicbase, nicbase;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tu_char romdata[32], tmp;\n\tconst char *intrstr;\n\tint i;\n\n\tiot = pa->pa_iot;\n\n\tif (pci_io_find(pc, pa->pa_tag, PCI_CBIO, &iobase, &iosize)) {\n\t\tprintf(\"%s: can't find I/O base\\n\", sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\tif (bus_space_map(iot, iobase, iosize, 0, &ioh)) {\n\t\tprintf(\"%s: can't map I/O space\\n\", sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\tsc->asic_base = asicbase = ED_NOVELL_ASIC_OFFSET;\n\tsc->nic_base = nicbase = ED_NOVELL_NIC_OFFSET;\n\tsc->vendor = ED_VENDOR_NOVELL;\n\tsc->mem_shared = 0;\n\tsc->cr_proto = ED_CR_RD2;\n\tsc->type = ED_TYPE_NE2000;\n\tsc->type_str = \"NE2000\";\n\n\t/* Reset the board. */\n\ttmp = bus_space_read_1(iot, ioh, asicbase + ED_NOVELL_RESET);\n\n\t/* Put the board into 16-bit mode (XXX - someday do 32-bit) */\n\tsc->isa16bit = 1;\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_DCR,\n\t    ED_DCR_WTS | ED_DCR_FT1 | ED_DCR_LS);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTART, 16384 >> ED_PAGE_SHIFT);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTOP, 32768 >> ED_PAGE_SHIFT);\n\n\t/*\n\t * NIC memory doesn't start at zero on an NE board.\n\t * The start address (and size) is tied to the bus width.\n\t * XXX - these should be 32K but the driver doesn't grok > 16bit\n\t */\n\tsc->mem_size = 16384;\t\t/* XXX - should be 8K x bus width */\n\tsc->mem_start = 16384;\t\t/*     - and this as well */\n\tsc->mem_end = sc->mem_start + sc->mem_size;\n\tsc->tx_page_start = sc->mem_size >> ED_PAGE_SHIFT;\n\tsc->txb_cnt = sc->mem_size / 8192;\n\tsc->rec_page_start = sc->tx_page_start + sc->txb_cnt * ED_TXBUF_SIZE;\n\tsc->rec_page_stop = sc->tx_page_start + (sc->mem_size >> ED_PAGE_SHIFT);\n\tsc->mem_ring =\n\t    sc->mem_start + ((sc->txb_cnt * ED_TXBUF_SIZE) << ED_PAGE_SHIFT);\n\tsc->sc_delaybah = 0;\t\t\t/* unused */\n\tsc->sc_iot = iot;\n\tsc->sc_ioh = ioh;\n\n\t/* Get ethernet address (XXX - size field should be \"8 * buswidth\") */\n\ted_pio_readmem(sc, 0, romdata, sizeof(romdata));\n\t/* XXX - change to (i * buswidth) when driver does 32bit */\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\tsc->sc_arpcom.ac_enaddr[i] = romdata[i * 2];\n\n\t/* Clear any pending interrupts that might have occurred above. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_ISR, 0xff);\n\n\t/* Set interface to stopped condition (reset). */\n\tedstop(sc);\n\n\t/* Initialize ifnet structure. */\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_start = edstart;\n\tifp->if_ioctl = edioctl;\n\tifp->if_watchdog = edwatchdog;\n\tifp->if_flags =\n\t    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;\n\n\t/* Attach the interface. */\n\tif ((sc->spec_flags & ED_REATTACH) == 0)\n\t\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n\t/* Print additional info when attached. */\n\tprintf(\": address %s, \", ether_sprintf(sc->sc_arpcom.ac_enaddr));\n\n\tif (sc->type_str)\n\t\tprintf(\"type %s \", sc->type_str);\n\telse\n\t\tprintf(\"type unknown (0x%x) \", sc->type);\n\tprintf(\"%s\", sc->isa16bit ? \"(16-bit)\" : \"(8-bit)\");\t/* XXX */\n\n#if NBPFILTER > 0\n        if ((sc->spec_flags & ED_REATTACH) == 0)\n\t\tbpfattach(&ifp->if_bpf, ifp, DLT_EN10MB,\n\t\t    sizeof(struct ether_header));\n#endif\n\n\t/* Map and establish the interrupt. */\n\tif (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,\n\t    pa->pa_intrline, &ih)) {\n\t\tprintf(\"\\n%s: couldn't map interrupt\\n\", sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\tintrstr = pci_intr_string(pc, ih);\n\tsc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, edintr,\n\t    sc, sc->sc_dev.dv_xname);\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\"\\n%s: couldn't establish interrupt\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\tprintf(\", %s\\n\", intrstr);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/isa/if_edreg.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"ed.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define PCI_CBIO\t\t0x10\t/* Configuration Base IO Address */",
      "#define\tETHER_ADDR_LEN\t6",
      "#define ED_REATTACH\t0x0001\t/* Reattach */"
    ],
    "globals_used": [
      "int edintr",
      "int edioctl",
      "void edstart",
      "void edwatchdog",
      "void edstop",
      "void ed_pio_readmem",
      "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\", %s\\n\"",
            "intrstr"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_intr_establish",
          "args": [
            "pc",
            "ih",
            "IPL_NET",
            "edintr",
            "sc",
            "sc->sc_dev.dv_xname"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_string",
          "args": [
            "pc",
            "ih"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_map",
          "args": [
            "pc",
            "pa->pa_intrtag",
            "pa->pa_intrpin",
            "pa->pa_intrline",
            "&ih"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpfattach",
          "args": [
            "&ifp->if_bpf",
            "ifp",
            "DLT_EN10MB",
            "sizeof(struct ether_header)"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_sprintf",
          "args": [
            "sc->sc_arpcom.ac_enaddr"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ifattach",
          "args": [
            "ifp"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_attach",
          "args": [
            "ifp"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "sc->sc_dev.dv_xname",
            "ifp->if_xname",
            "IFNAMSIZ"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "edstop",
          "args": [
            "sc"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "edstop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
          "lines": "1747-1767",
          "snippet": "void\nedstop(sc)\n\tstruct ed_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint nicbase = sc->nic_base;\n\tint n = 5000;\n\n\t/* Stop everything on the interface, and select page 0 registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\t/*\n\t * Wait for interface to enter stopped state, but limit # of checks to\n\t * 'n' (about 5ms).  It shouldn't even take 5us on modern DS8390's, but\n\t * just in case it's an old one.\n\t */\n\twhile (((NIC_GET(iot, ioh, nicbase,\n\t    ED_P0_ISR) & ED_ISR_RST) == 0) && --n);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/isa/if_edreg.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"ed.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void edstop",
            "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nvoid edstop;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nvoid\nedstop(sc)\n\tstruct ed_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint nicbase = sc->nic_base;\n\tint n = 5000;\n\n\t/* Stop everything on the interface, and select page 0 registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\t/*\n\t * Wait for interface to enter stopped state, but limit # of checks to\n\t * 'n' (about 5ms).  It shouldn't even take 5us on modern DS8390's, but\n\t * just in case it's an old one.\n\t */\n\twhile (((NIC_GET(iot, ioh, nicbase,\n\t    ED_P0_ISR) & ED_ISR_RST) == 0) && --n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_ISR",
            "0xff"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed_pio_readmem",
          "args": [
            "sc",
            "0",
            "romdata",
            "sizeof(romdata)"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "ed_pio_readmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
          "lines": "2584-2620",
          "snippet": "void\ned_pio_readmem(sc, src, dst, amount)\n\tstruct ed_softc *sc;\n\tu_int16_t src;\n\tcaddr_t dst;\n\tu_int16_t amount;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint nicbase = sc->nic_base;\n\n\t/* Select page 0 registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Round up to a word. */\n\tif (amount & 1)\n\t\t++amount;\n\n\t/* Set up DMA byte count. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR0, amount);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR1, amount >> 8);\n\n\t/* Set up source address in NIC mem. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RSAR0, src);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RSAR1, src >> 8);\n\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD0 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tif (sc->isa16bit)\n\t\tbus_space_read_raw_multi_2(iot, ioh,\n\t\t    sc->asic_base + ED_NOVELL_DATA, dst, amount);\n\telse\n\t\tbus_space_read_multi_1(iot, ioh,\n\t\t    sc->asic_base + ED_NOVELL_DATA, dst, amount);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/isa/if_edreg.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"ed.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ed_pio_readmem",
            "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;",
            "int src;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nvoid ed_pio_readmem;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\nint src;\n\nvoid\ned_pio_readmem(sc, src, dst, amount)\n\tstruct ed_softc *sc;\n\tu_int16_t src;\n\tcaddr_t dst;\n\tu_int16_t amount;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint nicbase = sc->nic_base;\n\n\t/* Select page 0 registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\t/* Round up to a word. */\n\tif (amount & 1)\n\t\t++amount;\n\n\t/* Set up DMA byte count. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR0, amount);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RBCR1, amount >> 8);\n\n\t/* Set up source address in NIC mem. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RSAR0, src);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RSAR1, src >> 8);\n\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD0 | ED_CR_PAGE_0 | ED_CR_STA);\n\n\tif (sc->isa16bit)\n\t\tbus_space_read_raw_multi_2(iot, ioh,\n\t\t    sc->asic_base + ED_NOVELL_DATA, dst, amount);\n\telse\n\t\tbus_space_read_multi_1(iot, ioh,\n\t\t    sc->asic_base + ED_NOVELL_DATA, dst, amount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_PSTOP",
            "32768 >> ED_PAGE_SHIFT"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_PSTART",
            "16384 >> ED_PAGE_SHIFT"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NIC_PUT",
          "args": [
            "iot",
            "ioh",
            "nicbase",
            "ED_P0_DCR",
            "ED_DCR_WTS | ED_DCR_FT1 | ED_DCR_LS"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "asicbase + ED_NOVELL_RESET"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "iot",
            "iobase",
            "iosize",
            "0",
            "&ioh"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_io_find",
          "args": [
            "pc",
            "pa->pa_tag",
            "PCI_CBIO",
            "&iobase",
            "&iosize"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "pci_io_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci_map.c",
          "lines": "186-195",
          "snippet": "int\npci_io_find(pc, pcitag, reg, iobasep, iosizep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *iobasep;\n\tbus_size_t *iosizep;\n{\n\treturn (nbsd_pci_io_find(pc, pcitag, reg, 0, iobasep, iosizep, 0));\n}",
          "includes": [
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nbsd_pci_io_find"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int nbsd_pci_io_find;\n\nint\npci_io_find(pc, pcitag, reg, iobasep, iosizep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *iobasep;\n\tbus_size_t *iosizep;\n{\n\treturn (nbsd_pci_io_find(pc, pcitag, reg, 0, iobasep, iosizep, 0));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\n#define PCI_CBIO\t\t0x10\t/* Configuration Base IO Address */\n#define\tETHER_ADDR_LEN\t6\n#define ED_REATTACH\t0x0001\t/* Reattach */\n\nint edintr;\nint edioctl;\nvoid edstart;\nvoid edwatchdog;\nvoid edstop;\nvoid ed_pio_readmem;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nvoid\ned_pci_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct ed_softc *sc = (void *)self;\n\tstruct pci_attach_args *pa = aux;\n\tpci_chipset_tag_t pc = pa->pa_pc;\n\tpci_intr_handle_t ih;\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tbus_addr_t iobase;\n\tbus_size_t iosize, asicbase, nicbase;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tu_char romdata[32], tmp;\n\tconst char *intrstr;\n\tint i;\n\n\tiot = pa->pa_iot;\n\n\tif (pci_io_find(pc, pa->pa_tag, PCI_CBIO, &iobase, &iosize)) {\n\t\tprintf(\"%s: can't find I/O base\\n\", sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\tif (bus_space_map(iot, iobase, iosize, 0, &ioh)) {\n\t\tprintf(\"%s: can't map I/O space\\n\", sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\tsc->asic_base = asicbase = ED_NOVELL_ASIC_OFFSET;\n\tsc->nic_base = nicbase = ED_NOVELL_NIC_OFFSET;\n\tsc->vendor = ED_VENDOR_NOVELL;\n\tsc->mem_shared = 0;\n\tsc->cr_proto = ED_CR_RD2;\n\tsc->type = ED_TYPE_NE2000;\n\tsc->type_str = \"NE2000\";\n\n\t/* Reset the board. */\n\ttmp = bus_space_read_1(iot, ioh, asicbase + ED_NOVELL_RESET);\n\n\t/* Put the board into 16-bit mode (XXX - someday do 32-bit) */\n\tsc->isa16bit = 1;\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_DCR,\n\t    ED_DCR_WTS | ED_DCR_FT1 | ED_DCR_LS);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTART, 16384 >> ED_PAGE_SHIFT);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTOP, 32768 >> ED_PAGE_SHIFT);\n\n\t/*\n\t * NIC memory doesn't start at zero on an NE board.\n\t * The start address (and size) is tied to the bus width.\n\t * XXX - these should be 32K but the driver doesn't grok > 16bit\n\t */\n\tsc->mem_size = 16384;\t\t/* XXX - should be 8K x bus width */\n\tsc->mem_start = 16384;\t\t/*     - and this as well */\n\tsc->mem_end = sc->mem_start + sc->mem_size;\n\tsc->tx_page_start = sc->mem_size >> ED_PAGE_SHIFT;\n\tsc->txb_cnt = sc->mem_size / 8192;\n\tsc->rec_page_start = sc->tx_page_start + sc->txb_cnt * ED_TXBUF_SIZE;\n\tsc->rec_page_stop = sc->tx_page_start + (sc->mem_size >> ED_PAGE_SHIFT);\n\tsc->mem_ring =\n\t    sc->mem_start + ((sc->txb_cnt * ED_TXBUF_SIZE) << ED_PAGE_SHIFT);\n\tsc->sc_delaybah = 0;\t\t\t/* unused */\n\tsc->sc_iot = iot;\n\tsc->sc_ioh = ioh;\n\n\t/* Get ethernet address (XXX - size field should be \"8 * buswidth\") */\n\ted_pio_readmem(sc, 0, romdata, sizeof(romdata));\n\t/* XXX - change to (i * buswidth) when driver does 32bit */\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\tsc->sc_arpcom.ac_enaddr[i] = romdata[i * 2];\n\n\t/* Clear any pending interrupts that might have occurred above. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_ISR, 0xff);\n\n\t/* Set interface to stopped condition (reset). */\n\tedstop(sc);\n\n\t/* Initialize ifnet structure. */\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_start = edstart;\n\tifp->if_ioctl = edioctl;\n\tifp->if_watchdog = edwatchdog;\n\tifp->if_flags =\n\t    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;\n\n\t/* Attach the interface. */\n\tif ((sc->spec_flags & ED_REATTACH) == 0)\n\t\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n\t/* Print additional info when attached. */\n\tprintf(\": address %s, \", ether_sprintf(sc->sc_arpcom.ac_enaddr));\n\n\tif (sc->type_str)\n\t\tprintf(\"type %s \", sc->type_str);\n\telse\n\t\tprintf(\"type unknown (0x%x) \", sc->type);\n\tprintf(\"%s\", sc->isa16bit ? \"(16-bit)\" : \"(8-bit)\");\t/* XXX */\n\n#if NBPFILTER > 0\n        if ((sc->spec_flags & ED_REATTACH) == 0)\n\t\tbpfattach(&ifp->if_bpf, ifp, DLT_EN10MB,\n\t\t    sizeof(struct ether_header));\n#endif\n\n\t/* Map and establish the interrupt. */\n\tif (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,\n\t    pa->pa_intrline, &ih)) {\n\t\tprintf(\"\\n%s: couldn't map interrupt\\n\", sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\tintrstr = pci_intr_string(pc, ih);\n\tsc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, edintr,\n\t    sc, sc->sc_dev.dv_xname);\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\"\\n%s: couldn't establish interrupt\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\tprintf(\", %s\\n\", intrstr);\n}"
  },
  {
    "function_name": "ed_pci_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
    "lines": "401-414",
    "snippet": "int\ned_pci_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct pci_attach_args *pa = aux;\n\tint i;\n\t\n\tfor (i = 0; i < sizeof(ed_pci_devs)/sizeof(ed_pci_devs[0]); i++)\n\t\tif (ed_pci_devs[i].vendor == PCI_VENDOR(pa->pa_id) &&\n\t\t    ed_pci_devs[i].product == PCI_PRODUCT(pa->pa_id))\n\t\t\treturn (1);\n\treturn (0);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/isa/if_edreg.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"ed.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PCI_PRODUCT",
          "args": [
            "pa->pa_id"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDOR",
          "args": [
            "pa->pa_id"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nint\ned_pci_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct pci_attach_args *pa = aux;\n\tint i;\n\t\n\tfor (i = 0; i < sizeof(ed_pci_devs)/sizeof(ed_pci_devs[0]); i++)\n\t\tif (ed_pci_devs[i].vendor == PCI_VENDOR(pa->pa_id) &&\n\t\t    ed_pci_devs[i].product == PCI_PRODUCT(pa->pa_id))\n\t\t\treturn (1);\n\treturn (0);\n}"
  },
  {
    "function_name": "ed_pcmcia_detach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
    "lines": "363-368",
    "snippet": "int\ned_pcmcia_detach(self)\n\tstruct device *self;\n{\n\treturn EBUSY;\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/isa/if_edreg.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"ed.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nint\ned_pcmcia_detach(self)\n\tstruct device *self;\n{\n\treturn EBUSY;\n}"
  },
  {
    "function_name": "ed_pcmcia_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
    "lines": "343-357",
    "snippet": "void\ned_pcmcia_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct pcmcia_attach_args *paa = aux;\n\t\n\tprintf(\"ed_pcmcia_attach %p %p %p\\n\", parent, self, aux);\n\tdelay(2000000);\n\tif (!pcmcia_configure(parent, self, paa->paa_link)) {\n\t\tstruct ed_softc *sc = (void *)self;\n\t\tsc->spec_flags |= ED_NOTPRESENT;\n\t\tprintf(\": not attached\\n\");\n\t}\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/isa/if_edreg.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"ed.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define ED_NOTPRESENT \t0x0002\t/* card not present; do not allow\n\t\t\t\t   reconfiguration */"
    ],
    "globals_used": [
      "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\": not attached\\n\""
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcmcia_configure",
          "args": [
            "parent",
            "self",
            "paa->paa_link"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "2000000"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\n#define ED_NOTPRESENT \t0x0002\t/* card not present; do not allow\n\t\t\t\t   reconfiguration */\n\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nvoid\ned_pcmcia_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct pcmcia_attach_args *paa = aux;\n\t\n\tprintf(\"ed_pcmcia_attach %p %p %p\\n\", parent, self, aux);\n\tdelay(2000000);\n\tif (!pcmcia_configure(parent, self, paa->paa_link)) {\n\t\tstruct ed_softc *sc = (void *)self;\n\t\tsc->spec_flags |= ED_NOTPRESENT;\n\t\tprintf(\": not attached\\n\");\n\t}\n}"
  },
  {
    "function_name": "ed_pcmcia_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
    "lines": "334-341",
    "snippet": "int\ned_pcmcia_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\treturn pcmcia_slave_match(parent, match, aux, pcmcia_ed_devs,\n\t\t\t\t  ned_pcmcia_devs);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/isa/if_edreg.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"ed.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define ned_pcmcia_devs sizeof(pcmcia_ed_devs)/sizeof(pcmcia_ed_devs[0])"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcmcia_slave_match",
          "args": [
            "parent",
            "match",
            "aux",
            "pcmcia_ed_devs",
            "ned_pcmcia_devs"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\n#define ned_pcmcia_devs sizeof(pcmcia_ed_devs)/sizeof(pcmcia_ed_devs[0])\n\nint\ned_pcmcia_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\treturn pcmcia_slave_match(parent, match, aux, pcmcia_ed_devs,\n\t\t\t\t  ned_pcmcia_devs);\n}"
  },
  {
    "function_name": "ed_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
    "lines": "283-297",
    "snippet": "int\ned_remove(pc_link,self) \n\tstruct pcmcia_link *pc_link;\n\tstruct device *self;\n{\n\tstruct ed_softc *sc = (void *)self;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tif_down(ifp);\n\tedstop(sc);\n\tshutdownhook_disestablish(sc->sc_sh);\n\tifp->if_flags &= ~(IFF_RUNNING|IFF_UP);\n\tsc->spec_flags |= ED_NOTPRESENT;\n\tisa_intr_disestablish(sc->sc_ic, sc->sc_ih);\n\treturn PCMCIA_BUS_UNCONFIG(pc_link->adapter, pc_link);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/isa/if_edreg.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"ed.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define ED_NOTPRESENT \t0x0002\t/* card not present; do not allow\n\t\t\t\t   reconfiguration */"
    ],
    "globals_used": [
      "void edstop",
      "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PCMCIA_BUS_UNCONFIG",
          "args": [
            "pc_link->adapter",
            "pc_link"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isa_intr_disestablish",
          "args": [
            "sc->sc_ic",
            "sc->sc_ih"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shutdownhook_disestablish",
          "args": [
            "sc->sc_sh"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "edstop",
          "args": [
            "sc"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "edstop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
          "lines": "1747-1767",
          "snippet": "void\nedstop(sc)\n\tstruct ed_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint nicbase = sc->nic_base;\n\tint n = 5000;\n\n\t/* Stop everything on the interface, and select page 0 registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\t/*\n\t * Wait for interface to enter stopped state, but limit # of checks to\n\t * 'n' (about 5ms).  It shouldn't even take 5us on modern DS8390's, but\n\t * just in case it's an old one.\n\t */\n\twhile (((NIC_GET(iot, ioh, nicbase,\n\t    ED_P0_ISR) & ED_ISR_RST) == 0) && --n);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/isa/if_edreg.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"ed.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void edstop",
            "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nvoid edstop;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nvoid\nedstop(sc)\n\tstruct ed_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint nicbase = sc->nic_base;\n\tint n = 5000;\n\n\t/* Stop everything on the interface, and select page 0 registers. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);\n\n\t/*\n\t * Wait for interface to enter stopped state, but limit # of checks to\n\t * 'n' (about 5ms).  It shouldn't even take 5us on modern DS8390's, but\n\t * just in case it's an old one.\n\t */\n\twhile (((NIC_GET(iot, ioh, nicbase,\n\t    ED_P0_ISR) & ED_ISR_RST) == 0) && --n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "if_down",
          "args": [
            "ifp"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\n#define ED_NOTPRESENT \t0x0002\t/* card not present; do not allow\n\t\t\t\t   reconfiguration */\n\nvoid edstop;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nint\ned_remove(pc_link,self) \n\tstruct pcmcia_link *pc_link;\n\tstruct device *self;\n{\n\tstruct ed_softc *sc = (void *)self;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tif_down(ifp);\n\tedstop(sc);\n\tshutdownhook_disestablish(sc->sc_sh);\n\tifp->if_flags &= ~(IFF_RUNNING|IFF_UP);\n\tsc->spec_flags |= ED_NOTPRESENT;\n\tisa_intr_disestablish(sc->sc_ic, sc->sc_ih);\n\treturn PCMCIA_BUS_UNCONFIG(pc_link->adapter, pc_link);\n}"
  },
  {
    "function_name": "edmod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
    "lines": "245-281",
    "snippet": "int\nedmod(pc_link, self, pc_cf, cf) \n\tstruct pcmcia_link *pc_link;\n\tstruct device *self;\n\tstruct pcmcia_conf *pc_cf;\n\tstruct cfdata *cf;\n{\n\tint err;\n/*\tstruct pcmciadevs *dev=pc_link->device;*/\n/*\tstruct ed_softc *sc = (void *)self;*/\n\tint svec_card =  pc_cf->memwin  == 5;\n\tint de650_0 = (pc_cf->memwin != 0) && !svec_card;\n\terr = PCMCIA_BUS_CONFIG(pc_link->adapter, pc_link, self, pc_cf, cf);\n\tif (err)\n\t\treturn err;\n\n\tif (svec_card) {\n\t\tpc_cf->memwin = 0;\n#if 0\n\t\tpc_cf->cfgid = 32;  /* Try this if it still doesn't work */\n\t\tpc_cf->cfgid |= 32;  /* or Try this if it still doesn't work */\n#endif\n\t}\n\tif (de650_0) {\n\t\tpc_cf->io[0].flags =\n\t\t    (pc_cf->io[0].flags&~PCMCIA_MAP_16)|PCMCIA_MAP_8;\n\t\tpc_cf->memwin = 0;\n\t\tpc_cf->cfgtype = DOSRESET|1;\n\t}\n\telse {\n\t\t/* still wrong in CIS; fix it here */\n\t\tpc_cf->io[0].flags = PCMCIA_MAP_8|PCMCIA_MAP_16;\n\t\tpc_cf->cfgtype = 1;\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/isa/if_edreg.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"ed.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PCMCIA_BUS_CONFIG",
          "args": [
            "pc_link->adapter",
            "pc_link",
            "self",
            "pc_cf",
            "cf"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nint\nedmod(pc_link, self, pc_cf, cf) \n\tstruct pcmcia_link *pc_link;\n\tstruct device *self;\n\tstruct pcmcia_conf *pc_cf;\n\tstruct cfdata *cf;\n{\n\tint err;\n/*\tstruct pcmciadevs *dev=pc_link->device;*/\n/*\tstruct ed_softc *sc = (void *)self;*/\n\tint svec_card =  pc_cf->memwin  == 5;\n\tint de650_0 = (pc_cf->memwin != 0) && !svec_card;\n\terr = PCMCIA_BUS_CONFIG(pc_link->adapter, pc_link, self, pc_cf, cf);\n\tif (err)\n\t\treturn err;\n\n\tif (svec_card) {\n\t\tpc_cf->memwin = 0;\n#if 0\n\t\tpc_cf->cfgid = 32;  /* Try this if it still doesn't work */\n\t\tpc_cf->cfgid |= 32;  /* or Try this if it still doesn't work */\n#endif\n\t}\n\tif (de650_0) {\n\t\tpc_cf->io[0].flags =\n\t\t    (pc_cf->io[0].flags&~PCMCIA_MAP_16)|PCMCIA_MAP_8;\n\t\tpc_cf->memwin = 0;\n\t\tpc_cf->cfgtype = DOSRESET|1;\n\t}\n\telse {\n\t\t/* still wrong in CIS; fix it here */\n\t\tpc_cf->io[0].flags = PCMCIA_MAP_8|PCMCIA_MAP_16;\n\t\tpc_cf->cfgtype = 1;\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "ed_pcmcia_isa_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
    "lines": "193-242",
    "snippet": "int\ned_pcmcia_isa_attach(parent, match, aux, pc_link)\n\tstruct device *parent;\n\tvoid *match;\n\tvoid *aux;\n\tstruct pcmcia_link *pc_link;\n{\n\tstruct ed_softc *sc = match;\n\tstruct cfdata *cf = sc->sc_dev.dv_cfdata;\n\tstruct isa_attach_args *ia = aux;\n\tstruct pcmciadevs *dev=pc_link->device;\n\tint err;\n\textern int ifqmaxlen;\n\tu_char enaddr[ETHER_ADDR_LEN];\n\n\tif ((int)dev->param != -1)\n\t\terr = pcmcia_read_cis(pc_link, enaddr, \n\t\t\t\t      (int) dev->param, ETHER_ADDR_LEN);\n\telse\n\t\terr = 0;\n\tif (err)\n\t\tprintf(\"%s: attaching ed: cannot read cis info %d\\n\",\n\t\t       parent->dv_xname, err);\n\n\tif (ed_find_Novell(sc, cf, ia)) {\n\t\tdelay(100);\n\t\tif ((int)dev->param != -1) {\n\t\t    err = pcmcia_read_cis(pc_link, sc->sc_arpcom.ac_enaddr,\n\t\t\t\t      (int) dev->param, ETHER_ADDR_LEN);\n\t\t    if (err) {\n\t\t\t    printf(\"Cannot read cis info %d\\n\", err);\n\t\t\t    return 0;\n\t\t    }\n\t\t    if (bcmp(enaddr, sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN)) {\n\t\t\t    printf(\"ENADDR MISMATCH %s \",\n\t\t\t\t   ether_sprintf(sc->sc_arpcom.ac_enaddr));\n\t\t\t    printf(\"- %s\\n\", ether_sprintf(enaddr));\n\t\t\t    bcopy(enaddr,sc->sc_arpcom.ac_enaddr,\n\t\t\t\t\t    ETHER_ADDR_LEN);\n\t\t    }\n\t\t}\n\t\t/* clear ED_NOTPRESENT, set ED_REATTACH if needed */\n\t\tsc->spec_flags=pc_link->flags&PCMCIA_REATTACH?ED_REATTACH:0;\n\t\tsc->type_str = dev->model;\n\t\tsc->sc_arpcom.ac_if.if_snd.ifq_maxlen=ifqmaxlen;\n\t\tsc->sc_ic = ia->ia_ic;\n\t\treturn 1;\n\t} else\n\t    return 0;\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pcmcia/pcmciavar.h>",
      "#include <dev/isa/if_edreg.h>",
      "#include <dev/ic/dp8390reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/netisr.h>",
      "#include <net/if_types.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"ed.h\"",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define\tETHER_ADDR_LEN\t6",
      "#define ED_NOTPRESENT \t0x0002\t/* card not present; do not allow\n\t\t\t\t   reconfiguration */",
      "#define ED_REATTACH\t0x0001\t/* Reattach */"
    ],
    "globals_used": [
      "int ed_find_Novell",
      "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "enaddr",
            "sc->sc_arpcom.ac_enaddr",
            "ETHER_ADDR_LEN"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"- %s\\n\"",
            "ether_sprintf(enaddr)"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_sprintf",
          "args": [
            "enaddr"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_sprintf",
          "args": [
            "sc->sc_arpcom.ac_enaddr"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "enaddr",
            "sc->sc_arpcom.ac_enaddr",
            "ETHER_ADDR_LEN"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcmcia_read_cis",
          "args": [
            "pc_link",
            "sc->sc_arpcom.ac_enaddr",
            "(int) dev->param",
            "ETHER_ADDR_LEN"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "pcmcia_read_cis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pcmcia/pcmcia_cis.c",
          "lines": "62-89",
          "snippet": "void\npcmcia_read_cis(sc)\n\tstruct pcmcia_softc *sc;\n{\n\tstruct cis_state state;\n\n\tstate.count = 0;\n\tstate.gotmfc = 0;\n\n\tstate.card = &sc->card;\n\n\tstate.card->error = 0;\n\tstate.card->cis1_major = -1;\n\tstate.card->cis1_minor = -1;\n\tstate.card->cis1_info[0] = NULL;\n\tstate.card->cis1_info[1] = NULL;\n\tstate.card->cis1_info[2] = NULL;\n\tstate.card->cis1_info[3] = NULL;\n\tstate.card->manufacturer = PCMCIA_VENDOR_INVALID;\n\tstate.card->product = PCMCIA_PRODUCT_INVALID;\n\tSIMPLEQ_INIT(&state.card->pf_head);\n\n\tstate.pf = NULL;\n\n\tif (pcmcia_scan_cis((struct device *)sc, pcmcia_parse_cis_tuple,\n\t    &state) == -1)\n\t\tstate.card->error++;\n}",
          "includes": [
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciachip.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tpcmcia_parse_cis_tuple"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciachip.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\tpcmcia_parse_cis_tuple;\n\nvoid\npcmcia_read_cis(sc)\n\tstruct pcmcia_softc *sc;\n{\n\tstruct cis_state state;\n\n\tstate.count = 0;\n\tstate.gotmfc = 0;\n\n\tstate.card = &sc->card;\n\n\tstate.card->error = 0;\n\tstate.card->cis1_major = -1;\n\tstate.card->cis1_minor = -1;\n\tstate.card->cis1_info[0] = NULL;\n\tstate.card->cis1_info[1] = NULL;\n\tstate.card->cis1_info[2] = NULL;\n\tstate.card->cis1_info[3] = NULL;\n\tstate.card->manufacturer = PCMCIA_VENDOR_INVALID;\n\tstate.card->product = PCMCIA_PRODUCT_INVALID;\n\tSIMPLEQ_INIT(&state.card->pf_head);\n\n\tstate.pf = NULL;\n\n\tif (pcmcia_scan_cis((struct device *)sc, pcmcia_parse_cis_tuple,\n\t    &state) == -1)\n\t\tstate.card->error++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "100"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ed_find_Novell",
          "args": [
            "sc",
            "cf",
            "ia"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "ed_find_Novell",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ed.c",
          "lines": "1387-1629",
          "snippet": "int\ned_find_Novell(sc, cf, ia)\n\tstruct ed_softc *sc;\n\tstruct cfdata *cf;\n\tstruct isa_attach_args *ia;\n{\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tu_int memsize, n;\n\tu_char romdata[16], tmp;\n\tstatic u_char test_pattern[32] = \"THIS is A memory TEST pattern\";\n\tu_char test_buffer[32];\n\tint asicbase, nicbase;\n\n\tiot = ia->ia_iot;\n\n\tif (bus_space_map(iot, ia->ia_iobase, ED_NOVELL_IO_PORTS, 0, &ioh))\n\t\treturn (0);\n\n\tsc->asic_base = asicbase = ED_NOVELL_ASIC_OFFSET;\n\tsc->nic_base = nicbase = ED_NOVELL_NIC_OFFSET;\n\n\t/* XXX - do Novell-specific probe here */\n\n\t/* Reset the board. */\n#ifdef GWETHER\n\tbus_space_write_1(iot, ioh, asicbase + ED_NOVELL_RESET, 0);\n\tdelay(200);\n#endif /* GWETHER */\n\ttmp = bus_space_read_1(iot, ioh, asicbase + ED_NOVELL_RESET);\n\n\t/*\n\t * I don't know if this is necessary; probably cruft leftover from\n\t * Clarkson packet driver code. Doesn't do a thing on the boards I've\n\t * tested. -DG [note that a outb(0x84, 0) seems to work here, and is\n\t * non-invasive...but some boards don't seem to reset and I don't have\n\t * complete documentation on what the 'right' thing to do is...so we do\n\t * the invasive thing for now.  Yuck.]\n\t */\n\tbus_space_write_1(iot, ioh, asicbase + ED_NOVELL_RESET, tmp);\n\tdelay(5000);\n\n\t/*\n\t * This is needed because some NE clones apparently don't reset the NIC\n\t * properly (or the NIC chip doesn't reset fully on power-up)\n\t * XXX - this makes the probe invasive! ...Done against my better\n\t * judgement.  -DLG\n\t */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STP);\n\n\tdelay(5000);\n\n\t/* Make sure that we really have an 8390 based board. */\n\tif (!ed_probe_generic8390(iot, ioh, nicbase))\n\t\tgoto out;\n\n\tsc->vendor = ED_VENDOR_NOVELL;\n\tsc->mem_shared = 0;\n\tsc->cr_proto = ED_CR_RD2;\n\tia->ia_msize = 0;\n\n\t/*\n\t * Test the ability to read and write to the NIC memory.  This has the\n\t * side affect of determining if this is an NE1000 or an NE2000.\n\t */\n\n\t/*\n\t * This prevents packets from being stored in the NIC memory when the\n\t * readmem routine turns on the start bit in the CR.\n\t */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RCR, ED_RCR_MON);\n\n\t/* Temporarily initialize DCR for byte operations. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_DCR, ED_DCR_FT1 | ED_DCR_LS);\n\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTART, 8192 >> ED_PAGE_SHIFT);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTOP, 16384 >> ED_PAGE_SHIFT);\n\n\tsc->isa16bit = 0;\n\n\t/*\n\t * XXX indirect brokenness, used by ed_pio{read,write}mem()\n\t */\n\tsc->sc_iot = iot;\n\tsc->sc_ioh = ioh;\n\n\t/*\n\t * Write a test pattern in byte mode.  If this fails, then there\n\t * probably isn't any memory at 8k - which likely means that the board\n\t * is an NE2000.\n\t */\n\ted_pio_writemem(sc, test_pattern, 8192, sizeof(test_pattern));\n\ted_pio_readmem(sc, 8192, test_buffer, sizeof(test_pattern));\n\n\tif (bcmp(test_pattern, test_buffer, sizeof(test_pattern))) {\n\t\t/* not an NE1000 - try NE2000 */\n\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_DCR,\n\t\t    ED_DCR_WTS | ED_DCR_FT1 | ED_DCR_LS);\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTART, 16384 >> ED_PAGE_SHIFT);\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTOP, 32768 >> ED_PAGE_SHIFT);\n\n\t\tsc->isa16bit = 1;\n\n\t\t/*\n\t\t * Write a test pattern in word mode.  If this also fails, then\n\t\t * we don't know what this board is.\n\t\t */\n\t\ted_pio_writemem(sc, test_pattern, 16384, sizeof(test_pattern));\n\t\ted_pio_readmem(sc, 16384, test_buffer, sizeof(test_pattern));\n\n\t\tif (bcmp(test_pattern, test_buffer, sizeof(test_pattern)))\n\t\t\tgoto out; /* not an NE2000 either */\n\n\t\tsc->type = ED_TYPE_NE2000;\n\t\tsc->type_str = \"NE2000\";\n\t} else {\n\t\tsc->type = ED_TYPE_NE1000;\n\t\tsc->type_str = \"NE1000\";\n\t}\n\n\tif (ia->ia_irq == IRQUNK) {\n\t\tprintf(\"%s: %s does not have soft configuration\\n\",\n\t\t    sc->sc_dev.dv_xname, sc->type_str);\n\t\tgoto out;\n\t}\n\n\t/* 8k of memory plus an additional 8k if 16-bit. */\n\tmemsize = 8192 + sc->isa16bit * 8192;\n\n#if 0 /* probably not useful - NE boards only come two ways */\n\t/* Allow kernel config file overrides. */\n\tif (ia->ia_msize)\n\t\tmemsize = ia->ia_msize;\n#endif\n\n\t/* NIC memory doesn't start at zero on an NE board. */\n\t/* The start address is tied to the bus width. */\n\tsc->mem_start = (8192 + sc->isa16bit * 8192);\n\tsc->tx_page_start = memsize >> ED_PAGE_SHIFT;\n\n#ifdef GWETHER\n\t{\n\t\tint x, i, mstart = 0;\n\t\tchar pbuf0[ED_PAGE_SIZE], pbuf[ED_PAGE_SIZE], tbuf[ED_PAGE_SIZE];\n\n\t\tfor (i = 0; i < ED_PAGE_SIZE; i++)\n\t\t\tpbuf0[i] = 0;\n\n\t\t/* Search for the start of RAM. */\n\t\tfor (x = 1; x < 256; x++) {\n\t\t\ted_pio_writemem(sc, pbuf0, x << ED_PAGE_SHIFT, ED_PAGE_SIZE);\n\t\t\ted_pio_readmem(sc, x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE);\n\t\t\tif (!bcmp(pbuf0, tbuf, ED_PAGE_SIZE)) {\n\t\t\t\tfor (i = 0; i < ED_PAGE_SIZE; i++)\n\t\t\t\t\tpbuf[i] = 255 - x;\n\t\t\t\ted_pio_writemem(sc, pbuf, x << ED_PAGE_SHIFT, ED_PAGE_SIZE);\n\t\t\t\ted_pio_readmem(sc, x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE);\n\t\t\t\tif (!bcmp(pbuf, tbuf, ED_PAGE_SIZE)) {\n\t\t\t\t\tmstart = x << ED_PAGE_SHIFT;\n\t\t\t\t\tmemsize = ED_PAGE_SIZE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (mstart == 0) {\n\t\t\tprintf(\"%s: cannot find start of RAM\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* Search for the end of RAM. */\n\t\tfor (++x; x < 256; x++) {\n\t\t\ted_pio_writemem(sc, pbuf0, x << ED_PAGE_SHIFT, ED_PAGE_SIZE);\n\t\t\ted_pio_readmem(sc, x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE);\n\t\t\tif (!bcmp(pbuf0, tbuf, ED_PAGE_SIZE)) {\n\t\t\t\tfor (i = 0; i < ED_PAGE_SIZE; i++)\n\t\t\t\t\tpbuf[i] = 255 - x;\n\t\t\t\ted_pio_writemem(sc, pbuf, x << ED_PAGE_SHIFT, ED_PAGE_SIZE);\n\t\t\t\ted_pio_readmem(sc, x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE);\n\t\t\t\tif (!bcmp(pbuf, tbuf, ED_PAGE_SIZE))\n\t\t\t\t\tmemsize += ED_PAGE_SIZE;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\n\t\tprintf(\"%s: RAM start %x, size %d\\n\",\n\t\t    sc->sc_dev.dv_xname, mstart, memsize);\n\n\t\tsc->mem_start = (caddr_t)mstart;\n\t\tsc->tx_page_start = mstart >> ED_PAGE_SHIFT;\n\t}\n#endif /* GWETHER */\n\n\tsc->mem_size = memsize;\n\tsc->mem_end = sc->mem_start + memsize;\n\n\t/*\n\t * Use one xmit buffer if < 16k, two buffers otherwise (if not told\n\t * otherwise).\n\t */\n\tif ((memsize < 16384) || (cf->cf_flags & ED_FLAGS_NO_MULTI_BUFFERING))\n\t\tsc->txb_cnt = 1;\n\telse\n\t\tsc->txb_cnt = 2;\n\n\tsc->rec_page_start = sc->tx_page_start + sc->txb_cnt * ED_TXBUF_SIZE;\n\tsc->rec_page_stop = sc->tx_page_start + (memsize >> ED_PAGE_SHIFT);\n\n\tsc->mem_ring =\n\t    sc->mem_start + ((sc->txb_cnt * ED_TXBUF_SIZE) << ED_PAGE_SHIFT);\n\n\ted_pio_readmem(sc, 0, romdata, 16);\n\tfor (n = 0; n < ETHER_ADDR_LEN; n++)\n\t\tsc->sc_arpcom.ac_enaddr[n] = romdata[n*(sc->isa16bit+1)];\n\n#ifdef GWETHER\n\tif (sc->arpcom.ac_enaddr[2] == 0x86)\n\t\tsc->type_str = \"Gateway AT\";\n#endif /* GWETHER */\n\n\t/* Clear any pending interrupts that might have occurred above. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_ISR, 0xff);\n\n\tia->ia_iosize = ED_NOVELL_IO_PORTS;\n\n\t/*\n\t * XXX Sould always unmap, but we can't yet.\n\t * XXX Need to squish \"indirect\" first.\n\t */\n\tsc->sc_iot = iot;\n\tsc->sc_ioh = ioh;\n\t/* sc_memh is not used by this driver */\n\treturn 1;\n out:\n\tbus_space_unmap(iot, ioh, ED_NOVELL_IO_PORTS);\n\n\treturn 0;\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/isa/if_edreg.h>",
            "#include <dev/ic/dp8390reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/netisr.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"ed.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tETHER_ADDR_LEN\t6"
          ],
          "globals_used": [
            "int ed_probe_generic8390",
            "int ed_find_Novell",
            "void ed_pio_readmem",
            "void ed_pio_writemem",
            "struct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\n#define\tETHER_ADDR_LEN\t6\n\nint ed_probe_generic8390;\nint ed_find_Novell;\nvoid ed_pio_readmem;\nvoid ed_pio_writemem;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nint\ned_find_Novell(sc, cf, ia)\n\tstruct ed_softc *sc;\n\tstruct cfdata *cf;\n\tstruct isa_attach_args *ia;\n{\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tu_int memsize, n;\n\tu_char romdata[16], tmp;\n\tstatic u_char test_pattern[32] = \"THIS is A memory TEST pattern\";\n\tu_char test_buffer[32];\n\tint asicbase, nicbase;\n\n\tiot = ia->ia_iot;\n\n\tif (bus_space_map(iot, ia->ia_iobase, ED_NOVELL_IO_PORTS, 0, &ioh))\n\t\treturn (0);\n\n\tsc->asic_base = asicbase = ED_NOVELL_ASIC_OFFSET;\n\tsc->nic_base = nicbase = ED_NOVELL_NIC_OFFSET;\n\n\t/* XXX - do Novell-specific probe here */\n\n\t/* Reset the board. */\n#ifdef GWETHER\n\tbus_space_write_1(iot, ioh, asicbase + ED_NOVELL_RESET, 0);\n\tdelay(200);\n#endif /* GWETHER */\n\ttmp = bus_space_read_1(iot, ioh, asicbase + ED_NOVELL_RESET);\n\n\t/*\n\t * I don't know if this is necessary; probably cruft leftover from\n\t * Clarkson packet driver code. Doesn't do a thing on the boards I've\n\t * tested. -DG [note that a outb(0x84, 0) seems to work here, and is\n\t * non-invasive...but some boards don't seem to reset and I don't have\n\t * complete documentation on what the 'right' thing to do is...so we do\n\t * the invasive thing for now.  Yuck.]\n\t */\n\tbus_space_write_1(iot, ioh, asicbase + ED_NOVELL_RESET, tmp);\n\tdelay(5000);\n\n\t/*\n\t * This is needed because some NE clones apparently don't reset the NIC\n\t * properly (or the NIC chip doesn't reset fully on power-up)\n\t * XXX - this makes the probe invasive! ...Done against my better\n\t * judgement.  -DLG\n\t */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_CR,\n\t    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STP);\n\n\tdelay(5000);\n\n\t/* Make sure that we really have an 8390 based board. */\n\tif (!ed_probe_generic8390(iot, ioh, nicbase))\n\t\tgoto out;\n\n\tsc->vendor = ED_VENDOR_NOVELL;\n\tsc->mem_shared = 0;\n\tsc->cr_proto = ED_CR_RD2;\n\tia->ia_msize = 0;\n\n\t/*\n\t * Test the ability to read and write to the NIC memory.  This has the\n\t * side affect of determining if this is an NE1000 or an NE2000.\n\t */\n\n\t/*\n\t * This prevents packets from being stored in the NIC memory when the\n\t * readmem routine turns on the start bit in the CR.\n\t */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_RCR, ED_RCR_MON);\n\n\t/* Temporarily initialize DCR for byte operations. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_DCR, ED_DCR_FT1 | ED_DCR_LS);\n\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTART, 8192 >> ED_PAGE_SHIFT);\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTOP, 16384 >> ED_PAGE_SHIFT);\n\n\tsc->isa16bit = 0;\n\n\t/*\n\t * XXX indirect brokenness, used by ed_pio{read,write}mem()\n\t */\n\tsc->sc_iot = iot;\n\tsc->sc_ioh = ioh;\n\n\t/*\n\t * Write a test pattern in byte mode.  If this fails, then there\n\t * probably isn't any memory at 8k - which likely means that the board\n\t * is an NE2000.\n\t */\n\ted_pio_writemem(sc, test_pattern, 8192, sizeof(test_pattern));\n\ted_pio_readmem(sc, 8192, test_buffer, sizeof(test_pattern));\n\n\tif (bcmp(test_pattern, test_buffer, sizeof(test_pattern))) {\n\t\t/* not an NE1000 - try NE2000 */\n\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_DCR,\n\t\t    ED_DCR_WTS | ED_DCR_FT1 | ED_DCR_LS);\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTART, 16384 >> ED_PAGE_SHIFT);\n\t\tNIC_PUT(iot, ioh, nicbase, ED_P0_PSTOP, 32768 >> ED_PAGE_SHIFT);\n\n\t\tsc->isa16bit = 1;\n\n\t\t/*\n\t\t * Write a test pattern in word mode.  If this also fails, then\n\t\t * we don't know what this board is.\n\t\t */\n\t\ted_pio_writemem(sc, test_pattern, 16384, sizeof(test_pattern));\n\t\ted_pio_readmem(sc, 16384, test_buffer, sizeof(test_pattern));\n\n\t\tif (bcmp(test_pattern, test_buffer, sizeof(test_pattern)))\n\t\t\tgoto out; /* not an NE2000 either */\n\n\t\tsc->type = ED_TYPE_NE2000;\n\t\tsc->type_str = \"NE2000\";\n\t} else {\n\t\tsc->type = ED_TYPE_NE1000;\n\t\tsc->type_str = \"NE1000\";\n\t}\n\n\tif (ia->ia_irq == IRQUNK) {\n\t\tprintf(\"%s: %s does not have soft configuration\\n\",\n\t\t    sc->sc_dev.dv_xname, sc->type_str);\n\t\tgoto out;\n\t}\n\n\t/* 8k of memory plus an additional 8k if 16-bit. */\n\tmemsize = 8192 + sc->isa16bit * 8192;\n\n#if 0 /* probably not useful - NE boards only come two ways */\n\t/* Allow kernel config file overrides. */\n\tif (ia->ia_msize)\n\t\tmemsize = ia->ia_msize;\n#endif\n\n\t/* NIC memory doesn't start at zero on an NE board. */\n\t/* The start address is tied to the bus width. */\n\tsc->mem_start = (8192 + sc->isa16bit * 8192);\n\tsc->tx_page_start = memsize >> ED_PAGE_SHIFT;\n\n#ifdef GWETHER\n\t{\n\t\tint x, i, mstart = 0;\n\t\tchar pbuf0[ED_PAGE_SIZE], pbuf[ED_PAGE_SIZE], tbuf[ED_PAGE_SIZE];\n\n\t\tfor (i = 0; i < ED_PAGE_SIZE; i++)\n\t\t\tpbuf0[i] = 0;\n\n\t\t/* Search for the start of RAM. */\n\t\tfor (x = 1; x < 256; x++) {\n\t\t\ted_pio_writemem(sc, pbuf0, x << ED_PAGE_SHIFT, ED_PAGE_SIZE);\n\t\t\ted_pio_readmem(sc, x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE);\n\t\t\tif (!bcmp(pbuf0, tbuf, ED_PAGE_SIZE)) {\n\t\t\t\tfor (i = 0; i < ED_PAGE_SIZE; i++)\n\t\t\t\t\tpbuf[i] = 255 - x;\n\t\t\t\ted_pio_writemem(sc, pbuf, x << ED_PAGE_SHIFT, ED_PAGE_SIZE);\n\t\t\t\ted_pio_readmem(sc, x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE);\n\t\t\t\tif (!bcmp(pbuf, tbuf, ED_PAGE_SIZE)) {\n\t\t\t\t\tmstart = x << ED_PAGE_SHIFT;\n\t\t\t\t\tmemsize = ED_PAGE_SIZE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (mstart == 0) {\n\t\t\tprintf(\"%s: cannot find start of RAM\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* Search for the end of RAM. */\n\t\tfor (++x; x < 256; x++) {\n\t\t\ted_pio_writemem(sc, pbuf0, x << ED_PAGE_SHIFT, ED_PAGE_SIZE);\n\t\t\ted_pio_readmem(sc, x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE);\n\t\t\tif (!bcmp(pbuf0, tbuf, ED_PAGE_SIZE)) {\n\t\t\t\tfor (i = 0; i < ED_PAGE_SIZE; i++)\n\t\t\t\t\tpbuf[i] = 255 - x;\n\t\t\t\ted_pio_writemem(sc, pbuf, x << ED_PAGE_SHIFT, ED_PAGE_SIZE);\n\t\t\t\ted_pio_readmem(sc, x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE);\n\t\t\t\tif (!bcmp(pbuf, tbuf, ED_PAGE_SIZE))\n\t\t\t\t\tmemsize += ED_PAGE_SIZE;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\n\t\tprintf(\"%s: RAM start %x, size %d\\n\",\n\t\t    sc->sc_dev.dv_xname, mstart, memsize);\n\n\t\tsc->mem_start = (caddr_t)mstart;\n\t\tsc->tx_page_start = mstart >> ED_PAGE_SHIFT;\n\t}\n#endif /* GWETHER */\n\n\tsc->mem_size = memsize;\n\tsc->mem_end = sc->mem_start + memsize;\n\n\t/*\n\t * Use one xmit buffer if < 16k, two buffers otherwise (if not told\n\t * otherwise).\n\t */\n\tif ((memsize < 16384) || (cf->cf_flags & ED_FLAGS_NO_MULTI_BUFFERING))\n\t\tsc->txb_cnt = 1;\n\telse\n\t\tsc->txb_cnt = 2;\n\n\tsc->rec_page_start = sc->tx_page_start + sc->txb_cnt * ED_TXBUF_SIZE;\n\tsc->rec_page_stop = sc->tx_page_start + (memsize >> ED_PAGE_SHIFT);\n\n\tsc->mem_ring =\n\t    sc->mem_start + ((sc->txb_cnt * ED_TXBUF_SIZE) << ED_PAGE_SHIFT);\n\n\ted_pio_readmem(sc, 0, romdata, 16);\n\tfor (n = 0; n < ETHER_ADDR_LEN; n++)\n\t\tsc->sc_arpcom.ac_enaddr[n] = romdata[n*(sc->isa16bit+1)];\n\n#ifdef GWETHER\n\tif (sc->arpcom.ac_enaddr[2] == 0x86)\n\t\tsc->type_str = \"Gateway AT\";\n#endif /* GWETHER */\n\n\t/* Clear any pending interrupts that might have occurred above. */\n\tNIC_PUT(iot, ioh, nicbase, ED_P0_ISR, 0xff);\n\n\tia->ia_iosize = ED_NOVELL_IO_PORTS;\n\n\t/*\n\t * XXX Sould always unmap, but we can't yet.\n\t * XXX Need to squish \"indirect\" first.\n\t */\n\tsc->sc_iot = iot;\n\tsc->sc_ioh = ioh;\n\t/* sc_memh is not used by this driver */\n\treturn 1;\n out:\n\tbus_space_unmap(iot, ioh, ED_NOVELL_IO_PORTS);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/isa/if_edreg.h>\n#include <dev/ic/dp8390reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/netisr.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"ed.h\"\n#include \"bpfilter.h\"\n\n#define\tETHER_ADDR_LEN\t6\n#define ED_NOTPRESENT \t0x0002\t/* card not present; do not allow\n\t\t\t\t   reconfiguration */\n#define ED_REATTACH\t0x0001\t/* Reattach */\n\nint ed_find_Novell;\nstruct mbuf *\nedget(sc, src, totlen)\n\tstruct ed_softc *sc;\n\nint\ned_pcmcia_isa_attach(parent, match, aux, pc_link)\n\tstruct device *parent;\n\tvoid *match;\n\tvoid *aux;\n\tstruct pcmcia_link *pc_link;\n{\n\tstruct ed_softc *sc = match;\n\tstruct cfdata *cf = sc->sc_dev.dv_cfdata;\n\tstruct isa_attach_args *ia = aux;\n\tstruct pcmciadevs *dev=pc_link->device;\n\tint err;\n\textern int ifqmaxlen;\n\tu_char enaddr[ETHER_ADDR_LEN];\n\n\tif ((int)dev->param != -1)\n\t\terr = pcmcia_read_cis(pc_link, enaddr, \n\t\t\t\t      (int) dev->param, ETHER_ADDR_LEN);\n\telse\n\t\terr = 0;\n\tif (err)\n\t\tprintf(\"%s: attaching ed: cannot read cis info %d\\n\",\n\t\t       parent->dv_xname, err);\n\n\tif (ed_find_Novell(sc, cf, ia)) {\n\t\tdelay(100);\n\t\tif ((int)dev->param != -1) {\n\t\t    err = pcmcia_read_cis(pc_link, sc->sc_arpcom.ac_enaddr,\n\t\t\t\t      (int) dev->param, ETHER_ADDR_LEN);\n\t\t    if (err) {\n\t\t\t    printf(\"Cannot read cis info %d\\n\", err);\n\t\t\t    return 0;\n\t\t    }\n\t\t    if (bcmp(enaddr, sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN)) {\n\t\t\t    printf(\"ENADDR MISMATCH %s \",\n\t\t\t\t   ether_sprintf(sc->sc_arpcom.ac_enaddr));\n\t\t\t    printf(\"- %s\\n\", ether_sprintf(enaddr));\n\t\t\t    bcopy(enaddr,sc->sc_arpcom.ac_enaddr,\n\t\t\t\t\t    ETHER_ADDR_LEN);\n\t\t    }\n\t\t}\n\t\t/* clear ED_NOTPRESENT, set ED_REATTACH if needed */\n\t\tsc->spec_flags=pc_link->flags&PCMCIA_REATTACH?ED_REATTACH:0;\n\t\tsc->type_str = dev->model;\n\t\tsc->sc_arpcom.ac_if.if_snd.ifq_maxlen=ifqmaxlen;\n\t\tsc->sc_ic = ia->ia_ic;\n\t\treturn 1;\n\t} else\n\t    return 0;\n}"
  }
]