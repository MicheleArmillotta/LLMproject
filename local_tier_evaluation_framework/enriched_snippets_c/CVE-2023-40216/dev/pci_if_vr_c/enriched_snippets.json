[
  {
    "function_name": "vr_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
    "lines": "1950-1957",
    "snippet": "void\nvr_shutdown(arg)\n\tvoid\t\t\t*arg;\n{\n\tstruct vr_softc\t\t*sc = (struct vr_softc *)arg;\n\n\tvr_stop(sc);\n}",
    "includes": [
      "#include <dev/pci/if_vrreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/device.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void vr_stop",
      "void vr_shutdown"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vr_stop",
          "args": [
            "sc"
          ],
          "line": 1956
        },
        "resolved": true,
        "details": {
          "function_name": "vr_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "1900-1944",
          "snippet": "void\nvr_stop(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_timer = 0;\n\n\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_STOP);\n\tVR_CLRBIT16(sc, VR_COMMAND, (VR_CMD_RX_ON|VR_CMD_TX_ON));\n\tCSR_WRITE_2(sc, VR_IMR, 0x0000);\n\tCSR_WRITE_4(sc, VR_TXADDR, 0x00000000);\n\tCSR_WRITE_4(sc, VR_RXADDR, 0x00000000);\n\n\t/*\n\t * Free data in the RX lists.\n\t */\n\tfor (i = 0; i < VR_RX_LIST_CNT; i++) {\n\t\tif (sc->vr_cdata.vr_rx_chain[i].vr_mbuf != NULL) {\n\t\t\tm_freem(sc->vr_cdata.vr_rx_chain[i].vr_mbuf);\n\t\t\tsc->vr_cdata.vr_rx_chain[i].vr_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->vr_ldata->vr_rx_list,\n\t\tsizeof(sc->vr_ldata->vr_rx_list));\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < VR_TX_LIST_CNT; i++) {\n\t\tif (sc->vr_cdata.vr_tx_chain[i].vr_mbuf != NULL) {\n\t\t\tm_freem(sc->vr_cdata.vr_tx_chain[i].vr_mbuf);\n\t\t\tsc->vr_cdata.vr_tx_chain[i].vr_mbuf = NULL;\n\t\t}\n\t}\n\n\tbzero((char *)&sc->vr_ldata->vr_tx_list,\n\t\tsizeof(sc->vr_ldata->vr_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void vr_stop"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_stop;\n\nvoid\nvr_stop(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_timer = 0;\n\n\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_STOP);\n\tVR_CLRBIT16(sc, VR_COMMAND, (VR_CMD_RX_ON|VR_CMD_TX_ON));\n\tCSR_WRITE_2(sc, VR_IMR, 0x0000);\n\tCSR_WRITE_4(sc, VR_TXADDR, 0x00000000);\n\tCSR_WRITE_4(sc, VR_RXADDR, 0x00000000);\n\n\t/*\n\t * Free data in the RX lists.\n\t */\n\tfor (i = 0; i < VR_RX_LIST_CNT; i++) {\n\t\tif (sc->vr_cdata.vr_rx_chain[i].vr_mbuf != NULL) {\n\t\t\tm_freem(sc->vr_cdata.vr_rx_chain[i].vr_mbuf);\n\t\t\tsc->vr_cdata.vr_rx_chain[i].vr_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->vr_ldata->vr_rx_list,\n\t\tsizeof(sc->vr_ldata->vr_rx_list));\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < VR_TX_LIST_CNT; i++) {\n\t\tif (sc->vr_cdata.vr_tx_chain[i].vr_mbuf != NULL) {\n\t\t\tm_freem(sc->vr_cdata.vr_tx_chain[i].vr_mbuf);\n\t\t\tsc->vr_cdata.vr_tx_chain[i].vr_mbuf = NULL;\n\t\t}\n\t}\n\n\tbzero((char *)&sc->vr_ldata->vr_tx_list,\n\t\tsizeof(sc->vr_ldata->vr_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_stop;\nvoid vr_shutdown;\n\nvoid\nvr_shutdown(arg)\n\tvoid\t\t\t*arg;\n{\n\tstruct vr_softc\t\t*sc = (struct vr_softc *)arg;\n\n\tvr_stop(sc);\n}"
  },
  {
    "function_name": "vr_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
    "lines": "1900-1944",
    "snippet": "void\nvr_stop(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_timer = 0;\n\n\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_STOP);\n\tVR_CLRBIT16(sc, VR_COMMAND, (VR_CMD_RX_ON|VR_CMD_TX_ON));\n\tCSR_WRITE_2(sc, VR_IMR, 0x0000);\n\tCSR_WRITE_4(sc, VR_TXADDR, 0x00000000);\n\tCSR_WRITE_4(sc, VR_RXADDR, 0x00000000);\n\n\t/*\n\t * Free data in the RX lists.\n\t */\n\tfor (i = 0; i < VR_RX_LIST_CNT; i++) {\n\t\tif (sc->vr_cdata.vr_rx_chain[i].vr_mbuf != NULL) {\n\t\t\tm_freem(sc->vr_cdata.vr_rx_chain[i].vr_mbuf);\n\t\t\tsc->vr_cdata.vr_rx_chain[i].vr_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->vr_ldata->vr_rx_list,\n\t\tsizeof(sc->vr_ldata->vr_rx_list));\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < VR_TX_LIST_CNT; i++) {\n\t\tif (sc->vr_cdata.vr_tx_chain[i].vr_mbuf != NULL) {\n\t\t\tm_freem(sc->vr_cdata.vr_tx_chain[i].vr_mbuf);\n\t\t\tsc->vr_cdata.vr_tx_chain[i].vr_mbuf = NULL;\n\t\t}\n\t}\n\n\tbzero((char *)&sc->vr_ldata->vr_tx_list,\n\t\tsizeof(sc->vr_ldata->vr_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_vrreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/device.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void vr_stop"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)&sc->vr_ldata->vr_tx_list",
            "sizeof(sc->vr_ldata->vr_tx_list)"
          ],
          "line": 1938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "sc->vr_cdata.vr_tx_chain[i].vr_mbuf"
          ],
          "line": 1933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)&sc->vr_ldata->vr_rx_list",
            "sizeof(sc->vr_ldata->vr_rx_list)"
          ],
          "line": 1925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "sc->vr_cdata.vr_rx_chain[i].vr_mbuf"
          ],
          "line": 1921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "VR_RXADDR",
            "0x00000000"
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "VR_TXADDR",
            "0x00000000"
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "VR_IMR",
            "0x0000"
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VR_CLRBIT16",
          "args": [
            "sc",
            "VR_COMMAND",
            "(VR_CMD_RX_ON|VR_CMD_TX_ON)"
          ],
          "line": 1911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VR_SETBIT16",
          "args": [
            "sc",
            "VR_COMMAND",
            "VR_CMD_STOP"
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_stop;\n\nvoid\nvr_stop(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_timer = 0;\n\n\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_STOP);\n\tVR_CLRBIT16(sc, VR_COMMAND, (VR_CMD_RX_ON|VR_CMD_TX_ON));\n\tCSR_WRITE_2(sc, VR_IMR, 0x0000);\n\tCSR_WRITE_4(sc, VR_TXADDR, 0x00000000);\n\tCSR_WRITE_4(sc, VR_RXADDR, 0x00000000);\n\n\t/*\n\t * Free data in the RX lists.\n\t */\n\tfor (i = 0; i < VR_RX_LIST_CNT; i++) {\n\t\tif (sc->vr_cdata.vr_rx_chain[i].vr_mbuf != NULL) {\n\t\t\tm_freem(sc->vr_cdata.vr_rx_chain[i].vr_mbuf);\n\t\t\tsc->vr_cdata.vr_rx_chain[i].vr_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->vr_ldata->vr_rx_list,\n\t\tsizeof(sc->vr_ldata->vr_rx_list));\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < VR_TX_LIST_CNT; i++) {\n\t\tif (sc->vr_cdata.vr_tx_chain[i].vr_mbuf != NULL) {\n\t\t\tm_freem(sc->vr_cdata.vr_tx_chain[i].vr_mbuf);\n\t\t\tsc->vr_cdata.vr_tx_chain[i].vr_mbuf = NULL;\n\t\t}\n\t}\n\n\tbzero((char *)&sc->vr_ldata->vr_tx_list,\n\t\tsizeof(sc->vr_ldata->vr_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}"
  },
  {
    "function_name": "vr_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
    "lines": "1866-1894",
    "snippet": "void\nvr_watchdog(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct vr_softc\t\t*sc;\n\n\tsc = ifp->if_softc;\n\n\tif (sc->vr_autoneg) {\n\t\tvr_autoneg_mii(sc, VR_FLAG_DELAYTIMEO, 1);\n\t\treturn;\n\t}\n\n\tifp->if_oerrors++;\n\tprintf(\"%s: watchdog timeout\\n\", sc->sc_dev.dv_xname);\n\n\tif (!(vr_phy_readreg(sc, PHY_BMSR) & PHY_BMSR_LINKSTAT))\n\t\tprintf(\"%s: no carrier - transceiver cable problem?\\n\",\n\t\t\t\t\t\t\tsc->sc_dev.dv_xname);\n\n\tvr_stop(sc);\n\tvr_reset(sc);\n\tvr_init(sc);\n\n\tif (ifp->if_snd.ifq_head != NULL)\n\t\tvr_start(ifp);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_vrreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/device.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void vr_start",
      "void vr_init",
      "void vr_stop",
      "void vr_watchdog",
      "u_int16_t vr_phy_readreg",
      "void vr_autoneg_mii",
      "void vr_reset"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vr_start",
          "args": [
            "ifp"
          ],
          "line": 1891
        },
        "resolved": true,
        "details": {
          "function_name": "vr_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "1558-1628",
          "snippet": "void\nvr_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct vr_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head = NULL;\n\tstruct vr_chain\t\t*cur_tx = NULL, *start_tx;\n\n\tsc = ifp->if_softc;\n\n\tif (sc->vr_autoneg) {\n\t\tsc->vr_tx_pend = 1;\n\t\treturn;\n\t}\n\n\t/*\n\t * Check for an available queue slot. If there are none,\n\t * punt.\n\t */\n\tif (sc->vr_cdata.vr_tx_free->vr_mbuf != NULL) {\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\n\tstart_tx = sc->vr_cdata.vr_tx_free;\n\n\twhile(sc->vr_cdata.vr_tx_free->vr_mbuf == NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\t/* Pick a descriptor off the free list. */\n\t\tcur_tx = sc->vr_cdata.vr_tx_free;\n\t\tsc->vr_cdata.vr_tx_free = cur_tx->vr_nextdesc;\n\n\t\t/* Pack the data into the descriptor. */\n\t\tvr_encap(sc, cur_tx, m_head);\n\n\t\tif (cur_tx != start_tx)\n\t\t\tVR_TXOWN(cur_tx) = VR_TXSTAT_OWN;\n\n#if NBPFILTER > 0\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, cur_tx->vr_mbuf);\n#endif\n\t\tVR_TXOWN(cur_tx) = VR_TXSTAT_OWN;\n\t\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_TX_ON|VR_CMD_TX_GO);\n\t}\n\n\t/*\n\t * If there are no frames queued, bail.\n\t */\n\tif (cur_tx == NULL)\n\t\treturn;\n\n\tsc->vr_cdata.vr_tx_tail = cur_tx;\n\n\tif (sc->vr_cdata.vr_tx_head == NULL)\n\t\tsc->vr_cdata.vr_tx_head = start_tx;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int vr_encap",
            "void vr_start"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint vr_encap;\nvoid vr_start;\n\nvoid\nvr_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct vr_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head = NULL;\n\tstruct vr_chain\t\t*cur_tx = NULL, *start_tx;\n\n\tsc = ifp->if_softc;\n\n\tif (sc->vr_autoneg) {\n\t\tsc->vr_tx_pend = 1;\n\t\treturn;\n\t}\n\n\t/*\n\t * Check for an available queue slot. If there are none,\n\t * punt.\n\t */\n\tif (sc->vr_cdata.vr_tx_free->vr_mbuf != NULL) {\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\n\tstart_tx = sc->vr_cdata.vr_tx_free;\n\n\twhile(sc->vr_cdata.vr_tx_free->vr_mbuf == NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\t/* Pick a descriptor off the free list. */\n\t\tcur_tx = sc->vr_cdata.vr_tx_free;\n\t\tsc->vr_cdata.vr_tx_free = cur_tx->vr_nextdesc;\n\n\t\t/* Pack the data into the descriptor. */\n\t\tvr_encap(sc, cur_tx, m_head);\n\n\t\tif (cur_tx != start_tx)\n\t\t\tVR_TXOWN(cur_tx) = VR_TXSTAT_OWN;\n\n#if NBPFILTER > 0\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, cur_tx->vr_mbuf);\n#endif\n\t\tVR_TXOWN(cur_tx) = VR_TXSTAT_OWN;\n\t\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_TX_ON|VR_CMD_TX_GO);\n\t}\n\n\t/*\n\t * If there are no frames queued, bail.\n\t */\n\tif (cur_tx == NULL)\n\t\treturn;\n\n\tsc->vr_cdata.vr_tx_tail = cur_tx;\n\n\tif (sc->vr_cdata.vr_tx_head == NULL)\n\t\tsc->vr_cdata.vr_tx_head = start_tx;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vr_init",
          "args": [
            "sc"
          ],
          "line": 1888
        },
        "resolved": true,
        "details": {
          "function_name": "vr_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "1630-1720",
          "snippet": "void\nvr_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct vr_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tu_int16_t\t\tphy_bmcr = 0;\n\tint\t\t\ts;\n\n\tif (sc->vr_autoneg)\n\t\treturn;\n\n\ts = splimp();\n\n\tif (sc->vr_pinfo != NULL)\n\t\tphy_bmcr = vr_phy_readreg(sc, PHY_BMCR);\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\tvr_stop(sc);\n\tvr_reset(sc);\n\n\tVR_CLRBIT(sc, VR_RXCFG, VR_RXCFG_RX_THRESH);\n\tVR_SETBIT(sc, VR_RXCFG, VR_RXTHRESH_STORENFWD);\n\n\tVR_CLRBIT(sc, VR_TXCFG, VR_TXCFG_TX_THRESH);\n\tVR_SETBIT(sc, VR_TXCFG, VR_TXTHRESH_STORENFWD);\n\n\t/* Init circular RX list. */\n\tif (vr_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: initialization failed: no memory for rx buffers\\n\",\n\t\t\t\t\t\t\tsc->sc_dev.dv_xname);\n\t\tvr_stop(sc);\n\t\t(void)splx(s);\n\t\treturn;\n\t}\n\n\t/*\n\t * Init tx descriptors.\n\t */\n\tvr_list_tx_init(sc);\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tVR_SETBIT(sc, VR_RXCFG, VR_RXCFG_RX_PROMISC);\n\telse\n\t\tVR_CLRBIT(sc, VR_RXCFG, VR_RXCFG_RX_PROMISC);\n\n\t/* Set capture broadcast bit to capture broadcast frames. */\n\tif (ifp->if_flags & IFF_BROADCAST)\n\t\tVR_SETBIT(sc, VR_RXCFG, VR_RXCFG_RX_BROAD);\n\telse\n\t\tVR_CLRBIT(sc, VR_RXCFG, VR_RXCFG_RX_BROAD);\n\n\t/*\n\t * Program the multicast filter, if necessary.\n\t */\n\tvr_setmulti(sc);\n\n\t/*\n\t * Load the address of the RX list.\n\t */\n\tCSR_WRITE_4(sc, VR_RXADDR, vtophys(sc->vr_cdata.vr_rx_head->vr_ptr));\n\n\t/* Enable receiver and transmitter. */\n\tCSR_WRITE_2(sc, VR_COMMAND, VR_CMD_TX_NOPOLL|VR_CMD_START|\n\t\t\t\t    VR_CMD_TX_ON|VR_CMD_RX_ON|\n\t\t\t\t    VR_CMD_RX_GO);\n\n\tvr_setcfg(sc, vr_phy_readreg(sc, PHY_BMCR));\n\n\tCSR_WRITE_4(sc, VR_TXADDR, vtophys(&sc->vr_ldata->vr_tx_list[0]));\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_2(sc, VR_ISR, 0xFFFF);\n\tCSR_WRITE_2(sc, VR_IMR, VR_INTRS);\n\n\t/* Restore state of BMCR */\n\tif (sc->vr_pinfo != NULL)\n\t\tvr_phy_writereg(sc, PHY_BMCR, phy_bmcr);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void vr_init",
            "void vr_stop",
            "u_int16_t vr_phy_readreg",
            "void vr_phy_writereg",
            "void vr_setcfg",
            "void vr_setmulti",
            "void vr_reset",
            "int vr_list_rx_init",
            "int vr_list_tx_init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_init;\nvoid vr_stop;\nu_int16_t vr_phy_readreg;\nvoid vr_phy_writereg;\nvoid vr_setcfg;\nvoid vr_setmulti;\nvoid vr_reset;\nint vr_list_rx_init;\nint vr_list_tx_init;\n\nvoid\nvr_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct vr_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tu_int16_t\t\tphy_bmcr = 0;\n\tint\t\t\ts;\n\n\tif (sc->vr_autoneg)\n\t\treturn;\n\n\ts = splimp();\n\n\tif (sc->vr_pinfo != NULL)\n\t\tphy_bmcr = vr_phy_readreg(sc, PHY_BMCR);\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\tvr_stop(sc);\n\tvr_reset(sc);\n\n\tVR_CLRBIT(sc, VR_RXCFG, VR_RXCFG_RX_THRESH);\n\tVR_SETBIT(sc, VR_RXCFG, VR_RXTHRESH_STORENFWD);\n\n\tVR_CLRBIT(sc, VR_TXCFG, VR_TXCFG_TX_THRESH);\n\tVR_SETBIT(sc, VR_TXCFG, VR_TXTHRESH_STORENFWD);\n\n\t/* Init circular RX list. */\n\tif (vr_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: initialization failed: no memory for rx buffers\\n\",\n\t\t\t\t\t\t\tsc->sc_dev.dv_xname);\n\t\tvr_stop(sc);\n\t\t(void)splx(s);\n\t\treturn;\n\t}\n\n\t/*\n\t * Init tx descriptors.\n\t */\n\tvr_list_tx_init(sc);\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tVR_SETBIT(sc, VR_RXCFG, VR_RXCFG_RX_PROMISC);\n\telse\n\t\tVR_CLRBIT(sc, VR_RXCFG, VR_RXCFG_RX_PROMISC);\n\n\t/* Set capture broadcast bit to capture broadcast frames. */\n\tif (ifp->if_flags & IFF_BROADCAST)\n\t\tVR_SETBIT(sc, VR_RXCFG, VR_RXCFG_RX_BROAD);\n\telse\n\t\tVR_CLRBIT(sc, VR_RXCFG, VR_RXCFG_RX_BROAD);\n\n\t/*\n\t * Program the multicast filter, if necessary.\n\t */\n\tvr_setmulti(sc);\n\n\t/*\n\t * Load the address of the RX list.\n\t */\n\tCSR_WRITE_4(sc, VR_RXADDR, vtophys(sc->vr_cdata.vr_rx_head->vr_ptr));\n\n\t/* Enable receiver and transmitter. */\n\tCSR_WRITE_2(sc, VR_COMMAND, VR_CMD_TX_NOPOLL|VR_CMD_START|\n\t\t\t\t    VR_CMD_TX_ON|VR_CMD_RX_ON|\n\t\t\t\t    VR_CMD_RX_GO);\n\n\tvr_setcfg(sc, vr_phy_readreg(sc, PHY_BMCR));\n\n\tCSR_WRITE_4(sc, VR_TXADDR, vtophys(&sc->vr_ldata->vr_tx_list[0]));\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_2(sc, VR_ISR, 0xFFFF);\n\tCSR_WRITE_2(sc, VR_IMR, VR_INTRS);\n\n\t/* Restore state of BMCR */\n\tif (sc->vr_pinfo != NULL)\n\t\tvr_phy_writereg(sc, PHY_BMCR, phy_bmcr);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vr_reset",
          "args": [
            "sc"
          ],
          "line": 1887
        },
        "resolved": true,
        "details": {
          "function_name": "vr_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "830-850",
          "snippet": "void\nvr_reset(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_RESET);\n\n\tfor (i = 0; i < VR_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(CSR_READ_2(sc, VR_COMMAND) & VR_CMD_RESET))\n\t\t\tbreak;\n\t}\n\tif (i == VR_TIMEOUT)\n\t\tprintf(\"%s: reset never completed!\\n\", sc->sc_dev.dv_xname);\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tDELAY(1000);\n\n        return;\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void vr_reset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_reset;\n\nvoid\nvr_reset(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_RESET);\n\n\tfor (i = 0; i < VR_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(CSR_READ_2(sc, VR_COMMAND) & VR_CMD_RESET))\n\t\t\tbreak;\n\t}\n\tif (i == VR_TIMEOUT)\n\t\tprintf(\"%s: reset never completed!\\n\", sc->sc_dev.dv_xname);\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tDELAY(1000);\n\n        return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vr_stop",
          "args": [
            "sc"
          ],
          "line": 1886
        },
        "resolved": true,
        "details": {
          "function_name": "vr_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "1900-1944",
          "snippet": "void\nvr_stop(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_timer = 0;\n\n\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_STOP);\n\tVR_CLRBIT16(sc, VR_COMMAND, (VR_CMD_RX_ON|VR_CMD_TX_ON));\n\tCSR_WRITE_2(sc, VR_IMR, 0x0000);\n\tCSR_WRITE_4(sc, VR_TXADDR, 0x00000000);\n\tCSR_WRITE_4(sc, VR_RXADDR, 0x00000000);\n\n\t/*\n\t * Free data in the RX lists.\n\t */\n\tfor (i = 0; i < VR_RX_LIST_CNT; i++) {\n\t\tif (sc->vr_cdata.vr_rx_chain[i].vr_mbuf != NULL) {\n\t\t\tm_freem(sc->vr_cdata.vr_rx_chain[i].vr_mbuf);\n\t\t\tsc->vr_cdata.vr_rx_chain[i].vr_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->vr_ldata->vr_rx_list,\n\t\tsizeof(sc->vr_ldata->vr_rx_list));\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < VR_TX_LIST_CNT; i++) {\n\t\tif (sc->vr_cdata.vr_tx_chain[i].vr_mbuf != NULL) {\n\t\t\tm_freem(sc->vr_cdata.vr_tx_chain[i].vr_mbuf);\n\t\t\tsc->vr_cdata.vr_tx_chain[i].vr_mbuf = NULL;\n\t\t}\n\t}\n\n\tbzero((char *)&sc->vr_ldata->vr_tx_list,\n\t\tsizeof(sc->vr_ldata->vr_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void vr_stop"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_stop;\n\nvoid\nvr_stop(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_timer = 0;\n\n\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_STOP);\n\tVR_CLRBIT16(sc, VR_COMMAND, (VR_CMD_RX_ON|VR_CMD_TX_ON));\n\tCSR_WRITE_2(sc, VR_IMR, 0x0000);\n\tCSR_WRITE_4(sc, VR_TXADDR, 0x00000000);\n\tCSR_WRITE_4(sc, VR_RXADDR, 0x00000000);\n\n\t/*\n\t * Free data in the RX lists.\n\t */\n\tfor (i = 0; i < VR_RX_LIST_CNT; i++) {\n\t\tif (sc->vr_cdata.vr_rx_chain[i].vr_mbuf != NULL) {\n\t\t\tm_freem(sc->vr_cdata.vr_rx_chain[i].vr_mbuf);\n\t\t\tsc->vr_cdata.vr_rx_chain[i].vr_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->vr_ldata->vr_rx_list,\n\t\tsizeof(sc->vr_ldata->vr_rx_list));\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < VR_TX_LIST_CNT; i++) {\n\t\tif (sc->vr_cdata.vr_tx_chain[i].vr_mbuf != NULL) {\n\t\t\tm_freem(sc->vr_cdata.vr_tx_chain[i].vr_mbuf);\n\t\t\tsc->vr_cdata.vr_tx_chain[i].vr_mbuf = NULL;\n\t\t}\n\t}\n\n\tbzero((char *)&sc->vr_ldata->vr_tx_list,\n\t\tsizeof(sc->vr_ldata->vr_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: no carrier - transceiver cable problem?\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1883
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vr_phy_readreg",
          "args": [
            "sc",
            "PHY_BMSR"
          ],
          "line": 1882
        },
        "resolved": true,
        "details": {
          "function_name": "vr_phy_readreg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "390-404",
          "snippet": "u_int16_t\nvr_phy_readreg(sc, reg)\n\tstruct vr_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tstruct vr_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->vr_phy_addr;\n\tframe.mii_regaddr = reg;\n\tvr_mii_readreg(sc, &frame);\n\n\treturn(frame.mii_data);\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int vr_mii_readreg",
            "u_int16_t vr_phy_readreg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint vr_mii_readreg;\nu_int16_t vr_phy_readreg;\n\nu_int16_t\nvr_phy_readreg(sc, reg)\n\tstruct vr_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tstruct vr_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->vr_phy_addr;\n\tframe.mii_regaddr = reg;\n\tvr_mii_readreg(sc, &frame);\n\n\treturn(frame.mii_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vr_autoneg_mii",
          "args": [
            "sc",
            "VR_FLAG_DELAYTIMEO",
            "1"
          ],
          "line": 1875
        },
        "resolved": true,
        "details": {
          "function_name": "vr_autoneg_mii",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "535-679",
          "snippet": "void\nvr_autoneg_mii(sc, flag, verbose)\n\tstruct vr_softc\t\t*sc;\n\tint\t\t\tflag;\n\tint\t\t\tverbose;\n{\n\tu_int16_t\t\tphy_sts = 0, media, advert, ability;\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmedia\t\t*ifm;\n\n\tifm = &sc->ifmedia;\n\tifp = &sc->arpcom.ac_if;\n\n\tifm->ifm_media = IFM_ETHER | IFM_AUTO;\n\n\t/*\n\t * The 100baseT4 PHY on the 3c905-T4 has the 'autoneg supported'\n\t * bit cleared in the status register, but has the 'autoneg enabled'\n\t * bit set in the control register. This is a contradiction, and\n\t * I'm not sure how to handle it. If you want to force an attempt\n\t * to autoneg for 100baseT4 PHYs, #define FORCE_AUTONEG_TFOUR\n\t * and see what happens.\n\t */\n#ifndef FORCE_AUTONEG_TFOUR\n\t/*\n\t * First, see if autoneg is supported. If not, there's\n\t * no point in continuing.\n\t */\n\tphy_sts = vr_phy_readreg(sc, PHY_BMSR);\n\tif (!(phy_sts & PHY_BMSR_CANAUTONEG)) {\n\t\tif (verbose)\n\t\t\tprintf(\"%s: autonegotiation not supported\\n\",\n\t\t\t\t\t\t\tsc->sc_dev.dv_xname);\n\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;\t\n\t\treturn;\n\t}\n#endif\n\n\tswitch (flag) {\n\tcase VR_FLAG_FORCEDELAY:\n\t\t/*\n\t \t * XXX Never use this option anywhere but in the probe\n\t \t * routine: making the kernel stop dead in its tracks\n \t\t * for three whole seconds after we've gone multi-user\n\t\t * is really bad manners.\n\t \t */\n\t\tvr_autoneg_xmit(sc);\n\t\tDELAY(5000000);\n\t\tbreak;\n\tcase VR_FLAG_SCHEDDELAY:\n\t\t/*\n\t\t * Wait for the transmitter to go idle before starting\n\t\t * an autoneg session, otherwise vr_start() may clobber\n\t \t * our timeout, and we don't want to allow transmission\n\t\t * during an autoneg session since that can screw it up.\n\t \t */\n\t\tif (sc->vr_cdata.vr_tx_head != NULL) {\n\t\t\tsc->vr_want_auto = 1;\n\t\t\treturn;\n\t\t}\n\t\tvr_autoneg_xmit(sc);\n\t\tifp->if_timer = 5;\n\t\tsc->vr_autoneg = 1;\n\t\tsc->vr_want_auto = 0;\n\t\treturn;\n\t\tbreak;\n\tcase VR_FLAG_DELAYTIMEO:\n\t\tifp->if_timer = 0;\n\t\tsc->vr_autoneg = 0;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: invalid autoneg flag: %d\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname, flag);\n\t\treturn;\n\t}\n\n\tif (vr_phy_readreg(sc, PHY_BMSR) & PHY_BMSR_AUTONEGCOMP) {\n\t\tif (verbose)\n\t\t\tprintf(\"%s: autoneg complete, \", sc->sc_dev.dv_xname);\n\t\tphy_sts = vr_phy_readreg(sc, PHY_BMSR);\n\t} else {\n\t\tif (verbose)\n\t\t\tprintf(\"%s: autoneg not complete, \",\n\t\t\t\t\t\tsc->sc_dev.dv_xname);\n\t}\n\n\tmedia = vr_phy_readreg(sc, PHY_BMCR);\n\n\t/* Link is good. Report modes and set duplex mode. */\n\tif (vr_phy_readreg(sc, PHY_BMSR) & PHY_BMSR_LINKSTAT) {\n\t\tif (verbose)\n\t\t\tprintf(\"link status good \");\n\t\tadvert = vr_phy_readreg(sc, PHY_ANAR);\n\t\tability = vr_phy_readreg(sc, PHY_LPAR);\n\n\t\tif (advert & PHY_ANAR_100BT4 && ability & PHY_ANAR_100BT4) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_T4;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(100baseT4)\\n\");\n\t\t} else if (advert & PHY_ANAR_100BTXFULL &&\n\t\t\tability & PHY_ANAR_100BTXFULL) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_FDX;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia |= PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(full-duplex, 100Mbps)\\n\");\n\t\t} else if (advert & PHY_ANAR_100BTXHALF &&\n\t\t\tability & PHY_ANAR_100BTXHALF) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_HDX;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(half-duplex, 100Mbps)\\n\");\n\t\t} else if (advert & PHY_ANAR_10BTFULL &&\n\t\t\tability & PHY_ANAR_10BTFULL) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_FDX;\n\t\t\tmedia &= ~PHY_BMCR_SPEEDSEL;\n\t\t\tmedia |= PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(full-duplex, 10Mbps)\\n\");\n\t\t} else {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;\n\t\t\tmedia &= ~PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(half-duplex, 10Mbps)\\n\");\n\t\t}\n\n\t\tmedia &= ~PHY_BMCR_AUTONEGENBL;\n\n\t\t/* Set ASIC's duplex mode to match the PHY. */\n\t\tvr_setcfg(sc, media);\n\t\tvr_phy_writereg(sc, PHY_BMCR, media);\n\t} else {\n\t\tif (verbose)\n\t\t\tprintf(\"no carrier\\n\");\n\t}\n\n\tvr_init(sc);\n\n\tif (sc->vr_tx_pend) {\n\t\tsc->vr_autoneg = 0;\n\t\tsc->vr_tx_pend = 0;\n\t\tvr_start(ifp);\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void vr_start",
            "void vr_init",
            "u_int16_t vr_phy_readreg",
            "void vr_phy_writereg",
            "void vr_autoneg_xmit",
            "void vr_autoneg_mii",
            "void vr_setcfg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_start;\nvoid vr_init;\nu_int16_t vr_phy_readreg;\nvoid vr_phy_writereg;\nvoid vr_autoneg_xmit;\nvoid vr_autoneg_mii;\nvoid vr_setcfg;\n\nvoid\nvr_autoneg_mii(sc, flag, verbose)\n\tstruct vr_softc\t\t*sc;\n\tint\t\t\tflag;\n\tint\t\t\tverbose;\n{\n\tu_int16_t\t\tphy_sts = 0, media, advert, ability;\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmedia\t\t*ifm;\n\n\tifm = &sc->ifmedia;\n\tifp = &sc->arpcom.ac_if;\n\n\tifm->ifm_media = IFM_ETHER | IFM_AUTO;\n\n\t/*\n\t * The 100baseT4 PHY on the 3c905-T4 has the 'autoneg supported'\n\t * bit cleared in the status register, but has the 'autoneg enabled'\n\t * bit set in the control register. This is a contradiction, and\n\t * I'm not sure how to handle it. If you want to force an attempt\n\t * to autoneg for 100baseT4 PHYs, #define FORCE_AUTONEG_TFOUR\n\t * and see what happens.\n\t */\n#ifndef FORCE_AUTONEG_TFOUR\n\t/*\n\t * First, see if autoneg is supported. If not, there's\n\t * no point in continuing.\n\t */\n\tphy_sts = vr_phy_readreg(sc, PHY_BMSR);\n\tif (!(phy_sts & PHY_BMSR_CANAUTONEG)) {\n\t\tif (verbose)\n\t\t\tprintf(\"%s: autonegotiation not supported\\n\",\n\t\t\t\t\t\t\tsc->sc_dev.dv_xname);\n\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;\t\n\t\treturn;\n\t}\n#endif\n\n\tswitch (flag) {\n\tcase VR_FLAG_FORCEDELAY:\n\t\t/*\n\t \t * XXX Never use this option anywhere but in the probe\n\t \t * routine: making the kernel stop dead in its tracks\n \t\t * for three whole seconds after we've gone multi-user\n\t\t * is really bad manners.\n\t \t */\n\t\tvr_autoneg_xmit(sc);\n\t\tDELAY(5000000);\n\t\tbreak;\n\tcase VR_FLAG_SCHEDDELAY:\n\t\t/*\n\t\t * Wait for the transmitter to go idle before starting\n\t\t * an autoneg session, otherwise vr_start() may clobber\n\t \t * our timeout, and we don't want to allow transmission\n\t\t * during an autoneg session since that can screw it up.\n\t \t */\n\t\tif (sc->vr_cdata.vr_tx_head != NULL) {\n\t\t\tsc->vr_want_auto = 1;\n\t\t\treturn;\n\t\t}\n\t\tvr_autoneg_xmit(sc);\n\t\tifp->if_timer = 5;\n\t\tsc->vr_autoneg = 1;\n\t\tsc->vr_want_auto = 0;\n\t\treturn;\n\t\tbreak;\n\tcase VR_FLAG_DELAYTIMEO:\n\t\tifp->if_timer = 0;\n\t\tsc->vr_autoneg = 0;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: invalid autoneg flag: %d\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname, flag);\n\t\treturn;\n\t}\n\n\tif (vr_phy_readreg(sc, PHY_BMSR) & PHY_BMSR_AUTONEGCOMP) {\n\t\tif (verbose)\n\t\t\tprintf(\"%s: autoneg complete, \", sc->sc_dev.dv_xname);\n\t\tphy_sts = vr_phy_readreg(sc, PHY_BMSR);\n\t} else {\n\t\tif (verbose)\n\t\t\tprintf(\"%s: autoneg not complete, \",\n\t\t\t\t\t\tsc->sc_dev.dv_xname);\n\t}\n\n\tmedia = vr_phy_readreg(sc, PHY_BMCR);\n\n\t/* Link is good. Report modes and set duplex mode. */\n\tif (vr_phy_readreg(sc, PHY_BMSR) & PHY_BMSR_LINKSTAT) {\n\t\tif (verbose)\n\t\t\tprintf(\"link status good \");\n\t\tadvert = vr_phy_readreg(sc, PHY_ANAR);\n\t\tability = vr_phy_readreg(sc, PHY_LPAR);\n\n\t\tif (advert & PHY_ANAR_100BT4 && ability & PHY_ANAR_100BT4) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_T4;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(100baseT4)\\n\");\n\t\t} else if (advert & PHY_ANAR_100BTXFULL &&\n\t\t\tability & PHY_ANAR_100BTXFULL) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_FDX;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia |= PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(full-duplex, 100Mbps)\\n\");\n\t\t} else if (advert & PHY_ANAR_100BTXHALF &&\n\t\t\tability & PHY_ANAR_100BTXHALF) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_HDX;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(half-duplex, 100Mbps)\\n\");\n\t\t} else if (advert & PHY_ANAR_10BTFULL &&\n\t\t\tability & PHY_ANAR_10BTFULL) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_FDX;\n\t\t\tmedia &= ~PHY_BMCR_SPEEDSEL;\n\t\t\tmedia |= PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(full-duplex, 10Mbps)\\n\");\n\t\t} else {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;\n\t\t\tmedia &= ~PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(half-duplex, 10Mbps)\\n\");\n\t\t}\n\n\t\tmedia &= ~PHY_BMCR_AUTONEGENBL;\n\n\t\t/* Set ASIC's duplex mode to match the PHY. */\n\t\tvr_setcfg(sc, media);\n\t\tvr_phy_writereg(sc, PHY_BMCR, media);\n\t} else {\n\t\tif (verbose)\n\t\t\tprintf(\"no carrier\\n\");\n\t}\n\n\tvr_init(sc);\n\n\tif (sc->vr_tx_pend) {\n\t\tsc->vr_autoneg = 0;\n\t\tsc->vr_tx_pend = 0;\n\t\tvr_start(ifp);\n\t}\n\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_start;\nvoid vr_init;\nvoid vr_stop;\nvoid vr_watchdog;\nu_int16_t vr_phy_readreg;\nvoid vr_autoneg_mii;\nvoid vr_reset;\n\nvoid\nvr_watchdog(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct vr_softc\t\t*sc;\n\n\tsc = ifp->if_softc;\n\n\tif (sc->vr_autoneg) {\n\t\tvr_autoneg_mii(sc, VR_FLAG_DELAYTIMEO, 1);\n\t\treturn;\n\t}\n\n\tifp->if_oerrors++;\n\tprintf(\"%s: watchdog timeout\\n\", sc->sc_dev.dv_xname);\n\n\tif (!(vr_phy_readreg(sc, PHY_BMSR) & PHY_BMSR_LINKSTAT))\n\t\tprintf(\"%s: no carrier - transceiver cable problem?\\n\",\n\t\t\t\t\t\t\tsc->sc_dev.dv_xname);\n\n\tvr_stop(sc);\n\tvr_reset(sc);\n\tvr_init(sc);\n\n\tif (ifp->if_snd.ifq_head != NULL)\n\t\tvr_start(ifp);\n\n\treturn;\n}"
  },
  {
    "function_name": "vr_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
    "lines": "1795-1864",
    "snippet": "int\nvr_ioctl(ifp, command, data)\n\tstruct ifnet\t\t*ifp;\n\tu_long\t\t\tcommand;\n\tcaddr_t\t\t\tdata;\n{\n\tstruct vr_softc\t\t*sc = ifp->if_softc;\n\tstruct ifreq\t\t*ifr = (struct ifreq *) data;\n\tint\t\t\ts, error = 0;\n\tstruct ifaddr *ifa = (struct ifaddr *)data;\n\n\ts = splimp();\n\n\tif ((error = ether_ioctl(ifp, &sc->arpcom, command, data)) > 0) {\n\t\tsplx(s);\n\t\treturn error;\n\t}\n\n\tswitch(command) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tvr_init(sc);\n\t\t\tarp_ifinit(&sc->arpcom, ifa);\n\t\t\tbreak;\n#endif\t/* INET */\n\t\tdefault:\n\t\t\tvr_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SIOCSIFFLAGS:\n\t\tif (ifp->if_flags & IFF_UP) {\n\t\t\tvr_init(sc);\n\t\t} else {\n\t\t\tif (ifp->if_flags & IFF_RUNNING)\n\t\t\t\tvr_stop(sc);\n\t\t}\n\t\terror = 0;\n\t\tbreak;\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\terror = (command == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->arpcom) :\n\t\t    ether_delmulti(ifr, &sc->arpcom);\n\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware\n\t\t\t * filter accordingly.\n\t\t\t */\n\t\t\tvr_setmulti(sc);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\tcase SIOCGIFMEDIA:\n\tcase SIOCSIFMEDIA:\n\t\terror = ifmedia_ioctl(ifp, ifr, &sc->ifmedia, command);\n\t\tbreak;\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\t(void)splx(s);\n\n\treturn(error);\n}",
    "includes": [
      "#include <dev/pci/if_vrreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/device.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int vr_ioctl",
      "void vr_init",
      "void vr_stop",
      "void vr_setmulti"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_ioctl",
          "args": [
            "ifp",
            "ifr",
            "&sc->ifmedia",
            "command"
          ],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vr_setmulti",
          "args": [
            "sc"
          ],
          "line": 1848
        },
        "resolved": true,
        "details": {
          "function_name": "vr_setmulti",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "457-509",
          "snippet": "void\nvr_setmulti(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\th = 0;\n\tu_int32_t\t\thashes[2] = { 0, 0 };\n\tstruct arpcom *ac = &sc->arpcom;\n\tstruct ether_multi *enm;\n\tstruct ether_multistep step;\n\tu_int8_t\t\trxfilt;\n\tint\t\t\tmcnt = 0;\n\n\tifp = &sc->arpcom.ac_if;\n\n\trxfilt = CSR_READ_1(sc, VR_RXCFG);\n\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\trxfilt |= VR_RXCFG_RX_MULTI;\n\t\tCSR_WRITE_1(sc, VR_RXCFG, rxfilt);\n\t\tCSR_WRITE_4(sc, VR_MAR0, 0xFFFFFFFF);\n\t\tCSR_WRITE_4(sc, VR_MAR1, 0xFFFFFFFF);\n\t\treturn;\n\t}\n\n\t/* first, zot all the existing hash bits */\n\tCSR_WRITE_4(sc, VR_MAR0, 0);\n\tCSR_WRITE_4(sc, VR_MAR1, 0);\n\n\t/* now program new ones */\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\th = vr_calchash(enm->enm_addrlo);\n\t\tif (h < 32)\n\t\t\thashes[0] |= (1 << h);\n\t\telse\n\t\t\thashes[1] |= (1 << (h - 32));\n\t\tmcnt++;\n\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\n\tif (mcnt)\n\t\trxfilt |= VR_RXCFG_RX_MULTI;\n\telse\n\t\trxfilt &= ~VR_RXCFG_RX_MULTI;\n\n\tCSR_WRITE_4(sc, VR_MAR0, hashes[0]);\n\tCSR_WRITE_4(sc, VR_MAR1, hashes[1]);\n\tCSR_WRITE_1(sc, VR_RXCFG, rxfilt);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int8_t vr_calchash",
            "void vr_setmulti"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int8_t vr_calchash;\nvoid vr_setmulti;\n\nvoid\nvr_setmulti(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\th = 0;\n\tu_int32_t\t\thashes[2] = { 0, 0 };\n\tstruct arpcom *ac = &sc->arpcom;\n\tstruct ether_multi *enm;\n\tstruct ether_multistep step;\n\tu_int8_t\t\trxfilt;\n\tint\t\t\tmcnt = 0;\n\n\tifp = &sc->arpcom.ac_if;\n\n\trxfilt = CSR_READ_1(sc, VR_RXCFG);\n\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\trxfilt |= VR_RXCFG_RX_MULTI;\n\t\tCSR_WRITE_1(sc, VR_RXCFG, rxfilt);\n\t\tCSR_WRITE_4(sc, VR_MAR0, 0xFFFFFFFF);\n\t\tCSR_WRITE_4(sc, VR_MAR1, 0xFFFFFFFF);\n\t\treturn;\n\t}\n\n\t/* first, zot all the existing hash bits */\n\tCSR_WRITE_4(sc, VR_MAR0, 0);\n\tCSR_WRITE_4(sc, VR_MAR1, 0);\n\n\t/* now program new ones */\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\th = vr_calchash(enm->enm_addrlo);\n\t\tif (h < 32)\n\t\t\thashes[0] |= (1 << h);\n\t\telse\n\t\t\thashes[1] |= (1 << (h - 32));\n\t\tmcnt++;\n\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\n\tif (mcnt)\n\t\trxfilt |= VR_RXCFG_RX_MULTI;\n\telse\n\t\trxfilt &= ~VR_RXCFG_RX_MULTI;\n\n\tCSR_WRITE_4(sc, VR_MAR0, hashes[0]);\n\tCSR_WRITE_4(sc, VR_MAR1, hashes[1]);\n\tCSR_WRITE_1(sc, VR_RXCFG, rxfilt);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_delmulti",
          "args": [
            "ifr",
            "&sc->arpcom"
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_addmulti",
          "args": [
            "ifr",
            "&sc->arpcom"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vr_stop",
          "args": [
            "sc"
          ],
          "line": 1833
        },
        "resolved": true,
        "details": {
          "function_name": "vr_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "1900-1944",
          "snippet": "void\nvr_stop(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_timer = 0;\n\n\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_STOP);\n\tVR_CLRBIT16(sc, VR_COMMAND, (VR_CMD_RX_ON|VR_CMD_TX_ON));\n\tCSR_WRITE_2(sc, VR_IMR, 0x0000);\n\tCSR_WRITE_4(sc, VR_TXADDR, 0x00000000);\n\tCSR_WRITE_4(sc, VR_RXADDR, 0x00000000);\n\n\t/*\n\t * Free data in the RX lists.\n\t */\n\tfor (i = 0; i < VR_RX_LIST_CNT; i++) {\n\t\tif (sc->vr_cdata.vr_rx_chain[i].vr_mbuf != NULL) {\n\t\t\tm_freem(sc->vr_cdata.vr_rx_chain[i].vr_mbuf);\n\t\t\tsc->vr_cdata.vr_rx_chain[i].vr_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->vr_ldata->vr_rx_list,\n\t\tsizeof(sc->vr_ldata->vr_rx_list));\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < VR_TX_LIST_CNT; i++) {\n\t\tif (sc->vr_cdata.vr_tx_chain[i].vr_mbuf != NULL) {\n\t\t\tm_freem(sc->vr_cdata.vr_tx_chain[i].vr_mbuf);\n\t\t\tsc->vr_cdata.vr_tx_chain[i].vr_mbuf = NULL;\n\t\t}\n\t}\n\n\tbzero((char *)&sc->vr_ldata->vr_tx_list,\n\t\tsizeof(sc->vr_ldata->vr_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void vr_stop"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_stop;\n\nvoid\nvr_stop(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_timer = 0;\n\n\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_STOP);\n\tVR_CLRBIT16(sc, VR_COMMAND, (VR_CMD_RX_ON|VR_CMD_TX_ON));\n\tCSR_WRITE_2(sc, VR_IMR, 0x0000);\n\tCSR_WRITE_4(sc, VR_TXADDR, 0x00000000);\n\tCSR_WRITE_4(sc, VR_RXADDR, 0x00000000);\n\n\t/*\n\t * Free data in the RX lists.\n\t */\n\tfor (i = 0; i < VR_RX_LIST_CNT; i++) {\n\t\tif (sc->vr_cdata.vr_rx_chain[i].vr_mbuf != NULL) {\n\t\t\tm_freem(sc->vr_cdata.vr_rx_chain[i].vr_mbuf);\n\t\t\tsc->vr_cdata.vr_rx_chain[i].vr_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->vr_ldata->vr_rx_list,\n\t\tsizeof(sc->vr_ldata->vr_rx_list));\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < VR_TX_LIST_CNT; i++) {\n\t\tif (sc->vr_cdata.vr_tx_chain[i].vr_mbuf != NULL) {\n\t\t\tm_freem(sc->vr_cdata.vr_tx_chain[i].vr_mbuf);\n\t\t\tsc->vr_cdata.vr_tx_chain[i].vr_mbuf = NULL;\n\t\t}\n\t}\n\n\tbzero((char *)&sc->vr_ldata->vr_tx_list,\n\t\tsizeof(sc->vr_ldata->vr_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vr_init",
          "args": [
            "sc"
          ],
          "line": 1830
        },
        "resolved": true,
        "details": {
          "function_name": "vr_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "1630-1720",
          "snippet": "void\nvr_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct vr_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tu_int16_t\t\tphy_bmcr = 0;\n\tint\t\t\ts;\n\n\tif (sc->vr_autoneg)\n\t\treturn;\n\n\ts = splimp();\n\n\tif (sc->vr_pinfo != NULL)\n\t\tphy_bmcr = vr_phy_readreg(sc, PHY_BMCR);\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\tvr_stop(sc);\n\tvr_reset(sc);\n\n\tVR_CLRBIT(sc, VR_RXCFG, VR_RXCFG_RX_THRESH);\n\tVR_SETBIT(sc, VR_RXCFG, VR_RXTHRESH_STORENFWD);\n\n\tVR_CLRBIT(sc, VR_TXCFG, VR_TXCFG_TX_THRESH);\n\tVR_SETBIT(sc, VR_TXCFG, VR_TXTHRESH_STORENFWD);\n\n\t/* Init circular RX list. */\n\tif (vr_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: initialization failed: no memory for rx buffers\\n\",\n\t\t\t\t\t\t\tsc->sc_dev.dv_xname);\n\t\tvr_stop(sc);\n\t\t(void)splx(s);\n\t\treturn;\n\t}\n\n\t/*\n\t * Init tx descriptors.\n\t */\n\tvr_list_tx_init(sc);\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tVR_SETBIT(sc, VR_RXCFG, VR_RXCFG_RX_PROMISC);\n\telse\n\t\tVR_CLRBIT(sc, VR_RXCFG, VR_RXCFG_RX_PROMISC);\n\n\t/* Set capture broadcast bit to capture broadcast frames. */\n\tif (ifp->if_flags & IFF_BROADCAST)\n\t\tVR_SETBIT(sc, VR_RXCFG, VR_RXCFG_RX_BROAD);\n\telse\n\t\tVR_CLRBIT(sc, VR_RXCFG, VR_RXCFG_RX_BROAD);\n\n\t/*\n\t * Program the multicast filter, if necessary.\n\t */\n\tvr_setmulti(sc);\n\n\t/*\n\t * Load the address of the RX list.\n\t */\n\tCSR_WRITE_4(sc, VR_RXADDR, vtophys(sc->vr_cdata.vr_rx_head->vr_ptr));\n\n\t/* Enable receiver and transmitter. */\n\tCSR_WRITE_2(sc, VR_COMMAND, VR_CMD_TX_NOPOLL|VR_CMD_START|\n\t\t\t\t    VR_CMD_TX_ON|VR_CMD_RX_ON|\n\t\t\t\t    VR_CMD_RX_GO);\n\n\tvr_setcfg(sc, vr_phy_readreg(sc, PHY_BMCR));\n\n\tCSR_WRITE_4(sc, VR_TXADDR, vtophys(&sc->vr_ldata->vr_tx_list[0]));\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_2(sc, VR_ISR, 0xFFFF);\n\tCSR_WRITE_2(sc, VR_IMR, VR_INTRS);\n\n\t/* Restore state of BMCR */\n\tif (sc->vr_pinfo != NULL)\n\t\tvr_phy_writereg(sc, PHY_BMCR, phy_bmcr);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void vr_init",
            "void vr_stop",
            "u_int16_t vr_phy_readreg",
            "void vr_phy_writereg",
            "void vr_setcfg",
            "void vr_setmulti",
            "void vr_reset",
            "int vr_list_rx_init",
            "int vr_list_tx_init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_init;\nvoid vr_stop;\nu_int16_t vr_phy_readreg;\nvoid vr_phy_writereg;\nvoid vr_setcfg;\nvoid vr_setmulti;\nvoid vr_reset;\nint vr_list_rx_init;\nint vr_list_tx_init;\n\nvoid\nvr_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct vr_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tu_int16_t\t\tphy_bmcr = 0;\n\tint\t\t\ts;\n\n\tif (sc->vr_autoneg)\n\t\treturn;\n\n\ts = splimp();\n\n\tif (sc->vr_pinfo != NULL)\n\t\tphy_bmcr = vr_phy_readreg(sc, PHY_BMCR);\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\tvr_stop(sc);\n\tvr_reset(sc);\n\n\tVR_CLRBIT(sc, VR_RXCFG, VR_RXCFG_RX_THRESH);\n\tVR_SETBIT(sc, VR_RXCFG, VR_RXTHRESH_STORENFWD);\n\n\tVR_CLRBIT(sc, VR_TXCFG, VR_TXCFG_TX_THRESH);\n\tVR_SETBIT(sc, VR_TXCFG, VR_TXTHRESH_STORENFWD);\n\n\t/* Init circular RX list. */\n\tif (vr_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: initialization failed: no memory for rx buffers\\n\",\n\t\t\t\t\t\t\tsc->sc_dev.dv_xname);\n\t\tvr_stop(sc);\n\t\t(void)splx(s);\n\t\treturn;\n\t}\n\n\t/*\n\t * Init tx descriptors.\n\t */\n\tvr_list_tx_init(sc);\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tVR_SETBIT(sc, VR_RXCFG, VR_RXCFG_RX_PROMISC);\n\telse\n\t\tVR_CLRBIT(sc, VR_RXCFG, VR_RXCFG_RX_PROMISC);\n\n\t/* Set capture broadcast bit to capture broadcast frames. */\n\tif (ifp->if_flags & IFF_BROADCAST)\n\t\tVR_SETBIT(sc, VR_RXCFG, VR_RXCFG_RX_BROAD);\n\telse\n\t\tVR_CLRBIT(sc, VR_RXCFG, VR_RXCFG_RX_BROAD);\n\n\t/*\n\t * Program the multicast filter, if necessary.\n\t */\n\tvr_setmulti(sc);\n\n\t/*\n\t * Load the address of the RX list.\n\t */\n\tCSR_WRITE_4(sc, VR_RXADDR, vtophys(sc->vr_cdata.vr_rx_head->vr_ptr));\n\n\t/* Enable receiver and transmitter. */\n\tCSR_WRITE_2(sc, VR_COMMAND, VR_CMD_TX_NOPOLL|VR_CMD_START|\n\t\t\t\t    VR_CMD_TX_ON|VR_CMD_RX_ON|\n\t\t\t\t    VR_CMD_RX_GO);\n\n\tvr_setcfg(sc, vr_phy_readreg(sc, PHY_BMCR));\n\n\tCSR_WRITE_4(sc, VR_TXADDR, vtophys(&sc->vr_ldata->vr_tx_list[0]));\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_2(sc, VR_ISR, 0xFFFF);\n\tCSR_WRITE_2(sc, VR_IMR, VR_INTRS);\n\n\t/* Restore state of BMCR */\n\tif (sc->vr_pinfo != NULL)\n\t\tvr_phy_writereg(sc, PHY_BMCR, phy_bmcr);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arp_ifinit",
          "args": [
            "&sc->arpcom",
            "ifa"
          ],
          "line": 1820
        },
        "resolved": true,
        "details": {
          "function_name": "arp_ifinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_devar.h",
          "lines": "929-936",
          "snippet": "static void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}",
          "includes": [
            "#include <sys/devconf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/devconf.h>\n\nstatic void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ioctl",
          "args": [
            "ifp",
            "&sc->arpcom",
            "command",
            "data"
          ],
          "line": 1808
        },
        "resolved": true,
        "details": {
          "function_name": "wx_ether_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "303-356",
          "snippet": "static int\nwx_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tIOCTL_CMD_TYPE cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tint error = 0;\n\twx_softc_t *sc = SOFTC_IFP(ifp);\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\terror = wx_init(sc);\n\t\tif (error) {\n\t\t\tifp->if_flags &= ~IFF_UP;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n#ifdef __OpenBSD__\n\t\t\tarp_ifinit(&sc->w.arpcom, ifa);\n#else\n\t\t\tarp_ifinit(ifp, ifa);\n#endif\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t{\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t break;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int wx_init",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic int wx_init;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic int\nwx_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tIOCTL_CMD_TYPE cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tint error = 0;\n\twx_softc_t *sc = SOFTC_IFP(ifp);\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\terror = wx_init(sc);\n\t\tif (error) {\n\t\t\tifp->if_flags &= ~IFF_UP;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n#ifdef __OpenBSD__\n\t\t\tarp_ifinit(&sc->w.arpcom, ifa);\n#else\n\t\t\tarp_ifinit(ifp, ifa);\n#endif\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t{\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t break;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint vr_ioctl;\nvoid vr_init;\nvoid vr_stop;\nvoid vr_setmulti;\n\nint\nvr_ioctl(ifp, command, data)\n\tstruct ifnet\t\t*ifp;\n\tu_long\t\t\tcommand;\n\tcaddr_t\t\t\tdata;\n{\n\tstruct vr_softc\t\t*sc = ifp->if_softc;\n\tstruct ifreq\t\t*ifr = (struct ifreq *) data;\n\tint\t\t\ts, error = 0;\n\tstruct ifaddr *ifa = (struct ifaddr *)data;\n\n\ts = splimp();\n\n\tif ((error = ether_ioctl(ifp, &sc->arpcom, command, data)) > 0) {\n\t\tsplx(s);\n\t\treturn error;\n\t}\n\n\tswitch(command) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tvr_init(sc);\n\t\t\tarp_ifinit(&sc->arpcom, ifa);\n\t\t\tbreak;\n#endif\t/* INET */\n\t\tdefault:\n\t\t\tvr_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SIOCSIFFLAGS:\n\t\tif (ifp->if_flags & IFF_UP) {\n\t\t\tvr_init(sc);\n\t\t} else {\n\t\t\tif (ifp->if_flags & IFF_RUNNING)\n\t\t\t\tvr_stop(sc);\n\t\t}\n\t\terror = 0;\n\t\tbreak;\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\terror = (command == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->arpcom) :\n\t\t    ether_delmulti(ifr, &sc->arpcom);\n\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware\n\t\t\t * filter accordingly.\n\t\t\t */\n\t\t\tvr_setmulti(sc);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\tcase SIOCGIFMEDIA:\n\tcase SIOCSIFMEDIA:\n\t\terror = ifmedia_ioctl(ifp, ifr, &sc->ifmedia, command);\n\t\tbreak;\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\t(void)splx(s);\n\n\treturn(error);\n}"
  },
  {
    "function_name": "vr_ifmedia_sts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
    "lines": "1749-1793",
    "snippet": "void\nvr_ifmedia_sts(ifp, ifmr)\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmediareq\t*ifmr;\n{\n\tstruct vr_softc\t\t*sc;\n\tu_int16_t\t\tadvert = 0, ability = 0;\n\n\tsc = ifp->if_softc;\n\n\tifmr->ifm_active = IFM_ETHER;\n\n\tif (!(vr_phy_readreg(sc, PHY_BMCR) & PHY_BMCR_AUTONEGENBL)) {\n\t\tif (vr_phy_readreg(sc, PHY_BMCR) & PHY_BMCR_SPEEDSEL)\n\t\t\tifmr->ifm_active = IFM_ETHER|IFM_100_TX;\n\t\telse\n\t\t\tifmr->ifm_active = IFM_ETHER|IFM_10_T;\n\t\tif (vr_phy_readreg(sc, PHY_BMCR) & PHY_BMCR_DUPLEX)\n\t\t\tifmr->ifm_active |= IFM_FDX;\n\t\telse\n\t\t\tifmr->ifm_active |= IFM_HDX;\n\t\treturn;\n\t}\n\n\tability = vr_phy_readreg(sc, PHY_LPAR);\n\tadvert = vr_phy_readreg(sc, PHY_ANAR);\n\tif (advert & PHY_ANAR_100BT4 &&\n\t\tability & PHY_ANAR_100BT4) {\n\t\tifmr->ifm_active = IFM_ETHER|IFM_100_T4;\n\t} else if (advert & PHY_ANAR_100BTXFULL &&\n\t\tability & PHY_ANAR_100BTXFULL) {\n\t\tifmr->ifm_active = IFM_ETHER|IFM_100_TX|IFM_FDX;\n\t} else if (advert & PHY_ANAR_100BTXHALF &&\n\t\tability & PHY_ANAR_100BTXHALF) {\n\t\tifmr->ifm_active = IFM_ETHER|IFM_100_TX|IFM_HDX;\n\t} else if (advert & PHY_ANAR_10BTFULL &&\n\t\tability & PHY_ANAR_10BTFULL) {\n\t\tifmr->ifm_active = IFM_ETHER|IFM_10_T|IFM_FDX;\n\t} else if (advert & PHY_ANAR_10BTHALF &&\n\t\tability & PHY_ANAR_10BTHALF) {\n\t\tifmr->ifm_active = IFM_ETHER|IFM_10_T|IFM_HDX;\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_vrreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/device.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void vr_ifmedia_sts",
      "u_int16_t vr_phy_readreg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vr_phy_readreg",
          "args": [
            "sc",
            "PHY_ANAR"
          ],
          "line": 1774
        },
        "resolved": true,
        "details": {
          "function_name": "vr_phy_readreg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "390-404",
          "snippet": "u_int16_t\nvr_phy_readreg(sc, reg)\n\tstruct vr_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tstruct vr_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->vr_phy_addr;\n\tframe.mii_regaddr = reg;\n\tvr_mii_readreg(sc, &frame);\n\n\treturn(frame.mii_data);\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int vr_mii_readreg",
            "u_int16_t vr_phy_readreg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint vr_mii_readreg;\nu_int16_t vr_phy_readreg;\n\nu_int16_t\nvr_phy_readreg(sc, reg)\n\tstruct vr_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tstruct vr_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->vr_phy_addr;\n\tframe.mii_regaddr = reg;\n\tvr_mii_readreg(sc, &frame);\n\n\treturn(frame.mii_data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_ifmedia_sts;\nu_int16_t vr_phy_readreg;\n\nvoid\nvr_ifmedia_sts(ifp, ifmr)\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmediareq\t*ifmr;\n{\n\tstruct vr_softc\t\t*sc;\n\tu_int16_t\t\tadvert = 0, ability = 0;\n\n\tsc = ifp->if_softc;\n\n\tifmr->ifm_active = IFM_ETHER;\n\n\tif (!(vr_phy_readreg(sc, PHY_BMCR) & PHY_BMCR_AUTONEGENBL)) {\n\t\tif (vr_phy_readreg(sc, PHY_BMCR) & PHY_BMCR_SPEEDSEL)\n\t\t\tifmr->ifm_active = IFM_ETHER|IFM_100_TX;\n\t\telse\n\t\t\tifmr->ifm_active = IFM_ETHER|IFM_10_T;\n\t\tif (vr_phy_readreg(sc, PHY_BMCR) & PHY_BMCR_DUPLEX)\n\t\t\tifmr->ifm_active |= IFM_FDX;\n\t\telse\n\t\t\tifmr->ifm_active |= IFM_HDX;\n\t\treturn;\n\t}\n\n\tability = vr_phy_readreg(sc, PHY_LPAR);\n\tadvert = vr_phy_readreg(sc, PHY_ANAR);\n\tif (advert & PHY_ANAR_100BT4 &&\n\t\tability & PHY_ANAR_100BT4) {\n\t\tifmr->ifm_active = IFM_ETHER|IFM_100_T4;\n\t} else if (advert & PHY_ANAR_100BTXFULL &&\n\t\tability & PHY_ANAR_100BTXFULL) {\n\t\tifmr->ifm_active = IFM_ETHER|IFM_100_TX|IFM_FDX;\n\t} else if (advert & PHY_ANAR_100BTXHALF &&\n\t\tability & PHY_ANAR_100BTXHALF) {\n\t\tifmr->ifm_active = IFM_ETHER|IFM_100_TX|IFM_HDX;\n\t} else if (advert & PHY_ANAR_10BTFULL &&\n\t\tability & PHY_ANAR_10BTFULL) {\n\t\tifmr->ifm_active = IFM_ETHER|IFM_10_T|IFM_FDX;\n\t} else if (advert & PHY_ANAR_10BTHALF &&\n\t\tability & PHY_ANAR_10BTHALF) {\n\t\tifmr->ifm_active = IFM_ETHER|IFM_10_T|IFM_HDX;\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "vr_ifmedia_upd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
    "lines": "1725-1744",
    "snippet": "int\nvr_ifmedia_upd(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct vr_softc\t\t*sc;\n\tstruct ifmedia\t\t*ifm;\n\n\tsc = ifp->if_softc;\n\tifm = &sc->ifmedia;\n\n\tif (IFM_TYPE(ifm->ifm_media) != IFM_ETHER)\n\t\treturn(EINVAL);\n\n\tif (IFM_SUBTYPE(ifm->ifm_media) == IFM_AUTO)\n\t\tvr_autoneg_mii(sc, VR_FLAG_SCHEDDELAY, 1);\n\telse\n\t\tvr_setmode_mii(sc, ifm->ifm_media);\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/if_vrreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/device.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int vr_ifmedia_upd",
      "void vr_autoneg_mii",
      "void vr_setmode_mii"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vr_setmode_mii",
          "args": [
            "sc",
            "ifm->ifm_media"
          ],
          "line": 1741
        },
        "resolved": true,
        "details": {
          "function_name": "vr_setmode_mii",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "744-800",
          "snippet": "void\nvr_setmode_mii(sc, media)\n\tstruct vr_softc\t\t*sc;\n\tint\t\t\tmedia;\n{\n\tu_int16_t\t\tbmcr;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/*\n\t * If an autoneg session is in progress, stop it.\n\t */\n\tif (sc->vr_autoneg) {\n\t\tprintf(\"%s: canceling autoneg session\\n\", sc->sc_dev.dv_xname);\n\t\tifp->if_timer = sc->vr_autoneg = sc->vr_want_auto = 0;\n\t\tbmcr = vr_phy_readreg(sc, PHY_BMCR);\n\t\tbmcr &= ~PHY_BMCR_AUTONEGENBL;\n\t\tvr_phy_writereg(sc, PHY_BMCR, bmcr);\n\t}\n\n\tprintf(\"%s: selecting MII, \", sc->sc_dev.dv_xname);\n\n\tbmcr = vr_phy_readreg(sc, PHY_BMCR);\n\n\tbmcr &= ~(PHY_BMCR_AUTONEGENBL|PHY_BMCR_SPEEDSEL|\n\t\t\tPHY_BMCR_DUPLEX|PHY_BMCR_LOOPBK);\n\n\tif (IFM_SUBTYPE(media) == IFM_100_T4) {\n\t\tprintf(\"100Mbps/T4, half-duplex\\n\");\n\t\tbmcr |= PHY_BMCR_SPEEDSEL;\n\t\tbmcr &= ~PHY_BMCR_DUPLEX;\n\t}\n\n\tif (IFM_SUBTYPE(media) == IFM_100_TX) {\n\t\tprintf(\"100Mbps, \");\n\t\tbmcr |= PHY_BMCR_SPEEDSEL;\n\t}\n\n\tif (IFM_SUBTYPE(media) == IFM_10_T) {\n\t\tprintf(\"10Mbps, \");\n\t\tbmcr &= ~PHY_BMCR_SPEEDSEL;\n\t}\n\n\tif ((media & IFM_GMASK) == IFM_FDX) {\n\t\tprintf(\"full duplex\\n\");\n\t\tbmcr |= PHY_BMCR_DUPLEX;\n\t} else {\n\t\tprintf(\"half duplex\\n\");\n\t\tbmcr &= ~PHY_BMCR_DUPLEX;\n\t}\n\n\tvr_setcfg(sc, bmcr);\n\tvr_phy_writereg(sc, PHY_BMCR, bmcr);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int16_t vr_phy_readreg",
            "void vr_phy_writereg",
            "void vr_setmode_mii",
            "void vr_setcfg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int16_t vr_phy_readreg;\nvoid vr_phy_writereg;\nvoid vr_setmode_mii;\nvoid vr_setcfg;\n\nvoid\nvr_setmode_mii(sc, media)\n\tstruct vr_softc\t\t*sc;\n\tint\t\t\tmedia;\n{\n\tu_int16_t\t\tbmcr;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/*\n\t * If an autoneg session is in progress, stop it.\n\t */\n\tif (sc->vr_autoneg) {\n\t\tprintf(\"%s: canceling autoneg session\\n\", sc->sc_dev.dv_xname);\n\t\tifp->if_timer = sc->vr_autoneg = sc->vr_want_auto = 0;\n\t\tbmcr = vr_phy_readreg(sc, PHY_BMCR);\n\t\tbmcr &= ~PHY_BMCR_AUTONEGENBL;\n\t\tvr_phy_writereg(sc, PHY_BMCR, bmcr);\n\t}\n\n\tprintf(\"%s: selecting MII, \", sc->sc_dev.dv_xname);\n\n\tbmcr = vr_phy_readreg(sc, PHY_BMCR);\n\n\tbmcr &= ~(PHY_BMCR_AUTONEGENBL|PHY_BMCR_SPEEDSEL|\n\t\t\tPHY_BMCR_DUPLEX|PHY_BMCR_LOOPBK);\n\n\tif (IFM_SUBTYPE(media) == IFM_100_T4) {\n\t\tprintf(\"100Mbps/T4, half-duplex\\n\");\n\t\tbmcr |= PHY_BMCR_SPEEDSEL;\n\t\tbmcr &= ~PHY_BMCR_DUPLEX;\n\t}\n\n\tif (IFM_SUBTYPE(media) == IFM_100_TX) {\n\t\tprintf(\"100Mbps, \");\n\t\tbmcr |= PHY_BMCR_SPEEDSEL;\n\t}\n\n\tif (IFM_SUBTYPE(media) == IFM_10_T) {\n\t\tprintf(\"10Mbps, \");\n\t\tbmcr &= ~PHY_BMCR_SPEEDSEL;\n\t}\n\n\tif ((media & IFM_GMASK) == IFM_FDX) {\n\t\tprintf(\"full duplex\\n\");\n\t\tbmcr |= PHY_BMCR_DUPLEX;\n\t} else {\n\t\tprintf(\"half duplex\\n\");\n\t\tbmcr &= ~PHY_BMCR_DUPLEX;\n\t}\n\n\tvr_setcfg(sc, bmcr);\n\tvr_phy_writereg(sc, PHY_BMCR, bmcr);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vr_autoneg_mii",
          "args": [
            "sc",
            "VR_FLAG_SCHEDDELAY",
            "1"
          ],
          "line": 1739
        },
        "resolved": true,
        "details": {
          "function_name": "vr_autoneg_mii",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "535-679",
          "snippet": "void\nvr_autoneg_mii(sc, flag, verbose)\n\tstruct vr_softc\t\t*sc;\n\tint\t\t\tflag;\n\tint\t\t\tverbose;\n{\n\tu_int16_t\t\tphy_sts = 0, media, advert, ability;\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmedia\t\t*ifm;\n\n\tifm = &sc->ifmedia;\n\tifp = &sc->arpcom.ac_if;\n\n\tifm->ifm_media = IFM_ETHER | IFM_AUTO;\n\n\t/*\n\t * The 100baseT4 PHY on the 3c905-T4 has the 'autoneg supported'\n\t * bit cleared in the status register, but has the 'autoneg enabled'\n\t * bit set in the control register. This is a contradiction, and\n\t * I'm not sure how to handle it. If you want to force an attempt\n\t * to autoneg for 100baseT4 PHYs, #define FORCE_AUTONEG_TFOUR\n\t * and see what happens.\n\t */\n#ifndef FORCE_AUTONEG_TFOUR\n\t/*\n\t * First, see if autoneg is supported. If not, there's\n\t * no point in continuing.\n\t */\n\tphy_sts = vr_phy_readreg(sc, PHY_BMSR);\n\tif (!(phy_sts & PHY_BMSR_CANAUTONEG)) {\n\t\tif (verbose)\n\t\t\tprintf(\"%s: autonegotiation not supported\\n\",\n\t\t\t\t\t\t\tsc->sc_dev.dv_xname);\n\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;\t\n\t\treturn;\n\t}\n#endif\n\n\tswitch (flag) {\n\tcase VR_FLAG_FORCEDELAY:\n\t\t/*\n\t \t * XXX Never use this option anywhere but in the probe\n\t \t * routine: making the kernel stop dead in its tracks\n \t\t * for three whole seconds after we've gone multi-user\n\t\t * is really bad manners.\n\t \t */\n\t\tvr_autoneg_xmit(sc);\n\t\tDELAY(5000000);\n\t\tbreak;\n\tcase VR_FLAG_SCHEDDELAY:\n\t\t/*\n\t\t * Wait for the transmitter to go idle before starting\n\t\t * an autoneg session, otherwise vr_start() may clobber\n\t \t * our timeout, and we don't want to allow transmission\n\t\t * during an autoneg session since that can screw it up.\n\t \t */\n\t\tif (sc->vr_cdata.vr_tx_head != NULL) {\n\t\t\tsc->vr_want_auto = 1;\n\t\t\treturn;\n\t\t}\n\t\tvr_autoneg_xmit(sc);\n\t\tifp->if_timer = 5;\n\t\tsc->vr_autoneg = 1;\n\t\tsc->vr_want_auto = 0;\n\t\treturn;\n\t\tbreak;\n\tcase VR_FLAG_DELAYTIMEO:\n\t\tifp->if_timer = 0;\n\t\tsc->vr_autoneg = 0;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: invalid autoneg flag: %d\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname, flag);\n\t\treturn;\n\t}\n\n\tif (vr_phy_readreg(sc, PHY_BMSR) & PHY_BMSR_AUTONEGCOMP) {\n\t\tif (verbose)\n\t\t\tprintf(\"%s: autoneg complete, \", sc->sc_dev.dv_xname);\n\t\tphy_sts = vr_phy_readreg(sc, PHY_BMSR);\n\t} else {\n\t\tif (verbose)\n\t\t\tprintf(\"%s: autoneg not complete, \",\n\t\t\t\t\t\tsc->sc_dev.dv_xname);\n\t}\n\n\tmedia = vr_phy_readreg(sc, PHY_BMCR);\n\n\t/* Link is good. Report modes and set duplex mode. */\n\tif (vr_phy_readreg(sc, PHY_BMSR) & PHY_BMSR_LINKSTAT) {\n\t\tif (verbose)\n\t\t\tprintf(\"link status good \");\n\t\tadvert = vr_phy_readreg(sc, PHY_ANAR);\n\t\tability = vr_phy_readreg(sc, PHY_LPAR);\n\n\t\tif (advert & PHY_ANAR_100BT4 && ability & PHY_ANAR_100BT4) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_T4;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(100baseT4)\\n\");\n\t\t} else if (advert & PHY_ANAR_100BTXFULL &&\n\t\t\tability & PHY_ANAR_100BTXFULL) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_FDX;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia |= PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(full-duplex, 100Mbps)\\n\");\n\t\t} else if (advert & PHY_ANAR_100BTXHALF &&\n\t\t\tability & PHY_ANAR_100BTXHALF) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_HDX;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(half-duplex, 100Mbps)\\n\");\n\t\t} else if (advert & PHY_ANAR_10BTFULL &&\n\t\t\tability & PHY_ANAR_10BTFULL) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_FDX;\n\t\t\tmedia &= ~PHY_BMCR_SPEEDSEL;\n\t\t\tmedia |= PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(full-duplex, 10Mbps)\\n\");\n\t\t} else {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;\n\t\t\tmedia &= ~PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(half-duplex, 10Mbps)\\n\");\n\t\t}\n\n\t\tmedia &= ~PHY_BMCR_AUTONEGENBL;\n\n\t\t/* Set ASIC's duplex mode to match the PHY. */\n\t\tvr_setcfg(sc, media);\n\t\tvr_phy_writereg(sc, PHY_BMCR, media);\n\t} else {\n\t\tif (verbose)\n\t\t\tprintf(\"no carrier\\n\");\n\t}\n\n\tvr_init(sc);\n\n\tif (sc->vr_tx_pend) {\n\t\tsc->vr_autoneg = 0;\n\t\tsc->vr_tx_pend = 0;\n\t\tvr_start(ifp);\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void vr_start",
            "void vr_init",
            "u_int16_t vr_phy_readreg",
            "void vr_phy_writereg",
            "void vr_autoneg_xmit",
            "void vr_autoneg_mii",
            "void vr_setcfg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_start;\nvoid vr_init;\nu_int16_t vr_phy_readreg;\nvoid vr_phy_writereg;\nvoid vr_autoneg_xmit;\nvoid vr_autoneg_mii;\nvoid vr_setcfg;\n\nvoid\nvr_autoneg_mii(sc, flag, verbose)\n\tstruct vr_softc\t\t*sc;\n\tint\t\t\tflag;\n\tint\t\t\tverbose;\n{\n\tu_int16_t\t\tphy_sts = 0, media, advert, ability;\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmedia\t\t*ifm;\n\n\tifm = &sc->ifmedia;\n\tifp = &sc->arpcom.ac_if;\n\n\tifm->ifm_media = IFM_ETHER | IFM_AUTO;\n\n\t/*\n\t * The 100baseT4 PHY on the 3c905-T4 has the 'autoneg supported'\n\t * bit cleared in the status register, but has the 'autoneg enabled'\n\t * bit set in the control register. This is a contradiction, and\n\t * I'm not sure how to handle it. If you want to force an attempt\n\t * to autoneg for 100baseT4 PHYs, #define FORCE_AUTONEG_TFOUR\n\t * and see what happens.\n\t */\n#ifndef FORCE_AUTONEG_TFOUR\n\t/*\n\t * First, see if autoneg is supported. If not, there's\n\t * no point in continuing.\n\t */\n\tphy_sts = vr_phy_readreg(sc, PHY_BMSR);\n\tif (!(phy_sts & PHY_BMSR_CANAUTONEG)) {\n\t\tif (verbose)\n\t\t\tprintf(\"%s: autonegotiation not supported\\n\",\n\t\t\t\t\t\t\tsc->sc_dev.dv_xname);\n\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;\t\n\t\treturn;\n\t}\n#endif\n\n\tswitch (flag) {\n\tcase VR_FLAG_FORCEDELAY:\n\t\t/*\n\t \t * XXX Never use this option anywhere but in the probe\n\t \t * routine: making the kernel stop dead in its tracks\n \t\t * for three whole seconds after we've gone multi-user\n\t\t * is really bad manners.\n\t \t */\n\t\tvr_autoneg_xmit(sc);\n\t\tDELAY(5000000);\n\t\tbreak;\n\tcase VR_FLAG_SCHEDDELAY:\n\t\t/*\n\t\t * Wait for the transmitter to go idle before starting\n\t\t * an autoneg session, otherwise vr_start() may clobber\n\t \t * our timeout, and we don't want to allow transmission\n\t\t * during an autoneg session since that can screw it up.\n\t \t */\n\t\tif (sc->vr_cdata.vr_tx_head != NULL) {\n\t\t\tsc->vr_want_auto = 1;\n\t\t\treturn;\n\t\t}\n\t\tvr_autoneg_xmit(sc);\n\t\tifp->if_timer = 5;\n\t\tsc->vr_autoneg = 1;\n\t\tsc->vr_want_auto = 0;\n\t\treturn;\n\t\tbreak;\n\tcase VR_FLAG_DELAYTIMEO:\n\t\tifp->if_timer = 0;\n\t\tsc->vr_autoneg = 0;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: invalid autoneg flag: %d\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname, flag);\n\t\treturn;\n\t}\n\n\tif (vr_phy_readreg(sc, PHY_BMSR) & PHY_BMSR_AUTONEGCOMP) {\n\t\tif (verbose)\n\t\t\tprintf(\"%s: autoneg complete, \", sc->sc_dev.dv_xname);\n\t\tphy_sts = vr_phy_readreg(sc, PHY_BMSR);\n\t} else {\n\t\tif (verbose)\n\t\t\tprintf(\"%s: autoneg not complete, \",\n\t\t\t\t\t\tsc->sc_dev.dv_xname);\n\t}\n\n\tmedia = vr_phy_readreg(sc, PHY_BMCR);\n\n\t/* Link is good. Report modes and set duplex mode. */\n\tif (vr_phy_readreg(sc, PHY_BMSR) & PHY_BMSR_LINKSTAT) {\n\t\tif (verbose)\n\t\t\tprintf(\"link status good \");\n\t\tadvert = vr_phy_readreg(sc, PHY_ANAR);\n\t\tability = vr_phy_readreg(sc, PHY_LPAR);\n\n\t\tif (advert & PHY_ANAR_100BT4 && ability & PHY_ANAR_100BT4) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_T4;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(100baseT4)\\n\");\n\t\t} else if (advert & PHY_ANAR_100BTXFULL &&\n\t\t\tability & PHY_ANAR_100BTXFULL) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_FDX;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia |= PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(full-duplex, 100Mbps)\\n\");\n\t\t} else if (advert & PHY_ANAR_100BTXHALF &&\n\t\t\tability & PHY_ANAR_100BTXHALF) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_HDX;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(half-duplex, 100Mbps)\\n\");\n\t\t} else if (advert & PHY_ANAR_10BTFULL &&\n\t\t\tability & PHY_ANAR_10BTFULL) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_FDX;\n\t\t\tmedia &= ~PHY_BMCR_SPEEDSEL;\n\t\t\tmedia |= PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(full-duplex, 10Mbps)\\n\");\n\t\t} else {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;\n\t\t\tmedia &= ~PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(half-duplex, 10Mbps)\\n\");\n\t\t}\n\n\t\tmedia &= ~PHY_BMCR_AUTONEGENBL;\n\n\t\t/* Set ASIC's duplex mode to match the PHY. */\n\t\tvr_setcfg(sc, media);\n\t\tvr_phy_writereg(sc, PHY_BMCR, media);\n\t} else {\n\t\tif (verbose)\n\t\t\tprintf(\"no carrier\\n\");\n\t}\n\n\tvr_init(sc);\n\n\tif (sc->vr_tx_pend) {\n\t\tsc->vr_autoneg = 0;\n\t\tsc->vr_tx_pend = 0;\n\t\tvr_start(ifp);\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "ifm->ifm_media"
          ],
          "line": 1738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_TYPE",
          "args": [
            "ifm->ifm_media"
          ],
          "line": 1735
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint vr_ifmedia_upd;\nvoid vr_autoneg_mii;\nvoid vr_setmode_mii;\n\nint\nvr_ifmedia_upd(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct vr_softc\t\t*sc;\n\tstruct ifmedia\t\t*ifm;\n\n\tsc = ifp->if_softc;\n\tifm = &sc->ifmedia;\n\n\tif (IFM_TYPE(ifm->ifm_media) != IFM_ETHER)\n\t\treturn(EINVAL);\n\n\tif (IFM_SUBTYPE(ifm->ifm_media) == IFM_AUTO)\n\t\tvr_autoneg_mii(sc, VR_FLAG_SCHEDDELAY, 1);\n\telse\n\t\tvr_setmode_mii(sc, ifm->ifm_media);\n\n\treturn(0);\n}"
  },
  {
    "function_name": "vr_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
    "lines": "1630-1720",
    "snippet": "void\nvr_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct vr_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tu_int16_t\t\tphy_bmcr = 0;\n\tint\t\t\ts;\n\n\tif (sc->vr_autoneg)\n\t\treturn;\n\n\ts = splimp();\n\n\tif (sc->vr_pinfo != NULL)\n\t\tphy_bmcr = vr_phy_readreg(sc, PHY_BMCR);\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\tvr_stop(sc);\n\tvr_reset(sc);\n\n\tVR_CLRBIT(sc, VR_RXCFG, VR_RXCFG_RX_THRESH);\n\tVR_SETBIT(sc, VR_RXCFG, VR_RXTHRESH_STORENFWD);\n\n\tVR_CLRBIT(sc, VR_TXCFG, VR_TXCFG_TX_THRESH);\n\tVR_SETBIT(sc, VR_TXCFG, VR_TXTHRESH_STORENFWD);\n\n\t/* Init circular RX list. */\n\tif (vr_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: initialization failed: no memory for rx buffers\\n\",\n\t\t\t\t\t\t\tsc->sc_dev.dv_xname);\n\t\tvr_stop(sc);\n\t\t(void)splx(s);\n\t\treturn;\n\t}\n\n\t/*\n\t * Init tx descriptors.\n\t */\n\tvr_list_tx_init(sc);\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tVR_SETBIT(sc, VR_RXCFG, VR_RXCFG_RX_PROMISC);\n\telse\n\t\tVR_CLRBIT(sc, VR_RXCFG, VR_RXCFG_RX_PROMISC);\n\n\t/* Set capture broadcast bit to capture broadcast frames. */\n\tif (ifp->if_flags & IFF_BROADCAST)\n\t\tVR_SETBIT(sc, VR_RXCFG, VR_RXCFG_RX_BROAD);\n\telse\n\t\tVR_CLRBIT(sc, VR_RXCFG, VR_RXCFG_RX_BROAD);\n\n\t/*\n\t * Program the multicast filter, if necessary.\n\t */\n\tvr_setmulti(sc);\n\n\t/*\n\t * Load the address of the RX list.\n\t */\n\tCSR_WRITE_4(sc, VR_RXADDR, vtophys(sc->vr_cdata.vr_rx_head->vr_ptr));\n\n\t/* Enable receiver and transmitter. */\n\tCSR_WRITE_2(sc, VR_COMMAND, VR_CMD_TX_NOPOLL|VR_CMD_START|\n\t\t\t\t    VR_CMD_TX_ON|VR_CMD_RX_ON|\n\t\t\t\t    VR_CMD_RX_GO);\n\n\tvr_setcfg(sc, vr_phy_readreg(sc, PHY_BMCR));\n\n\tCSR_WRITE_4(sc, VR_TXADDR, vtophys(&sc->vr_ldata->vr_tx_list[0]));\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_2(sc, VR_ISR, 0xFFFF);\n\tCSR_WRITE_2(sc, VR_IMR, VR_INTRS);\n\n\t/* Restore state of BMCR */\n\tif (sc->vr_pinfo != NULL)\n\t\tvr_phy_writereg(sc, PHY_BMCR, phy_bmcr);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_vrreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/device.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void vr_init",
      "void vr_stop",
      "u_int16_t vr_phy_readreg",
      "void vr_phy_writereg",
      "void vr_setcfg",
      "void vr_setmulti",
      "void vr_reset",
      "int vr_list_rx_init",
      "int vr_list_tx_init"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vr_phy_writereg",
          "args": [
            "sc",
            "PHY_BMCR",
            "phy_bmcr"
          ],
          "line": 1712
        },
        "resolved": true,
        "details": {
          "function_name": "vr_phy_writereg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "406-423",
          "snippet": "void\nvr_phy_writereg(sc, reg, data)\n\tstruct vr_softc\t\t*sc;\n\tu_int16_t\t\treg;\n\tu_int16_t\t\tdata;\n{\n\tstruct vr_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->vr_phy_addr;\n\tframe.mii_regaddr = reg;\n\tframe.mii_data = data;\n\n\tvr_mii_writereg(sc, &frame);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int vr_mii_writereg",
            "void vr_phy_writereg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint vr_mii_writereg;\nvoid vr_phy_writereg;\n\nvoid\nvr_phy_writereg(sc, reg, data)\n\tstruct vr_softc\t\t*sc;\n\tu_int16_t\t\treg;\n\tu_int16_t\t\tdata;\n{\n\tstruct vr_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->vr_phy_addr;\n\tframe.mii_regaddr = reg;\n\tframe.mii_data = data;\n\n\tvr_mii_writereg(sc, &frame);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "VR_IMR",
            "VR_INTRS"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "VR_ISR",
            "0xFFFF"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "VR_TXADDR",
            "vtophys(&sc->vr_ldata->vr_tx_list[0])"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&sc->vr_ldata->vr_tx_list[0]"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vr_setcfg",
          "args": [
            "sc",
            "vr_phy_readreg(sc, PHY_BMCR)"
          ],
          "line": 1700
        },
        "resolved": true,
        "details": {
          "function_name": "vr_setcfg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "807-828",
          "snippet": "void\nvr_setcfg(sc, bmcr)\n\tstruct vr_softc\t\t*sc;\n\tu_int16_t\t\tbmcr;\n{\n\tint\t\t\trestart = 0;\n\n\tif (CSR_READ_2(sc, VR_COMMAND) & (VR_CMD_TX_ON|VR_CMD_RX_ON)) {\n\t\trestart = 1;\n\t\tVR_CLRBIT16(sc, VR_COMMAND, (VR_CMD_TX_ON|VR_CMD_RX_ON));\n\t}\n\n\tif (bmcr & PHY_BMCR_DUPLEX)\n\t\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_FULLDUPLEX);\n\telse\n\t\tVR_CLRBIT16(sc, VR_COMMAND, VR_CMD_FULLDUPLEX);\n\n\tif (restart)\n\t\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_TX_ON|VR_CMD_RX_ON);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void vr_setcfg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_setcfg;\n\nvoid\nvr_setcfg(sc, bmcr)\n\tstruct vr_softc\t\t*sc;\n\tu_int16_t\t\tbmcr;\n{\n\tint\t\t\trestart = 0;\n\n\tif (CSR_READ_2(sc, VR_COMMAND) & (VR_CMD_TX_ON|VR_CMD_RX_ON)) {\n\t\trestart = 1;\n\t\tVR_CLRBIT16(sc, VR_COMMAND, (VR_CMD_TX_ON|VR_CMD_RX_ON));\n\t}\n\n\tif (bmcr & PHY_BMCR_DUPLEX)\n\t\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_FULLDUPLEX);\n\telse\n\t\tVR_CLRBIT16(sc, VR_COMMAND, VR_CMD_FULLDUPLEX);\n\n\tif (restart)\n\t\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_TX_ON|VR_CMD_RX_ON);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vr_phy_readreg",
          "args": [
            "sc",
            "PHY_BMCR"
          ],
          "line": 1700
        },
        "resolved": true,
        "details": {
          "function_name": "vr_phy_readreg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "390-404",
          "snippet": "u_int16_t\nvr_phy_readreg(sc, reg)\n\tstruct vr_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tstruct vr_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->vr_phy_addr;\n\tframe.mii_regaddr = reg;\n\tvr_mii_readreg(sc, &frame);\n\n\treturn(frame.mii_data);\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int vr_mii_readreg",
            "u_int16_t vr_phy_readreg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint vr_mii_readreg;\nu_int16_t vr_phy_readreg;\n\nu_int16_t\nvr_phy_readreg(sc, reg)\n\tstruct vr_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tstruct vr_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->vr_phy_addr;\n\tframe.mii_regaddr = reg;\n\tvr_mii_readreg(sc, &frame);\n\n\treturn(frame.mii_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "VR_COMMAND",
            "VR_CMD_TX_NOPOLL|VR_CMD_START|\n\t\t\t\t    VR_CMD_TX_ON|VR_CMD_RX_ON|\n\t\t\t\t    VR_CMD_RX_GO"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "VR_RXADDR",
            "vtophys(sc->vr_cdata.vr_rx_head->vr_ptr)"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "sc->vr_cdata.vr_rx_head->vr_ptr"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vr_setmulti",
          "args": [
            "sc"
          ],
          "line": 1688
        },
        "resolved": true,
        "details": {
          "function_name": "vr_setmulti",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "457-509",
          "snippet": "void\nvr_setmulti(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\th = 0;\n\tu_int32_t\t\thashes[2] = { 0, 0 };\n\tstruct arpcom *ac = &sc->arpcom;\n\tstruct ether_multi *enm;\n\tstruct ether_multistep step;\n\tu_int8_t\t\trxfilt;\n\tint\t\t\tmcnt = 0;\n\n\tifp = &sc->arpcom.ac_if;\n\n\trxfilt = CSR_READ_1(sc, VR_RXCFG);\n\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\trxfilt |= VR_RXCFG_RX_MULTI;\n\t\tCSR_WRITE_1(sc, VR_RXCFG, rxfilt);\n\t\tCSR_WRITE_4(sc, VR_MAR0, 0xFFFFFFFF);\n\t\tCSR_WRITE_4(sc, VR_MAR1, 0xFFFFFFFF);\n\t\treturn;\n\t}\n\n\t/* first, zot all the existing hash bits */\n\tCSR_WRITE_4(sc, VR_MAR0, 0);\n\tCSR_WRITE_4(sc, VR_MAR1, 0);\n\n\t/* now program new ones */\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\th = vr_calchash(enm->enm_addrlo);\n\t\tif (h < 32)\n\t\t\thashes[0] |= (1 << h);\n\t\telse\n\t\t\thashes[1] |= (1 << (h - 32));\n\t\tmcnt++;\n\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\n\tif (mcnt)\n\t\trxfilt |= VR_RXCFG_RX_MULTI;\n\telse\n\t\trxfilt &= ~VR_RXCFG_RX_MULTI;\n\n\tCSR_WRITE_4(sc, VR_MAR0, hashes[0]);\n\tCSR_WRITE_4(sc, VR_MAR1, hashes[1]);\n\tCSR_WRITE_1(sc, VR_RXCFG, rxfilt);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int8_t vr_calchash",
            "void vr_setmulti"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int8_t vr_calchash;\nvoid vr_setmulti;\n\nvoid\nvr_setmulti(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\th = 0;\n\tu_int32_t\t\thashes[2] = { 0, 0 };\n\tstruct arpcom *ac = &sc->arpcom;\n\tstruct ether_multi *enm;\n\tstruct ether_multistep step;\n\tu_int8_t\t\trxfilt;\n\tint\t\t\tmcnt = 0;\n\n\tifp = &sc->arpcom.ac_if;\n\n\trxfilt = CSR_READ_1(sc, VR_RXCFG);\n\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\trxfilt |= VR_RXCFG_RX_MULTI;\n\t\tCSR_WRITE_1(sc, VR_RXCFG, rxfilt);\n\t\tCSR_WRITE_4(sc, VR_MAR0, 0xFFFFFFFF);\n\t\tCSR_WRITE_4(sc, VR_MAR1, 0xFFFFFFFF);\n\t\treturn;\n\t}\n\n\t/* first, zot all the existing hash bits */\n\tCSR_WRITE_4(sc, VR_MAR0, 0);\n\tCSR_WRITE_4(sc, VR_MAR1, 0);\n\n\t/* now program new ones */\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\th = vr_calchash(enm->enm_addrlo);\n\t\tif (h < 32)\n\t\t\thashes[0] |= (1 << h);\n\t\telse\n\t\t\thashes[1] |= (1 << (h - 32));\n\t\tmcnt++;\n\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\n\tif (mcnt)\n\t\trxfilt |= VR_RXCFG_RX_MULTI;\n\telse\n\t\trxfilt &= ~VR_RXCFG_RX_MULTI;\n\n\tCSR_WRITE_4(sc, VR_MAR0, hashes[0]);\n\tCSR_WRITE_4(sc, VR_MAR1, hashes[1]);\n\tCSR_WRITE_1(sc, VR_RXCFG, rxfilt);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VR_CLRBIT",
          "args": [
            "sc",
            "VR_RXCFG",
            "VR_RXCFG_RX_BROAD"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VR_SETBIT",
          "args": [
            "sc",
            "VR_RXCFG",
            "VR_RXCFG_RX_BROAD"
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VR_CLRBIT",
          "args": [
            "sc",
            "VR_RXCFG",
            "VR_RXCFG_RX_PROMISC"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VR_SETBIT",
          "args": [
            "sc",
            "VR_RXCFG",
            "VR_RXCFG_RX_PROMISC"
          ],
          "line": 1675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vr_list_tx_init",
          "args": [
            "sc"
          ],
          "line": 1671
        },
        "resolved": true,
        "details": {
          "function_name": "vr_list_tx_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "1108-1132",
          "snippet": "int\nvr_list_tx_init(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tstruct vr_chain_data\t*cd;\n\tstruct vr_list_data\t*ld;\n\tint\t\t\ti;\n\n\tcd = &sc->vr_cdata;\n\tld = sc->vr_ldata;\n\tfor (i = 0; i < VR_TX_LIST_CNT; i++) {\n\t\tcd->vr_tx_chain[i].vr_ptr = &ld->vr_tx_list[i];\n\t\tif (i == (VR_TX_LIST_CNT - 1))\n\t\t\tcd->vr_tx_chain[i].vr_nextdesc = \n\t\t\t\t&cd->vr_tx_chain[0];\n\t\telse\n\t\t\tcd->vr_tx_chain[i].vr_nextdesc =\n\t\t\t\t&cd->vr_tx_chain[i + 1];\n\t}\n\n\tcd->vr_tx_free = &cd->vr_tx_chain[0];\n\tcd->vr_tx_tail = cd->vr_tx_head = NULL;\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int vr_list_tx_init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint vr_list_tx_init;\n\nint\nvr_list_tx_init(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tstruct vr_chain_data\t*cd;\n\tstruct vr_list_data\t*ld;\n\tint\t\t\ti;\n\n\tcd = &sc->vr_cdata;\n\tld = sc->vr_ldata;\n\tfor (i = 0; i < VR_TX_LIST_CNT; i++) {\n\t\tcd->vr_tx_chain[i].vr_ptr = &ld->vr_tx_list[i];\n\t\tif (i == (VR_TX_LIST_CNT - 1))\n\t\t\tcd->vr_tx_chain[i].vr_nextdesc = \n\t\t\t\t&cd->vr_tx_chain[0];\n\t\telse\n\t\t\tcd->vr_tx_chain[i].vr_nextdesc =\n\t\t\t\t&cd->vr_tx_chain[i + 1];\n\t}\n\n\tcd->vr_tx_free = &cd->vr_tx_chain[0];\n\tcd->vr_tx_tail = cd->vr_tx_head = NULL;\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vr_stop",
          "args": [
            "sc"
          ],
          "line": 1663
        },
        "resolved": true,
        "details": {
          "function_name": "vr_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "1900-1944",
          "snippet": "void\nvr_stop(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_timer = 0;\n\n\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_STOP);\n\tVR_CLRBIT16(sc, VR_COMMAND, (VR_CMD_RX_ON|VR_CMD_TX_ON));\n\tCSR_WRITE_2(sc, VR_IMR, 0x0000);\n\tCSR_WRITE_4(sc, VR_TXADDR, 0x00000000);\n\tCSR_WRITE_4(sc, VR_RXADDR, 0x00000000);\n\n\t/*\n\t * Free data in the RX lists.\n\t */\n\tfor (i = 0; i < VR_RX_LIST_CNT; i++) {\n\t\tif (sc->vr_cdata.vr_rx_chain[i].vr_mbuf != NULL) {\n\t\t\tm_freem(sc->vr_cdata.vr_rx_chain[i].vr_mbuf);\n\t\t\tsc->vr_cdata.vr_rx_chain[i].vr_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->vr_ldata->vr_rx_list,\n\t\tsizeof(sc->vr_ldata->vr_rx_list));\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < VR_TX_LIST_CNT; i++) {\n\t\tif (sc->vr_cdata.vr_tx_chain[i].vr_mbuf != NULL) {\n\t\t\tm_freem(sc->vr_cdata.vr_tx_chain[i].vr_mbuf);\n\t\t\tsc->vr_cdata.vr_tx_chain[i].vr_mbuf = NULL;\n\t\t}\n\t}\n\n\tbzero((char *)&sc->vr_ldata->vr_tx_list,\n\t\tsizeof(sc->vr_ldata->vr_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void vr_stop"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_stop;\n\nvoid\nvr_stop(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_timer = 0;\n\n\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_STOP);\n\tVR_CLRBIT16(sc, VR_COMMAND, (VR_CMD_RX_ON|VR_CMD_TX_ON));\n\tCSR_WRITE_2(sc, VR_IMR, 0x0000);\n\tCSR_WRITE_4(sc, VR_TXADDR, 0x00000000);\n\tCSR_WRITE_4(sc, VR_RXADDR, 0x00000000);\n\n\t/*\n\t * Free data in the RX lists.\n\t */\n\tfor (i = 0; i < VR_RX_LIST_CNT; i++) {\n\t\tif (sc->vr_cdata.vr_rx_chain[i].vr_mbuf != NULL) {\n\t\t\tm_freem(sc->vr_cdata.vr_rx_chain[i].vr_mbuf);\n\t\t\tsc->vr_cdata.vr_rx_chain[i].vr_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->vr_ldata->vr_rx_list,\n\t\tsizeof(sc->vr_ldata->vr_rx_list));\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < VR_TX_LIST_CNT; i++) {\n\t\tif (sc->vr_cdata.vr_tx_chain[i].vr_mbuf != NULL) {\n\t\t\tm_freem(sc->vr_cdata.vr_tx_chain[i].vr_mbuf);\n\t\t\tsc->vr_cdata.vr_tx_chain[i].vr_mbuf = NULL;\n\t\t}\n\t}\n\n\tbzero((char *)&sc->vr_ldata->vr_tx_list,\n\t\tsizeof(sc->vr_ldata->vr_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: initialization failed: no memory for rx buffers\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1661
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vr_list_rx_init",
          "args": [
            "sc"
          ],
          "line": 1660
        },
        "resolved": true,
        "details": {
          "function_name": "vr_list_rx_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "1140-1172",
          "snippet": "int\nvr_list_rx_init(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tstruct vr_chain_data\t*cd;\n\tstruct vr_list_data\t*ld;\n\tint\t\t\ti;\n\n\tcd = &sc->vr_cdata;\n\tld = sc->vr_ldata;\n\n\tfor (i = 0; i < VR_RX_LIST_CNT; i++) {\n\t\tcd->vr_rx_chain[i].vr_ptr =\n\t\t\t(struct vr_desc *)&ld->vr_rx_list[i];\n\t\tif (vr_newbuf(sc, &cd->vr_rx_chain[i]) == ENOBUFS)\n\t\t\treturn(ENOBUFS);\n\t\tif (i == (VR_RX_LIST_CNT - 1)) {\n\t\t\tcd->vr_rx_chain[i].vr_nextdesc =\n\t\t\t\t\t&cd->vr_rx_chain[0];\n\t\t\tld->vr_rx_list[i].vr_next =\n\t\t\t\t\tvtophys(&ld->vr_rx_list[0]);\n\t\t} else {\n\t\t\tcd->vr_rx_chain[i].vr_nextdesc =\n\t\t\t\t\t&cd->vr_rx_chain[i + 1];\n\t\t\tld->vr_rx_list[i].vr_next =\n\t\t\t\t\tvtophys(&ld->vr_rx_list[i + 1]);\n\t\t}\n\t}\n\n\tcd->vr_rx_head = &cd->vr_rx_chain[0];\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int vr_newbuf",
            "int vr_list_rx_init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint vr_newbuf;\nint vr_list_rx_init;\n\nint\nvr_list_rx_init(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tstruct vr_chain_data\t*cd;\n\tstruct vr_list_data\t*ld;\n\tint\t\t\ti;\n\n\tcd = &sc->vr_cdata;\n\tld = sc->vr_ldata;\n\n\tfor (i = 0; i < VR_RX_LIST_CNT; i++) {\n\t\tcd->vr_rx_chain[i].vr_ptr =\n\t\t\t(struct vr_desc *)&ld->vr_rx_list[i];\n\t\tif (vr_newbuf(sc, &cd->vr_rx_chain[i]) == ENOBUFS)\n\t\t\treturn(ENOBUFS);\n\t\tif (i == (VR_RX_LIST_CNT - 1)) {\n\t\t\tcd->vr_rx_chain[i].vr_nextdesc =\n\t\t\t\t\t&cd->vr_rx_chain[0];\n\t\t\tld->vr_rx_list[i].vr_next =\n\t\t\t\t\tvtophys(&ld->vr_rx_list[0]);\n\t\t} else {\n\t\t\tcd->vr_rx_chain[i].vr_nextdesc =\n\t\t\t\t\t&cd->vr_rx_chain[i + 1];\n\t\t\tld->vr_rx_list[i].vr_next =\n\t\t\t\t\tvtophys(&ld->vr_rx_list[i + 1]);\n\t\t}\n\t}\n\n\tcd->vr_rx_head = &cd->vr_rx_chain[0];\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VR_SETBIT",
          "args": [
            "sc",
            "VR_TXCFG",
            "VR_TXTHRESH_STORENFWD"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VR_CLRBIT",
          "args": [
            "sc",
            "VR_TXCFG",
            "VR_TXCFG_TX_THRESH"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VR_SETBIT",
          "args": [
            "sc",
            "VR_RXCFG",
            "VR_RXTHRESH_STORENFWD"
          ],
          "line": 1654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VR_CLRBIT",
          "args": [
            "sc",
            "VR_RXCFG",
            "VR_RXCFG_RX_THRESH"
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vr_reset",
          "args": [
            "sc"
          ],
          "line": 1651
        },
        "resolved": true,
        "details": {
          "function_name": "vr_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "830-850",
          "snippet": "void\nvr_reset(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_RESET);\n\n\tfor (i = 0; i < VR_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(CSR_READ_2(sc, VR_COMMAND) & VR_CMD_RESET))\n\t\t\tbreak;\n\t}\n\tif (i == VR_TIMEOUT)\n\t\tprintf(\"%s: reset never completed!\\n\", sc->sc_dev.dv_xname);\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tDELAY(1000);\n\n        return;\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void vr_reset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_reset;\n\nvoid\nvr_reset(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_RESET);\n\n\tfor (i = 0; i < VR_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(CSR_READ_2(sc, VR_COMMAND) & VR_CMD_RESET))\n\t\t\tbreak;\n\t}\n\tif (i == VR_TIMEOUT)\n\t\tprintf(\"%s: reset never completed!\\n\", sc->sc_dev.dv_xname);\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tDELAY(1000);\n\n        return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_init;\nvoid vr_stop;\nu_int16_t vr_phy_readreg;\nvoid vr_phy_writereg;\nvoid vr_setcfg;\nvoid vr_setmulti;\nvoid vr_reset;\nint vr_list_rx_init;\nint vr_list_tx_init;\n\nvoid\nvr_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct vr_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tu_int16_t\t\tphy_bmcr = 0;\n\tint\t\t\ts;\n\n\tif (sc->vr_autoneg)\n\t\treturn;\n\n\ts = splimp();\n\n\tif (sc->vr_pinfo != NULL)\n\t\tphy_bmcr = vr_phy_readreg(sc, PHY_BMCR);\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\tvr_stop(sc);\n\tvr_reset(sc);\n\n\tVR_CLRBIT(sc, VR_RXCFG, VR_RXCFG_RX_THRESH);\n\tVR_SETBIT(sc, VR_RXCFG, VR_RXTHRESH_STORENFWD);\n\n\tVR_CLRBIT(sc, VR_TXCFG, VR_TXCFG_TX_THRESH);\n\tVR_SETBIT(sc, VR_TXCFG, VR_TXTHRESH_STORENFWD);\n\n\t/* Init circular RX list. */\n\tif (vr_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: initialization failed: no memory for rx buffers\\n\",\n\t\t\t\t\t\t\tsc->sc_dev.dv_xname);\n\t\tvr_stop(sc);\n\t\t(void)splx(s);\n\t\treturn;\n\t}\n\n\t/*\n\t * Init tx descriptors.\n\t */\n\tvr_list_tx_init(sc);\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tVR_SETBIT(sc, VR_RXCFG, VR_RXCFG_RX_PROMISC);\n\telse\n\t\tVR_CLRBIT(sc, VR_RXCFG, VR_RXCFG_RX_PROMISC);\n\n\t/* Set capture broadcast bit to capture broadcast frames. */\n\tif (ifp->if_flags & IFF_BROADCAST)\n\t\tVR_SETBIT(sc, VR_RXCFG, VR_RXCFG_RX_BROAD);\n\telse\n\t\tVR_CLRBIT(sc, VR_RXCFG, VR_RXCFG_RX_BROAD);\n\n\t/*\n\t * Program the multicast filter, if necessary.\n\t */\n\tvr_setmulti(sc);\n\n\t/*\n\t * Load the address of the RX list.\n\t */\n\tCSR_WRITE_4(sc, VR_RXADDR, vtophys(sc->vr_cdata.vr_rx_head->vr_ptr));\n\n\t/* Enable receiver and transmitter. */\n\tCSR_WRITE_2(sc, VR_COMMAND, VR_CMD_TX_NOPOLL|VR_CMD_START|\n\t\t\t\t    VR_CMD_TX_ON|VR_CMD_RX_ON|\n\t\t\t\t    VR_CMD_RX_GO);\n\n\tvr_setcfg(sc, vr_phy_readreg(sc, PHY_BMCR));\n\n\tCSR_WRITE_4(sc, VR_TXADDR, vtophys(&sc->vr_ldata->vr_tx_list[0]));\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_2(sc, VR_ISR, 0xFFFF);\n\tCSR_WRITE_2(sc, VR_IMR, VR_INTRS);\n\n\t/* Restore state of BMCR */\n\tif (sc->vr_pinfo != NULL)\n\t\tvr_phy_writereg(sc, PHY_BMCR, phy_bmcr);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\treturn;\n}"
  },
  {
    "function_name": "vr_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
    "lines": "1558-1628",
    "snippet": "void\nvr_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct vr_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head = NULL;\n\tstruct vr_chain\t\t*cur_tx = NULL, *start_tx;\n\n\tsc = ifp->if_softc;\n\n\tif (sc->vr_autoneg) {\n\t\tsc->vr_tx_pend = 1;\n\t\treturn;\n\t}\n\n\t/*\n\t * Check for an available queue slot. If there are none,\n\t * punt.\n\t */\n\tif (sc->vr_cdata.vr_tx_free->vr_mbuf != NULL) {\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\n\tstart_tx = sc->vr_cdata.vr_tx_free;\n\n\twhile(sc->vr_cdata.vr_tx_free->vr_mbuf == NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\t/* Pick a descriptor off the free list. */\n\t\tcur_tx = sc->vr_cdata.vr_tx_free;\n\t\tsc->vr_cdata.vr_tx_free = cur_tx->vr_nextdesc;\n\n\t\t/* Pack the data into the descriptor. */\n\t\tvr_encap(sc, cur_tx, m_head);\n\n\t\tif (cur_tx != start_tx)\n\t\t\tVR_TXOWN(cur_tx) = VR_TXSTAT_OWN;\n\n#if NBPFILTER > 0\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, cur_tx->vr_mbuf);\n#endif\n\t\tVR_TXOWN(cur_tx) = VR_TXSTAT_OWN;\n\t\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_TX_ON|VR_CMD_TX_GO);\n\t}\n\n\t/*\n\t * If there are no frames queued, bail.\n\t */\n\tif (cur_tx == NULL)\n\t\treturn;\n\n\tsc->vr_cdata.vr_tx_tail = cur_tx;\n\n\tif (sc->vr_cdata.vr_tx_head == NULL)\n\t\tsc->vr_cdata.vr_tx_head = start_tx;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_vrreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/device.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int vr_encap",
      "void vr_start"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VR_SETBIT16",
          "args": [
            "sc",
            "VR_COMMAND",
            "VR_CMD_TX_ON|VR_CMD_TX_GO"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VR_TXOWN",
          "args": [
            "cur_tx"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "cur_tx->vr_mbuf"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VR_TXOWN",
          "args": [
            "cur_tx"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vr_encap",
          "args": [
            "sc",
            "cur_tx",
            "m_head"
          ],
          "line": 1594
        },
        "resolved": true,
        "details": {
          "function_name": "vr_encap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "1488-1549",
          "snippet": "int\nvr_encap(sc, c, m_head)\n\tstruct vr_softc\t\t*sc;\n\tstruct vr_chain\t\t*c;\n\tstruct mbuf\t\t*m_head;\n{\n\tint\t\t\tfrag = 0;\n\tstruct vr_desc\t\t*f = NULL;\n\tint\t\t\ttotal_len;\n\tstruct mbuf\t\t*m;\n\n\tm = m_head;\n\ttotal_len = 0;\n\n\t/*\n\t * The VIA Rhine wants packet buffers to be longword\n\t * aligned, but very often our mbufs aren't. Rather than\n\t * waste time trying to decide when to copy and when not\n\t * to copy, just do it all the time.\n\t */\n\tif (m != NULL) {\n\t\tstruct mbuf\t\t*m_new = NULL;\n\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\treturn(1);\n\t\t}\n\t\tif (m_head->m_pkthdr.len > MHLEN) {\n\t\t\tMCLGET(m_new, M_DONTWAIT);\n\t\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\t\tm_freem(m_new);\n\t\t\t\treturn(1);\n\t\t\t}\n\t\t}\n\t\tm_copydata(m_head, 0, m_head->m_pkthdr.len,\t\n\t\t\t\t\tmtod(m_new, caddr_t));\n\t\tm_new->m_pkthdr.len = m_new->m_len = m_head->m_pkthdr.len;\n\t\tm_freem(m_head);\n\t\tm_head = m_new;\n\t\t/*\n\t\t * The Rhine chip doesn't auto-pad, so we have to make\n\t\t * sure to pad short frames out to the minimum frame length\n\t\t * ourselves.\n\t\t */\n\t\tif (m_head->m_len < VR_MIN_FRAMELEN) {\n\t\t\tm_new->m_pkthdr.len += VR_MIN_FRAMELEN - m_new->m_len;\n\t\t\tm_new->m_len = m_new->m_pkthdr.len;\n\t\t}\n\t\tf = c->vr_ptr;\n\t\tf->vr_data = vtophys(mtod(m_new, caddr_t));\n\t\tf->vr_ctl = total_len = m_new->m_len;\n\t\tf->vr_ctl |= VR_TXCTL_TLINK|VR_TXCTL_FIRSTFRAG;\n\t\tf->vr_status = 0;\n\t\tfrag = 1;\n\t}\n\n\tc->vr_mbuf = m_head;\n\tc->vr_ptr->vr_ctl |= VR_TXCTL_LASTFRAG|VR_TXCTL_FINT;\n\tc->vr_ptr->vr_next = vtophys(c->vr_nextdesc->vr_ptr);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int vr_encap"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint vr_encap;\n\nint\nvr_encap(sc, c, m_head)\n\tstruct vr_softc\t\t*sc;\n\tstruct vr_chain\t\t*c;\n\tstruct mbuf\t\t*m_head;\n{\n\tint\t\t\tfrag = 0;\n\tstruct vr_desc\t\t*f = NULL;\n\tint\t\t\ttotal_len;\n\tstruct mbuf\t\t*m;\n\n\tm = m_head;\n\ttotal_len = 0;\n\n\t/*\n\t * The VIA Rhine wants packet buffers to be longword\n\t * aligned, but very often our mbufs aren't. Rather than\n\t * waste time trying to decide when to copy and when not\n\t * to copy, just do it all the time.\n\t */\n\tif (m != NULL) {\n\t\tstruct mbuf\t\t*m_new = NULL;\n\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\treturn(1);\n\t\t}\n\t\tif (m_head->m_pkthdr.len > MHLEN) {\n\t\t\tMCLGET(m_new, M_DONTWAIT);\n\t\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\t\tm_freem(m_new);\n\t\t\t\treturn(1);\n\t\t\t}\n\t\t}\n\t\tm_copydata(m_head, 0, m_head->m_pkthdr.len,\t\n\t\t\t\t\tmtod(m_new, caddr_t));\n\t\tm_new->m_pkthdr.len = m_new->m_len = m_head->m_pkthdr.len;\n\t\tm_freem(m_head);\n\t\tm_head = m_new;\n\t\t/*\n\t\t * The Rhine chip doesn't auto-pad, so we have to make\n\t\t * sure to pad short frames out to the minimum frame length\n\t\t * ourselves.\n\t\t */\n\t\tif (m_head->m_len < VR_MIN_FRAMELEN) {\n\t\t\tm_new->m_pkthdr.len += VR_MIN_FRAMELEN - m_new->m_len;\n\t\t\tm_new->m_len = m_new->m_pkthdr.len;\n\t\t}\n\t\tf = c->vr_ptr;\n\t\tf->vr_data = vtophys(mtod(m_new, caddr_t));\n\t\tf->vr_ctl = total_len = m_new->m_len;\n\t\tf->vr_ctl |= VR_TXCTL_TLINK|VR_TXCTL_FIRSTFRAG;\n\t\tf->vr_status = 0;\n\t\tfrag = 1;\n\t}\n\n\tc->vr_mbuf = m_head;\n\tc->vr_ptr->vr_ctl |= VR_TXCTL_LASTFRAG|VR_TXCTL_FINT;\n\tc->vr_ptr->vr_next = vtophys(c->vr_nextdesc->vr_ptr);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "m_head"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint vr_encap;\nvoid vr_start;\n\nvoid\nvr_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct vr_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head = NULL;\n\tstruct vr_chain\t\t*cur_tx = NULL, *start_tx;\n\n\tsc = ifp->if_softc;\n\n\tif (sc->vr_autoneg) {\n\t\tsc->vr_tx_pend = 1;\n\t\treturn;\n\t}\n\n\t/*\n\t * Check for an available queue slot. If there are none,\n\t * punt.\n\t */\n\tif (sc->vr_cdata.vr_tx_free->vr_mbuf != NULL) {\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\n\tstart_tx = sc->vr_cdata.vr_tx_free;\n\n\twhile(sc->vr_cdata.vr_tx_free->vr_mbuf == NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\t/* Pick a descriptor off the free list. */\n\t\tcur_tx = sc->vr_cdata.vr_tx_free;\n\t\tsc->vr_cdata.vr_tx_free = cur_tx->vr_nextdesc;\n\n\t\t/* Pack the data into the descriptor. */\n\t\tvr_encap(sc, cur_tx, m_head);\n\n\t\tif (cur_tx != start_tx)\n\t\t\tVR_TXOWN(cur_tx) = VR_TXSTAT_OWN;\n\n#if NBPFILTER > 0\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, cur_tx->vr_mbuf);\n#endif\n\t\tVR_TXOWN(cur_tx) = VR_TXSTAT_OWN;\n\t\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_TX_ON|VR_CMD_TX_GO);\n\t}\n\n\t/*\n\t * If there are no frames queued, bail.\n\t */\n\tif (cur_tx == NULL)\n\t\treturn;\n\n\tsc->vr_cdata.vr_tx_tail = cur_tx;\n\n\tif (sc->vr_cdata.vr_tx_head == NULL)\n\t\tsc->vr_cdata.vr_tx_head = start_tx;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n\n\treturn;\n}"
  },
  {
    "function_name": "vr_encap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
    "lines": "1488-1549",
    "snippet": "int\nvr_encap(sc, c, m_head)\n\tstruct vr_softc\t\t*sc;\n\tstruct vr_chain\t\t*c;\n\tstruct mbuf\t\t*m_head;\n{\n\tint\t\t\tfrag = 0;\n\tstruct vr_desc\t\t*f = NULL;\n\tint\t\t\ttotal_len;\n\tstruct mbuf\t\t*m;\n\n\tm = m_head;\n\ttotal_len = 0;\n\n\t/*\n\t * The VIA Rhine wants packet buffers to be longword\n\t * aligned, but very often our mbufs aren't. Rather than\n\t * waste time trying to decide when to copy and when not\n\t * to copy, just do it all the time.\n\t */\n\tif (m != NULL) {\n\t\tstruct mbuf\t\t*m_new = NULL;\n\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\treturn(1);\n\t\t}\n\t\tif (m_head->m_pkthdr.len > MHLEN) {\n\t\t\tMCLGET(m_new, M_DONTWAIT);\n\t\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\t\tm_freem(m_new);\n\t\t\t\treturn(1);\n\t\t\t}\n\t\t}\n\t\tm_copydata(m_head, 0, m_head->m_pkthdr.len,\t\n\t\t\t\t\tmtod(m_new, caddr_t));\n\t\tm_new->m_pkthdr.len = m_new->m_len = m_head->m_pkthdr.len;\n\t\tm_freem(m_head);\n\t\tm_head = m_new;\n\t\t/*\n\t\t * The Rhine chip doesn't auto-pad, so we have to make\n\t\t * sure to pad short frames out to the minimum frame length\n\t\t * ourselves.\n\t\t */\n\t\tif (m_head->m_len < VR_MIN_FRAMELEN) {\n\t\t\tm_new->m_pkthdr.len += VR_MIN_FRAMELEN - m_new->m_len;\n\t\t\tm_new->m_len = m_new->m_pkthdr.len;\n\t\t}\n\t\tf = c->vr_ptr;\n\t\tf->vr_data = vtophys(mtod(m_new, caddr_t));\n\t\tf->vr_ctl = total_len = m_new->m_len;\n\t\tf->vr_ctl |= VR_TXCTL_TLINK|VR_TXCTL_FIRSTFRAG;\n\t\tf->vr_status = 0;\n\t\tfrag = 1;\n\t}\n\n\tc->vr_mbuf = m_head;\n\tc->vr_ptr->vr_ctl |= VR_TXCTL_LASTFRAG|VR_TXCTL_FINT;\n\tc->vr_ptr->vr_next = vtophys(c->vr_nextdesc->vr_ptr);\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/if_vrreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/device.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int vr_encap"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "c->vr_nextdesc->vr_ptr"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "mtod(m_new, caddr_t)"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m_new",
            "caddr_t"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m_head"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_copydata",
          "args": [
            "m_head",
            "0",
            "m_head->m_pkthdr.len",
            "mtod(m_new, caddr_t)"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m_new",
            "caddr_t"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m_new"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCLGET",
          "args": [
            "m_new",
            "M_DONTWAIT"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGETHDR",
          "args": [
            "m_new",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint vr_encap;\n\nint\nvr_encap(sc, c, m_head)\n\tstruct vr_softc\t\t*sc;\n\tstruct vr_chain\t\t*c;\n\tstruct mbuf\t\t*m_head;\n{\n\tint\t\t\tfrag = 0;\n\tstruct vr_desc\t\t*f = NULL;\n\tint\t\t\ttotal_len;\n\tstruct mbuf\t\t*m;\n\n\tm = m_head;\n\ttotal_len = 0;\n\n\t/*\n\t * The VIA Rhine wants packet buffers to be longword\n\t * aligned, but very often our mbufs aren't. Rather than\n\t * waste time trying to decide when to copy and when not\n\t * to copy, just do it all the time.\n\t */\n\tif (m != NULL) {\n\t\tstruct mbuf\t\t*m_new = NULL;\n\n\t\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\t\tif (m_new == NULL) {\n\t\t\treturn(1);\n\t\t}\n\t\tif (m_head->m_pkthdr.len > MHLEN) {\n\t\t\tMCLGET(m_new, M_DONTWAIT);\n\t\t\tif (!(m_new->m_flags & M_EXT)) {\n\t\t\t\tm_freem(m_new);\n\t\t\t\treturn(1);\n\t\t\t}\n\t\t}\n\t\tm_copydata(m_head, 0, m_head->m_pkthdr.len,\t\n\t\t\t\t\tmtod(m_new, caddr_t));\n\t\tm_new->m_pkthdr.len = m_new->m_len = m_head->m_pkthdr.len;\n\t\tm_freem(m_head);\n\t\tm_head = m_new;\n\t\t/*\n\t\t * The Rhine chip doesn't auto-pad, so we have to make\n\t\t * sure to pad short frames out to the minimum frame length\n\t\t * ourselves.\n\t\t */\n\t\tif (m_head->m_len < VR_MIN_FRAMELEN) {\n\t\t\tm_new->m_pkthdr.len += VR_MIN_FRAMELEN - m_new->m_len;\n\t\t\tm_new->m_len = m_new->m_pkthdr.len;\n\t\t}\n\t\tf = c->vr_ptr;\n\t\tf->vr_data = vtophys(mtod(m_new, caddr_t));\n\t\tf->vr_ctl = total_len = m_new->m_len;\n\t\tf->vr_ctl |= VR_TXCTL_TLINK|VR_TXCTL_FIRSTFRAG;\n\t\tf->vr_status = 0;\n\t\tfrag = 1;\n\t}\n\n\tc->vr_mbuf = m_head;\n\tc->vr_ptr->vr_ctl |= VR_TXCTL_LASTFRAG|VR_TXCTL_FINT;\n\tc->vr_ptr->vr_next = vtophys(c->vr_nextdesc->vr_ptr);\n\n\treturn(0);\n}"
  },
  {
    "function_name": "vr_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
    "lines": "1412-1482",
    "snippet": "int\nvr_intr(arg)\n\tvoid\t\t\t*arg;\n{\n\tstruct vr_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tu_int16_t\t\tstatus;\n\tint claimed = 0;\n\n\tsc = arg;\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Supress unwanted interrupts. */\n\tif (!(ifp->if_flags & IFF_UP)) {\n\t\tvr_stop(sc);\n\t\treturn 0;\n\t}\n\n\t/* Disable interrupts. */\n\tCSR_WRITE_2(sc, VR_IMR, 0x0000);\n\n\tfor (;;) {\n\n\t\tstatus = CSR_READ_2(sc, VR_ISR);\n\t\tif (status)\n\t\t\tCSR_WRITE_2(sc, VR_ISR, status);\n\n\t\tif ((status & VR_INTRS) == 0)\n\t\t\tbreak;\n\n\t\tclaimed = 1;\n\n\t\tif (status & VR_ISR_RX_OK)\n\t\t\tvr_rxeof(sc);\n\n\t\tif ((status & VR_ISR_RX_ERR) || (status & VR_ISR_RX_NOBUF) ||\n\t\t    (status & VR_ISR_RX_NOBUF) || (status & VR_ISR_RX_OFLOW) ||\n\t\t    (status & VR_ISR_RX_DROPPED)) {\n\t\t\tvr_rxeof(sc);\n\t\t\tvr_rxeoc(sc);\n\t\t}\n\n\t\tif (status & VR_ISR_TX_OK) {\n\t\t\tvr_txeof(sc);\n\t\t\tvr_txeoc(sc);\n\t\t}\n\n\t\tif ((status & VR_ISR_TX_UNDERRUN)||(status & VR_ISR_TX_ABRT)){ \n\t\t\tifp->if_oerrors++;\n\t\t\tvr_txeof(sc);\n\t\t\tif (sc->vr_cdata.vr_tx_head != NULL) {\n\t\t\t\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_TX_ON);\n\t\t\t\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_TX_GO);\n\t\t\t}\n\t\t}\n\n\t\tif (status & VR_ISR_BUSERR) {\n\t\t\tvr_reset(sc);\n\t\t\tvr_init(sc);\n\t\t}\n\t}\n\n\t/* Re-enable interrupts. */\n\tCSR_WRITE_2(sc, VR_IMR, VR_INTRS);\n\n\tif (ifp->if_snd.ifq_head != NULL) {\n\t\tvr_start(ifp);\n\t}\n\n\treturn (claimed);\n}",
    "includes": [
      "#include <dev/pci/if_vrreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/device.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void vr_rxeof",
      "void vr_rxeoc",
      "void vr_txeof",
      "void vr_txeoc",
      "int vr_intr",
      "void vr_start",
      "void vr_init",
      "void vr_stop",
      "void vr_reset"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vr_start",
          "args": [
            "ifp"
          ],
          "line": 1478
        },
        "resolved": true,
        "details": {
          "function_name": "vr_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "1558-1628",
          "snippet": "void\nvr_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct vr_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head = NULL;\n\tstruct vr_chain\t\t*cur_tx = NULL, *start_tx;\n\n\tsc = ifp->if_softc;\n\n\tif (sc->vr_autoneg) {\n\t\tsc->vr_tx_pend = 1;\n\t\treturn;\n\t}\n\n\t/*\n\t * Check for an available queue slot. If there are none,\n\t * punt.\n\t */\n\tif (sc->vr_cdata.vr_tx_free->vr_mbuf != NULL) {\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\n\tstart_tx = sc->vr_cdata.vr_tx_free;\n\n\twhile(sc->vr_cdata.vr_tx_free->vr_mbuf == NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\t/* Pick a descriptor off the free list. */\n\t\tcur_tx = sc->vr_cdata.vr_tx_free;\n\t\tsc->vr_cdata.vr_tx_free = cur_tx->vr_nextdesc;\n\n\t\t/* Pack the data into the descriptor. */\n\t\tvr_encap(sc, cur_tx, m_head);\n\n\t\tif (cur_tx != start_tx)\n\t\t\tVR_TXOWN(cur_tx) = VR_TXSTAT_OWN;\n\n#if NBPFILTER > 0\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, cur_tx->vr_mbuf);\n#endif\n\t\tVR_TXOWN(cur_tx) = VR_TXSTAT_OWN;\n\t\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_TX_ON|VR_CMD_TX_GO);\n\t}\n\n\t/*\n\t * If there are no frames queued, bail.\n\t */\n\tif (cur_tx == NULL)\n\t\treturn;\n\n\tsc->vr_cdata.vr_tx_tail = cur_tx;\n\n\tif (sc->vr_cdata.vr_tx_head == NULL)\n\t\tsc->vr_cdata.vr_tx_head = start_tx;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int vr_encap",
            "void vr_start"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint vr_encap;\nvoid vr_start;\n\nvoid\nvr_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct vr_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head = NULL;\n\tstruct vr_chain\t\t*cur_tx = NULL, *start_tx;\n\n\tsc = ifp->if_softc;\n\n\tif (sc->vr_autoneg) {\n\t\tsc->vr_tx_pend = 1;\n\t\treturn;\n\t}\n\n\t/*\n\t * Check for an available queue slot. If there are none,\n\t * punt.\n\t */\n\tif (sc->vr_cdata.vr_tx_free->vr_mbuf != NULL) {\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\n\tstart_tx = sc->vr_cdata.vr_tx_free;\n\n\twhile(sc->vr_cdata.vr_tx_free->vr_mbuf == NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\t/* Pick a descriptor off the free list. */\n\t\tcur_tx = sc->vr_cdata.vr_tx_free;\n\t\tsc->vr_cdata.vr_tx_free = cur_tx->vr_nextdesc;\n\n\t\t/* Pack the data into the descriptor. */\n\t\tvr_encap(sc, cur_tx, m_head);\n\n\t\tif (cur_tx != start_tx)\n\t\t\tVR_TXOWN(cur_tx) = VR_TXSTAT_OWN;\n\n#if NBPFILTER > 0\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, cur_tx->vr_mbuf);\n#endif\n\t\tVR_TXOWN(cur_tx) = VR_TXSTAT_OWN;\n\t\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_TX_ON|VR_CMD_TX_GO);\n\t}\n\n\t/*\n\t * If there are no frames queued, bail.\n\t */\n\tif (cur_tx == NULL)\n\t\treturn;\n\n\tsc->vr_cdata.vr_tx_tail = cur_tx;\n\n\tif (sc->vr_cdata.vr_tx_head == NULL)\n\t\tsc->vr_cdata.vr_tx_head = start_tx;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "VR_IMR",
            "VR_INTRS"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vr_init",
          "args": [
            "sc"
          ],
          "line": 1470
        },
        "resolved": true,
        "details": {
          "function_name": "vr_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "1630-1720",
          "snippet": "void\nvr_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct vr_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tu_int16_t\t\tphy_bmcr = 0;\n\tint\t\t\ts;\n\n\tif (sc->vr_autoneg)\n\t\treturn;\n\n\ts = splimp();\n\n\tif (sc->vr_pinfo != NULL)\n\t\tphy_bmcr = vr_phy_readreg(sc, PHY_BMCR);\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\tvr_stop(sc);\n\tvr_reset(sc);\n\n\tVR_CLRBIT(sc, VR_RXCFG, VR_RXCFG_RX_THRESH);\n\tVR_SETBIT(sc, VR_RXCFG, VR_RXTHRESH_STORENFWD);\n\n\tVR_CLRBIT(sc, VR_TXCFG, VR_TXCFG_TX_THRESH);\n\tVR_SETBIT(sc, VR_TXCFG, VR_TXTHRESH_STORENFWD);\n\n\t/* Init circular RX list. */\n\tif (vr_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: initialization failed: no memory for rx buffers\\n\",\n\t\t\t\t\t\t\tsc->sc_dev.dv_xname);\n\t\tvr_stop(sc);\n\t\t(void)splx(s);\n\t\treturn;\n\t}\n\n\t/*\n\t * Init tx descriptors.\n\t */\n\tvr_list_tx_init(sc);\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tVR_SETBIT(sc, VR_RXCFG, VR_RXCFG_RX_PROMISC);\n\telse\n\t\tVR_CLRBIT(sc, VR_RXCFG, VR_RXCFG_RX_PROMISC);\n\n\t/* Set capture broadcast bit to capture broadcast frames. */\n\tif (ifp->if_flags & IFF_BROADCAST)\n\t\tVR_SETBIT(sc, VR_RXCFG, VR_RXCFG_RX_BROAD);\n\telse\n\t\tVR_CLRBIT(sc, VR_RXCFG, VR_RXCFG_RX_BROAD);\n\n\t/*\n\t * Program the multicast filter, if necessary.\n\t */\n\tvr_setmulti(sc);\n\n\t/*\n\t * Load the address of the RX list.\n\t */\n\tCSR_WRITE_4(sc, VR_RXADDR, vtophys(sc->vr_cdata.vr_rx_head->vr_ptr));\n\n\t/* Enable receiver and transmitter. */\n\tCSR_WRITE_2(sc, VR_COMMAND, VR_CMD_TX_NOPOLL|VR_CMD_START|\n\t\t\t\t    VR_CMD_TX_ON|VR_CMD_RX_ON|\n\t\t\t\t    VR_CMD_RX_GO);\n\n\tvr_setcfg(sc, vr_phy_readreg(sc, PHY_BMCR));\n\n\tCSR_WRITE_4(sc, VR_TXADDR, vtophys(&sc->vr_ldata->vr_tx_list[0]));\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_2(sc, VR_ISR, 0xFFFF);\n\tCSR_WRITE_2(sc, VR_IMR, VR_INTRS);\n\n\t/* Restore state of BMCR */\n\tif (sc->vr_pinfo != NULL)\n\t\tvr_phy_writereg(sc, PHY_BMCR, phy_bmcr);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void vr_init",
            "void vr_stop",
            "u_int16_t vr_phy_readreg",
            "void vr_phy_writereg",
            "void vr_setcfg",
            "void vr_setmulti",
            "void vr_reset",
            "int vr_list_rx_init",
            "int vr_list_tx_init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_init;\nvoid vr_stop;\nu_int16_t vr_phy_readreg;\nvoid vr_phy_writereg;\nvoid vr_setcfg;\nvoid vr_setmulti;\nvoid vr_reset;\nint vr_list_rx_init;\nint vr_list_tx_init;\n\nvoid\nvr_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct vr_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tu_int16_t\t\tphy_bmcr = 0;\n\tint\t\t\ts;\n\n\tif (sc->vr_autoneg)\n\t\treturn;\n\n\ts = splimp();\n\n\tif (sc->vr_pinfo != NULL)\n\t\tphy_bmcr = vr_phy_readreg(sc, PHY_BMCR);\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\tvr_stop(sc);\n\tvr_reset(sc);\n\n\tVR_CLRBIT(sc, VR_RXCFG, VR_RXCFG_RX_THRESH);\n\tVR_SETBIT(sc, VR_RXCFG, VR_RXTHRESH_STORENFWD);\n\n\tVR_CLRBIT(sc, VR_TXCFG, VR_TXCFG_TX_THRESH);\n\tVR_SETBIT(sc, VR_TXCFG, VR_TXTHRESH_STORENFWD);\n\n\t/* Init circular RX list. */\n\tif (vr_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: initialization failed: no memory for rx buffers\\n\",\n\t\t\t\t\t\t\tsc->sc_dev.dv_xname);\n\t\tvr_stop(sc);\n\t\t(void)splx(s);\n\t\treturn;\n\t}\n\n\t/*\n\t * Init tx descriptors.\n\t */\n\tvr_list_tx_init(sc);\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tVR_SETBIT(sc, VR_RXCFG, VR_RXCFG_RX_PROMISC);\n\telse\n\t\tVR_CLRBIT(sc, VR_RXCFG, VR_RXCFG_RX_PROMISC);\n\n\t/* Set capture broadcast bit to capture broadcast frames. */\n\tif (ifp->if_flags & IFF_BROADCAST)\n\t\tVR_SETBIT(sc, VR_RXCFG, VR_RXCFG_RX_BROAD);\n\telse\n\t\tVR_CLRBIT(sc, VR_RXCFG, VR_RXCFG_RX_BROAD);\n\n\t/*\n\t * Program the multicast filter, if necessary.\n\t */\n\tvr_setmulti(sc);\n\n\t/*\n\t * Load the address of the RX list.\n\t */\n\tCSR_WRITE_4(sc, VR_RXADDR, vtophys(sc->vr_cdata.vr_rx_head->vr_ptr));\n\n\t/* Enable receiver and transmitter. */\n\tCSR_WRITE_2(sc, VR_COMMAND, VR_CMD_TX_NOPOLL|VR_CMD_START|\n\t\t\t\t    VR_CMD_TX_ON|VR_CMD_RX_ON|\n\t\t\t\t    VR_CMD_RX_GO);\n\n\tvr_setcfg(sc, vr_phy_readreg(sc, PHY_BMCR));\n\n\tCSR_WRITE_4(sc, VR_TXADDR, vtophys(&sc->vr_ldata->vr_tx_list[0]));\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_2(sc, VR_ISR, 0xFFFF);\n\tCSR_WRITE_2(sc, VR_IMR, VR_INTRS);\n\n\t/* Restore state of BMCR */\n\tif (sc->vr_pinfo != NULL)\n\t\tvr_phy_writereg(sc, PHY_BMCR, phy_bmcr);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vr_reset",
          "args": [
            "sc"
          ],
          "line": 1469
        },
        "resolved": true,
        "details": {
          "function_name": "vr_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "830-850",
          "snippet": "void\nvr_reset(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_RESET);\n\n\tfor (i = 0; i < VR_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(CSR_READ_2(sc, VR_COMMAND) & VR_CMD_RESET))\n\t\t\tbreak;\n\t}\n\tif (i == VR_TIMEOUT)\n\t\tprintf(\"%s: reset never completed!\\n\", sc->sc_dev.dv_xname);\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tDELAY(1000);\n\n        return;\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void vr_reset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_reset;\n\nvoid\nvr_reset(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_RESET);\n\n\tfor (i = 0; i < VR_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(CSR_READ_2(sc, VR_COMMAND) & VR_CMD_RESET))\n\t\t\tbreak;\n\t}\n\tif (i == VR_TIMEOUT)\n\t\tprintf(\"%s: reset never completed!\\n\", sc->sc_dev.dv_xname);\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tDELAY(1000);\n\n        return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VR_SETBIT16",
          "args": [
            "sc",
            "VR_COMMAND",
            "VR_CMD_TX_GO"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VR_SETBIT16",
          "args": [
            "sc",
            "VR_COMMAND",
            "VR_CMD_TX_ON"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vr_txeof",
          "args": [
            "sc"
          ],
          "line": 1461
        },
        "resolved": true,
        "details": {
          "function_name": "vr_txeof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "1333-1387",
          "snippet": "void\nvr_txeof(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tstruct vr_chain\t\t*cur_tx;\n\tstruct ifnet\t\t*ifp;\n\tregister struct mbuf\t*n;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Clear the timeout timer. */\n\tifp->if_timer = 0;\n\n\t/* Sanity check. */\n\tif (sc->vr_cdata.vr_tx_head == NULL)\n\t\treturn;\n\n\t/*\n\t * Go through our tx list and free mbufs for those\n\t * frames that have been transmitted.\n\t */\n\twhile(sc->vr_cdata.vr_tx_head->vr_mbuf != NULL) {\n\t\tu_int32_t\t\ttxstat;\n\n\t\tcur_tx = sc->vr_cdata.vr_tx_head;\n\t\ttxstat = cur_tx->vr_ptr->vr_status;\n\n\t\tif (txstat & VR_TXSTAT_OWN)\n\t\t\tbreak;\n\n\t\tif (txstat & VR_TXSTAT_ERRSUM) {\n\t\t\tifp->if_oerrors++;\n\t\t\tif (txstat & VR_TXSTAT_DEFER)\n\t\t\t\tifp->if_collisions++;\n\t\t\tif (txstat & VR_TXSTAT_LATECOLL)\n\t\t\t\tifp->if_collisions++;\n\t\t}\n\n\t\tifp->if_collisions +=(txstat & VR_TXSTAT_COLLCNT) >> 3;\n\n\t\tifp->if_opackets++;\n        \tMFREE(cur_tx->vr_mbuf, n);\n\t\tcur_tx->vr_mbuf = NULL;\n\n\t\tif (sc->vr_cdata.vr_tx_head == sc->vr_cdata.vr_tx_tail) {\n\t\t\tsc->vr_cdata.vr_tx_head = NULL;\n\t\t\tsc->vr_cdata.vr_tx_tail = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tsc->vr_cdata.vr_tx_head = cur_tx->vr_nextdesc;\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void vr_txeof"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_txeof;\n\nvoid\nvr_txeof(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tstruct vr_chain\t\t*cur_tx;\n\tstruct ifnet\t\t*ifp;\n\tregister struct mbuf\t*n;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Clear the timeout timer. */\n\tifp->if_timer = 0;\n\n\t/* Sanity check. */\n\tif (sc->vr_cdata.vr_tx_head == NULL)\n\t\treturn;\n\n\t/*\n\t * Go through our tx list and free mbufs for those\n\t * frames that have been transmitted.\n\t */\n\twhile(sc->vr_cdata.vr_tx_head->vr_mbuf != NULL) {\n\t\tu_int32_t\t\ttxstat;\n\n\t\tcur_tx = sc->vr_cdata.vr_tx_head;\n\t\ttxstat = cur_tx->vr_ptr->vr_status;\n\n\t\tif (txstat & VR_TXSTAT_OWN)\n\t\t\tbreak;\n\n\t\tif (txstat & VR_TXSTAT_ERRSUM) {\n\t\t\tifp->if_oerrors++;\n\t\t\tif (txstat & VR_TXSTAT_DEFER)\n\t\t\t\tifp->if_collisions++;\n\t\t\tif (txstat & VR_TXSTAT_LATECOLL)\n\t\t\t\tifp->if_collisions++;\n\t\t}\n\n\t\tifp->if_collisions +=(txstat & VR_TXSTAT_COLLCNT) >> 3;\n\n\t\tifp->if_opackets++;\n        \tMFREE(cur_tx->vr_mbuf, n);\n\t\tcur_tx->vr_mbuf = NULL;\n\n\t\tif (sc->vr_cdata.vr_tx_head == sc->vr_cdata.vr_tx_tail) {\n\t\t\tsc->vr_cdata.vr_tx_head = NULL;\n\t\t\tsc->vr_cdata.vr_tx_tail = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tsc->vr_cdata.vr_tx_head = cur_tx->vr_nextdesc;\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vr_txeoc",
          "args": [
            "sc"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "vr_txeoc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "1392-1410",
          "snippet": "void\nvr_txeoc(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tifp->if_timer = 0;\n\n\tif (sc->vr_cdata.vr_tx_head == NULL) {\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t\tsc->vr_cdata.vr_tx_tail = NULL;\n\t\tif (sc->vr_want_auto)\n\t\t\tvr_autoneg_mii(sc, VR_FLAG_SCHEDDELAY, 1);\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void vr_txeoc",
            "void vr_autoneg_mii"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_txeoc;\nvoid vr_autoneg_mii;\n\nvoid\nvr_txeoc(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tifp->if_timer = 0;\n\n\tif (sc->vr_cdata.vr_tx_head == NULL) {\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t\tsc->vr_cdata.vr_tx_tail = NULL;\n\t\tif (sc->vr_want_auto)\n\t\t\tvr_autoneg_mii(sc, VR_FLAG_SCHEDDELAY, 1);\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vr_rxeoc",
          "args": [
            "sc"
          ],
          "line": 1451
        },
        "resolved": true,
        "details": {
          "function_name": "vr_rxeoc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "1314-1326",
          "snippet": "void\nvr_rxeoc(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\n\tvr_rxeof(sc);\n\tVR_CLRBIT16(sc, VR_COMMAND, VR_CMD_RX_ON);\n\tCSR_WRITE_4(sc, VR_RXADDR, vtophys(sc->vr_cdata.vr_rx_head->vr_ptr));\n\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_RX_ON);\n\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_RX_GO);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void vr_rxeof",
            "void vr_rxeoc"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_rxeof;\nvoid vr_rxeoc;\n\nvoid\nvr_rxeoc(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\n\tvr_rxeof(sc);\n\tVR_CLRBIT16(sc, VR_COMMAND, VR_CMD_RX_ON);\n\tCSR_WRITE_4(sc, VR_RXADDR, vtophys(sc->vr_cdata.vr_rx_head->vr_ptr));\n\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_RX_ON);\n\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_RX_GO);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vr_rxeof",
          "args": [
            "sc"
          ],
          "line": 1450
        },
        "resolved": true,
        "details": {
          "function_name": "vr_rxeof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "1210-1312",
          "snippet": "void\nvr_rxeof(sc)\n\tstruct vr_softc\t\t*sc;\n{\n        struct ether_header\t*eh;\n        struct mbuf\t\t*m;\n        struct ifnet\t\t*ifp;\n\tstruct vr_chain_onefrag\t*cur_rx;\n\tint\t\t\ttotal_len = 0;\n\tu_int32_t\t\trxstat;\n\n\tifp = &sc->arpcom.ac_if;\n\n\twhile(!((rxstat = sc->vr_cdata.vr_rx_head->vr_ptr->vr_status) &\n\t\t\t\t\t\t\tVR_RXSTAT_OWN)) {\n\t\tcur_rx = sc->vr_cdata.vr_rx_head;\n\t\tsc->vr_cdata.vr_rx_head = cur_rx->vr_nextdesc;\n\n\t\t/*\n\t\t * If an error occurs, update stats, clear the\n\t\t * status word and leave the mbuf cluster in place:\n\t\t * it should simply get re-used next time this descriptor\n\t \t * comes up in the ring.\n\t\t */\n\t\tif (rxstat & VR_RXSTAT_RXERR) {\n\t\t\tifp->if_ierrors++;\n\t\t\tprintf(\"%s: rx error: \", sc->sc_dev.dv_xname);\n\t\t\tswitch(rxstat & 0x000000FF) {\n\t\t\tcase VR_RXSTAT_CRCERR:\n\t\t\t\tprintf(\"crc error\\n\");\n\t\t\t\tbreak;\n\t\t\tcase VR_RXSTAT_FRAMEALIGNERR:\n\t\t\t\tprintf(\"frame alignment error\\n\");\n\t\t\t\tbreak;\n\t\t\tcase VR_RXSTAT_FIFOOFLOW:\n\t\t\t\tprintf(\"FIFO overflow\\n\");\n\t\t\t\tbreak;\n\t\t\tcase VR_RXSTAT_GIANT:\n\t\t\t\tprintf(\"received giant packet\\n\");\n\t\t\t\tbreak;\n\t\t\tcase VR_RXSTAT_RUNT:\n\t\t\t\tprintf(\"received runt packet\\n\");\n\t\t\t\tbreak;\n\t\t\tcase VR_RXSTAT_BUSERR:\n\t\t\t\tprintf(\"system bus error\\n\");\n\t\t\t\tbreak;\n\t\t\tcase VR_RXSTAT_BUFFERR:\n\t\t\t\tprintf(\"rx buffer error\\n\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"unknown rx error\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcur_rx->vr_ptr->vr_status = VR_RXSTAT;\n\t\t\tcur_rx->vr_ptr->vr_ctl = VR_RXCTL|VR_RXLEN;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* No errors; receive the packet. */\t\n\t\tm = cur_rx->vr_mbuf;\n\t\ttotal_len = VR_RXBYTES(cur_rx->vr_ptr->vr_status);\n\n\t\t/*\n\t\t * XXX The VIA Rhine chip includes the CRC with every\n\t\t * received frame, and there's no way to turn this\n\t\t * behavior off (at least, I can't find anything in\n\t \t * the manual that explains how to do it) so we have\n\t\t * to trim off the CRC manually.\n\t\t */\n\t\ttotal_len -= ETHER_CRC_LEN;\n\n\t\t/*\n\t\t * Try to conjure up a new mbuf cluster. If that\n\t\t * fails, it means we have an out of memory condition and\n\t\t * should leave the buffer in place and continue. This will\n\t\t * result in a lost packet, but there's little else we\n\t\t * can do in this situation.\n\t\t */\n\t\tif (vr_newbuf(sc, cur_rx) == ENOBUFS) {\n\t\t\tifp->if_ierrors++;\n\t\t\tcur_rx->vr_ptr->vr_status = VR_RXSTAT;\n\t\t\tcur_rx->vr_ptr->vr_ctl = VR_RXCTL|VR_RXLEN;\n\t\t\tcontinue;\n\t\t}\n\n\t\tifp->if_ipackets++;\n\t\teh = mtod(m, struct ether_header *);\n\t\tm->m_pkthdr.rcvif = ifp;\n\t\tm->m_pkthdr.len = m->m_len = total_len;\n#if NBPFILTER > 0\n\t\t/*\n\t\t * Handle BPF listeners. Let the BPF user see the packet.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\t\t/* Remove header from mbuf and pass it on. */\n\t\tm_adj(m, sizeof(struct ether_header));\n\t\tether_input(ifp, eh, m);\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int vr_newbuf",
            "void vr_rxeof"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint vr_newbuf;\nvoid vr_rxeof;\n\nvoid\nvr_rxeof(sc)\n\tstruct vr_softc\t\t*sc;\n{\n        struct ether_header\t*eh;\n        struct mbuf\t\t*m;\n        struct ifnet\t\t*ifp;\n\tstruct vr_chain_onefrag\t*cur_rx;\n\tint\t\t\ttotal_len = 0;\n\tu_int32_t\t\trxstat;\n\n\tifp = &sc->arpcom.ac_if;\n\n\twhile(!((rxstat = sc->vr_cdata.vr_rx_head->vr_ptr->vr_status) &\n\t\t\t\t\t\t\tVR_RXSTAT_OWN)) {\n\t\tcur_rx = sc->vr_cdata.vr_rx_head;\n\t\tsc->vr_cdata.vr_rx_head = cur_rx->vr_nextdesc;\n\n\t\t/*\n\t\t * If an error occurs, update stats, clear the\n\t\t * status word and leave the mbuf cluster in place:\n\t\t * it should simply get re-used next time this descriptor\n\t \t * comes up in the ring.\n\t\t */\n\t\tif (rxstat & VR_RXSTAT_RXERR) {\n\t\t\tifp->if_ierrors++;\n\t\t\tprintf(\"%s: rx error: \", sc->sc_dev.dv_xname);\n\t\t\tswitch(rxstat & 0x000000FF) {\n\t\t\tcase VR_RXSTAT_CRCERR:\n\t\t\t\tprintf(\"crc error\\n\");\n\t\t\t\tbreak;\n\t\t\tcase VR_RXSTAT_FRAMEALIGNERR:\n\t\t\t\tprintf(\"frame alignment error\\n\");\n\t\t\t\tbreak;\n\t\t\tcase VR_RXSTAT_FIFOOFLOW:\n\t\t\t\tprintf(\"FIFO overflow\\n\");\n\t\t\t\tbreak;\n\t\t\tcase VR_RXSTAT_GIANT:\n\t\t\t\tprintf(\"received giant packet\\n\");\n\t\t\t\tbreak;\n\t\t\tcase VR_RXSTAT_RUNT:\n\t\t\t\tprintf(\"received runt packet\\n\");\n\t\t\t\tbreak;\n\t\t\tcase VR_RXSTAT_BUSERR:\n\t\t\t\tprintf(\"system bus error\\n\");\n\t\t\t\tbreak;\n\t\t\tcase VR_RXSTAT_BUFFERR:\n\t\t\t\tprintf(\"rx buffer error\\n\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"unknown rx error\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcur_rx->vr_ptr->vr_status = VR_RXSTAT;\n\t\t\tcur_rx->vr_ptr->vr_ctl = VR_RXCTL|VR_RXLEN;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* No errors; receive the packet. */\t\n\t\tm = cur_rx->vr_mbuf;\n\t\ttotal_len = VR_RXBYTES(cur_rx->vr_ptr->vr_status);\n\n\t\t/*\n\t\t * XXX The VIA Rhine chip includes the CRC with every\n\t\t * received frame, and there's no way to turn this\n\t\t * behavior off (at least, I can't find anything in\n\t \t * the manual that explains how to do it) so we have\n\t\t * to trim off the CRC manually.\n\t\t */\n\t\ttotal_len -= ETHER_CRC_LEN;\n\n\t\t/*\n\t\t * Try to conjure up a new mbuf cluster. If that\n\t\t * fails, it means we have an out of memory condition and\n\t\t * should leave the buffer in place and continue. This will\n\t\t * result in a lost packet, but there's little else we\n\t\t * can do in this situation.\n\t\t */\n\t\tif (vr_newbuf(sc, cur_rx) == ENOBUFS) {\n\t\t\tifp->if_ierrors++;\n\t\t\tcur_rx->vr_ptr->vr_status = VR_RXSTAT;\n\t\t\tcur_rx->vr_ptr->vr_ctl = VR_RXCTL|VR_RXLEN;\n\t\t\tcontinue;\n\t\t}\n\n\t\tifp->if_ipackets++;\n\t\teh = mtod(m, struct ether_header *);\n\t\tm->m_pkthdr.rcvif = ifp;\n\t\tm->m_pkthdr.len = m->m_len = total_len;\n#if NBPFILTER > 0\n\t\t/*\n\t\t * Handle BPF listeners. Let the BPF user see the packet.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\t\t/* Remove header from mbuf and pass it on. */\n\t\tm_adj(m, sizeof(struct ether_header));\n\t\tether_input(ifp, eh, m);\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "VR_ISR",
            "status"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "VR_ISR"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "VR_IMR",
            "0x0000"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vr_stop",
          "args": [
            "sc"
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "vr_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "1900-1944",
          "snippet": "void\nvr_stop(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_timer = 0;\n\n\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_STOP);\n\tVR_CLRBIT16(sc, VR_COMMAND, (VR_CMD_RX_ON|VR_CMD_TX_ON));\n\tCSR_WRITE_2(sc, VR_IMR, 0x0000);\n\tCSR_WRITE_4(sc, VR_TXADDR, 0x00000000);\n\tCSR_WRITE_4(sc, VR_RXADDR, 0x00000000);\n\n\t/*\n\t * Free data in the RX lists.\n\t */\n\tfor (i = 0; i < VR_RX_LIST_CNT; i++) {\n\t\tif (sc->vr_cdata.vr_rx_chain[i].vr_mbuf != NULL) {\n\t\t\tm_freem(sc->vr_cdata.vr_rx_chain[i].vr_mbuf);\n\t\t\tsc->vr_cdata.vr_rx_chain[i].vr_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->vr_ldata->vr_rx_list,\n\t\tsizeof(sc->vr_ldata->vr_rx_list));\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < VR_TX_LIST_CNT; i++) {\n\t\tif (sc->vr_cdata.vr_tx_chain[i].vr_mbuf != NULL) {\n\t\t\tm_freem(sc->vr_cdata.vr_tx_chain[i].vr_mbuf);\n\t\t\tsc->vr_cdata.vr_tx_chain[i].vr_mbuf = NULL;\n\t\t}\n\t}\n\n\tbzero((char *)&sc->vr_ldata->vr_tx_list,\n\t\tsizeof(sc->vr_ldata->vr_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void vr_stop"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_stop;\n\nvoid\nvr_stop(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_timer = 0;\n\n\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_STOP);\n\tVR_CLRBIT16(sc, VR_COMMAND, (VR_CMD_RX_ON|VR_CMD_TX_ON));\n\tCSR_WRITE_2(sc, VR_IMR, 0x0000);\n\tCSR_WRITE_4(sc, VR_TXADDR, 0x00000000);\n\tCSR_WRITE_4(sc, VR_RXADDR, 0x00000000);\n\n\t/*\n\t * Free data in the RX lists.\n\t */\n\tfor (i = 0; i < VR_RX_LIST_CNT; i++) {\n\t\tif (sc->vr_cdata.vr_rx_chain[i].vr_mbuf != NULL) {\n\t\t\tm_freem(sc->vr_cdata.vr_rx_chain[i].vr_mbuf);\n\t\t\tsc->vr_cdata.vr_rx_chain[i].vr_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->vr_ldata->vr_rx_list,\n\t\tsizeof(sc->vr_ldata->vr_rx_list));\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < VR_TX_LIST_CNT; i++) {\n\t\tif (sc->vr_cdata.vr_tx_chain[i].vr_mbuf != NULL) {\n\t\t\tm_freem(sc->vr_cdata.vr_tx_chain[i].vr_mbuf);\n\t\t\tsc->vr_cdata.vr_tx_chain[i].vr_mbuf = NULL;\n\t\t}\n\t}\n\n\tbzero((char *)&sc->vr_ldata->vr_tx_list,\n\t\tsizeof(sc->vr_ldata->vr_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_rxeof;\nvoid vr_rxeoc;\nvoid vr_txeof;\nvoid vr_txeoc;\nint vr_intr;\nvoid vr_start;\nvoid vr_init;\nvoid vr_stop;\nvoid vr_reset;\n\nint\nvr_intr(arg)\n\tvoid\t\t\t*arg;\n{\n\tstruct vr_softc\t\t*sc;\n\tstruct ifnet\t\t*ifp;\n\tu_int16_t\t\tstatus;\n\tint claimed = 0;\n\n\tsc = arg;\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Supress unwanted interrupts. */\n\tif (!(ifp->if_flags & IFF_UP)) {\n\t\tvr_stop(sc);\n\t\treturn 0;\n\t}\n\n\t/* Disable interrupts. */\n\tCSR_WRITE_2(sc, VR_IMR, 0x0000);\n\n\tfor (;;) {\n\n\t\tstatus = CSR_READ_2(sc, VR_ISR);\n\t\tif (status)\n\t\t\tCSR_WRITE_2(sc, VR_ISR, status);\n\n\t\tif ((status & VR_INTRS) == 0)\n\t\t\tbreak;\n\n\t\tclaimed = 1;\n\n\t\tif (status & VR_ISR_RX_OK)\n\t\t\tvr_rxeof(sc);\n\n\t\tif ((status & VR_ISR_RX_ERR) || (status & VR_ISR_RX_NOBUF) ||\n\t\t    (status & VR_ISR_RX_NOBUF) || (status & VR_ISR_RX_OFLOW) ||\n\t\t    (status & VR_ISR_RX_DROPPED)) {\n\t\t\tvr_rxeof(sc);\n\t\t\tvr_rxeoc(sc);\n\t\t}\n\n\t\tif (status & VR_ISR_TX_OK) {\n\t\t\tvr_txeof(sc);\n\t\t\tvr_txeoc(sc);\n\t\t}\n\n\t\tif ((status & VR_ISR_TX_UNDERRUN)||(status & VR_ISR_TX_ABRT)){ \n\t\t\tifp->if_oerrors++;\n\t\t\tvr_txeof(sc);\n\t\t\tif (sc->vr_cdata.vr_tx_head != NULL) {\n\t\t\t\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_TX_ON);\n\t\t\t\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_TX_GO);\n\t\t\t}\n\t\t}\n\n\t\tif (status & VR_ISR_BUSERR) {\n\t\t\tvr_reset(sc);\n\t\t\tvr_init(sc);\n\t\t}\n\t}\n\n\t/* Re-enable interrupts. */\n\tCSR_WRITE_2(sc, VR_IMR, VR_INTRS);\n\n\tif (ifp->if_snd.ifq_head != NULL) {\n\t\tvr_start(ifp);\n\t}\n\n\treturn (claimed);\n}"
  },
  {
    "function_name": "vr_txeoc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
    "lines": "1392-1410",
    "snippet": "void\nvr_txeoc(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tifp->if_timer = 0;\n\n\tif (sc->vr_cdata.vr_tx_head == NULL) {\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t\tsc->vr_cdata.vr_tx_tail = NULL;\n\t\tif (sc->vr_want_auto)\n\t\t\tvr_autoneg_mii(sc, VR_FLAG_SCHEDDELAY, 1);\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_vrreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/device.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void vr_txeoc",
      "void vr_autoneg_mii"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vr_autoneg_mii",
          "args": [
            "sc",
            "VR_FLAG_SCHEDDELAY",
            "1"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "vr_autoneg_mii",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "535-679",
          "snippet": "void\nvr_autoneg_mii(sc, flag, verbose)\n\tstruct vr_softc\t\t*sc;\n\tint\t\t\tflag;\n\tint\t\t\tverbose;\n{\n\tu_int16_t\t\tphy_sts = 0, media, advert, ability;\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmedia\t\t*ifm;\n\n\tifm = &sc->ifmedia;\n\tifp = &sc->arpcom.ac_if;\n\n\tifm->ifm_media = IFM_ETHER | IFM_AUTO;\n\n\t/*\n\t * The 100baseT4 PHY on the 3c905-T4 has the 'autoneg supported'\n\t * bit cleared in the status register, but has the 'autoneg enabled'\n\t * bit set in the control register. This is a contradiction, and\n\t * I'm not sure how to handle it. If you want to force an attempt\n\t * to autoneg for 100baseT4 PHYs, #define FORCE_AUTONEG_TFOUR\n\t * and see what happens.\n\t */\n#ifndef FORCE_AUTONEG_TFOUR\n\t/*\n\t * First, see if autoneg is supported. If not, there's\n\t * no point in continuing.\n\t */\n\tphy_sts = vr_phy_readreg(sc, PHY_BMSR);\n\tif (!(phy_sts & PHY_BMSR_CANAUTONEG)) {\n\t\tif (verbose)\n\t\t\tprintf(\"%s: autonegotiation not supported\\n\",\n\t\t\t\t\t\t\tsc->sc_dev.dv_xname);\n\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;\t\n\t\treturn;\n\t}\n#endif\n\n\tswitch (flag) {\n\tcase VR_FLAG_FORCEDELAY:\n\t\t/*\n\t \t * XXX Never use this option anywhere but in the probe\n\t \t * routine: making the kernel stop dead in its tracks\n \t\t * for three whole seconds after we've gone multi-user\n\t\t * is really bad manners.\n\t \t */\n\t\tvr_autoneg_xmit(sc);\n\t\tDELAY(5000000);\n\t\tbreak;\n\tcase VR_FLAG_SCHEDDELAY:\n\t\t/*\n\t\t * Wait for the transmitter to go idle before starting\n\t\t * an autoneg session, otherwise vr_start() may clobber\n\t \t * our timeout, and we don't want to allow transmission\n\t\t * during an autoneg session since that can screw it up.\n\t \t */\n\t\tif (sc->vr_cdata.vr_tx_head != NULL) {\n\t\t\tsc->vr_want_auto = 1;\n\t\t\treturn;\n\t\t}\n\t\tvr_autoneg_xmit(sc);\n\t\tifp->if_timer = 5;\n\t\tsc->vr_autoneg = 1;\n\t\tsc->vr_want_auto = 0;\n\t\treturn;\n\t\tbreak;\n\tcase VR_FLAG_DELAYTIMEO:\n\t\tifp->if_timer = 0;\n\t\tsc->vr_autoneg = 0;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: invalid autoneg flag: %d\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname, flag);\n\t\treturn;\n\t}\n\n\tif (vr_phy_readreg(sc, PHY_BMSR) & PHY_BMSR_AUTONEGCOMP) {\n\t\tif (verbose)\n\t\t\tprintf(\"%s: autoneg complete, \", sc->sc_dev.dv_xname);\n\t\tphy_sts = vr_phy_readreg(sc, PHY_BMSR);\n\t} else {\n\t\tif (verbose)\n\t\t\tprintf(\"%s: autoneg not complete, \",\n\t\t\t\t\t\tsc->sc_dev.dv_xname);\n\t}\n\n\tmedia = vr_phy_readreg(sc, PHY_BMCR);\n\n\t/* Link is good. Report modes and set duplex mode. */\n\tif (vr_phy_readreg(sc, PHY_BMSR) & PHY_BMSR_LINKSTAT) {\n\t\tif (verbose)\n\t\t\tprintf(\"link status good \");\n\t\tadvert = vr_phy_readreg(sc, PHY_ANAR);\n\t\tability = vr_phy_readreg(sc, PHY_LPAR);\n\n\t\tif (advert & PHY_ANAR_100BT4 && ability & PHY_ANAR_100BT4) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_T4;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(100baseT4)\\n\");\n\t\t} else if (advert & PHY_ANAR_100BTXFULL &&\n\t\t\tability & PHY_ANAR_100BTXFULL) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_FDX;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia |= PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(full-duplex, 100Mbps)\\n\");\n\t\t} else if (advert & PHY_ANAR_100BTXHALF &&\n\t\t\tability & PHY_ANAR_100BTXHALF) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_HDX;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(half-duplex, 100Mbps)\\n\");\n\t\t} else if (advert & PHY_ANAR_10BTFULL &&\n\t\t\tability & PHY_ANAR_10BTFULL) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_FDX;\n\t\t\tmedia &= ~PHY_BMCR_SPEEDSEL;\n\t\t\tmedia |= PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(full-duplex, 10Mbps)\\n\");\n\t\t} else {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;\n\t\t\tmedia &= ~PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(half-duplex, 10Mbps)\\n\");\n\t\t}\n\n\t\tmedia &= ~PHY_BMCR_AUTONEGENBL;\n\n\t\t/* Set ASIC's duplex mode to match the PHY. */\n\t\tvr_setcfg(sc, media);\n\t\tvr_phy_writereg(sc, PHY_BMCR, media);\n\t} else {\n\t\tif (verbose)\n\t\t\tprintf(\"no carrier\\n\");\n\t}\n\n\tvr_init(sc);\n\n\tif (sc->vr_tx_pend) {\n\t\tsc->vr_autoneg = 0;\n\t\tsc->vr_tx_pend = 0;\n\t\tvr_start(ifp);\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void vr_start",
            "void vr_init",
            "u_int16_t vr_phy_readreg",
            "void vr_phy_writereg",
            "void vr_autoneg_xmit",
            "void vr_autoneg_mii",
            "void vr_setcfg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_start;\nvoid vr_init;\nu_int16_t vr_phy_readreg;\nvoid vr_phy_writereg;\nvoid vr_autoneg_xmit;\nvoid vr_autoneg_mii;\nvoid vr_setcfg;\n\nvoid\nvr_autoneg_mii(sc, flag, verbose)\n\tstruct vr_softc\t\t*sc;\n\tint\t\t\tflag;\n\tint\t\t\tverbose;\n{\n\tu_int16_t\t\tphy_sts = 0, media, advert, ability;\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmedia\t\t*ifm;\n\n\tifm = &sc->ifmedia;\n\tifp = &sc->arpcom.ac_if;\n\n\tifm->ifm_media = IFM_ETHER | IFM_AUTO;\n\n\t/*\n\t * The 100baseT4 PHY on the 3c905-T4 has the 'autoneg supported'\n\t * bit cleared in the status register, but has the 'autoneg enabled'\n\t * bit set in the control register. This is a contradiction, and\n\t * I'm not sure how to handle it. If you want to force an attempt\n\t * to autoneg for 100baseT4 PHYs, #define FORCE_AUTONEG_TFOUR\n\t * and see what happens.\n\t */\n#ifndef FORCE_AUTONEG_TFOUR\n\t/*\n\t * First, see if autoneg is supported. If not, there's\n\t * no point in continuing.\n\t */\n\tphy_sts = vr_phy_readreg(sc, PHY_BMSR);\n\tif (!(phy_sts & PHY_BMSR_CANAUTONEG)) {\n\t\tif (verbose)\n\t\t\tprintf(\"%s: autonegotiation not supported\\n\",\n\t\t\t\t\t\t\tsc->sc_dev.dv_xname);\n\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;\t\n\t\treturn;\n\t}\n#endif\n\n\tswitch (flag) {\n\tcase VR_FLAG_FORCEDELAY:\n\t\t/*\n\t \t * XXX Never use this option anywhere but in the probe\n\t \t * routine: making the kernel stop dead in its tracks\n \t\t * for three whole seconds after we've gone multi-user\n\t\t * is really bad manners.\n\t \t */\n\t\tvr_autoneg_xmit(sc);\n\t\tDELAY(5000000);\n\t\tbreak;\n\tcase VR_FLAG_SCHEDDELAY:\n\t\t/*\n\t\t * Wait for the transmitter to go idle before starting\n\t\t * an autoneg session, otherwise vr_start() may clobber\n\t \t * our timeout, and we don't want to allow transmission\n\t\t * during an autoneg session since that can screw it up.\n\t \t */\n\t\tif (sc->vr_cdata.vr_tx_head != NULL) {\n\t\t\tsc->vr_want_auto = 1;\n\t\t\treturn;\n\t\t}\n\t\tvr_autoneg_xmit(sc);\n\t\tifp->if_timer = 5;\n\t\tsc->vr_autoneg = 1;\n\t\tsc->vr_want_auto = 0;\n\t\treturn;\n\t\tbreak;\n\tcase VR_FLAG_DELAYTIMEO:\n\t\tifp->if_timer = 0;\n\t\tsc->vr_autoneg = 0;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: invalid autoneg flag: %d\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname, flag);\n\t\treturn;\n\t}\n\n\tif (vr_phy_readreg(sc, PHY_BMSR) & PHY_BMSR_AUTONEGCOMP) {\n\t\tif (verbose)\n\t\t\tprintf(\"%s: autoneg complete, \", sc->sc_dev.dv_xname);\n\t\tphy_sts = vr_phy_readreg(sc, PHY_BMSR);\n\t} else {\n\t\tif (verbose)\n\t\t\tprintf(\"%s: autoneg not complete, \",\n\t\t\t\t\t\tsc->sc_dev.dv_xname);\n\t}\n\n\tmedia = vr_phy_readreg(sc, PHY_BMCR);\n\n\t/* Link is good. Report modes and set duplex mode. */\n\tif (vr_phy_readreg(sc, PHY_BMSR) & PHY_BMSR_LINKSTAT) {\n\t\tif (verbose)\n\t\t\tprintf(\"link status good \");\n\t\tadvert = vr_phy_readreg(sc, PHY_ANAR);\n\t\tability = vr_phy_readreg(sc, PHY_LPAR);\n\n\t\tif (advert & PHY_ANAR_100BT4 && ability & PHY_ANAR_100BT4) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_T4;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(100baseT4)\\n\");\n\t\t} else if (advert & PHY_ANAR_100BTXFULL &&\n\t\t\tability & PHY_ANAR_100BTXFULL) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_FDX;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia |= PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(full-duplex, 100Mbps)\\n\");\n\t\t} else if (advert & PHY_ANAR_100BTXHALF &&\n\t\t\tability & PHY_ANAR_100BTXHALF) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_HDX;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(half-duplex, 100Mbps)\\n\");\n\t\t} else if (advert & PHY_ANAR_10BTFULL &&\n\t\t\tability & PHY_ANAR_10BTFULL) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_FDX;\n\t\t\tmedia &= ~PHY_BMCR_SPEEDSEL;\n\t\t\tmedia |= PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(full-duplex, 10Mbps)\\n\");\n\t\t} else {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;\n\t\t\tmedia &= ~PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(half-duplex, 10Mbps)\\n\");\n\t\t}\n\n\t\tmedia &= ~PHY_BMCR_AUTONEGENBL;\n\n\t\t/* Set ASIC's duplex mode to match the PHY. */\n\t\tvr_setcfg(sc, media);\n\t\tvr_phy_writereg(sc, PHY_BMCR, media);\n\t} else {\n\t\tif (verbose)\n\t\t\tprintf(\"no carrier\\n\");\n\t}\n\n\tvr_init(sc);\n\n\tif (sc->vr_tx_pend) {\n\t\tsc->vr_autoneg = 0;\n\t\tsc->vr_tx_pend = 0;\n\t\tvr_start(ifp);\n\t}\n\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_txeoc;\nvoid vr_autoneg_mii;\n\nvoid\nvr_txeoc(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tifp->if_timer = 0;\n\n\tif (sc->vr_cdata.vr_tx_head == NULL) {\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t\tsc->vr_cdata.vr_tx_tail = NULL;\n\t\tif (sc->vr_want_auto)\n\t\t\tvr_autoneg_mii(sc, VR_FLAG_SCHEDDELAY, 1);\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "vr_txeof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
    "lines": "1333-1387",
    "snippet": "void\nvr_txeof(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tstruct vr_chain\t\t*cur_tx;\n\tstruct ifnet\t\t*ifp;\n\tregister struct mbuf\t*n;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Clear the timeout timer. */\n\tifp->if_timer = 0;\n\n\t/* Sanity check. */\n\tif (sc->vr_cdata.vr_tx_head == NULL)\n\t\treturn;\n\n\t/*\n\t * Go through our tx list and free mbufs for those\n\t * frames that have been transmitted.\n\t */\n\twhile(sc->vr_cdata.vr_tx_head->vr_mbuf != NULL) {\n\t\tu_int32_t\t\ttxstat;\n\n\t\tcur_tx = sc->vr_cdata.vr_tx_head;\n\t\ttxstat = cur_tx->vr_ptr->vr_status;\n\n\t\tif (txstat & VR_TXSTAT_OWN)\n\t\t\tbreak;\n\n\t\tif (txstat & VR_TXSTAT_ERRSUM) {\n\t\t\tifp->if_oerrors++;\n\t\t\tif (txstat & VR_TXSTAT_DEFER)\n\t\t\t\tifp->if_collisions++;\n\t\t\tif (txstat & VR_TXSTAT_LATECOLL)\n\t\t\t\tifp->if_collisions++;\n\t\t}\n\n\t\tifp->if_collisions +=(txstat & VR_TXSTAT_COLLCNT) >> 3;\n\n\t\tifp->if_opackets++;\n        \tMFREE(cur_tx->vr_mbuf, n);\n\t\tcur_tx->vr_mbuf = NULL;\n\n\t\tif (sc->vr_cdata.vr_tx_head == sc->vr_cdata.vr_tx_tail) {\n\t\t\tsc->vr_cdata.vr_tx_head = NULL;\n\t\t\tsc->vr_cdata.vr_tx_tail = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tsc->vr_cdata.vr_tx_head = cur_tx->vr_nextdesc;\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_vrreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/device.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void vr_txeof"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MFREE",
          "args": [
            "cur_tx->vr_mbuf",
            "n"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_txeof;\n\nvoid\nvr_txeof(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tstruct vr_chain\t\t*cur_tx;\n\tstruct ifnet\t\t*ifp;\n\tregister struct mbuf\t*n;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/* Clear the timeout timer. */\n\tifp->if_timer = 0;\n\n\t/* Sanity check. */\n\tif (sc->vr_cdata.vr_tx_head == NULL)\n\t\treturn;\n\n\t/*\n\t * Go through our tx list and free mbufs for those\n\t * frames that have been transmitted.\n\t */\n\twhile(sc->vr_cdata.vr_tx_head->vr_mbuf != NULL) {\n\t\tu_int32_t\t\ttxstat;\n\n\t\tcur_tx = sc->vr_cdata.vr_tx_head;\n\t\ttxstat = cur_tx->vr_ptr->vr_status;\n\n\t\tif (txstat & VR_TXSTAT_OWN)\n\t\t\tbreak;\n\n\t\tif (txstat & VR_TXSTAT_ERRSUM) {\n\t\t\tifp->if_oerrors++;\n\t\t\tif (txstat & VR_TXSTAT_DEFER)\n\t\t\t\tifp->if_collisions++;\n\t\t\tif (txstat & VR_TXSTAT_LATECOLL)\n\t\t\t\tifp->if_collisions++;\n\t\t}\n\n\t\tifp->if_collisions +=(txstat & VR_TXSTAT_COLLCNT) >> 3;\n\n\t\tifp->if_opackets++;\n        \tMFREE(cur_tx->vr_mbuf, n);\n\t\tcur_tx->vr_mbuf = NULL;\n\n\t\tif (sc->vr_cdata.vr_tx_head == sc->vr_cdata.vr_tx_tail) {\n\t\t\tsc->vr_cdata.vr_tx_head = NULL;\n\t\t\tsc->vr_cdata.vr_tx_tail = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tsc->vr_cdata.vr_tx_head = cur_tx->vr_nextdesc;\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "vr_rxeoc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
    "lines": "1314-1326",
    "snippet": "void\nvr_rxeoc(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\n\tvr_rxeof(sc);\n\tVR_CLRBIT16(sc, VR_COMMAND, VR_CMD_RX_ON);\n\tCSR_WRITE_4(sc, VR_RXADDR, vtophys(sc->vr_cdata.vr_rx_head->vr_ptr));\n\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_RX_ON);\n\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_RX_GO);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_vrreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/device.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void vr_rxeof",
      "void vr_rxeoc"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VR_SETBIT16",
          "args": [
            "sc",
            "VR_COMMAND",
            "VR_CMD_RX_GO"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VR_SETBIT16",
          "args": [
            "sc",
            "VR_COMMAND",
            "VR_CMD_RX_ON"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "VR_RXADDR",
            "vtophys(sc->vr_cdata.vr_rx_head->vr_ptr)"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "sc->vr_cdata.vr_rx_head->vr_ptr"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VR_CLRBIT16",
          "args": [
            "sc",
            "VR_COMMAND",
            "VR_CMD_RX_ON"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vr_rxeof",
          "args": [
            "sc"
          ],
          "line": 1319
        },
        "resolved": true,
        "details": {
          "function_name": "vr_rxeof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "1210-1312",
          "snippet": "void\nvr_rxeof(sc)\n\tstruct vr_softc\t\t*sc;\n{\n        struct ether_header\t*eh;\n        struct mbuf\t\t*m;\n        struct ifnet\t\t*ifp;\n\tstruct vr_chain_onefrag\t*cur_rx;\n\tint\t\t\ttotal_len = 0;\n\tu_int32_t\t\trxstat;\n\n\tifp = &sc->arpcom.ac_if;\n\n\twhile(!((rxstat = sc->vr_cdata.vr_rx_head->vr_ptr->vr_status) &\n\t\t\t\t\t\t\tVR_RXSTAT_OWN)) {\n\t\tcur_rx = sc->vr_cdata.vr_rx_head;\n\t\tsc->vr_cdata.vr_rx_head = cur_rx->vr_nextdesc;\n\n\t\t/*\n\t\t * If an error occurs, update stats, clear the\n\t\t * status word and leave the mbuf cluster in place:\n\t\t * it should simply get re-used next time this descriptor\n\t \t * comes up in the ring.\n\t\t */\n\t\tif (rxstat & VR_RXSTAT_RXERR) {\n\t\t\tifp->if_ierrors++;\n\t\t\tprintf(\"%s: rx error: \", sc->sc_dev.dv_xname);\n\t\t\tswitch(rxstat & 0x000000FF) {\n\t\t\tcase VR_RXSTAT_CRCERR:\n\t\t\t\tprintf(\"crc error\\n\");\n\t\t\t\tbreak;\n\t\t\tcase VR_RXSTAT_FRAMEALIGNERR:\n\t\t\t\tprintf(\"frame alignment error\\n\");\n\t\t\t\tbreak;\n\t\t\tcase VR_RXSTAT_FIFOOFLOW:\n\t\t\t\tprintf(\"FIFO overflow\\n\");\n\t\t\t\tbreak;\n\t\t\tcase VR_RXSTAT_GIANT:\n\t\t\t\tprintf(\"received giant packet\\n\");\n\t\t\t\tbreak;\n\t\t\tcase VR_RXSTAT_RUNT:\n\t\t\t\tprintf(\"received runt packet\\n\");\n\t\t\t\tbreak;\n\t\t\tcase VR_RXSTAT_BUSERR:\n\t\t\t\tprintf(\"system bus error\\n\");\n\t\t\t\tbreak;\n\t\t\tcase VR_RXSTAT_BUFFERR:\n\t\t\t\tprintf(\"rx buffer error\\n\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"unknown rx error\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcur_rx->vr_ptr->vr_status = VR_RXSTAT;\n\t\t\tcur_rx->vr_ptr->vr_ctl = VR_RXCTL|VR_RXLEN;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* No errors; receive the packet. */\t\n\t\tm = cur_rx->vr_mbuf;\n\t\ttotal_len = VR_RXBYTES(cur_rx->vr_ptr->vr_status);\n\n\t\t/*\n\t\t * XXX The VIA Rhine chip includes the CRC with every\n\t\t * received frame, and there's no way to turn this\n\t\t * behavior off (at least, I can't find anything in\n\t \t * the manual that explains how to do it) so we have\n\t\t * to trim off the CRC manually.\n\t\t */\n\t\ttotal_len -= ETHER_CRC_LEN;\n\n\t\t/*\n\t\t * Try to conjure up a new mbuf cluster. If that\n\t\t * fails, it means we have an out of memory condition and\n\t\t * should leave the buffer in place and continue. This will\n\t\t * result in a lost packet, but there's little else we\n\t\t * can do in this situation.\n\t\t */\n\t\tif (vr_newbuf(sc, cur_rx) == ENOBUFS) {\n\t\t\tifp->if_ierrors++;\n\t\t\tcur_rx->vr_ptr->vr_status = VR_RXSTAT;\n\t\t\tcur_rx->vr_ptr->vr_ctl = VR_RXCTL|VR_RXLEN;\n\t\t\tcontinue;\n\t\t}\n\n\t\tifp->if_ipackets++;\n\t\teh = mtod(m, struct ether_header *);\n\t\tm->m_pkthdr.rcvif = ifp;\n\t\tm->m_pkthdr.len = m->m_len = total_len;\n#if NBPFILTER > 0\n\t\t/*\n\t\t * Handle BPF listeners. Let the BPF user see the packet.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\t\t/* Remove header from mbuf and pass it on. */\n\t\tm_adj(m, sizeof(struct ether_header));\n\t\tether_input(ifp, eh, m);\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int vr_newbuf",
            "void vr_rxeof"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint vr_newbuf;\nvoid vr_rxeof;\n\nvoid\nvr_rxeof(sc)\n\tstruct vr_softc\t\t*sc;\n{\n        struct ether_header\t*eh;\n        struct mbuf\t\t*m;\n        struct ifnet\t\t*ifp;\n\tstruct vr_chain_onefrag\t*cur_rx;\n\tint\t\t\ttotal_len = 0;\n\tu_int32_t\t\trxstat;\n\n\tifp = &sc->arpcom.ac_if;\n\n\twhile(!((rxstat = sc->vr_cdata.vr_rx_head->vr_ptr->vr_status) &\n\t\t\t\t\t\t\tVR_RXSTAT_OWN)) {\n\t\tcur_rx = sc->vr_cdata.vr_rx_head;\n\t\tsc->vr_cdata.vr_rx_head = cur_rx->vr_nextdesc;\n\n\t\t/*\n\t\t * If an error occurs, update stats, clear the\n\t\t * status word and leave the mbuf cluster in place:\n\t\t * it should simply get re-used next time this descriptor\n\t \t * comes up in the ring.\n\t\t */\n\t\tif (rxstat & VR_RXSTAT_RXERR) {\n\t\t\tifp->if_ierrors++;\n\t\t\tprintf(\"%s: rx error: \", sc->sc_dev.dv_xname);\n\t\t\tswitch(rxstat & 0x000000FF) {\n\t\t\tcase VR_RXSTAT_CRCERR:\n\t\t\t\tprintf(\"crc error\\n\");\n\t\t\t\tbreak;\n\t\t\tcase VR_RXSTAT_FRAMEALIGNERR:\n\t\t\t\tprintf(\"frame alignment error\\n\");\n\t\t\t\tbreak;\n\t\t\tcase VR_RXSTAT_FIFOOFLOW:\n\t\t\t\tprintf(\"FIFO overflow\\n\");\n\t\t\t\tbreak;\n\t\t\tcase VR_RXSTAT_GIANT:\n\t\t\t\tprintf(\"received giant packet\\n\");\n\t\t\t\tbreak;\n\t\t\tcase VR_RXSTAT_RUNT:\n\t\t\t\tprintf(\"received runt packet\\n\");\n\t\t\t\tbreak;\n\t\t\tcase VR_RXSTAT_BUSERR:\n\t\t\t\tprintf(\"system bus error\\n\");\n\t\t\t\tbreak;\n\t\t\tcase VR_RXSTAT_BUFFERR:\n\t\t\t\tprintf(\"rx buffer error\\n\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"unknown rx error\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcur_rx->vr_ptr->vr_status = VR_RXSTAT;\n\t\t\tcur_rx->vr_ptr->vr_ctl = VR_RXCTL|VR_RXLEN;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* No errors; receive the packet. */\t\n\t\tm = cur_rx->vr_mbuf;\n\t\ttotal_len = VR_RXBYTES(cur_rx->vr_ptr->vr_status);\n\n\t\t/*\n\t\t * XXX The VIA Rhine chip includes the CRC with every\n\t\t * received frame, and there's no way to turn this\n\t\t * behavior off (at least, I can't find anything in\n\t \t * the manual that explains how to do it) so we have\n\t\t * to trim off the CRC manually.\n\t\t */\n\t\ttotal_len -= ETHER_CRC_LEN;\n\n\t\t/*\n\t\t * Try to conjure up a new mbuf cluster. If that\n\t\t * fails, it means we have an out of memory condition and\n\t\t * should leave the buffer in place and continue. This will\n\t\t * result in a lost packet, but there's little else we\n\t\t * can do in this situation.\n\t\t */\n\t\tif (vr_newbuf(sc, cur_rx) == ENOBUFS) {\n\t\t\tifp->if_ierrors++;\n\t\t\tcur_rx->vr_ptr->vr_status = VR_RXSTAT;\n\t\t\tcur_rx->vr_ptr->vr_ctl = VR_RXCTL|VR_RXLEN;\n\t\t\tcontinue;\n\t\t}\n\n\t\tifp->if_ipackets++;\n\t\teh = mtod(m, struct ether_header *);\n\t\tm->m_pkthdr.rcvif = ifp;\n\t\tm->m_pkthdr.len = m->m_len = total_len;\n#if NBPFILTER > 0\n\t\t/*\n\t\t * Handle BPF listeners. Let the BPF user see the packet.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\t\t/* Remove header from mbuf and pass it on. */\n\t\tm_adj(m, sizeof(struct ether_header));\n\t\tether_input(ifp, eh, m);\n\t}\n\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_rxeof;\nvoid vr_rxeoc;\n\nvoid\nvr_rxeoc(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\n\tvr_rxeof(sc);\n\tVR_CLRBIT16(sc, VR_COMMAND, VR_CMD_RX_ON);\n\tCSR_WRITE_4(sc, VR_RXADDR, vtophys(sc->vr_cdata.vr_rx_head->vr_ptr));\n\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_RX_ON);\n\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_RX_GO);\n\n\treturn;\n}"
  },
  {
    "function_name": "vr_rxeof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
    "lines": "1210-1312",
    "snippet": "void\nvr_rxeof(sc)\n\tstruct vr_softc\t\t*sc;\n{\n        struct ether_header\t*eh;\n        struct mbuf\t\t*m;\n        struct ifnet\t\t*ifp;\n\tstruct vr_chain_onefrag\t*cur_rx;\n\tint\t\t\ttotal_len = 0;\n\tu_int32_t\t\trxstat;\n\n\tifp = &sc->arpcom.ac_if;\n\n\twhile(!((rxstat = sc->vr_cdata.vr_rx_head->vr_ptr->vr_status) &\n\t\t\t\t\t\t\tVR_RXSTAT_OWN)) {\n\t\tcur_rx = sc->vr_cdata.vr_rx_head;\n\t\tsc->vr_cdata.vr_rx_head = cur_rx->vr_nextdesc;\n\n\t\t/*\n\t\t * If an error occurs, update stats, clear the\n\t\t * status word and leave the mbuf cluster in place:\n\t\t * it should simply get re-used next time this descriptor\n\t \t * comes up in the ring.\n\t\t */\n\t\tif (rxstat & VR_RXSTAT_RXERR) {\n\t\t\tifp->if_ierrors++;\n\t\t\tprintf(\"%s: rx error: \", sc->sc_dev.dv_xname);\n\t\t\tswitch(rxstat & 0x000000FF) {\n\t\t\tcase VR_RXSTAT_CRCERR:\n\t\t\t\tprintf(\"crc error\\n\");\n\t\t\t\tbreak;\n\t\t\tcase VR_RXSTAT_FRAMEALIGNERR:\n\t\t\t\tprintf(\"frame alignment error\\n\");\n\t\t\t\tbreak;\n\t\t\tcase VR_RXSTAT_FIFOOFLOW:\n\t\t\t\tprintf(\"FIFO overflow\\n\");\n\t\t\t\tbreak;\n\t\t\tcase VR_RXSTAT_GIANT:\n\t\t\t\tprintf(\"received giant packet\\n\");\n\t\t\t\tbreak;\n\t\t\tcase VR_RXSTAT_RUNT:\n\t\t\t\tprintf(\"received runt packet\\n\");\n\t\t\t\tbreak;\n\t\t\tcase VR_RXSTAT_BUSERR:\n\t\t\t\tprintf(\"system bus error\\n\");\n\t\t\t\tbreak;\n\t\t\tcase VR_RXSTAT_BUFFERR:\n\t\t\t\tprintf(\"rx buffer error\\n\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"unknown rx error\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcur_rx->vr_ptr->vr_status = VR_RXSTAT;\n\t\t\tcur_rx->vr_ptr->vr_ctl = VR_RXCTL|VR_RXLEN;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* No errors; receive the packet. */\t\n\t\tm = cur_rx->vr_mbuf;\n\t\ttotal_len = VR_RXBYTES(cur_rx->vr_ptr->vr_status);\n\n\t\t/*\n\t\t * XXX The VIA Rhine chip includes the CRC with every\n\t\t * received frame, and there's no way to turn this\n\t\t * behavior off (at least, I can't find anything in\n\t \t * the manual that explains how to do it) so we have\n\t\t * to trim off the CRC manually.\n\t\t */\n\t\ttotal_len -= ETHER_CRC_LEN;\n\n\t\t/*\n\t\t * Try to conjure up a new mbuf cluster. If that\n\t\t * fails, it means we have an out of memory condition and\n\t\t * should leave the buffer in place and continue. This will\n\t\t * result in a lost packet, but there's little else we\n\t\t * can do in this situation.\n\t\t */\n\t\tif (vr_newbuf(sc, cur_rx) == ENOBUFS) {\n\t\t\tifp->if_ierrors++;\n\t\t\tcur_rx->vr_ptr->vr_status = VR_RXSTAT;\n\t\t\tcur_rx->vr_ptr->vr_ctl = VR_RXCTL|VR_RXLEN;\n\t\t\tcontinue;\n\t\t}\n\n\t\tifp->if_ipackets++;\n\t\teh = mtod(m, struct ether_header *);\n\t\tm->m_pkthdr.rcvif = ifp;\n\t\tm->m_pkthdr.len = m->m_len = total_len;\n#if NBPFILTER > 0\n\t\t/*\n\t\t * Handle BPF listeners. Let the BPF user see the packet.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\t\t/* Remove header from mbuf and pass it on. */\n\t\tm_adj(m, sizeof(struct ether_header));\n\t\tether_input(ifp, eh, m);\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_vrreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/device.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int vr_newbuf",
      "void vr_rxeof"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ether_input",
          "args": [
            "ifp",
            "eh",
            "m"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_adj",
          "args": [
            "m",
            "sizeof(struct ether_header)"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "m"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "structether_header*"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vr_newbuf",
          "args": [
            "sc",
            "cur_rx"
          ],
          "line": 1288
        },
        "resolved": true,
        "details": {
          "function_name": "vr_newbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "1181-1204",
          "snippet": "int\nvr_newbuf(sc, c)\n\tstruct vr_softc\t\t*sc;\n\tstruct vr_chain_onefrag\t*c;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\tif (m_new == NULL)\n\t\treturn(ENOBUFS);\n\n\tMCLGET(m_new, M_DONTWAIT);\n\tif (!(m_new->m_flags & M_EXT)) {\n\t\tm_freem(m_new);\n\t\treturn(ENOBUFS);\n\t}\n\n\tc->vr_mbuf = m_new;\n\tc->vr_ptr->vr_status = VR_RXSTAT;\n\tc->vr_ptr->vr_data = vtophys(mtod(m_new, caddr_t));\n\tc->vr_ptr->vr_ctl = VR_RXCTL | VR_RXLEN;\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int vr_newbuf"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint vr_newbuf;\n\nint\nvr_newbuf(sc, c)\n\tstruct vr_softc\t\t*sc;\n\tstruct vr_chain_onefrag\t*c;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\tif (m_new == NULL)\n\t\treturn(ENOBUFS);\n\n\tMCLGET(m_new, M_DONTWAIT);\n\tif (!(m_new->m_flags & M_EXT)) {\n\t\tm_freem(m_new);\n\t\treturn(ENOBUFS);\n\t}\n\n\tc->vr_mbuf = m_new;\n\tc->vr_ptr->vr_status = VR_RXSTAT;\n\tc->vr_ptr->vr_data = vtophys(mtod(m_new, caddr_t));\n\tc->vr_ptr->vr_ctl = VR_RXCTL | VR_RXLEN;\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VR_RXBYTES",
          "args": [
            "cur_rx->vr_ptr->vr_status"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"unknown rx error\\n\""
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint vr_newbuf;\nvoid vr_rxeof;\n\nvoid\nvr_rxeof(sc)\n\tstruct vr_softc\t\t*sc;\n{\n        struct ether_header\t*eh;\n        struct mbuf\t\t*m;\n        struct ifnet\t\t*ifp;\n\tstruct vr_chain_onefrag\t*cur_rx;\n\tint\t\t\ttotal_len = 0;\n\tu_int32_t\t\trxstat;\n\n\tifp = &sc->arpcom.ac_if;\n\n\twhile(!((rxstat = sc->vr_cdata.vr_rx_head->vr_ptr->vr_status) &\n\t\t\t\t\t\t\tVR_RXSTAT_OWN)) {\n\t\tcur_rx = sc->vr_cdata.vr_rx_head;\n\t\tsc->vr_cdata.vr_rx_head = cur_rx->vr_nextdesc;\n\n\t\t/*\n\t\t * If an error occurs, update stats, clear the\n\t\t * status word and leave the mbuf cluster in place:\n\t\t * it should simply get re-used next time this descriptor\n\t \t * comes up in the ring.\n\t\t */\n\t\tif (rxstat & VR_RXSTAT_RXERR) {\n\t\t\tifp->if_ierrors++;\n\t\t\tprintf(\"%s: rx error: \", sc->sc_dev.dv_xname);\n\t\t\tswitch(rxstat & 0x000000FF) {\n\t\t\tcase VR_RXSTAT_CRCERR:\n\t\t\t\tprintf(\"crc error\\n\");\n\t\t\t\tbreak;\n\t\t\tcase VR_RXSTAT_FRAMEALIGNERR:\n\t\t\t\tprintf(\"frame alignment error\\n\");\n\t\t\t\tbreak;\n\t\t\tcase VR_RXSTAT_FIFOOFLOW:\n\t\t\t\tprintf(\"FIFO overflow\\n\");\n\t\t\t\tbreak;\n\t\t\tcase VR_RXSTAT_GIANT:\n\t\t\t\tprintf(\"received giant packet\\n\");\n\t\t\t\tbreak;\n\t\t\tcase VR_RXSTAT_RUNT:\n\t\t\t\tprintf(\"received runt packet\\n\");\n\t\t\t\tbreak;\n\t\t\tcase VR_RXSTAT_BUSERR:\n\t\t\t\tprintf(\"system bus error\\n\");\n\t\t\t\tbreak;\n\t\t\tcase VR_RXSTAT_BUFFERR:\n\t\t\t\tprintf(\"rx buffer error\\n\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"unknown rx error\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcur_rx->vr_ptr->vr_status = VR_RXSTAT;\n\t\t\tcur_rx->vr_ptr->vr_ctl = VR_RXCTL|VR_RXLEN;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* No errors; receive the packet. */\t\n\t\tm = cur_rx->vr_mbuf;\n\t\ttotal_len = VR_RXBYTES(cur_rx->vr_ptr->vr_status);\n\n\t\t/*\n\t\t * XXX The VIA Rhine chip includes the CRC with every\n\t\t * received frame, and there's no way to turn this\n\t\t * behavior off (at least, I can't find anything in\n\t \t * the manual that explains how to do it) so we have\n\t\t * to trim off the CRC manually.\n\t\t */\n\t\ttotal_len -= ETHER_CRC_LEN;\n\n\t\t/*\n\t\t * Try to conjure up a new mbuf cluster. If that\n\t\t * fails, it means we have an out of memory condition and\n\t\t * should leave the buffer in place and continue. This will\n\t\t * result in a lost packet, but there's little else we\n\t\t * can do in this situation.\n\t\t */\n\t\tif (vr_newbuf(sc, cur_rx) == ENOBUFS) {\n\t\t\tifp->if_ierrors++;\n\t\t\tcur_rx->vr_ptr->vr_status = VR_RXSTAT;\n\t\t\tcur_rx->vr_ptr->vr_ctl = VR_RXCTL|VR_RXLEN;\n\t\t\tcontinue;\n\t\t}\n\n\t\tifp->if_ipackets++;\n\t\teh = mtod(m, struct ether_header *);\n\t\tm->m_pkthdr.rcvif = ifp;\n\t\tm->m_pkthdr.len = m->m_len = total_len;\n#if NBPFILTER > 0\n\t\t/*\n\t\t * Handle BPF listeners. Let the BPF user see the packet.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m);\n#endif\n\t\t/* Remove header from mbuf and pass it on. */\n\t\tm_adj(m, sizeof(struct ether_header));\n\t\tether_input(ifp, eh, m);\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "vr_newbuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
    "lines": "1181-1204",
    "snippet": "int\nvr_newbuf(sc, c)\n\tstruct vr_softc\t\t*sc;\n\tstruct vr_chain_onefrag\t*c;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\tif (m_new == NULL)\n\t\treturn(ENOBUFS);\n\n\tMCLGET(m_new, M_DONTWAIT);\n\tif (!(m_new->m_flags & M_EXT)) {\n\t\tm_freem(m_new);\n\t\treturn(ENOBUFS);\n\t}\n\n\tc->vr_mbuf = m_new;\n\tc->vr_ptr->vr_status = VR_RXSTAT;\n\tc->vr_ptr->vr_data = vtophys(mtod(m_new, caddr_t));\n\tc->vr_ptr->vr_ctl = VR_RXCTL | VR_RXLEN;\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/if_vrreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/device.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int vr_newbuf"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "mtod(m_new, caddr_t)"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m_new",
            "caddr_t"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m_new"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCLGET",
          "args": [
            "m_new",
            "M_DONTWAIT"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGETHDR",
          "args": [
            "m_new",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint vr_newbuf;\n\nint\nvr_newbuf(sc, c)\n\tstruct vr_softc\t\t*sc;\n\tstruct vr_chain_onefrag\t*c;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\tif (m_new == NULL)\n\t\treturn(ENOBUFS);\n\n\tMCLGET(m_new, M_DONTWAIT);\n\tif (!(m_new->m_flags & M_EXT)) {\n\t\tm_freem(m_new);\n\t\treturn(ENOBUFS);\n\t}\n\n\tc->vr_mbuf = m_new;\n\tc->vr_ptr->vr_status = VR_RXSTAT;\n\tc->vr_ptr->vr_data = vtophys(mtod(m_new, caddr_t));\n\tc->vr_ptr->vr_ctl = VR_RXCTL | VR_RXLEN;\n\n\treturn(0);\n}"
  },
  {
    "function_name": "vr_list_rx_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
    "lines": "1140-1172",
    "snippet": "int\nvr_list_rx_init(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tstruct vr_chain_data\t*cd;\n\tstruct vr_list_data\t*ld;\n\tint\t\t\ti;\n\n\tcd = &sc->vr_cdata;\n\tld = sc->vr_ldata;\n\n\tfor (i = 0; i < VR_RX_LIST_CNT; i++) {\n\t\tcd->vr_rx_chain[i].vr_ptr =\n\t\t\t(struct vr_desc *)&ld->vr_rx_list[i];\n\t\tif (vr_newbuf(sc, &cd->vr_rx_chain[i]) == ENOBUFS)\n\t\t\treturn(ENOBUFS);\n\t\tif (i == (VR_RX_LIST_CNT - 1)) {\n\t\t\tcd->vr_rx_chain[i].vr_nextdesc =\n\t\t\t\t\t&cd->vr_rx_chain[0];\n\t\t\tld->vr_rx_list[i].vr_next =\n\t\t\t\t\tvtophys(&ld->vr_rx_list[0]);\n\t\t} else {\n\t\t\tcd->vr_rx_chain[i].vr_nextdesc =\n\t\t\t\t\t&cd->vr_rx_chain[i + 1];\n\t\t\tld->vr_rx_list[i].vr_next =\n\t\t\t\t\tvtophys(&ld->vr_rx_list[i + 1]);\n\t\t}\n\t}\n\n\tcd->vr_rx_head = &cd->vr_rx_chain[0];\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/if_vrreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/device.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int vr_newbuf",
      "int vr_list_rx_init"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&ld->vr_rx_list[i + 1]"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&ld->vr_rx_list[0]"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vr_newbuf",
          "args": [
            "sc",
            "&cd->vr_rx_chain[i]"
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "vr_newbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "1181-1204",
          "snippet": "int\nvr_newbuf(sc, c)\n\tstruct vr_softc\t\t*sc;\n\tstruct vr_chain_onefrag\t*c;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\tif (m_new == NULL)\n\t\treturn(ENOBUFS);\n\n\tMCLGET(m_new, M_DONTWAIT);\n\tif (!(m_new->m_flags & M_EXT)) {\n\t\tm_freem(m_new);\n\t\treturn(ENOBUFS);\n\t}\n\n\tc->vr_mbuf = m_new;\n\tc->vr_ptr->vr_status = VR_RXSTAT;\n\tc->vr_ptr->vr_data = vtophys(mtod(m_new, caddr_t));\n\tc->vr_ptr->vr_ctl = VR_RXCTL | VR_RXLEN;\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int vr_newbuf"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint vr_newbuf;\n\nint\nvr_newbuf(sc, c)\n\tstruct vr_softc\t\t*sc;\n\tstruct vr_chain_onefrag\t*c;\n{\n\tstruct mbuf\t\t*m_new = NULL;\n\n\tMGETHDR(m_new, M_DONTWAIT, MT_DATA);\n\tif (m_new == NULL)\n\t\treturn(ENOBUFS);\n\n\tMCLGET(m_new, M_DONTWAIT);\n\tif (!(m_new->m_flags & M_EXT)) {\n\t\tm_freem(m_new);\n\t\treturn(ENOBUFS);\n\t}\n\n\tc->vr_mbuf = m_new;\n\tc->vr_ptr->vr_status = VR_RXSTAT;\n\tc->vr_ptr->vr_data = vtophys(mtod(m_new, caddr_t));\n\tc->vr_ptr->vr_ctl = VR_RXCTL | VR_RXLEN;\n\n\treturn(0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint vr_newbuf;\nint vr_list_rx_init;\n\nint\nvr_list_rx_init(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tstruct vr_chain_data\t*cd;\n\tstruct vr_list_data\t*ld;\n\tint\t\t\ti;\n\n\tcd = &sc->vr_cdata;\n\tld = sc->vr_ldata;\n\n\tfor (i = 0; i < VR_RX_LIST_CNT; i++) {\n\t\tcd->vr_rx_chain[i].vr_ptr =\n\t\t\t(struct vr_desc *)&ld->vr_rx_list[i];\n\t\tif (vr_newbuf(sc, &cd->vr_rx_chain[i]) == ENOBUFS)\n\t\t\treturn(ENOBUFS);\n\t\tif (i == (VR_RX_LIST_CNT - 1)) {\n\t\t\tcd->vr_rx_chain[i].vr_nextdesc =\n\t\t\t\t\t&cd->vr_rx_chain[0];\n\t\t\tld->vr_rx_list[i].vr_next =\n\t\t\t\t\tvtophys(&ld->vr_rx_list[0]);\n\t\t} else {\n\t\t\tcd->vr_rx_chain[i].vr_nextdesc =\n\t\t\t\t\t&cd->vr_rx_chain[i + 1];\n\t\t\tld->vr_rx_list[i].vr_next =\n\t\t\t\t\tvtophys(&ld->vr_rx_list[i + 1]);\n\t\t}\n\t}\n\n\tcd->vr_rx_head = &cd->vr_rx_chain[0];\n\n\treturn(0);\n}"
  },
  {
    "function_name": "vr_list_tx_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
    "lines": "1108-1132",
    "snippet": "int\nvr_list_tx_init(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tstruct vr_chain_data\t*cd;\n\tstruct vr_list_data\t*ld;\n\tint\t\t\ti;\n\n\tcd = &sc->vr_cdata;\n\tld = sc->vr_ldata;\n\tfor (i = 0; i < VR_TX_LIST_CNT; i++) {\n\t\tcd->vr_tx_chain[i].vr_ptr = &ld->vr_tx_list[i];\n\t\tif (i == (VR_TX_LIST_CNT - 1))\n\t\t\tcd->vr_tx_chain[i].vr_nextdesc = \n\t\t\t\t&cd->vr_tx_chain[0];\n\t\telse\n\t\t\tcd->vr_tx_chain[i].vr_nextdesc =\n\t\t\t\t&cd->vr_tx_chain[i + 1];\n\t}\n\n\tcd->vr_tx_free = &cd->vr_tx_chain[0];\n\tcd->vr_tx_tail = cd->vr_tx_head = NULL;\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/if_vrreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/device.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int vr_list_tx_init"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint vr_list_tx_init;\n\nint\nvr_list_tx_init(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tstruct vr_chain_data\t*cd;\n\tstruct vr_list_data\t*ld;\n\tint\t\t\ti;\n\n\tcd = &sc->vr_cdata;\n\tld = sc->vr_ldata;\n\tfor (i = 0; i < VR_TX_LIST_CNT; i++) {\n\t\tcd->vr_tx_chain[i].vr_ptr = &ld->vr_tx_list[i];\n\t\tif (i == (VR_TX_LIST_CNT - 1))\n\t\t\tcd->vr_tx_chain[i].vr_nextdesc = \n\t\t\t\t&cd->vr_tx_chain[0];\n\t\telse\n\t\t\tcd->vr_tx_chain[i].vr_nextdesc =\n\t\t\t\t&cd->vr_tx_chain[i + 1];\n\t}\n\n\tcd->vr_tx_free = &cd->vr_tx_chain[0];\n\tcd->vr_tx_tail = cd->vr_tx_head = NULL;\n\n\treturn(0);\n}"
  },
  {
    "function_name": "vr_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
    "lines": "885-1103",
    "snippet": "void\nvr_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tint\t\t\ts, i;\n\tu_char\t\t\teaddr[ETHER_ADDR_LEN];\n\tu_int32_t\t\tcommand;\n\tstruct vr_softc\t\t*sc = (struct vr_softc *)self;\n\tstruct pci_attach_args \t*pa = aux;\n\tpci_chipset_tag_t\tpc = pa->pa_pc;\n\tpci_intr_handle_t\tih;\n\tconst char\t\t*intrstr = NULL;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tbus_addr_t\t\tiobase;\n\tbus_size_t\t\tiosize;\n\tint\t\t\tmedia = IFM_ETHER|IFM_100_TX|IFM_FDX;\n\tunsigned int\t\tround;\n\tcaddr_t\t\t\troundptr;\n\tstruct vr_type\t\t*p;\n\tu_int16_t\t\tphy_vid, phy_did, phy_sts;\n\n\ts = splimp();\n\n\t/*\n\t * Handle power management nonsense.\n\t */\n\tcommand = pci_conf_read(pa->pa_pc, pa->pa_tag,\n\t\t\t\t\tVR_PCI_CAPID) & 0x000000FF;\n\tif (command == 0x01) {\n\t\tcommand = pci_conf_read(pa->pa_pc, pa->pa_tag,\n\t\t\t\t\tVR_PCI_PWRMGMTCTRL);\n\t\tif (command & VR_PSTATE_MASK) {\n\t\t\tu_int32_t\t\tiobase, membase, irq;\n\n\t\t\t/* Save important PCI config data. */\n\t\t\tiobase = pci_conf_read(pa->pa_pc, pa->pa_tag,\n\t\t\t\t\t\tVR_PCI_LOIO);\n\t\t\tmembase = pci_conf_read(pa->pa_pc, pa->pa_tag,\n\t\t\t\t\t\tVR_PCI_LOMEM);\n\t\t\tirq = pci_conf_read(pa->pa_pc, pa->pa_tag,\n\t\t\t\t\t\tVR_PCI_INTLINE);\n\n\t\t\t/* Reset the power state. */\n\t\t\tcommand &= 0xFFFFFFFC;\n\t\t\tpci_conf_write(pa->pa_pc, pa->pa_tag,\n\t\t\t\t\t\tVR_PCI_PWRMGMTCTRL, command);\n\n\t\t\t/* Restore PCI config data. */\n\t\t\tpci_conf_write(pa->pa_pc, pa->pa_tag,\n\t\t\t\t\t\tVR_PCI_LOIO, iobase);\n\t\t\tpci_conf_write(pa->pa_pc, pa->pa_tag,\n\t\t\t\t\t\tVR_PCI_LOMEM, membase);\n\t\t\tpci_conf_write(pa->pa_pc, pa->pa_tag,\n\t\t\t\t\t\tVR_PCI_INTLINE, irq);\n\t\t}\n\t}\n\n\t/*\n\t * Map control/status registers.\n\t */\n\tcommand = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);\n\n#ifdef VR_USEIOSPACE\n\tif (!(command & PCI_COMMAND_IO_ENABLE)) {\n\t\tprintf(\": failed to enable I/O ports\\n\");\n\t\tgoto fail;\n\t}\n\tif (pci_io_find(pc, pa->pa_tag, VR_PCI_LOIO, &iobase, &iosize)) {\n\t\tprintf(\": failed to find i/o space\\n\");\n\t\tgoto fail;\n\t}\n\tif (bus_space_map(pa->pa_iot, iobase, iosize, 0, &sc->vr_bhandle)) {\n\t\tprintf(\": failed map i/o space\\n\");\n\t\tgoto fail;\n\t}\n\tsc->vr_btag = pa->pa_iot;\n#else\n\tif (!(command & PCI_COMMAND_MEM_ENABLE)) {\n\t\tprintf(\": failed to enable memory mapping\\n\");\n\t\tgoto fail;\n\t}\n\tif (pci_mem_find(pc, pa->pa_tag, VR_PCI_LOMEM, &iobase, &iosize)) {\n\t\tprintf(\": failed to find memory space\\n\");\n\t\tgoto fail;\n\t}\n\tif (bus_space_map(pa->pa_memt, iobase, iosize, 0, &sc->vr_bhandle)) {\n\t\tprintf(\": failed map memory space\\n\");\n\t\tgoto fail;\n\t}\n\tsc->vr_btag = pa->pa_memt;\n#endif\n\n\t/* Allocate interrupt */\n\tif (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,\n\t\t\t pa->pa_intrline, &ih)) {\n\t\tprintf(\": couldn't map interrupt\\n\");\n\t\tgoto fail;\n\t}\n\tintrstr = pci_intr_string(pc, ih);\n\tsc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, vr_intr, sc,\n\t\t\t\t       self->dv_xname);\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\": could not establish interrupt\");\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\tgoto fail;\n\t}\n\tprintf(\": %s\", intrstr);\n\n\t/* Reset the adapter. */\n\tvr_reset(sc);\n\n\t/*\n\t * Get station address. The way the Rhine chips work,\n\t * you're not allowed to directly access the EEPROM once\n\t * they've been programmed a special way. Consequently,\n\t * we need to read the node address from the PAR0 and PAR1\n\t * registers.\n\t */\n\tVR_SETBIT(sc, VR_EECSR, VR_EECSR_LOAD);\n\tDELAY(200);\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\teaddr[i] = CSR_READ_1(sc, VR_PAR0 + i);\n\n\t/*\n\t * A Rhine chip was detected. Inform the world.\n\t */\n\tbcopy(eaddr, (char *)&sc->arpcom.ac_enaddr, ETHER_ADDR_LEN);\n\tprintf(\" address %s\\n\", ether_sprintf(sc->arpcom.ac_enaddr));\n\n\tsc->vr_ldata_ptr = malloc(sizeof(struct vr_list_data) + 8,\n\t\t\t\tM_DEVBUF, M_NOWAIT);\n\tif (sc->vr_ldata_ptr == NULL) {\n\t\tprintf(\"%s: no memory for list buffers\\n\", sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\tsc->vr_ldata = (struct vr_list_data *)sc->vr_ldata_ptr;\n\tround = (unsigned int)sc->vr_ldata_ptr & 0xF;\n\troundptr = sc->vr_ldata_ptr;\n\tfor (i = 0; i < 8; i++) {\n\t\tif (round % 8) {\n\t\t\tround++;\n\t\t\troundptr++;\n\t\t} else\n\t\t\tbreak;\n\t}\n\tsc->vr_ldata = (struct vr_list_data *)roundptr;\n\tbzero(sc->vr_ldata, sizeof(struct vr_list_data));\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_softc = sc;\n\tifp->if_mtu = ETHERMTU;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;\n\tifp->if_ioctl = vr_ioctl;\n\tifp->if_output = ether_output;\n\tifp->if_start = vr_start;\n\tifp->if_watchdog = vr_watchdog;\n\tifp->if_baudrate = 10000000;\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\n\tfor (i = VR_PHYADDR_MIN; i < VR_PHYADDR_MAX + 1; i++) {\n\t\tsc->vr_phy_addr = i;\n\t\tvr_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);\n\t\tDELAY(500);\n\t\twhile(vr_phy_readreg(sc, PHY_BMCR)\n\t\t\t\t& PHY_BMCR_RESET);\n\t\tif ((phy_sts = vr_phy_readreg(sc, PHY_BMSR)))\n\t\t\tbreak;\n\t}\n\tif (phy_sts) {\n\t\tphy_vid = vr_phy_readreg(sc, PHY_VENID);\n\t\tphy_did = vr_phy_readreg(sc, PHY_DEVID);\n\t\tp = vr_phys;\n\t\twhile(p->vr_vid) {\n\t\t\tif (phy_vid == p->vr_vid &&\n\t\t\t\t(phy_did | 0x000F) == p->vr_did) {\n\t\t\t\tsc->vr_pinfo = p;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\t\tif (sc->vr_pinfo == NULL)\n\t\t\tsc->vr_pinfo = &vr_phys[PHY_UNKNOWN];\n\t} else {\n\t\tprintf(\"%s: MII without any phy!\\n\", sc->sc_dev.dv_xname);\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * Do ifmedia setup.\n\t */\n\tifmedia_init(&sc->ifmedia, 0, vr_ifmedia_upd, vr_ifmedia_sts);\n\n\tvr_getmode_mii(sc);\n\tvr_autoneg_mii(sc, VR_FLAG_FORCEDELAY, 1);\n\tmedia = sc->ifmedia.ifm_media;\n\tvr_stop(sc);\n\n\tifmedia_set(&sc->ifmedia, media);\n\n\t/*\n\t * Call MI attach routines.\n\t */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n#if NBPFILTER > 0\n\tbpfattach(&sc->arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,\n\t\t\tsizeof(struct ether_header));\n#endif\n\tshutdownhook_establish(vr_shutdown, sc);\n\nfail:\n\tsplx(s);\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_vrreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/device.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define VR_USEIOSPACE"
    ],
    "globals_used": [
      "static struct vr_type vr_phys[] = {\n\t{ TI_PHY_VENDORID, TI_PHY_10BT, \"<TI ThunderLAN 10BT (internal)>\" },\n\t{ TI_PHY_VENDORID, TI_PHY_100VGPMI, \"<TI TNETE211 100VG Any-LAN>\" },\n\t{ NS_PHY_VENDORID, NS_PHY_83840A, \"<National Semiconductor DP83840A>\"},\n\t{ LEVEL1_PHY_VENDORID, LEVEL1_PHY_LXT970, \"<Level 1 LXT970>\" },\n\t{ INTEL_PHY_VENDORID, INTEL_PHY_82555, \"<Intel 82555>\" },\n\t{ SEEQ_PHY_VENDORID, SEEQ_PHY_80220, \"<SEEQ 80220>\" },\n\t{ 0, 0, \"<MII-compliant physical interface>\" }\n};",
      "void vr_attach",
      "int vr_intr",
      "void vr_start",
      "int vr_ioctl",
      "void vr_stop",
      "void vr_watchdog",
      "void vr_shutdown",
      "int vr_ifmedia_upd",
      "void vr_ifmedia_sts",
      "u_int16_t vr_phy_readreg",
      "void vr_phy_writereg",
      "void vr_autoneg_mii",
      "void vr_getmode_mii",
      "void vr_reset"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shutdownhook_establish",
          "args": [
            "vr_shutdown",
            "sc"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpfattach",
          "args": [
            "&sc->arpcom.ac_if.if_bpf",
            "ifp",
            "DLT_EN10MB",
            "sizeof(struct ether_header)"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ifattach",
          "args": [
            "ifp"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_attach",
          "args": [
            "ifp"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_set",
          "args": [
            "&sc->ifmedia",
            "media"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vr_stop",
          "args": [
            "sc"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "vr_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "1900-1944",
          "snippet": "void\nvr_stop(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_timer = 0;\n\n\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_STOP);\n\tVR_CLRBIT16(sc, VR_COMMAND, (VR_CMD_RX_ON|VR_CMD_TX_ON));\n\tCSR_WRITE_2(sc, VR_IMR, 0x0000);\n\tCSR_WRITE_4(sc, VR_TXADDR, 0x00000000);\n\tCSR_WRITE_4(sc, VR_RXADDR, 0x00000000);\n\n\t/*\n\t * Free data in the RX lists.\n\t */\n\tfor (i = 0; i < VR_RX_LIST_CNT; i++) {\n\t\tif (sc->vr_cdata.vr_rx_chain[i].vr_mbuf != NULL) {\n\t\t\tm_freem(sc->vr_cdata.vr_rx_chain[i].vr_mbuf);\n\t\t\tsc->vr_cdata.vr_rx_chain[i].vr_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->vr_ldata->vr_rx_list,\n\t\tsizeof(sc->vr_ldata->vr_rx_list));\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < VR_TX_LIST_CNT; i++) {\n\t\tif (sc->vr_cdata.vr_tx_chain[i].vr_mbuf != NULL) {\n\t\t\tm_freem(sc->vr_cdata.vr_tx_chain[i].vr_mbuf);\n\t\t\tsc->vr_cdata.vr_tx_chain[i].vr_mbuf = NULL;\n\t\t}\n\t}\n\n\tbzero((char *)&sc->vr_ldata->vr_tx_list,\n\t\tsizeof(sc->vr_ldata->vr_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void vr_stop"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_stop;\n\nvoid\nvr_stop(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_timer = 0;\n\n\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_STOP);\n\tVR_CLRBIT16(sc, VR_COMMAND, (VR_CMD_RX_ON|VR_CMD_TX_ON));\n\tCSR_WRITE_2(sc, VR_IMR, 0x0000);\n\tCSR_WRITE_4(sc, VR_TXADDR, 0x00000000);\n\tCSR_WRITE_4(sc, VR_RXADDR, 0x00000000);\n\n\t/*\n\t * Free data in the RX lists.\n\t */\n\tfor (i = 0; i < VR_RX_LIST_CNT; i++) {\n\t\tif (sc->vr_cdata.vr_rx_chain[i].vr_mbuf != NULL) {\n\t\t\tm_freem(sc->vr_cdata.vr_rx_chain[i].vr_mbuf);\n\t\t\tsc->vr_cdata.vr_rx_chain[i].vr_mbuf = NULL;\n\t\t}\n\t}\n\tbzero((char *)&sc->vr_ldata->vr_rx_list,\n\t\tsizeof(sc->vr_ldata->vr_rx_list));\n\n\t/*\n\t * Free the TX list buffers.\n\t */\n\tfor (i = 0; i < VR_TX_LIST_CNT; i++) {\n\t\tif (sc->vr_cdata.vr_tx_chain[i].vr_mbuf != NULL) {\n\t\t\tm_freem(sc->vr_cdata.vr_tx_chain[i].vr_mbuf);\n\t\t\tsc->vr_cdata.vr_tx_chain[i].vr_mbuf = NULL;\n\t\t}\n\t}\n\n\tbzero((char *)&sc->vr_ldata->vr_tx_list,\n\t\tsizeof(sc->vr_ldata->vr_tx_list));\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vr_autoneg_mii",
          "args": [
            "sc",
            "VR_FLAG_FORCEDELAY",
            "1"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "vr_autoneg_mii",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "535-679",
          "snippet": "void\nvr_autoneg_mii(sc, flag, verbose)\n\tstruct vr_softc\t\t*sc;\n\tint\t\t\tflag;\n\tint\t\t\tverbose;\n{\n\tu_int16_t\t\tphy_sts = 0, media, advert, ability;\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmedia\t\t*ifm;\n\n\tifm = &sc->ifmedia;\n\tifp = &sc->arpcom.ac_if;\n\n\tifm->ifm_media = IFM_ETHER | IFM_AUTO;\n\n\t/*\n\t * The 100baseT4 PHY on the 3c905-T4 has the 'autoneg supported'\n\t * bit cleared in the status register, but has the 'autoneg enabled'\n\t * bit set in the control register. This is a contradiction, and\n\t * I'm not sure how to handle it. If you want to force an attempt\n\t * to autoneg for 100baseT4 PHYs, #define FORCE_AUTONEG_TFOUR\n\t * and see what happens.\n\t */\n#ifndef FORCE_AUTONEG_TFOUR\n\t/*\n\t * First, see if autoneg is supported. If not, there's\n\t * no point in continuing.\n\t */\n\tphy_sts = vr_phy_readreg(sc, PHY_BMSR);\n\tif (!(phy_sts & PHY_BMSR_CANAUTONEG)) {\n\t\tif (verbose)\n\t\t\tprintf(\"%s: autonegotiation not supported\\n\",\n\t\t\t\t\t\t\tsc->sc_dev.dv_xname);\n\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;\t\n\t\treturn;\n\t}\n#endif\n\n\tswitch (flag) {\n\tcase VR_FLAG_FORCEDELAY:\n\t\t/*\n\t \t * XXX Never use this option anywhere but in the probe\n\t \t * routine: making the kernel stop dead in its tracks\n \t\t * for three whole seconds after we've gone multi-user\n\t\t * is really bad manners.\n\t \t */\n\t\tvr_autoneg_xmit(sc);\n\t\tDELAY(5000000);\n\t\tbreak;\n\tcase VR_FLAG_SCHEDDELAY:\n\t\t/*\n\t\t * Wait for the transmitter to go idle before starting\n\t\t * an autoneg session, otherwise vr_start() may clobber\n\t \t * our timeout, and we don't want to allow transmission\n\t\t * during an autoneg session since that can screw it up.\n\t \t */\n\t\tif (sc->vr_cdata.vr_tx_head != NULL) {\n\t\t\tsc->vr_want_auto = 1;\n\t\t\treturn;\n\t\t}\n\t\tvr_autoneg_xmit(sc);\n\t\tifp->if_timer = 5;\n\t\tsc->vr_autoneg = 1;\n\t\tsc->vr_want_auto = 0;\n\t\treturn;\n\t\tbreak;\n\tcase VR_FLAG_DELAYTIMEO:\n\t\tifp->if_timer = 0;\n\t\tsc->vr_autoneg = 0;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: invalid autoneg flag: %d\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname, flag);\n\t\treturn;\n\t}\n\n\tif (vr_phy_readreg(sc, PHY_BMSR) & PHY_BMSR_AUTONEGCOMP) {\n\t\tif (verbose)\n\t\t\tprintf(\"%s: autoneg complete, \", sc->sc_dev.dv_xname);\n\t\tphy_sts = vr_phy_readreg(sc, PHY_BMSR);\n\t} else {\n\t\tif (verbose)\n\t\t\tprintf(\"%s: autoneg not complete, \",\n\t\t\t\t\t\tsc->sc_dev.dv_xname);\n\t}\n\n\tmedia = vr_phy_readreg(sc, PHY_BMCR);\n\n\t/* Link is good. Report modes and set duplex mode. */\n\tif (vr_phy_readreg(sc, PHY_BMSR) & PHY_BMSR_LINKSTAT) {\n\t\tif (verbose)\n\t\t\tprintf(\"link status good \");\n\t\tadvert = vr_phy_readreg(sc, PHY_ANAR);\n\t\tability = vr_phy_readreg(sc, PHY_LPAR);\n\n\t\tif (advert & PHY_ANAR_100BT4 && ability & PHY_ANAR_100BT4) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_T4;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(100baseT4)\\n\");\n\t\t} else if (advert & PHY_ANAR_100BTXFULL &&\n\t\t\tability & PHY_ANAR_100BTXFULL) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_FDX;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia |= PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(full-duplex, 100Mbps)\\n\");\n\t\t} else if (advert & PHY_ANAR_100BTXHALF &&\n\t\t\tability & PHY_ANAR_100BTXHALF) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_HDX;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(half-duplex, 100Mbps)\\n\");\n\t\t} else if (advert & PHY_ANAR_10BTFULL &&\n\t\t\tability & PHY_ANAR_10BTFULL) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_FDX;\n\t\t\tmedia &= ~PHY_BMCR_SPEEDSEL;\n\t\t\tmedia |= PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(full-duplex, 10Mbps)\\n\");\n\t\t} else {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;\n\t\t\tmedia &= ~PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(half-duplex, 10Mbps)\\n\");\n\t\t}\n\n\t\tmedia &= ~PHY_BMCR_AUTONEGENBL;\n\n\t\t/* Set ASIC's duplex mode to match the PHY. */\n\t\tvr_setcfg(sc, media);\n\t\tvr_phy_writereg(sc, PHY_BMCR, media);\n\t} else {\n\t\tif (verbose)\n\t\t\tprintf(\"no carrier\\n\");\n\t}\n\n\tvr_init(sc);\n\n\tif (sc->vr_tx_pend) {\n\t\tsc->vr_autoneg = 0;\n\t\tsc->vr_tx_pend = 0;\n\t\tvr_start(ifp);\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void vr_start",
            "void vr_init",
            "u_int16_t vr_phy_readreg",
            "void vr_phy_writereg",
            "void vr_autoneg_xmit",
            "void vr_autoneg_mii",
            "void vr_setcfg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_start;\nvoid vr_init;\nu_int16_t vr_phy_readreg;\nvoid vr_phy_writereg;\nvoid vr_autoneg_xmit;\nvoid vr_autoneg_mii;\nvoid vr_setcfg;\n\nvoid\nvr_autoneg_mii(sc, flag, verbose)\n\tstruct vr_softc\t\t*sc;\n\tint\t\t\tflag;\n\tint\t\t\tverbose;\n{\n\tu_int16_t\t\tphy_sts = 0, media, advert, ability;\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmedia\t\t*ifm;\n\n\tifm = &sc->ifmedia;\n\tifp = &sc->arpcom.ac_if;\n\n\tifm->ifm_media = IFM_ETHER | IFM_AUTO;\n\n\t/*\n\t * The 100baseT4 PHY on the 3c905-T4 has the 'autoneg supported'\n\t * bit cleared in the status register, but has the 'autoneg enabled'\n\t * bit set in the control register. This is a contradiction, and\n\t * I'm not sure how to handle it. If you want to force an attempt\n\t * to autoneg for 100baseT4 PHYs, #define FORCE_AUTONEG_TFOUR\n\t * and see what happens.\n\t */\n#ifndef FORCE_AUTONEG_TFOUR\n\t/*\n\t * First, see if autoneg is supported. If not, there's\n\t * no point in continuing.\n\t */\n\tphy_sts = vr_phy_readreg(sc, PHY_BMSR);\n\tif (!(phy_sts & PHY_BMSR_CANAUTONEG)) {\n\t\tif (verbose)\n\t\t\tprintf(\"%s: autonegotiation not supported\\n\",\n\t\t\t\t\t\t\tsc->sc_dev.dv_xname);\n\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;\t\n\t\treturn;\n\t}\n#endif\n\n\tswitch (flag) {\n\tcase VR_FLAG_FORCEDELAY:\n\t\t/*\n\t \t * XXX Never use this option anywhere but in the probe\n\t \t * routine: making the kernel stop dead in its tracks\n \t\t * for three whole seconds after we've gone multi-user\n\t\t * is really bad manners.\n\t \t */\n\t\tvr_autoneg_xmit(sc);\n\t\tDELAY(5000000);\n\t\tbreak;\n\tcase VR_FLAG_SCHEDDELAY:\n\t\t/*\n\t\t * Wait for the transmitter to go idle before starting\n\t\t * an autoneg session, otherwise vr_start() may clobber\n\t \t * our timeout, and we don't want to allow transmission\n\t\t * during an autoneg session since that can screw it up.\n\t \t */\n\t\tif (sc->vr_cdata.vr_tx_head != NULL) {\n\t\t\tsc->vr_want_auto = 1;\n\t\t\treturn;\n\t\t}\n\t\tvr_autoneg_xmit(sc);\n\t\tifp->if_timer = 5;\n\t\tsc->vr_autoneg = 1;\n\t\tsc->vr_want_auto = 0;\n\t\treturn;\n\t\tbreak;\n\tcase VR_FLAG_DELAYTIMEO:\n\t\tifp->if_timer = 0;\n\t\tsc->vr_autoneg = 0;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: invalid autoneg flag: %d\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname, flag);\n\t\treturn;\n\t}\n\n\tif (vr_phy_readreg(sc, PHY_BMSR) & PHY_BMSR_AUTONEGCOMP) {\n\t\tif (verbose)\n\t\t\tprintf(\"%s: autoneg complete, \", sc->sc_dev.dv_xname);\n\t\tphy_sts = vr_phy_readreg(sc, PHY_BMSR);\n\t} else {\n\t\tif (verbose)\n\t\t\tprintf(\"%s: autoneg not complete, \",\n\t\t\t\t\t\tsc->sc_dev.dv_xname);\n\t}\n\n\tmedia = vr_phy_readreg(sc, PHY_BMCR);\n\n\t/* Link is good. Report modes and set duplex mode. */\n\tif (vr_phy_readreg(sc, PHY_BMSR) & PHY_BMSR_LINKSTAT) {\n\t\tif (verbose)\n\t\t\tprintf(\"link status good \");\n\t\tadvert = vr_phy_readreg(sc, PHY_ANAR);\n\t\tability = vr_phy_readreg(sc, PHY_LPAR);\n\n\t\tif (advert & PHY_ANAR_100BT4 && ability & PHY_ANAR_100BT4) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_T4;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(100baseT4)\\n\");\n\t\t} else if (advert & PHY_ANAR_100BTXFULL &&\n\t\t\tability & PHY_ANAR_100BTXFULL) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_FDX;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia |= PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(full-duplex, 100Mbps)\\n\");\n\t\t} else if (advert & PHY_ANAR_100BTXHALF &&\n\t\t\tability & PHY_ANAR_100BTXHALF) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_HDX;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(half-duplex, 100Mbps)\\n\");\n\t\t} else if (advert & PHY_ANAR_10BTFULL &&\n\t\t\tability & PHY_ANAR_10BTFULL) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_FDX;\n\t\t\tmedia &= ~PHY_BMCR_SPEEDSEL;\n\t\t\tmedia |= PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(full-duplex, 10Mbps)\\n\");\n\t\t} else {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;\n\t\t\tmedia &= ~PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(half-duplex, 10Mbps)\\n\");\n\t\t}\n\n\t\tmedia &= ~PHY_BMCR_AUTONEGENBL;\n\n\t\t/* Set ASIC's duplex mode to match the PHY. */\n\t\tvr_setcfg(sc, media);\n\t\tvr_phy_writereg(sc, PHY_BMCR, media);\n\t} else {\n\t\tif (verbose)\n\t\t\tprintf(\"no carrier\\n\");\n\t}\n\n\tvr_init(sc);\n\n\tif (sc->vr_tx_pend) {\n\t\tsc->vr_autoneg = 0;\n\t\tsc->vr_tx_pend = 0;\n\t\tvr_start(ifp);\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vr_getmode_mii",
          "args": [
            "sc"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "vr_getmode_mii",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "681-739",
          "snippet": "void\nvr_getmode_mii(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tu_int16_t\t\tbmsr;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tbmsr = vr_phy_readreg(sc, PHY_BMSR);\n\n\t/* fallback */\n\tsc->ifmedia.ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;\n\n\tif (bmsr & PHY_BMSR_10BTHALF) {\n\t\tifmedia_add(&sc->ifmedia,\n\t\t\tIFM_ETHER|IFM_10_T|IFM_HDX, 0, NULL);\n\t\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_T, 0, NULL);\n\t}\n\n\tif (bmsr & PHY_BMSR_10BTFULL) {\n\t\tifmedia_add(&sc->ifmedia,\n\t\t\tIFM_ETHER|IFM_10_T|IFM_FDX, 0, NULL);\n\t\tsc->ifmedia.ifm_media = IFM_ETHER|IFM_10_T|IFM_FDX;\n\t}\n\n\tif (bmsr & PHY_BMSR_100BTXHALF) {\n\t\tifp->if_baudrate = 100000000;\n\t\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_100_TX, 0, NULL);\n\t\tifmedia_add(&sc->ifmedia,\n\t\t\tIFM_ETHER|IFM_100_TX|IFM_HDX, 0, NULL);\n\t\tsc->ifmedia.ifm_media = IFM_ETHER|IFM_100_TX|IFM_HDX;\n\t}\n\n\tif (bmsr & PHY_BMSR_100BTXFULL) {\n\t\tifp->if_baudrate = 100000000;\n\t\tifmedia_add(&sc->ifmedia,\n\t\t\tIFM_ETHER|IFM_100_TX|IFM_FDX, 0, NULL);\n\t\tsc->ifmedia.ifm_media = IFM_ETHER|IFM_100_TX|IFM_FDX;\n\t}\n\n\t/* Some also support 100BaseT4. */\n\tif (bmsr & PHY_BMSR_100BT4) {\n\t\tifp->if_baudrate = 100000000;\n\t\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_100_T4, 0, NULL);\n\t\tsc->ifmedia.ifm_media = IFM_ETHER|IFM_100_T4;\n#ifdef FORCE_AUTONEG_TFOUR\n\t\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_AUTO, 0 NULL):\n\t\tsc->ifmedia.ifm_media = IFM_ETHER|IFM_AUTO;\n#endif\n\t}\n\n\tif (bmsr & PHY_BMSR_CANAUTONEG) {\n\t\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_AUTO, 0, NULL);\n\t\tsc->ifmedia.ifm_media = IFM_ETHER|IFM_AUTO;\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int16_t vr_phy_readreg",
            "void vr_getmode_mii"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int16_t vr_phy_readreg;\nvoid vr_getmode_mii;\n\nvoid\nvr_getmode_mii(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tu_int16_t\t\tbmsr;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tbmsr = vr_phy_readreg(sc, PHY_BMSR);\n\n\t/* fallback */\n\tsc->ifmedia.ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;\n\n\tif (bmsr & PHY_BMSR_10BTHALF) {\n\t\tifmedia_add(&sc->ifmedia,\n\t\t\tIFM_ETHER|IFM_10_T|IFM_HDX, 0, NULL);\n\t\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_T, 0, NULL);\n\t}\n\n\tif (bmsr & PHY_BMSR_10BTFULL) {\n\t\tifmedia_add(&sc->ifmedia,\n\t\t\tIFM_ETHER|IFM_10_T|IFM_FDX, 0, NULL);\n\t\tsc->ifmedia.ifm_media = IFM_ETHER|IFM_10_T|IFM_FDX;\n\t}\n\n\tif (bmsr & PHY_BMSR_100BTXHALF) {\n\t\tifp->if_baudrate = 100000000;\n\t\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_100_TX, 0, NULL);\n\t\tifmedia_add(&sc->ifmedia,\n\t\t\tIFM_ETHER|IFM_100_TX|IFM_HDX, 0, NULL);\n\t\tsc->ifmedia.ifm_media = IFM_ETHER|IFM_100_TX|IFM_HDX;\n\t}\n\n\tif (bmsr & PHY_BMSR_100BTXFULL) {\n\t\tifp->if_baudrate = 100000000;\n\t\tifmedia_add(&sc->ifmedia,\n\t\t\tIFM_ETHER|IFM_100_TX|IFM_FDX, 0, NULL);\n\t\tsc->ifmedia.ifm_media = IFM_ETHER|IFM_100_TX|IFM_FDX;\n\t}\n\n\t/* Some also support 100BaseT4. */\n\tif (bmsr & PHY_BMSR_100BT4) {\n\t\tifp->if_baudrate = 100000000;\n\t\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_100_T4, 0, NULL);\n\t\tsc->ifmedia.ifm_media = IFM_ETHER|IFM_100_T4;\n#ifdef FORCE_AUTONEG_TFOUR\n\t\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_AUTO, 0 NULL):\n\t\tsc->ifmedia.ifm_media = IFM_ETHER|IFM_AUTO;\n#endif\n\t}\n\n\tif (bmsr & PHY_BMSR_CANAUTONEG) {\n\t\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_AUTO, 0, NULL);\n\t\tsc->ifmedia.ifm_media = IFM_ETHER|IFM_AUTO;\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ifmedia_init",
          "args": [
            "&sc->ifmedia",
            "0",
            "vr_ifmedia_upd",
            "vr_ifmedia_sts"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: MII without any phy!\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vr_phy_readreg",
          "args": [
            "sc",
            "PHY_DEVID"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "vr_phy_readreg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "390-404",
          "snippet": "u_int16_t\nvr_phy_readreg(sc, reg)\n\tstruct vr_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tstruct vr_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->vr_phy_addr;\n\tframe.mii_regaddr = reg;\n\tvr_mii_readreg(sc, &frame);\n\n\treturn(frame.mii_data);\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int vr_mii_readreg",
            "u_int16_t vr_phy_readreg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint vr_mii_readreg;\nu_int16_t vr_phy_readreg;\n\nu_int16_t\nvr_phy_readreg(sc, reg)\n\tstruct vr_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tstruct vr_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->vr_phy_addr;\n\tframe.mii_regaddr = reg;\n\tvr_mii_readreg(sc, &frame);\n\n\treturn(frame.mii_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "500"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vr_phy_writereg",
          "args": [
            "sc",
            "PHY_BMCR",
            "PHY_BMCR_RESET"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "vr_phy_writereg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "406-423",
          "snippet": "void\nvr_phy_writereg(sc, reg, data)\n\tstruct vr_softc\t\t*sc;\n\tu_int16_t\t\treg;\n\tu_int16_t\t\tdata;\n{\n\tstruct vr_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->vr_phy_addr;\n\tframe.mii_regaddr = reg;\n\tframe.mii_data = data;\n\n\tvr_mii_writereg(sc, &frame);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int vr_mii_writereg",
            "void vr_phy_writereg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint vr_mii_writereg;\nvoid vr_phy_writereg;\n\nvoid\nvr_phy_writereg(sc, reg, data)\n\tstruct vr_softc\t\t*sc;\n\tu_int16_t\t\treg;\n\tu_int16_t\t\tdata;\n{\n\tstruct vr_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->vr_phy_addr;\n\tframe.mii_regaddr = reg;\n\tframe.mii_data = data;\n\n\tvr_mii_writereg(sc, &frame);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "sc->sc_dev.dv_xname",
            "ifp->if_xname",
            "IFNAMSIZ"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "sc->vr_ldata",
            "sizeof(struct vr_list_data)"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct vr_list_data) + 8",
            "M_DEVBUF",
            "M_NOWAIT"
          ],
          "line": 1017
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_sprintf",
          "args": [
            "sc->arpcom.ac_enaddr"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_1",
          "args": [
            "sc",
            "VR_PAR0 + i"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "200"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VR_SETBIT",
          "args": [
            "sc",
            "VR_EECSR",
            "VR_EECSR_LOAD"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vr_reset",
          "args": [
            "sc"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "vr_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "830-850",
          "snippet": "void\nvr_reset(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_RESET);\n\n\tfor (i = 0; i < VR_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(CSR_READ_2(sc, VR_COMMAND) & VR_CMD_RESET))\n\t\t\tbreak;\n\t}\n\tif (i == VR_TIMEOUT)\n\t\tprintf(\"%s: reset never completed!\\n\", sc->sc_dev.dv_xname);\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tDELAY(1000);\n\n        return;\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void vr_reset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_reset;\n\nvoid\nvr_reset(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_RESET);\n\n\tfor (i = 0; i < VR_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(CSR_READ_2(sc, VR_COMMAND) & VR_CMD_RESET))\n\t\t\tbreak;\n\t}\n\tif (i == VR_TIMEOUT)\n\t\tprintf(\"%s: reset never completed!\\n\", sc->sc_dev.dv_xname);\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tDELAY(1000);\n\n        return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_intr_establish",
          "args": [
            "pc",
            "ih",
            "IPL_NET",
            "vr_intr",
            "sc",
            "self->dv_xname"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_string",
          "args": [
            "pc",
            "ih"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_map",
          "args": [
            "pc",
            "pa->pa_intrtag",
            "pa->pa_intrpin",
            "pa->pa_intrline",
            "&ih"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "pa->pa_memt",
            "iobase",
            "iosize",
            "0",
            "&sc->vr_bhandle"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_mem_find",
          "args": [
            "pc",
            "pa->pa_tag",
            "VR_PCI_LOMEM",
            "&iobase",
            "&iosize"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "pci_mem_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci_map.c",
          "lines": "197-208",
          "snippet": "int\npci_mem_find(pc, pcitag, reg, membasep, memsizep, cacheablep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *membasep;\n\tbus_size_t *memsizep;\n\tint *cacheablep;\n{\n\treturn (nbsd_pci_mem_find(pc, pcitag, reg, -1, membasep, memsizep,\n\t\t\t\t  cacheablep));\n}",
          "includes": [
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nbsd_pci_mem_find"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int nbsd_pci_mem_find;\n\nint\npci_mem_find(pc, pcitag, reg, membasep, memsizep, cacheablep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *membasep;\n\tbus_size_t *memsizep;\n\tint *cacheablep;\n{\n\treturn (nbsd_pci_mem_find(pc, pcitag, reg, -1, membasep, memsizep,\n\t\t\t\t  cacheablep));\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "pa->pa_iot",
            "iobase",
            "iosize",
            "0",
            "&sc->vr_bhandle"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_io_find",
          "args": [
            "pc",
            "pa->pa_tag",
            "VR_PCI_LOIO",
            "&iobase",
            "&iosize"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "pci_io_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci_map.c",
          "lines": "186-195",
          "snippet": "int\npci_io_find(pc, pcitag, reg, iobasep, iosizep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *iobasep;\n\tbus_size_t *iosizep;\n{\n\treturn (nbsd_pci_io_find(pc, pcitag, reg, 0, iobasep, iosizep, 0));\n}",
          "includes": [
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nbsd_pci_io_find"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int nbsd_pci_io_find;\n\nint\npci_io_find(pc, pcitag, reg, iobasep, iosizep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *iobasep;\n\tbus_size_t *iosizep;\n{\n\treturn (nbsd_pci_io_find(pc, pcitag, reg, 0, iobasep, iosizep, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "PCI_COMMAND_STATUS_REG"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "VR_PCI_INTLINE",
            "irq"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "VR_PCI_LOMEM",
            "membase"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "VR_PCI_LOIO",
            "iobase"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "VR_PCI_PWRMGMTCTRL",
            "command"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "VR_PCI_INTLINE"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "VR_PCI_LOMEM"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "VR_PCI_LOIO"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "VR_PCI_PWRMGMTCTRL"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "VR_PCI_CAPID"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define VR_USEIOSPACE\n\nstatic struct vr_type vr_phys[] = {\n\t{ TI_PHY_VENDORID, TI_PHY_10BT, \"<TI ThunderLAN 10BT (internal)>\" },\n\t{ TI_PHY_VENDORID, TI_PHY_100VGPMI, \"<TI TNETE211 100VG Any-LAN>\" },\n\t{ NS_PHY_VENDORID, NS_PHY_83840A, \"<National Semiconductor DP83840A>\"},\n\t{ LEVEL1_PHY_VENDORID, LEVEL1_PHY_LXT970, \"<Level 1 LXT970>\" },\n\t{ INTEL_PHY_VENDORID, INTEL_PHY_82555, \"<Intel 82555>\" },\n\t{ SEEQ_PHY_VENDORID, SEEQ_PHY_80220, \"<SEEQ 80220>\" },\n\t{ 0, 0, \"<MII-compliant physical interface>\" }\n};\nvoid vr_attach;\nint vr_intr;\nvoid vr_start;\nint vr_ioctl;\nvoid vr_stop;\nvoid vr_watchdog;\nvoid vr_shutdown;\nint vr_ifmedia_upd;\nvoid vr_ifmedia_sts;\nu_int16_t vr_phy_readreg;\nvoid vr_phy_writereg;\nvoid vr_autoneg_mii;\nvoid vr_getmode_mii;\nvoid vr_reset;\n\nvoid\nvr_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tint\t\t\ts, i;\n\tu_char\t\t\teaddr[ETHER_ADDR_LEN];\n\tu_int32_t\t\tcommand;\n\tstruct vr_softc\t\t*sc = (struct vr_softc *)self;\n\tstruct pci_attach_args \t*pa = aux;\n\tpci_chipset_tag_t\tpc = pa->pa_pc;\n\tpci_intr_handle_t\tih;\n\tconst char\t\t*intrstr = NULL;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tbus_addr_t\t\tiobase;\n\tbus_size_t\t\tiosize;\n\tint\t\t\tmedia = IFM_ETHER|IFM_100_TX|IFM_FDX;\n\tunsigned int\t\tround;\n\tcaddr_t\t\t\troundptr;\n\tstruct vr_type\t\t*p;\n\tu_int16_t\t\tphy_vid, phy_did, phy_sts;\n\n\ts = splimp();\n\n\t/*\n\t * Handle power management nonsense.\n\t */\n\tcommand = pci_conf_read(pa->pa_pc, pa->pa_tag,\n\t\t\t\t\tVR_PCI_CAPID) & 0x000000FF;\n\tif (command == 0x01) {\n\t\tcommand = pci_conf_read(pa->pa_pc, pa->pa_tag,\n\t\t\t\t\tVR_PCI_PWRMGMTCTRL);\n\t\tif (command & VR_PSTATE_MASK) {\n\t\t\tu_int32_t\t\tiobase, membase, irq;\n\n\t\t\t/* Save important PCI config data. */\n\t\t\tiobase = pci_conf_read(pa->pa_pc, pa->pa_tag,\n\t\t\t\t\t\tVR_PCI_LOIO);\n\t\t\tmembase = pci_conf_read(pa->pa_pc, pa->pa_tag,\n\t\t\t\t\t\tVR_PCI_LOMEM);\n\t\t\tirq = pci_conf_read(pa->pa_pc, pa->pa_tag,\n\t\t\t\t\t\tVR_PCI_INTLINE);\n\n\t\t\t/* Reset the power state. */\n\t\t\tcommand &= 0xFFFFFFFC;\n\t\t\tpci_conf_write(pa->pa_pc, pa->pa_tag,\n\t\t\t\t\t\tVR_PCI_PWRMGMTCTRL, command);\n\n\t\t\t/* Restore PCI config data. */\n\t\t\tpci_conf_write(pa->pa_pc, pa->pa_tag,\n\t\t\t\t\t\tVR_PCI_LOIO, iobase);\n\t\t\tpci_conf_write(pa->pa_pc, pa->pa_tag,\n\t\t\t\t\t\tVR_PCI_LOMEM, membase);\n\t\t\tpci_conf_write(pa->pa_pc, pa->pa_tag,\n\t\t\t\t\t\tVR_PCI_INTLINE, irq);\n\t\t}\n\t}\n\n\t/*\n\t * Map control/status registers.\n\t */\n\tcommand = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);\n\n#ifdef VR_USEIOSPACE\n\tif (!(command & PCI_COMMAND_IO_ENABLE)) {\n\t\tprintf(\": failed to enable I/O ports\\n\");\n\t\tgoto fail;\n\t}\n\tif (pci_io_find(pc, pa->pa_tag, VR_PCI_LOIO, &iobase, &iosize)) {\n\t\tprintf(\": failed to find i/o space\\n\");\n\t\tgoto fail;\n\t}\n\tif (bus_space_map(pa->pa_iot, iobase, iosize, 0, &sc->vr_bhandle)) {\n\t\tprintf(\": failed map i/o space\\n\");\n\t\tgoto fail;\n\t}\n\tsc->vr_btag = pa->pa_iot;\n#else\n\tif (!(command & PCI_COMMAND_MEM_ENABLE)) {\n\t\tprintf(\": failed to enable memory mapping\\n\");\n\t\tgoto fail;\n\t}\n\tif (pci_mem_find(pc, pa->pa_tag, VR_PCI_LOMEM, &iobase, &iosize)) {\n\t\tprintf(\": failed to find memory space\\n\");\n\t\tgoto fail;\n\t}\n\tif (bus_space_map(pa->pa_memt, iobase, iosize, 0, &sc->vr_bhandle)) {\n\t\tprintf(\": failed map memory space\\n\");\n\t\tgoto fail;\n\t}\n\tsc->vr_btag = pa->pa_memt;\n#endif\n\n\t/* Allocate interrupt */\n\tif (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,\n\t\t\t pa->pa_intrline, &ih)) {\n\t\tprintf(\": couldn't map interrupt\\n\");\n\t\tgoto fail;\n\t}\n\tintrstr = pci_intr_string(pc, ih);\n\tsc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, vr_intr, sc,\n\t\t\t\t       self->dv_xname);\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\": could not establish interrupt\");\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\tgoto fail;\n\t}\n\tprintf(\": %s\", intrstr);\n\n\t/* Reset the adapter. */\n\tvr_reset(sc);\n\n\t/*\n\t * Get station address. The way the Rhine chips work,\n\t * you're not allowed to directly access the EEPROM once\n\t * they've been programmed a special way. Consequently,\n\t * we need to read the node address from the PAR0 and PAR1\n\t * registers.\n\t */\n\tVR_SETBIT(sc, VR_EECSR, VR_EECSR_LOAD);\n\tDELAY(200);\n\tfor (i = 0; i < ETHER_ADDR_LEN; i++)\n\t\teaddr[i] = CSR_READ_1(sc, VR_PAR0 + i);\n\n\t/*\n\t * A Rhine chip was detected. Inform the world.\n\t */\n\tbcopy(eaddr, (char *)&sc->arpcom.ac_enaddr, ETHER_ADDR_LEN);\n\tprintf(\" address %s\\n\", ether_sprintf(sc->arpcom.ac_enaddr));\n\n\tsc->vr_ldata_ptr = malloc(sizeof(struct vr_list_data) + 8,\n\t\t\t\tM_DEVBUF, M_NOWAIT);\n\tif (sc->vr_ldata_ptr == NULL) {\n\t\tprintf(\"%s: no memory for list buffers\\n\", sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\tsc->vr_ldata = (struct vr_list_data *)sc->vr_ldata_ptr;\n\tround = (unsigned int)sc->vr_ldata_ptr & 0xF;\n\troundptr = sc->vr_ldata_ptr;\n\tfor (i = 0; i < 8; i++) {\n\t\tif (round % 8) {\n\t\t\tround++;\n\t\t\troundptr++;\n\t\t} else\n\t\t\tbreak;\n\t}\n\tsc->vr_ldata = (struct vr_list_data *)roundptr;\n\tbzero(sc->vr_ldata, sizeof(struct vr_list_data));\n\n\tifp = &sc->arpcom.ac_if;\n\tifp->if_softc = sc;\n\tifp->if_mtu = ETHERMTU;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;\n\tifp->if_ioctl = vr_ioctl;\n\tifp->if_output = ether_output;\n\tifp->if_start = vr_start;\n\tifp->if_watchdog = vr_watchdog;\n\tifp->if_baudrate = 10000000;\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\n\tfor (i = VR_PHYADDR_MIN; i < VR_PHYADDR_MAX + 1; i++) {\n\t\tsc->vr_phy_addr = i;\n\t\tvr_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);\n\t\tDELAY(500);\n\t\twhile(vr_phy_readreg(sc, PHY_BMCR)\n\t\t\t\t& PHY_BMCR_RESET);\n\t\tif ((phy_sts = vr_phy_readreg(sc, PHY_BMSR)))\n\t\t\tbreak;\n\t}\n\tif (phy_sts) {\n\t\tphy_vid = vr_phy_readreg(sc, PHY_VENID);\n\t\tphy_did = vr_phy_readreg(sc, PHY_DEVID);\n\t\tp = vr_phys;\n\t\twhile(p->vr_vid) {\n\t\t\tif (phy_vid == p->vr_vid &&\n\t\t\t\t(phy_did | 0x000F) == p->vr_did) {\n\t\t\t\tsc->vr_pinfo = p;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\t\tif (sc->vr_pinfo == NULL)\n\t\t\tsc->vr_pinfo = &vr_phys[PHY_UNKNOWN];\n\t} else {\n\t\tprintf(\"%s: MII without any phy!\\n\", sc->sc_dev.dv_xname);\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * Do ifmedia setup.\n\t */\n\tifmedia_init(&sc->ifmedia, 0, vr_ifmedia_upd, vr_ifmedia_sts);\n\n\tvr_getmode_mii(sc);\n\tvr_autoneg_mii(sc, VR_FLAG_FORCEDELAY, 1);\n\tmedia = sc->ifmedia.ifm_media;\n\tvr_stop(sc);\n\n\tifmedia_set(&sc->ifmedia, media);\n\n\t/*\n\t * Call MI attach routines.\n\t */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n#if NBPFILTER > 0\n\tbpfattach(&sc->arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,\n\t\t\tsizeof(struct ether_header));\n#endif\n\tshutdownhook_establish(vr_shutdown, sc);\n\nfail:\n\tsplx(s);\n\treturn;\n}"
  },
  {
    "function_name": "vr_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
    "lines": "855-879",
    "snippet": "int\nvr_probe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct pci_attach_args *pa = (struct pci_attach_args *)aux;\n\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_VIATECH) {\n\t\tswitch (PCI_PRODUCT(pa->pa_id)) {\n\t\tcase PCI_PRODUCT_VIATECH_RHINE:\n\t\tcase PCI_PRODUCT_VIATECH_RHINEII:\n\t\t\treturn (1);\n\t\t}\n\t}\n\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_DELTA &&\n\t    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_DELTA_RHINEII)\n\t\treturn (1);\n\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_ADDTRON &&\n\t    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ADDTRON_RHINEII)\n\t\treturn (1);\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/pci/if_vrreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/device.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int vr_probe"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PCI_PRODUCT",
          "args": [
            "pa->pa_id"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDOR",
          "args": [
            "pa->pa_id"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_PRODUCT",
          "args": [
            "pa->pa_id"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDOR",
          "args": [
            "pa->pa_id"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_PRODUCT",
          "args": [
            "pa->pa_id"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDOR",
          "args": [
            "pa->pa_id"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint vr_probe;\n\nint\nvr_probe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct pci_attach_args *pa = (struct pci_attach_args *)aux;\n\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_VIATECH) {\n\t\tswitch (PCI_PRODUCT(pa->pa_id)) {\n\t\tcase PCI_PRODUCT_VIATECH_RHINE:\n\t\tcase PCI_PRODUCT_VIATECH_RHINEII:\n\t\t\treturn (1);\n\t\t}\n\t}\n\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_DELTA &&\n\t    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_DELTA_RHINEII)\n\t\treturn (1);\n\n\tif (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_ADDTRON &&\n\t    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ADDTRON_RHINEII)\n\t\treturn (1);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "vr_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
    "lines": "830-850",
    "snippet": "void\nvr_reset(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_RESET);\n\n\tfor (i = 0; i < VR_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(CSR_READ_2(sc, VR_COMMAND) & VR_CMD_RESET))\n\t\t\tbreak;\n\t}\n\tif (i == VR_TIMEOUT)\n\t\tprintf(\"%s: reset never completed!\\n\", sc->sc_dev.dv_xname);\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tDELAY(1000);\n\n        return;\n}",
    "includes": [
      "#include <dev/pci/if_vrreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/device.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void vr_reset"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: reset never completed!\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "VR_COMMAND"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VR_SETBIT16",
          "args": [
            "sc",
            "VR_COMMAND",
            "VR_CMD_RESET"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_reset;\n\nvoid\nvr_reset(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_RESET);\n\n\tfor (i = 0; i < VR_TIMEOUT; i++) {\n\t\tDELAY(10);\n\t\tif (!(CSR_READ_2(sc, VR_COMMAND) & VR_CMD_RESET))\n\t\t\tbreak;\n\t}\n\tif (i == VR_TIMEOUT)\n\t\tprintf(\"%s: reset never completed!\\n\", sc->sc_dev.dv_xname);\n\n\t/* Wait a little while for the chip to get its brains in order. */\n\tDELAY(1000);\n\n        return;\n}"
  },
  {
    "function_name": "vr_setcfg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
    "lines": "807-828",
    "snippet": "void\nvr_setcfg(sc, bmcr)\n\tstruct vr_softc\t\t*sc;\n\tu_int16_t\t\tbmcr;\n{\n\tint\t\t\trestart = 0;\n\n\tif (CSR_READ_2(sc, VR_COMMAND) & (VR_CMD_TX_ON|VR_CMD_RX_ON)) {\n\t\trestart = 1;\n\t\tVR_CLRBIT16(sc, VR_COMMAND, (VR_CMD_TX_ON|VR_CMD_RX_ON));\n\t}\n\n\tif (bmcr & PHY_BMCR_DUPLEX)\n\t\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_FULLDUPLEX);\n\telse\n\t\tVR_CLRBIT16(sc, VR_COMMAND, VR_CMD_FULLDUPLEX);\n\n\tif (restart)\n\t\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_TX_ON|VR_CMD_RX_ON);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_vrreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/device.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void vr_setcfg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VR_SETBIT16",
          "args": [
            "sc",
            "VR_COMMAND",
            "VR_CMD_TX_ON|VR_CMD_RX_ON"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VR_CLRBIT16",
          "args": [
            "sc",
            "VR_COMMAND",
            "VR_CMD_FULLDUPLEX"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VR_SETBIT16",
          "args": [
            "sc",
            "VR_COMMAND",
            "VR_CMD_FULLDUPLEX"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VR_CLRBIT16",
          "args": [
            "sc",
            "VR_COMMAND",
            "(VR_CMD_TX_ON|VR_CMD_RX_ON)"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "VR_COMMAND"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_setcfg;\n\nvoid\nvr_setcfg(sc, bmcr)\n\tstruct vr_softc\t\t*sc;\n\tu_int16_t\t\tbmcr;\n{\n\tint\t\t\trestart = 0;\n\n\tif (CSR_READ_2(sc, VR_COMMAND) & (VR_CMD_TX_ON|VR_CMD_RX_ON)) {\n\t\trestart = 1;\n\t\tVR_CLRBIT16(sc, VR_COMMAND, (VR_CMD_TX_ON|VR_CMD_RX_ON));\n\t}\n\n\tif (bmcr & PHY_BMCR_DUPLEX)\n\t\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_FULLDUPLEX);\n\telse\n\t\tVR_CLRBIT16(sc, VR_COMMAND, VR_CMD_FULLDUPLEX);\n\n\tif (restart)\n\t\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_TX_ON|VR_CMD_RX_ON);\n\n\treturn;\n}"
  },
  {
    "function_name": "vr_setmode_mii",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
    "lines": "744-800",
    "snippet": "void\nvr_setmode_mii(sc, media)\n\tstruct vr_softc\t\t*sc;\n\tint\t\t\tmedia;\n{\n\tu_int16_t\t\tbmcr;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/*\n\t * If an autoneg session is in progress, stop it.\n\t */\n\tif (sc->vr_autoneg) {\n\t\tprintf(\"%s: canceling autoneg session\\n\", sc->sc_dev.dv_xname);\n\t\tifp->if_timer = sc->vr_autoneg = sc->vr_want_auto = 0;\n\t\tbmcr = vr_phy_readreg(sc, PHY_BMCR);\n\t\tbmcr &= ~PHY_BMCR_AUTONEGENBL;\n\t\tvr_phy_writereg(sc, PHY_BMCR, bmcr);\n\t}\n\n\tprintf(\"%s: selecting MII, \", sc->sc_dev.dv_xname);\n\n\tbmcr = vr_phy_readreg(sc, PHY_BMCR);\n\n\tbmcr &= ~(PHY_BMCR_AUTONEGENBL|PHY_BMCR_SPEEDSEL|\n\t\t\tPHY_BMCR_DUPLEX|PHY_BMCR_LOOPBK);\n\n\tif (IFM_SUBTYPE(media) == IFM_100_T4) {\n\t\tprintf(\"100Mbps/T4, half-duplex\\n\");\n\t\tbmcr |= PHY_BMCR_SPEEDSEL;\n\t\tbmcr &= ~PHY_BMCR_DUPLEX;\n\t}\n\n\tif (IFM_SUBTYPE(media) == IFM_100_TX) {\n\t\tprintf(\"100Mbps, \");\n\t\tbmcr |= PHY_BMCR_SPEEDSEL;\n\t}\n\n\tif (IFM_SUBTYPE(media) == IFM_10_T) {\n\t\tprintf(\"10Mbps, \");\n\t\tbmcr &= ~PHY_BMCR_SPEEDSEL;\n\t}\n\n\tif ((media & IFM_GMASK) == IFM_FDX) {\n\t\tprintf(\"full duplex\\n\");\n\t\tbmcr |= PHY_BMCR_DUPLEX;\n\t} else {\n\t\tprintf(\"half duplex\\n\");\n\t\tbmcr &= ~PHY_BMCR_DUPLEX;\n\t}\n\n\tvr_setcfg(sc, bmcr);\n\tvr_phy_writereg(sc, PHY_BMCR, bmcr);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_vrreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/device.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "u_int16_t vr_phy_readreg",
      "void vr_phy_writereg",
      "void vr_setmode_mii",
      "void vr_setcfg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vr_phy_writereg",
          "args": [
            "sc",
            "PHY_BMCR",
            "bmcr"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "vr_phy_writereg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "406-423",
          "snippet": "void\nvr_phy_writereg(sc, reg, data)\n\tstruct vr_softc\t\t*sc;\n\tu_int16_t\t\treg;\n\tu_int16_t\t\tdata;\n{\n\tstruct vr_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->vr_phy_addr;\n\tframe.mii_regaddr = reg;\n\tframe.mii_data = data;\n\n\tvr_mii_writereg(sc, &frame);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int vr_mii_writereg",
            "void vr_phy_writereg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint vr_mii_writereg;\nvoid vr_phy_writereg;\n\nvoid\nvr_phy_writereg(sc, reg, data)\n\tstruct vr_softc\t\t*sc;\n\tu_int16_t\t\treg;\n\tu_int16_t\t\tdata;\n{\n\tstruct vr_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->vr_phy_addr;\n\tframe.mii_regaddr = reg;\n\tframe.mii_data = data;\n\n\tvr_mii_writereg(sc, &frame);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vr_setcfg",
          "args": [
            "sc",
            "bmcr"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "vr_setcfg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "807-828",
          "snippet": "void\nvr_setcfg(sc, bmcr)\n\tstruct vr_softc\t\t*sc;\n\tu_int16_t\t\tbmcr;\n{\n\tint\t\t\trestart = 0;\n\n\tif (CSR_READ_2(sc, VR_COMMAND) & (VR_CMD_TX_ON|VR_CMD_RX_ON)) {\n\t\trestart = 1;\n\t\tVR_CLRBIT16(sc, VR_COMMAND, (VR_CMD_TX_ON|VR_CMD_RX_ON));\n\t}\n\n\tif (bmcr & PHY_BMCR_DUPLEX)\n\t\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_FULLDUPLEX);\n\telse\n\t\tVR_CLRBIT16(sc, VR_COMMAND, VR_CMD_FULLDUPLEX);\n\n\tif (restart)\n\t\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_TX_ON|VR_CMD_RX_ON);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void vr_setcfg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_setcfg;\n\nvoid\nvr_setcfg(sc, bmcr)\n\tstruct vr_softc\t\t*sc;\n\tu_int16_t\t\tbmcr;\n{\n\tint\t\t\trestart = 0;\n\n\tif (CSR_READ_2(sc, VR_COMMAND) & (VR_CMD_TX_ON|VR_CMD_RX_ON)) {\n\t\trestart = 1;\n\t\tVR_CLRBIT16(sc, VR_COMMAND, (VR_CMD_TX_ON|VR_CMD_RX_ON));\n\t}\n\n\tif (bmcr & PHY_BMCR_DUPLEX)\n\t\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_FULLDUPLEX);\n\telse\n\t\tVR_CLRBIT16(sc, VR_COMMAND, VR_CMD_FULLDUPLEX);\n\n\tif (restart)\n\t\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_TX_ON|VR_CMD_RX_ON);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"half duplex\\n\""
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "media"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "media"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "media"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vr_phy_readreg",
          "args": [
            "sc",
            "PHY_BMCR"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "vr_phy_readreg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "390-404",
          "snippet": "u_int16_t\nvr_phy_readreg(sc, reg)\n\tstruct vr_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tstruct vr_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->vr_phy_addr;\n\tframe.mii_regaddr = reg;\n\tvr_mii_readreg(sc, &frame);\n\n\treturn(frame.mii_data);\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int vr_mii_readreg",
            "u_int16_t vr_phy_readreg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint vr_mii_readreg;\nu_int16_t vr_phy_readreg;\n\nu_int16_t\nvr_phy_readreg(sc, reg)\n\tstruct vr_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tstruct vr_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->vr_phy_addr;\n\tframe.mii_regaddr = reg;\n\tvr_mii_readreg(sc, &frame);\n\n\treturn(frame.mii_data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int16_t vr_phy_readreg;\nvoid vr_phy_writereg;\nvoid vr_setmode_mii;\nvoid vr_setcfg;\n\nvoid\nvr_setmode_mii(sc, media)\n\tstruct vr_softc\t\t*sc;\n\tint\t\t\tmedia;\n{\n\tu_int16_t\t\tbmcr;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\t/*\n\t * If an autoneg session is in progress, stop it.\n\t */\n\tif (sc->vr_autoneg) {\n\t\tprintf(\"%s: canceling autoneg session\\n\", sc->sc_dev.dv_xname);\n\t\tifp->if_timer = sc->vr_autoneg = sc->vr_want_auto = 0;\n\t\tbmcr = vr_phy_readreg(sc, PHY_BMCR);\n\t\tbmcr &= ~PHY_BMCR_AUTONEGENBL;\n\t\tvr_phy_writereg(sc, PHY_BMCR, bmcr);\n\t}\n\n\tprintf(\"%s: selecting MII, \", sc->sc_dev.dv_xname);\n\n\tbmcr = vr_phy_readreg(sc, PHY_BMCR);\n\n\tbmcr &= ~(PHY_BMCR_AUTONEGENBL|PHY_BMCR_SPEEDSEL|\n\t\t\tPHY_BMCR_DUPLEX|PHY_BMCR_LOOPBK);\n\n\tif (IFM_SUBTYPE(media) == IFM_100_T4) {\n\t\tprintf(\"100Mbps/T4, half-duplex\\n\");\n\t\tbmcr |= PHY_BMCR_SPEEDSEL;\n\t\tbmcr &= ~PHY_BMCR_DUPLEX;\n\t}\n\n\tif (IFM_SUBTYPE(media) == IFM_100_TX) {\n\t\tprintf(\"100Mbps, \");\n\t\tbmcr |= PHY_BMCR_SPEEDSEL;\n\t}\n\n\tif (IFM_SUBTYPE(media) == IFM_10_T) {\n\t\tprintf(\"10Mbps, \");\n\t\tbmcr &= ~PHY_BMCR_SPEEDSEL;\n\t}\n\n\tif ((media & IFM_GMASK) == IFM_FDX) {\n\t\tprintf(\"full duplex\\n\");\n\t\tbmcr |= PHY_BMCR_DUPLEX;\n\t} else {\n\t\tprintf(\"half duplex\\n\");\n\t\tbmcr &= ~PHY_BMCR_DUPLEX;\n\t}\n\n\tvr_setcfg(sc, bmcr);\n\tvr_phy_writereg(sc, PHY_BMCR, bmcr);\n\n\treturn;\n}"
  },
  {
    "function_name": "vr_getmode_mii",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
    "lines": "681-739",
    "snippet": "void\nvr_getmode_mii(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tu_int16_t\t\tbmsr;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tbmsr = vr_phy_readreg(sc, PHY_BMSR);\n\n\t/* fallback */\n\tsc->ifmedia.ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;\n\n\tif (bmsr & PHY_BMSR_10BTHALF) {\n\t\tifmedia_add(&sc->ifmedia,\n\t\t\tIFM_ETHER|IFM_10_T|IFM_HDX, 0, NULL);\n\t\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_T, 0, NULL);\n\t}\n\n\tif (bmsr & PHY_BMSR_10BTFULL) {\n\t\tifmedia_add(&sc->ifmedia,\n\t\t\tIFM_ETHER|IFM_10_T|IFM_FDX, 0, NULL);\n\t\tsc->ifmedia.ifm_media = IFM_ETHER|IFM_10_T|IFM_FDX;\n\t}\n\n\tif (bmsr & PHY_BMSR_100BTXHALF) {\n\t\tifp->if_baudrate = 100000000;\n\t\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_100_TX, 0, NULL);\n\t\tifmedia_add(&sc->ifmedia,\n\t\t\tIFM_ETHER|IFM_100_TX|IFM_HDX, 0, NULL);\n\t\tsc->ifmedia.ifm_media = IFM_ETHER|IFM_100_TX|IFM_HDX;\n\t}\n\n\tif (bmsr & PHY_BMSR_100BTXFULL) {\n\t\tifp->if_baudrate = 100000000;\n\t\tifmedia_add(&sc->ifmedia,\n\t\t\tIFM_ETHER|IFM_100_TX|IFM_FDX, 0, NULL);\n\t\tsc->ifmedia.ifm_media = IFM_ETHER|IFM_100_TX|IFM_FDX;\n\t}\n\n\t/* Some also support 100BaseT4. */\n\tif (bmsr & PHY_BMSR_100BT4) {\n\t\tifp->if_baudrate = 100000000;\n\t\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_100_T4, 0, NULL);\n\t\tsc->ifmedia.ifm_media = IFM_ETHER|IFM_100_T4;\n#ifdef FORCE_AUTONEG_TFOUR\n\t\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_AUTO, 0 NULL):\n\t\tsc->ifmedia.ifm_media = IFM_ETHER|IFM_AUTO;\n#endif\n\t}\n\n\tif (bmsr & PHY_BMSR_CANAUTONEG) {\n\t\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_AUTO, 0, NULL);\n\t\tsc->ifmedia.ifm_media = IFM_ETHER|IFM_AUTO;\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_vrreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/device.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "u_int16_t vr_phy_readreg",
      "void vr_getmode_mii"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->ifmedia",
            "IFM_ETHER|IFM_AUTO",
            "0",
            "NULL"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->ifmedia",
            "IFM_ETHER|IFM_AUTO",
            "0NULL"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->ifmedia",
            "IFM_ETHER|IFM_100_T4",
            "0",
            "NULL"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->ifmedia",
            "IFM_ETHER|IFM_100_TX|IFM_FDX",
            "0",
            "NULL"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->ifmedia",
            "IFM_ETHER|IFM_100_TX|IFM_HDX",
            "0",
            "NULL"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->ifmedia",
            "IFM_ETHER|IFM_100_TX",
            "0",
            "NULL"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->ifmedia",
            "IFM_ETHER|IFM_10_T|IFM_FDX",
            "0",
            "NULL"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->ifmedia",
            "IFM_ETHER|IFM_10_T",
            "0",
            "NULL"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->ifmedia",
            "IFM_ETHER|IFM_10_T|IFM_HDX",
            "0",
            "NULL"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vr_phy_readreg",
          "args": [
            "sc",
            "PHY_BMSR"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "vr_phy_readreg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "390-404",
          "snippet": "u_int16_t\nvr_phy_readreg(sc, reg)\n\tstruct vr_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tstruct vr_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->vr_phy_addr;\n\tframe.mii_regaddr = reg;\n\tvr_mii_readreg(sc, &frame);\n\n\treturn(frame.mii_data);\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int vr_mii_readreg",
            "u_int16_t vr_phy_readreg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint vr_mii_readreg;\nu_int16_t vr_phy_readreg;\n\nu_int16_t\nvr_phy_readreg(sc, reg)\n\tstruct vr_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tstruct vr_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->vr_phy_addr;\n\tframe.mii_regaddr = reg;\n\tvr_mii_readreg(sc, &frame);\n\n\treturn(frame.mii_data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int16_t vr_phy_readreg;\nvoid vr_getmode_mii;\n\nvoid\nvr_getmode_mii(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tu_int16_t\t\tbmsr;\n\tstruct ifnet\t\t*ifp;\n\n\tifp = &sc->arpcom.ac_if;\n\n\tbmsr = vr_phy_readreg(sc, PHY_BMSR);\n\n\t/* fallback */\n\tsc->ifmedia.ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;\n\n\tif (bmsr & PHY_BMSR_10BTHALF) {\n\t\tifmedia_add(&sc->ifmedia,\n\t\t\tIFM_ETHER|IFM_10_T|IFM_HDX, 0, NULL);\n\t\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_T, 0, NULL);\n\t}\n\n\tif (bmsr & PHY_BMSR_10BTFULL) {\n\t\tifmedia_add(&sc->ifmedia,\n\t\t\tIFM_ETHER|IFM_10_T|IFM_FDX, 0, NULL);\n\t\tsc->ifmedia.ifm_media = IFM_ETHER|IFM_10_T|IFM_FDX;\n\t}\n\n\tif (bmsr & PHY_BMSR_100BTXHALF) {\n\t\tifp->if_baudrate = 100000000;\n\t\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_100_TX, 0, NULL);\n\t\tifmedia_add(&sc->ifmedia,\n\t\t\tIFM_ETHER|IFM_100_TX|IFM_HDX, 0, NULL);\n\t\tsc->ifmedia.ifm_media = IFM_ETHER|IFM_100_TX|IFM_HDX;\n\t}\n\n\tif (bmsr & PHY_BMSR_100BTXFULL) {\n\t\tifp->if_baudrate = 100000000;\n\t\tifmedia_add(&sc->ifmedia,\n\t\t\tIFM_ETHER|IFM_100_TX|IFM_FDX, 0, NULL);\n\t\tsc->ifmedia.ifm_media = IFM_ETHER|IFM_100_TX|IFM_FDX;\n\t}\n\n\t/* Some also support 100BaseT4. */\n\tif (bmsr & PHY_BMSR_100BT4) {\n\t\tifp->if_baudrate = 100000000;\n\t\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_100_T4, 0, NULL);\n\t\tsc->ifmedia.ifm_media = IFM_ETHER|IFM_100_T4;\n#ifdef FORCE_AUTONEG_TFOUR\n\t\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_AUTO, 0 NULL):\n\t\tsc->ifmedia.ifm_media = IFM_ETHER|IFM_AUTO;\n#endif\n\t}\n\n\tif (bmsr & PHY_BMSR_CANAUTONEG) {\n\t\tifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_AUTO, 0, NULL);\n\t\tsc->ifmedia.ifm_media = IFM_ETHER|IFM_AUTO;\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "vr_autoneg_mii",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
    "lines": "535-679",
    "snippet": "void\nvr_autoneg_mii(sc, flag, verbose)\n\tstruct vr_softc\t\t*sc;\n\tint\t\t\tflag;\n\tint\t\t\tverbose;\n{\n\tu_int16_t\t\tphy_sts = 0, media, advert, ability;\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmedia\t\t*ifm;\n\n\tifm = &sc->ifmedia;\n\tifp = &sc->arpcom.ac_if;\n\n\tifm->ifm_media = IFM_ETHER | IFM_AUTO;\n\n\t/*\n\t * The 100baseT4 PHY on the 3c905-T4 has the 'autoneg supported'\n\t * bit cleared in the status register, but has the 'autoneg enabled'\n\t * bit set in the control register. This is a contradiction, and\n\t * I'm not sure how to handle it. If you want to force an attempt\n\t * to autoneg for 100baseT4 PHYs, #define FORCE_AUTONEG_TFOUR\n\t * and see what happens.\n\t */\n#ifndef FORCE_AUTONEG_TFOUR\n\t/*\n\t * First, see if autoneg is supported. If not, there's\n\t * no point in continuing.\n\t */\n\tphy_sts = vr_phy_readreg(sc, PHY_BMSR);\n\tif (!(phy_sts & PHY_BMSR_CANAUTONEG)) {\n\t\tif (verbose)\n\t\t\tprintf(\"%s: autonegotiation not supported\\n\",\n\t\t\t\t\t\t\tsc->sc_dev.dv_xname);\n\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;\t\n\t\treturn;\n\t}\n#endif\n\n\tswitch (flag) {\n\tcase VR_FLAG_FORCEDELAY:\n\t\t/*\n\t \t * XXX Never use this option anywhere but in the probe\n\t \t * routine: making the kernel stop dead in its tracks\n \t\t * for three whole seconds after we've gone multi-user\n\t\t * is really bad manners.\n\t \t */\n\t\tvr_autoneg_xmit(sc);\n\t\tDELAY(5000000);\n\t\tbreak;\n\tcase VR_FLAG_SCHEDDELAY:\n\t\t/*\n\t\t * Wait for the transmitter to go idle before starting\n\t\t * an autoneg session, otherwise vr_start() may clobber\n\t \t * our timeout, and we don't want to allow transmission\n\t\t * during an autoneg session since that can screw it up.\n\t \t */\n\t\tif (sc->vr_cdata.vr_tx_head != NULL) {\n\t\t\tsc->vr_want_auto = 1;\n\t\t\treturn;\n\t\t}\n\t\tvr_autoneg_xmit(sc);\n\t\tifp->if_timer = 5;\n\t\tsc->vr_autoneg = 1;\n\t\tsc->vr_want_auto = 0;\n\t\treturn;\n\t\tbreak;\n\tcase VR_FLAG_DELAYTIMEO:\n\t\tifp->if_timer = 0;\n\t\tsc->vr_autoneg = 0;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: invalid autoneg flag: %d\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname, flag);\n\t\treturn;\n\t}\n\n\tif (vr_phy_readreg(sc, PHY_BMSR) & PHY_BMSR_AUTONEGCOMP) {\n\t\tif (verbose)\n\t\t\tprintf(\"%s: autoneg complete, \", sc->sc_dev.dv_xname);\n\t\tphy_sts = vr_phy_readreg(sc, PHY_BMSR);\n\t} else {\n\t\tif (verbose)\n\t\t\tprintf(\"%s: autoneg not complete, \",\n\t\t\t\t\t\tsc->sc_dev.dv_xname);\n\t}\n\n\tmedia = vr_phy_readreg(sc, PHY_BMCR);\n\n\t/* Link is good. Report modes and set duplex mode. */\n\tif (vr_phy_readreg(sc, PHY_BMSR) & PHY_BMSR_LINKSTAT) {\n\t\tif (verbose)\n\t\t\tprintf(\"link status good \");\n\t\tadvert = vr_phy_readreg(sc, PHY_ANAR);\n\t\tability = vr_phy_readreg(sc, PHY_LPAR);\n\n\t\tif (advert & PHY_ANAR_100BT4 && ability & PHY_ANAR_100BT4) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_T4;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(100baseT4)\\n\");\n\t\t} else if (advert & PHY_ANAR_100BTXFULL &&\n\t\t\tability & PHY_ANAR_100BTXFULL) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_FDX;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia |= PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(full-duplex, 100Mbps)\\n\");\n\t\t} else if (advert & PHY_ANAR_100BTXHALF &&\n\t\t\tability & PHY_ANAR_100BTXHALF) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_HDX;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(half-duplex, 100Mbps)\\n\");\n\t\t} else if (advert & PHY_ANAR_10BTFULL &&\n\t\t\tability & PHY_ANAR_10BTFULL) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_FDX;\n\t\t\tmedia &= ~PHY_BMCR_SPEEDSEL;\n\t\t\tmedia |= PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(full-duplex, 10Mbps)\\n\");\n\t\t} else {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;\n\t\t\tmedia &= ~PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(half-duplex, 10Mbps)\\n\");\n\t\t}\n\n\t\tmedia &= ~PHY_BMCR_AUTONEGENBL;\n\n\t\t/* Set ASIC's duplex mode to match the PHY. */\n\t\tvr_setcfg(sc, media);\n\t\tvr_phy_writereg(sc, PHY_BMCR, media);\n\t} else {\n\t\tif (verbose)\n\t\t\tprintf(\"no carrier\\n\");\n\t}\n\n\tvr_init(sc);\n\n\tif (sc->vr_tx_pend) {\n\t\tsc->vr_autoneg = 0;\n\t\tsc->vr_tx_pend = 0;\n\t\tvr_start(ifp);\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_vrreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/device.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void vr_start",
      "void vr_init",
      "u_int16_t vr_phy_readreg",
      "void vr_phy_writereg",
      "void vr_autoneg_xmit",
      "void vr_autoneg_mii",
      "void vr_setcfg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vr_start",
          "args": [
            "ifp"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "vr_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "1558-1628",
          "snippet": "void\nvr_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct vr_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head = NULL;\n\tstruct vr_chain\t\t*cur_tx = NULL, *start_tx;\n\n\tsc = ifp->if_softc;\n\n\tif (sc->vr_autoneg) {\n\t\tsc->vr_tx_pend = 1;\n\t\treturn;\n\t}\n\n\t/*\n\t * Check for an available queue slot. If there are none,\n\t * punt.\n\t */\n\tif (sc->vr_cdata.vr_tx_free->vr_mbuf != NULL) {\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\n\tstart_tx = sc->vr_cdata.vr_tx_free;\n\n\twhile(sc->vr_cdata.vr_tx_free->vr_mbuf == NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\t/* Pick a descriptor off the free list. */\n\t\tcur_tx = sc->vr_cdata.vr_tx_free;\n\t\tsc->vr_cdata.vr_tx_free = cur_tx->vr_nextdesc;\n\n\t\t/* Pack the data into the descriptor. */\n\t\tvr_encap(sc, cur_tx, m_head);\n\n\t\tif (cur_tx != start_tx)\n\t\t\tVR_TXOWN(cur_tx) = VR_TXSTAT_OWN;\n\n#if NBPFILTER > 0\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, cur_tx->vr_mbuf);\n#endif\n\t\tVR_TXOWN(cur_tx) = VR_TXSTAT_OWN;\n\t\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_TX_ON|VR_CMD_TX_GO);\n\t}\n\n\t/*\n\t * If there are no frames queued, bail.\n\t */\n\tif (cur_tx == NULL)\n\t\treturn;\n\n\tsc->vr_cdata.vr_tx_tail = cur_tx;\n\n\tif (sc->vr_cdata.vr_tx_head == NULL)\n\t\tsc->vr_cdata.vr_tx_head = start_tx;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int vr_encap",
            "void vr_start"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint vr_encap;\nvoid vr_start;\n\nvoid\nvr_start(ifp)\n\tstruct ifnet\t\t*ifp;\n{\n\tstruct vr_softc\t\t*sc;\n\tstruct mbuf\t\t*m_head = NULL;\n\tstruct vr_chain\t\t*cur_tx = NULL, *start_tx;\n\n\tsc = ifp->if_softc;\n\n\tif (sc->vr_autoneg) {\n\t\tsc->vr_tx_pend = 1;\n\t\treturn;\n\t}\n\n\t/*\n\t * Check for an available queue slot. If there are none,\n\t * punt.\n\t */\n\tif (sc->vr_cdata.vr_tx_free->vr_mbuf != NULL) {\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t\treturn;\n\t}\n\n\tstart_tx = sc->vr_cdata.vr_tx_free;\n\n\twhile(sc->vr_cdata.vr_tx_free->vr_mbuf == NULL) {\n\t\tIF_DEQUEUE(&ifp->if_snd, m_head);\n\t\tif (m_head == NULL)\n\t\t\tbreak;\n\n\t\t/* Pick a descriptor off the free list. */\n\t\tcur_tx = sc->vr_cdata.vr_tx_free;\n\t\tsc->vr_cdata.vr_tx_free = cur_tx->vr_nextdesc;\n\n\t\t/* Pack the data into the descriptor. */\n\t\tvr_encap(sc, cur_tx, m_head);\n\n\t\tif (cur_tx != start_tx)\n\t\t\tVR_TXOWN(cur_tx) = VR_TXSTAT_OWN;\n\n#if NBPFILTER > 0\n\t\t/*\n\t\t * If there's a BPF listener, bounce a copy of this frame\n\t\t * to him.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, cur_tx->vr_mbuf);\n#endif\n\t\tVR_TXOWN(cur_tx) = VR_TXSTAT_OWN;\n\t\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_TX_ON|VR_CMD_TX_GO);\n\t}\n\n\t/*\n\t * If there are no frames queued, bail.\n\t */\n\tif (cur_tx == NULL)\n\t\treturn;\n\n\tsc->vr_cdata.vr_tx_tail = cur_tx;\n\n\tif (sc->vr_cdata.vr_tx_head == NULL)\n\t\tsc->vr_cdata.vr_tx_head = start_tx;\n\n\t/*\n\t * Set a timeout in case the chip goes out to lunch.\n\t */\n\tifp->if_timer = 5;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vr_init",
          "args": [
            "sc"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "vr_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "1630-1720",
          "snippet": "void\nvr_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct vr_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tu_int16_t\t\tphy_bmcr = 0;\n\tint\t\t\ts;\n\n\tif (sc->vr_autoneg)\n\t\treturn;\n\n\ts = splimp();\n\n\tif (sc->vr_pinfo != NULL)\n\t\tphy_bmcr = vr_phy_readreg(sc, PHY_BMCR);\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\tvr_stop(sc);\n\tvr_reset(sc);\n\n\tVR_CLRBIT(sc, VR_RXCFG, VR_RXCFG_RX_THRESH);\n\tVR_SETBIT(sc, VR_RXCFG, VR_RXTHRESH_STORENFWD);\n\n\tVR_CLRBIT(sc, VR_TXCFG, VR_TXCFG_TX_THRESH);\n\tVR_SETBIT(sc, VR_TXCFG, VR_TXTHRESH_STORENFWD);\n\n\t/* Init circular RX list. */\n\tif (vr_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: initialization failed: no memory for rx buffers\\n\",\n\t\t\t\t\t\t\tsc->sc_dev.dv_xname);\n\t\tvr_stop(sc);\n\t\t(void)splx(s);\n\t\treturn;\n\t}\n\n\t/*\n\t * Init tx descriptors.\n\t */\n\tvr_list_tx_init(sc);\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tVR_SETBIT(sc, VR_RXCFG, VR_RXCFG_RX_PROMISC);\n\telse\n\t\tVR_CLRBIT(sc, VR_RXCFG, VR_RXCFG_RX_PROMISC);\n\n\t/* Set capture broadcast bit to capture broadcast frames. */\n\tif (ifp->if_flags & IFF_BROADCAST)\n\t\tVR_SETBIT(sc, VR_RXCFG, VR_RXCFG_RX_BROAD);\n\telse\n\t\tVR_CLRBIT(sc, VR_RXCFG, VR_RXCFG_RX_BROAD);\n\n\t/*\n\t * Program the multicast filter, if necessary.\n\t */\n\tvr_setmulti(sc);\n\n\t/*\n\t * Load the address of the RX list.\n\t */\n\tCSR_WRITE_4(sc, VR_RXADDR, vtophys(sc->vr_cdata.vr_rx_head->vr_ptr));\n\n\t/* Enable receiver and transmitter. */\n\tCSR_WRITE_2(sc, VR_COMMAND, VR_CMD_TX_NOPOLL|VR_CMD_START|\n\t\t\t\t    VR_CMD_TX_ON|VR_CMD_RX_ON|\n\t\t\t\t    VR_CMD_RX_GO);\n\n\tvr_setcfg(sc, vr_phy_readreg(sc, PHY_BMCR));\n\n\tCSR_WRITE_4(sc, VR_TXADDR, vtophys(&sc->vr_ldata->vr_tx_list[0]));\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_2(sc, VR_ISR, 0xFFFF);\n\tCSR_WRITE_2(sc, VR_IMR, VR_INTRS);\n\n\t/* Restore state of BMCR */\n\tif (sc->vr_pinfo != NULL)\n\t\tvr_phy_writereg(sc, PHY_BMCR, phy_bmcr);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void vr_init",
            "void vr_stop",
            "u_int16_t vr_phy_readreg",
            "void vr_phy_writereg",
            "void vr_setcfg",
            "void vr_setmulti",
            "void vr_reset",
            "int vr_list_rx_init",
            "int vr_list_tx_init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_init;\nvoid vr_stop;\nu_int16_t vr_phy_readreg;\nvoid vr_phy_writereg;\nvoid vr_setcfg;\nvoid vr_setmulti;\nvoid vr_reset;\nint vr_list_rx_init;\nint vr_list_tx_init;\n\nvoid\nvr_init(xsc)\n\tvoid\t\t\t*xsc;\n{\n\tstruct vr_softc\t\t*sc = xsc;\n\tstruct ifnet\t\t*ifp = &sc->arpcom.ac_if;\n\tu_int16_t\t\tphy_bmcr = 0;\n\tint\t\t\ts;\n\n\tif (sc->vr_autoneg)\n\t\treturn;\n\n\ts = splimp();\n\n\tif (sc->vr_pinfo != NULL)\n\t\tphy_bmcr = vr_phy_readreg(sc, PHY_BMCR);\n\n\t/*\n\t * Cancel pending I/O and free all RX/TX buffers.\n\t */\n\tvr_stop(sc);\n\tvr_reset(sc);\n\n\tVR_CLRBIT(sc, VR_RXCFG, VR_RXCFG_RX_THRESH);\n\tVR_SETBIT(sc, VR_RXCFG, VR_RXTHRESH_STORENFWD);\n\n\tVR_CLRBIT(sc, VR_TXCFG, VR_TXCFG_TX_THRESH);\n\tVR_SETBIT(sc, VR_TXCFG, VR_TXTHRESH_STORENFWD);\n\n\t/* Init circular RX list. */\n\tif (vr_list_rx_init(sc) == ENOBUFS) {\n\t\tprintf(\"%s: initialization failed: no memory for rx buffers\\n\",\n\t\t\t\t\t\t\tsc->sc_dev.dv_xname);\n\t\tvr_stop(sc);\n\t\t(void)splx(s);\n\t\treturn;\n\t}\n\n\t/*\n\t * Init tx descriptors.\n\t */\n\tvr_list_tx_init(sc);\n\n\t/* If we want promiscuous mode, set the allframes bit. */\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tVR_SETBIT(sc, VR_RXCFG, VR_RXCFG_RX_PROMISC);\n\telse\n\t\tVR_CLRBIT(sc, VR_RXCFG, VR_RXCFG_RX_PROMISC);\n\n\t/* Set capture broadcast bit to capture broadcast frames. */\n\tif (ifp->if_flags & IFF_BROADCAST)\n\t\tVR_SETBIT(sc, VR_RXCFG, VR_RXCFG_RX_BROAD);\n\telse\n\t\tVR_CLRBIT(sc, VR_RXCFG, VR_RXCFG_RX_BROAD);\n\n\t/*\n\t * Program the multicast filter, if necessary.\n\t */\n\tvr_setmulti(sc);\n\n\t/*\n\t * Load the address of the RX list.\n\t */\n\tCSR_WRITE_4(sc, VR_RXADDR, vtophys(sc->vr_cdata.vr_rx_head->vr_ptr));\n\n\t/* Enable receiver and transmitter. */\n\tCSR_WRITE_2(sc, VR_COMMAND, VR_CMD_TX_NOPOLL|VR_CMD_START|\n\t\t\t\t    VR_CMD_TX_ON|VR_CMD_RX_ON|\n\t\t\t\t    VR_CMD_RX_GO);\n\n\tvr_setcfg(sc, vr_phy_readreg(sc, PHY_BMCR));\n\n\tCSR_WRITE_4(sc, VR_TXADDR, vtophys(&sc->vr_ldata->vr_tx_list[0]));\n\n\t/*\n\t * Enable interrupts.\n\t */\n\tCSR_WRITE_2(sc, VR_ISR, 0xFFFF);\n\tCSR_WRITE_2(sc, VR_IMR, VR_INTRS);\n\n\t/* Restore state of BMCR */\n\tif (sc->vr_pinfo != NULL)\n\t\tvr_phy_writereg(sc, PHY_BMCR, phy_bmcr);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\t(void)splx(s);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"no carrier\\n\""
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vr_phy_writereg",
          "args": [
            "sc",
            "PHY_BMCR",
            "media"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "vr_phy_writereg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "406-423",
          "snippet": "void\nvr_phy_writereg(sc, reg, data)\n\tstruct vr_softc\t\t*sc;\n\tu_int16_t\t\treg;\n\tu_int16_t\t\tdata;\n{\n\tstruct vr_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->vr_phy_addr;\n\tframe.mii_regaddr = reg;\n\tframe.mii_data = data;\n\n\tvr_mii_writereg(sc, &frame);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int vr_mii_writereg",
            "void vr_phy_writereg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint vr_mii_writereg;\nvoid vr_phy_writereg;\n\nvoid\nvr_phy_writereg(sc, reg, data)\n\tstruct vr_softc\t\t*sc;\n\tu_int16_t\t\treg;\n\tu_int16_t\t\tdata;\n{\n\tstruct vr_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->vr_phy_addr;\n\tframe.mii_regaddr = reg;\n\tframe.mii_data = data;\n\n\tvr_mii_writereg(sc, &frame);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vr_setcfg",
          "args": [
            "sc",
            "media"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "vr_setcfg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "807-828",
          "snippet": "void\nvr_setcfg(sc, bmcr)\n\tstruct vr_softc\t\t*sc;\n\tu_int16_t\t\tbmcr;\n{\n\tint\t\t\trestart = 0;\n\n\tif (CSR_READ_2(sc, VR_COMMAND) & (VR_CMD_TX_ON|VR_CMD_RX_ON)) {\n\t\trestart = 1;\n\t\tVR_CLRBIT16(sc, VR_COMMAND, (VR_CMD_TX_ON|VR_CMD_RX_ON));\n\t}\n\n\tif (bmcr & PHY_BMCR_DUPLEX)\n\t\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_FULLDUPLEX);\n\telse\n\t\tVR_CLRBIT16(sc, VR_COMMAND, VR_CMD_FULLDUPLEX);\n\n\tif (restart)\n\t\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_TX_ON|VR_CMD_RX_ON);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void vr_setcfg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_setcfg;\n\nvoid\nvr_setcfg(sc, bmcr)\n\tstruct vr_softc\t\t*sc;\n\tu_int16_t\t\tbmcr;\n{\n\tint\t\t\trestart = 0;\n\n\tif (CSR_READ_2(sc, VR_COMMAND) & (VR_CMD_TX_ON|VR_CMD_RX_ON)) {\n\t\trestart = 1;\n\t\tVR_CLRBIT16(sc, VR_COMMAND, (VR_CMD_TX_ON|VR_CMD_RX_ON));\n\t}\n\n\tif (bmcr & PHY_BMCR_DUPLEX)\n\t\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_FULLDUPLEX);\n\telse\n\t\tVR_CLRBIT16(sc, VR_COMMAND, VR_CMD_FULLDUPLEX);\n\n\tif (restart)\n\t\tVR_SETBIT16(sc, VR_COMMAND, VR_CMD_TX_ON|VR_CMD_RX_ON);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vr_phy_readreg",
          "args": [
            "sc",
            "PHY_LPAR"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "vr_phy_readreg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "390-404",
          "snippet": "u_int16_t\nvr_phy_readreg(sc, reg)\n\tstruct vr_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tstruct vr_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->vr_phy_addr;\n\tframe.mii_regaddr = reg;\n\tvr_mii_readreg(sc, &frame);\n\n\treturn(frame.mii_data);\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int vr_mii_readreg",
            "u_int16_t vr_phy_readreg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint vr_mii_readreg;\nu_int16_t vr_phy_readreg;\n\nu_int16_t\nvr_phy_readreg(sc, reg)\n\tstruct vr_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tstruct vr_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->vr_phy_addr;\n\tframe.mii_regaddr = reg;\n\tvr_mii_readreg(sc, &frame);\n\n\treturn(frame.mii_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vr_autoneg_xmit",
          "args": [
            "sc"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "vr_autoneg_xmit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "514-530",
          "snippet": "void\nvr_autoneg_xmit(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tu_int16_t\t\tphy_sts;\n\n\tvr_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);\n\tDELAY(500);\n\twhile(vr_phy_readreg(sc, PHY_BMCR)\n\t\t\t& PHY_BMCR_RESET);\n\n\tphy_sts = vr_phy_readreg(sc, PHY_BMCR);\n\tphy_sts |= PHY_BMCR_AUTONEGENBL|PHY_BMCR_AUTONEGRSTR;\n\tvr_phy_writereg(sc, PHY_BMCR, phy_sts);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int16_t vr_phy_readreg",
            "void vr_phy_writereg",
            "void vr_autoneg_xmit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int16_t vr_phy_readreg;\nvoid vr_phy_writereg;\nvoid vr_autoneg_xmit;\n\nvoid\nvr_autoneg_xmit(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tu_int16_t\t\tphy_sts;\n\n\tvr_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);\n\tDELAY(500);\n\twhile(vr_phy_readreg(sc, PHY_BMCR)\n\t\t\t& PHY_BMCR_RESET);\n\n\tphy_sts = vr_phy_readreg(sc, PHY_BMCR);\n\tphy_sts |= PHY_BMCR_AUTONEGENBL|PHY_BMCR_AUTONEGRSTR;\n\tvr_phy_writereg(sc, PHY_BMCR, phy_sts);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "5000000"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_start;\nvoid vr_init;\nu_int16_t vr_phy_readreg;\nvoid vr_phy_writereg;\nvoid vr_autoneg_xmit;\nvoid vr_autoneg_mii;\nvoid vr_setcfg;\n\nvoid\nvr_autoneg_mii(sc, flag, verbose)\n\tstruct vr_softc\t\t*sc;\n\tint\t\t\tflag;\n\tint\t\t\tverbose;\n{\n\tu_int16_t\t\tphy_sts = 0, media, advert, ability;\n\tstruct ifnet\t\t*ifp;\n\tstruct ifmedia\t\t*ifm;\n\n\tifm = &sc->ifmedia;\n\tifp = &sc->arpcom.ac_if;\n\n\tifm->ifm_media = IFM_ETHER | IFM_AUTO;\n\n\t/*\n\t * The 100baseT4 PHY on the 3c905-T4 has the 'autoneg supported'\n\t * bit cleared in the status register, but has the 'autoneg enabled'\n\t * bit set in the control register. This is a contradiction, and\n\t * I'm not sure how to handle it. If you want to force an attempt\n\t * to autoneg for 100baseT4 PHYs, #define FORCE_AUTONEG_TFOUR\n\t * and see what happens.\n\t */\n#ifndef FORCE_AUTONEG_TFOUR\n\t/*\n\t * First, see if autoneg is supported. If not, there's\n\t * no point in continuing.\n\t */\n\tphy_sts = vr_phy_readreg(sc, PHY_BMSR);\n\tif (!(phy_sts & PHY_BMSR_CANAUTONEG)) {\n\t\tif (verbose)\n\t\t\tprintf(\"%s: autonegotiation not supported\\n\",\n\t\t\t\t\t\t\tsc->sc_dev.dv_xname);\n\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;\t\n\t\treturn;\n\t}\n#endif\n\n\tswitch (flag) {\n\tcase VR_FLAG_FORCEDELAY:\n\t\t/*\n\t \t * XXX Never use this option anywhere but in the probe\n\t \t * routine: making the kernel stop dead in its tracks\n \t\t * for three whole seconds after we've gone multi-user\n\t\t * is really bad manners.\n\t \t */\n\t\tvr_autoneg_xmit(sc);\n\t\tDELAY(5000000);\n\t\tbreak;\n\tcase VR_FLAG_SCHEDDELAY:\n\t\t/*\n\t\t * Wait for the transmitter to go idle before starting\n\t\t * an autoneg session, otherwise vr_start() may clobber\n\t \t * our timeout, and we don't want to allow transmission\n\t\t * during an autoneg session since that can screw it up.\n\t \t */\n\t\tif (sc->vr_cdata.vr_tx_head != NULL) {\n\t\t\tsc->vr_want_auto = 1;\n\t\t\treturn;\n\t\t}\n\t\tvr_autoneg_xmit(sc);\n\t\tifp->if_timer = 5;\n\t\tsc->vr_autoneg = 1;\n\t\tsc->vr_want_auto = 0;\n\t\treturn;\n\t\tbreak;\n\tcase VR_FLAG_DELAYTIMEO:\n\t\tifp->if_timer = 0;\n\t\tsc->vr_autoneg = 0;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%s: invalid autoneg flag: %d\\n\",\n\t\t\t\t\t\tsc->sc_dev.dv_xname, flag);\n\t\treturn;\n\t}\n\n\tif (vr_phy_readreg(sc, PHY_BMSR) & PHY_BMSR_AUTONEGCOMP) {\n\t\tif (verbose)\n\t\t\tprintf(\"%s: autoneg complete, \", sc->sc_dev.dv_xname);\n\t\tphy_sts = vr_phy_readreg(sc, PHY_BMSR);\n\t} else {\n\t\tif (verbose)\n\t\t\tprintf(\"%s: autoneg not complete, \",\n\t\t\t\t\t\tsc->sc_dev.dv_xname);\n\t}\n\n\tmedia = vr_phy_readreg(sc, PHY_BMCR);\n\n\t/* Link is good. Report modes and set duplex mode. */\n\tif (vr_phy_readreg(sc, PHY_BMSR) & PHY_BMSR_LINKSTAT) {\n\t\tif (verbose)\n\t\t\tprintf(\"link status good \");\n\t\tadvert = vr_phy_readreg(sc, PHY_ANAR);\n\t\tability = vr_phy_readreg(sc, PHY_LPAR);\n\n\t\tif (advert & PHY_ANAR_100BT4 && ability & PHY_ANAR_100BT4) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_T4;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(100baseT4)\\n\");\n\t\t} else if (advert & PHY_ANAR_100BTXFULL &&\n\t\t\tability & PHY_ANAR_100BTXFULL) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_FDX;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia |= PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(full-duplex, 100Mbps)\\n\");\n\t\t} else if (advert & PHY_ANAR_100BTXHALF &&\n\t\t\tability & PHY_ANAR_100BTXHALF) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_HDX;\n\t\t\tmedia |= PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(half-duplex, 100Mbps)\\n\");\n\t\t} else if (advert & PHY_ANAR_10BTFULL &&\n\t\t\tability & PHY_ANAR_10BTFULL) {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_FDX;\n\t\t\tmedia &= ~PHY_BMCR_SPEEDSEL;\n\t\t\tmedia |= PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(full-duplex, 10Mbps)\\n\");\n\t\t} else {\n\t\t\tifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;\n\t\t\tmedia &= ~PHY_BMCR_SPEEDSEL;\n\t\t\tmedia &= ~PHY_BMCR_DUPLEX;\n\t\t\tprintf(\"(half-duplex, 10Mbps)\\n\");\n\t\t}\n\n\t\tmedia &= ~PHY_BMCR_AUTONEGENBL;\n\n\t\t/* Set ASIC's duplex mode to match the PHY. */\n\t\tvr_setcfg(sc, media);\n\t\tvr_phy_writereg(sc, PHY_BMCR, media);\n\t} else {\n\t\tif (verbose)\n\t\t\tprintf(\"no carrier\\n\");\n\t}\n\n\tvr_init(sc);\n\n\tif (sc->vr_tx_pend) {\n\t\tsc->vr_autoneg = 0;\n\t\tsc->vr_tx_pend = 0;\n\t\tvr_start(ifp);\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "vr_autoneg_xmit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
    "lines": "514-530",
    "snippet": "void\nvr_autoneg_xmit(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tu_int16_t\t\tphy_sts;\n\n\tvr_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);\n\tDELAY(500);\n\twhile(vr_phy_readreg(sc, PHY_BMCR)\n\t\t\t& PHY_BMCR_RESET);\n\n\tphy_sts = vr_phy_readreg(sc, PHY_BMCR);\n\tphy_sts |= PHY_BMCR_AUTONEGENBL|PHY_BMCR_AUTONEGRSTR;\n\tvr_phy_writereg(sc, PHY_BMCR, phy_sts);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_vrreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/device.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "u_int16_t vr_phy_readreg",
      "void vr_phy_writereg",
      "void vr_autoneg_xmit"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vr_phy_writereg",
          "args": [
            "sc",
            "PHY_BMCR",
            "phy_sts"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "vr_phy_writereg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "406-423",
          "snippet": "void\nvr_phy_writereg(sc, reg, data)\n\tstruct vr_softc\t\t*sc;\n\tu_int16_t\t\treg;\n\tu_int16_t\t\tdata;\n{\n\tstruct vr_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->vr_phy_addr;\n\tframe.mii_regaddr = reg;\n\tframe.mii_data = data;\n\n\tvr_mii_writereg(sc, &frame);\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int vr_mii_writereg",
            "void vr_phy_writereg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint vr_mii_writereg;\nvoid vr_phy_writereg;\n\nvoid\nvr_phy_writereg(sc, reg, data)\n\tstruct vr_softc\t\t*sc;\n\tu_int16_t\t\treg;\n\tu_int16_t\t\tdata;\n{\n\tstruct vr_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->vr_phy_addr;\n\tframe.mii_regaddr = reg;\n\tframe.mii_data = data;\n\n\tvr_mii_writereg(sc, &frame);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vr_phy_readreg",
          "args": [
            "sc",
            "PHY_BMCR"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "vr_phy_readreg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "390-404",
          "snippet": "u_int16_t\nvr_phy_readreg(sc, reg)\n\tstruct vr_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tstruct vr_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->vr_phy_addr;\n\tframe.mii_regaddr = reg;\n\tvr_mii_readreg(sc, &frame);\n\n\treturn(frame.mii_data);\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int vr_mii_readreg",
            "u_int16_t vr_phy_readreg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint vr_mii_readreg;\nu_int16_t vr_phy_readreg;\n\nu_int16_t\nvr_phy_readreg(sc, reg)\n\tstruct vr_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tstruct vr_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->vr_phy_addr;\n\tframe.mii_regaddr = reg;\n\tvr_mii_readreg(sc, &frame);\n\n\treturn(frame.mii_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "500"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int16_t vr_phy_readreg;\nvoid vr_phy_writereg;\nvoid vr_autoneg_xmit;\n\nvoid\nvr_autoneg_xmit(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tu_int16_t\t\tphy_sts;\n\n\tvr_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);\n\tDELAY(500);\n\twhile(vr_phy_readreg(sc, PHY_BMCR)\n\t\t\t& PHY_BMCR_RESET);\n\n\tphy_sts = vr_phy_readreg(sc, PHY_BMCR);\n\tphy_sts |= PHY_BMCR_AUTONEGENBL|PHY_BMCR_AUTONEGRSTR;\n\tvr_phy_writereg(sc, PHY_BMCR, phy_sts);\n\n\treturn;\n}"
  },
  {
    "function_name": "vr_setmulti",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
    "lines": "457-509",
    "snippet": "void\nvr_setmulti(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\th = 0;\n\tu_int32_t\t\thashes[2] = { 0, 0 };\n\tstruct arpcom *ac = &sc->arpcom;\n\tstruct ether_multi *enm;\n\tstruct ether_multistep step;\n\tu_int8_t\t\trxfilt;\n\tint\t\t\tmcnt = 0;\n\n\tifp = &sc->arpcom.ac_if;\n\n\trxfilt = CSR_READ_1(sc, VR_RXCFG);\n\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\trxfilt |= VR_RXCFG_RX_MULTI;\n\t\tCSR_WRITE_1(sc, VR_RXCFG, rxfilt);\n\t\tCSR_WRITE_4(sc, VR_MAR0, 0xFFFFFFFF);\n\t\tCSR_WRITE_4(sc, VR_MAR1, 0xFFFFFFFF);\n\t\treturn;\n\t}\n\n\t/* first, zot all the existing hash bits */\n\tCSR_WRITE_4(sc, VR_MAR0, 0);\n\tCSR_WRITE_4(sc, VR_MAR1, 0);\n\n\t/* now program new ones */\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\th = vr_calchash(enm->enm_addrlo);\n\t\tif (h < 32)\n\t\t\thashes[0] |= (1 << h);\n\t\telse\n\t\t\thashes[1] |= (1 << (h - 32));\n\t\tmcnt++;\n\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\n\tif (mcnt)\n\t\trxfilt |= VR_RXCFG_RX_MULTI;\n\telse\n\t\trxfilt &= ~VR_RXCFG_RX_MULTI;\n\n\tCSR_WRITE_4(sc, VR_MAR0, hashes[0]);\n\tCSR_WRITE_4(sc, VR_MAR1, hashes[1]);\n\tCSR_WRITE_1(sc, VR_RXCFG, rxfilt);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_vrreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/device.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "u_int8_t vr_calchash",
      "void vr_setmulti"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_1",
          "args": [
            "sc",
            "VR_RXCFG",
            "rxfilt"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "VR_MAR1",
            "hashes[1]"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "VR_MAR0",
            "hashes[0]"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ETHER_NEXT_MULTI",
          "args": [
            "step",
            "enm"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vr_calchash",
          "args": [
            "enm->enm_addrlo"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "vr_calchash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "428-452",
          "snippet": "u_int8_t\nvr_calchash(addr)\n\tu_int8_t\t\t*addr;\n{\n\tu_int32_t\t\tcrc, carry;\n\tint\t\t\ti, j;\n\tu_int8_t\t\tc;\n\n\t/* Compute CRC for the address value. */\n\tcrc = 0xFFFFFFFF; /* initial value */\n\n\tfor (i = 0; i < 6; i++) {\n\t\tc = *(addr + i);\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tcarry = ((crc & 0x80000000) ? 1 : 0) ^ (c & 0x01);\n\t\t\tcrc <<= 1;\n\t\t\tc >>= 1;\n\t\t\tif (carry)\n\t\t\t\tcrc = (crc ^ 0x04c11db6) | carry;\n\t\t}\n\t}\n\n\t/* return the filter bit position */\n\treturn((crc >> 26) & 0x0000003F);\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "u_int8_t vr_calchash"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int8_t vr_calchash;\n\nu_int8_t\nvr_calchash(addr)\n\tu_int8_t\t\t*addr;\n{\n\tu_int32_t\t\tcrc, carry;\n\tint\t\t\ti, j;\n\tu_int8_t\t\tc;\n\n\t/* Compute CRC for the address value. */\n\tcrc = 0xFFFFFFFF; /* initial value */\n\n\tfor (i = 0; i < 6; i++) {\n\t\tc = *(addr + i);\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tcarry = ((crc & 0x80000000) ? 1 : 0) ^ (c & 0x01);\n\t\t\tcrc <<= 1;\n\t\t\tc >>= 1;\n\t\t\tif (carry)\n\t\t\t\tcrc = (crc ^ 0x04c11db6) | carry;\n\t\t}\n\t}\n\n\t/* return the filter bit position */\n\treturn((crc >> 26) & 0x0000003F);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ETHER_FIRST_MULTI",
          "args": [
            "step",
            "ac",
            "enm"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "VR_MAR1",
            "0"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "VR_MAR0",
            "0"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "VR_MAR1",
            "0xFFFFFFFF"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "VR_MAR0",
            "0xFFFFFFFF"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_1",
          "args": [
            "sc",
            "VR_RXCFG",
            "rxfilt"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_1",
          "args": [
            "sc",
            "VR_RXCFG"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int8_t vr_calchash;\nvoid vr_setmulti;\n\nvoid\nvr_setmulti(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tstruct ifnet\t\t*ifp;\n\tint\t\t\th = 0;\n\tu_int32_t\t\thashes[2] = { 0, 0 };\n\tstruct arpcom *ac = &sc->arpcom;\n\tstruct ether_multi *enm;\n\tstruct ether_multistep step;\n\tu_int8_t\t\trxfilt;\n\tint\t\t\tmcnt = 0;\n\n\tifp = &sc->arpcom.ac_if;\n\n\trxfilt = CSR_READ_1(sc, VR_RXCFG);\n\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\trxfilt |= VR_RXCFG_RX_MULTI;\n\t\tCSR_WRITE_1(sc, VR_RXCFG, rxfilt);\n\t\tCSR_WRITE_4(sc, VR_MAR0, 0xFFFFFFFF);\n\t\tCSR_WRITE_4(sc, VR_MAR1, 0xFFFFFFFF);\n\t\treturn;\n\t}\n\n\t/* first, zot all the existing hash bits */\n\tCSR_WRITE_4(sc, VR_MAR0, 0);\n\tCSR_WRITE_4(sc, VR_MAR1, 0);\n\n\t/* now program new ones */\n\tETHER_FIRST_MULTI(step, ac, enm);\n\twhile (enm != NULL) {\n\t\th = vr_calchash(enm->enm_addrlo);\n\t\tif (h < 32)\n\t\t\thashes[0] |= (1 << h);\n\t\telse\n\t\t\thashes[1] |= (1 << (h - 32));\n\t\tmcnt++;\n\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\n\tif (mcnt)\n\t\trxfilt |= VR_RXCFG_RX_MULTI;\n\telse\n\t\trxfilt &= ~VR_RXCFG_RX_MULTI;\n\n\tCSR_WRITE_4(sc, VR_MAR0, hashes[0]);\n\tCSR_WRITE_4(sc, VR_MAR1, hashes[1]);\n\tCSR_WRITE_1(sc, VR_RXCFG, rxfilt);\n\n\treturn;\n}"
  },
  {
    "function_name": "vr_calchash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
    "lines": "428-452",
    "snippet": "u_int8_t\nvr_calchash(addr)\n\tu_int8_t\t\t*addr;\n{\n\tu_int32_t\t\tcrc, carry;\n\tint\t\t\ti, j;\n\tu_int8_t\t\tc;\n\n\t/* Compute CRC for the address value. */\n\tcrc = 0xFFFFFFFF; /* initial value */\n\n\tfor (i = 0; i < 6; i++) {\n\t\tc = *(addr + i);\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tcarry = ((crc & 0x80000000) ? 1 : 0) ^ (c & 0x01);\n\t\t\tcrc <<= 1;\n\t\t\tc >>= 1;\n\t\t\tif (carry)\n\t\t\t\tcrc = (crc ^ 0x04c11db6) | carry;\n\t\t}\n\t}\n\n\t/* return the filter bit position */\n\treturn((crc >> 26) & 0x0000003F);\n}",
    "includes": [
      "#include <dev/pci/if_vrreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/device.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "u_int8_t vr_calchash"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nu_int8_t vr_calchash;\n\nu_int8_t\nvr_calchash(addr)\n\tu_int8_t\t\t*addr;\n{\n\tu_int32_t\t\tcrc, carry;\n\tint\t\t\ti, j;\n\tu_int8_t\t\tc;\n\n\t/* Compute CRC for the address value. */\n\tcrc = 0xFFFFFFFF; /* initial value */\n\n\tfor (i = 0; i < 6; i++) {\n\t\tc = *(addr + i);\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tcarry = ((crc & 0x80000000) ? 1 : 0) ^ (c & 0x01);\n\t\t\tcrc <<= 1;\n\t\t\tc >>= 1;\n\t\t\tif (carry)\n\t\t\t\tcrc = (crc ^ 0x04c11db6) | carry;\n\t\t}\n\t}\n\n\t/* return the filter bit position */\n\treturn((crc >> 26) & 0x0000003F);\n}"
  },
  {
    "function_name": "vr_phy_writereg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
    "lines": "406-423",
    "snippet": "void\nvr_phy_writereg(sc, reg, data)\n\tstruct vr_softc\t\t*sc;\n\tu_int16_t\t\treg;\n\tu_int16_t\t\tdata;\n{\n\tstruct vr_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->vr_phy_addr;\n\tframe.mii_regaddr = reg;\n\tframe.mii_data = data;\n\n\tvr_mii_writereg(sc, &frame);\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_vrreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/device.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int vr_mii_writereg",
      "void vr_phy_writereg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vr_mii_writereg",
          "args": [
            "sc",
            "&frame"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "vr_mii_writereg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "339-388",
          "snippet": "int\nvr_mii_writereg(sc, frame)\n\tstruct vr_softc\t\t*sc;\n\tstruct vr_mii_frame\t*frame;\n\t\n{\n\tint\t\t\ts;\n\n\ts = splimp();\n\n\tCSR_WRITE_1(sc, VR_MIICMD, 0);\n\tVR_SETBIT(sc, VR_MIICMD, VR_MIICMD_DIRECTPGM);\n\n\t/*\n\t * Set up frame for TX.\n\t */\n\n\tframe->mii_stdelim = VR_MII_STARTDELIM;\n\tframe->mii_opcode = VR_MII_WRITEOP;\n\tframe->mii_turnaround = VR_MII_TURNAROUND;\n\t\n\t/*\n \t * Turn on data output.\n\t */\n\tSIO_SET(VR_MIICMD_DIR);\n\n\tvr_mii_sync(sc);\n\n\tvr_mii_send(sc, frame->mii_stdelim, 2);\n\tvr_mii_send(sc, frame->mii_opcode, 2);\n\tvr_mii_send(sc, frame->mii_phyaddr, 5);\n\tvr_mii_send(sc, frame->mii_regaddr, 5);\n\tvr_mii_send(sc, frame->mii_turnaround, 2);\n\tvr_mii_send(sc, frame->mii_data, 16);\n\n\t/* Idle bit. */\n\tSIO_SET(VR_MIICMD_CLK);\n\tDELAY(1);\n\tSIO_CLR(VR_MIICMD_CLK);\n\tDELAY(1);\n\n\t/*\n\t * Turn off xmit.\n\t */\n\tSIO_CLR(VR_MIICMD_DIR);\n\n\tsplx(s);\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void vr_mii_sync",
            "void vr_mii_send",
            "int vr_mii_writereg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_mii_sync;\nvoid vr_mii_send;\nint vr_mii_writereg;\n\nint\nvr_mii_writereg(sc, frame)\n\tstruct vr_softc\t\t*sc;\n\tstruct vr_mii_frame\t*frame;\n\t\n{\n\tint\t\t\ts;\n\n\ts = splimp();\n\n\tCSR_WRITE_1(sc, VR_MIICMD, 0);\n\tVR_SETBIT(sc, VR_MIICMD, VR_MIICMD_DIRECTPGM);\n\n\t/*\n\t * Set up frame for TX.\n\t */\n\n\tframe->mii_stdelim = VR_MII_STARTDELIM;\n\tframe->mii_opcode = VR_MII_WRITEOP;\n\tframe->mii_turnaround = VR_MII_TURNAROUND;\n\t\n\t/*\n \t * Turn on data output.\n\t */\n\tSIO_SET(VR_MIICMD_DIR);\n\n\tvr_mii_sync(sc);\n\n\tvr_mii_send(sc, frame->mii_stdelim, 2);\n\tvr_mii_send(sc, frame->mii_opcode, 2);\n\tvr_mii_send(sc, frame->mii_phyaddr, 5);\n\tvr_mii_send(sc, frame->mii_regaddr, 5);\n\tvr_mii_send(sc, frame->mii_turnaround, 2);\n\tvr_mii_send(sc, frame->mii_data, 16);\n\n\t/* Idle bit. */\n\tSIO_SET(VR_MIICMD_CLK);\n\tDELAY(1);\n\tSIO_CLR(VR_MIICMD_CLK);\n\tDELAY(1);\n\n\t/*\n\t * Turn off xmit.\n\t */\n\tSIO_CLR(VR_MIICMD_DIR);\n\n\tsplx(s);\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)&frame",
            "sizeof(frame)"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint vr_mii_writereg;\nvoid vr_phy_writereg;\n\nvoid\nvr_phy_writereg(sc, reg, data)\n\tstruct vr_softc\t\t*sc;\n\tu_int16_t\t\treg;\n\tu_int16_t\t\tdata;\n{\n\tstruct vr_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->vr_phy_addr;\n\tframe.mii_regaddr = reg;\n\tframe.mii_data = data;\n\n\tvr_mii_writereg(sc, &frame);\n\n\treturn;\n}"
  },
  {
    "function_name": "vr_phy_readreg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
    "lines": "390-404",
    "snippet": "u_int16_t\nvr_phy_readreg(sc, reg)\n\tstruct vr_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tstruct vr_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->vr_phy_addr;\n\tframe.mii_regaddr = reg;\n\tvr_mii_readreg(sc, &frame);\n\n\treturn(frame.mii_data);\n}",
    "includes": [
      "#include <dev/pci/if_vrreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/device.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int vr_mii_readreg",
      "u_int16_t vr_phy_readreg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vr_mii_readreg",
          "args": [
            "sc",
            "&frame"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "vr_mii_readreg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "244-334",
          "snippet": "int\nvr_mii_readreg(sc, frame)\n\tstruct vr_softc\t\t*sc;\n\tstruct vr_mii_frame\t*frame;\n\t\n{\n\tint\t\t\ti, ack, s;\n\n\ts = splimp();\n\n\t/*\n\t * Set up frame for RX.\n\t */\n\tframe->mii_stdelim = VR_MII_STARTDELIM;\n\tframe->mii_opcode = VR_MII_READOP;\n\tframe->mii_turnaround = 0;\n\tframe->mii_data = 0;\n\t\n\tCSR_WRITE_1(sc, VR_MIICMD, 0);\n\tVR_SETBIT(sc, VR_MIICMD, VR_MIICMD_DIRECTPGM);\n\n\t/*\n \t * Turn on data xmit.\n\t */\n\tSIO_SET(VR_MIICMD_DIR);\n\n\tvr_mii_sync(sc);\n\n\t/*\n\t * Send command/address info.\n\t */\n\tvr_mii_send(sc, frame->mii_stdelim, 2);\n\tvr_mii_send(sc, frame->mii_opcode, 2);\n\tvr_mii_send(sc, frame->mii_phyaddr, 5);\n\tvr_mii_send(sc, frame->mii_regaddr, 5);\n\n\t/* Idle bit */\n\tSIO_CLR((VR_MIICMD_CLK|VR_MIICMD_DATAIN));\n\tDELAY(1);\n\tSIO_SET(VR_MIICMD_CLK);\n\tDELAY(1);\n\n\t/* Turn off xmit. */\n\tSIO_CLR(VR_MIICMD_DIR);\n\n\t/* Check for ack */\n\tSIO_CLR(VR_MIICMD_CLK);\n\tDELAY(1);\n\tSIO_SET(VR_MIICMD_CLK);\n\tDELAY(1);\n\tack = CSR_READ_4(sc, VR_MIICMD) & VR_MIICMD_DATAOUT;\n\n\t/*\n\t * Now try reading data bits. If the ack failed, we still\n\t * need to clock through 16 cycles to keep the PHY(s) in sync.\n\t */\n\tif (ack) {\n\t\tfor(i = 0; i < 16; i++) {\n\t\t\tSIO_CLR(VR_MIICMD_CLK);\n\t\t\tDELAY(1);\n\t\t\tSIO_SET(VR_MIICMD_CLK);\n\t\t\tDELAY(1);\n\t\t}\n\t\tgoto fail;\n\t}\n\n\tfor (i = 0x8000; i; i >>= 1) {\n\t\tSIO_CLR(VR_MIICMD_CLK);\n\t\tDELAY(1);\n\t\tif (!ack) {\n\t\t\tif (CSR_READ_4(sc, VR_MIICMD) & VR_MIICMD_DATAOUT)\n\t\t\t\tframe->mii_data |= i;\n\t\t\tDELAY(1);\n\t\t}\n\t\tSIO_SET(VR_MIICMD_CLK);\n\t\tDELAY(1);\n\t}\n\nfail:\n\n\tSIO_CLR(VR_MIICMD_CLK);\n\tDELAY(1);\n\tSIO_SET(VR_MIICMD_CLK);\n\tDELAY(1);\n\n\tsplx(s);\n\n\tif (ack)\n\t\treturn(1);\n\treturn(0);\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void vr_mii_sync",
            "void vr_mii_send",
            "int vr_mii_readreg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_mii_sync;\nvoid vr_mii_send;\nint vr_mii_readreg;\n\nint\nvr_mii_readreg(sc, frame)\n\tstruct vr_softc\t\t*sc;\n\tstruct vr_mii_frame\t*frame;\n\t\n{\n\tint\t\t\ti, ack, s;\n\n\ts = splimp();\n\n\t/*\n\t * Set up frame for RX.\n\t */\n\tframe->mii_stdelim = VR_MII_STARTDELIM;\n\tframe->mii_opcode = VR_MII_READOP;\n\tframe->mii_turnaround = 0;\n\tframe->mii_data = 0;\n\t\n\tCSR_WRITE_1(sc, VR_MIICMD, 0);\n\tVR_SETBIT(sc, VR_MIICMD, VR_MIICMD_DIRECTPGM);\n\n\t/*\n \t * Turn on data xmit.\n\t */\n\tSIO_SET(VR_MIICMD_DIR);\n\n\tvr_mii_sync(sc);\n\n\t/*\n\t * Send command/address info.\n\t */\n\tvr_mii_send(sc, frame->mii_stdelim, 2);\n\tvr_mii_send(sc, frame->mii_opcode, 2);\n\tvr_mii_send(sc, frame->mii_phyaddr, 5);\n\tvr_mii_send(sc, frame->mii_regaddr, 5);\n\n\t/* Idle bit */\n\tSIO_CLR((VR_MIICMD_CLK|VR_MIICMD_DATAIN));\n\tDELAY(1);\n\tSIO_SET(VR_MIICMD_CLK);\n\tDELAY(1);\n\n\t/* Turn off xmit. */\n\tSIO_CLR(VR_MIICMD_DIR);\n\n\t/* Check for ack */\n\tSIO_CLR(VR_MIICMD_CLK);\n\tDELAY(1);\n\tSIO_SET(VR_MIICMD_CLK);\n\tDELAY(1);\n\tack = CSR_READ_4(sc, VR_MIICMD) & VR_MIICMD_DATAOUT;\n\n\t/*\n\t * Now try reading data bits. If the ack failed, we still\n\t * need to clock through 16 cycles to keep the PHY(s) in sync.\n\t */\n\tif (ack) {\n\t\tfor(i = 0; i < 16; i++) {\n\t\t\tSIO_CLR(VR_MIICMD_CLK);\n\t\t\tDELAY(1);\n\t\t\tSIO_SET(VR_MIICMD_CLK);\n\t\t\tDELAY(1);\n\t\t}\n\t\tgoto fail;\n\t}\n\n\tfor (i = 0x8000; i; i >>= 1) {\n\t\tSIO_CLR(VR_MIICMD_CLK);\n\t\tDELAY(1);\n\t\tif (!ack) {\n\t\t\tif (CSR_READ_4(sc, VR_MIICMD) & VR_MIICMD_DATAOUT)\n\t\t\t\tframe->mii_data |= i;\n\t\t\tDELAY(1);\n\t\t}\n\t\tSIO_SET(VR_MIICMD_CLK);\n\t\tDELAY(1);\n\t}\n\nfail:\n\n\tSIO_CLR(VR_MIICMD_CLK);\n\tDELAY(1);\n\tSIO_SET(VR_MIICMD_CLK);\n\tDELAY(1);\n\n\tsplx(s);\n\n\tif (ack)\n\t\treturn(1);\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *)&frame",
            "sizeof(frame)"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint vr_mii_readreg;\nu_int16_t vr_phy_readreg;\n\nu_int16_t\nvr_phy_readreg(sc, reg)\n\tstruct vr_softc\t\t*sc;\n\tint\t\t\treg;\n{\n\tstruct vr_mii_frame\tframe;\n\n\tbzero((char *)&frame, sizeof(frame));\n\n\tframe.mii_phyaddr = sc->vr_phy_addr;\n\tframe.mii_regaddr = reg;\n\tvr_mii_readreg(sc, &frame);\n\n\treturn(frame.mii_data);\n}"
  },
  {
    "function_name": "vr_mii_writereg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
    "lines": "339-388",
    "snippet": "int\nvr_mii_writereg(sc, frame)\n\tstruct vr_softc\t\t*sc;\n\tstruct vr_mii_frame\t*frame;\n\t\n{\n\tint\t\t\ts;\n\n\ts = splimp();\n\n\tCSR_WRITE_1(sc, VR_MIICMD, 0);\n\tVR_SETBIT(sc, VR_MIICMD, VR_MIICMD_DIRECTPGM);\n\n\t/*\n\t * Set up frame for TX.\n\t */\n\n\tframe->mii_stdelim = VR_MII_STARTDELIM;\n\tframe->mii_opcode = VR_MII_WRITEOP;\n\tframe->mii_turnaround = VR_MII_TURNAROUND;\n\t\n\t/*\n \t * Turn on data output.\n\t */\n\tSIO_SET(VR_MIICMD_DIR);\n\n\tvr_mii_sync(sc);\n\n\tvr_mii_send(sc, frame->mii_stdelim, 2);\n\tvr_mii_send(sc, frame->mii_opcode, 2);\n\tvr_mii_send(sc, frame->mii_phyaddr, 5);\n\tvr_mii_send(sc, frame->mii_regaddr, 5);\n\tvr_mii_send(sc, frame->mii_turnaround, 2);\n\tvr_mii_send(sc, frame->mii_data, 16);\n\n\t/* Idle bit. */\n\tSIO_SET(VR_MIICMD_CLK);\n\tDELAY(1);\n\tSIO_CLR(VR_MIICMD_CLK);\n\tDELAY(1);\n\n\t/*\n\t * Turn off xmit.\n\t */\n\tSIO_CLR(VR_MIICMD_DIR);\n\n\tsplx(s);\n\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/if_vrreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/device.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void vr_mii_sync",
      "void vr_mii_send",
      "int vr_mii_writereg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIO_CLR",
          "args": [
            "VR_MIICMD_DIR"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIO_CLR",
          "args": [
            "VR_MIICMD_CLK"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIO_SET",
          "args": [
            "VR_MIICMD_CLK"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vr_mii_send",
          "args": [
            "sc",
            "frame->mii_data",
            "16"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "vr_mii_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "218-239",
          "snippet": "void\nvr_mii_send(sc, bits, cnt)\n\tstruct vr_softc\t\t*sc;\n\tu_int32_t\t\tbits;\n\tint\t\t\tcnt;\n{\n\tint\t\t\ti;\n\n\tSIO_CLR(VR_MIICMD_CLK);\n\n\tfor (i = (0x1 << (cnt - 1)); i; i >>= 1) {\n                if (bits & i) {\n\t\t\tSIO_SET(VR_MIICMD_DATAIN);\n                } else {\n\t\t\tSIO_CLR(VR_MIICMD_DATAIN);\n                }\n\t\tDELAY(1);\n\t\tSIO_CLR(VR_MIICMD_CLK);\n\t\tDELAY(1);\n\t\tSIO_SET(VR_MIICMD_CLK);\n\t}\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void vr_mii_send"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_mii_send;\n\nvoid\nvr_mii_send(sc, bits, cnt)\n\tstruct vr_softc\t\t*sc;\n\tu_int32_t\t\tbits;\n\tint\t\t\tcnt;\n{\n\tint\t\t\ti;\n\n\tSIO_CLR(VR_MIICMD_CLK);\n\n\tfor (i = (0x1 << (cnt - 1)); i; i >>= 1) {\n                if (bits & i) {\n\t\t\tSIO_SET(VR_MIICMD_DATAIN);\n                } else {\n\t\t\tSIO_CLR(VR_MIICMD_DATAIN);\n                }\n\t\tDELAY(1);\n\t\tSIO_CLR(VR_MIICMD_CLK);\n\t\tDELAY(1);\n\t\tSIO_SET(VR_MIICMD_CLK);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vr_mii_sync",
          "args": [
            "sc"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "vr_mii_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "197-213",
          "snippet": "void\nvr_mii_sync(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tSIO_SET(VR_MIICMD_DIR|VR_MIICMD_DATAIN);\n\n\tfor (i = 0; i < 32; i++) {\n\t\tSIO_SET(VR_MIICMD_CLK);\n\t\tDELAY(1);\n\t\tSIO_CLR(VR_MIICMD_CLK);\n\t\tDELAY(1);\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void vr_mii_sync"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_mii_sync;\n\nvoid\nvr_mii_sync(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tSIO_SET(VR_MIICMD_DIR|VR_MIICMD_DATAIN);\n\n\tfor (i = 0; i < 32; i++) {\n\t\tSIO_SET(VR_MIICMD_CLK);\n\t\tDELAY(1);\n\t\tSIO_CLR(VR_MIICMD_CLK);\n\t\tDELAY(1);\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIO_SET",
          "args": [
            "VR_MIICMD_DIR"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VR_SETBIT",
          "args": [
            "sc",
            "VR_MIICMD",
            "VR_MIICMD_DIRECTPGM"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_1",
          "args": [
            "sc",
            "VR_MIICMD",
            "0"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_mii_sync;\nvoid vr_mii_send;\nint vr_mii_writereg;\n\nint\nvr_mii_writereg(sc, frame)\n\tstruct vr_softc\t\t*sc;\n\tstruct vr_mii_frame\t*frame;\n\t\n{\n\tint\t\t\ts;\n\n\ts = splimp();\n\n\tCSR_WRITE_1(sc, VR_MIICMD, 0);\n\tVR_SETBIT(sc, VR_MIICMD, VR_MIICMD_DIRECTPGM);\n\n\t/*\n\t * Set up frame for TX.\n\t */\n\n\tframe->mii_stdelim = VR_MII_STARTDELIM;\n\tframe->mii_opcode = VR_MII_WRITEOP;\n\tframe->mii_turnaround = VR_MII_TURNAROUND;\n\t\n\t/*\n \t * Turn on data output.\n\t */\n\tSIO_SET(VR_MIICMD_DIR);\n\n\tvr_mii_sync(sc);\n\n\tvr_mii_send(sc, frame->mii_stdelim, 2);\n\tvr_mii_send(sc, frame->mii_opcode, 2);\n\tvr_mii_send(sc, frame->mii_phyaddr, 5);\n\tvr_mii_send(sc, frame->mii_regaddr, 5);\n\tvr_mii_send(sc, frame->mii_turnaround, 2);\n\tvr_mii_send(sc, frame->mii_data, 16);\n\n\t/* Idle bit. */\n\tSIO_SET(VR_MIICMD_CLK);\n\tDELAY(1);\n\tSIO_CLR(VR_MIICMD_CLK);\n\tDELAY(1);\n\n\t/*\n\t * Turn off xmit.\n\t */\n\tSIO_CLR(VR_MIICMD_DIR);\n\n\tsplx(s);\n\n\treturn(0);\n}"
  },
  {
    "function_name": "vr_mii_readreg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
    "lines": "244-334",
    "snippet": "int\nvr_mii_readreg(sc, frame)\n\tstruct vr_softc\t\t*sc;\n\tstruct vr_mii_frame\t*frame;\n\t\n{\n\tint\t\t\ti, ack, s;\n\n\ts = splimp();\n\n\t/*\n\t * Set up frame for RX.\n\t */\n\tframe->mii_stdelim = VR_MII_STARTDELIM;\n\tframe->mii_opcode = VR_MII_READOP;\n\tframe->mii_turnaround = 0;\n\tframe->mii_data = 0;\n\t\n\tCSR_WRITE_1(sc, VR_MIICMD, 0);\n\tVR_SETBIT(sc, VR_MIICMD, VR_MIICMD_DIRECTPGM);\n\n\t/*\n \t * Turn on data xmit.\n\t */\n\tSIO_SET(VR_MIICMD_DIR);\n\n\tvr_mii_sync(sc);\n\n\t/*\n\t * Send command/address info.\n\t */\n\tvr_mii_send(sc, frame->mii_stdelim, 2);\n\tvr_mii_send(sc, frame->mii_opcode, 2);\n\tvr_mii_send(sc, frame->mii_phyaddr, 5);\n\tvr_mii_send(sc, frame->mii_regaddr, 5);\n\n\t/* Idle bit */\n\tSIO_CLR((VR_MIICMD_CLK|VR_MIICMD_DATAIN));\n\tDELAY(1);\n\tSIO_SET(VR_MIICMD_CLK);\n\tDELAY(1);\n\n\t/* Turn off xmit. */\n\tSIO_CLR(VR_MIICMD_DIR);\n\n\t/* Check for ack */\n\tSIO_CLR(VR_MIICMD_CLK);\n\tDELAY(1);\n\tSIO_SET(VR_MIICMD_CLK);\n\tDELAY(1);\n\tack = CSR_READ_4(sc, VR_MIICMD) & VR_MIICMD_DATAOUT;\n\n\t/*\n\t * Now try reading data bits. If the ack failed, we still\n\t * need to clock through 16 cycles to keep the PHY(s) in sync.\n\t */\n\tif (ack) {\n\t\tfor(i = 0; i < 16; i++) {\n\t\t\tSIO_CLR(VR_MIICMD_CLK);\n\t\t\tDELAY(1);\n\t\t\tSIO_SET(VR_MIICMD_CLK);\n\t\t\tDELAY(1);\n\t\t}\n\t\tgoto fail;\n\t}\n\n\tfor (i = 0x8000; i; i >>= 1) {\n\t\tSIO_CLR(VR_MIICMD_CLK);\n\t\tDELAY(1);\n\t\tif (!ack) {\n\t\t\tif (CSR_READ_4(sc, VR_MIICMD) & VR_MIICMD_DATAOUT)\n\t\t\t\tframe->mii_data |= i;\n\t\t\tDELAY(1);\n\t\t}\n\t\tSIO_SET(VR_MIICMD_CLK);\n\t\tDELAY(1);\n\t}\n\nfail:\n\n\tSIO_CLR(VR_MIICMD_CLK);\n\tDELAY(1);\n\tSIO_SET(VR_MIICMD_CLK);\n\tDELAY(1);\n\n\tsplx(s);\n\n\tif (ack)\n\t\treturn(1);\n\treturn(0);\n}",
    "includes": [
      "#include <dev/pci/if_vrreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/device.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void vr_mii_sync",
      "void vr_mii_send",
      "int vr_mii_readreg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIO_SET",
          "args": [
            "VR_MIICMD_CLK"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIO_CLR",
          "args": [
            "VR_MIICMD_CLK"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIO_SET",
          "args": [
            "VR_MIICMD_CLK"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "VR_MIICMD"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIO_CLR",
          "args": [
            "VR_MIICMD_CLK"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIO_SET",
          "args": [
            "VR_MIICMD_CLK"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIO_CLR",
          "args": [
            "VR_MIICMD_CLK"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "VR_MIICMD"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIO_SET",
          "args": [
            "VR_MIICMD_CLK"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIO_CLR",
          "args": [
            "VR_MIICMD_CLK"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIO_CLR",
          "args": [
            "VR_MIICMD_DIR"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIO_SET",
          "args": [
            "VR_MIICMD_CLK"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIO_CLR",
          "args": [
            "(VR_MIICMD_CLK|VR_MIICMD_DATAIN)"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vr_mii_send",
          "args": [
            "sc",
            "frame->mii_regaddr",
            "5"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "vr_mii_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "218-239",
          "snippet": "void\nvr_mii_send(sc, bits, cnt)\n\tstruct vr_softc\t\t*sc;\n\tu_int32_t\t\tbits;\n\tint\t\t\tcnt;\n{\n\tint\t\t\ti;\n\n\tSIO_CLR(VR_MIICMD_CLK);\n\n\tfor (i = (0x1 << (cnt - 1)); i; i >>= 1) {\n                if (bits & i) {\n\t\t\tSIO_SET(VR_MIICMD_DATAIN);\n                } else {\n\t\t\tSIO_CLR(VR_MIICMD_DATAIN);\n                }\n\t\tDELAY(1);\n\t\tSIO_CLR(VR_MIICMD_CLK);\n\t\tDELAY(1);\n\t\tSIO_SET(VR_MIICMD_CLK);\n\t}\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void vr_mii_send"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_mii_send;\n\nvoid\nvr_mii_send(sc, bits, cnt)\n\tstruct vr_softc\t\t*sc;\n\tu_int32_t\t\tbits;\n\tint\t\t\tcnt;\n{\n\tint\t\t\ti;\n\n\tSIO_CLR(VR_MIICMD_CLK);\n\n\tfor (i = (0x1 << (cnt - 1)); i; i >>= 1) {\n                if (bits & i) {\n\t\t\tSIO_SET(VR_MIICMD_DATAIN);\n                } else {\n\t\t\tSIO_CLR(VR_MIICMD_DATAIN);\n                }\n\t\tDELAY(1);\n\t\tSIO_CLR(VR_MIICMD_CLK);\n\t\tDELAY(1);\n\t\tSIO_SET(VR_MIICMD_CLK);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vr_mii_sync",
          "args": [
            "sc"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "vr_mii_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
          "lines": "197-213",
          "snippet": "void\nvr_mii_sync(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tSIO_SET(VR_MIICMD_DIR|VR_MIICMD_DATAIN);\n\n\tfor (i = 0; i < 32; i++) {\n\t\tSIO_SET(VR_MIICMD_CLK);\n\t\tDELAY(1);\n\t\tSIO_CLR(VR_MIICMD_CLK);\n\t\tDELAY(1);\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/if_vrreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <sys/device.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void vr_mii_sync"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_mii_sync;\n\nvoid\nvr_mii_sync(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tSIO_SET(VR_MIICMD_DIR|VR_MIICMD_DATAIN);\n\n\tfor (i = 0; i < 32; i++) {\n\t\tSIO_SET(VR_MIICMD_CLK);\n\t\tDELAY(1);\n\t\tSIO_CLR(VR_MIICMD_CLK);\n\t\tDELAY(1);\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIO_SET",
          "args": [
            "VR_MIICMD_DIR"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VR_SETBIT",
          "args": [
            "sc",
            "VR_MIICMD",
            "VR_MIICMD_DIRECTPGM"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_1",
          "args": [
            "sc",
            "VR_MIICMD",
            "0"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_mii_sync;\nvoid vr_mii_send;\nint vr_mii_readreg;\n\nint\nvr_mii_readreg(sc, frame)\n\tstruct vr_softc\t\t*sc;\n\tstruct vr_mii_frame\t*frame;\n\t\n{\n\tint\t\t\ti, ack, s;\n\n\ts = splimp();\n\n\t/*\n\t * Set up frame for RX.\n\t */\n\tframe->mii_stdelim = VR_MII_STARTDELIM;\n\tframe->mii_opcode = VR_MII_READOP;\n\tframe->mii_turnaround = 0;\n\tframe->mii_data = 0;\n\t\n\tCSR_WRITE_1(sc, VR_MIICMD, 0);\n\tVR_SETBIT(sc, VR_MIICMD, VR_MIICMD_DIRECTPGM);\n\n\t/*\n \t * Turn on data xmit.\n\t */\n\tSIO_SET(VR_MIICMD_DIR);\n\n\tvr_mii_sync(sc);\n\n\t/*\n\t * Send command/address info.\n\t */\n\tvr_mii_send(sc, frame->mii_stdelim, 2);\n\tvr_mii_send(sc, frame->mii_opcode, 2);\n\tvr_mii_send(sc, frame->mii_phyaddr, 5);\n\tvr_mii_send(sc, frame->mii_regaddr, 5);\n\n\t/* Idle bit */\n\tSIO_CLR((VR_MIICMD_CLK|VR_MIICMD_DATAIN));\n\tDELAY(1);\n\tSIO_SET(VR_MIICMD_CLK);\n\tDELAY(1);\n\n\t/* Turn off xmit. */\n\tSIO_CLR(VR_MIICMD_DIR);\n\n\t/* Check for ack */\n\tSIO_CLR(VR_MIICMD_CLK);\n\tDELAY(1);\n\tSIO_SET(VR_MIICMD_CLK);\n\tDELAY(1);\n\tack = CSR_READ_4(sc, VR_MIICMD) & VR_MIICMD_DATAOUT;\n\n\t/*\n\t * Now try reading data bits. If the ack failed, we still\n\t * need to clock through 16 cycles to keep the PHY(s) in sync.\n\t */\n\tif (ack) {\n\t\tfor(i = 0; i < 16; i++) {\n\t\t\tSIO_CLR(VR_MIICMD_CLK);\n\t\t\tDELAY(1);\n\t\t\tSIO_SET(VR_MIICMD_CLK);\n\t\t\tDELAY(1);\n\t\t}\n\t\tgoto fail;\n\t}\n\n\tfor (i = 0x8000; i; i >>= 1) {\n\t\tSIO_CLR(VR_MIICMD_CLK);\n\t\tDELAY(1);\n\t\tif (!ack) {\n\t\t\tif (CSR_READ_4(sc, VR_MIICMD) & VR_MIICMD_DATAOUT)\n\t\t\t\tframe->mii_data |= i;\n\t\t\tDELAY(1);\n\t\t}\n\t\tSIO_SET(VR_MIICMD_CLK);\n\t\tDELAY(1);\n\t}\n\nfail:\n\n\tSIO_CLR(VR_MIICMD_CLK);\n\tDELAY(1);\n\tSIO_SET(VR_MIICMD_CLK);\n\tDELAY(1);\n\n\tsplx(s);\n\n\tif (ack)\n\t\treturn(1);\n\treturn(0);\n}"
  },
  {
    "function_name": "vr_mii_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
    "lines": "218-239",
    "snippet": "void\nvr_mii_send(sc, bits, cnt)\n\tstruct vr_softc\t\t*sc;\n\tu_int32_t\t\tbits;\n\tint\t\t\tcnt;\n{\n\tint\t\t\ti;\n\n\tSIO_CLR(VR_MIICMD_CLK);\n\n\tfor (i = (0x1 << (cnt - 1)); i; i >>= 1) {\n                if (bits & i) {\n\t\t\tSIO_SET(VR_MIICMD_DATAIN);\n                } else {\n\t\t\tSIO_CLR(VR_MIICMD_DATAIN);\n                }\n\t\tDELAY(1);\n\t\tSIO_CLR(VR_MIICMD_CLK);\n\t\tDELAY(1);\n\t\tSIO_SET(VR_MIICMD_CLK);\n\t}\n}",
    "includes": [
      "#include <dev/pci/if_vrreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/device.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void vr_mii_send"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SIO_SET",
          "args": [
            "VR_MIICMD_CLK"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIO_CLR",
          "args": [
            "VR_MIICMD_CLK"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIO_CLR",
          "args": [
            "VR_MIICMD_DATAIN"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIO_SET",
          "args": [
            "VR_MIICMD_DATAIN"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIO_CLR",
          "args": [
            "VR_MIICMD_CLK"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_mii_send;\n\nvoid\nvr_mii_send(sc, bits, cnt)\n\tstruct vr_softc\t\t*sc;\n\tu_int32_t\t\tbits;\n\tint\t\t\tcnt;\n{\n\tint\t\t\ti;\n\n\tSIO_CLR(VR_MIICMD_CLK);\n\n\tfor (i = (0x1 << (cnt - 1)); i; i >>= 1) {\n                if (bits & i) {\n\t\t\tSIO_SET(VR_MIICMD_DATAIN);\n                } else {\n\t\t\tSIO_CLR(VR_MIICMD_DATAIN);\n                }\n\t\tDELAY(1);\n\t\tSIO_CLR(VR_MIICMD_CLK);\n\t\tDELAY(1);\n\t\tSIO_SET(VR_MIICMD_CLK);\n\t}\n}"
  },
  {
    "function_name": "vr_mii_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_vr.c",
    "lines": "197-213",
    "snippet": "void\nvr_mii_sync(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tSIO_SET(VR_MIICMD_DIR|VR_MIICMD_DATAIN);\n\n\tfor (i = 0; i < 32; i++) {\n\t\tSIO_SET(VR_MIICMD_CLK);\n\t\tDELAY(1);\n\t\tSIO_CLR(VR_MIICMD_CLK);\n\t\tDELAY(1);\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/if_vrreg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <vm/pmap.h>            /* for vtophys */",
      "#include <vm/vm.h>              /* for vtophys */",
      "#include <net/bpf.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <sys/device.h>",
      "#include <net/if.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/sockio.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void vr_mii_sync"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIO_CLR",
          "args": [
            "VR_MIICMD_CLK"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIO_SET",
          "args": [
            "VR_MIICMD_CLK"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIO_SET",
          "args": [
            "VR_MIICMD_DIR|VR_MIICMD_DATAIN"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/if_vrreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <sys/device.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid vr_mii_sync;\n\nvoid\nvr_mii_sync(sc)\n\tstruct vr_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tSIO_SET(VR_MIICMD_DIR|VR_MIICMD_DATAIN);\n\n\tfor (i = 0; i < 32; i++) {\n\t\tSIO_SET(VR_MIICMD_CLK);\n\t\tDELAY(1);\n\t\tSIO_CLR(VR_MIICMD_CLK);\n\t\tDELAY(1);\n\t}\n\n\treturn;\n}"
  }
]