[
  {
    "function_name": "rf_IdentifyStripeDeclusteredPQ",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_declusterPQ.c",
    "lines": "464-489",
    "snippet": "void \nrf_IdentifyStripeDeclusteredPQ(\n    RF_Raid_t * raidPtr,\n    RF_RaidAddr_t addr,\n    RF_RowCol_t ** diskids,\n    RF_RowCol_t * outRow)\n{\n\tRF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;\n\tRF_StripeCount_t sus_per_fulltable = info->SUsPerFullTable;\n\tRF_StripeCount_t fulltable_depth = info->FullTableDepthInPUs * layoutPtr->SUsPerPU;\n\tRF_StripeNum_t base_suid = 0;\n\tRF_StripeNum_t SUID = rf_RaidAddressToStripeUnitID(layoutPtr, addr);\n\tRF_StripeNum_t stripeID, FullTableID;\n\tint     tableOffset;\n\n\trf_decluster_adjust_params(layoutPtr, &SUID, &sus_per_fulltable, &fulltable_depth, &base_suid);\n\tFullTableID = SUID / sus_per_fulltable;\t/* fulltable ID within array\n\t\t\t\t\t\t * (across rows) */\n\t*outRow = FullTableID % raidPtr->numRow;\n\tstripeID = rf_StripeUnitIDToStripeID(layoutPtr, SUID);\t/* find stripe offset\n\t\t\t\t\t\t\t\t * into array */\n\ttableOffset = (stripeID % info->BlocksPerTable);\t/* find offset into\n\t\t\t\t\t\t\t\t * block design table */\n\t*diskids = info->LayoutTable[tableOffset];\n}",
    "includes": [
      "#include \"rf_general.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_declusterPQ.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_StripeUnitIDToStripeID",
          "args": [
            "layoutPtr",
            "SUID"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_decluster_adjust_params",
          "args": [
            "layoutPtr",
            "&SUID",
            "&sus_per_fulltable",
            "&fulltable_depth",
            "&base_suid"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "rf_decluster_adjust_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_decluster.c",
          "lines": "550-579",
          "snippet": "void \nrf_decluster_adjust_params(\n    RF_RaidLayout_t * layoutPtr,\n    RF_StripeNum_t * SUID,\n    RF_StripeCount_t * sus_per_fulltable,\n    RF_StripeCount_t * fulltable_depth,\n    RF_StripeNum_t * base_suid)\n{\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;\n#if (defined(__NetBSD__) || defined (__OpenBSD__)) && defined(_KERNEL)\n\t/* Nothing! */\n#else\n\tchar    pc = layoutPtr->map->parityConfig;\n#endif\n\n\tif (*SUID >= info->FullTableLimitSUID) {\n\t\t/* new full table size is size of last full table on disk */\n\t\t*sus_per_fulltable = info->ExtraTablesPerDisk * info->SUsPerTable;\n\n\t\t/* new full table depth is corresponding depth */\n\t\t*fulltable_depth = info->ExtraTablesPerDisk * info->TableDepthInPUs * layoutPtr->SUsPerPU;\n\n\t\t/* set up the new base offset */\n\t\t*base_suid = info->DiskOffsetOfLastFullTableInSUs;\n\n\t\t/* convert users array address to an offset into the last\n\t\t * fulltable */\n\t\t*SUID -= info->FullTableLimitSUID;\n\t}\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_utils.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_decluster.h\"\n#include \"rf_configure.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_decluster_adjust_params(\n    RF_RaidLayout_t * layoutPtr,\n    RF_StripeNum_t * SUID,\n    RF_StripeCount_t * sus_per_fulltable,\n    RF_StripeCount_t * fulltable_depth,\n    RF_StripeNum_t * base_suid)\n{\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;\n#if (defined(__NetBSD__) || defined (__OpenBSD__)) && defined(_KERNEL)\n\t/* Nothing! */\n#else\n\tchar    pc = layoutPtr->map->parityConfig;\n#endif\n\n\tif (*SUID >= info->FullTableLimitSUID) {\n\t\t/* new full table size is size of last full table on disk */\n\t\t*sus_per_fulltable = info->ExtraTablesPerDisk * info->SUsPerTable;\n\n\t\t/* new full table depth is corresponding depth */\n\t\t*fulltable_depth = info->ExtraTablesPerDisk * info->TableDepthInPUs * layoutPtr->SUsPerPU;\n\n\t\t/* set up the new base offset */\n\t\t*base_suid = info->DiskOffsetOfLastFullTableInSUs;\n\n\t\t/* convert users array address to an offset into the last\n\t\t * fulltable */\n\t\t*SUID -= info->FullTableLimitSUID;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToStripeUnitID",
          "args": [
            "layoutPtr",
            "addr"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_utils.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_declusterPQ.h\"\n#include \"rf_decluster.h\"\n#include \"rf_configure.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_IdentifyStripeDeclusteredPQ(\n    RF_Raid_t * raidPtr,\n    RF_RaidAddr_t addr,\n    RF_RowCol_t ** diskids,\n    RF_RowCol_t * outRow)\n{\n\tRF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;\n\tRF_StripeCount_t sus_per_fulltable = info->SUsPerFullTable;\n\tRF_StripeCount_t fulltable_depth = info->FullTableDepthInPUs * layoutPtr->SUsPerPU;\n\tRF_StripeNum_t base_suid = 0;\n\tRF_StripeNum_t SUID = rf_RaidAddressToStripeUnitID(layoutPtr, addr);\n\tRF_StripeNum_t stripeID, FullTableID;\n\tint     tableOffset;\n\n\trf_decluster_adjust_params(layoutPtr, &SUID, &sus_per_fulltable, &fulltable_depth, &base_suid);\n\tFullTableID = SUID / sus_per_fulltable;\t/* fulltable ID within array\n\t\t\t\t\t\t * (across rows) */\n\t*outRow = FullTableID % raidPtr->numRow;\n\tstripeID = rf_StripeUnitIDToStripeID(layoutPtr, SUID);\t/* find stripe offset\n\t\t\t\t\t\t\t\t * into array */\n\ttableOffset = (stripeID % info->BlocksPerTable);\t/* find offset into\n\t\t\t\t\t\t\t\t * block design table */\n\t*diskids = info->LayoutTable[tableOffset];\n}"
  },
  {
    "function_name": "rf_MapQDeclusteredPQ",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_declusterPQ.c",
    "lines": "405-460",
    "snippet": "void \nrf_MapQDeclusteredPQ(\n    RF_Raid_t * raidPtr,\n    RF_RaidAddr_t raidSector,\n    RF_RowCol_t * row,\n    RF_RowCol_t * col,\n    RF_SectorNum_t * diskSector,\n    int remap)\n{\n\tRF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;\n\tRF_StripeNum_t SUID = raidSector / layoutPtr->sectorsPerStripeUnit;\n\tRF_StripeNum_t FullTableID, FullTableOffset, TableID, TableOffset;\n\tRF_StripeNum_t BlockID, BlockOffset, RepIndex, RepIndexQ;\n\tRF_StripeCount_t sus_per_fulltable = info->SUsPerFullTable;\n\tRF_StripeCount_t fulltable_depth = info->FullTableDepthInPUs * layoutPtr->SUsPerPU;\n\tRF_StripeNum_t base_suid = 0, outSU, SpareRegion, SpareSpace = 0;\n\n\trf_decluster_adjust_params(layoutPtr, &SUID, &sus_per_fulltable, &fulltable_depth, &base_suid);\n\n\t/* compute row & (possibly) spare space exactly as before */\n\tFullTableID = SUID / sus_per_fulltable;\n\t*row = FullTableID % raidPtr->numRow;\n\tFullTableID /= raidPtr->numRow;\t/* convert to fulltable ID on this\n\t\t\t\t\t * disk */\n\tif ((raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE)) {\n\t\tSpareRegion = FullTableID / info->FullTablesPerSpareRegion;\n\t\tSpareSpace = SpareRegion * info->SpareSpaceDepthPerRegionInSUs;\n\t}\n\t/* compute BlockID and RepIndex exactly as before */\n\tFullTableOffset = SUID % sus_per_fulltable;\n\tTableID = FullTableOffset / info->SUsPerTable;\n\tTableOffset = FullTableOffset - TableID * info->SUsPerTable;\n\tBlockID = TableOffset / info->PUsPerBlock;\n\tBlockOffset = TableOffset - BlockID * info->PUsPerBlock;\n\tBlockID %= info->BlocksPerTable;\n\n\t/* the q block is in the position indicated by RepIndex */\n\tRepIndex = (raidPtr->noRotate) ? info->PUsPerBlock : info->groupSize - 1 - TableID;\n\tRepIndexQ = ((RepIndex == (info->groupSize - 1)) ? 0 : RepIndex + 1);\n\t*col = info->LayoutTable[BlockID][RepIndexQ];\n\n\tif (remap)\n\t\tRF_PANIC();\n\n\t/* compute sector as before, except use RepIndex instead of\n\t * BlockOffset */\n\toutSU = base_suid;\n\toutSU += FullTableID * fulltable_depth;\n\toutSU += SpareSpace;\t/* skip rsvd spare space */\n\toutSU += TableID * info->TableDepthInPUs * layoutPtr->SUsPerPU;\n\toutSU += TableOffset / (info->BlocksPerTable * info->PUsPerBlock);\n\n\toutSU += info->OffsetTable[BlockID][RepIndexQ] * layoutPtr->SUsPerPU;\n\t*diskSector = outSU * layoutPtr->sectorsPerStripeUnit + (raidSector % layoutPtr->sectorsPerStripeUnit);\n}",
    "includes": [
      "#include \"rf_general.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_declusterPQ.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_PANIC",
          "args": [],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_decluster_adjust_params",
          "args": [
            "layoutPtr",
            "&SUID",
            "&sus_per_fulltable",
            "&fulltable_depth",
            "&base_suid"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "rf_decluster_adjust_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_decluster.c",
          "lines": "550-579",
          "snippet": "void \nrf_decluster_adjust_params(\n    RF_RaidLayout_t * layoutPtr,\n    RF_StripeNum_t * SUID,\n    RF_StripeCount_t * sus_per_fulltable,\n    RF_StripeCount_t * fulltable_depth,\n    RF_StripeNum_t * base_suid)\n{\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;\n#if (defined(__NetBSD__) || defined (__OpenBSD__)) && defined(_KERNEL)\n\t/* Nothing! */\n#else\n\tchar    pc = layoutPtr->map->parityConfig;\n#endif\n\n\tif (*SUID >= info->FullTableLimitSUID) {\n\t\t/* new full table size is size of last full table on disk */\n\t\t*sus_per_fulltable = info->ExtraTablesPerDisk * info->SUsPerTable;\n\n\t\t/* new full table depth is corresponding depth */\n\t\t*fulltable_depth = info->ExtraTablesPerDisk * info->TableDepthInPUs * layoutPtr->SUsPerPU;\n\n\t\t/* set up the new base offset */\n\t\t*base_suid = info->DiskOffsetOfLastFullTableInSUs;\n\n\t\t/* convert users array address to an offset into the last\n\t\t * fulltable */\n\t\t*SUID -= info->FullTableLimitSUID;\n\t}\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_utils.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_decluster.h\"\n#include \"rf_configure.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_decluster_adjust_params(\n    RF_RaidLayout_t * layoutPtr,\n    RF_StripeNum_t * SUID,\n    RF_StripeCount_t * sus_per_fulltable,\n    RF_StripeCount_t * fulltable_depth,\n    RF_StripeNum_t * base_suid)\n{\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;\n#if (defined(__NetBSD__) || defined (__OpenBSD__)) && defined(_KERNEL)\n\t/* Nothing! */\n#else\n\tchar    pc = layoutPtr->map->parityConfig;\n#endif\n\n\tif (*SUID >= info->FullTableLimitSUID) {\n\t\t/* new full table size is size of last full table on disk */\n\t\t*sus_per_fulltable = info->ExtraTablesPerDisk * info->SUsPerTable;\n\n\t\t/* new full table depth is corresponding depth */\n\t\t*fulltable_depth = info->ExtraTablesPerDisk * info->TableDepthInPUs * layoutPtr->SUsPerPU;\n\n\t\t/* set up the new base offset */\n\t\t*base_suid = info->DiskOffsetOfLastFullTableInSUs;\n\n\t\t/* convert users array address to an offset into the last\n\t\t * fulltable */\n\t\t*SUID -= info->FullTableLimitSUID;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_utils.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_declusterPQ.h\"\n#include \"rf_decluster.h\"\n#include \"rf_configure.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_MapQDeclusteredPQ(\n    RF_Raid_t * raidPtr,\n    RF_RaidAddr_t raidSector,\n    RF_RowCol_t * row,\n    RF_RowCol_t * col,\n    RF_SectorNum_t * diskSector,\n    int remap)\n{\n\tRF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;\n\tRF_StripeNum_t SUID = raidSector / layoutPtr->sectorsPerStripeUnit;\n\tRF_StripeNum_t FullTableID, FullTableOffset, TableID, TableOffset;\n\tRF_StripeNum_t BlockID, BlockOffset, RepIndex, RepIndexQ;\n\tRF_StripeCount_t sus_per_fulltable = info->SUsPerFullTable;\n\tRF_StripeCount_t fulltable_depth = info->FullTableDepthInPUs * layoutPtr->SUsPerPU;\n\tRF_StripeNum_t base_suid = 0, outSU, SpareRegion, SpareSpace = 0;\n\n\trf_decluster_adjust_params(layoutPtr, &SUID, &sus_per_fulltable, &fulltable_depth, &base_suid);\n\n\t/* compute row & (possibly) spare space exactly as before */\n\tFullTableID = SUID / sus_per_fulltable;\n\t*row = FullTableID % raidPtr->numRow;\n\tFullTableID /= raidPtr->numRow;\t/* convert to fulltable ID on this\n\t\t\t\t\t * disk */\n\tif ((raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE)) {\n\t\tSpareRegion = FullTableID / info->FullTablesPerSpareRegion;\n\t\tSpareSpace = SpareRegion * info->SpareSpaceDepthPerRegionInSUs;\n\t}\n\t/* compute BlockID and RepIndex exactly as before */\n\tFullTableOffset = SUID % sus_per_fulltable;\n\tTableID = FullTableOffset / info->SUsPerTable;\n\tTableOffset = FullTableOffset - TableID * info->SUsPerTable;\n\tBlockID = TableOffset / info->PUsPerBlock;\n\tBlockOffset = TableOffset - BlockID * info->PUsPerBlock;\n\tBlockID %= info->BlocksPerTable;\n\n\t/* the q block is in the position indicated by RepIndex */\n\tRepIndex = (raidPtr->noRotate) ? info->PUsPerBlock : info->groupSize - 1 - TableID;\n\tRepIndexQ = ((RepIndex == (info->groupSize - 1)) ? 0 : RepIndex + 1);\n\t*col = info->LayoutTable[BlockID][RepIndexQ];\n\n\tif (remap)\n\t\tRF_PANIC();\n\n\t/* compute sector as before, except use RepIndex instead of\n\t * BlockOffset */\n\toutSU = base_suid;\n\toutSU += FullTableID * fulltable_depth;\n\toutSU += SpareSpace;\t/* skip rsvd spare space */\n\toutSU += TableID * info->TableDepthInPUs * layoutPtr->SUsPerPU;\n\toutSU += TableOffset / (info->BlocksPerTable * info->PUsPerBlock);\n\n\toutSU += info->OffsetTable[BlockID][RepIndexQ] * layoutPtr->SUsPerPU;\n\t*diskSector = outSU * layoutPtr->sectorsPerStripeUnit + (raidSector % layoutPtr->sectorsPerStripeUnit);\n}"
  },
  {
    "function_name": "rf_MapParityDeclusteredPQ",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_declusterPQ.c",
    "lines": "349-403",
    "snippet": "void \nrf_MapParityDeclusteredPQ(\n    RF_Raid_t * raidPtr,\n    RF_RaidAddr_t raidSector,\n    RF_RowCol_t * row,\n    RF_RowCol_t * col,\n    RF_SectorNum_t * diskSector,\n    int remap)\n{\n\tRF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;\n\tRF_StripeNum_t SUID = raidSector / layoutPtr->sectorsPerStripeUnit;\n\tRF_StripeNum_t FullTableID, FullTableOffset, TableID, TableOffset;\n\tRF_StripeNum_t BlockID, BlockOffset, RepIndex;\n\tRF_StripeCount_t sus_per_fulltable = info->SUsPerFullTable;\n\tRF_StripeCount_t fulltable_depth = info->FullTableDepthInPUs * layoutPtr->SUsPerPU;\n\tRF_StripeNum_t base_suid = 0, outSU, SpareRegion, SpareSpace = 0;\n\n\trf_decluster_adjust_params(layoutPtr, &SUID, &sus_per_fulltable, &fulltable_depth, &base_suid);\n\n\t/* compute row & (possibly) spare space exactly as before */\n\tFullTableID = SUID / sus_per_fulltable;\n\t*row = FullTableID % raidPtr->numRow;\n\tFullTableID /= raidPtr->numRow;\t/* convert to fulltable ID on this\n\t\t\t\t\t * disk */\n\tif ((raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE)) {\n\t\tSpareRegion = FullTableID / info->FullTablesPerSpareRegion;\n\t\tSpareSpace = SpareRegion * info->SpareSpaceDepthPerRegionInSUs;\n\t}\n\t/* compute BlockID and RepIndex exactly as before */\n\tFullTableOffset = SUID % sus_per_fulltable;\n\tTableID = FullTableOffset / info->SUsPerTable;\n\tTableOffset = FullTableOffset - TableID * info->SUsPerTable;\n\tBlockID = TableOffset / info->PUsPerBlock;\n\tBlockOffset = TableOffset - BlockID * info->PUsPerBlock;\n\tBlockID %= info->BlocksPerTable;\n\n\t/* the parity block is in the position indicated by RepIndex */\n\tRepIndex = (raidPtr->noRotate) ? info->PUsPerBlock : info->groupSize - 1 - TableID;\n\t*col = info->LayoutTable[BlockID][RepIndex];\n\n\tif (remap)\n\t\tRF_PANIC();\n\n\t/* compute sector as before, except use RepIndex instead of\n\t * BlockOffset */\n\toutSU = base_suid;\n\toutSU += FullTableID * fulltable_depth;\n\toutSU += SpareSpace;\t/* skip rsvd spare space */\n\toutSU += TableID * info->TableDepthInPUs * layoutPtr->SUsPerPU;\n\toutSU += info->OffsetTable[BlockID][RepIndex] * layoutPtr->SUsPerPU;\n\toutSU += TableOffset / (info->BlocksPerTable * info->PUsPerBlock);\n\n\t*diskSector = outSU * layoutPtr->sectorsPerStripeUnit + (raidSector % layoutPtr->sectorsPerStripeUnit);\n}",
    "includes": [
      "#include \"rf_general.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_declusterPQ.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_PANIC",
          "args": [],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_decluster_adjust_params",
          "args": [
            "layoutPtr",
            "&SUID",
            "&sus_per_fulltable",
            "&fulltable_depth",
            "&base_suid"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "rf_decluster_adjust_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_decluster.c",
          "lines": "550-579",
          "snippet": "void \nrf_decluster_adjust_params(\n    RF_RaidLayout_t * layoutPtr,\n    RF_StripeNum_t * SUID,\n    RF_StripeCount_t * sus_per_fulltable,\n    RF_StripeCount_t * fulltable_depth,\n    RF_StripeNum_t * base_suid)\n{\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;\n#if (defined(__NetBSD__) || defined (__OpenBSD__)) && defined(_KERNEL)\n\t/* Nothing! */\n#else\n\tchar    pc = layoutPtr->map->parityConfig;\n#endif\n\n\tif (*SUID >= info->FullTableLimitSUID) {\n\t\t/* new full table size is size of last full table on disk */\n\t\t*sus_per_fulltable = info->ExtraTablesPerDisk * info->SUsPerTable;\n\n\t\t/* new full table depth is corresponding depth */\n\t\t*fulltable_depth = info->ExtraTablesPerDisk * info->TableDepthInPUs * layoutPtr->SUsPerPU;\n\n\t\t/* set up the new base offset */\n\t\t*base_suid = info->DiskOffsetOfLastFullTableInSUs;\n\n\t\t/* convert users array address to an offset into the last\n\t\t * fulltable */\n\t\t*SUID -= info->FullTableLimitSUID;\n\t}\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_utils.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_decluster.h\"\n#include \"rf_configure.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_decluster_adjust_params(\n    RF_RaidLayout_t * layoutPtr,\n    RF_StripeNum_t * SUID,\n    RF_StripeCount_t * sus_per_fulltable,\n    RF_StripeCount_t * fulltable_depth,\n    RF_StripeNum_t * base_suid)\n{\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;\n#if (defined(__NetBSD__) || defined (__OpenBSD__)) && defined(_KERNEL)\n\t/* Nothing! */\n#else\n\tchar    pc = layoutPtr->map->parityConfig;\n#endif\n\n\tif (*SUID >= info->FullTableLimitSUID) {\n\t\t/* new full table size is size of last full table on disk */\n\t\t*sus_per_fulltable = info->ExtraTablesPerDisk * info->SUsPerTable;\n\n\t\t/* new full table depth is corresponding depth */\n\t\t*fulltable_depth = info->ExtraTablesPerDisk * info->TableDepthInPUs * layoutPtr->SUsPerPU;\n\n\t\t/* set up the new base offset */\n\t\t*base_suid = info->DiskOffsetOfLastFullTableInSUs;\n\n\t\t/* convert users array address to an offset into the last\n\t\t * fulltable */\n\t\t*SUID -= info->FullTableLimitSUID;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_utils.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_declusterPQ.h\"\n#include \"rf_decluster.h\"\n#include \"rf_configure.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_MapParityDeclusteredPQ(\n    RF_Raid_t * raidPtr,\n    RF_RaidAddr_t raidSector,\n    RF_RowCol_t * row,\n    RF_RowCol_t * col,\n    RF_SectorNum_t * diskSector,\n    int remap)\n{\n\tRF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;\n\tRF_StripeNum_t SUID = raidSector / layoutPtr->sectorsPerStripeUnit;\n\tRF_StripeNum_t FullTableID, FullTableOffset, TableID, TableOffset;\n\tRF_StripeNum_t BlockID, BlockOffset, RepIndex;\n\tRF_StripeCount_t sus_per_fulltable = info->SUsPerFullTable;\n\tRF_StripeCount_t fulltable_depth = info->FullTableDepthInPUs * layoutPtr->SUsPerPU;\n\tRF_StripeNum_t base_suid = 0, outSU, SpareRegion, SpareSpace = 0;\n\n\trf_decluster_adjust_params(layoutPtr, &SUID, &sus_per_fulltable, &fulltable_depth, &base_suid);\n\n\t/* compute row & (possibly) spare space exactly as before */\n\tFullTableID = SUID / sus_per_fulltable;\n\t*row = FullTableID % raidPtr->numRow;\n\tFullTableID /= raidPtr->numRow;\t/* convert to fulltable ID on this\n\t\t\t\t\t * disk */\n\tif ((raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE)) {\n\t\tSpareRegion = FullTableID / info->FullTablesPerSpareRegion;\n\t\tSpareSpace = SpareRegion * info->SpareSpaceDepthPerRegionInSUs;\n\t}\n\t/* compute BlockID and RepIndex exactly as before */\n\tFullTableOffset = SUID % sus_per_fulltable;\n\tTableID = FullTableOffset / info->SUsPerTable;\n\tTableOffset = FullTableOffset - TableID * info->SUsPerTable;\n\tBlockID = TableOffset / info->PUsPerBlock;\n\tBlockOffset = TableOffset - BlockID * info->PUsPerBlock;\n\tBlockID %= info->BlocksPerTable;\n\n\t/* the parity block is in the position indicated by RepIndex */\n\tRepIndex = (raidPtr->noRotate) ? info->PUsPerBlock : info->groupSize - 1 - TableID;\n\t*col = info->LayoutTable[BlockID][RepIndex];\n\n\tif (remap)\n\t\tRF_PANIC();\n\n\t/* compute sector as before, except use RepIndex instead of\n\t * BlockOffset */\n\toutSU = base_suid;\n\toutSU += FullTableID * fulltable_depth;\n\toutSU += SpareSpace;\t/* skip rsvd spare space */\n\toutSU += TableID * info->TableDepthInPUs * layoutPtr->SUsPerPU;\n\toutSU += info->OffsetTable[BlockID][RepIndex] * layoutPtr->SUsPerPU;\n\toutSU += TableOffset / (info->BlocksPerTable * info->PUsPerBlock);\n\n\t*diskSector = outSU * layoutPtr->sectorsPerStripeUnit + (raidSector % layoutPtr->sectorsPerStripeUnit);\n}"
  },
  {
    "function_name": "rf_MapSectorDeclusteredPQ",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_declusterPQ.c",
    "lines": "277-346",
    "snippet": "void \nrf_MapSectorDeclusteredPQ(\n    RF_Raid_t * raidPtr,\n    RF_RaidAddr_t raidSector,\n    RF_RowCol_t * row,\n    RF_RowCol_t * col,\n    RF_SectorNum_t * diskSector,\n    int remap)\n{\n\tRF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;\n\tRF_StripeNum_t SUID = raidSector / layoutPtr->sectorsPerStripeUnit;\n\tRF_StripeNum_t FullTableID, FullTableOffset, TableID, TableOffset;\n\tRF_StripeNum_t BlockID, BlockOffset, RepIndex;\n\tRF_StripeCount_t sus_per_fulltable = info->SUsPerFullTable;\n\tRF_StripeCount_t fulltable_depth = info->FullTableDepthInPUs * layoutPtr->SUsPerPU;\n\tRF_StripeNum_t base_suid = 0, outSU, SpareRegion = 0, SpareSpace = 0;\n\n\trf_decluster_adjust_params(layoutPtr, &SUID, &sus_per_fulltable, &fulltable_depth, &base_suid);\n\n\tFullTableID = SUID / sus_per_fulltable;\t/* fulltable ID within array\n\t\t\t\t\t\t * (across rows) */\n\t*row = FullTableID % raidPtr->numRow;\n\tFullTableID /= raidPtr->numRow;\t/* convert to fulltable ID on this\n\t\t\t\t\t * disk */\n\tif ((raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE)) {\n\t\tSpareRegion = FullTableID / info->FullTablesPerSpareRegion;\n\t\tSpareSpace = SpareRegion * info->SpareSpaceDepthPerRegionInSUs;\n\t}\n\tFullTableOffset = SUID % sus_per_fulltable;\n\tTableID = FullTableOffset / info->SUsPerTable;\n\tTableOffset = FullTableOffset - TableID * info->SUsPerTable;\n\tBlockID = TableOffset / info->PUsPerBlock;\n\tBlockOffset = TableOffset - BlockID * info->PUsPerBlock;\n\tBlockID %= info->BlocksPerTable;\n\tRF_ASSERT(BlockOffset < info->groupSize - 2);\n\t/*\n           TableIDs go from 0 .. GroupSize-1 inclusive.\n           PUsPerBlock is k-2.\n           We want the tableIDs to rotate from the\n           right, so use GroupSize\n           */\n\tRepIndex = info->groupSize - 1 - TableID;\n\tRF_ASSERT(RepIndex >= 0);\n\tif (!raidPtr->noRotate) {\n\t\tif (TableID == 0)\n\t\t\tBlockOffset++;\t/* P on last drive, Q on first */\n\t\telse\n\t\t\tBlockOffset += ((BlockOffset >= RepIndex) ? 2 : 0);\t/* skip over PQ */\n\t\tRF_ASSERT(BlockOffset < info->groupSize);\n\t\t*col = info->LayoutTable[BlockID][BlockOffset];\n\t}\n\t/* remap to distributed spare space if indicated */\n\tif (remap) {\n\t\trf_remap_to_spare_space(layoutPtr, info, *row, FullTableID, TableID, BlockID, (base_suid) ? 1 : 0, SpareRegion, col, &outSU);\n\t} else {\n\n\t\toutSU = base_suid;\n\t\toutSU += FullTableID * fulltable_depth;\t/* offs to strt of FT */\n\t\toutSU += SpareSpace;\t/* skip rsvd spare space */\n\t\toutSU += TableID * info->TableDepthInPUs * layoutPtr->SUsPerPU;\t/* offs to strt of tble */\n\t\toutSU += info->OffsetTable[BlockID][BlockOffset] * layoutPtr->SUsPerPU;\t/* offs to the PU */\n\t}\n\toutSU += TableOffset / (info->BlocksPerTable * info->PUsPerBlock);\t/* offs to the SU within\n\t\t\t\t\t\t\t\t\t\t * a PU */\n\n\t/* convert SUs to sectors, and, if not aligned to SU boundary, add in\n\t * offset to sector */\n\t*diskSector = outSU * layoutPtr->sectorsPerStripeUnit + (raidSector % layoutPtr->sectorsPerStripeUnit);\n}",
    "includes": [
      "#include \"rf_general.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_declusterPQ.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_remap_to_spare_space",
          "args": [
            "layoutPtr",
            "info",
            "*row",
            "FullTableID",
            "TableID",
            "BlockID",
            "(base_suid) ? 1 : 0",
            "SpareRegion",
            "col",
            "&outSU"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "rf_remap_to_spare_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_decluster.c",
          "lines": "605-652",
          "snippet": "void \nrf_remap_to_spare_space(\n    RF_RaidLayout_t * layoutPtr,\n    RF_DeclusteredConfigInfo_t * info,\n    RF_RowCol_t row,\n    RF_StripeNum_t FullTableID,\n    RF_StripeNum_t TableID,\n    RF_SectorNum_t BlockID,\n    RF_StripeNum_t base_suid,\n    RF_StripeNum_t SpareRegion,\n    RF_RowCol_t * outCol,\n    RF_StripeNum_t * outSU)\n{\n\tRF_StripeNum_t ftID, spareTableStartSU, TableInSpareRegion, lastSROffset,\n\t        which_ft;\n\n\t/*\n         * note that FullTableID and hence SpareRegion may have gotten\n         * tweaked by rf_decluster_adjust_params. We detect this by\n         * noticing that base_suid is not 0.\n         */\n\tif (base_suid == 0) {\n\t\tftID = FullTableID;\n\t} else {\n\t\t/*\n\t         * There may be > 1.0 full tables in the last (i.e. partial)\n\t         * spare region.  find out which of these we're in.\n\t         */\n\t\tlastSROffset = info->NumCompleteSRs * info->SpareRegionDepthInSUs;\n\t\twhich_ft = (info->DiskOffsetOfLastFullTableInSUs - lastSROffset) / (info->FullTableDepthInPUs * layoutPtr->SUsPerPU);\n\n\t\t/* compute the actual full table ID */\n\t\tftID = info->DiskOffsetOfLastFullTableInSUs / (info->FullTableDepthInPUs * layoutPtr->SUsPerPU) + which_ft;\n\t\tSpareRegion = info->NumCompleteSRs;\n\t}\n\tTableInSpareRegion = (ftID * info->NumParityReps + TableID) % info->TablesPerSpareRegion;\n\n\t*outCol = info->SpareTable[TableInSpareRegion][BlockID].spareDisk;\n\tRF_ASSERT(*outCol != -1);\n\n\tspareTableStartSU = (SpareRegion == info->NumCompleteSRs) ?\n\t    info->DiskOffsetOfLastFullTableInSUs + info->ExtraTablesPerDisk * info->TableDepthInPUs * layoutPtr->SUsPerPU :\n\t    (SpareRegion + 1) * info->SpareRegionDepthInSUs - info->SpareSpaceDepthPerRegionInSUs;\n\t*outSU = spareTableStartSU + info->SpareTable[TableInSpareRegion][BlockID].spareBlockOffsetInSUs;\n\tif (*outSU >= layoutPtr->stripeUnitsPerDisk) {\n\t\tprintf(\"rf_remap_to_spare_space: invalid remapped disk SU offset %ld\\n\", (long) *outSU);\n\t}\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_utils.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_decluster.h\"\n#include \"rf_configure.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_remap_to_spare_space(\n    RF_RaidLayout_t * layoutPtr,\n    RF_DeclusteredConfigInfo_t * info,\n    RF_RowCol_t row,\n    RF_StripeNum_t FullTableID,\n    RF_StripeNum_t TableID,\n    RF_SectorNum_t BlockID,\n    RF_StripeNum_t base_suid,\n    RF_StripeNum_t SpareRegion,\n    RF_RowCol_t * outCol,\n    RF_StripeNum_t * outSU)\n{\n\tRF_StripeNum_t ftID, spareTableStartSU, TableInSpareRegion, lastSROffset,\n\t        which_ft;\n\n\t/*\n         * note that FullTableID and hence SpareRegion may have gotten\n         * tweaked by rf_decluster_adjust_params. We detect this by\n         * noticing that base_suid is not 0.\n         */\n\tif (base_suid == 0) {\n\t\tftID = FullTableID;\n\t} else {\n\t\t/*\n\t         * There may be > 1.0 full tables in the last (i.e. partial)\n\t         * spare region.  find out which of these we're in.\n\t         */\n\t\tlastSROffset = info->NumCompleteSRs * info->SpareRegionDepthInSUs;\n\t\twhich_ft = (info->DiskOffsetOfLastFullTableInSUs - lastSROffset) / (info->FullTableDepthInPUs * layoutPtr->SUsPerPU);\n\n\t\t/* compute the actual full table ID */\n\t\tftID = info->DiskOffsetOfLastFullTableInSUs / (info->FullTableDepthInPUs * layoutPtr->SUsPerPU) + which_ft;\n\t\tSpareRegion = info->NumCompleteSRs;\n\t}\n\tTableInSpareRegion = (ftID * info->NumParityReps + TableID) % info->TablesPerSpareRegion;\n\n\t*outCol = info->SpareTable[TableInSpareRegion][BlockID].spareDisk;\n\tRF_ASSERT(*outCol != -1);\n\n\tspareTableStartSU = (SpareRegion == info->NumCompleteSRs) ?\n\t    info->DiskOffsetOfLastFullTableInSUs + info->ExtraTablesPerDisk * info->TableDepthInPUs * layoutPtr->SUsPerPU :\n\t    (SpareRegion + 1) * info->SpareRegionDepthInSUs - info->SpareSpaceDepthPerRegionInSUs;\n\t*outSU = spareTableStartSU + info->SpareTable[TableInSpareRegion][BlockID].spareBlockOffsetInSUs;\n\tif (*outSU >= layoutPtr->stripeUnitsPerDisk) {\n\t\tprintf(\"rf_remap_to_spare_space: invalid remapped disk SU offset %ld\\n\", (long) *outSU);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "BlockOffset < info->groupSize"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "RepIndex >= 0"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "BlockOffset < info->groupSize - 2"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_decluster_adjust_params",
          "args": [
            "layoutPtr",
            "&SUID",
            "&sus_per_fulltable",
            "&fulltable_depth",
            "&base_suid"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "rf_decluster_adjust_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_decluster.c",
          "lines": "550-579",
          "snippet": "void \nrf_decluster_adjust_params(\n    RF_RaidLayout_t * layoutPtr,\n    RF_StripeNum_t * SUID,\n    RF_StripeCount_t * sus_per_fulltable,\n    RF_StripeCount_t * fulltable_depth,\n    RF_StripeNum_t * base_suid)\n{\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;\n#if (defined(__NetBSD__) || defined (__OpenBSD__)) && defined(_KERNEL)\n\t/* Nothing! */\n#else\n\tchar    pc = layoutPtr->map->parityConfig;\n#endif\n\n\tif (*SUID >= info->FullTableLimitSUID) {\n\t\t/* new full table size is size of last full table on disk */\n\t\t*sus_per_fulltable = info->ExtraTablesPerDisk * info->SUsPerTable;\n\n\t\t/* new full table depth is corresponding depth */\n\t\t*fulltable_depth = info->ExtraTablesPerDisk * info->TableDepthInPUs * layoutPtr->SUsPerPU;\n\n\t\t/* set up the new base offset */\n\t\t*base_suid = info->DiskOffsetOfLastFullTableInSUs;\n\n\t\t/* convert users array address to an offset into the last\n\t\t * fulltable */\n\t\t*SUID -= info->FullTableLimitSUID;\n\t}\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_utils.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_decluster.h\"\n#include \"rf_configure.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_decluster_adjust_params(\n    RF_RaidLayout_t * layoutPtr,\n    RF_StripeNum_t * SUID,\n    RF_StripeCount_t * sus_per_fulltable,\n    RF_StripeCount_t * fulltable_depth,\n    RF_StripeNum_t * base_suid)\n{\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;\n#if (defined(__NetBSD__) || defined (__OpenBSD__)) && defined(_KERNEL)\n\t/* Nothing! */\n#else\n\tchar    pc = layoutPtr->map->parityConfig;\n#endif\n\n\tif (*SUID >= info->FullTableLimitSUID) {\n\t\t/* new full table size is size of last full table on disk */\n\t\t*sus_per_fulltable = info->ExtraTablesPerDisk * info->SUsPerTable;\n\n\t\t/* new full table depth is corresponding depth */\n\t\t*fulltable_depth = info->ExtraTablesPerDisk * info->TableDepthInPUs * layoutPtr->SUsPerPU;\n\n\t\t/* set up the new base offset */\n\t\t*base_suid = info->DiskOffsetOfLastFullTableInSUs;\n\n\t\t/* convert users array address to an offset into the last\n\t\t * fulltable */\n\t\t*SUID -= info->FullTableLimitSUID;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_utils.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_declusterPQ.h\"\n#include \"rf_decluster.h\"\n#include \"rf_configure.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_MapSectorDeclusteredPQ(\n    RF_Raid_t * raidPtr,\n    RF_RaidAddr_t raidSector,\n    RF_RowCol_t * row,\n    RF_RowCol_t * col,\n    RF_SectorNum_t * diskSector,\n    int remap)\n{\n\tRF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);\n\tRF_DeclusteredConfigInfo_t *info = (RF_DeclusteredConfigInfo_t *) layoutPtr->layoutSpecificInfo;\n\tRF_StripeNum_t SUID = raidSector / layoutPtr->sectorsPerStripeUnit;\n\tRF_StripeNum_t FullTableID, FullTableOffset, TableID, TableOffset;\n\tRF_StripeNum_t BlockID, BlockOffset, RepIndex;\n\tRF_StripeCount_t sus_per_fulltable = info->SUsPerFullTable;\n\tRF_StripeCount_t fulltable_depth = info->FullTableDepthInPUs * layoutPtr->SUsPerPU;\n\tRF_StripeNum_t base_suid = 0, outSU, SpareRegion = 0, SpareSpace = 0;\n\n\trf_decluster_adjust_params(layoutPtr, &SUID, &sus_per_fulltable, &fulltable_depth, &base_suid);\n\n\tFullTableID = SUID / sus_per_fulltable;\t/* fulltable ID within array\n\t\t\t\t\t\t * (across rows) */\n\t*row = FullTableID % raidPtr->numRow;\n\tFullTableID /= raidPtr->numRow;\t/* convert to fulltable ID on this\n\t\t\t\t\t * disk */\n\tif ((raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE)) {\n\t\tSpareRegion = FullTableID / info->FullTablesPerSpareRegion;\n\t\tSpareSpace = SpareRegion * info->SpareSpaceDepthPerRegionInSUs;\n\t}\n\tFullTableOffset = SUID % sus_per_fulltable;\n\tTableID = FullTableOffset / info->SUsPerTable;\n\tTableOffset = FullTableOffset - TableID * info->SUsPerTable;\n\tBlockID = TableOffset / info->PUsPerBlock;\n\tBlockOffset = TableOffset - BlockID * info->PUsPerBlock;\n\tBlockID %= info->BlocksPerTable;\n\tRF_ASSERT(BlockOffset < info->groupSize - 2);\n\t/*\n           TableIDs go from 0 .. GroupSize-1 inclusive.\n           PUsPerBlock is k-2.\n           We want the tableIDs to rotate from the\n           right, so use GroupSize\n           */\n\tRepIndex = info->groupSize - 1 - TableID;\n\tRF_ASSERT(RepIndex >= 0);\n\tif (!raidPtr->noRotate) {\n\t\tif (TableID == 0)\n\t\t\tBlockOffset++;\t/* P on last drive, Q on first */\n\t\telse\n\t\t\tBlockOffset += ((BlockOffset >= RepIndex) ? 2 : 0);\t/* skip over PQ */\n\t\tRF_ASSERT(BlockOffset < info->groupSize);\n\t\t*col = info->LayoutTable[BlockID][BlockOffset];\n\t}\n\t/* remap to distributed spare space if indicated */\n\tif (remap) {\n\t\trf_remap_to_spare_space(layoutPtr, info, *row, FullTableID, TableID, BlockID, (base_suid) ? 1 : 0, SpareRegion, col, &outSU);\n\t} else {\n\n\t\toutSU = base_suid;\n\t\toutSU += FullTableID * fulltable_depth;\t/* offs to strt of FT */\n\t\toutSU += SpareSpace;\t/* skip rsvd spare space */\n\t\toutSU += TableID * info->TableDepthInPUs * layoutPtr->SUsPerPU;\t/* offs to strt of tble */\n\t\toutSU += info->OffsetTable[BlockID][BlockOffset] * layoutPtr->SUsPerPU;\t/* offs to the PU */\n\t}\n\toutSU += TableOffset / (info->BlocksPerTable * info->PUsPerBlock);\t/* offs to the SU within\n\t\t\t\t\t\t\t\t\t\t * a PU */\n\n\t/* convert SUs to sectors, and, if not aligned to SU boundary, add in\n\t * offset to sector */\n\t*diskSector = outSU * layoutPtr->sectorsPerStripeUnit + (raidSector % layoutPtr->sectorsPerStripeUnit);\n}"
  },
  {
    "function_name": "rf_GetDefaultNumFloatingReconBuffersPQ",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_declusterPQ.c",
    "lines": "268-275",
    "snippet": "int \nrf_GetDefaultNumFloatingReconBuffersPQ(RF_Raid_t * raidPtr)\n{\n\tint     def_decl;\n\n\tdef_decl = rf_GetDefaultNumFloatingReconBuffersDeclustered(raidPtr);\n\treturn (RF_MAX(3 * raidPtr->numCol, def_decl));\n}",
    "includes": [
      "#include \"rf_general.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_declusterPQ.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_MAX",
          "args": [
            "3 * raidPtr->numCol",
            "def_decl"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_GetDefaultNumFloatingReconBuffersDeclustered",
          "args": [
            "raidPtr"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "rf_GetDefaultNumFloatingReconBuffersDeclustered",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_decluster.c",
          "lines": "529-533",
          "snippet": "int \nrf_GetDefaultNumFloatingReconBuffersDeclustered(RF_Raid_t * raidPtr)\n{\n\treturn (100 * rf_numBufsToAccumulate);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_decluster.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_raidframe.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_utils.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_decluster.h\"\n#include \"rf_configure.h\"\n#include \"rf_raidframe.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nint \nrf_GetDefaultNumFloatingReconBuffersDeclustered(RF_Raid_t * raidPtr)\n{\n\treturn (100 * rf_numBufsToAccumulate);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_utils.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_declusterPQ.h\"\n#include \"rf_decluster.h\"\n#include \"rf_configure.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nint \nrf_GetDefaultNumFloatingReconBuffersPQ(RF_Raid_t * raidPtr)\n{\n\tint     def_decl;\n\n\tdef_decl = rf_GetDefaultNumFloatingReconBuffersDeclustered(raidPtr);\n\treturn (RF_MAX(3 * raidPtr->numCol, def_decl));\n}"
  },
  {
    "function_name": "rf_ConfigureDeclusteredPQ",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_declusterPQ.c",
    "lines": "51-266",
    "snippet": "int \nrf_ConfigureDeclusteredPQ(\n    RF_ShutdownList_t ** listp,\n    RF_Raid_t * raidPtr,\n    RF_Config_t * cfgPtr)\n{\n\tRF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);\n\tint     b, v, k, r, lambda;\t/* block design params */\n\tint     i, j, l;\n\tint    *first_avail_slot;\n\tint     complete_FT_count, SUID;\n\tRF_DeclusteredConfigInfo_t *info;\n\tint     numCompleteFullTablesPerDisk;\n\tint     PUsPerDisk, spareRegionDepthInPUs, numCompleteSpareRegionsPerDisk = 0,\n\t        extraPUsPerDisk;\n\tint     totSparePUsPerDisk;\n\tint     diskOffsetOfLastFullTableInSUs, SpareSpaceInSUs;\n\tchar   *cfgBuf = (char *) (cfgPtr->layoutSpecific);\n\n\tcfgBuf += RF_SPAREMAP_NAME_LEN;\n\n\tb = *((int *) cfgBuf);\n\tcfgBuf += sizeof(int);\n\tv = *((int *) cfgBuf);\n\tcfgBuf += sizeof(int);\n\tk = *((int *) cfgBuf);\n\tcfgBuf += sizeof(int);\n\tr = *((int *) cfgBuf);\n\tcfgBuf += sizeof(int);\n\tlambda = *((int *) cfgBuf);\n\tcfgBuf += sizeof(int);\n\traidPtr->noRotate = *((int *) cfgBuf);\n\tcfgBuf += sizeof(int);\n\n\tif (k <= 2) {\n\t\tprintf(\"RAIDFRAME: k=%d, minimum value 2\\n\", k);\n\t\treturn (EINVAL);\n\t}\n\t/* 1. create layout specific structure */\n\tRF_MallocAndAdd(info, sizeof(RF_DeclusteredConfigInfo_t), (RF_DeclusteredConfigInfo_t *), raidPtr->cleanupList);\n\tif (info == NULL)\n\t\treturn (ENOMEM);\n\tlayoutPtr->layoutSpecificInfo = (void *) info;\n\n\t/* the sparemaps are generated assuming that parity is rotated, so we\n\t * issue a warning if both distributed sparing and no-rotate are on at\n\t * the same time */\n\tif ((raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) && raidPtr->noRotate) {\n\t\tRF_ERRORMSG(\"Warning:  distributed sparing specified without parity rotation.\\n\");\n\t}\n\tif (raidPtr->numCol != v) {\n\t\tRF_ERRORMSG2(\"RAID: config error: table element count (%d) not equal to no. of cols (%d)\\n\", v, raidPtr->numCol);\n\t\treturn (EINVAL);\n\t}\n\t/* 3.  set up the values used in devRaidMap */\n\tinfo->BlocksPerTable = b;\n\tinfo->NumParityReps = info->groupSize = k;\n\tinfo->PUsPerBlock = k - 2;\t/* PQ */\n\tinfo->SUsPerTable = b * info->PUsPerBlock * layoutPtr->SUsPerPU;\t/* b blks, k-1 SUs each */\n\tinfo->SUsPerFullTable = k * info->SUsPerTable;\t/* rot k times */\n\tinfo->SUsPerBlock = info->PUsPerBlock * layoutPtr->SUsPerPU;\n\tinfo->TableDepthInPUs = (b * k) / v;\n\tinfo->FullTableDepthInPUs = info->TableDepthInPUs * k;\t/* k repetitions */\n\n\t/* used only in distributed sparing case */\n\tinfo->FullTablesPerSpareRegion = (v - 1) / rf_gcd(r, v - 1);\t/* (v-1)/gcd fulltables */\n\tinfo->TablesPerSpareRegion = k * info->FullTablesPerSpareRegion;\n\tinfo->SpareSpaceDepthPerRegionInSUs = (r * info->TablesPerSpareRegion / (v - 1)) * layoutPtr->SUsPerPU;\n\n\t/* check to make sure the block design is sufficiently small */\n\tif ((raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE)) {\n\t\tif (info->FullTableDepthInPUs * layoutPtr->SUsPerPU + info->SpareSpaceDepthPerRegionInSUs > layoutPtr->stripeUnitsPerDisk) {\n\t\t\tRF_ERRORMSG3(\"RAID: config error: Full Table depth (%d) + Spare Space (%d) larger than disk size (%d) (BD too big)\\n\",\n\t\t\t    (int) info->FullTableDepthInPUs,\n\t\t\t    (int) info->SpareSpaceDepthPerRegionInSUs,\n\t\t\t    (int) layoutPtr->stripeUnitsPerDisk);\n\t\t\treturn (EINVAL);\n\t\t}\n\t} else {\n\t\tif (info->TableDepthInPUs * layoutPtr->SUsPerPU > layoutPtr->stripeUnitsPerDisk) {\n\t\t\tRF_ERRORMSG2(\"RAID: config error: Table depth (%d) larger than disk size (%d) (BD too big)\\n\",\n\t\t\t    (int) (info->TableDepthInPUs * layoutPtr->SUsPerPU),\n\t\t\t    (int) layoutPtr->stripeUnitsPerDisk);\n\t\t\treturn (EINVAL);\n\t\t}\n\t}\n\n\n\t/* compute the size of each disk, and the number of tables in the last\n\t * fulltable (which need not be complete) */\n\tif ((raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE)) {\n\n\t\tPUsPerDisk = layoutPtr->stripeUnitsPerDisk / layoutPtr->SUsPerPU;\n\t\tspareRegionDepthInPUs = (info->TablesPerSpareRegion * info->TableDepthInPUs +\n\t\t    (info->TablesPerSpareRegion * info->TableDepthInPUs) / (v - 1));\n\t\tinfo->SpareRegionDepthInSUs = spareRegionDepthInPUs * layoutPtr->SUsPerPU;\n\n\t\tnumCompleteSpareRegionsPerDisk = PUsPerDisk / spareRegionDepthInPUs;\n\t\tinfo->NumCompleteSRs = numCompleteSpareRegionsPerDisk;\n\t\textraPUsPerDisk = PUsPerDisk % spareRegionDepthInPUs;\n\n\t\t/* assume conservatively that we need the full amount of spare\n\t\t * space in one region in order to provide spares for the\n\t\t * partial spare region at the end of the array.  We set \"i\"\n\t\t * to the number of tables in the partial spare region.  This\n\t\t * may actually include some fulltables. */\n\t\textraPUsPerDisk -= (info->SpareSpaceDepthPerRegionInSUs / layoutPtr->SUsPerPU);\n\t\tif (extraPUsPerDisk <= 0)\n\t\t\ti = 0;\n\t\telse\n\t\t\ti = extraPUsPerDisk / info->TableDepthInPUs;\n\n\t\tcomplete_FT_count = raidPtr->numRow * (numCompleteSpareRegionsPerDisk * (info->TablesPerSpareRegion / k) + i / k);\n\t\tinfo->FullTableLimitSUID = complete_FT_count * info->SUsPerFullTable;\n\t\tinfo->ExtraTablesPerDisk = i % k;\n\n\t\t/* note that in the last spare region, the spare space is\n\t\t * complete even though data/parity space is not */\n\t\ttotSparePUsPerDisk = (numCompleteSpareRegionsPerDisk + 1) * (info->SpareSpaceDepthPerRegionInSUs / layoutPtr->SUsPerPU);\n\t\tinfo->TotSparePUsPerDisk = totSparePUsPerDisk;\n\n\t\tlayoutPtr->stripeUnitsPerDisk =\n\t\t    ((complete_FT_count / raidPtr->numRow) * info->FullTableDepthInPUs +\t/* data & parity space */\n\t\t    info->ExtraTablesPerDisk * info->TableDepthInPUs +\n\t\t    totSparePUsPerDisk\t/* spare space */\n\t\t    ) * layoutPtr->SUsPerPU;\n\t\tlayoutPtr->dataStripeUnitsPerDisk =\n\t\t    (complete_FT_count * info->FullTableDepthInPUs + info->ExtraTablesPerDisk * info->TableDepthInPUs)\n\t\t    * layoutPtr->SUsPerPU * (k - 1) / k;\n\n\t} else {\n\t\t/* non-dist spare case:  force each disk to contain an\n\t\t * integral number of tables */\n\t\tlayoutPtr->stripeUnitsPerDisk /= (info->TableDepthInPUs * layoutPtr->SUsPerPU);\n\t\tlayoutPtr->stripeUnitsPerDisk *= (info->TableDepthInPUs * layoutPtr->SUsPerPU);\n\n\t\t/* compute the number of tables in the last fulltable, which\n\t\t * need not be complete */\n\t\tcomplete_FT_count =\n\t\t    ((layoutPtr->stripeUnitsPerDisk / layoutPtr->SUsPerPU) / info->FullTableDepthInPUs) * raidPtr->numRow;\n\n\t\tinfo->FullTableLimitSUID = complete_FT_count * info->SUsPerFullTable;\n\t\tinfo->ExtraTablesPerDisk =\n\t\t    ((layoutPtr->stripeUnitsPerDisk / layoutPtr->SUsPerPU) / info->TableDepthInPUs) % k;\n\t}\n\n\traidPtr->sectorsPerDisk = layoutPtr->stripeUnitsPerDisk * layoutPtr->sectorsPerStripeUnit;\n\n\t/* find the disk offset of the stripe unit where the last fulltable\n\t * starts */\n\tnumCompleteFullTablesPerDisk = complete_FT_count / raidPtr->numRow;\n\tdiskOffsetOfLastFullTableInSUs = numCompleteFullTablesPerDisk * info->FullTableDepthInPUs * layoutPtr->SUsPerPU;\n\tif ((raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE)) {\n\t\tSpareSpaceInSUs = numCompleteSpareRegionsPerDisk * info->SpareSpaceDepthPerRegionInSUs;\n\t\tdiskOffsetOfLastFullTableInSUs += SpareSpaceInSUs;\n\t\tinfo->DiskOffsetOfLastSpareSpaceChunkInSUs =\n\t\t    diskOffsetOfLastFullTableInSUs + info->ExtraTablesPerDisk * info->TableDepthInPUs * layoutPtr->SUsPerPU;\n\t}\n\tinfo->DiskOffsetOfLastFullTableInSUs = diskOffsetOfLastFullTableInSUs;\n\tinfo->numCompleteFullTablesPerDisk = numCompleteFullTablesPerDisk;\n\n\t/* 4.  create and initialize the lookup tables */\n\tinfo->LayoutTable = rf_make_2d_array(b, k, raidPtr->cleanupList);\n\tif (info->LayoutTable == NULL)\n\t\treturn (ENOMEM);\n\tinfo->OffsetTable = rf_make_2d_array(b, k, raidPtr->cleanupList);\n\tif (info->OffsetTable == NULL)\n\t\treturn (ENOMEM);\n\tinfo->BlockTable = rf_make_2d_array(info->TableDepthInPUs * layoutPtr->SUsPerPU, raidPtr->numCol, raidPtr->cleanupList);\n\tif (info->BlockTable == NULL)\n\t\treturn (ENOMEM);\n\n\tfirst_avail_slot = (int *) rf_make_1d_array(v, NULL);\n\tif (first_avail_slot == NULL)\n\t\treturn (ENOMEM);\n\n\tfor (i = 0; i < b; i++)\n\t\tfor (j = 0; j < k; j++)\n\t\t\tinfo->LayoutTable[i][j] = *cfgBuf++;\n\n\t/* initialize offset table */\n\tfor (i = 0; i < b; i++)\n\t\tfor (j = 0; j < k; j++) {\n\t\t\tinfo->OffsetTable[i][j] = first_avail_slot[info->LayoutTable[i][j]];\n\t\t\tfirst_avail_slot[info->LayoutTable[i][j]]++;\n\t\t}\n\n\t/* initialize block table */\n\tfor (SUID = l = 0; l < layoutPtr->SUsPerPU; l++) {\n\t\tfor (i = 0; i < b; i++) {\n\t\t\tfor (j = 0; j < k; j++) {\n\t\t\t\tinfo->BlockTable[(info->OffsetTable[i][j] * layoutPtr->SUsPerPU) + l]\n\t\t\t\t    [info->LayoutTable[i][j]] = SUID;\n\t\t\t}\n\t\t\tSUID++;\n\t\t}\n\t}\n\n\trf_free_1d_array(first_avail_slot, v);\n\n\t/* 5.  set up the remaining redundant-but-useful parameters */\n\n\traidPtr->totalSectors = (k * complete_FT_count + raidPtr->numRow * info->ExtraTablesPerDisk) *\n\t    info->SUsPerTable * layoutPtr->sectorsPerStripeUnit;\n\tlayoutPtr->numStripe = (raidPtr->totalSectors / layoutPtr->sectorsPerStripeUnit) / (k - 2);\n\n\t/* strange evaluation order below to try and minimize overflow\n\t * problems */\n\n\tlayoutPtr->dataSectorsPerStripe = (k - 2) * layoutPtr->sectorsPerStripeUnit;\n\tlayoutPtr->bytesPerStripeUnit = layoutPtr->sectorsPerStripeUnit << raidPtr->logBytesPerSector;\n\tlayoutPtr->numDataCol = k - 2;\n\tlayoutPtr->numParityCol = 2;\n\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_general.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_declusterPQ.h\"",
      "#include \"rf_decluster.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_free_1d_array",
          "args": [
            "first_avail_slot",
            "v"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "rf_free_1d_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_utils.c",
          "lines": "90-96",
          "snippet": "void \nrf_free_1d_array(a, n)\n\tRF_RowCol_t *a;\n\tint     n;\n{\n\tRF_Free(a, n * sizeof(RF_RowCol_t));\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_utils.h\"",
            "#include <sys/time.h>",
            "#include \"rf_threadstuff.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_utils.h\"\n#include <sys/time.h>\n#include \"rf_threadstuff.h\"\n\nvoid \nrf_free_1d_array(a, n)\n\tRF_RowCol_t *a;\n\tint     n;\n{\n\tRF_Free(a, n * sizeof(RF_RowCol_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_make_1d_array",
          "args": [
            "v",
            "NULL"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_make_2d_array",
          "args": [
            "info->TableDepthInPUs * layoutPtr->SUsPerPU",
            "raidPtr->numCol",
            "raidPtr->cleanupList"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_make_2d_array",
          "args": [
            "b",
            "k",
            "raidPtr->cleanupList"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_make_2d_array",
          "args": [
            "b",
            "k",
            "raidPtr->cleanupList"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG2",
          "args": [
            "\"RAID: config error: Table depth (%d) larger than disk size (%d) (BD too big)\\n\"",
            "(int) (info->TableDepthInPUs * layoutPtr->SUsPerPU)",
            "(int) layoutPtr->stripeUnitsPerDisk"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"RAID: config error: Full Table depth (%d) + Spare Space (%d) larger than disk size (%d) (BD too big)\\n\"",
            "(int) info->FullTableDepthInPUs",
            "(int) info->SpareSpaceDepthPerRegionInSUs",
            "(int) layoutPtr->stripeUnitsPerDisk"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_gcd",
          "args": [
            "r",
            "v - 1"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "rf_gcd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_utils.c",
          "lines": "100-113",
          "snippet": "int \nrf_gcd(m, n)\n\tint     m;\n\tint     n;\n{\n\tint     t;\n\n\twhile (m > 0) {\n\t\tt = n % m;\n\t\tn = m;\n\t\tm = t;\n\t}\n\treturn (n);\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_utils.h\"",
            "#include <sys/time.h>",
            "#include \"rf_threadstuff.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_utils.h\"\n#include <sys/time.h>\n#include \"rf_threadstuff.h\"\n\nint \nrf_gcd(m, n)\n\tint     m;\n\tint     n;\n{\n\tint     t;\n\n\twhile (m > 0) {\n\t\tt = n % m;\n\t\tn = m;\n\t\tm = t;\n\t}\n\treturn (n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG2",
          "args": [
            "\"RAID: config error: table element count (%d) not equal to no. of cols (%d)\\n\"",
            "v",
            "raidPtr->numCol"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG",
          "args": [
            "\"Warning:  distributed sparing specified without parity rotation.\\n\""
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_MallocAndAdd",
          "args": [
            "info",
            "sizeof(RF_DeclusteredConfigInfo_t)",
            "(RF_DeclusteredConfigInfo_t *), raidPtr->cleanupList"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"RAIDFRAME: k=%d, minimum value 2\\n\"",
            "k"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_utils.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_declusterPQ.h\"\n#include \"rf_decluster.h\"\n#include \"rf_configure.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nint \nrf_ConfigureDeclusteredPQ(\n    RF_ShutdownList_t ** listp,\n    RF_Raid_t * raidPtr,\n    RF_Config_t * cfgPtr)\n{\n\tRF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);\n\tint     b, v, k, r, lambda;\t/* block design params */\n\tint     i, j, l;\n\tint    *first_avail_slot;\n\tint     complete_FT_count, SUID;\n\tRF_DeclusteredConfigInfo_t *info;\n\tint     numCompleteFullTablesPerDisk;\n\tint     PUsPerDisk, spareRegionDepthInPUs, numCompleteSpareRegionsPerDisk = 0,\n\t        extraPUsPerDisk;\n\tint     totSparePUsPerDisk;\n\tint     diskOffsetOfLastFullTableInSUs, SpareSpaceInSUs;\n\tchar   *cfgBuf = (char *) (cfgPtr->layoutSpecific);\n\n\tcfgBuf += RF_SPAREMAP_NAME_LEN;\n\n\tb = *((int *) cfgBuf);\n\tcfgBuf += sizeof(int);\n\tv = *((int *) cfgBuf);\n\tcfgBuf += sizeof(int);\n\tk = *((int *) cfgBuf);\n\tcfgBuf += sizeof(int);\n\tr = *((int *) cfgBuf);\n\tcfgBuf += sizeof(int);\n\tlambda = *((int *) cfgBuf);\n\tcfgBuf += sizeof(int);\n\traidPtr->noRotate = *((int *) cfgBuf);\n\tcfgBuf += sizeof(int);\n\n\tif (k <= 2) {\n\t\tprintf(\"RAIDFRAME: k=%d, minimum value 2\\n\", k);\n\t\treturn (EINVAL);\n\t}\n\t/* 1. create layout specific structure */\n\tRF_MallocAndAdd(info, sizeof(RF_DeclusteredConfigInfo_t), (RF_DeclusteredConfigInfo_t *), raidPtr->cleanupList);\n\tif (info == NULL)\n\t\treturn (ENOMEM);\n\tlayoutPtr->layoutSpecificInfo = (void *) info;\n\n\t/* the sparemaps are generated assuming that parity is rotated, so we\n\t * issue a warning if both distributed sparing and no-rotate are on at\n\t * the same time */\n\tif ((raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) && raidPtr->noRotate) {\n\t\tRF_ERRORMSG(\"Warning:  distributed sparing specified without parity rotation.\\n\");\n\t}\n\tif (raidPtr->numCol != v) {\n\t\tRF_ERRORMSG2(\"RAID: config error: table element count (%d) not equal to no. of cols (%d)\\n\", v, raidPtr->numCol);\n\t\treturn (EINVAL);\n\t}\n\t/* 3.  set up the values used in devRaidMap */\n\tinfo->BlocksPerTable = b;\n\tinfo->NumParityReps = info->groupSize = k;\n\tinfo->PUsPerBlock = k - 2;\t/* PQ */\n\tinfo->SUsPerTable = b * info->PUsPerBlock * layoutPtr->SUsPerPU;\t/* b blks, k-1 SUs each */\n\tinfo->SUsPerFullTable = k * info->SUsPerTable;\t/* rot k times */\n\tinfo->SUsPerBlock = info->PUsPerBlock * layoutPtr->SUsPerPU;\n\tinfo->TableDepthInPUs = (b * k) / v;\n\tinfo->FullTableDepthInPUs = info->TableDepthInPUs * k;\t/* k repetitions */\n\n\t/* used only in distributed sparing case */\n\tinfo->FullTablesPerSpareRegion = (v - 1) / rf_gcd(r, v - 1);\t/* (v-1)/gcd fulltables */\n\tinfo->TablesPerSpareRegion = k * info->FullTablesPerSpareRegion;\n\tinfo->SpareSpaceDepthPerRegionInSUs = (r * info->TablesPerSpareRegion / (v - 1)) * layoutPtr->SUsPerPU;\n\n\t/* check to make sure the block design is sufficiently small */\n\tif ((raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE)) {\n\t\tif (info->FullTableDepthInPUs * layoutPtr->SUsPerPU + info->SpareSpaceDepthPerRegionInSUs > layoutPtr->stripeUnitsPerDisk) {\n\t\t\tRF_ERRORMSG3(\"RAID: config error: Full Table depth (%d) + Spare Space (%d) larger than disk size (%d) (BD too big)\\n\",\n\t\t\t    (int) info->FullTableDepthInPUs,\n\t\t\t    (int) info->SpareSpaceDepthPerRegionInSUs,\n\t\t\t    (int) layoutPtr->stripeUnitsPerDisk);\n\t\t\treturn (EINVAL);\n\t\t}\n\t} else {\n\t\tif (info->TableDepthInPUs * layoutPtr->SUsPerPU > layoutPtr->stripeUnitsPerDisk) {\n\t\t\tRF_ERRORMSG2(\"RAID: config error: Table depth (%d) larger than disk size (%d) (BD too big)\\n\",\n\t\t\t    (int) (info->TableDepthInPUs * layoutPtr->SUsPerPU),\n\t\t\t    (int) layoutPtr->stripeUnitsPerDisk);\n\t\t\treturn (EINVAL);\n\t\t}\n\t}\n\n\n\t/* compute the size of each disk, and the number of tables in the last\n\t * fulltable (which need not be complete) */\n\tif ((raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE)) {\n\n\t\tPUsPerDisk = layoutPtr->stripeUnitsPerDisk / layoutPtr->SUsPerPU;\n\t\tspareRegionDepthInPUs = (info->TablesPerSpareRegion * info->TableDepthInPUs +\n\t\t    (info->TablesPerSpareRegion * info->TableDepthInPUs) / (v - 1));\n\t\tinfo->SpareRegionDepthInSUs = spareRegionDepthInPUs * layoutPtr->SUsPerPU;\n\n\t\tnumCompleteSpareRegionsPerDisk = PUsPerDisk / spareRegionDepthInPUs;\n\t\tinfo->NumCompleteSRs = numCompleteSpareRegionsPerDisk;\n\t\textraPUsPerDisk = PUsPerDisk % spareRegionDepthInPUs;\n\n\t\t/* assume conservatively that we need the full amount of spare\n\t\t * space in one region in order to provide spares for the\n\t\t * partial spare region at the end of the array.  We set \"i\"\n\t\t * to the number of tables in the partial spare region.  This\n\t\t * may actually include some fulltables. */\n\t\textraPUsPerDisk -= (info->SpareSpaceDepthPerRegionInSUs / layoutPtr->SUsPerPU);\n\t\tif (extraPUsPerDisk <= 0)\n\t\t\ti = 0;\n\t\telse\n\t\t\ti = extraPUsPerDisk / info->TableDepthInPUs;\n\n\t\tcomplete_FT_count = raidPtr->numRow * (numCompleteSpareRegionsPerDisk * (info->TablesPerSpareRegion / k) + i / k);\n\t\tinfo->FullTableLimitSUID = complete_FT_count * info->SUsPerFullTable;\n\t\tinfo->ExtraTablesPerDisk = i % k;\n\n\t\t/* note that in the last spare region, the spare space is\n\t\t * complete even though data/parity space is not */\n\t\ttotSparePUsPerDisk = (numCompleteSpareRegionsPerDisk + 1) * (info->SpareSpaceDepthPerRegionInSUs / layoutPtr->SUsPerPU);\n\t\tinfo->TotSparePUsPerDisk = totSparePUsPerDisk;\n\n\t\tlayoutPtr->stripeUnitsPerDisk =\n\t\t    ((complete_FT_count / raidPtr->numRow) * info->FullTableDepthInPUs +\t/* data & parity space */\n\t\t    info->ExtraTablesPerDisk * info->TableDepthInPUs +\n\t\t    totSparePUsPerDisk\t/* spare space */\n\t\t    ) * layoutPtr->SUsPerPU;\n\t\tlayoutPtr->dataStripeUnitsPerDisk =\n\t\t    (complete_FT_count * info->FullTableDepthInPUs + info->ExtraTablesPerDisk * info->TableDepthInPUs)\n\t\t    * layoutPtr->SUsPerPU * (k - 1) / k;\n\n\t} else {\n\t\t/* non-dist spare case:  force each disk to contain an\n\t\t * integral number of tables */\n\t\tlayoutPtr->stripeUnitsPerDisk /= (info->TableDepthInPUs * layoutPtr->SUsPerPU);\n\t\tlayoutPtr->stripeUnitsPerDisk *= (info->TableDepthInPUs * layoutPtr->SUsPerPU);\n\n\t\t/* compute the number of tables in the last fulltable, which\n\t\t * need not be complete */\n\t\tcomplete_FT_count =\n\t\t    ((layoutPtr->stripeUnitsPerDisk / layoutPtr->SUsPerPU) / info->FullTableDepthInPUs) * raidPtr->numRow;\n\n\t\tinfo->FullTableLimitSUID = complete_FT_count * info->SUsPerFullTable;\n\t\tinfo->ExtraTablesPerDisk =\n\t\t    ((layoutPtr->stripeUnitsPerDisk / layoutPtr->SUsPerPU) / info->TableDepthInPUs) % k;\n\t}\n\n\traidPtr->sectorsPerDisk = layoutPtr->stripeUnitsPerDisk * layoutPtr->sectorsPerStripeUnit;\n\n\t/* find the disk offset of the stripe unit where the last fulltable\n\t * starts */\n\tnumCompleteFullTablesPerDisk = complete_FT_count / raidPtr->numRow;\n\tdiskOffsetOfLastFullTableInSUs = numCompleteFullTablesPerDisk * info->FullTableDepthInPUs * layoutPtr->SUsPerPU;\n\tif ((raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE)) {\n\t\tSpareSpaceInSUs = numCompleteSpareRegionsPerDisk * info->SpareSpaceDepthPerRegionInSUs;\n\t\tdiskOffsetOfLastFullTableInSUs += SpareSpaceInSUs;\n\t\tinfo->DiskOffsetOfLastSpareSpaceChunkInSUs =\n\t\t    diskOffsetOfLastFullTableInSUs + info->ExtraTablesPerDisk * info->TableDepthInPUs * layoutPtr->SUsPerPU;\n\t}\n\tinfo->DiskOffsetOfLastFullTableInSUs = diskOffsetOfLastFullTableInSUs;\n\tinfo->numCompleteFullTablesPerDisk = numCompleteFullTablesPerDisk;\n\n\t/* 4.  create and initialize the lookup tables */\n\tinfo->LayoutTable = rf_make_2d_array(b, k, raidPtr->cleanupList);\n\tif (info->LayoutTable == NULL)\n\t\treturn (ENOMEM);\n\tinfo->OffsetTable = rf_make_2d_array(b, k, raidPtr->cleanupList);\n\tif (info->OffsetTable == NULL)\n\t\treturn (ENOMEM);\n\tinfo->BlockTable = rf_make_2d_array(info->TableDepthInPUs * layoutPtr->SUsPerPU, raidPtr->numCol, raidPtr->cleanupList);\n\tif (info->BlockTable == NULL)\n\t\treturn (ENOMEM);\n\n\tfirst_avail_slot = (int *) rf_make_1d_array(v, NULL);\n\tif (first_avail_slot == NULL)\n\t\treturn (ENOMEM);\n\n\tfor (i = 0; i < b; i++)\n\t\tfor (j = 0; j < k; j++)\n\t\t\tinfo->LayoutTable[i][j] = *cfgBuf++;\n\n\t/* initialize offset table */\n\tfor (i = 0; i < b; i++)\n\t\tfor (j = 0; j < k; j++) {\n\t\t\tinfo->OffsetTable[i][j] = first_avail_slot[info->LayoutTable[i][j]];\n\t\t\tfirst_avail_slot[info->LayoutTable[i][j]]++;\n\t\t}\n\n\t/* initialize block table */\n\tfor (SUID = l = 0; l < layoutPtr->SUsPerPU; l++) {\n\t\tfor (i = 0; i < b; i++) {\n\t\t\tfor (j = 0; j < k; j++) {\n\t\t\t\tinfo->BlockTable[(info->OffsetTable[i][j] * layoutPtr->SUsPerPU) + l]\n\t\t\t\t    [info->LayoutTable[i][j]] = SUID;\n\t\t\t}\n\t\t\tSUID++;\n\t\t}\n\t}\n\n\trf_free_1d_array(first_avail_slot, v);\n\n\t/* 5.  set up the remaining redundant-but-useful parameters */\n\n\traidPtr->totalSectors = (k * complete_FT_count + raidPtr->numRow * info->ExtraTablesPerDisk) *\n\t    info->SUsPerTable * layoutPtr->sectorsPerStripeUnit;\n\tlayoutPtr->numStripe = (raidPtr->totalSectors / layoutPtr->sectorsPerStripeUnit) / (k - 2);\n\n\t/* strange evaluation order below to try and minimize overflow\n\t * problems */\n\n\tlayoutPtr->dataSectorsPerStripe = (k - 2) * layoutPtr->sectorsPerStripeUnit;\n\tlayoutPtr->bytesPerStripeUnit = layoutPtr->sectorsPerStripeUnit << raidPtr->logBytesPerSector;\n\tlayoutPtr->numDataCol = k - 2;\n\tlayoutPtr->numParityCol = 2;\n\n\treturn (0);\n}"
  }
]