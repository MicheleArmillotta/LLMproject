[
  {
    "function_name": "usb_freemem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_mem.c",
    "lines": "271-291",
    "snippet": "void\nusb_freemem(bus, p)\n\tusbd_bus_handle bus;\n        usb_dma_t *p;\n{\n\tstruct usb_frag_dma *f;\n\tint s;\n\n\tif (p->block->fullblock) {\n\t\tDPRINTFN(1, (\"usb_freemem: large free\\n\"));\n\t\tusb_block_freemem(p->block);\n\t\treturn;\n\t}\n\tf = KERNADDR(p);\n\tf->block = p->block;\n\tf->offs = p->offs;\n\ts = splusb();\n\tLIST_INSERT_HEAD(&usb_frag_freelist, f, next);\n\tsplx(s);\n\tDPRINTFN(5, (\"usb_freemem: frag=%p\\n\", f));\n}",
    "includes": [
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>\t/* just for usb_dma_t */",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/proc.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>\t\t/* for usbdivar.h */",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static LIST_HEAD(, usb_frag_dma) usb_frag_freelist =\n\tLIST_HEAD_INITIALIZER(usb_frag_freelist);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"usb_freemem: frag=%p\\n\", f)"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_INSERT_HEAD",
          "args": [
            "&usb_frag_freelist",
            "f",
            "next"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KERNADDR",
          "args": [
            "p"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_block_freemem",
          "args": [
            "p->block"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "usb_block_freemem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_mem.c",
          "lines": "203-214",
          "snippet": "Static void\nusb_block_freemem(p)\n        usb_dma_block_t *p;\n{\n\tint s;\n\n\tDPRINTFN(6, (\"usb_block_freemem: size=%lu\\n\", (u_long)p->size));\n\ts = splusb();\n\tLIST_INSERT_HEAD(&usb_blk_freelist, p, next);\n\tusb_blk_nfree++;\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>\t/* just for usb_dma_t */",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/proc.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>\t\t/* for usbdivar.h */",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usb_block_allocmem __P((bus_dma_tag_t, size_t, size_t,\n\t\t\t\t\t\tusb_dma_block_t **));",
            "Static void",
            "usb_block_freemem  __P((usb_dma_block_t *));",
            "Static LIST_HEAD(, usb_dma_block) usb_blk_freelist = \n\tLIST_HEAD_INITIALIZER(usb_blk_freelist);",
            "Static int usb_blk_nfree = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\t/* just for usb_dma_t */\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/proc.h>\n#include <machine/bus.h>\n#include <sys/device.h>\t\t/* for usbdivar.h */\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusb_block_allocmem __P((bus_dma_tag_t, size_t, size_t,\n\t\t\t\t\t\tusb_dma_block_t **));\nStatic void;\nusb_block_freemem  __P((usb_dma_block_t *));\nStatic LIST_HEAD(, usb_dma_block) usb_blk_freelist = \n\tLIST_HEAD_INITIALIZER(usb_blk_freelist);\nStatic int usb_blk_nfree = 0;\n\nStatic void\nusb_block_freemem(p)\n        usb_dma_block_t *p;\n{\n\tint s;\n\n\tDPRINTFN(6, (\"usb_block_freemem: size=%lu\\n\", (u_long)p->size));\n\ts = splusb();\n\tLIST_INSERT_HEAD(&usb_blk_freelist, p, next);\n\tusb_blk_nfree++;\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"usb_freemem: large free\\n\")"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\t/* just for usb_dma_t */\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/proc.h>\n#include <machine/bus.h>\n#include <sys/device.h>\t\t/* for usbdivar.h */\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic LIST_HEAD(, usb_frag_dma) usb_frag_freelist =\n\tLIST_HEAD_INITIALIZER(usb_frag_freelist);\n\nvoid\nusb_freemem(bus, p)\n\tusbd_bus_handle bus;\n        usb_dma_t *p;\n{\n\tstruct usb_frag_dma *f;\n\tint s;\n\n\tif (p->block->fullblock) {\n\t\tDPRINTFN(1, (\"usb_freemem: large free\\n\"));\n\t\tusb_block_freemem(p->block);\n\t\treturn;\n\t}\n\tf = KERNADDR(p);\n\tf->block = p->block;\n\tf->offs = p->offs;\n\ts = splusb();\n\tLIST_INSERT_HEAD(&usb_frag_freelist, f, next);\n\tsplx(s);\n\tDPRINTFN(5, (\"usb_freemem: frag=%p\\n\", f));\n}"
  },
  {
    "function_name": "usb_allocmem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_mem.c",
    "lines": "216-269",
    "snippet": "usbd_status\nusb_allocmem(bus, size, align, p)\n\tusbd_bus_handle bus;\n\tsize_t size;\n\tsize_t align;\n        usb_dma_t *p;\n{\n\tbus_dma_tag_t tag = bus->dmatag;\n\tusbd_status err;\n\tstruct usb_frag_dma *f;\n\tusb_dma_block_t *b;\n\tint i;\n\tint s;\n\n\t/* If the request is large then just use a full block. */\n\tif (size > USB_MEM_SMALL || align > USB_MEM_SMALL) {\n\t\tDPRINTFN(1, (\"usb_allocmem: large alloc %d\\n\", (int)size));\n\t\tsize = (size + USB_MEM_BLOCK - 1) & ~(USB_MEM_BLOCK - 1);\n\t\terr = usb_block_allocmem(tag, size, align, &p->block);\n\t\tif (!err) {\n\t\t\tp->block->fullblock = 1;\n\t\t\tp->offs = 0;\n\t\t}\n\t\treturn (err);\n\t}\n\t\n\ts = splusb();\n\t/* Check for free fragments. */\n\tfor (f = LIST_FIRST(&usb_frag_freelist); f; f = LIST_NEXT(f, next))\n\t\tif (f->block->tag == tag)\n\t\t\tbreak;\n\tif (f == NULL) {\n\t\tDPRINTFN(1, (\"usb_allocmem: adding fragments\\n\"));\n\t\terr = usb_block_allocmem(tag, USB_MEM_BLOCK, USB_MEM_SMALL,&b);\n\t\tif (err) {\n\t\t\tsplx(s);\n\t\t\treturn (err);\n\t\t}\n\t\tb->fullblock = 0;\n\t\tfor (i = 0; i < USB_MEM_BLOCK; i += USB_MEM_SMALL) {\n\t\t\tf = (struct usb_frag_dma *)(b->kaddr + i);\n\t\t\tf->block = b;\n\t\t\tf->offs = i;\n\t\t\tLIST_INSERT_HEAD(&usb_frag_freelist, f, next);\n\t\t}\n\t\tf = LIST_FIRST(&usb_frag_freelist);\n\t}\n\tp->block = f->block;\n\tp->offs = f->offs;\n\tLIST_REMOVE(f, next);\n\tsplx(s);\n\tDPRINTFN(5, (\"usb_allocmem: use frag=%p size=%d\\n\", f, (int)size));\n\treturn (USBD_NORMAL_COMPLETION);\n}",
    "includes": [
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>\t/* just for usb_dma_t */",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/proc.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>\t\t/* for usbdivar.h */",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define USB_MEM_BLOCK (USB_MEM_SMALL * USB_MEM_CHUNKS)",
      "#define USB_MEM_SMALL 64"
    ],
    "globals_used": [
      "Static usbd_status",
      "usb_block_allocmem __P((bus_dma_tag_t, size_t, size_t,\n\t\t\t\t\t\tusb_dma_block_t **));",
      "usb_block_freemem  __P((usb_dma_block_t *));",
      "Static LIST_HEAD(, usb_frag_dma) usb_frag_freelist =\n\tLIST_HEAD_INITIALIZER(usb_frag_freelist);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"usb_allocmem: use frag=%p size=%d\\n\", f, (int)size)"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_REMOVE",
          "args": [
            "f",
            "next"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_FIRST",
          "args": [
            "&usb_frag_freelist"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_INSERT_HEAD",
          "args": [
            "&usb_frag_freelist",
            "f",
            "next"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_block_allocmem",
          "args": [
            "tag",
            "USB_MEM_BLOCK",
            "USB_MEM_SMALL",
            "&b"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "usb_block_allocmem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_mem.c",
          "lines": "96-177",
          "snippet": "Static usbd_status\nusb_block_allocmem(tag, size, align, dmap)\n\tbus_dma_tag_t tag;\n\tsize_t size;\n\tsize_t align;\n        usb_dma_block_t **dmap;\n{\n\tint error;\n        usb_dma_block_t *p;\n\tint s;\n\n\tDPRINTFN(5, (\"usb_block_allocmem: size=%lu align=%lu\\n\", \n\t\t     (u_long)size, (u_long)align));\n\n#ifdef DIAGNOSTIC\n\tif (!curproc) {\n\t\tprintf(\"usb_block_allocmem: in interrupt context, size=%lu\\n\",\n\t\t    (unsigned long) size);\n\t}\n#endif\n\n\ts = splusb();\n\t/* First check the free list. */\n\tfor (p = LIST_FIRST(&usb_blk_freelist); p; p = LIST_NEXT(p, next)) {\n\t\tif (p->tag == tag && p->size >= size && p->align >= align) {\n\t\t\tLIST_REMOVE(p, next);\n\t\t\tusb_blk_nfree--;\n\t\t\tsplx(s);\n\t\t\t*dmap = p;\n\t\t\tDPRINTFN(6,(\"usb_block_allocmem: free list size=%lu\\n\",\n\t\t\t\t    (u_long)p->size));\n\t\t\treturn (USBD_NORMAL_COMPLETION);\n\t\t}\n\t}\n\tsplx(s);\n\n#ifdef DIAGNOSTIC\n\tif (!curproc) {\n\t\tprintf(\"usb_block_allocmem: in interrupt context, failed\\n\");\n\t\treturn (USBD_NOMEM);\n\t}\n#endif\n\n\tDPRINTFN(6, (\"usb_block_allocmem: no free\\n\"));\n\tp = malloc(sizeof *p, M_USB, M_NOWAIT);\n\tif (p == NULL)\n\t\treturn (USBD_NOMEM);\n\t*dmap = p;\n\n\tp->tag = tag;\n\tp->size = size;\n\tp->align = align;\n\terror = bus_dmamem_alloc(tag, p->size, align, 0,\n\t\t\t\t p->segs, sizeof(p->segs)/sizeof(p->segs[0]),\n\t\t\t\t &p->nsegs, BUS_DMA_NOWAIT);\n\tif (error)\n\t\treturn (USBD_NOMEM);\n\n\terror = bus_dmamem_map(tag, p->segs, p->nsegs, p->size, \n\t\t\t       &p->kaddr, BUS_DMA_NOWAIT|BUS_DMA_COHERENT);\n\tif (error)\n\t\tgoto free;\n\n\terror = bus_dmamap_create(tag, p->size, 1, p->size,\n\t\t\t\t  0, BUS_DMA_NOWAIT, &p->map);\n\tif (error)\n\t\tgoto unmap;\n\n\terror = bus_dmamap_load(tag, p->map, p->kaddr, p->size, NULL, \n\t\t\t\tBUS_DMA_NOWAIT);\n\tif (error)\n\t\tgoto destroy;\n\treturn (USBD_NORMAL_COMPLETION);\n\ndestroy:\n\tbus_dmamap_destroy(tag, p->map);\nunmap:\n\tbus_dmamem_unmap(tag, p->kaddr, p->size);\nfree:\n\tbus_dmamem_free(tag, p->segs, p->nsegs);\n\treturn (USBD_NOMEM);\n}",
          "includes": [
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>\t/* just for usb_dma_t */",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/proc.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>\t\t/* for usbdivar.h */",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usb_block_allocmem __P((bus_dma_tag_t, size_t, size_t,\n\t\t\t\t\t\tusb_dma_block_t **));",
            "Static void",
            "usb_block_freemem  __P((usb_dma_block_t *));",
            "Static LIST_HEAD(, usb_dma_block) usb_blk_freelist = \n\tLIST_HEAD_INITIALIZER(usb_blk_freelist);",
            "Static int usb_blk_nfree = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\t/* just for usb_dma_t */\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/proc.h>\n#include <machine/bus.h>\n#include <sys/device.h>\t\t/* for usbdivar.h */\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusb_block_allocmem __P((bus_dma_tag_t, size_t, size_t,\n\t\t\t\t\t\tusb_dma_block_t **));\nStatic void;\nusb_block_freemem  __P((usb_dma_block_t *));\nStatic LIST_HEAD(, usb_dma_block) usb_blk_freelist = \n\tLIST_HEAD_INITIALIZER(usb_blk_freelist);\nStatic int usb_blk_nfree = 0;\n\nStatic usbd_status\nusb_block_allocmem(tag, size, align, dmap)\n\tbus_dma_tag_t tag;\n\tsize_t size;\n\tsize_t align;\n        usb_dma_block_t **dmap;\n{\n\tint error;\n        usb_dma_block_t *p;\n\tint s;\n\n\tDPRINTFN(5, (\"usb_block_allocmem: size=%lu align=%lu\\n\", \n\t\t     (u_long)size, (u_long)align));\n\n#ifdef DIAGNOSTIC\n\tif (!curproc) {\n\t\tprintf(\"usb_block_allocmem: in interrupt context, size=%lu\\n\",\n\t\t    (unsigned long) size);\n\t}\n#endif\n\n\ts = splusb();\n\t/* First check the free list. */\n\tfor (p = LIST_FIRST(&usb_blk_freelist); p; p = LIST_NEXT(p, next)) {\n\t\tif (p->tag == tag && p->size >= size && p->align >= align) {\n\t\t\tLIST_REMOVE(p, next);\n\t\t\tusb_blk_nfree--;\n\t\t\tsplx(s);\n\t\t\t*dmap = p;\n\t\t\tDPRINTFN(6,(\"usb_block_allocmem: free list size=%lu\\n\",\n\t\t\t\t    (u_long)p->size));\n\t\t\treturn (USBD_NORMAL_COMPLETION);\n\t\t}\n\t}\n\tsplx(s);\n\n#ifdef DIAGNOSTIC\n\tif (!curproc) {\n\t\tprintf(\"usb_block_allocmem: in interrupt context, failed\\n\");\n\t\treturn (USBD_NOMEM);\n\t}\n#endif\n\n\tDPRINTFN(6, (\"usb_block_allocmem: no free\\n\"));\n\tp = malloc(sizeof *p, M_USB, M_NOWAIT);\n\tif (p == NULL)\n\t\treturn (USBD_NOMEM);\n\t*dmap = p;\n\n\tp->tag = tag;\n\tp->size = size;\n\tp->align = align;\n\terror = bus_dmamem_alloc(tag, p->size, align, 0,\n\t\t\t\t p->segs, sizeof(p->segs)/sizeof(p->segs[0]),\n\t\t\t\t &p->nsegs, BUS_DMA_NOWAIT);\n\tif (error)\n\t\treturn (USBD_NOMEM);\n\n\terror = bus_dmamem_map(tag, p->segs, p->nsegs, p->size, \n\t\t\t       &p->kaddr, BUS_DMA_NOWAIT|BUS_DMA_COHERENT);\n\tif (error)\n\t\tgoto free;\n\n\terror = bus_dmamap_create(tag, p->size, 1, p->size,\n\t\t\t\t  0, BUS_DMA_NOWAIT, &p->map);\n\tif (error)\n\t\tgoto unmap;\n\n\terror = bus_dmamap_load(tag, p->map, p->kaddr, p->size, NULL, \n\t\t\t\tBUS_DMA_NOWAIT);\n\tif (error)\n\t\tgoto destroy;\n\treturn (USBD_NORMAL_COMPLETION);\n\ndestroy:\n\tbus_dmamap_destroy(tag, p->map);\nunmap:\n\tbus_dmamem_unmap(tag, p->kaddr, p->size);\nfree:\n\tbus_dmamem_free(tag, p->segs, p->nsegs);\n\treturn (USBD_NOMEM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"usb_allocmem: adding fragments\\n\")"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_NEXT",
          "args": [
            "f",
            "next"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_FIRST",
          "args": [
            "&usb_frag_freelist"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"usb_allocmem: large alloc %d\\n\", (int)size)"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\t/* just for usb_dma_t */\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/proc.h>\n#include <machine/bus.h>\n#include <sys/device.h>\t\t/* for usbdivar.h */\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define USB_MEM_BLOCK (USB_MEM_SMALL * USB_MEM_CHUNKS)\n#define USB_MEM_SMALL 64\n\nStatic usbd_status;\nusb_block_allocmem __P((bus_dma_tag_t, size_t, size_t,\n\t\t\t\t\t\tusb_dma_block_t **));\nusb_block_freemem  __P((usb_dma_block_t *));\nStatic LIST_HEAD(, usb_frag_dma) usb_frag_freelist =\n\tLIST_HEAD_INITIALIZER(usb_frag_freelist);\n\nusbd_status\nusb_allocmem(bus, size, align, p)\n\tusbd_bus_handle bus;\n\tsize_t size;\n\tsize_t align;\n        usb_dma_t *p;\n{\n\tbus_dma_tag_t tag = bus->dmatag;\n\tusbd_status err;\n\tstruct usb_frag_dma *f;\n\tusb_dma_block_t *b;\n\tint i;\n\tint s;\n\n\t/* If the request is large then just use a full block. */\n\tif (size > USB_MEM_SMALL || align > USB_MEM_SMALL) {\n\t\tDPRINTFN(1, (\"usb_allocmem: large alloc %d\\n\", (int)size));\n\t\tsize = (size + USB_MEM_BLOCK - 1) & ~(USB_MEM_BLOCK - 1);\n\t\terr = usb_block_allocmem(tag, size, align, &p->block);\n\t\tif (!err) {\n\t\t\tp->block->fullblock = 1;\n\t\t\tp->offs = 0;\n\t\t}\n\t\treturn (err);\n\t}\n\t\n\ts = splusb();\n\t/* Check for free fragments. */\n\tfor (f = LIST_FIRST(&usb_frag_freelist); f; f = LIST_NEXT(f, next))\n\t\tif (f->block->tag == tag)\n\t\t\tbreak;\n\tif (f == NULL) {\n\t\tDPRINTFN(1, (\"usb_allocmem: adding fragments\\n\"));\n\t\terr = usb_block_allocmem(tag, USB_MEM_BLOCK, USB_MEM_SMALL,&b);\n\t\tif (err) {\n\t\t\tsplx(s);\n\t\t\treturn (err);\n\t\t}\n\t\tb->fullblock = 0;\n\t\tfor (i = 0; i < USB_MEM_BLOCK; i += USB_MEM_SMALL) {\n\t\t\tf = (struct usb_frag_dma *)(b->kaddr + i);\n\t\t\tf->block = b;\n\t\t\tf->offs = i;\n\t\t\tLIST_INSERT_HEAD(&usb_frag_freelist, f, next);\n\t\t}\n\t\tf = LIST_FIRST(&usb_frag_freelist);\n\t}\n\tp->block = f->block;\n\tp->offs = f->offs;\n\tLIST_REMOVE(f, next);\n\tsplx(s);\n\tDPRINTFN(5, (\"usb_allocmem: use frag=%p size=%d\\n\", f, (int)size));\n\treturn (USBD_NORMAL_COMPLETION);\n}"
  },
  {
    "function_name": "usb_block_freemem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_mem.c",
    "lines": "203-214",
    "snippet": "Static void\nusb_block_freemem(p)\n        usb_dma_block_t *p;\n{\n\tint s;\n\n\tDPRINTFN(6, (\"usb_block_freemem: size=%lu\\n\", (u_long)p->size));\n\ts = splusb();\n\tLIST_INSERT_HEAD(&usb_blk_freelist, p, next);\n\tusb_blk_nfree++;\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>\t/* just for usb_dma_t */",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/proc.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>\t\t/* for usbdivar.h */",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "usb_block_allocmem __P((bus_dma_tag_t, size_t, size_t,\n\t\t\t\t\t\tusb_dma_block_t **));",
      "Static void",
      "usb_block_freemem  __P((usb_dma_block_t *));",
      "Static LIST_HEAD(, usb_dma_block) usb_blk_freelist = \n\tLIST_HEAD_INITIALIZER(usb_blk_freelist);",
      "Static int usb_blk_nfree = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_INSERT_HEAD",
          "args": [
            "&usb_blk_freelist",
            "p",
            "next"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "6",
            "(\"usb_block_freemem: size=%lu\\n\", (u_long)p->size)"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\t/* just for usb_dma_t */\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/proc.h>\n#include <machine/bus.h>\n#include <sys/device.h>\t\t/* for usbdivar.h */\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusb_block_allocmem __P((bus_dma_tag_t, size_t, size_t,\n\t\t\t\t\t\tusb_dma_block_t **));\nStatic void;\nusb_block_freemem  __P((usb_dma_block_t *));\nStatic LIST_HEAD(, usb_dma_block) usb_blk_freelist = \n\tLIST_HEAD_INITIALIZER(usb_blk_freelist);\nStatic int usb_blk_nfree = 0;\n\nStatic void\nusb_block_freemem(p)\n        usb_dma_block_t *p;\n{\n\tint s;\n\n\tDPRINTFN(6, (\"usb_block_freemem: size=%lu\\n\", (u_long)p->size));\n\ts = splusb();\n\tLIST_INSERT_HEAD(&usb_blk_freelist, p, next);\n\tusb_blk_nfree++;\n\tsplx(s);\n}"
  },
  {
    "function_name": "usb_block_real_freemem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_mem.c",
    "lines": "180-195",
    "snippet": "void\nusb_block_real_freemem(p)\n        usb_dma_block_t *p;\n{\n#ifdef DIAGNOSTIC\n\tif (!curproc) {\n\t\tprintf(\"usb_block_real_freemem: in interrupt context\\n\");\n\t\treturn;\n\t}\n#endif\n\tbus_dmamap_unload(p->tag, p->map);\n\tbus_dmamap_destroy(p->tag, p->map);\n\tbus_dmamem_unmap(p->tag, p->kaddr, p->size);\n\tbus_dmamem_free(p->tag, p->segs, p->nsegs);\n\tfree(p, M_USB);\n}",
    "includes": [
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>\t/* just for usb_dma_t */",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/proc.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>\t\t/* for usbdivar.h */",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "usb_block_allocmem __P((bus_dma_tag_t, size_t, size_t,\n\t\t\t\t\t\tusb_dma_block_t **));",
      "usb_block_freemem  __P((usb_dma_block_t *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "p",
            "M_USB"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "usb_freemem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_mem.c",
          "lines": "271-291",
          "snippet": "void\nusb_freemem(bus, p)\n\tusbd_bus_handle bus;\n        usb_dma_t *p;\n{\n\tstruct usb_frag_dma *f;\n\tint s;\n\n\tif (p->block->fullblock) {\n\t\tDPRINTFN(1, (\"usb_freemem: large free\\n\"));\n\t\tusb_block_freemem(p->block);\n\t\treturn;\n\t}\n\tf = KERNADDR(p);\n\tf->block = p->block;\n\tf->offs = p->offs;\n\ts = splusb();\n\tLIST_INSERT_HEAD(&usb_frag_freelist, f, next);\n\tsplx(s);\n\tDPRINTFN(5, (\"usb_freemem: frag=%p\\n\", f));\n}",
          "includes": [
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>\t/* just for usb_dma_t */",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/proc.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>\t\t/* for usbdivar.h */",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static LIST_HEAD(, usb_frag_dma) usb_frag_freelist =\n\tLIST_HEAD_INITIALIZER(usb_frag_freelist);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\t/* just for usb_dma_t */\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/proc.h>\n#include <machine/bus.h>\n#include <sys/device.h>\t\t/* for usbdivar.h */\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic LIST_HEAD(, usb_frag_dma) usb_frag_freelist =\n\tLIST_HEAD_INITIALIZER(usb_frag_freelist);\n\nvoid\nusb_freemem(bus, p)\n\tusbd_bus_handle bus;\n        usb_dma_t *p;\n{\n\tstruct usb_frag_dma *f;\n\tint s;\n\n\tif (p->block->fullblock) {\n\t\tDPRINTFN(1, (\"usb_freemem: large free\\n\"));\n\t\tusb_block_freemem(p->block);\n\t\treturn;\n\t}\n\tf = KERNADDR(p);\n\tf->block = p->block;\n\tf->offs = p->offs;\n\ts = splusb();\n\tLIST_INSERT_HEAD(&usb_frag_freelist, f, next);\n\tsplx(s);\n\tDPRINTFN(5, (\"usb_freemem: frag=%p\\n\", f));\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_dmamem_free",
          "args": [
            "p->tag",
            "p->segs",
            "p->nsegs"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_unmap",
          "args": [
            "p->tag",
            "p->kaddr",
            "p->size"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_destroy",
          "args": [
            "p->tag",
            "p->map"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_unload",
          "args": [
            "p->tag",
            "p->map"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"usb_block_real_freemem: in interrupt context\\n\""
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\t/* just for usb_dma_t */\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/proc.h>\n#include <machine/bus.h>\n#include <sys/device.h>\t\t/* for usbdivar.h */\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusb_block_allocmem __P((bus_dma_tag_t, size_t, size_t,\n\t\t\t\t\t\tusb_dma_block_t **));\nusb_block_freemem  __P((usb_dma_block_t *));\n\nvoid\nusb_block_real_freemem(p)\n        usb_dma_block_t *p;\n{\n#ifdef DIAGNOSTIC\n\tif (!curproc) {\n\t\tprintf(\"usb_block_real_freemem: in interrupt context\\n\");\n\t\treturn;\n\t}\n#endif\n\tbus_dmamap_unload(p->tag, p->map);\n\tbus_dmamap_destroy(p->tag, p->map);\n\tbus_dmamem_unmap(p->tag, p->kaddr, p->size);\n\tbus_dmamem_free(p->tag, p->segs, p->nsegs);\n\tfree(p, M_USB);\n}"
  },
  {
    "function_name": "usb_block_allocmem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usb_mem.c",
    "lines": "96-177",
    "snippet": "Static usbd_status\nusb_block_allocmem(tag, size, align, dmap)\n\tbus_dma_tag_t tag;\n\tsize_t size;\n\tsize_t align;\n        usb_dma_block_t **dmap;\n{\n\tint error;\n        usb_dma_block_t *p;\n\tint s;\n\n\tDPRINTFN(5, (\"usb_block_allocmem: size=%lu align=%lu\\n\", \n\t\t     (u_long)size, (u_long)align));\n\n#ifdef DIAGNOSTIC\n\tif (!curproc) {\n\t\tprintf(\"usb_block_allocmem: in interrupt context, size=%lu\\n\",\n\t\t    (unsigned long) size);\n\t}\n#endif\n\n\ts = splusb();\n\t/* First check the free list. */\n\tfor (p = LIST_FIRST(&usb_blk_freelist); p; p = LIST_NEXT(p, next)) {\n\t\tif (p->tag == tag && p->size >= size && p->align >= align) {\n\t\t\tLIST_REMOVE(p, next);\n\t\t\tusb_blk_nfree--;\n\t\t\tsplx(s);\n\t\t\t*dmap = p;\n\t\t\tDPRINTFN(6,(\"usb_block_allocmem: free list size=%lu\\n\",\n\t\t\t\t    (u_long)p->size));\n\t\t\treturn (USBD_NORMAL_COMPLETION);\n\t\t}\n\t}\n\tsplx(s);\n\n#ifdef DIAGNOSTIC\n\tif (!curproc) {\n\t\tprintf(\"usb_block_allocmem: in interrupt context, failed\\n\");\n\t\treturn (USBD_NOMEM);\n\t}\n#endif\n\n\tDPRINTFN(6, (\"usb_block_allocmem: no free\\n\"));\n\tp = malloc(sizeof *p, M_USB, M_NOWAIT);\n\tif (p == NULL)\n\t\treturn (USBD_NOMEM);\n\t*dmap = p;\n\n\tp->tag = tag;\n\tp->size = size;\n\tp->align = align;\n\terror = bus_dmamem_alloc(tag, p->size, align, 0,\n\t\t\t\t p->segs, sizeof(p->segs)/sizeof(p->segs[0]),\n\t\t\t\t &p->nsegs, BUS_DMA_NOWAIT);\n\tif (error)\n\t\treturn (USBD_NOMEM);\n\n\terror = bus_dmamem_map(tag, p->segs, p->nsegs, p->size, \n\t\t\t       &p->kaddr, BUS_DMA_NOWAIT|BUS_DMA_COHERENT);\n\tif (error)\n\t\tgoto free;\n\n\terror = bus_dmamap_create(tag, p->size, 1, p->size,\n\t\t\t\t  0, BUS_DMA_NOWAIT, &p->map);\n\tif (error)\n\t\tgoto unmap;\n\n\terror = bus_dmamap_load(tag, p->map, p->kaddr, p->size, NULL, \n\t\t\t\tBUS_DMA_NOWAIT);\n\tif (error)\n\t\tgoto destroy;\n\treturn (USBD_NORMAL_COMPLETION);\n\ndestroy:\n\tbus_dmamap_destroy(tag, p->map);\nunmap:\n\tbus_dmamem_unmap(tag, p->kaddr, p->size);\nfree:\n\tbus_dmamem_free(tag, p->segs, p->nsegs);\n\treturn (USBD_NOMEM);\n}",
    "includes": [
      "#include <dev/usb/usb_mem.h>",
      "#include <dev/usb/usbdivar.h>\t/* just for usb_dma_t */",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/proc.h>",
      "#include <machine/bus.h>",
      "#include <sys/device.h>\t\t/* for usbdivar.h */",
      "#include <sys/queue.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "Static usbd_status",
      "usb_block_allocmem __P((bus_dma_tag_t, size_t, size_t,\n\t\t\t\t\t\tusb_dma_block_t **));",
      "Static void",
      "usb_block_freemem  __P((usb_dma_block_t *));",
      "Static LIST_HEAD(, usb_dma_block) usb_blk_freelist = \n\tLIST_HEAD_INITIALIZER(usb_blk_freelist);",
      "Static int usb_blk_nfree = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_dmamem_free",
          "args": [
            "tag",
            "p->segs",
            "p->nsegs"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_unmap",
          "args": [
            "tag",
            "p->kaddr",
            "p->size"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_destroy",
          "args": [
            "tag",
            "p->map"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_load",
          "args": [
            "tag",
            "p->map",
            "p->kaddr",
            "p->size",
            "NULL",
            "BUS_DMA_NOWAIT"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_create",
          "args": [
            "tag",
            "p->size",
            "1",
            "p->size",
            "0",
            "BUS_DMA_NOWAIT",
            "&p->map"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_map",
          "args": [
            "tag",
            "p->segs",
            "p->nsegs",
            "p->size",
            "&p->kaddr",
            "BUS_DMA_NOWAIT|BUS_DMA_COHERENT"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_alloc",
          "args": [
            "tag",
            "p->size",
            "align",
            "0",
            "p->segs",
            "sizeof(p->segs)/sizeof(p->segs[0])",
            "&p->nsegs",
            "BUS_DMA_NOWAIT"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof *p",
            "M_USB",
            "M_NOWAIT"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "6",
            "(\"usb_block_allocmem: no free\\n\")"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"usb_block_allocmem: in interrupt context, failed\\n\""
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "6",
            "(\"usb_block_allocmem: free list size=%lu\\n\",\n\t\t\t\t    (u_long)p->size)"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_REMOVE",
          "args": [
            "p",
            "next"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_NEXT",
          "args": [
            "p",
            "next"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_FIRST",
          "args": [
            "&usb_blk_freelist"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splusb",
          "args": [],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"usb_block_allocmem: size=%lu align=%lu\\n\", \n\t\t     (u_long)size, (u_long)align)"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\t/* just for usb_dma_t */\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/proc.h>\n#include <machine/bus.h>\n#include <sys/device.h>\t\t/* for usbdivar.h */\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusb_block_allocmem __P((bus_dma_tag_t, size_t, size_t,\n\t\t\t\t\t\tusb_dma_block_t **));\nStatic void;\nusb_block_freemem  __P((usb_dma_block_t *));\nStatic LIST_HEAD(, usb_dma_block) usb_blk_freelist = \n\tLIST_HEAD_INITIALIZER(usb_blk_freelist);\nStatic int usb_blk_nfree = 0;\n\nStatic usbd_status\nusb_block_allocmem(tag, size, align, dmap)\n\tbus_dma_tag_t tag;\n\tsize_t size;\n\tsize_t align;\n        usb_dma_block_t **dmap;\n{\n\tint error;\n        usb_dma_block_t *p;\n\tint s;\n\n\tDPRINTFN(5, (\"usb_block_allocmem: size=%lu align=%lu\\n\", \n\t\t     (u_long)size, (u_long)align));\n\n#ifdef DIAGNOSTIC\n\tif (!curproc) {\n\t\tprintf(\"usb_block_allocmem: in interrupt context, size=%lu\\n\",\n\t\t    (unsigned long) size);\n\t}\n#endif\n\n\ts = splusb();\n\t/* First check the free list. */\n\tfor (p = LIST_FIRST(&usb_blk_freelist); p; p = LIST_NEXT(p, next)) {\n\t\tif (p->tag == tag && p->size >= size && p->align >= align) {\n\t\t\tLIST_REMOVE(p, next);\n\t\t\tusb_blk_nfree--;\n\t\t\tsplx(s);\n\t\t\t*dmap = p;\n\t\t\tDPRINTFN(6,(\"usb_block_allocmem: free list size=%lu\\n\",\n\t\t\t\t    (u_long)p->size));\n\t\t\treturn (USBD_NORMAL_COMPLETION);\n\t\t}\n\t}\n\tsplx(s);\n\n#ifdef DIAGNOSTIC\n\tif (!curproc) {\n\t\tprintf(\"usb_block_allocmem: in interrupt context, failed\\n\");\n\t\treturn (USBD_NOMEM);\n\t}\n#endif\n\n\tDPRINTFN(6, (\"usb_block_allocmem: no free\\n\"));\n\tp = malloc(sizeof *p, M_USB, M_NOWAIT);\n\tif (p == NULL)\n\t\treturn (USBD_NOMEM);\n\t*dmap = p;\n\n\tp->tag = tag;\n\tp->size = size;\n\tp->align = align;\n\terror = bus_dmamem_alloc(tag, p->size, align, 0,\n\t\t\t\t p->segs, sizeof(p->segs)/sizeof(p->segs[0]),\n\t\t\t\t &p->nsegs, BUS_DMA_NOWAIT);\n\tif (error)\n\t\treturn (USBD_NOMEM);\n\n\terror = bus_dmamem_map(tag, p->segs, p->nsegs, p->size, \n\t\t\t       &p->kaddr, BUS_DMA_NOWAIT|BUS_DMA_COHERENT);\n\tif (error)\n\t\tgoto free;\n\n\terror = bus_dmamap_create(tag, p->size, 1, p->size,\n\t\t\t\t  0, BUS_DMA_NOWAIT, &p->map);\n\tif (error)\n\t\tgoto unmap;\n\n\terror = bus_dmamap_load(tag, p->map, p->kaddr, p->size, NULL, \n\t\t\t\tBUS_DMA_NOWAIT);\n\tif (error)\n\t\tgoto destroy;\n\treturn (USBD_NORMAL_COMPLETION);\n\ndestroy:\n\tbus_dmamap_destroy(tag, p->map);\nunmap:\n\tbus_dmamem_unmap(tag, p->kaddr, p->size);\nfree:\n\tbus_dmamem_free(tag, p->segs, p->nsegs);\n\treturn (USBD_NOMEM);\n}"
  }
]