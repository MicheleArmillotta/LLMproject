[
  {
    "function_name": "rf_SstfPromote",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_sstf.c",
    "lines": "624-664",
    "snippet": "int \nrf_SstfPromote(qptr, parityStripeID, which_ru)\n\tvoid   *qptr;\n\tRF_StripeNum_t parityStripeID;\n\tRF_ReconUnitNum_t which_ru;\n{\n\tRF_DiskQueueData_t *r, *next;\n\tRF_Sstf_t *sstfq;\n\tint     n;\n\n\tsstfq = (RF_Sstf_t *) qptr;\n\n\tn = 0;\n\tif (rf_sstfDebug || rf_scanDebug || rf_cscanDebug) {\n\t\tprintf(\"raid%d: promote %ld %d  queues are %d,%d,%d\\n\",\n\t\t       r->raidPtr->raidid, (long) parityStripeID, \n\t\t       (int) which_ru,\n\t\t    sstfq->left.qlen,\n\t\t    sstfq->right.qlen,\n\t\t    sstfq->lopri.qlen);\n\t}\n\tfor (r = sstfq->lopri.queue; r; r = next) {\n\t\tnext = r->next;\n\t\tif (rf_sstfDebug || rf_scanDebug || rf_cscanDebug) {\n\t\t\tprintf(\"raid%d: check promote %lx\\n\",\n\t\t\t       r->raidPtr->raidid, (long) r);\n\t\t}\n\t\tif ((r->parityStripeID == parityStripeID)\n\t\t    && (r->which_ru == which_ru)) {\n\t\t\tdo_dequeue(&sstfq->lopri, r);\n\t\t\trf_SstfEnqueue(qptr, r, RF_IO_NORMAL_PRIORITY);\n\t\t\tn++;\n\t\t}\n\t}\n\tif (rf_sstfDebug || rf_scanDebug || rf_cscanDebug) {\n\t\tprintf(\"raid%d: promoted %d matching I/Os queues are %d,%d,%d\\n\",\n\t\t       r->raidPtr->raidid, n, sstfq->left.qlen, \n\t\t       sstfq->right.qlen, sstfq->lopri.qlen);\n\t}\n\treturn (n);\n}",
    "includes": [
      "#include \"rf_types.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_sstf.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_stripelocks.h\"",
      "#include \"rf_alloclist.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void \ndo_sstf_ord_q(RF_DiskQueueData_t **,\n    RF_DiskQueueData_t **,\n    RF_DiskQueueData_t *);",
      "static void do_dequeue(RF_SstfQ_t *, RF_DiskQueueData_t *);",
      "static RF_DiskQueueData_t *\nclosest_to_arm(queue, arm_pos, dir, allow_reverse)\n\tRF_SstfQ_t *queue;",
      "RF_DiskQueueData_t *\nrf_SstfDequeue(qptr)\n\tvoid   *qptr;",
      "RF_DiskQueueData_t *\nrf_ScanDequeue(qptr)\n\tvoid   *qptr;",
      "RF_DiskQueueData_t *\nrf_CscanDequeue(qptr)\n\tvoid   *qptr;",
      "RF_DiskQueueData_t *\nrf_SstfPeek(qptr)\n\tvoid   *qptr;",
      "RF_DiskQueueData_t *\nrf_ScanPeek(qptr)\n\tvoid   *qptr;",
      "RF_DiskQueueData_t *\nrf_CscanPeek(qptr)\n\tvoid   *qptr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"raid%d: promoted %d matching I/Os queues are %d,%d,%d\\n\"",
            "r->raidPtr->raidid",
            "n",
            "sstfq->left.qlen",
            "sstfq->right.qlen",
            "sstfq->lopri.qlen"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_SstfEnqueue",
          "args": [
            "qptr",
            "r",
            "RF_IO_NORMAL_PRIORITY"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "rf_SstfEnqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_sstf.c",
          "lines": "286-317",
          "snippet": "void \nrf_SstfEnqueue(qptr, req, priority)\n\tvoid   *qptr;\n\tRF_DiskQueueData_t *req;\n\tint     priority;\n{\n\tRF_Sstf_t *sstfq;\n\n\tsstfq = (RF_Sstf_t *) qptr;\n\n\tif (priority == RF_IO_LOW_PRIORITY) {\n\t\tif (rf_sstfDebug || rf_scanDebug || rf_cscanDebug) {\n\t\t\tRF_DiskQueue_t *dq;\n\t\t\tdq = (RF_DiskQueue_t *) req->queue;\n\t\t\tprintf(\"raid%d: ENQ lopri %d,%d queues are %d,%d,%d\\n\",\n\t\t\t       req->raidPtr->raidid,\n\t\t\t       dq->row, dq->col, \n\t\t\t       sstfq->left.qlen, sstfq->right.qlen,\n\t\t\t    sstfq->lopri.qlen);\n\t\t}\n\t\tdo_sstf_ord_q(&sstfq->lopri.queue, &sstfq->lopri.qtail, req);\n\t\tsstfq->lopri.qlen++;\n\t} else {\n\t\tif (req->sectorOffset < sstfq->last_sector) {\n\t\t\tdo_sstf_ord_q(&sstfq->left.queue, &sstfq->left.qtail, req);\n\t\t\tsstfq->left.qlen++;\n\t\t} else {\n\t\t\tdo_sstf_ord_q(&sstfq->right.queue, &sstfq->right.qtail, req);\n\t\t\tsstfq->right.qlen++;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"rf_types.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_sstf.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_stripelocks.h\"",
            "#include \"rf_alloclist.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void \ndo_sstf_ord_q(RF_DiskQueueData_t **,\n    RF_DiskQueueData_t **,\n    RF_DiskQueueData_t *);",
            "static void do_dequeue(RF_SstfQ_t *, RF_DiskQueueData_t *);",
            "static RF_DiskQueueData_t *\nclosest_to_arm(queue, arm_pos, dir, allow_reverse)\n\tRF_SstfQ_t *queue;",
            "RF_DiskQueueData_t *\nrf_SstfDequeue(qptr)\n\tvoid   *qptr;",
            "RF_DiskQueueData_t *\nrf_ScanDequeue(qptr)\n\tvoid   *qptr;",
            "RF_DiskQueueData_t *\nrf_CscanDequeue(qptr)\n\tvoid   *qptr;",
            "RF_DiskQueueData_t *\nrf_SstfPeek(qptr)\n\tvoid   *qptr;",
            "RF_DiskQueueData_t *\nrf_ScanPeek(qptr)\n\tvoid   *qptr;",
            "RF_DiskQueueData_t *\nrf_CscanPeek(qptr)\n\tvoid   *qptr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_types.h\"\n#include \"rf_raid.h\"\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_sstf.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_layout.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_alloclist.h\"\n\nstatic void \ndo_sstf_ord_q(RF_DiskQueueData_t **,\n    RF_DiskQueueData_t **,\n    RF_DiskQueueData_t *);\nstatic void do_dequeue(RF_SstfQ_t *, RF_DiskQueueData_t *);\nstatic RF_DiskQueueData_t *\nclosest_to_arm(queue, arm_pos, dir, allow_reverse)\n\tRF_SstfQ_t *queue;\nRF_DiskQueueData_t *\nrf_SstfDequeue(qptr)\n\tvoid   *qptr;\nRF_DiskQueueData_t *\nrf_ScanDequeue(qptr)\n\tvoid   *qptr;\nRF_DiskQueueData_t *\nrf_CscanDequeue(qptr)\n\tvoid   *qptr;\nRF_DiskQueueData_t *\nrf_SstfPeek(qptr)\n\tvoid   *qptr;\nRF_DiskQueueData_t *\nrf_ScanPeek(qptr)\n\tvoid   *qptr;\nRF_DiskQueueData_t *\nrf_CscanPeek(qptr)\n\tvoid   *qptr;\n\nvoid \nrf_SstfEnqueue(qptr, req, priority)\n\tvoid   *qptr;\n\tRF_DiskQueueData_t *req;\n\tint     priority;\n{\n\tRF_Sstf_t *sstfq;\n\n\tsstfq = (RF_Sstf_t *) qptr;\n\n\tif (priority == RF_IO_LOW_PRIORITY) {\n\t\tif (rf_sstfDebug || rf_scanDebug || rf_cscanDebug) {\n\t\t\tRF_DiskQueue_t *dq;\n\t\t\tdq = (RF_DiskQueue_t *) req->queue;\n\t\t\tprintf(\"raid%d: ENQ lopri %d,%d queues are %d,%d,%d\\n\",\n\t\t\t       req->raidPtr->raidid,\n\t\t\t       dq->row, dq->col, \n\t\t\t       sstfq->left.qlen, sstfq->right.qlen,\n\t\t\t    sstfq->lopri.qlen);\n\t\t}\n\t\tdo_sstf_ord_q(&sstfq->lopri.queue, &sstfq->lopri.qtail, req);\n\t\tsstfq->lopri.qlen++;\n\t} else {\n\t\tif (req->sectorOffset < sstfq->last_sector) {\n\t\t\tdo_sstf_ord_q(&sstfq->left.queue, &sstfq->left.qtail, req);\n\t\t\tsstfq->left.qlen++;\n\t\t} else {\n\t\t\tdo_sstf_ord_q(&sstfq->right.queue, &sstfq->right.qtail, req);\n\t\t\tsstfq->right.qlen++;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_dequeue",
          "args": [
            "&sstfq->lopri",
            "r"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "do_dequeue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_sstf.c",
          "lines": "319-345",
          "snippet": "static void \ndo_dequeue(queue, req)\n\tRF_SstfQ_t *queue;\n\tRF_DiskQueueData_t *req;\n{\n\tRF_DiskQueueData_t *req2;\n\n\tif (rf_sstfDebug || rf_scanDebug || rf_cscanDebug) {\n\t\tprintf(\"raid%d: do_dequeue\\n\", req->raidPtr->raidid);\n\t}\n\tif (req == queue->queue) {\n\t\tDO_HEAD_DEQ(req2, queue);\n\t\tRF_ASSERT(req2 == req);\n\t} else\n\t\tif (req == queue->qtail) {\n\t\t\tDO_TAIL_DEQ(req2, queue);\n\t\t\tRF_ASSERT(req2 == req);\n\t\t} else {\n\t\t\t/* dequeue from middle of list */\n\t\t\tRF_ASSERT(req->next);\n\t\t\tRF_ASSERT(req->prev);\n\t\t\tqueue->qlen--;\n\t\t\treq->next->prev = req->prev;\n\t\t\treq->prev->next = req->next;\n\t\t\treq->next = req->prev = NULL;\n\t\t}\n}",
          "includes": [
            "#include \"rf_types.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_sstf.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_stripelocks.h\"",
            "#include \"rf_alloclist.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void \ndo_sstf_ord_q(RF_DiskQueueData_t **,\n    RF_DiskQueueData_t **,\n    RF_DiskQueueData_t *);",
            "static void do_dequeue(RF_SstfQ_t *, RF_DiskQueueData_t *);",
            "static RF_DiskQueueData_t *\nclosest_to_arm(queue, arm_pos, dir, allow_reverse)\n\tRF_SstfQ_t *queue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_types.h\"\n#include \"rf_raid.h\"\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_sstf.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_layout.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_alloclist.h\"\n\nstatic void \ndo_sstf_ord_q(RF_DiskQueueData_t **,\n    RF_DiskQueueData_t **,\n    RF_DiskQueueData_t *);\nstatic void do_dequeue(RF_SstfQ_t *, RF_DiskQueueData_t *);\nstatic RF_DiskQueueData_t *\nclosest_to_arm(queue, arm_pos, dir, allow_reverse)\n\tRF_SstfQ_t *queue;\n\nstatic void \ndo_dequeue(queue, req)\n\tRF_SstfQ_t *queue;\n\tRF_DiskQueueData_t *req;\n{\n\tRF_DiskQueueData_t *req2;\n\n\tif (rf_sstfDebug || rf_scanDebug || rf_cscanDebug) {\n\t\tprintf(\"raid%d: do_dequeue\\n\", req->raidPtr->raidid);\n\t}\n\tif (req == queue->queue) {\n\t\tDO_HEAD_DEQ(req2, queue);\n\t\tRF_ASSERT(req2 == req);\n\t} else\n\t\tif (req == queue->qtail) {\n\t\t\tDO_TAIL_DEQ(req2, queue);\n\t\t\tRF_ASSERT(req2 == req);\n\t\t} else {\n\t\t\t/* dequeue from middle of list */\n\t\t\tRF_ASSERT(req->next);\n\t\t\tRF_ASSERT(req->prev);\n\t\t\tqueue->qlen--;\n\t\t\treq->next->prev = req->prev;\n\t\t\treq->prev->next = req->next;\n\t\t\treq->next = req->prev = NULL;\n\t\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_types.h\"\n#include \"rf_raid.h\"\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_sstf.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_layout.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_alloclist.h\"\n\nstatic void \ndo_sstf_ord_q(RF_DiskQueueData_t **,\n    RF_DiskQueueData_t **,\n    RF_DiskQueueData_t *);\nstatic void do_dequeue(RF_SstfQ_t *, RF_DiskQueueData_t *);\nstatic RF_DiskQueueData_t *\nclosest_to_arm(queue, arm_pos, dir, allow_reverse)\n\tRF_SstfQ_t *queue;\nRF_DiskQueueData_t *\nrf_SstfDequeue(qptr)\n\tvoid   *qptr;\nRF_DiskQueueData_t *\nrf_ScanDequeue(qptr)\n\tvoid   *qptr;\nRF_DiskQueueData_t *\nrf_CscanDequeue(qptr)\n\tvoid   *qptr;\nRF_DiskQueueData_t *\nrf_SstfPeek(qptr)\n\tvoid   *qptr;\nRF_DiskQueueData_t *\nrf_ScanPeek(qptr)\n\tvoid   *qptr;\nRF_DiskQueueData_t *\nrf_CscanPeek(qptr)\n\tvoid   *qptr;\n\nint \nrf_SstfPromote(qptr, parityStripeID, which_ru)\n\tvoid   *qptr;\n\tRF_StripeNum_t parityStripeID;\n\tRF_ReconUnitNum_t which_ru;\n{\n\tRF_DiskQueueData_t *r, *next;\n\tRF_Sstf_t *sstfq;\n\tint     n;\n\n\tsstfq = (RF_Sstf_t *) qptr;\n\n\tn = 0;\n\tif (rf_sstfDebug || rf_scanDebug || rf_cscanDebug) {\n\t\tprintf(\"raid%d: promote %ld %d  queues are %d,%d,%d\\n\",\n\t\t       r->raidPtr->raidid, (long) parityStripeID, \n\t\t       (int) which_ru,\n\t\t    sstfq->left.qlen,\n\t\t    sstfq->right.qlen,\n\t\t    sstfq->lopri.qlen);\n\t}\n\tfor (r = sstfq->lopri.queue; r; r = next) {\n\t\tnext = r->next;\n\t\tif (rf_sstfDebug || rf_scanDebug || rf_cscanDebug) {\n\t\t\tprintf(\"raid%d: check promote %lx\\n\",\n\t\t\t       r->raidPtr->raidid, (long) r);\n\t\t}\n\t\tif ((r->parityStripeID == parityStripeID)\n\t\t    && (r->which_ru == which_ru)) {\n\t\t\tdo_dequeue(&sstfq->lopri, r);\n\t\t\trf_SstfEnqueue(qptr, r, RF_IO_NORMAL_PRIORITY);\n\t\t\tn++;\n\t\t}\n\t}\n\tif (rf_sstfDebug || rf_scanDebug || rf_cscanDebug) {\n\t\tprintf(\"raid%d: promoted %d matching I/Os queues are %d,%d,%d\\n\",\n\t\t       r->raidPtr->raidid, n, sstfq->left.qlen, \n\t\t       sstfq->right.qlen, sstfq->lopri.qlen);\n\t}\n\treturn (n);\n}"
  },
  {
    "function_name": "do_dequeue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_sstf.c",
    "lines": "319-345",
    "snippet": "static void \ndo_dequeue(queue, req)\n\tRF_SstfQ_t *queue;\n\tRF_DiskQueueData_t *req;\n{\n\tRF_DiskQueueData_t *req2;\n\n\tif (rf_sstfDebug || rf_scanDebug || rf_cscanDebug) {\n\t\tprintf(\"raid%d: do_dequeue\\n\", req->raidPtr->raidid);\n\t}\n\tif (req == queue->queue) {\n\t\tDO_HEAD_DEQ(req2, queue);\n\t\tRF_ASSERT(req2 == req);\n\t} else\n\t\tif (req == queue->qtail) {\n\t\t\tDO_TAIL_DEQ(req2, queue);\n\t\t\tRF_ASSERT(req2 == req);\n\t\t} else {\n\t\t\t/* dequeue from middle of list */\n\t\t\tRF_ASSERT(req->next);\n\t\t\tRF_ASSERT(req->prev);\n\t\t\tqueue->qlen--;\n\t\t\treq->next->prev = req->prev;\n\t\t\treq->prev->next = req->next;\n\t\t\treq->next = req->prev = NULL;\n\t\t}\n}",
    "includes": [
      "#include \"rf_types.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_sstf.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_stripelocks.h\"",
      "#include \"rf_alloclist.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void \ndo_sstf_ord_q(RF_DiskQueueData_t **,\n    RF_DiskQueueData_t **,\n    RF_DiskQueueData_t *);",
      "static void do_dequeue(RF_SstfQ_t *, RF_DiskQueueData_t *);",
      "static RF_DiskQueueData_t *\nclosest_to_arm(queue, arm_pos, dir, allow_reverse)\n\tRF_SstfQ_t *queue;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "req->prev"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "req->next"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "req2 == req"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_TAIL_DEQ",
          "args": [
            "req2",
            "queue"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "req2 == req"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_HEAD_DEQ",
          "args": [
            "req2",
            "queue"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"raid%d: do_dequeue\\n\"",
            "req->raidPtr->raidid"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_types.h\"\n#include \"rf_raid.h\"\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_sstf.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_layout.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_alloclist.h\"\n\nstatic void \ndo_sstf_ord_q(RF_DiskQueueData_t **,\n    RF_DiskQueueData_t **,\n    RF_DiskQueueData_t *);\nstatic void do_dequeue(RF_SstfQ_t *, RF_DiskQueueData_t *);\nstatic RF_DiskQueueData_t *\nclosest_to_arm(queue, arm_pos, dir, allow_reverse)\n\tRF_SstfQ_t *queue;\n\nstatic void \ndo_dequeue(queue, req)\n\tRF_SstfQ_t *queue;\n\tRF_DiskQueueData_t *req;\n{\n\tRF_DiskQueueData_t *req2;\n\n\tif (rf_sstfDebug || rf_scanDebug || rf_cscanDebug) {\n\t\tprintf(\"raid%d: do_dequeue\\n\", req->raidPtr->raidid);\n\t}\n\tif (req == queue->queue) {\n\t\tDO_HEAD_DEQ(req2, queue);\n\t\tRF_ASSERT(req2 == req);\n\t} else\n\t\tif (req == queue->qtail) {\n\t\t\tDO_TAIL_DEQ(req2, queue);\n\t\t\tRF_ASSERT(req2 == req);\n\t\t} else {\n\t\t\t/* dequeue from middle of list */\n\t\t\tRF_ASSERT(req->next);\n\t\t\tRF_ASSERT(req->prev);\n\t\t\tqueue->qlen--;\n\t\t\treq->next->prev = req->prev;\n\t\t\treq->prev->next = req->next;\n\t\t\treq->next = req->prev = NULL;\n\t\t}\n}"
  },
  {
    "function_name": "rf_SstfEnqueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_sstf.c",
    "lines": "286-317",
    "snippet": "void \nrf_SstfEnqueue(qptr, req, priority)\n\tvoid   *qptr;\n\tRF_DiskQueueData_t *req;\n\tint     priority;\n{\n\tRF_Sstf_t *sstfq;\n\n\tsstfq = (RF_Sstf_t *) qptr;\n\n\tif (priority == RF_IO_LOW_PRIORITY) {\n\t\tif (rf_sstfDebug || rf_scanDebug || rf_cscanDebug) {\n\t\t\tRF_DiskQueue_t *dq;\n\t\t\tdq = (RF_DiskQueue_t *) req->queue;\n\t\t\tprintf(\"raid%d: ENQ lopri %d,%d queues are %d,%d,%d\\n\",\n\t\t\t       req->raidPtr->raidid,\n\t\t\t       dq->row, dq->col, \n\t\t\t       sstfq->left.qlen, sstfq->right.qlen,\n\t\t\t    sstfq->lopri.qlen);\n\t\t}\n\t\tdo_sstf_ord_q(&sstfq->lopri.queue, &sstfq->lopri.qtail, req);\n\t\tsstfq->lopri.qlen++;\n\t} else {\n\t\tif (req->sectorOffset < sstfq->last_sector) {\n\t\t\tdo_sstf_ord_q(&sstfq->left.queue, &sstfq->left.qtail, req);\n\t\t\tsstfq->left.qlen++;\n\t\t} else {\n\t\t\tdo_sstf_ord_q(&sstfq->right.queue, &sstfq->right.qtail, req);\n\t\t\tsstfq->right.qlen++;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"rf_types.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_sstf.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_stripelocks.h\"",
      "#include \"rf_alloclist.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void \ndo_sstf_ord_q(RF_DiskQueueData_t **,\n    RF_DiskQueueData_t **,\n    RF_DiskQueueData_t *);",
      "static void do_dequeue(RF_SstfQ_t *, RF_DiskQueueData_t *);",
      "static RF_DiskQueueData_t *\nclosest_to_arm(queue, arm_pos, dir, allow_reverse)\n\tRF_SstfQ_t *queue;",
      "RF_DiskQueueData_t *\nrf_SstfDequeue(qptr)\n\tvoid   *qptr;",
      "RF_DiskQueueData_t *\nrf_ScanDequeue(qptr)\n\tvoid   *qptr;",
      "RF_DiskQueueData_t *\nrf_CscanDequeue(qptr)\n\tvoid   *qptr;",
      "RF_DiskQueueData_t *\nrf_SstfPeek(qptr)\n\tvoid   *qptr;",
      "RF_DiskQueueData_t *\nrf_ScanPeek(qptr)\n\tvoid   *qptr;",
      "RF_DiskQueueData_t *\nrf_CscanPeek(qptr)\n\tvoid   *qptr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_sstf_ord_q",
          "args": [
            "&sstfq->right.queue",
            "&sstfq->right.qtail",
            "req"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "do_sstf_ord_q",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_sstf.c",
          "lines": "69-117",
          "snippet": "static void \ndo_sstf_ord_q(queuep, tailp, req)\n\tRF_DiskQueueData_t **queuep;\n\tRF_DiskQueueData_t **tailp;\n\tRF_DiskQueueData_t *req;\n{\n\tRF_DiskQueueData_t *r, *s;\n\n\tif (*queuep == NULL) {\n\t\t*queuep = req;\n\t\t*tailp = req;\n\t\treq->next = NULL;\n\t\treq->prev = NULL;\n\t\treturn;\n\t}\n\tif (req->sectorOffset <= (*queuep)->sectorOffset) {\n\t\treq->next = *queuep;\n\t\treq->prev = NULL;\n\t\t(*queuep)->prev = req;\n\t\t*queuep = req;\n\t\treturn;\n\t}\n\tif (req->sectorOffset > (*tailp)->sectorOffset) {\n\t\t/* optimization */\n\t\tr = NULL;\n\t\ts = *tailp;\n\t\tgoto q_at_end;\n\t}\n\tfor (s = NULL, r = *queuep; r; s = r, r = r->next) {\n\t\tif (r->sectorOffset >= req->sectorOffset) {\n\t\t\t/* insert after s, before r */\n\t\t\tRF_ASSERT(s);\n\t\t\treq->next = r;\n\t\t\tr->prev = req;\n\t\t\ts->next = req;\n\t\t\treq->prev = s;\n\t\t\treturn;\n\t\t}\n\t}\nq_at_end:\n\t/* insert after s, at end of queue */\n\tRF_ASSERT(r == NULL);\n\tRF_ASSERT(s);\n\tRF_ASSERT(s == (*tailp));\n\treq->next = NULL;\n\treq->prev = s;\n\ts->next = req;\n\t*tailp = req;\n}",
          "includes": [
            "#include \"rf_types.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_sstf.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_stripelocks.h\"",
            "#include \"rf_alloclist.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void \ndo_sstf_ord_q(RF_DiskQueueData_t **,\n    RF_DiskQueueData_t **,\n    RF_DiskQueueData_t *);",
            "static void do_dequeue(RF_SstfQ_t *, RF_DiskQueueData_t *);",
            "static RF_DiskQueueData_t *\nclosest_to_arm(queue, arm_pos, dir, allow_reverse)\n\tRF_SstfQ_t *queue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_types.h\"\n#include \"rf_raid.h\"\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_sstf.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_layout.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_alloclist.h\"\n\nstatic void \ndo_sstf_ord_q(RF_DiskQueueData_t **,\n    RF_DiskQueueData_t **,\n    RF_DiskQueueData_t *);\nstatic void do_dequeue(RF_SstfQ_t *, RF_DiskQueueData_t *);\nstatic RF_DiskQueueData_t *\nclosest_to_arm(queue, arm_pos, dir, allow_reverse)\n\tRF_SstfQ_t *queue;\n\nstatic void \ndo_sstf_ord_q(queuep, tailp, req)\n\tRF_DiskQueueData_t **queuep;\n\tRF_DiskQueueData_t **tailp;\n\tRF_DiskQueueData_t *req;\n{\n\tRF_DiskQueueData_t *r, *s;\n\n\tif (*queuep == NULL) {\n\t\t*queuep = req;\n\t\t*tailp = req;\n\t\treq->next = NULL;\n\t\treq->prev = NULL;\n\t\treturn;\n\t}\n\tif (req->sectorOffset <= (*queuep)->sectorOffset) {\n\t\treq->next = *queuep;\n\t\treq->prev = NULL;\n\t\t(*queuep)->prev = req;\n\t\t*queuep = req;\n\t\treturn;\n\t}\n\tif (req->sectorOffset > (*tailp)->sectorOffset) {\n\t\t/* optimization */\n\t\tr = NULL;\n\t\ts = *tailp;\n\t\tgoto q_at_end;\n\t}\n\tfor (s = NULL, r = *queuep; r; s = r, r = r->next) {\n\t\tif (r->sectorOffset >= req->sectorOffset) {\n\t\t\t/* insert after s, before r */\n\t\t\tRF_ASSERT(s);\n\t\t\treq->next = r;\n\t\t\tr->prev = req;\n\t\t\ts->next = req;\n\t\t\treq->prev = s;\n\t\t\treturn;\n\t\t}\n\t}\nq_at_end:\n\t/* insert after s, at end of queue */\n\tRF_ASSERT(r == NULL);\n\tRF_ASSERT(s);\n\tRF_ASSERT(s == (*tailp));\n\treq->next = NULL;\n\treq->prev = s;\n\ts->next = req;\n\t*tailp = req;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"raid%d: ENQ lopri %d,%d queues are %d,%d,%d\\n\"",
            "req->raidPtr->raidid",
            "dq->row",
            "dq->col",
            "sstfq->left.qlen",
            "sstfq->right.qlen",
            "sstfq->lopri.qlen"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_types.h\"\n#include \"rf_raid.h\"\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_sstf.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_layout.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_alloclist.h\"\n\nstatic void \ndo_sstf_ord_q(RF_DiskQueueData_t **,\n    RF_DiskQueueData_t **,\n    RF_DiskQueueData_t *);\nstatic void do_dequeue(RF_SstfQ_t *, RF_DiskQueueData_t *);\nstatic RF_DiskQueueData_t *\nclosest_to_arm(queue, arm_pos, dir, allow_reverse)\n\tRF_SstfQ_t *queue;\nRF_DiskQueueData_t *\nrf_SstfDequeue(qptr)\n\tvoid   *qptr;\nRF_DiskQueueData_t *\nrf_ScanDequeue(qptr)\n\tvoid   *qptr;\nRF_DiskQueueData_t *\nrf_CscanDequeue(qptr)\n\tvoid   *qptr;\nRF_DiskQueueData_t *\nrf_SstfPeek(qptr)\n\tvoid   *qptr;\nRF_DiskQueueData_t *\nrf_ScanPeek(qptr)\n\tvoid   *qptr;\nRF_DiskQueueData_t *\nrf_CscanPeek(qptr)\n\tvoid   *qptr;\n\nvoid \nrf_SstfEnqueue(qptr, req, priority)\n\tvoid   *qptr;\n\tRF_DiskQueueData_t *req;\n\tint     priority;\n{\n\tRF_Sstf_t *sstfq;\n\n\tsstfq = (RF_Sstf_t *) qptr;\n\n\tif (priority == RF_IO_LOW_PRIORITY) {\n\t\tif (rf_sstfDebug || rf_scanDebug || rf_cscanDebug) {\n\t\t\tRF_DiskQueue_t *dq;\n\t\t\tdq = (RF_DiskQueue_t *) req->queue;\n\t\t\tprintf(\"raid%d: ENQ lopri %d,%d queues are %d,%d,%d\\n\",\n\t\t\t       req->raidPtr->raidid,\n\t\t\t       dq->row, dq->col, \n\t\t\t       sstfq->left.qlen, sstfq->right.qlen,\n\t\t\t    sstfq->lopri.qlen);\n\t\t}\n\t\tdo_sstf_ord_q(&sstfq->lopri.queue, &sstfq->lopri.qtail, req);\n\t\tsstfq->lopri.qlen++;\n\t} else {\n\t\tif (req->sectorOffset < sstfq->last_sector) {\n\t\t\tdo_sstf_ord_q(&sstfq->left.queue, &sstfq->left.qtail, req);\n\t\t\tsstfq->left.qlen++;\n\t\t} else {\n\t\t\tdo_sstf_ord_q(&sstfq->right.queue, &sstfq->right.qtail, req);\n\t\t\tsstfq->right.qlen++;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "do_sstf_ord_q",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_sstf.c",
    "lines": "69-117",
    "snippet": "static void \ndo_sstf_ord_q(queuep, tailp, req)\n\tRF_DiskQueueData_t **queuep;\n\tRF_DiskQueueData_t **tailp;\n\tRF_DiskQueueData_t *req;\n{\n\tRF_DiskQueueData_t *r, *s;\n\n\tif (*queuep == NULL) {\n\t\t*queuep = req;\n\t\t*tailp = req;\n\t\treq->next = NULL;\n\t\treq->prev = NULL;\n\t\treturn;\n\t}\n\tif (req->sectorOffset <= (*queuep)->sectorOffset) {\n\t\treq->next = *queuep;\n\t\treq->prev = NULL;\n\t\t(*queuep)->prev = req;\n\t\t*queuep = req;\n\t\treturn;\n\t}\n\tif (req->sectorOffset > (*tailp)->sectorOffset) {\n\t\t/* optimization */\n\t\tr = NULL;\n\t\ts = *tailp;\n\t\tgoto q_at_end;\n\t}\n\tfor (s = NULL, r = *queuep; r; s = r, r = r->next) {\n\t\tif (r->sectorOffset >= req->sectorOffset) {\n\t\t\t/* insert after s, before r */\n\t\t\tRF_ASSERT(s);\n\t\t\treq->next = r;\n\t\t\tr->prev = req;\n\t\t\ts->next = req;\n\t\t\treq->prev = s;\n\t\t\treturn;\n\t\t}\n\t}\nq_at_end:\n\t/* insert after s, at end of queue */\n\tRF_ASSERT(r == NULL);\n\tRF_ASSERT(s);\n\tRF_ASSERT(s == (*tailp));\n\treq->next = NULL;\n\treq->prev = s;\n\ts->next = req;\n\t*tailp = req;\n}",
    "includes": [
      "#include \"rf_types.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_options.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_debugMem.h\"",
      "#include \"rf_sstf.h\"",
      "#include \"rf_diskqueue.h\"",
      "#include \"rf_layout.h\"",
      "#include \"rf_stripelocks.h\"",
      "#include \"rf_alloclist.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void \ndo_sstf_ord_q(RF_DiskQueueData_t **,\n    RF_DiskQueueData_t **,\n    RF_DiskQueueData_t *);",
      "static void do_dequeue(RF_SstfQ_t *, RF_DiskQueueData_t *);",
      "static RF_DiskQueueData_t *\nclosest_to_arm(queue, arm_pos, dir, allow_reverse)\n\tRF_SstfQ_t *queue;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "s == (*tailp)"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "s"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "r == NULL"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "s"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_types.h\"\n#include \"rf_raid.h\"\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_sstf.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_layout.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_alloclist.h\"\n\nstatic void \ndo_sstf_ord_q(RF_DiskQueueData_t **,\n    RF_DiskQueueData_t **,\n    RF_DiskQueueData_t *);\nstatic void do_dequeue(RF_SstfQ_t *, RF_DiskQueueData_t *);\nstatic RF_DiskQueueData_t *\nclosest_to_arm(queue, arm_pos, dir, allow_reverse)\n\tRF_SstfQ_t *queue;\n\nstatic void \ndo_sstf_ord_q(queuep, tailp, req)\n\tRF_DiskQueueData_t **queuep;\n\tRF_DiskQueueData_t **tailp;\n\tRF_DiskQueueData_t *req;\n{\n\tRF_DiskQueueData_t *r, *s;\n\n\tif (*queuep == NULL) {\n\t\t*queuep = req;\n\t\t*tailp = req;\n\t\treq->next = NULL;\n\t\treq->prev = NULL;\n\t\treturn;\n\t}\n\tif (req->sectorOffset <= (*queuep)->sectorOffset) {\n\t\treq->next = *queuep;\n\t\treq->prev = NULL;\n\t\t(*queuep)->prev = req;\n\t\t*queuep = req;\n\t\treturn;\n\t}\n\tif (req->sectorOffset > (*tailp)->sectorOffset) {\n\t\t/* optimization */\n\t\tr = NULL;\n\t\ts = *tailp;\n\t\tgoto q_at_end;\n\t}\n\tfor (s = NULL, r = *queuep; r; s = r, r = r->next) {\n\t\tif (r->sectorOffset >= req->sectorOffset) {\n\t\t\t/* insert after s, before r */\n\t\t\tRF_ASSERT(s);\n\t\t\treq->next = r;\n\t\t\tr->prev = req;\n\t\t\ts->next = req;\n\t\t\treq->prev = s;\n\t\t\treturn;\n\t\t}\n\t}\nq_at_end:\n\t/* insert after s, at end of queue */\n\tRF_ASSERT(r == NULL);\n\tRF_ASSERT(s);\n\tRF_ASSERT(s == (*tailp));\n\treq->next = NULL;\n\treq->prev = s;\n\ts->next = req;\n\t*tailp = req;\n}"
  }
]