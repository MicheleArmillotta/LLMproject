[
  {
    "function_name": "wx_ifmedia_sts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "1970-1986",
    "snippet": "static void\nwx_ifmedia_sts(ifp, ifmr)\n\tstruct ifnet *ifp;\n\tstruct ifmediareq *ifmr;\n{\n\tstruct wx_softc *sc = SOFTC_IFP(ifp);\n\n\tifmr->ifm_status = IFM_AVALID;\n\tifmr->ifm_active = IFM_ETHER;\n\n\tif (sc->linkup == 0)\n\t\treturn;\n\n\tifmr->ifm_status |= IFM_ACTIVE|IFM_1000_SX;\n\tif (READ_CSR(sc, WXREG_DSR) & WXDSR_FD)\n\t\tifmr->ifm_active |= IFM_FDX;\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wx_ifmedia_sts"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_CSR",
          "args": [
            "sc",
            "WXREG_DSR"
          ],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SOFTC_IFP",
          "args": [
            "ifp"
          ],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic void wx_ifmedia_sts;\n\nstatic void\nwx_ifmedia_sts(ifp, ifmr)\n\tstruct ifnet *ifp;\n\tstruct ifmediareq *ifmr;\n{\n\tstruct wx_softc *sc = SOFTC_IFP(ifp);\n\n\tifmr->ifm_status = IFM_AVALID;\n\tifmr->ifm_active = IFM_ETHER;\n\n\tif (sc->linkup == 0)\n\t\treturn;\n\n\tifmr->ifm_status |= IFM_ACTIVE|IFM_1000_SX;\n\tif (READ_CSR(sc, WXREG_DSR) & WXDSR_FD)\n\t\tifmr->ifm_active |= IFM_FDX;\n}"
  },
  {
    "function_name": "wx_ifmedia_upd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "1958-1968",
    "snippet": "static int\nwx_ifmedia_upd(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct wx_softc *sc = SOFTC_IFP(ifp);\n\tstruct ifmedia *ifm = &sc->wx_media;\n\n\tif (IFM_TYPE(ifm->ifm_media) != IFM_ETHER)\n\t\treturn (EINVAL);\n\treturn (0);\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int wx_ifmedia_upd"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IFM_TYPE",
          "args": [
            "ifm->ifm_media"
          ],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SOFTC_IFP",
          "args": [
            "ifp"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic int wx_ifmedia_upd;\n\nstatic int\nwx_ifmedia_upd(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct wx_softc *sc = SOFTC_IFP(ifp);\n\tstruct ifmedia *ifm = &sc->wx_media;\n\n\tif (IFM_TYPE(ifm->ifm_media) != IFM_ETHER)\n\t\treturn (EINVAL);\n\treturn (0);\n}"
  },
  {
    "function_name": "wx_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "1879-1956",
    "snippet": "static int\nwx_ioctl(ifp, command, data)\n\tstruct ifnet *ifp;\n\tIOCTL_CMD_TYPE command;\n\tcaddr_t data;\n{\n\twx_softc_t *sc = SOFTC_IFP(ifp);\n\tstruct ifreq *ifr = (struct ifreq *) data;\n\tint s, error = 0;\n\n\ts = splimp();\n\tswitch (command) {\n\tcase SIOCSIFADDR:\n#if !defined(__NetBSD__) && !defined(__OpenBSD__)\n\tcase SIOCGIFADDR:\n#endif\n\t\terror = ether_ioctl(ifp, command, data);\n\t\tbreak;\n\n\tcase SIOCSIFMTU:\n\t\tif (ifr->ifr_mtu > WX_MAXMTU || ifr->ifr_mtu < ETHERMIN) {\n\t\t\terror = EINVAL;\n                } else if (ifp->if_mtu != ifr->ifr_mtu) {\n\t\t\tifp->if_mtu = ifr->ifr_mtu;\n\t\t\terror = wx_init(sc);\n                }\n                break;\n\n\tcase SIOCSIFFLAGS:\n\t\tsc->all_mcasts = (ifp->if_flags & IFF_ALLMULTI) ? 1 : 0;\n\n\t\t/*\n\t\t * If interface is marked up and not running, then start it.\n\t\t * If it is marked down and running, stop it.\n\t\t * If it's up then re-initialize it. This is so flags\n\t\t * such as IFF_PROMISC are handled.\n\t\t */\n\t\tif (ifp->if_flags & IFF_UP) {\n\t\t\terror = wx_init(sc);\n\t\t} else {\n\t\t\tif (ifp->if_flags & IFF_RUNNING) {\n\t\t\t\twx_stop(sc);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n#ifdef\tSIOCADDMULTI\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n#if defined(__NetBSD__)\n\t{\n\t\tint all_mc_change = (sc->all_mcasts ==\n\t\t    ((ifp->if_flags & IFF_ALLMULTI) ? 1 : 0));\n\t\terror = (command == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->w.ethercom) :\n\t\t    ether_delmulti(ifr, &sc->w.ethercom);\n\t\tif (error != ENETRESET && all_mc_change == 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\t\tsc->all_mcasts = (ifp->if_flags & IFF_ALLMULTI) ? 1 : 0;\n\t\terror = wx_mc_setup(sc);\n\t\tbreak;\n#endif\n#ifdef\tSIOCGIFMEDIA\n\tcase SIOCGIFMEDIA:\n\tcase SIOCSIFMEDIA:\n\t\terror = ifmedia_ioctl(ifp, ifr, &sc->wx_media, command);\n\t\tbreak;\n#endif\n\tdefault:\n\t\terror = EINVAL;\n\t}\n\n\t(void) splx(s);\n\treturn (error);\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [
      "#define\t\tether_ioctl\twx_ether_ioctl",
      "#define\tWX_MAXMTU\tETHERMTU",
      "#define\tWX_MAXMTU\tJUMBOMTU"
    ],
    "globals_used": [
      "static int wx_ioctl",
      "static int wx_init",
      "static void wx_stop",
      "wx_eeprom_sibits __P((wx_softc_t *));",
      "wx_eeprom_cleanup __P((wx_softc_t *));",
      "wx_read_eeprom_word __P((wx_softc_t *, int));",
      "wx_mwi_whackon\t__P((wx_softc_t *));",
      "wx_mwi_unwhack\t__P((wx_softc_t *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_ioctl",
          "args": [
            "ifp",
            "ifr",
            "&sc->wx_media",
            "command"
          ],
          "line": 1947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wx_mc_setup",
          "args": [
            "sc"
          ],
          "line": 1941
        },
        "resolved": true,
        "details": {
          "function_name": "wx_mc_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "492-527",
          "snippet": "static int\nwx_mc_setup(sc)\n\twx_softc_t *sc;\n{\n\tstruct ifnet *ifp = &sc->wx_if;\n\tstruct ifmultiaddr *ifma;\n\n\t/*\n\t * XXX: drain TX queue- use a tsleep/wakeup until done.\n\t */\n\tif (sc->tactive) {\n\t\treturn (EBUSY);\n\t}\n\n\twx_stop(sc);\n\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\tsc->all_mcasts = 1;\n\t\treturn (wx_init(sc));\n\t}\n\n\tfor (ifma = ifp->if_multiaddrs.lh_first, sc->wx_nmca = 0;\n\t    ifma != NULL; ifma = ifma->ifma_link.le_next) {\n\t\tif (ifma->ifma_addr->sa_family != AF_LINK) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (sc->wx_nmca >= WX_RAL_TAB_SIZE-1) {\n\t\t\tsc->wx_nmca = 0;\n\t\t\tsc->all_mcasts = 1;\n\t\t\tbreak;\n\t\t}\n\t\tbcopy(LLADDR((struct sockaddr_dl *)ifma->ifma_addr),\n\t\t    (void *) &sc->wx_mcaddr[sc->wx_nmca++][0], 6);\n\t}\n\treturn (wx_init(sc));\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int wx_init",
            "static void wx_stop",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic int wx_init;\nstatic void wx_stop;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic int\nwx_mc_setup(sc)\n\twx_softc_t *sc;\n{\n\tstruct ifnet *ifp = &sc->wx_if;\n\tstruct ifmultiaddr *ifma;\n\n\t/*\n\t * XXX: drain TX queue- use a tsleep/wakeup until done.\n\t */\n\tif (sc->tactive) {\n\t\treturn (EBUSY);\n\t}\n\n\twx_stop(sc);\n\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\tsc->all_mcasts = 1;\n\t\treturn (wx_init(sc));\n\t}\n\n\tfor (ifma = ifp->if_multiaddrs.lh_first, sc->wx_nmca = 0;\n\t    ifma != NULL; ifma = ifma->ifma_link.le_next) {\n\t\tif (ifma->ifma_addr->sa_family != AF_LINK) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (sc->wx_nmca >= WX_RAL_TAB_SIZE-1) {\n\t\t\tsc->wx_nmca = 0;\n\t\t\tsc->all_mcasts = 1;\n\t\t\tbreak;\n\t\t}\n\t\tbcopy(LLADDR((struct sockaddr_dl *)ifma->ifma_addr),\n\t\t    (void *) &sc->wx_mcaddr[sc->wx_nmca++][0], 6);\n\t}\n\treturn (wx_init(sc));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_delmulti",
          "args": [
            "ifr",
            "&sc->w.ethercom"
          ],
          "line": 1934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_addmulti",
          "args": [
            "ifr",
            "&sc->w.ethercom"
          ],
          "line": 1933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wx_stop",
          "args": [
            "sc"
          ],
          "line": 1920
        },
        "resolved": true,
        "details": {
          "function_name": "wx_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "1641-1690",
          "snippet": "static void\nwx_stop(sc)\n\twx_softc_t *sc;\n{\n\ttxpkt_t *txp;\n\trxpkt_t *rxp;\n\tstruct ifnet *ifp = &sc->wx_if;\n\n\t/*\n\t * Cancel stats updater.\n\t */\n\tUNTIMEOUT(wx_stats_update, sc, sc);\n\n\t/*\n\t * Reset the chip\n\t */\n\twx_hw_stop(sc);\n\n\t/*\n\t * Release any xmit buffers.\n\t */\n\tfor (txp = sc->tbase; txp && txp < &sc->tbase[WX_MAX_TDESC]; txp++) {\n\t\tif (txp->dptr) {\n\t\t\tm_free(txp->dptr);\n\t\t\ttxp->dptr = NULL;\n\t\t}\n\t}\n\n\t/*\n\t * Free all the receive buffers.\n\t */\n\tfor (rxp = sc->rbase; rxp && rxp < &sc->rbase[WX_MAX_RDESC]; rxp++) {\n\t\tif (rxp->dptr) {\n\t\t\tm_free(rxp->dptr);\n\t\t\trxp->dptr = NULL;\n\t\t}\n\t}\n\n\tif (sc->rpending) {\n\t\tm_freem(sc->rpending);\n\t\tsc->rpending = NULL;\n\t}\n\n\t/*\n\t * And we're outta here...\n\t */\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\tifp->if_timer = 0;\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wx_hw_stop",
            "static void wx_stop",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "static void wx_stats_update",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic void wx_hw_stop;\nstatic void wx_stop;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic void wx_stats_update;\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic void\nwx_stop(sc)\n\twx_softc_t *sc;\n{\n\ttxpkt_t *txp;\n\trxpkt_t *rxp;\n\tstruct ifnet *ifp = &sc->wx_if;\n\n\t/*\n\t * Cancel stats updater.\n\t */\n\tUNTIMEOUT(wx_stats_update, sc, sc);\n\n\t/*\n\t * Reset the chip\n\t */\n\twx_hw_stop(sc);\n\n\t/*\n\t * Release any xmit buffers.\n\t */\n\tfor (txp = sc->tbase; txp && txp < &sc->tbase[WX_MAX_TDESC]; txp++) {\n\t\tif (txp->dptr) {\n\t\t\tm_free(txp->dptr);\n\t\t\ttxp->dptr = NULL;\n\t\t}\n\t}\n\n\t/*\n\t * Free all the receive buffers.\n\t */\n\tfor (rxp = sc->rbase; rxp && rxp < &sc->rbase[WX_MAX_RDESC]; rxp++) {\n\t\tif (rxp->dptr) {\n\t\t\tm_free(rxp->dptr);\n\t\t\trxp->dptr = NULL;\n\t\t}\n\t}\n\n\tif (sc->rpending) {\n\t\tm_freem(sc->rpending);\n\t\tsc->rpending = NULL;\n\t}\n\n\t/*\n\t * And we're outta here...\n\t */\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\tifp->if_timer = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wx_init",
          "args": [
            "sc"
          ],
          "line": 1917
        },
        "resolved": true,
        "details": {
          "function_name": "wx_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "1708-1835",
          "snippet": "static int\nwx_init(xsc)\n\tvoid *xsc;\n{\n\tstruct ifmedia *ifm;\n\twx_softc_t *sc = xsc;\n\tstruct ifnet *ifp = &sc->wx_if;\n\trxpkt_t *rxpkt;\n\twxrd_t *rd;\n\tsize_t len;\n\tint s, i, bflags;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel any pending I/O by resetting things.\n\t * wx_stop will free any allocated mbufs.\n\t */\n\twx_stop(sc);\n\n\t/*\n\t * Reset the hardware. All network addresses loaded here, but\n\t * neither the receiver nor the transmitter are enabled.\n\t */\n\n\tif (wx_hw_initialize(sc)) {\n\t\treturn (EIO);\n\t}\n\n\t/*\n\t * Set up the receive ring stuff.\n\t */\n\tlen = sizeof (wxrd_t) * WX_MAX_RDESC;\n\tbzero(sc->rdescriptors, len);\n\tfor (rxpkt = sc->rbase, i = 0; rxpkt != NULL && i < WX_MAX_RDESC;\n\t    i += RXINCR, rxpkt++) {\n\t\trd = &sc->rdescriptors[i];\n\t\tif (wx_get_rbuf(sc, rxpkt)) {\n\t\t\tbreak;\n\t\t}\n\t\trd->address.lowpart = rxpkt->dma_addr + WX_RX_OFFSET_VALUE;\n\t}\n\tif (i != WX_MAX_RDESC) {\n\t\tprintf(\"%s: could not set up rbufs\\n\", sc->wx_name);\n\t\twx_stop(sc);\n\t\treturn (ENOMEM);\n\t}\n\n\t/*\n\t * Set up transmit parameters and enable the transmitter.\n\t */\n\tsc->tnxtfree = sc->tactive = 0;\n\tsc->tbsyf = sc->tbsyl = NULL;\n\tWRITE_CSR(sc, WXREG_TCTL, 0);\n\tDELAY(5 * 1000);\n\tWRITE_CSR(sc, WXREG_TDBA_LO,\n\t\tvtophys((vm_offset_t)&sc->tdescriptors[0]));\n\tWRITE_CSR(sc, WXREG_TDBA_HI, 0);\n\tWRITE_CSR(sc, WXREG_TDLEN, WX_MAX_TDESC * sizeof (wxtd_t));\n\tWRITE_CSR(sc, WXREG_TDH, 0);\n\tWRITE_CSR(sc, WXREG_TDT, 0);\n\tWRITE_CSR(sc, WXREG_TQSA_HI, 0);\n\tWRITE_CSR(sc, WXREG_TQSA_LO, 0);\n\tWRITE_CSR(sc, WXREG_TIPG, WX_TIPG_DFLT);\n\tWRITE_CSR(sc, WXREG_TIDV, sc->wx_txint_delay);\n\tWRITE_CSR(sc, WXREG_TCTL, (WXTCTL_CT(WX_COLLISION_THRESHOLD) |\n\t    WXTCTL_COLD(WX_FDX_COLLISION_DX) | WXTCTL_EN));\n\t/*\n\t * Set up receive parameters and enable the receiver.\n\t */\n\n\tsc->rnxt = 0;\n\tWRITE_CSR(sc, WXREG_RCTL, 0);\n\tDELAY(5 * 1000);\n\tWRITE_CSR(sc, WXREG_RDTR0, WXRDTR_FPD);\n\tWRITE_CSR(sc, WXREG_RDBA0_LO,\n\t    vtophys((vm_offset_t)&sc->rdescriptors[0]));\n\tWRITE_CSR(sc, WXREG_RDBA0_HI, 0);\n\tWRITE_CSR(sc, WXREG_RDLEN0, WX_MAX_RDESC * sizeof (wxrd_t));\n\tWRITE_CSR(sc, WXREG_RDH0, 0);\n\tWRITE_CSR(sc, WXREG_RDT0, (WX_MAX_RDESC - RXINCR));\n\tWRITE_CSR(sc, WXREG_RDTR1, 0);\n\tWRITE_CSR(sc, WXREG_RDBA1_LO, 0);\n\tWRITE_CSR(sc, WXREG_RDBA1_HI, 0);\n\tWRITE_CSR(sc, WXREG_RDLEN1, 0);\n\tWRITE_CSR(sc, WXREG_RDH1, 0);\n\tWRITE_CSR(sc, WXREG_RDT1, 0);\n\n\tif (ifp->if_mtu > ETHERMTU) {\n\t\tprintf(\"%s: enabling for jumbo packets\\n\", sc->wx_name);\n\t\tbflags = WXRCTL_EN | WXRCTL_LPE | WXRCTL_2KRBUF;\n\t} else {\n\t\tbflags = WXRCTL_EN | WXRCTL_2KRBUF;\n\t}\n\n\tWRITE_CSR(sc, WXREG_RCTL, bflags |\n\t    ((ifp->if_flags & IFF_BROADCAST) ? WXRCTL_BAM : 0) |\n\t    ((ifp->if_flags & IFF_PROMISC) ? WXRCTL_UPE : 0) |\n\t    ((sc->all_mcasts) ? WXRCTL_MPE : 0));\n\n\t/*\n\t * Enable Interrupts\n\t */\n\tWX_ENABLE_INT(sc);\n\n\t/*\n\t * Mark that we're up and running...\n\t */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tifm = &sc->wx_media;\n\ti = ifm->ifm_media;\n\tifm->ifm_media = ifm->ifm_cur->ifm_media;\n\twx_ifmedia_upd(ifp);\n\tifm->ifm_media = i;\n\tsplx(s);\n\n\t/*\n\t * Start stats updater.\n\t */\n\tTIMEOUT(sc, wx_stats_update, sc, hz);\n\n\t/*\n\t * And we're outta here...\n\t */\n\treturn (0);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int wx_ifmedia_upd",
            "static int wx_init",
            "static int wx_hw_initialize",
            "static void wx_stop",
            "static int wx_get_rbuf",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "static void wx_stats_update",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic int wx_ifmedia_upd;\nstatic int wx_init;\nstatic int wx_hw_initialize;\nstatic void wx_stop;\nstatic int wx_get_rbuf;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic void wx_stats_update;\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic int\nwx_init(xsc)\n\tvoid *xsc;\n{\n\tstruct ifmedia *ifm;\n\twx_softc_t *sc = xsc;\n\tstruct ifnet *ifp = &sc->wx_if;\n\trxpkt_t *rxpkt;\n\twxrd_t *rd;\n\tsize_t len;\n\tint s, i, bflags;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel any pending I/O by resetting things.\n\t * wx_stop will free any allocated mbufs.\n\t */\n\twx_stop(sc);\n\n\t/*\n\t * Reset the hardware. All network addresses loaded here, but\n\t * neither the receiver nor the transmitter are enabled.\n\t */\n\n\tif (wx_hw_initialize(sc)) {\n\t\treturn (EIO);\n\t}\n\n\t/*\n\t * Set up the receive ring stuff.\n\t */\n\tlen = sizeof (wxrd_t) * WX_MAX_RDESC;\n\tbzero(sc->rdescriptors, len);\n\tfor (rxpkt = sc->rbase, i = 0; rxpkt != NULL && i < WX_MAX_RDESC;\n\t    i += RXINCR, rxpkt++) {\n\t\trd = &sc->rdescriptors[i];\n\t\tif (wx_get_rbuf(sc, rxpkt)) {\n\t\t\tbreak;\n\t\t}\n\t\trd->address.lowpart = rxpkt->dma_addr + WX_RX_OFFSET_VALUE;\n\t}\n\tif (i != WX_MAX_RDESC) {\n\t\tprintf(\"%s: could not set up rbufs\\n\", sc->wx_name);\n\t\twx_stop(sc);\n\t\treturn (ENOMEM);\n\t}\n\n\t/*\n\t * Set up transmit parameters and enable the transmitter.\n\t */\n\tsc->tnxtfree = sc->tactive = 0;\n\tsc->tbsyf = sc->tbsyl = NULL;\n\tWRITE_CSR(sc, WXREG_TCTL, 0);\n\tDELAY(5 * 1000);\n\tWRITE_CSR(sc, WXREG_TDBA_LO,\n\t\tvtophys((vm_offset_t)&sc->tdescriptors[0]));\n\tWRITE_CSR(sc, WXREG_TDBA_HI, 0);\n\tWRITE_CSR(sc, WXREG_TDLEN, WX_MAX_TDESC * sizeof (wxtd_t));\n\tWRITE_CSR(sc, WXREG_TDH, 0);\n\tWRITE_CSR(sc, WXREG_TDT, 0);\n\tWRITE_CSR(sc, WXREG_TQSA_HI, 0);\n\tWRITE_CSR(sc, WXREG_TQSA_LO, 0);\n\tWRITE_CSR(sc, WXREG_TIPG, WX_TIPG_DFLT);\n\tWRITE_CSR(sc, WXREG_TIDV, sc->wx_txint_delay);\n\tWRITE_CSR(sc, WXREG_TCTL, (WXTCTL_CT(WX_COLLISION_THRESHOLD) |\n\t    WXTCTL_COLD(WX_FDX_COLLISION_DX) | WXTCTL_EN));\n\t/*\n\t * Set up receive parameters and enable the receiver.\n\t */\n\n\tsc->rnxt = 0;\n\tWRITE_CSR(sc, WXREG_RCTL, 0);\n\tDELAY(5 * 1000);\n\tWRITE_CSR(sc, WXREG_RDTR0, WXRDTR_FPD);\n\tWRITE_CSR(sc, WXREG_RDBA0_LO,\n\t    vtophys((vm_offset_t)&sc->rdescriptors[0]));\n\tWRITE_CSR(sc, WXREG_RDBA0_HI, 0);\n\tWRITE_CSR(sc, WXREG_RDLEN0, WX_MAX_RDESC * sizeof (wxrd_t));\n\tWRITE_CSR(sc, WXREG_RDH0, 0);\n\tWRITE_CSR(sc, WXREG_RDT0, (WX_MAX_RDESC - RXINCR));\n\tWRITE_CSR(sc, WXREG_RDTR1, 0);\n\tWRITE_CSR(sc, WXREG_RDBA1_LO, 0);\n\tWRITE_CSR(sc, WXREG_RDBA1_HI, 0);\n\tWRITE_CSR(sc, WXREG_RDLEN1, 0);\n\tWRITE_CSR(sc, WXREG_RDH1, 0);\n\tWRITE_CSR(sc, WXREG_RDT1, 0);\n\n\tif (ifp->if_mtu > ETHERMTU) {\n\t\tprintf(\"%s: enabling for jumbo packets\\n\", sc->wx_name);\n\t\tbflags = WXRCTL_EN | WXRCTL_LPE | WXRCTL_2KRBUF;\n\t} else {\n\t\tbflags = WXRCTL_EN | WXRCTL_2KRBUF;\n\t}\n\n\tWRITE_CSR(sc, WXREG_RCTL, bflags |\n\t    ((ifp->if_flags & IFF_BROADCAST) ? WXRCTL_BAM : 0) |\n\t    ((ifp->if_flags & IFF_PROMISC) ? WXRCTL_UPE : 0) |\n\t    ((sc->all_mcasts) ? WXRCTL_MPE : 0));\n\n\t/*\n\t * Enable Interrupts\n\t */\n\tWX_ENABLE_INT(sc);\n\n\t/*\n\t * Mark that we're up and running...\n\t */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tifm = &sc->wx_media;\n\ti = ifm->ifm_media;\n\tifm->ifm_media = ifm->ifm_cur->ifm_media;\n\twx_ifmedia_upd(ifp);\n\tifm->ifm_media = i;\n\tsplx(s);\n\n\t/*\n\t * Start stats updater.\n\t */\n\tTIMEOUT(sc, wx_stats_update, sc, hz);\n\n\t/*\n\t * And we're outta here...\n\t */\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_ioctl",
          "args": [
            "ifp",
            "command",
            "data"
          ],
          "line": 1895
        },
        "resolved": true,
        "details": {
          "function_name": "wx_ether_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "303-356",
          "snippet": "static int\nwx_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tIOCTL_CMD_TYPE cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tint error = 0;\n\twx_softc_t *sc = SOFTC_IFP(ifp);\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\terror = wx_init(sc);\n\t\tif (error) {\n\t\t\tifp->if_flags &= ~IFF_UP;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n#ifdef __OpenBSD__\n\t\t\tarp_ifinit(&sc->w.arpcom, ifa);\n#else\n\t\t\tarp_ifinit(ifp, ifa);\n#endif\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t{\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t break;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int wx_init",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic int wx_init;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic int\nwx_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tIOCTL_CMD_TYPE cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tint error = 0;\n\twx_softc_t *sc = SOFTC_IFP(ifp);\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\terror = wx_init(sc);\n\t\tif (error) {\n\t\t\tifp->if_flags &= ~IFF_UP;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n#ifdef __OpenBSD__\n\t\t\tarp_ifinit(&sc->w.arpcom, ifa);\n#else\n\t\t\tarp_ifinit(ifp, ifa);\n#endif\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t{\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t break;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SOFTC_IFP",
          "args": [
            "ifp"
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\n#define\t\tether_ioctl\twx_ether_ioctl\n#define\tWX_MAXMTU\tETHERMTU\n#define\tWX_MAXMTU\tJUMBOMTU\n\nstatic int wx_ioctl;\nstatic int wx_init;\nstatic void wx_stop;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic int\nwx_ioctl(ifp, command, data)\n\tstruct ifnet *ifp;\n\tIOCTL_CMD_TYPE command;\n\tcaddr_t data;\n{\n\twx_softc_t *sc = SOFTC_IFP(ifp);\n\tstruct ifreq *ifr = (struct ifreq *) data;\n\tint s, error = 0;\n\n\ts = splimp();\n\tswitch (command) {\n\tcase SIOCSIFADDR:\n#if !defined(__NetBSD__) && !defined(__OpenBSD__)\n\tcase SIOCGIFADDR:\n#endif\n\t\terror = ether_ioctl(ifp, command, data);\n\t\tbreak;\n\n\tcase SIOCSIFMTU:\n\t\tif (ifr->ifr_mtu > WX_MAXMTU || ifr->ifr_mtu < ETHERMIN) {\n\t\t\terror = EINVAL;\n                } else if (ifp->if_mtu != ifr->ifr_mtu) {\n\t\t\tifp->if_mtu = ifr->ifr_mtu;\n\t\t\terror = wx_init(sc);\n                }\n                break;\n\n\tcase SIOCSIFFLAGS:\n\t\tsc->all_mcasts = (ifp->if_flags & IFF_ALLMULTI) ? 1 : 0;\n\n\t\t/*\n\t\t * If interface is marked up and not running, then start it.\n\t\t * If it is marked down and running, stop it.\n\t\t * If it's up then re-initialize it. This is so flags\n\t\t * such as IFF_PROMISC are handled.\n\t\t */\n\t\tif (ifp->if_flags & IFF_UP) {\n\t\t\terror = wx_init(sc);\n\t\t} else {\n\t\t\tif (ifp->if_flags & IFF_RUNNING) {\n\t\t\t\twx_stop(sc);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n#ifdef\tSIOCADDMULTI\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n#if defined(__NetBSD__)\n\t{\n\t\tint all_mc_change = (sc->all_mcasts ==\n\t\t    ((ifp->if_flags & IFF_ALLMULTI) ? 1 : 0));\n\t\terror = (command == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->w.ethercom) :\n\t\t    ether_delmulti(ifr, &sc->w.ethercom);\n\t\tif (error != ENETRESET && all_mc_change == 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\t\tsc->all_mcasts = (ifp->if_flags & IFF_ALLMULTI) ? 1 : 0;\n\t\terror = wx_mc_setup(sc);\n\t\tbreak;\n#endif\n#ifdef\tSIOCGIFMEDIA\n\tcase SIOCGIFMEDIA:\n\tcase SIOCSIFMEDIA:\n\t\terror = ifmedia_ioctl(ifp, ifr, &sc->wx_media, command);\n\t\tbreak;\n#endif\n\tdefault:\n\t\terror = EINVAL;\n\t}\n\n\t(void) splx(s);\n\treturn (error);\n}"
  },
  {
    "function_name": "wx_get_rbuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "1858-1877",
    "snippet": "static int\nwx_get_rbuf(sc, rxpkt)\n\twx_softc_t *sc;\n\trxpkt_t *rxpkt;\n{\n\tstruct mbuf *mb;\n\tMGETHDR(mb, M_DONTWAIT, MT_DATA);\n\tif (mb == NULL) {\n\t\trxpkt->dptr = NULL;\n\t\treturn (-1);\n\t}\n\tMCLGET(mb, M_DONTWAIT);\n\tif ((mb->m_flags & M_EXT) == 0) {\n\t\tm_freem(mb);\n\t\trxpkt->dptr = NULL;\n\t\treturn (-1);\n\t}\n\twx_rxdma_map(sc, rxpkt, mb);\n\treturn (0);\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int wx_get_rbuf",
      "static void wx_rxdma_map",
      "wx_eeprom_sibits __P((wx_softc_t *));",
      "wx_eeprom_cleanup __P((wx_softc_t *));",
      "wx_read_eeprom_word __P((wx_softc_t *, int));",
      "wx_mwi_whackon\t__P((wx_softc_t *));",
      "wx_mwi_unwhack\t__P((wx_softc_t *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wx_rxdma_map",
          "args": [
            "sc",
            "rxpkt",
            "mb"
          ],
          "line": 1875
        },
        "resolved": true,
        "details": {
          "function_name": "wx_rxdma_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "1848-1856",
          "snippet": "static void\nwx_rxdma_map(sc, rxpkt, mb)\n\twx_softc_t *sc;\n\trxpkt_t *rxpkt;\n\tstruct mbuf *mb;\n{\n\trxpkt->dptr = mb;\n\trxpkt->dma_addr = vtophys(mtod(mb, vm_offset_t));\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wx_rxdma_map",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic void wx_rxdma_map;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic void\nwx_rxdma_map(sc, rxpkt, mb)\n\twx_softc_t *sc;\n\trxpkt_t *rxpkt;\n\tstruct mbuf *mb;\n{\n\trxpkt->dptr = mb;\n\trxpkt->dma_addr = vtophys(mtod(mb, vm_offset_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "mb"
          ],
          "line": 1871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCLGET",
          "args": [
            "mb",
            "M_DONTWAIT"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGETHDR",
          "args": [
            "mb",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic int wx_get_rbuf;\nstatic void wx_rxdma_map;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic int\nwx_get_rbuf(sc, rxpkt)\n\twx_softc_t *sc;\n\trxpkt_t *rxpkt;\n{\n\tstruct mbuf *mb;\n\tMGETHDR(mb, M_DONTWAIT, MT_DATA);\n\tif (mb == NULL) {\n\t\trxpkt->dptr = NULL;\n\t\treturn (-1);\n\t}\n\tMCLGET(mb, M_DONTWAIT);\n\tif ((mb->m_flags & M_EXT) == 0) {\n\t\tm_freem(mb);\n\t\trxpkt->dptr = NULL;\n\t\treturn (-1);\n\t}\n\twx_rxdma_map(sc, rxpkt, mb);\n\treturn (0);\n}"
  },
  {
    "function_name": "wx_rxdma_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "1848-1856",
    "snippet": "static void\nwx_rxdma_map(sc, rxpkt, mb)\n\twx_softc_t *sc;\n\trxpkt_t *rxpkt;\n\tstruct mbuf *mb;\n{\n\trxpkt->dptr = mb;\n\trxpkt->dma_addr = vtophys(mtod(mb, vm_offset_t));\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wx_rxdma_map",
      "wx_eeprom_sibits __P((wx_softc_t *));",
      "wx_eeprom_cleanup __P((wx_softc_t *));",
      "wx_read_eeprom_word __P((wx_softc_t *, int));",
      "wx_mwi_whackon\t__P((wx_softc_t *));",
      "wx_mwi_unwhack\t__P((wx_softc_t *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "mtod(mb, vm_offset_t)"
          ],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "mb",
            "vm_offset_t"
          ],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic void wx_rxdma_map;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic void\nwx_rxdma_map(sc, rxpkt, mb)\n\twx_softc_t *sc;\n\trxpkt_t *rxpkt;\n\tstruct mbuf *mb;\n{\n\trxpkt->dptr = mb;\n\trxpkt->dma_addr = vtophys(mtod(mb, vm_offset_t));\n}"
  },
  {
    "function_name": "wx_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "1708-1835",
    "snippet": "static int\nwx_init(xsc)\n\tvoid *xsc;\n{\n\tstruct ifmedia *ifm;\n\twx_softc_t *sc = xsc;\n\tstruct ifnet *ifp = &sc->wx_if;\n\trxpkt_t *rxpkt;\n\twxrd_t *rd;\n\tsize_t len;\n\tint s, i, bflags;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel any pending I/O by resetting things.\n\t * wx_stop will free any allocated mbufs.\n\t */\n\twx_stop(sc);\n\n\t/*\n\t * Reset the hardware. All network addresses loaded here, but\n\t * neither the receiver nor the transmitter are enabled.\n\t */\n\n\tif (wx_hw_initialize(sc)) {\n\t\treturn (EIO);\n\t}\n\n\t/*\n\t * Set up the receive ring stuff.\n\t */\n\tlen = sizeof (wxrd_t) * WX_MAX_RDESC;\n\tbzero(sc->rdescriptors, len);\n\tfor (rxpkt = sc->rbase, i = 0; rxpkt != NULL && i < WX_MAX_RDESC;\n\t    i += RXINCR, rxpkt++) {\n\t\trd = &sc->rdescriptors[i];\n\t\tif (wx_get_rbuf(sc, rxpkt)) {\n\t\t\tbreak;\n\t\t}\n\t\trd->address.lowpart = rxpkt->dma_addr + WX_RX_OFFSET_VALUE;\n\t}\n\tif (i != WX_MAX_RDESC) {\n\t\tprintf(\"%s: could not set up rbufs\\n\", sc->wx_name);\n\t\twx_stop(sc);\n\t\treturn (ENOMEM);\n\t}\n\n\t/*\n\t * Set up transmit parameters and enable the transmitter.\n\t */\n\tsc->tnxtfree = sc->tactive = 0;\n\tsc->tbsyf = sc->tbsyl = NULL;\n\tWRITE_CSR(sc, WXREG_TCTL, 0);\n\tDELAY(5 * 1000);\n\tWRITE_CSR(sc, WXREG_TDBA_LO,\n\t\tvtophys((vm_offset_t)&sc->tdescriptors[0]));\n\tWRITE_CSR(sc, WXREG_TDBA_HI, 0);\n\tWRITE_CSR(sc, WXREG_TDLEN, WX_MAX_TDESC * sizeof (wxtd_t));\n\tWRITE_CSR(sc, WXREG_TDH, 0);\n\tWRITE_CSR(sc, WXREG_TDT, 0);\n\tWRITE_CSR(sc, WXREG_TQSA_HI, 0);\n\tWRITE_CSR(sc, WXREG_TQSA_LO, 0);\n\tWRITE_CSR(sc, WXREG_TIPG, WX_TIPG_DFLT);\n\tWRITE_CSR(sc, WXREG_TIDV, sc->wx_txint_delay);\n\tWRITE_CSR(sc, WXREG_TCTL, (WXTCTL_CT(WX_COLLISION_THRESHOLD) |\n\t    WXTCTL_COLD(WX_FDX_COLLISION_DX) | WXTCTL_EN));\n\t/*\n\t * Set up receive parameters and enable the receiver.\n\t */\n\n\tsc->rnxt = 0;\n\tWRITE_CSR(sc, WXREG_RCTL, 0);\n\tDELAY(5 * 1000);\n\tWRITE_CSR(sc, WXREG_RDTR0, WXRDTR_FPD);\n\tWRITE_CSR(sc, WXREG_RDBA0_LO,\n\t    vtophys((vm_offset_t)&sc->rdescriptors[0]));\n\tWRITE_CSR(sc, WXREG_RDBA0_HI, 0);\n\tWRITE_CSR(sc, WXREG_RDLEN0, WX_MAX_RDESC * sizeof (wxrd_t));\n\tWRITE_CSR(sc, WXREG_RDH0, 0);\n\tWRITE_CSR(sc, WXREG_RDT0, (WX_MAX_RDESC - RXINCR));\n\tWRITE_CSR(sc, WXREG_RDTR1, 0);\n\tWRITE_CSR(sc, WXREG_RDBA1_LO, 0);\n\tWRITE_CSR(sc, WXREG_RDBA1_HI, 0);\n\tWRITE_CSR(sc, WXREG_RDLEN1, 0);\n\tWRITE_CSR(sc, WXREG_RDH1, 0);\n\tWRITE_CSR(sc, WXREG_RDT1, 0);\n\n\tif (ifp->if_mtu > ETHERMTU) {\n\t\tprintf(\"%s: enabling for jumbo packets\\n\", sc->wx_name);\n\t\tbflags = WXRCTL_EN | WXRCTL_LPE | WXRCTL_2KRBUF;\n\t} else {\n\t\tbflags = WXRCTL_EN | WXRCTL_2KRBUF;\n\t}\n\n\tWRITE_CSR(sc, WXREG_RCTL, bflags |\n\t    ((ifp->if_flags & IFF_BROADCAST) ? WXRCTL_BAM : 0) |\n\t    ((ifp->if_flags & IFF_PROMISC) ? WXRCTL_UPE : 0) |\n\t    ((sc->all_mcasts) ? WXRCTL_MPE : 0));\n\n\t/*\n\t * Enable Interrupts\n\t */\n\tWX_ENABLE_INT(sc);\n\n\t/*\n\t * Mark that we're up and running...\n\t */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tifm = &sc->wx_media;\n\ti = ifm->ifm_media;\n\tifm->ifm_media = ifm->ifm_cur->ifm_media;\n\twx_ifmedia_upd(ifp);\n\tifm->ifm_media = i;\n\tsplx(s);\n\n\t/*\n\t * Start stats updater.\n\t */\n\tTIMEOUT(sc, wx_stats_update, sc, hz);\n\n\t/*\n\t * And we're outta here...\n\t */\n\treturn (0);\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int wx_ifmedia_upd",
      "static int wx_init",
      "static int wx_hw_initialize",
      "static void wx_stop",
      "static int wx_get_rbuf",
      "wx_eeprom_sibits __P((wx_softc_t *));",
      "wx_eeprom_cleanup __P((wx_softc_t *));",
      "wx_read_eeprom_word __P((wx_softc_t *, int));",
      "static void wx_stats_update",
      "wx_mwi_whackon\t__P((wx_softc_t *));",
      "wx_mwi_unwhack\t__P((wx_softc_t *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TIMEOUT",
          "args": [
            "sc",
            "wx_stats_update",
            "sc",
            "hz"
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wx_ifmedia_upd",
          "args": [
            "ifp"
          ],
          "line": 1822
        },
        "resolved": true,
        "details": {
          "function_name": "wx_ifmedia_upd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "1958-1968",
          "snippet": "static int\nwx_ifmedia_upd(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct wx_softc *sc = SOFTC_IFP(ifp);\n\tstruct ifmedia *ifm = &sc->wx_media;\n\n\tif (IFM_TYPE(ifm->ifm_media) != IFM_ETHER)\n\t\treturn (EINVAL);\n\treturn (0);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int wx_ifmedia_upd"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic int wx_ifmedia_upd;\n\nstatic int\nwx_ifmedia_upd(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct wx_softc *sc = SOFTC_IFP(ifp);\n\tstruct ifmedia *ifm = &sc->wx_media;\n\n\tif (IFM_TYPE(ifm->ifm_media) != IFM_ETHER)\n\t\treturn (EINVAL);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WX_ENABLE_INT",
          "args": [
            "sc"
          ],
          "line": 1811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_RCTL",
            "bflags |\n\t    ((ifp->if_flags & IFF_BROADCAST) ? WXRCTL_BAM : 0) |\n\t    ((ifp->if_flags & IFF_PROMISC) ? WXRCTL_UPE : 0) |\n\t    ((sc->all_mcasts) ? WXRCTL_MPE : 0)"
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: enabling for jumbo packets\\n\"",
            "sc->wx_name"
          ],
          "line": 1797
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_RDT1",
            "0"
          ],
          "line": 1794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_RDH1",
            "0"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_RDLEN1",
            "0"
          ],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_RDBA1_HI",
            "0"
          ],
          "line": 1791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_RDBA1_LO",
            "0"
          ],
          "line": 1790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_RDTR1",
            "0"
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_RDT0",
            "(WX_MAX_RDESC - RXINCR)"
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_RDH0",
            "0"
          ],
          "line": 1787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_RDLEN0",
            "WX_MAX_RDESC * sizeof (wxrd_t)"
          ],
          "line": 1786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_RDBA0_HI",
            "0"
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_RDBA0_LO",
            "vtophys((vm_offset_t)&sc->rdescriptors[0])"
          ],
          "line": 1783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "(vm_offset_t)&sc->rdescriptors[0]"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_RDTR0",
            "WXRDTR_FPD"
          ],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "5 * 1000"
          ],
          "line": 1781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_RCTL",
            "0"
          ],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_TCTL",
            "(WXTCTL_CT(WX_COLLISION_THRESHOLD) |\n\t    WXTCTL_COLD(WX_FDX_COLLISION_DX) | WXTCTL_EN)"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WXTCTL_COLD",
          "args": [
            "WX_FDX_COLLISION_DX"
          ],
          "line": 1774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WXTCTL_CT",
          "args": [
            "WX_COLLISION_THRESHOLD"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_TIDV",
            "sc->wx_txint_delay"
          ],
          "line": 1772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_TIPG",
            "WX_TIPG_DFLT"
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_TQSA_LO",
            "0"
          ],
          "line": 1770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_TQSA_HI",
            "0"
          ],
          "line": 1769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_TDT",
            "0"
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_TDH",
            "0"
          ],
          "line": 1767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_TDLEN",
            "WX_MAX_TDESC * sizeof (wxtd_t)"
          ],
          "line": 1766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_TDBA_HI",
            "0"
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_TDBA_LO",
            "vtophys((vm_offset_t)&sc->tdescriptors[0])"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "(vm_offset_t)&sc->tdescriptors[0]"
          ],
          "line": 1764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "5 * 1000"
          ],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_TCTL",
            "0"
          ],
          "line": 1761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wx_stop",
          "args": [
            "sc"
          ],
          "line": 1752
        },
        "resolved": true,
        "details": {
          "function_name": "wx_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "1641-1690",
          "snippet": "static void\nwx_stop(sc)\n\twx_softc_t *sc;\n{\n\ttxpkt_t *txp;\n\trxpkt_t *rxp;\n\tstruct ifnet *ifp = &sc->wx_if;\n\n\t/*\n\t * Cancel stats updater.\n\t */\n\tUNTIMEOUT(wx_stats_update, sc, sc);\n\n\t/*\n\t * Reset the chip\n\t */\n\twx_hw_stop(sc);\n\n\t/*\n\t * Release any xmit buffers.\n\t */\n\tfor (txp = sc->tbase; txp && txp < &sc->tbase[WX_MAX_TDESC]; txp++) {\n\t\tif (txp->dptr) {\n\t\t\tm_free(txp->dptr);\n\t\t\ttxp->dptr = NULL;\n\t\t}\n\t}\n\n\t/*\n\t * Free all the receive buffers.\n\t */\n\tfor (rxp = sc->rbase; rxp && rxp < &sc->rbase[WX_MAX_RDESC]; rxp++) {\n\t\tif (rxp->dptr) {\n\t\t\tm_free(rxp->dptr);\n\t\t\trxp->dptr = NULL;\n\t\t}\n\t}\n\n\tif (sc->rpending) {\n\t\tm_freem(sc->rpending);\n\t\tsc->rpending = NULL;\n\t}\n\n\t/*\n\t * And we're outta here...\n\t */\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\tifp->if_timer = 0;\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wx_hw_stop",
            "static void wx_stop",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "static void wx_stats_update",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic void wx_hw_stop;\nstatic void wx_stop;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic void wx_stats_update;\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic void\nwx_stop(sc)\n\twx_softc_t *sc;\n{\n\ttxpkt_t *txp;\n\trxpkt_t *rxp;\n\tstruct ifnet *ifp = &sc->wx_if;\n\n\t/*\n\t * Cancel stats updater.\n\t */\n\tUNTIMEOUT(wx_stats_update, sc, sc);\n\n\t/*\n\t * Reset the chip\n\t */\n\twx_hw_stop(sc);\n\n\t/*\n\t * Release any xmit buffers.\n\t */\n\tfor (txp = sc->tbase; txp && txp < &sc->tbase[WX_MAX_TDESC]; txp++) {\n\t\tif (txp->dptr) {\n\t\t\tm_free(txp->dptr);\n\t\t\ttxp->dptr = NULL;\n\t\t}\n\t}\n\n\t/*\n\t * Free all the receive buffers.\n\t */\n\tfor (rxp = sc->rbase; rxp && rxp < &sc->rbase[WX_MAX_RDESC]; rxp++) {\n\t\tif (rxp->dptr) {\n\t\t\tm_free(rxp->dptr);\n\t\t\trxp->dptr = NULL;\n\t\t}\n\t}\n\n\tif (sc->rpending) {\n\t\tm_freem(sc->rpending);\n\t\tsc->rpending = NULL;\n\t}\n\n\t/*\n\t * And we're outta here...\n\t */\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\tifp->if_timer = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wx_get_rbuf",
          "args": [
            "sc",
            "rxpkt"
          ],
          "line": 1745
        },
        "resolved": true,
        "details": {
          "function_name": "wx_get_rbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "1858-1877",
          "snippet": "static int\nwx_get_rbuf(sc, rxpkt)\n\twx_softc_t *sc;\n\trxpkt_t *rxpkt;\n{\n\tstruct mbuf *mb;\n\tMGETHDR(mb, M_DONTWAIT, MT_DATA);\n\tif (mb == NULL) {\n\t\trxpkt->dptr = NULL;\n\t\treturn (-1);\n\t}\n\tMCLGET(mb, M_DONTWAIT);\n\tif ((mb->m_flags & M_EXT) == 0) {\n\t\tm_freem(mb);\n\t\trxpkt->dptr = NULL;\n\t\treturn (-1);\n\t}\n\twx_rxdma_map(sc, rxpkt, mb);\n\treturn (0);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int wx_get_rbuf",
            "static void wx_rxdma_map",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic int wx_get_rbuf;\nstatic void wx_rxdma_map;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic int\nwx_get_rbuf(sc, rxpkt)\n\twx_softc_t *sc;\n\trxpkt_t *rxpkt;\n{\n\tstruct mbuf *mb;\n\tMGETHDR(mb, M_DONTWAIT, MT_DATA);\n\tif (mb == NULL) {\n\t\trxpkt->dptr = NULL;\n\t\treturn (-1);\n\t}\n\tMCLGET(mb, M_DONTWAIT);\n\tif ((mb->m_flags & M_EXT) == 0) {\n\t\tm_freem(mb);\n\t\trxpkt->dptr = NULL;\n\t\treturn (-1);\n\t}\n\twx_rxdma_map(sc, rxpkt, mb);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "sc->rdescriptors",
            "len"
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wx_hw_initialize",
          "args": [
            "sc"
          ],
          "line": 1733
        },
        "resolved": true,
        "details": {
          "function_name": "wx_hw_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "1547-1636",
          "snippet": "static int\nwx_hw_initialize(sc)\n\twx_softc_t *sc;\n{\n\tint i;\n\n\tWRITE_CSR(sc, WXREG_VET, 0);\n\tfor (i = 0; i < (WX_VLAN_TAB_SIZE << 2); i += 4) {\n\t\tWRITE_CSR(sc, (WXREG_VFTA + i), 0);\n\t}\n\tif (sc->revision == 2) {\n\t\twx_mwi_whackon(sc);\n\t\tWRITE_CSR(sc, WXREG_RCTL, WXRCTL_RST);\n\t\tDELAY(5 * 1000);\n\t}\n\t/*\n\t * Load the first receiver address with our MAC address,\n\t * and load as many multicast addresses as can fit into\n\t * the receive address array.\n\t */\n\twx_set_addr(sc, 0, sc->wx_enaddr);\n\tfor (i = 1; i <= sc->wx_nmca; i++) {\n\t\tif (i >= WX_RAL_TAB_SIZE) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\twx_set_addr(sc, i, sc->wx_mcaddr[i-1]);\n\t\t}\n\t}\n\n\twhile (i < WX_RAL_TAB_SIZE) {\n\t\tWRITE_CSR(sc, WXREG_RAL_LO(i), 0);\n\t\tWRITE_CSR(sc, WXREG_RAL_HI(i), 0);\n\t\ti++;\n\t}\n\n\tif (sc->revision == 2) {\n\t\tWRITE_CSR(sc, WXREG_RCTL, 0);\n\t\tDELAY(1 * 1000);\n\t\twx_mwi_unwhack(sc);\n\t}\n\n\t/*\n\t * Clear out the hashed multicast table array.\n\t */\n\tfor (i = 0; i < WX_MC_TAB_SIZE; i++) {\n\t\tWRITE_CSR(sc, WXREG_MTA + (sizeof (u_int32_t) * 4), 0);\n\t}\n\tif (sc->wx_dcr & (WXDCR_RFCE|WXDCR_TFCE)) {\n\t\tWRITE_CSR(sc, WXREG_FCAL, FC_FRM_CONST_LO);\n\t\tWRITE_CSR(sc, WXREG_FCAH, FC_FRM_CONST_HI);\n\t\tWRITE_CSR(sc, WXREG_FCT, FC_TYP_CONST);\n\t} else {\n\t\tWRITE_CSR(sc, WXREG_FCAL, 0);\n\t\tWRITE_CSR(sc, WXREG_FCAH, 0);\n\t\tWRITE_CSR(sc, WXREG_FCT, 0);\n\t}\n\tWRITE_CSR(sc, WXREG_FLOW_XTIMER, WX_XTIMER_DFLT);\n\tif (sc->revision == 2) {\n\t\tWRITE_CSR(sc, WXREG_FLOW_RCV_HI, 0);\n\t\tWRITE_CSR(sc, WXREG_FLOW_RCV_LO, 0);\n\t} else {\n\t\tWRITE_CSR(sc, WXREG_FLOW_RCV_HI, WX_RCV_FLOW_HI_DFLT);\n\t\tWRITE_CSR(sc, WXREG_FLOW_RCV_LO, WX_RCV_FLOW_LO_DFLT);\n\t}\n\tWRITE_CSR(sc, WXREG_XMIT_CFGW, WXTXCW_DEFAULT);\n\tWRITE_CSR(sc, WXREG_DCR, sc->wx_dcr);\n\tDELAY(50 * 1000);\n\n\t/*\n\t * The pin stuff is all FM from the Linux driver.\n\t */\n\tif ((READ_CSR(sc, WXREG_DCR) & WXDCR_SWDPIN1) == 0) {\n\t\tfor (i = 0; i < 500; i++) {\n\t\t\tDELAY(10 * 1000);\n\t\t\tif (READ_CSR(sc, WXREG_DSR) & WXDSR_LU) {\n\t\t\t\tsc->linkup = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tprintf(\"%s: swdpio did not clear\\n\", sc->wx_name);\n\t\treturn (-1);\n\t}\n\tif (sc->linkup == 0) {\n\t\tprintf(\"%s: link never came up\\n\", sc->wx_name);\n\t\treturn (-1);\n\t}\n\tsc->wx_ienable = WXIENABLE_DEFAULT;\n\treturn (0);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wx_set_addr",
            "static int wx_hw_initialize",
            "wx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));",
            "wx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic void wx_set_addr;\nstatic int wx_hw_initialize;\nwx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));\nwx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic int\nwx_hw_initialize(sc)\n\twx_softc_t *sc;\n{\n\tint i;\n\n\tWRITE_CSR(sc, WXREG_VET, 0);\n\tfor (i = 0; i < (WX_VLAN_TAB_SIZE << 2); i += 4) {\n\t\tWRITE_CSR(sc, (WXREG_VFTA + i), 0);\n\t}\n\tif (sc->revision == 2) {\n\t\twx_mwi_whackon(sc);\n\t\tWRITE_CSR(sc, WXREG_RCTL, WXRCTL_RST);\n\t\tDELAY(5 * 1000);\n\t}\n\t/*\n\t * Load the first receiver address with our MAC address,\n\t * and load as many multicast addresses as can fit into\n\t * the receive address array.\n\t */\n\twx_set_addr(sc, 0, sc->wx_enaddr);\n\tfor (i = 1; i <= sc->wx_nmca; i++) {\n\t\tif (i >= WX_RAL_TAB_SIZE) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\twx_set_addr(sc, i, sc->wx_mcaddr[i-1]);\n\t\t}\n\t}\n\n\twhile (i < WX_RAL_TAB_SIZE) {\n\t\tWRITE_CSR(sc, WXREG_RAL_LO(i), 0);\n\t\tWRITE_CSR(sc, WXREG_RAL_HI(i), 0);\n\t\ti++;\n\t}\n\n\tif (sc->revision == 2) {\n\t\tWRITE_CSR(sc, WXREG_RCTL, 0);\n\t\tDELAY(1 * 1000);\n\t\twx_mwi_unwhack(sc);\n\t}\n\n\t/*\n\t * Clear out the hashed multicast table array.\n\t */\n\tfor (i = 0; i < WX_MC_TAB_SIZE; i++) {\n\t\tWRITE_CSR(sc, WXREG_MTA + (sizeof (u_int32_t) * 4), 0);\n\t}\n\tif (sc->wx_dcr & (WXDCR_RFCE|WXDCR_TFCE)) {\n\t\tWRITE_CSR(sc, WXREG_FCAL, FC_FRM_CONST_LO);\n\t\tWRITE_CSR(sc, WXREG_FCAH, FC_FRM_CONST_HI);\n\t\tWRITE_CSR(sc, WXREG_FCT, FC_TYP_CONST);\n\t} else {\n\t\tWRITE_CSR(sc, WXREG_FCAL, 0);\n\t\tWRITE_CSR(sc, WXREG_FCAH, 0);\n\t\tWRITE_CSR(sc, WXREG_FCT, 0);\n\t}\n\tWRITE_CSR(sc, WXREG_FLOW_XTIMER, WX_XTIMER_DFLT);\n\tif (sc->revision == 2) {\n\t\tWRITE_CSR(sc, WXREG_FLOW_RCV_HI, 0);\n\t\tWRITE_CSR(sc, WXREG_FLOW_RCV_LO, 0);\n\t} else {\n\t\tWRITE_CSR(sc, WXREG_FLOW_RCV_HI, WX_RCV_FLOW_HI_DFLT);\n\t\tWRITE_CSR(sc, WXREG_FLOW_RCV_LO, WX_RCV_FLOW_LO_DFLT);\n\t}\n\tWRITE_CSR(sc, WXREG_XMIT_CFGW, WXTXCW_DEFAULT);\n\tWRITE_CSR(sc, WXREG_DCR, sc->wx_dcr);\n\tDELAY(50 * 1000);\n\n\t/*\n\t * The pin stuff is all FM from the Linux driver.\n\t */\n\tif ((READ_CSR(sc, WXREG_DCR) & WXDCR_SWDPIN1) == 0) {\n\t\tfor (i = 0; i < 500; i++) {\n\t\t\tDELAY(10 * 1000);\n\t\t\tif (READ_CSR(sc, WXREG_DSR) & WXDSR_LU) {\n\t\t\t\tsc->linkup = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tprintf(\"%s: swdpio did not clear\\n\", sc->wx_name);\n\t\treturn (-1);\n\t}\n\tif (sc->linkup == 0) {\n\t\tprintf(\"%s: link never came up\\n\", sc->wx_name);\n\t\treturn (-1);\n\t}\n\tsc->wx_ienable = WXIENABLE_DEFAULT;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic int wx_ifmedia_upd;\nstatic int wx_init;\nstatic int wx_hw_initialize;\nstatic void wx_stop;\nstatic int wx_get_rbuf;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic void wx_stats_update;\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic int\nwx_init(xsc)\n\tvoid *xsc;\n{\n\tstruct ifmedia *ifm;\n\twx_softc_t *sc = xsc;\n\tstruct ifnet *ifp = &sc->wx_if;\n\trxpkt_t *rxpkt;\n\twxrd_t *rd;\n\tsize_t len;\n\tint s, i, bflags;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel any pending I/O by resetting things.\n\t * wx_stop will free any allocated mbufs.\n\t */\n\twx_stop(sc);\n\n\t/*\n\t * Reset the hardware. All network addresses loaded here, but\n\t * neither the receiver nor the transmitter are enabled.\n\t */\n\n\tif (wx_hw_initialize(sc)) {\n\t\treturn (EIO);\n\t}\n\n\t/*\n\t * Set up the receive ring stuff.\n\t */\n\tlen = sizeof (wxrd_t) * WX_MAX_RDESC;\n\tbzero(sc->rdescriptors, len);\n\tfor (rxpkt = sc->rbase, i = 0; rxpkt != NULL && i < WX_MAX_RDESC;\n\t    i += RXINCR, rxpkt++) {\n\t\trd = &sc->rdescriptors[i];\n\t\tif (wx_get_rbuf(sc, rxpkt)) {\n\t\t\tbreak;\n\t\t}\n\t\trd->address.lowpart = rxpkt->dma_addr + WX_RX_OFFSET_VALUE;\n\t}\n\tif (i != WX_MAX_RDESC) {\n\t\tprintf(\"%s: could not set up rbufs\\n\", sc->wx_name);\n\t\twx_stop(sc);\n\t\treturn (ENOMEM);\n\t}\n\n\t/*\n\t * Set up transmit parameters and enable the transmitter.\n\t */\n\tsc->tnxtfree = sc->tactive = 0;\n\tsc->tbsyf = sc->tbsyl = NULL;\n\tWRITE_CSR(sc, WXREG_TCTL, 0);\n\tDELAY(5 * 1000);\n\tWRITE_CSR(sc, WXREG_TDBA_LO,\n\t\tvtophys((vm_offset_t)&sc->tdescriptors[0]));\n\tWRITE_CSR(sc, WXREG_TDBA_HI, 0);\n\tWRITE_CSR(sc, WXREG_TDLEN, WX_MAX_TDESC * sizeof (wxtd_t));\n\tWRITE_CSR(sc, WXREG_TDH, 0);\n\tWRITE_CSR(sc, WXREG_TDT, 0);\n\tWRITE_CSR(sc, WXREG_TQSA_HI, 0);\n\tWRITE_CSR(sc, WXREG_TQSA_LO, 0);\n\tWRITE_CSR(sc, WXREG_TIPG, WX_TIPG_DFLT);\n\tWRITE_CSR(sc, WXREG_TIDV, sc->wx_txint_delay);\n\tWRITE_CSR(sc, WXREG_TCTL, (WXTCTL_CT(WX_COLLISION_THRESHOLD) |\n\t    WXTCTL_COLD(WX_FDX_COLLISION_DX) | WXTCTL_EN));\n\t/*\n\t * Set up receive parameters and enable the receiver.\n\t */\n\n\tsc->rnxt = 0;\n\tWRITE_CSR(sc, WXREG_RCTL, 0);\n\tDELAY(5 * 1000);\n\tWRITE_CSR(sc, WXREG_RDTR0, WXRDTR_FPD);\n\tWRITE_CSR(sc, WXREG_RDBA0_LO,\n\t    vtophys((vm_offset_t)&sc->rdescriptors[0]));\n\tWRITE_CSR(sc, WXREG_RDBA0_HI, 0);\n\tWRITE_CSR(sc, WXREG_RDLEN0, WX_MAX_RDESC * sizeof (wxrd_t));\n\tWRITE_CSR(sc, WXREG_RDH0, 0);\n\tWRITE_CSR(sc, WXREG_RDT0, (WX_MAX_RDESC - RXINCR));\n\tWRITE_CSR(sc, WXREG_RDTR1, 0);\n\tWRITE_CSR(sc, WXREG_RDBA1_LO, 0);\n\tWRITE_CSR(sc, WXREG_RDBA1_HI, 0);\n\tWRITE_CSR(sc, WXREG_RDLEN1, 0);\n\tWRITE_CSR(sc, WXREG_RDH1, 0);\n\tWRITE_CSR(sc, WXREG_RDT1, 0);\n\n\tif (ifp->if_mtu > ETHERMTU) {\n\t\tprintf(\"%s: enabling for jumbo packets\\n\", sc->wx_name);\n\t\tbflags = WXRCTL_EN | WXRCTL_LPE | WXRCTL_2KRBUF;\n\t} else {\n\t\tbflags = WXRCTL_EN | WXRCTL_2KRBUF;\n\t}\n\n\tWRITE_CSR(sc, WXREG_RCTL, bflags |\n\t    ((ifp->if_flags & IFF_BROADCAST) ? WXRCTL_BAM : 0) |\n\t    ((ifp->if_flags & IFF_PROMISC) ? WXRCTL_UPE : 0) |\n\t    ((sc->all_mcasts) ? WXRCTL_MPE : 0));\n\n\t/*\n\t * Enable Interrupts\n\t */\n\tWX_ENABLE_INT(sc);\n\n\t/*\n\t * Mark that we're up and running...\n\t */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tifm = &sc->wx_media;\n\ti = ifm->ifm_media;\n\tifm->ifm_media = ifm->ifm_cur->ifm_media;\n\twx_ifmedia_upd(ifp);\n\tifm->ifm_media = i;\n\tsplx(s);\n\n\t/*\n\t * Start stats updater.\n\t */\n\tTIMEOUT(sc, wx_stats_update, sc, hz);\n\n\t/*\n\t * And we're outta here...\n\t */\n\treturn (0);\n}"
  },
  {
    "function_name": "wx_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "1695-1706",
    "snippet": "static void\nwx_watchdog(ifp)\n\tstruct ifnet *ifp;\n{\n\twx_softc_t *sc = SOFTC_IFP(ifp);\n\tprintf(\"%s: device timeout\\n\", sc->wx_name);\n\tifp->if_oerrors++;\n\tif (wx_init(sc)) {\n\t\tprintf(\"%s: could not re-init device\\n\", sc->wx_name);\n\t\tVTIMEOUT(sc, (void (*)(void *))wx_init, sc, hz);\n\t}\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int wx_init",
      "static void wx_watchdog",
      "wx_eeprom_sibits __P((wx_softc_t *));",
      "wx_eeprom_cleanup __P((wx_softc_t *));",
      "wx_read_eeprom_word __P((wx_softc_t *, int));",
      "wx_mwi_whackon\t__P((wx_softc_t *));",
      "wx_mwi_unwhack\t__P((wx_softc_t *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VTIMEOUT",
          "args": [
            "sc",
            "(void (*)(void *))wx_init",
            "sc",
            "hz"
          ],
          "line": 1704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: could not re-init device\\n\"",
            "sc->wx_name"
          ],
          "line": 1703
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wx_init",
          "args": [
            "sc"
          ],
          "line": 1702
        },
        "resolved": true,
        "details": {
          "function_name": "wx_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "1708-1835",
          "snippet": "static int\nwx_init(xsc)\n\tvoid *xsc;\n{\n\tstruct ifmedia *ifm;\n\twx_softc_t *sc = xsc;\n\tstruct ifnet *ifp = &sc->wx_if;\n\trxpkt_t *rxpkt;\n\twxrd_t *rd;\n\tsize_t len;\n\tint s, i, bflags;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel any pending I/O by resetting things.\n\t * wx_stop will free any allocated mbufs.\n\t */\n\twx_stop(sc);\n\n\t/*\n\t * Reset the hardware. All network addresses loaded here, but\n\t * neither the receiver nor the transmitter are enabled.\n\t */\n\n\tif (wx_hw_initialize(sc)) {\n\t\treturn (EIO);\n\t}\n\n\t/*\n\t * Set up the receive ring stuff.\n\t */\n\tlen = sizeof (wxrd_t) * WX_MAX_RDESC;\n\tbzero(sc->rdescriptors, len);\n\tfor (rxpkt = sc->rbase, i = 0; rxpkt != NULL && i < WX_MAX_RDESC;\n\t    i += RXINCR, rxpkt++) {\n\t\trd = &sc->rdescriptors[i];\n\t\tif (wx_get_rbuf(sc, rxpkt)) {\n\t\t\tbreak;\n\t\t}\n\t\trd->address.lowpart = rxpkt->dma_addr + WX_RX_OFFSET_VALUE;\n\t}\n\tif (i != WX_MAX_RDESC) {\n\t\tprintf(\"%s: could not set up rbufs\\n\", sc->wx_name);\n\t\twx_stop(sc);\n\t\treturn (ENOMEM);\n\t}\n\n\t/*\n\t * Set up transmit parameters and enable the transmitter.\n\t */\n\tsc->tnxtfree = sc->tactive = 0;\n\tsc->tbsyf = sc->tbsyl = NULL;\n\tWRITE_CSR(sc, WXREG_TCTL, 0);\n\tDELAY(5 * 1000);\n\tWRITE_CSR(sc, WXREG_TDBA_LO,\n\t\tvtophys((vm_offset_t)&sc->tdescriptors[0]));\n\tWRITE_CSR(sc, WXREG_TDBA_HI, 0);\n\tWRITE_CSR(sc, WXREG_TDLEN, WX_MAX_TDESC * sizeof (wxtd_t));\n\tWRITE_CSR(sc, WXREG_TDH, 0);\n\tWRITE_CSR(sc, WXREG_TDT, 0);\n\tWRITE_CSR(sc, WXREG_TQSA_HI, 0);\n\tWRITE_CSR(sc, WXREG_TQSA_LO, 0);\n\tWRITE_CSR(sc, WXREG_TIPG, WX_TIPG_DFLT);\n\tWRITE_CSR(sc, WXREG_TIDV, sc->wx_txint_delay);\n\tWRITE_CSR(sc, WXREG_TCTL, (WXTCTL_CT(WX_COLLISION_THRESHOLD) |\n\t    WXTCTL_COLD(WX_FDX_COLLISION_DX) | WXTCTL_EN));\n\t/*\n\t * Set up receive parameters and enable the receiver.\n\t */\n\n\tsc->rnxt = 0;\n\tWRITE_CSR(sc, WXREG_RCTL, 0);\n\tDELAY(5 * 1000);\n\tWRITE_CSR(sc, WXREG_RDTR0, WXRDTR_FPD);\n\tWRITE_CSR(sc, WXREG_RDBA0_LO,\n\t    vtophys((vm_offset_t)&sc->rdescriptors[0]));\n\tWRITE_CSR(sc, WXREG_RDBA0_HI, 0);\n\tWRITE_CSR(sc, WXREG_RDLEN0, WX_MAX_RDESC * sizeof (wxrd_t));\n\tWRITE_CSR(sc, WXREG_RDH0, 0);\n\tWRITE_CSR(sc, WXREG_RDT0, (WX_MAX_RDESC - RXINCR));\n\tWRITE_CSR(sc, WXREG_RDTR1, 0);\n\tWRITE_CSR(sc, WXREG_RDBA1_LO, 0);\n\tWRITE_CSR(sc, WXREG_RDBA1_HI, 0);\n\tWRITE_CSR(sc, WXREG_RDLEN1, 0);\n\tWRITE_CSR(sc, WXREG_RDH1, 0);\n\tWRITE_CSR(sc, WXREG_RDT1, 0);\n\n\tif (ifp->if_mtu > ETHERMTU) {\n\t\tprintf(\"%s: enabling for jumbo packets\\n\", sc->wx_name);\n\t\tbflags = WXRCTL_EN | WXRCTL_LPE | WXRCTL_2KRBUF;\n\t} else {\n\t\tbflags = WXRCTL_EN | WXRCTL_2KRBUF;\n\t}\n\n\tWRITE_CSR(sc, WXREG_RCTL, bflags |\n\t    ((ifp->if_flags & IFF_BROADCAST) ? WXRCTL_BAM : 0) |\n\t    ((ifp->if_flags & IFF_PROMISC) ? WXRCTL_UPE : 0) |\n\t    ((sc->all_mcasts) ? WXRCTL_MPE : 0));\n\n\t/*\n\t * Enable Interrupts\n\t */\n\tWX_ENABLE_INT(sc);\n\n\t/*\n\t * Mark that we're up and running...\n\t */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tifm = &sc->wx_media;\n\ti = ifm->ifm_media;\n\tifm->ifm_media = ifm->ifm_cur->ifm_media;\n\twx_ifmedia_upd(ifp);\n\tifm->ifm_media = i;\n\tsplx(s);\n\n\t/*\n\t * Start stats updater.\n\t */\n\tTIMEOUT(sc, wx_stats_update, sc, hz);\n\n\t/*\n\t * And we're outta here...\n\t */\n\treturn (0);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int wx_ifmedia_upd",
            "static int wx_init",
            "static int wx_hw_initialize",
            "static void wx_stop",
            "static int wx_get_rbuf",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "static void wx_stats_update",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic int wx_ifmedia_upd;\nstatic int wx_init;\nstatic int wx_hw_initialize;\nstatic void wx_stop;\nstatic int wx_get_rbuf;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic void wx_stats_update;\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic int\nwx_init(xsc)\n\tvoid *xsc;\n{\n\tstruct ifmedia *ifm;\n\twx_softc_t *sc = xsc;\n\tstruct ifnet *ifp = &sc->wx_if;\n\trxpkt_t *rxpkt;\n\twxrd_t *rd;\n\tsize_t len;\n\tint s, i, bflags;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel any pending I/O by resetting things.\n\t * wx_stop will free any allocated mbufs.\n\t */\n\twx_stop(sc);\n\n\t/*\n\t * Reset the hardware. All network addresses loaded here, but\n\t * neither the receiver nor the transmitter are enabled.\n\t */\n\n\tif (wx_hw_initialize(sc)) {\n\t\treturn (EIO);\n\t}\n\n\t/*\n\t * Set up the receive ring stuff.\n\t */\n\tlen = sizeof (wxrd_t) * WX_MAX_RDESC;\n\tbzero(sc->rdescriptors, len);\n\tfor (rxpkt = sc->rbase, i = 0; rxpkt != NULL && i < WX_MAX_RDESC;\n\t    i += RXINCR, rxpkt++) {\n\t\trd = &sc->rdescriptors[i];\n\t\tif (wx_get_rbuf(sc, rxpkt)) {\n\t\t\tbreak;\n\t\t}\n\t\trd->address.lowpart = rxpkt->dma_addr + WX_RX_OFFSET_VALUE;\n\t}\n\tif (i != WX_MAX_RDESC) {\n\t\tprintf(\"%s: could not set up rbufs\\n\", sc->wx_name);\n\t\twx_stop(sc);\n\t\treturn (ENOMEM);\n\t}\n\n\t/*\n\t * Set up transmit parameters and enable the transmitter.\n\t */\n\tsc->tnxtfree = sc->tactive = 0;\n\tsc->tbsyf = sc->tbsyl = NULL;\n\tWRITE_CSR(sc, WXREG_TCTL, 0);\n\tDELAY(5 * 1000);\n\tWRITE_CSR(sc, WXREG_TDBA_LO,\n\t\tvtophys((vm_offset_t)&sc->tdescriptors[0]));\n\tWRITE_CSR(sc, WXREG_TDBA_HI, 0);\n\tWRITE_CSR(sc, WXREG_TDLEN, WX_MAX_TDESC * sizeof (wxtd_t));\n\tWRITE_CSR(sc, WXREG_TDH, 0);\n\tWRITE_CSR(sc, WXREG_TDT, 0);\n\tWRITE_CSR(sc, WXREG_TQSA_HI, 0);\n\tWRITE_CSR(sc, WXREG_TQSA_LO, 0);\n\tWRITE_CSR(sc, WXREG_TIPG, WX_TIPG_DFLT);\n\tWRITE_CSR(sc, WXREG_TIDV, sc->wx_txint_delay);\n\tWRITE_CSR(sc, WXREG_TCTL, (WXTCTL_CT(WX_COLLISION_THRESHOLD) |\n\t    WXTCTL_COLD(WX_FDX_COLLISION_DX) | WXTCTL_EN));\n\t/*\n\t * Set up receive parameters and enable the receiver.\n\t */\n\n\tsc->rnxt = 0;\n\tWRITE_CSR(sc, WXREG_RCTL, 0);\n\tDELAY(5 * 1000);\n\tWRITE_CSR(sc, WXREG_RDTR0, WXRDTR_FPD);\n\tWRITE_CSR(sc, WXREG_RDBA0_LO,\n\t    vtophys((vm_offset_t)&sc->rdescriptors[0]));\n\tWRITE_CSR(sc, WXREG_RDBA0_HI, 0);\n\tWRITE_CSR(sc, WXREG_RDLEN0, WX_MAX_RDESC * sizeof (wxrd_t));\n\tWRITE_CSR(sc, WXREG_RDH0, 0);\n\tWRITE_CSR(sc, WXREG_RDT0, (WX_MAX_RDESC - RXINCR));\n\tWRITE_CSR(sc, WXREG_RDTR1, 0);\n\tWRITE_CSR(sc, WXREG_RDBA1_LO, 0);\n\tWRITE_CSR(sc, WXREG_RDBA1_HI, 0);\n\tWRITE_CSR(sc, WXREG_RDLEN1, 0);\n\tWRITE_CSR(sc, WXREG_RDH1, 0);\n\tWRITE_CSR(sc, WXREG_RDT1, 0);\n\n\tif (ifp->if_mtu > ETHERMTU) {\n\t\tprintf(\"%s: enabling for jumbo packets\\n\", sc->wx_name);\n\t\tbflags = WXRCTL_EN | WXRCTL_LPE | WXRCTL_2KRBUF;\n\t} else {\n\t\tbflags = WXRCTL_EN | WXRCTL_2KRBUF;\n\t}\n\n\tWRITE_CSR(sc, WXREG_RCTL, bflags |\n\t    ((ifp->if_flags & IFF_BROADCAST) ? WXRCTL_BAM : 0) |\n\t    ((ifp->if_flags & IFF_PROMISC) ? WXRCTL_UPE : 0) |\n\t    ((sc->all_mcasts) ? WXRCTL_MPE : 0));\n\n\t/*\n\t * Enable Interrupts\n\t */\n\tWX_ENABLE_INT(sc);\n\n\t/*\n\t * Mark that we're up and running...\n\t */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tifm = &sc->wx_media;\n\ti = ifm->ifm_media;\n\tifm->ifm_media = ifm->ifm_cur->ifm_media;\n\twx_ifmedia_upd(ifp);\n\tifm->ifm_media = i;\n\tsplx(s);\n\n\t/*\n\t * Start stats updater.\n\t */\n\tTIMEOUT(sc, wx_stats_update, sc, hz);\n\n\t/*\n\t * And we're outta here...\n\t */\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SOFTC_IFP",
          "args": [
            "ifp"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic int wx_init;\nstatic void wx_watchdog;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic void\nwx_watchdog(ifp)\n\tstruct ifnet *ifp;\n{\n\twx_softc_t *sc = SOFTC_IFP(ifp);\n\tprintf(\"%s: device timeout\\n\", sc->wx_name);\n\tifp->if_oerrors++;\n\tif (wx_init(sc)) {\n\t\tprintf(\"%s: could not re-init device\\n\", sc->wx_name);\n\t\tVTIMEOUT(sc, (void (*)(void *))wx_init, sc, hz);\n\t}\n}"
  },
  {
    "function_name": "wx_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "1641-1690",
    "snippet": "static void\nwx_stop(sc)\n\twx_softc_t *sc;\n{\n\ttxpkt_t *txp;\n\trxpkt_t *rxp;\n\tstruct ifnet *ifp = &sc->wx_if;\n\n\t/*\n\t * Cancel stats updater.\n\t */\n\tUNTIMEOUT(wx_stats_update, sc, sc);\n\n\t/*\n\t * Reset the chip\n\t */\n\twx_hw_stop(sc);\n\n\t/*\n\t * Release any xmit buffers.\n\t */\n\tfor (txp = sc->tbase; txp && txp < &sc->tbase[WX_MAX_TDESC]; txp++) {\n\t\tif (txp->dptr) {\n\t\t\tm_free(txp->dptr);\n\t\t\ttxp->dptr = NULL;\n\t\t}\n\t}\n\n\t/*\n\t * Free all the receive buffers.\n\t */\n\tfor (rxp = sc->rbase; rxp && rxp < &sc->rbase[WX_MAX_RDESC]; rxp++) {\n\t\tif (rxp->dptr) {\n\t\t\tm_free(rxp->dptr);\n\t\t\trxp->dptr = NULL;\n\t\t}\n\t}\n\n\tif (sc->rpending) {\n\t\tm_freem(sc->rpending);\n\t\tsc->rpending = NULL;\n\t}\n\n\t/*\n\t * And we're outta here...\n\t */\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\tifp->if_timer = 0;\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wx_hw_stop",
      "static void wx_stop",
      "wx_eeprom_sibits __P((wx_softc_t *));",
      "wx_eeprom_cleanup __P((wx_softc_t *));",
      "wx_read_eeprom_word __P((wx_softc_t *, int));",
      "static void wx_stats_update",
      "wx_mwi_whackon\t__P((wx_softc_t *));",
      "wx_mwi_unwhack\t__P((wx_softc_t *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "sc->rpending"
          ],
          "line": 1680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_free",
          "args": [
            "rxp->dptr"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_pcmcia_mem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "2382-2395",
          "snippet": "STATIC void\npccbb_pcmcia_mem_free(pch, pcmhp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_mem_handle *pcmhp;\n{\n#if rbus\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ph->ph_parent;\n\n\trbus_space_free(sc->sc_rbus_memt, pcmhp->memh, pcmhp->realsize, NULL);\n#else\n\tbus_space_free(pcmhp->memt, pcmhp->memh, pcmhp->realsize);\n#endif\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define STATIC static",
            "#define STATIC"
          ],
          "globals_used": [
            "STATIC int",
            "cb_reset __P((struct pccbb_softc *));",
            "STATIC int",
            "cb_detect_voltage __P((struct pccbb_softc *));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "pccbb_pcmcia_mem_alloc __P((pcmcia_chipset_handle_t, bus_size_t,\n    struct pcmcia_mem_handle *));",
            "STATIC void",
            "pccbb_pcmcia_mem_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_mem_handle *));",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC int",
            "STATIC void",
            "STATIC int",
            "STATIC void",
            "pccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));",
            "STATIC void",
            "pccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));",
            "STATIC void",
            "pccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));",
            "STATIC void",
            "pccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));",
            "STATIC int",
            "pccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));",
            "struct pccbb_softc *sc = psc->cpc_parent;",
            "static void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;",
            "struct pcic_handle *ph = poll->ph;",
            "struct pccbb_softc *sc = ph->sc;",
            "STATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define STATIC static\n#define STATIC\n\nSTATIC int;\ncb_reset __P((struct pccbb_softc *));\nSTATIC int;\ncb_detect_voltage __P((struct pccbb_softc *));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC int;\npccbb_pcmcia_mem_alloc __P((pcmcia_chipset_handle_t, bus_size_t,\n    struct pcmcia_mem_handle *));\nSTATIC void;\npccbb_pcmcia_mem_free __P((pcmcia_chipset_handle_t,\n    struct pcmcia_mem_handle *));\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_mem_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC int;\nSTATIC void;\nSTATIC int;\nSTATIC void;\npccbb_pcmcia_io_unmap __P((pcmcia_chipset_handle_t, int));\nSTATIC void;\npccbb_pcmcia_intr_disestablish __P((pcmcia_chipset_handle_t,\n    void *));\nSTATIC void;\npccbb_pcmcia_socket_enable __P((pcmcia_chipset_handle_t));\nSTATIC void;\npccbb_pcmcia_socket_disable __P((pcmcia_chipset_handle_t));\nSTATIC int;\npccbb_pcmcia_card_detect __P((pcmcia_chipset_handle_t pch));\nstruct pccbb_softc *sc = psc->cpc_parent;\nstatic void *\npccbb_intr_establish(sc, irq, level, func, arg)\n\tstruct pccbb_softc *sc;\nstruct pcic_handle *ph = poll->ph;\nstruct pccbb_softc *sc = ph->sc;\nSTATIC void *\npccbb_pcmcia_intr_establish(pch, pf, ipl, func, arg)\n\tpcmcia_chipset_handle_t pch;\n\nSTATIC void\npccbb_pcmcia_mem_free(pch, pcmhp)\n\tpcmcia_chipset_handle_t pch;\n\tstruct pcmcia_mem_handle *pcmhp;\n{\n#if rbus\n\tstruct pcic_handle *ph = (struct pcic_handle *)pch;\n\tstruct pccbb_softc *sc = (struct pccbb_softc *)ph->ph_parent;\n\n\trbus_space_free(sc->sc_rbus_memt, pcmhp->memh, pcmhp->realsize, NULL);\n#else\n\tbus_space_free(pcmhp->memt, pcmhp->memh, pcmhp->realsize);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "wx_hw_stop",
          "args": [
            "sc"
          ],
          "line": 1657
        },
        "resolved": true,
        "details": {
          "function_name": "wx_hw_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "1515-1531",
          "snippet": "static void\nwx_hw_stop(sc)\n\twx_softc_t *sc;\n{\n\tu_int32_t icr;\n\tif (sc->revision == 2) {\n\t\twx_mwi_whackon(sc);\n\t}\n\tWRITE_CSR(sc, WXREG_DCR, WXDCR_RST);\n\tDELAY(20 * 1000);\n\tWRITE_CSR(sc, WXREG_IMASK, ~0);\n\ticr = READ_CSR(sc, WXREG_ICR);\n\tif (sc->revision == 2) {\n\t\twx_mwi_unwhack(sc);\n\t}\n\tWX_DISABLE_INT(sc);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wx_hw_stop",
            "wx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));",
            "wx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic void wx_hw_stop;\nwx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));\nwx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic void\nwx_hw_stop(sc)\n\twx_softc_t *sc;\n{\n\tu_int32_t icr;\n\tif (sc->revision == 2) {\n\t\twx_mwi_whackon(sc);\n\t}\n\tWRITE_CSR(sc, WXREG_DCR, WXDCR_RST);\n\tDELAY(20 * 1000);\n\tWRITE_CSR(sc, WXREG_IMASK, ~0);\n\ticr = READ_CSR(sc, WXREG_ICR);\n\tif (sc->revision == 2) {\n\t\twx_mwi_unwhack(sc);\n\t}\n\tWX_DISABLE_INT(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UNTIMEOUT",
          "args": [
            "wx_stats_update",
            "sc",
            "sc"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic void wx_hw_stop;\nstatic void wx_stop;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic void wx_stats_update;\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic void\nwx_stop(sc)\n\twx_softc_t *sc;\n{\n\ttxpkt_t *txp;\n\trxpkt_t *rxp;\n\tstruct ifnet *ifp = &sc->wx_if;\n\n\t/*\n\t * Cancel stats updater.\n\t */\n\tUNTIMEOUT(wx_stats_update, sc, sc);\n\n\t/*\n\t * Reset the chip\n\t */\n\twx_hw_stop(sc);\n\n\t/*\n\t * Release any xmit buffers.\n\t */\n\tfor (txp = sc->tbase; txp && txp < &sc->tbase[WX_MAX_TDESC]; txp++) {\n\t\tif (txp->dptr) {\n\t\t\tm_free(txp->dptr);\n\t\t\ttxp->dptr = NULL;\n\t\t}\n\t}\n\n\t/*\n\t * Free all the receive buffers.\n\t */\n\tfor (rxp = sc->rbase; rxp && rxp < &sc->rbase[WX_MAX_RDESC]; rxp++) {\n\t\tif (rxp->dptr) {\n\t\t\tm_free(rxp->dptr);\n\t\t\trxp->dptr = NULL;\n\t\t}\n\t}\n\n\tif (sc->rpending) {\n\t\tm_freem(sc->rpending);\n\t\tsc->rpending = NULL;\n\t}\n\n\t/*\n\t * And we're outta here...\n\t */\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\tifp->if_timer = 0;\n}"
  },
  {
    "function_name": "wx_hw_initialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "1547-1636",
    "snippet": "static int\nwx_hw_initialize(sc)\n\twx_softc_t *sc;\n{\n\tint i;\n\n\tWRITE_CSR(sc, WXREG_VET, 0);\n\tfor (i = 0; i < (WX_VLAN_TAB_SIZE << 2); i += 4) {\n\t\tWRITE_CSR(sc, (WXREG_VFTA + i), 0);\n\t}\n\tif (sc->revision == 2) {\n\t\twx_mwi_whackon(sc);\n\t\tWRITE_CSR(sc, WXREG_RCTL, WXRCTL_RST);\n\t\tDELAY(5 * 1000);\n\t}\n\t/*\n\t * Load the first receiver address with our MAC address,\n\t * and load as many multicast addresses as can fit into\n\t * the receive address array.\n\t */\n\twx_set_addr(sc, 0, sc->wx_enaddr);\n\tfor (i = 1; i <= sc->wx_nmca; i++) {\n\t\tif (i >= WX_RAL_TAB_SIZE) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\twx_set_addr(sc, i, sc->wx_mcaddr[i-1]);\n\t\t}\n\t}\n\n\twhile (i < WX_RAL_TAB_SIZE) {\n\t\tWRITE_CSR(sc, WXREG_RAL_LO(i), 0);\n\t\tWRITE_CSR(sc, WXREG_RAL_HI(i), 0);\n\t\ti++;\n\t}\n\n\tif (sc->revision == 2) {\n\t\tWRITE_CSR(sc, WXREG_RCTL, 0);\n\t\tDELAY(1 * 1000);\n\t\twx_mwi_unwhack(sc);\n\t}\n\n\t/*\n\t * Clear out the hashed multicast table array.\n\t */\n\tfor (i = 0; i < WX_MC_TAB_SIZE; i++) {\n\t\tWRITE_CSR(sc, WXREG_MTA + (sizeof (u_int32_t) * 4), 0);\n\t}\n\tif (sc->wx_dcr & (WXDCR_RFCE|WXDCR_TFCE)) {\n\t\tWRITE_CSR(sc, WXREG_FCAL, FC_FRM_CONST_LO);\n\t\tWRITE_CSR(sc, WXREG_FCAH, FC_FRM_CONST_HI);\n\t\tWRITE_CSR(sc, WXREG_FCT, FC_TYP_CONST);\n\t} else {\n\t\tWRITE_CSR(sc, WXREG_FCAL, 0);\n\t\tWRITE_CSR(sc, WXREG_FCAH, 0);\n\t\tWRITE_CSR(sc, WXREG_FCT, 0);\n\t}\n\tWRITE_CSR(sc, WXREG_FLOW_XTIMER, WX_XTIMER_DFLT);\n\tif (sc->revision == 2) {\n\t\tWRITE_CSR(sc, WXREG_FLOW_RCV_HI, 0);\n\t\tWRITE_CSR(sc, WXREG_FLOW_RCV_LO, 0);\n\t} else {\n\t\tWRITE_CSR(sc, WXREG_FLOW_RCV_HI, WX_RCV_FLOW_HI_DFLT);\n\t\tWRITE_CSR(sc, WXREG_FLOW_RCV_LO, WX_RCV_FLOW_LO_DFLT);\n\t}\n\tWRITE_CSR(sc, WXREG_XMIT_CFGW, WXTXCW_DEFAULT);\n\tWRITE_CSR(sc, WXREG_DCR, sc->wx_dcr);\n\tDELAY(50 * 1000);\n\n\t/*\n\t * The pin stuff is all FM from the Linux driver.\n\t */\n\tif ((READ_CSR(sc, WXREG_DCR) & WXDCR_SWDPIN1) == 0) {\n\t\tfor (i = 0; i < 500; i++) {\n\t\t\tDELAY(10 * 1000);\n\t\t\tif (READ_CSR(sc, WXREG_DSR) & WXDSR_LU) {\n\t\t\t\tsc->linkup = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tprintf(\"%s: swdpio did not clear\\n\", sc->wx_name);\n\t\treturn (-1);\n\t}\n\tif (sc->linkup == 0) {\n\t\tprintf(\"%s: link never came up\\n\", sc->wx_name);\n\t\treturn (-1);\n\t}\n\tsc->wx_ienable = WXIENABLE_DEFAULT;\n\treturn (0);\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wx_set_addr",
      "static int wx_hw_initialize",
      "wx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));",
      "wx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));",
      "wx_eeprom_sibits __P((wx_softc_t *));",
      "wx_eeprom_cleanup __P((wx_softc_t *));",
      "wx_read_eeprom_word __P((wx_softc_t *, int));",
      "wx_mwi_whackon\t__P((wx_softc_t *));",
      "wx_mwi_unwhack\t__P((wx_softc_t *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: link never came up\\n\"",
            "sc->wx_name"
          ],
          "line": 1631
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_CSR",
          "args": [
            "sc",
            "WXREG_DSR"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10 * 1000"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_CSR",
          "args": [
            "sc",
            "WXREG_DCR"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "50 * 1000"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_DCR",
            "sc->wx_dcr"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_XMIT_CFGW",
            "WXTXCW_DEFAULT"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_FLOW_RCV_LO",
            "WX_RCV_FLOW_LO_DFLT"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_FLOW_RCV_HI",
            "WX_RCV_FLOW_HI_DFLT"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_FLOW_RCV_LO",
            "0"
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_FLOW_RCV_HI",
            "0"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_FLOW_XTIMER",
            "WX_XTIMER_DFLT"
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_FCT",
            "0"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_FCAH",
            "0"
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_FCAL",
            "0"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_FCT",
            "FC_TYP_CONST"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_FCAH",
            "FC_FRM_CONST_HI"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_FCAL",
            "FC_FRM_CONST_LO"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_MTA + (sizeof (u_int32_t) * 4)",
            "0"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wx_mwi_unwhack",
          "args": [
            "sc"
          ],
          "line": 1585
        },
        "resolved": true,
        "details": {
          "function_name": "wx_mwi_unwhack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "700-707",
          "snippet": "static INLINE void\nwx_mwi_unwhack(sc)\n\twx_softc_t *sc;\n{\n\tif (sc->wx_cmdw & MWI) {\n\t\tpci_write_config(sc->w.dev, PCIR_COMMAND, sc->wx_cmdw, 2);\n\t}\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static INLINE void",
            "static INLINE void",
            "static INLINE void",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "static INLINE void",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "static INLINE void",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "static INLINE void",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic INLINE void;\nstatic INLINE void;\nstatic INLINE void;\nwx_eeprom_sibits __P((wx_softc_t *));\nstatic INLINE void;\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic INLINE void;\nwx_mwi_whackon\t__P((wx_softc_t *));\nstatic INLINE void;\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic INLINE void\nwx_mwi_unwhack(sc)\n\twx_softc_t *sc;\n{\n\tif (sc->wx_cmdw & MWI) {\n\t\tpci_write_config(sc->w.dev, PCIR_COMMAND, sc->wx_cmdw, 2);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1 * 1000"
          ],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_RCTL",
            "0"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_RAL_HI(i)",
            "0"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WXREG_RAL_HI",
          "args": [
            "i"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_RAL_LO(i)",
            "0"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WXREG_RAL_LO",
          "args": [
            "i"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wx_set_addr",
          "args": [
            "sc",
            "i",
            "sc->wx_mcaddr[i-1]"
          ],
          "line": 1572
        },
        "resolved": true,
        "details": {
          "function_name": "wx_set_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "1533-1545",
          "snippet": "static void\nwx_set_addr(sc, idx, mac)\n\twx_softc_t *sc;\n\tint idx;\n\tu_int8_t *mac;\n{\n\tu_int32_t t0, t1;\n\tt0 = (mac[0]) | (mac[1] << 8) | (mac[2] << 16) | (mac[3] << 24);\n\tt1 = (mac[4] << 0) | (mac[5] << 8);\n\tt1 |= WX_RAL_AV;\n\tWRITE_CSR(sc, WXREG_RAL_LO(idx), t0);\n\tWRITE_CSR(sc, WXREG_RAL_HI(idx), t1);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wx_set_addr",
            "wx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));",
            "wx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic void wx_set_addr;\nwx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));\nwx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic void\nwx_set_addr(sc, idx, mac)\n\twx_softc_t *sc;\n\tint idx;\n\tu_int8_t *mac;\n{\n\tu_int32_t t0, t1;\n\tt0 = (mac[0]) | (mac[1] << 8) | (mac[2] << 16) | (mac[3] << 24);\n\tt1 = (mac[4] << 0) | (mac[5] << 8);\n\tt1 |= WX_RAL_AV;\n\tWRITE_CSR(sc, WXREG_RAL_LO(idx), t0);\n\tWRITE_CSR(sc, WXREG_RAL_HI(idx), t1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "5 * 1000"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_RCTL",
            "WXRCTL_RST"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wx_mwi_whackon",
          "args": [
            "sc"
          ],
          "line": 1558
        },
        "resolved": true,
        "details": {
          "function_name": "wx_mwi_whackon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "692-698",
          "snippet": "static INLINE void\nwx_mwi_whackon(sc)\n\twx_softc_t *sc;\n{\n\tsc->wx_cmdw = pci_read_config(sc->w.dev, PCIR_COMMAND, 2);\n\tpci_write_config(sc->w.dev, PCIR_COMMAND, sc->wx_cmdw & ~MWI, 2);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static INLINE void",
            "static INLINE void",
            "static INLINE void",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "static INLINE void",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "static INLINE void",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "static INLINE void",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic INLINE void;\nstatic INLINE void;\nstatic INLINE void;\nwx_eeprom_sibits __P((wx_softc_t *));\nstatic INLINE void;\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic INLINE void;\nwx_mwi_whackon\t__P((wx_softc_t *));\nstatic INLINE void;\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic INLINE void\nwx_mwi_whackon(sc)\n\twx_softc_t *sc;\n{\n\tsc->wx_cmdw = pci_read_config(sc->w.dev, PCIR_COMMAND, 2);\n\tpci_write_config(sc->w.dev, PCIR_COMMAND, sc->wx_cmdw & ~MWI, 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "(WXREG_VFTA + i)",
            "0"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_VET",
            "0"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic void wx_set_addr;\nstatic int wx_hw_initialize;\nwx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));\nwx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic int\nwx_hw_initialize(sc)\n\twx_softc_t *sc;\n{\n\tint i;\n\n\tWRITE_CSR(sc, WXREG_VET, 0);\n\tfor (i = 0; i < (WX_VLAN_TAB_SIZE << 2); i += 4) {\n\t\tWRITE_CSR(sc, (WXREG_VFTA + i), 0);\n\t}\n\tif (sc->revision == 2) {\n\t\twx_mwi_whackon(sc);\n\t\tWRITE_CSR(sc, WXREG_RCTL, WXRCTL_RST);\n\t\tDELAY(5 * 1000);\n\t}\n\t/*\n\t * Load the first receiver address with our MAC address,\n\t * and load as many multicast addresses as can fit into\n\t * the receive address array.\n\t */\n\twx_set_addr(sc, 0, sc->wx_enaddr);\n\tfor (i = 1; i <= sc->wx_nmca; i++) {\n\t\tif (i >= WX_RAL_TAB_SIZE) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\twx_set_addr(sc, i, sc->wx_mcaddr[i-1]);\n\t\t}\n\t}\n\n\twhile (i < WX_RAL_TAB_SIZE) {\n\t\tWRITE_CSR(sc, WXREG_RAL_LO(i), 0);\n\t\tWRITE_CSR(sc, WXREG_RAL_HI(i), 0);\n\t\ti++;\n\t}\n\n\tif (sc->revision == 2) {\n\t\tWRITE_CSR(sc, WXREG_RCTL, 0);\n\t\tDELAY(1 * 1000);\n\t\twx_mwi_unwhack(sc);\n\t}\n\n\t/*\n\t * Clear out the hashed multicast table array.\n\t */\n\tfor (i = 0; i < WX_MC_TAB_SIZE; i++) {\n\t\tWRITE_CSR(sc, WXREG_MTA + (sizeof (u_int32_t) * 4), 0);\n\t}\n\tif (sc->wx_dcr & (WXDCR_RFCE|WXDCR_TFCE)) {\n\t\tWRITE_CSR(sc, WXREG_FCAL, FC_FRM_CONST_LO);\n\t\tWRITE_CSR(sc, WXREG_FCAH, FC_FRM_CONST_HI);\n\t\tWRITE_CSR(sc, WXREG_FCT, FC_TYP_CONST);\n\t} else {\n\t\tWRITE_CSR(sc, WXREG_FCAL, 0);\n\t\tWRITE_CSR(sc, WXREG_FCAH, 0);\n\t\tWRITE_CSR(sc, WXREG_FCT, 0);\n\t}\n\tWRITE_CSR(sc, WXREG_FLOW_XTIMER, WX_XTIMER_DFLT);\n\tif (sc->revision == 2) {\n\t\tWRITE_CSR(sc, WXREG_FLOW_RCV_HI, 0);\n\t\tWRITE_CSR(sc, WXREG_FLOW_RCV_LO, 0);\n\t} else {\n\t\tWRITE_CSR(sc, WXREG_FLOW_RCV_HI, WX_RCV_FLOW_HI_DFLT);\n\t\tWRITE_CSR(sc, WXREG_FLOW_RCV_LO, WX_RCV_FLOW_LO_DFLT);\n\t}\n\tWRITE_CSR(sc, WXREG_XMIT_CFGW, WXTXCW_DEFAULT);\n\tWRITE_CSR(sc, WXREG_DCR, sc->wx_dcr);\n\tDELAY(50 * 1000);\n\n\t/*\n\t * The pin stuff is all FM from the Linux driver.\n\t */\n\tif ((READ_CSR(sc, WXREG_DCR) & WXDCR_SWDPIN1) == 0) {\n\t\tfor (i = 0; i < 500; i++) {\n\t\t\tDELAY(10 * 1000);\n\t\t\tif (READ_CSR(sc, WXREG_DSR) & WXDSR_LU) {\n\t\t\t\tsc->linkup = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tprintf(\"%s: swdpio did not clear\\n\", sc->wx_name);\n\t\treturn (-1);\n\t}\n\tif (sc->linkup == 0) {\n\t\tprintf(\"%s: link never came up\\n\", sc->wx_name);\n\t\treturn (-1);\n\t}\n\tsc->wx_ienable = WXIENABLE_DEFAULT;\n\treturn (0);\n}"
  },
  {
    "function_name": "wx_set_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "1533-1545",
    "snippet": "static void\nwx_set_addr(sc, idx, mac)\n\twx_softc_t *sc;\n\tint idx;\n\tu_int8_t *mac;\n{\n\tu_int32_t t0, t1;\n\tt0 = (mac[0]) | (mac[1] << 8) | (mac[2] << 16) | (mac[3] << 24);\n\tt1 = (mac[4] << 0) | (mac[5] << 8);\n\tt1 |= WX_RAL_AV;\n\tWRITE_CSR(sc, WXREG_RAL_LO(idx), t0);\n\tWRITE_CSR(sc, WXREG_RAL_HI(idx), t1);\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wx_set_addr",
      "wx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));",
      "wx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));",
      "wx_eeprom_sibits __P((wx_softc_t *));",
      "wx_eeprom_cleanup __P((wx_softc_t *));",
      "wx_read_eeprom_word __P((wx_softc_t *, int));",
      "wx_mwi_whackon\t__P((wx_softc_t *));",
      "wx_mwi_unwhack\t__P((wx_softc_t *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_RAL_HI(idx)",
            "t1"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WXREG_RAL_HI",
          "args": [
            "idx"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_RAL_LO(idx)",
            "t0"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WXREG_RAL_LO",
          "args": [
            "idx"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic void wx_set_addr;\nwx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));\nwx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic void\nwx_set_addr(sc, idx, mac)\n\twx_softc_t *sc;\n\tint idx;\n\tu_int8_t *mac;\n{\n\tu_int32_t t0, t1;\n\tt0 = (mac[0]) | (mac[1] << 8) | (mac[2] << 16) | (mac[3] << 24);\n\tt1 = (mac[4] << 0) | (mac[5] << 8);\n\tt1 |= WX_RAL_AV;\n\tWRITE_CSR(sc, WXREG_RAL_LO(idx), t0);\n\tWRITE_CSR(sc, WXREG_RAL_HI(idx), t1);\n}"
  },
  {
    "function_name": "wx_hw_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "1515-1531",
    "snippet": "static void\nwx_hw_stop(sc)\n\twx_softc_t *sc;\n{\n\tu_int32_t icr;\n\tif (sc->revision == 2) {\n\t\twx_mwi_whackon(sc);\n\t}\n\tWRITE_CSR(sc, WXREG_DCR, WXDCR_RST);\n\tDELAY(20 * 1000);\n\tWRITE_CSR(sc, WXREG_IMASK, ~0);\n\ticr = READ_CSR(sc, WXREG_ICR);\n\tif (sc->revision == 2) {\n\t\twx_mwi_unwhack(sc);\n\t}\n\tWX_DISABLE_INT(sc);\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wx_hw_stop",
      "wx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));",
      "wx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));",
      "wx_eeprom_sibits __P((wx_softc_t *));",
      "wx_eeprom_cleanup __P((wx_softc_t *));",
      "wx_read_eeprom_word __P((wx_softc_t *, int));",
      "wx_mwi_whackon\t__P((wx_softc_t *));",
      "wx_mwi_unwhack\t__P((wx_softc_t *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WX_DISABLE_INT",
          "args": [
            "sc"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wx_mwi_unwhack",
          "args": [
            "sc"
          ],
          "line": 1528
        },
        "resolved": true,
        "details": {
          "function_name": "wx_mwi_unwhack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "700-707",
          "snippet": "static INLINE void\nwx_mwi_unwhack(sc)\n\twx_softc_t *sc;\n{\n\tif (sc->wx_cmdw & MWI) {\n\t\tpci_write_config(sc->w.dev, PCIR_COMMAND, sc->wx_cmdw, 2);\n\t}\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static INLINE void",
            "static INLINE void",
            "static INLINE void",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "static INLINE void",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "static INLINE void",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "static INLINE void",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic INLINE void;\nstatic INLINE void;\nstatic INLINE void;\nwx_eeprom_sibits __P((wx_softc_t *));\nstatic INLINE void;\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic INLINE void;\nwx_mwi_whackon\t__P((wx_softc_t *));\nstatic INLINE void;\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic INLINE void\nwx_mwi_unwhack(sc)\n\twx_softc_t *sc;\n{\n\tif (sc->wx_cmdw & MWI) {\n\t\tpci_write_config(sc->w.dev, PCIR_COMMAND, sc->wx_cmdw, 2);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_CSR",
          "args": [
            "sc",
            "WXREG_ICR"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_IMASK",
            "~0"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "20 * 1000"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_DCR",
            "WXDCR_RST"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wx_mwi_whackon",
          "args": [
            "sc"
          ],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "wx_mwi_whackon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "692-698",
          "snippet": "static INLINE void\nwx_mwi_whackon(sc)\n\twx_softc_t *sc;\n{\n\tsc->wx_cmdw = pci_read_config(sc->w.dev, PCIR_COMMAND, 2);\n\tpci_write_config(sc->w.dev, PCIR_COMMAND, sc->wx_cmdw & ~MWI, 2);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static INLINE void",
            "static INLINE void",
            "static INLINE void",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "static INLINE void",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "static INLINE void",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "static INLINE void",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic INLINE void;\nstatic INLINE void;\nstatic INLINE void;\nwx_eeprom_sibits __P((wx_softc_t *));\nstatic INLINE void;\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic INLINE void;\nwx_mwi_whackon\t__P((wx_softc_t *));\nstatic INLINE void;\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic INLINE void\nwx_mwi_whackon(sc)\n\twx_softc_t *sc;\n{\n\tsc->wx_cmdw = pci_read_config(sc->w.dev, PCIR_COMMAND, 2);\n\tpci_write_config(sc->w.dev, PCIR_COMMAND, sc->wx_cmdw & ~MWI, 2);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic void wx_hw_stop;\nwx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));\nwx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic void\nwx_hw_stop(sc)\n\twx_softc_t *sc;\n{\n\tu_int32_t icr;\n\tif (sc->revision == 2) {\n\t\twx_mwi_whackon(sc);\n\t}\n\tWRITE_CSR(sc, WXREG_DCR, WXDCR_RST);\n\tDELAY(20 * 1000);\n\tWRITE_CSR(sc, WXREG_IMASK, ~0);\n\ticr = READ_CSR(sc, WXREG_ICR);\n\tif (sc->revision == 2) {\n\t\twx_mwi_unwhack(sc);\n\t}\n\tWX_DISABLE_INT(sc);\n}"
  },
  {
    "function_name": "wx_stats_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "1495-1510",
    "snippet": "static void\nwx_stats_update(arg)\n\tvoid *arg;\n{\n\twx_softc_t *sc = arg;\n\tint s;\n\n\ts = splimp();\n\twx_gc(sc);\n\tsplx(s);\n\n\t/*\n\t * Schedule another timeout one second from now.\n\t */\n\tTIMEOUT(sc, wx_stats_update, sc, hz);\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wx_gc",
      "wx_eeprom_sibits __P((wx_softc_t *));",
      "wx_eeprom_cleanup __P((wx_softc_t *));",
      "wx_read_eeprom_word __P((wx_softc_t *, int));",
      "static void wx_stats_update",
      "wx_mwi_whackon\t__P((wx_softc_t *));",
      "wx_mwi_unwhack\t__P((wx_softc_t *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TIMEOUT",
          "args": [
            "sc",
            "wx_stats_update",
            "sc",
            "hz"
          ],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wx_gc",
          "args": [
            "sc"
          ],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "wx_gc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "1402-1490",
          "snippet": "static void\nwx_gc(sc)\n\twx_softc_t *sc;\n{\n\tstruct ifnet *ifp = &sc->wx_if;\n\ttxpkt_t *txpkt = sc->tbsyf;\n\tu_int32_t tdh = READ_CSR(sc, WXREG_TDH);\n\tint s;\n\n\ts = splimp();\n\twhile (txpkt != NULL) {\n\t\tu_int32_t end = txpkt->eidx, cidx = tdh;\n\n\t\t/*\n\t\t * Normalize start..end indices to 2 *\n\t \t * WX_MAX_TDESC range to eliminate wrap.\n\t\t */\n\t\tif (txpkt->eidx < txpkt->sidx) {\n\t\t\tend += WX_MAX_TDESC;\n\t\t}\n\n\t\t/*\n\t\t * Normalize current chip index to 2 *\n\t \t * WX_MAX_TDESC range to eliminate wrap.\n\t\t */\n\t\tif (cidx < txpkt->sidx) {\n\t\t\tcidx += WX_MAX_TDESC;\n\t\t}\n\n\t\t/*\n\t\t * If the current chip index is between low and\n\t\t * high indices for this packet, it's not finished\n\t\t * transmitting yet. Because transmits are done FIFO,\n\t\t * this means we're done garbage collecting too.\n\t\t */\n\n\t\tif (txpkt->sidx <= cidx && cidx < txpkt->eidx) {\n\t\t\tif (sc->wx_debug) {\n\t\t\t\tprintf(\"%s: TXGC %d..%d TDH %d\\n\", sc->wx_name,\n\t\t\t\t    txpkt->sidx, txpkt->eidx, tdh);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tifp->if_opackets++;\n\n\t\tif (txpkt->dptr) {\n\t\t\t(void) m_freem(txpkt->dptr);\n\t\t} else {\n\t\t\tprintf(\"%s: null mbuf in gc\\n\", sc->wx_name);\n\t\t}\n\n\t\tfor (cidx = txpkt->sidx; cidx != txpkt->eidx;\n\t\t    cidx = T_NXT_IDX(cidx)) {\n\t\t\ttxpkt_t *tmp;\n\t\t\twxtd_t *td;\n\n\t\t\ttd = &sc->tdescriptors[cidx];\n\t\t\tif (td->status & TXSTS_EC) {\n\t\t\t\tprintf(\"%s: excess collisions\\n\", sc->wx_name);\n\t\t\t\tifp->if_collisions++;\n\t\t\t\tifp->if_oerrors++;\n\t\t\t}\n\t\t\tif (td->status & TXSTS_LC) {\n\t\t\t\tprintf(\"%s: lost carrier\\n\", sc->wx_name);\n\t\t\t\tifp->if_oerrors++;\n\t\t\t}\n\t\t\ttmp = &sc->tbase[cidx];\n\t\t\tif (sc->wx_debug) {\n\t\t\t\tprintf(\"%s: TXGC[%d] %p %d..%d done nact %d \"\n\t\t\t\t    \"TDH %d\\n\", sc->wx_name, cidx, tmp->dptr,\n\t\t\t\t    txpkt->sidx, txpkt->eidx, sc->tactive, tdh);\n\t\t\t}\n\t\t\ttmp->dptr = NULL;\n\t\t\tif (sc->tactive == 0) {\n\t\t\t\tprintf(\"%s: nactive < 0?\\n\", sc->wx_name);\n\t\t\t} else {\n\t\t\t\tsc->tactive -= 1;\n\t\t\t}\n\t\t\tbzero(td, sizeof (*td));\n\t\t}\n\t\tsc->tbsyf = txpkt->next;\n\t\ttxpkt = sc->tbsyf;\n\t}\n\tif (sc->tactive < WX_MAX_TDESC) {\n\t\tifp->if_timer = 0;\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t}\n\tsplx(s);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wx_gc",
            "wx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));",
            "wx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic void wx_gc;\nwx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));\nwx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic void\nwx_gc(sc)\n\twx_softc_t *sc;\n{\n\tstruct ifnet *ifp = &sc->wx_if;\n\ttxpkt_t *txpkt = sc->tbsyf;\n\tu_int32_t tdh = READ_CSR(sc, WXREG_TDH);\n\tint s;\n\n\ts = splimp();\n\twhile (txpkt != NULL) {\n\t\tu_int32_t end = txpkt->eidx, cidx = tdh;\n\n\t\t/*\n\t\t * Normalize start..end indices to 2 *\n\t \t * WX_MAX_TDESC range to eliminate wrap.\n\t\t */\n\t\tif (txpkt->eidx < txpkt->sidx) {\n\t\t\tend += WX_MAX_TDESC;\n\t\t}\n\n\t\t/*\n\t\t * Normalize current chip index to 2 *\n\t \t * WX_MAX_TDESC range to eliminate wrap.\n\t\t */\n\t\tif (cidx < txpkt->sidx) {\n\t\t\tcidx += WX_MAX_TDESC;\n\t\t}\n\n\t\t/*\n\t\t * If the current chip index is between low and\n\t\t * high indices for this packet, it's not finished\n\t\t * transmitting yet. Because transmits are done FIFO,\n\t\t * this means we're done garbage collecting too.\n\t\t */\n\n\t\tif (txpkt->sidx <= cidx && cidx < txpkt->eidx) {\n\t\t\tif (sc->wx_debug) {\n\t\t\t\tprintf(\"%s: TXGC %d..%d TDH %d\\n\", sc->wx_name,\n\t\t\t\t    txpkt->sidx, txpkt->eidx, tdh);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tifp->if_opackets++;\n\n\t\tif (txpkt->dptr) {\n\t\t\t(void) m_freem(txpkt->dptr);\n\t\t} else {\n\t\t\tprintf(\"%s: null mbuf in gc\\n\", sc->wx_name);\n\t\t}\n\n\t\tfor (cidx = txpkt->sidx; cidx != txpkt->eidx;\n\t\t    cidx = T_NXT_IDX(cidx)) {\n\t\t\ttxpkt_t *tmp;\n\t\t\twxtd_t *td;\n\n\t\t\ttd = &sc->tdescriptors[cidx];\n\t\t\tif (td->status & TXSTS_EC) {\n\t\t\t\tprintf(\"%s: excess collisions\\n\", sc->wx_name);\n\t\t\t\tifp->if_collisions++;\n\t\t\t\tifp->if_oerrors++;\n\t\t\t}\n\t\t\tif (td->status & TXSTS_LC) {\n\t\t\t\tprintf(\"%s: lost carrier\\n\", sc->wx_name);\n\t\t\t\tifp->if_oerrors++;\n\t\t\t}\n\t\t\ttmp = &sc->tbase[cidx];\n\t\t\tif (sc->wx_debug) {\n\t\t\t\tprintf(\"%s: TXGC[%d] %p %d..%d done nact %d \"\n\t\t\t\t    \"TDH %d\\n\", sc->wx_name, cidx, tmp->dptr,\n\t\t\t\t    txpkt->sidx, txpkt->eidx, sc->tactive, tdh);\n\t\t\t}\n\t\t\ttmp->dptr = NULL;\n\t\t\tif (sc->tactive == 0) {\n\t\t\t\tprintf(\"%s: nactive < 0?\\n\", sc->wx_name);\n\t\t\t} else {\n\t\t\t\tsc->tactive -= 1;\n\t\t\t}\n\t\t\tbzero(td, sizeof (*td));\n\t\t}\n\t\tsc->tbsyf = txpkt->next;\n\t\ttxpkt = sc->tbsyf;\n\t}\n\tif (sc->tactive < WX_MAX_TDESC) {\n\t\tifp->if_timer = 0;\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t}\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic void wx_gc;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic void wx_stats_update;\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic void\nwx_stats_update(arg)\n\tvoid *arg;\n{\n\twx_softc_t *sc = arg;\n\tint s;\n\n\ts = splimp();\n\twx_gc(sc);\n\tsplx(s);\n\n\t/*\n\t * Schedule another timeout one second from now.\n\t */\n\tTIMEOUT(sc, wx_stats_update, sc, hz);\n}"
  },
  {
    "function_name": "wx_gc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "1402-1490",
    "snippet": "static void\nwx_gc(sc)\n\twx_softc_t *sc;\n{\n\tstruct ifnet *ifp = &sc->wx_if;\n\ttxpkt_t *txpkt = sc->tbsyf;\n\tu_int32_t tdh = READ_CSR(sc, WXREG_TDH);\n\tint s;\n\n\ts = splimp();\n\twhile (txpkt != NULL) {\n\t\tu_int32_t end = txpkt->eidx, cidx = tdh;\n\n\t\t/*\n\t\t * Normalize start..end indices to 2 *\n\t \t * WX_MAX_TDESC range to eliminate wrap.\n\t\t */\n\t\tif (txpkt->eidx < txpkt->sidx) {\n\t\t\tend += WX_MAX_TDESC;\n\t\t}\n\n\t\t/*\n\t\t * Normalize current chip index to 2 *\n\t \t * WX_MAX_TDESC range to eliminate wrap.\n\t\t */\n\t\tif (cidx < txpkt->sidx) {\n\t\t\tcidx += WX_MAX_TDESC;\n\t\t}\n\n\t\t/*\n\t\t * If the current chip index is between low and\n\t\t * high indices for this packet, it's not finished\n\t\t * transmitting yet. Because transmits are done FIFO,\n\t\t * this means we're done garbage collecting too.\n\t\t */\n\n\t\tif (txpkt->sidx <= cidx && cidx < txpkt->eidx) {\n\t\t\tif (sc->wx_debug) {\n\t\t\t\tprintf(\"%s: TXGC %d..%d TDH %d\\n\", sc->wx_name,\n\t\t\t\t    txpkt->sidx, txpkt->eidx, tdh);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tifp->if_opackets++;\n\n\t\tif (txpkt->dptr) {\n\t\t\t(void) m_freem(txpkt->dptr);\n\t\t} else {\n\t\t\tprintf(\"%s: null mbuf in gc\\n\", sc->wx_name);\n\t\t}\n\n\t\tfor (cidx = txpkt->sidx; cidx != txpkt->eidx;\n\t\t    cidx = T_NXT_IDX(cidx)) {\n\t\t\ttxpkt_t *tmp;\n\t\t\twxtd_t *td;\n\n\t\t\ttd = &sc->tdescriptors[cidx];\n\t\t\tif (td->status & TXSTS_EC) {\n\t\t\t\tprintf(\"%s: excess collisions\\n\", sc->wx_name);\n\t\t\t\tifp->if_collisions++;\n\t\t\t\tifp->if_oerrors++;\n\t\t\t}\n\t\t\tif (td->status & TXSTS_LC) {\n\t\t\t\tprintf(\"%s: lost carrier\\n\", sc->wx_name);\n\t\t\t\tifp->if_oerrors++;\n\t\t\t}\n\t\t\ttmp = &sc->tbase[cidx];\n\t\t\tif (sc->wx_debug) {\n\t\t\t\tprintf(\"%s: TXGC[%d] %p %d..%d done nact %d \"\n\t\t\t\t    \"TDH %d\\n\", sc->wx_name, cidx, tmp->dptr,\n\t\t\t\t    txpkt->sidx, txpkt->eidx, sc->tactive, tdh);\n\t\t\t}\n\t\t\ttmp->dptr = NULL;\n\t\t\tif (sc->tactive == 0) {\n\t\t\t\tprintf(\"%s: nactive < 0?\\n\", sc->wx_name);\n\t\t\t} else {\n\t\t\t\tsc->tactive -= 1;\n\t\t\t}\n\t\t\tbzero(td, sizeof (*td));\n\t\t}\n\t\tsc->tbsyf = txpkt->next;\n\t\ttxpkt = sc->tbsyf;\n\t}\n\tif (sc->tactive < WX_MAX_TDESC) {\n\t\tifp->if_timer = 0;\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t}\n\tsplx(s);\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wx_gc",
      "wx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));",
      "wx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));",
      "wx_eeprom_sibits __P((wx_softc_t *));",
      "wx_eeprom_cleanup __P((wx_softc_t *));",
      "wx_read_eeprom_word __P((wx_softc_t *, int));",
      "wx_mwi_whackon\t__P((wx_softc_t *));",
      "wx_mwi_unwhack\t__P((wx_softc_t *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "td",
            "sizeof (*td)"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: nactive < 0?\\n\"",
            "sc->wx_name"
          ],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "T_NXT_IDX",
          "args": [
            "cidx"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "txpkt->dptr"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_CSR",
          "args": [
            "sc",
            "WXREG_TDH"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic void wx_gc;\nwx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));\nwx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic void\nwx_gc(sc)\n\twx_softc_t *sc;\n{\n\tstruct ifnet *ifp = &sc->wx_if;\n\ttxpkt_t *txpkt = sc->tbsyf;\n\tu_int32_t tdh = READ_CSR(sc, WXREG_TDH);\n\tint s;\n\n\ts = splimp();\n\twhile (txpkt != NULL) {\n\t\tu_int32_t end = txpkt->eidx, cidx = tdh;\n\n\t\t/*\n\t\t * Normalize start..end indices to 2 *\n\t \t * WX_MAX_TDESC range to eliminate wrap.\n\t\t */\n\t\tif (txpkt->eidx < txpkt->sidx) {\n\t\t\tend += WX_MAX_TDESC;\n\t\t}\n\n\t\t/*\n\t\t * Normalize current chip index to 2 *\n\t \t * WX_MAX_TDESC range to eliminate wrap.\n\t\t */\n\t\tif (cidx < txpkt->sidx) {\n\t\t\tcidx += WX_MAX_TDESC;\n\t\t}\n\n\t\t/*\n\t\t * If the current chip index is between low and\n\t\t * high indices for this packet, it's not finished\n\t\t * transmitting yet. Because transmits are done FIFO,\n\t\t * this means we're done garbage collecting too.\n\t\t */\n\n\t\tif (txpkt->sidx <= cidx && cidx < txpkt->eidx) {\n\t\t\tif (sc->wx_debug) {\n\t\t\t\tprintf(\"%s: TXGC %d..%d TDH %d\\n\", sc->wx_name,\n\t\t\t\t    txpkt->sidx, txpkt->eidx, tdh);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tifp->if_opackets++;\n\n\t\tif (txpkt->dptr) {\n\t\t\t(void) m_freem(txpkt->dptr);\n\t\t} else {\n\t\t\tprintf(\"%s: null mbuf in gc\\n\", sc->wx_name);\n\t\t}\n\n\t\tfor (cidx = txpkt->sidx; cidx != txpkt->eidx;\n\t\t    cidx = T_NXT_IDX(cidx)) {\n\t\t\ttxpkt_t *tmp;\n\t\t\twxtd_t *td;\n\n\t\t\ttd = &sc->tdescriptors[cidx];\n\t\t\tif (td->status & TXSTS_EC) {\n\t\t\t\tprintf(\"%s: excess collisions\\n\", sc->wx_name);\n\t\t\t\tifp->if_collisions++;\n\t\t\t\tifp->if_oerrors++;\n\t\t\t}\n\t\t\tif (td->status & TXSTS_LC) {\n\t\t\t\tprintf(\"%s: lost carrier\\n\", sc->wx_name);\n\t\t\t\tifp->if_oerrors++;\n\t\t\t}\n\t\t\ttmp = &sc->tbase[cidx];\n\t\t\tif (sc->wx_debug) {\n\t\t\t\tprintf(\"%s: TXGC[%d] %p %d..%d done nact %d \"\n\t\t\t\t    \"TDH %d\\n\", sc->wx_name, cidx, tmp->dptr,\n\t\t\t\t    txpkt->sidx, txpkt->eidx, sc->tactive, tdh);\n\t\t\t}\n\t\t\ttmp->dptr = NULL;\n\t\t\tif (sc->tactive == 0) {\n\t\t\t\tprintf(\"%s: nactive < 0?\\n\", sc->wx_name);\n\t\t\t} else {\n\t\t\t\tsc->tactive -= 1;\n\t\t\t}\n\t\t\tbzero(td, sizeof (*td));\n\t\t}\n\t\tsc->tbsyf = txpkt->next;\n\t\ttxpkt = sc->tbsyf;\n\t}\n\tif (sc->tactive < WX_MAX_TDESC) {\n\t\tifp->if_timer = 0;\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t}\n\tsplx(s);\n}"
  },
  {
    "function_name": "wx_handle_rxint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "1214-1400",
    "snippet": "static void\nwx_handle_rxint(sc)\n\twx_softc_t *sc;\n{\n\tstruct ether_header *eh;\n\tstruct mbuf *m0, *mb, *pending[WX_MAX_RDESC];\n\tstruct ifnet *ifp = &sc->wx_if;\n\tint npkts, ndesc, lidx, idx, tlen;\n\n\tfor (m0 = sc->rpending, tlen = ndesc = npkts = 0, idx = sc->rnxt,\n\t    lidx = R_PREV_IDX(idx); ndesc < WX_MAX_RDESC;\n\t    ndesc++, lidx = idx, idx = R_NXT_IDX(idx)) {\n\t\twxrd_t *rd;\n\t\trxpkt_t *rxpkt;\n\t\tint length, offset, lastframe;\n\n\t\trd = &sc->rdescriptors[idx];\n\t\tif ((rd->status & RDSTAT_DD) == 0) {\n\t\t\tif (m0) {\n\t\t\t\tif (sc->rpending == NULL) {\n\t\t\t\t\tm0->m_pkthdr.len = tlen;\n\t\t\t\t\tsc->rpending = m0;\n\t\t\t\t} else {\n\t\t\t\t\tm_freem(m0);\n\t\t\t\t}\n\t\t\t\tm0 = NULL;\n\t\t\t}\n\t\t\tif (sc->wx_debug) {\n\t\t\t\tprintf(\"WXRX: ndesc %d idx %d lidx %d\\n\",\n\t\t\t\t    ndesc, idx, lidx);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rd->errors != 0) {\n\t\t\tprintf(\"%s: packet with errors (%x)\\n\",\n\t\t\t    sc->wx_name, rd->errors);\n\t\t\trd->status = 0;\n\t\t\tifp->if_ierrors++;\n\t\t\tif (m0) {\n\t\t\t\tm_freem(m0);\n\t\t\t\tm0 = NULL;\n\t\t\t\tif (sc->rpending) {\n\t\t\t\t\tm_freem(sc->rpending);\n\t\t\t\t\tsc->rpending = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\n\t\trxpkt = &sc->rbase[idx];\n\t\tmb = rxpkt->dptr;\n\t\tif (mb == NULL) {\n\t\t\tprintf(\"%s: receive descriptor with no mbuf\\n\",\n\t\t\t    sc->wx_name);\n\t\t\t(void) wx_get_rbuf(sc, rxpkt);\n\t\t\trd->status = 0;\n\t\t\tifp->if_ierrors++;\n\t\t\tif (m0) {\n\t\t\t\tm_freem(m0);\n\t\t\t\tm0 = NULL;\n\t\t\t\tif (sc->rpending) {\n\t\t\t\t\tm_freem(sc->rpending);\n\t\t\t\t\tsc->rpending = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* XXX: Flush DMA for rxpkt */\n\n\t\tif (wx_get_rbuf(sc, rxpkt)) {\n\t\t\tsc->wx_rxnobuf++;\n\t\t\twx_rxdma_map(sc, rxpkt, mb);\n\t\t\tifp->if_ierrors++;\n\t\t\trd->status = 0;\n\t\t\tif (m0) {\n\t\t\t\tm_freem(m0);\n\t\t\t\tm0 = NULL;\n\t\t\t\tif (sc->rpending) {\n\t\t\t\t\tm_freem(sc->rpending);\n\t\t\t\t\tsc->rpending = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Save the completing packet's offset value and length\n\t\t * and install the new one into the descriptor.\n\t\t */\n\t\tlastframe = (rd->status & RDSTAT_EOP) != 0;\n\t\tlength = rd->length;\n\t\toffset = rd->address.lowpart & 0xff;\n\t\tbzero (rd, sizeof (*rd));\n\t\trd->address.lowpart = rxpkt->dma_addr + WX_RX_OFFSET_VALUE;\n\n\t\tmb->m_len = length;\n\t\tmb->m_data += offset;\n\t\tmb->m_next = NULL;\n\t\tif (m0 == NULL) {\n\t\t\tm0 = mb;\n\t\t\ttlen = length;\n\t\t} else if (m0 == sc->rpending) {\n\t\t\t/*\n\t\t\t * Pick up where we left off before. If\n\t\t\t * we have an offset (we're assuming the\n\t\t\t * first frame has an offset), then we've\n\t\t\t * lost sync somewhere along the line.\n\t\t\t */\n\t\t\tif (offset) {\n\t\t\t\tprintf(\"%s: lost sync with partial packet\\n\",\n\t\t\t\t    sc->wx_name);\n\t\t\t\tm_freem(sc->rpending);\n\t\t\t\tsc->rpending = NULL;\n\t\t\t\tm0 = mb;\n\t\t\t\ttlen = length;\n\t\t\t} else {\n\t\t\t\tsc->rpending = NULL;\n\t\t\t\ttlen = m0->m_pkthdr.len;\n\t\t\t}\n\t\t} else {\n\t\t\ttlen += length;\n\t\t}\n\n\t\tif (sc->wx_debug) {\n\t\t\tprintf(\"%s: RDESC[%d] len %d off %d lastframe %d\\n\",\n\t\t\t    sc->wx_name, idx, mb->m_len, offset, lastframe);\n\t\t}\n\t\tif (m0 != mb)\n\t\t\tm_cat(m0, mb);\n\t\tif (lastframe == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tm0->m_pkthdr.rcvif = ifp;\n\t\tm0->m_pkthdr.len = tlen - WX_CRC_LENGTH;\n\t\tmb->m_len -= WX_CRC_LENGTH;\n\n#ifdef __OpenBSD__\n\t\tpending[npkts++] = m0;\n#else\n\t\teh = mtod(m0, struct ether_header *);\n\t\tif ((ifp->if_flags & IFF_PROMISC) &&\n\t\t    (bcmp(eh->ether_dhost, sc->wx_enaddr, ETHER_ADDR_LEN) &&\n\t\t    (eh->ether_dhost[0] & 1) == 0)) {\n\t\t\tm_freem(m0);\n\t\t\tif (sc->rpending) {\n\t\t\t\tm_freem(sc->rpending);\n\t\t\t\tsc->rpending = NULL;\n\t\t\t}\n                } else {\n\t\t\tpending[npkts++] = m0;\n\t\t}\n#endif\n\t\tm0 = NULL;\n\t\ttlen = 0;\n\t}\n\n\tif (ndesc) {\n\t\tWRITE_CSR(sc, WXREG_RDT0, lidx);\n\t\tsc->rnxt = idx;\n\t}\n\n\tif (npkts) {\n\t\tsc->wx_rxintr++;\n\t}\n\n\tfor (idx = 0; idx < npkts; idx++) {\n\t\tmb = pending[idx];\n                if (ifp->if_bpf) {\n                        bpf_mtap(WX_BPFTAP_ARG(ifp), mb);\n\t\t}\n                ifp->if_ipackets++;\n\t\tif (sc->wx_debug) {\n\t\t\tprintf(\"%s: RECV packet length %d\\n\",\n\t\t\t    sc->wx_name, mb->m_pkthdr.len);\n\t\t}\n#if defined(__FreeBSD__) || defined(__OpenBSD__)\n\t\teh = mtod(mb, struct ether_header *);\n\t\tm_adj(mb, sizeof (struct ether_header));\n\t\tether_input(ifp, eh, mb);\n#else\n                (*ifp->if_input)(ifp, mb);\n#endif\n\t}\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wx_handle_rxint",
      "static int wx_get_rbuf",
      "static void wx_rxdma_map",
      "wx_eeprom_sibits __P((wx_softc_t *));",
      "wx_eeprom_cleanup __P((wx_softc_t *));",
      "wx_read_eeprom_word __P((wx_softc_t *, int));",
      "wx_mwi_whackon\t__P((wx_softc_t *));",
      "wx_mwi_unwhack\t__P((wx_softc_t *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "ifp",
            "mb"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_input",
          "args": [
            "ifp",
            "eh",
            "mb"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_adj",
          "args": [
            "mb",
            "sizeof (struct ether_header)"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "mb",
            "structether_header*"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: RECV packet length %d\\n\"",
            "sc->wx_name",
            "mb->m_pkthdr.len"
          ],
          "line": 1389
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "WX_BPFTAP_ARG(ifp)",
            "mb"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WX_BPFTAP_ARG",
          "args": [
            "ifp"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_RDT0",
            "lidx"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "sc->rpending"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m0"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "eh->ether_dhost",
            "sc->wx_enaddr",
            "ETHER_ADDR_LEN"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m0",
            "structether_header*"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_cat",
          "args": [
            "m0",
            "mb"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "sc->rpending"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "rd",
            "sizeof (*rd)"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "sc->rpending"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m0"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wx_rxdma_map",
          "args": [
            "sc",
            "rxpkt",
            "mb"
          ],
          "line": 1288
        },
        "resolved": true,
        "details": {
          "function_name": "wx_rxdma_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "1848-1856",
          "snippet": "static void\nwx_rxdma_map(sc, rxpkt, mb)\n\twx_softc_t *sc;\n\trxpkt_t *rxpkt;\n\tstruct mbuf *mb;\n{\n\trxpkt->dptr = mb;\n\trxpkt->dma_addr = vtophys(mtod(mb, vm_offset_t));\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wx_rxdma_map",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic void wx_rxdma_map;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic void\nwx_rxdma_map(sc, rxpkt, mb)\n\twx_softc_t *sc;\n\trxpkt_t *rxpkt;\n\tstruct mbuf *mb;\n{\n\trxpkt->dptr = mb;\n\trxpkt->dma_addr = vtophys(mtod(mb, vm_offset_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wx_get_rbuf",
          "args": [
            "sc",
            "rxpkt"
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "wx_get_rbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "1858-1877",
          "snippet": "static int\nwx_get_rbuf(sc, rxpkt)\n\twx_softc_t *sc;\n\trxpkt_t *rxpkt;\n{\n\tstruct mbuf *mb;\n\tMGETHDR(mb, M_DONTWAIT, MT_DATA);\n\tif (mb == NULL) {\n\t\trxpkt->dptr = NULL;\n\t\treturn (-1);\n\t}\n\tMCLGET(mb, M_DONTWAIT);\n\tif ((mb->m_flags & M_EXT) == 0) {\n\t\tm_freem(mb);\n\t\trxpkt->dptr = NULL;\n\t\treturn (-1);\n\t}\n\twx_rxdma_map(sc, rxpkt, mb);\n\treturn (0);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int wx_get_rbuf",
            "static void wx_rxdma_map",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic int wx_get_rbuf;\nstatic void wx_rxdma_map;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic int\nwx_get_rbuf(sc, rxpkt)\n\twx_softc_t *sc;\n\trxpkt_t *rxpkt;\n{\n\tstruct mbuf *mb;\n\tMGETHDR(mb, M_DONTWAIT, MT_DATA);\n\tif (mb == NULL) {\n\t\trxpkt->dptr = NULL;\n\t\treturn (-1);\n\t}\n\tMCLGET(mb, M_DONTWAIT);\n\tif ((mb->m_flags & M_EXT) == 0) {\n\t\tm_freem(mb);\n\t\trxpkt->dptr = NULL;\n\t\treturn (-1);\n\t}\n\twx_rxdma_map(sc, rxpkt, mb);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "sc->rpending"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m0"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "sc->rpending"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m0"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m0"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "R_NXT_IDX",
          "args": [
            "idx"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "R_PREV_IDX",
          "args": [
            "idx"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic void wx_handle_rxint;\nstatic int wx_get_rbuf;\nstatic void wx_rxdma_map;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic void\nwx_handle_rxint(sc)\n\twx_softc_t *sc;\n{\n\tstruct ether_header *eh;\n\tstruct mbuf *m0, *mb, *pending[WX_MAX_RDESC];\n\tstruct ifnet *ifp = &sc->wx_if;\n\tint npkts, ndesc, lidx, idx, tlen;\n\n\tfor (m0 = sc->rpending, tlen = ndesc = npkts = 0, idx = sc->rnxt,\n\t    lidx = R_PREV_IDX(idx); ndesc < WX_MAX_RDESC;\n\t    ndesc++, lidx = idx, idx = R_NXT_IDX(idx)) {\n\t\twxrd_t *rd;\n\t\trxpkt_t *rxpkt;\n\t\tint length, offset, lastframe;\n\n\t\trd = &sc->rdescriptors[idx];\n\t\tif ((rd->status & RDSTAT_DD) == 0) {\n\t\t\tif (m0) {\n\t\t\t\tif (sc->rpending == NULL) {\n\t\t\t\t\tm0->m_pkthdr.len = tlen;\n\t\t\t\t\tsc->rpending = m0;\n\t\t\t\t} else {\n\t\t\t\t\tm_freem(m0);\n\t\t\t\t}\n\t\t\t\tm0 = NULL;\n\t\t\t}\n\t\t\tif (sc->wx_debug) {\n\t\t\t\tprintf(\"WXRX: ndesc %d idx %d lidx %d\\n\",\n\t\t\t\t    ndesc, idx, lidx);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rd->errors != 0) {\n\t\t\tprintf(\"%s: packet with errors (%x)\\n\",\n\t\t\t    sc->wx_name, rd->errors);\n\t\t\trd->status = 0;\n\t\t\tifp->if_ierrors++;\n\t\t\tif (m0) {\n\t\t\t\tm_freem(m0);\n\t\t\t\tm0 = NULL;\n\t\t\t\tif (sc->rpending) {\n\t\t\t\t\tm_freem(sc->rpending);\n\t\t\t\t\tsc->rpending = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\n\t\trxpkt = &sc->rbase[idx];\n\t\tmb = rxpkt->dptr;\n\t\tif (mb == NULL) {\n\t\t\tprintf(\"%s: receive descriptor with no mbuf\\n\",\n\t\t\t    sc->wx_name);\n\t\t\t(void) wx_get_rbuf(sc, rxpkt);\n\t\t\trd->status = 0;\n\t\t\tifp->if_ierrors++;\n\t\t\tif (m0) {\n\t\t\t\tm_freem(m0);\n\t\t\t\tm0 = NULL;\n\t\t\t\tif (sc->rpending) {\n\t\t\t\t\tm_freem(sc->rpending);\n\t\t\t\t\tsc->rpending = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* XXX: Flush DMA for rxpkt */\n\n\t\tif (wx_get_rbuf(sc, rxpkt)) {\n\t\t\tsc->wx_rxnobuf++;\n\t\t\twx_rxdma_map(sc, rxpkt, mb);\n\t\t\tifp->if_ierrors++;\n\t\t\trd->status = 0;\n\t\t\tif (m0) {\n\t\t\t\tm_freem(m0);\n\t\t\t\tm0 = NULL;\n\t\t\t\tif (sc->rpending) {\n\t\t\t\t\tm_freem(sc->rpending);\n\t\t\t\t\tsc->rpending = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Save the completing packet's offset value and length\n\t\t * and install the new one into the descriptor.\n\t\t */\n\t\tlastframe = (rd->status & RDSTAT_EOP) != 0;\n\t\tlength = rd->length;\n\t\toffset = rd->address.lowpart & 0xff;\n\t\tbzero (rd, sizeof (*rd));\n\t\trd->address.lowpart = rxpkt->dma_addr + WX_RX_OFFSET_VALUE;\n\n\t\tmb->m_len = length;\n\t\tmb->m_data += offset;\n\t\tmb->m_next = NULL;\n\t\tif (m0 == NULL) {\n\t\t\tm0 = mb;\n\t\t\ttlen = length;\n\t\t} else if (m0 == sc->rpending) {\n\t\t\t/*\n\t\t\t * Pick up where we left off before. If\n\t\t\t * we have an offset (we're assuming the\n\t\t\t * first frame has an offset), then we've\n\t\t\t * lost sync somewhere along the line.\n\t\t\t */\n\t\t\tif (offset) {\n\t\t\t\tprintf(\"%s: lost sync with partial packet\\n\",\n\t\t\t\t    sc->wx_name);\n\t\t\t\tm_freem(sc->rpending);\n\t\t\t\tsc->rpending = NULL;\n\t\t\t\tm0 = mb;\n\t\t\t\ttlen = length;\n\t\t\t} else {\n\t\t\t\tsc->rpending = NULL;\n\t\t\t\ttlen = m0->m_pkthdr.len;\n\t\t\t}\n\t\t} else {\n\t\t\ttlen += length;\n\t\t}\n\n\t\tif (sc->wx_debug) {\n\t\t\tprintf(\"%s: RDESC[%d] len %d off %d lastframe %d\\n\",\n\t\t\t    sc->wx_name, idx, mb->m_len, offset, lastframe);\n\t\t}\n\t\tif (m0 != mb)\n\t\t\tm_cat(m0, mb);\n\t\tif (lastframe == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tm0->m_pkthdr.rcvif = ifp;\n\t\tm0->m_pkthdr.len = tlen - WX_CRC_LENGTH;\n\t\tmb->m_len -= WX_CRC_LENGTH;\n\n#ifdef __OpenBSD__\n\t\tpending[npkts++] = m0;\n#else\n\t\teh = mtod(m0, struct ether_header *);\n\t\tif ((ifp->if_flags & IFF_PROMISC) &&\n\t\t    (bcmp(eh->ether_dhost, sc->wx_enaddr, ETHER_ADDR_LEN) &&\n\t\t    (eh->ether_dhost[0] & 1) == 0)) {\n\t\t\tm_freem(m0);\n\t\t\tif (sc->rpending) {\n\t\t\t\tm_freem(sc->rpending);\n\t\t\t\tsc->rpending = NULL;\n\t\t\t}\n                } else {\n\t\t\tpending[npkts++] = m0;\n\t\t}\n#endif\n\t\tm0 = NULL;\n\t\ttlen = 0;\n\t}\n\n\tif (ndesc) {\n\t\tWRITE_CSR(sc, WXREG_RDT0, lidx);\n\t\tsc->rnxt = idx;\n\t}\n\n\tif (npkts) {\n\t\tsc->wx_rxintr++;\n\t}\n\n\tfor (idx = 0; idx < npkts; idx++) {\n\t\tmb = pending[idx];\n                if (ifp->if_bpf) {\n                        bpf_mtap(WX_BPFTAP_ARG(ifp), mb);\n\t\t}\n                ifp->if_ipackets++;\n\t\tif (sc->wx_debug) {\n\t\t\tprintf(\"%s: RECV packet length %d\\n\",\n\t\t\t    sc->wx_name, mb->m_pkthdr.len);\n\t\t}\n#if defined(__FreeBSD__) || defined(__OpenBSD__)\n\t\teh = mtod(mb, struct ether_header *);\n\t\tm_adj(mb, sizeof (struct ether_header));\n\t\tether_input(ifp, eh, mb);\n#else\n                (*ifp->if_input)(ifp, mb);\n#endif\n\t}\n}"
  },
  {
    "function_name": "wx_handle_link_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "1206-1212",
    "snippet": "static void\nwx_handle_link_intr(sc)\n\twx_softc_t *sc;\n{\n\tsc->wx_linkintr++;\n\tprintf(\"%s: link intr 0x%x\\n\", sc->wx_name, sc->wx_icr);\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wx_handle_link_intr",
      "wx_eeprom_sibits __P((wx_softc_t *));",
      "wx_eeprom_cleanup __P((wx_softc_t *));",
      "wx_read_eeprom_word __P((wx_softc_t *, int));",
      "wx_mwi_whackon\t__P((wx_softc_t *));",
      "wx_mwi_unwhack\t__P((wx_softc_t *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: link intr 0x%x\\n\"",
            "sc->wx_name",
            "sc->wx_icr"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic void wx_handle_link_intr;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic void\nwx_handle_link_intr(sc)\n\twx_softc_t *sc;\n{\n\tsc->wx_linkintr++;\n\tprintf(\"%s: link intr 0x%x\\n\", sc->wx_name, sc->wx_icr);\n}"
  },
  {
    "function_name": "wx_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "1176-1204",
    "snippet": "static int\nwx_intr(arg)\n\tvoid *arg;\n{\n\twx_softc_t *sc = arg;\n\tint claimed = 0;\n\n\t/*\n\t * Read interrupt cause register. Reading it clears bits.\n\t */\n\tsc->wx_icr = READ_CSR(sc, WXREG_ICR);\n\tif (sc->wx_icr) {\n\t\tclaimed++;\n\t\tWX_DISABLE_INT(sc);\n\t\tsc->wx_intr++;\n\t\tif (sc->wx_icr & (WXISR_LSC|WXISR_RXSEQ)) {\n\t\t\twx_handle_link_intr(sc);\n\t\t}\n\t\twx_handle_rxint(sc);\n\t\tif (sc->tactive) {\n\t\t\twx_gc(sc);\n\t\t}\n\t\tif (sc->wx_if.if_snd.ifq_head != NULL) {\n\t\t\twx_start(&sc->wx_if);\n\t\t}\n\t\tWX_ENABLE_INT(sc);\n\t}\n\treturn (claimed);\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int wx_intr",
      "static void wx_handle_link_intr",
      "static void wx_handle_rxint",
      "static void wx_gc",
      "static void wx_start",
      "wx_eeprom_sibits __P((wx_softc_t *));",
      "wx_eeprom_cleanup __P((wx_softc_t *));",
      "wx_read_eeprom_word __P((wx_softc_t *, int));",
      "wx_mwi_whackon\t__P((wx_softc_t *));",
      "wx_mwi_unwhack\t__P((wx_softc_t *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WX_ENABLE_INT",
          "args": [
            "sc"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wx_start",
          "args": [
            "&sc->wx_if"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "wx_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "987-1171",
          "snippet": "static void\nwx_start(ifp)\n\tstruct ifnet *ifp;\n{\n\twx_softc_t *sc = SOFTC_IFP(ifp);\n\tu_int16_t cidx, nactv;\n\n\tnactv = sc->tactive;\n\twhile (nactv < WX_MAX_TDESC) {\n\t\tint ndesc;\n\t\tint gctried = 0;\n\t\tstruct mbuf *m, *mb_head;\n\n\t\tIF_DEQUEUE(&ifp->if_snd, mb_head);\n\t\tif (mb_head == NULL) {\n\t\t\tbreak;\n\t\t}\n\t\tsc->wx_xmitwanted++;\n\n\t\t/*\n\t\t * If we have a packet less than ethermin, pad it out.\n\t\t */\n\t\tif (mb_head->m_pkthdr.len < WX_MIN_RPKT_SIZE) {\n\t\t\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\t\t\tif (m == NULL) {\n\t\t\t\tm_freem(mb_head);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tm_copydata(mb_head, 0, mb_head->m_pkthdr.len,\n\t\t\t    mtod(m, caddr_t));\n\t\t\tm->m_pkthdr.len = m->m_len = WX_MIN_RPKT_SIZE;\n\t\t\tbzero(mtod(m, char *) + mb_head->m_pkthdr.len,\n\t\t\t     WX_MIN_RPKT_SIZE - mb_head->m_pkthdr.len);\n\t\t\tsc->wx_xmitpullup++;\n\t\t\tm_freem(mb_head);\n\t\t\tmb_head = m;\n\t\t}\nagain:\n\t\tcidx = sc->tnxtfree;\n\t\tnactv = sc->tactive;\n\n\n\t\t/*\n\t\t * Go through each of the mbufs in the chain and initialize\n\t\t * the transmit buffer descriptors with the physical address\n\t\t * and size of that mbuf. If we have a length less than our\n\t\t * minimum transmit size, we bail (to do a pullup). If we run\n\t\t * out of descriptors, we also bail and try and do a pullup.\n\t\t */\n\t\tfor (ndesc = 0, m = mb_head; m != NULL; m = m->m_next) {\n\t\t\tvm_offset_t vptr;\n\t\t\twxtd_t *td;\n\n\t\t\t/*\n\t\t\t * If this mbuf has no data, skip it.\n\t\t\t */\n\t\t\tif (m->m_len == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If this packet is too small for the chip's minimum,\n\t\t\t * break out to to cluster it.\n\t\t\t */\n\t\t\tif (m->m_len < WX_MIN_RPKT_SIZE) {\n\t\t\t\tsc->wx_xmitrunt++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Do we have a descriptor available for this mbuf?\n\t\t\t */\n\t\t\tif (++nactv == WX_MAX_TDESC) {\n\t\t\t\tif (gctried++ == 0) {\n\t\t\t\t\tsc->wx_xmitgc++;\n\t\t\t\t\twx_gc(sc);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsc->tbase[cidx].dptr = m;\n\t\t\ttd = &sc->tdescriptors[cidx];\n\t\t\ttd->length = m->m_len;\n\n\t\t\tvptr = mtod(m, vm_offset_t);\n\t\t\ttd->address.highpart = 0;\n\t\t\ttd->address.lowpart = vtophys(vptr);\n\n\t\t\ttd->cso = 0;\n\t\t\ttd->status = 0;\n\t\t\ttd->special = 0;\n\t\t\ttd->cmd = 0;\n\t\t\ttd->css = 0;\n\n\t\t\tif (sc->wx_debug) {\n\t\t\t\tprintf(\"%s: XMIT[%d] %p vptr %lx (length %d \"\n\t\t\t\t    \"DMA addr %x) idx %d\\n\", sc->wx_name,\n\t\t\t\t    ndesc, m, (long) vptr, td->length,\n\t\t\t\t    td->address.lowpart, cidx);\n\t\t\t}\n\t\t\tndesc++;\n\t\t\tcidx = T_NXT_IDX(cidx);\n\t\t}\n\n\t\t/*\n\t\t * If we get here and m is NULL, we can send\n\t\t * the the packet chain described by mb_head.\n\t\t */\n\t\tif (m == NULL) {\n\t\t\t/*\n\t\t\t * Mark the last descriptor with EOP and tell the\n\t\t\t * chip to insert a final checksum.\n\t\t\t */\n\t\t\twxtd_t *td = &sc->tdescriptors[T_PREV_IDX(cidx)];\n\t\t\ttd->cmd = TXCMD_EOP|TXCMD_IFCS;\n\n\t\t\tsc->tbase[sc->tnxtfree].sidx = sc->tnxtfree;\n\t\t\tsc->tbase[sc->tnxtfree].eidx = cidx;\n\t\t\tsc->tbase[sc->tnxtfree].next = NULL;\n\t\t\tif (sc->tbsyf) {\n\t\t\t\tsc->tbsyl->next = &sc->tbase[sc->tnxtfree];\n\t\t\t} else {\n\t\t\t\tsc->tbsyf = &sc->tbase[sc->tnxtfree];\n\t\t\t}\n\t\t\tsc->tbsyl = &sc->tbase[sc->tnxtfree];\n\t\t\tsc->tnxtfree = cidx;\n\t\t\tsc->tactive = nactv;\n\t\t\tifp->if_timer = 10;\n\t\t\tWRITE_CSR(sc, WXREG_TDT, cidx);\n\t\t\tif (ifp->if_bpf)\n\t\t\t\tbpf_mtap(WX_BPFTAP_ARG(ifp), mb_head);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Otherwise, we couldn't send this packet for some reason.\n\t\t *\n\t\t * If don't have a descriptor available, and this is a\n\t\t * single mbuf packet, freeze output so that later we\n\t\t * can restart when we have more room. Otherwise, we'll\n\t\t * try and cluster the request. We've already tried to\n\t\t * garbage collect completed descriptors.\n\t\t */\n\t\tif (nactv == WX_MAX_TDESC && mb_head->m_next == NULL) {\n\t\t\tsc->wx_xmitputback++;\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tIF_PREPEND(&ifp->if_snd, mb_head);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Otherwise, it's either a fragment length somewhere in the\n\t\t * chain that isn't at least WX_MIN_XPKT_SIZE in length or\n\t\t * the number of fragments exceeds the number of descriptors\n\t\t * available.\n\t\t *\n\t\t * We could try a variety of strategies here- if this is\n\t\t * a length problem for single mbuf packet or a length problem\n\t\t * for the last mbuf in a chain (we could just try and adjust\n\t\t * it), but it's just simpler to try and cluster it.\n\t\t */\n\t\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\t\tif (m == NULL) {\n\t\t\tm_freem(mb_head);\n\t\t\tbreak;\n\t\t}\n\t\tMCLGET(m, M_DONTWAIT);\n\t\tif ((m->m_flags & M_EXT) == 0) {\n\t\t\tm_freem(m);\n\t\t\tm_freem(mb_head);\n\t\t\tbreak;\n\t\t}\n\t\tm_copydata(mb_head, 0, mb_head->m_pkthdr.len, mtod(m, caddr_t));\n\t\tm->m_pkthdr.len = m->m_len = mb_head->m_pkthdr.len;\n\t\tm_freem(mb_head);\n\t\tmb_head = m;\n\t\tsc->wx_xmitcluster++;\n\t\tgoto again;\n\t}\n\n\tif (sc->tactive == WX_MAX_TDESC) {\n\t\tsc->wx_xmitblocked++;\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t}\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wx_gc",
            "static void wx_start",
            "wx_eeprom_sobits __P((wx_softc_t *, u_int16_t, u_int16_t));",
            "static INLINE u_int16_t",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "static INLINE u_int16_t",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic void wx_gc;\nstatic void wx_start;\nwx_eeprom_sobits __P((wx_softc_t *, u_int16_t, u_int16_t));\nstatic INLINE u_int16_t;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nstatic INLINE u_int16_t;\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic void\nwx_start(ifp)\n\tstruct ifnet *ifp;\n{\n\twx_softc_t *sc = SOFTC_IFP(ifp);\n\tu_int16_t cidx, nactv;\n\n\tnactv = sc->tactive;\n\twhile (nactv < WX_MAX_TDESC) {\n\t\tint ndesc;\n\t\tint gctried = 0;\n\t\tstruct mbuf *m, *mb_head;\n\n\t\tIF_DEQUEUE(&ifp->if_snd, mb_head);\n\t\tif (mb_head == NULL) {\n\t\t\tbreak;\n\t\t}\n\t\tsc->wx_xmitwanted++;\n\n\t\t/*\n\t\t * If we have a packet less than ethermin, pad it out.\n\t\t */\n\t\tif (mb_head->m_pkthdr.len < WX_MIN_RPKT_SIZE) {\n\t\t\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\t\t\tif (m == NULL) {\n\t\t\t\tm_freem(mb_head);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tm_copydata(mb_head, 0, mb_head->m_pkthdr.len,\n\t\t\t    mtod(m, caddr_t));\n\t\t\tm->m_pkthdr.len = m->m_len = WX_MIN_RPKT_SIZE;\n\t\t\tbzero(mtod(m, char *) + mb_head->m_pkthdr.len,\n\t\t\t     WX_MIN_RPKT_SIZE - mb_head->m_pkthdr.len);\n\t\t\tsc->wx_xmitpullup++;\n\t\t\tm_freem(mb_head);\n\t\t\tmb_head = m;\n\t\t}\nagain:\n\t\tcidx = sc->tnxtfree;\n\t\tnactv = sc->tactive;\n\n\n\t\t/*\n\t\t * Go through each of the mbufs in the chain and initialize\n\t\t * the transmit buffer descriptors with the physical address\n\t\t * and size of that mbuf. If we have a length less than our\n\t\t * minimum transmit size, we bail (to do a pullup). If we run\n\t\t * out of descriptors, we also bail and try and do a pullup.\n\t\t */\n\t\tfor (ndesc = 0, m = mb_head; m != NULL; m = m->m_next) {\n\t\t\tvm_offset_t vptr;\n\t\t\twxtd_t *td;\n\n\t\t\t/*\n\t\t\t * If this mbuf has no data, skip it.\n\t\t\t */\n\t\t\tif (m->m_len == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If this packet is too small for the chip's minimum,\n\t\t\t * break out to to cluster it.\n\t\t\t */\n\t\t\tif (m->m_len < WX_MIN_RPKT_SIZE) {\n\t\t\t\tsc->wx_xmitrunt++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Do we have a descriptor available for this mbuf?\n\t\t\t */\n\t\t\tif (++nactv == WX_MAX_TDESC) {\n\t\t\t\tif (gctried++ == 0) {\n\t\t\t\t\tsc->wx_xmitgc++;\n\t\t\t\t\twx_gc(sc);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsc->tbase[cidx].dptr = m;\n\t\t\ttd = &sc->tdescriptors[cidx];\n\t\t\ttd->length = m->m_len;\n\n\t\t\tvptr = mtod(m, vm_offset_t);\n\t\t\ttd->address.highpart = 0;\n\t\t\ttd->address.lowpart = vtophys(vptr);\n\n\t\t\ttd->cso = 0;\n\t\t\ttd->status = 0;\n\t\t\ttd->special = 0;\n\t\t\ttd->cmd = 0;\n\t\t\ttd->css = 0;\n\n\t\t\tif (sc->wx_debug) {\n\t\t\t\tprintf(\"%s: XMIT[%d] %p vptr %lx (length %d \"\n\t\t\t\t    \"DMA addr %x) idx %d\\n\", sc->wx_name,\n\t\t\t\t    ndesc, m, (long) vptr, td->length,\n\t\t\t\t    td->address.lowpart, cidx);\n\t\t\t}\n\t\t\tndesc++;\n\t\t\tcidx = T_NXT_IDX(cidx);\n\t\t}\n\n\t\t/*\n\t\t * If we get here and m is NULL, we can send\n\t\t * the the packet chain described by mb_head.\n\t\t */\n\t\tif (m == NULL) {\n\t\t\t/*\n\t\t\t * Mark the last descriptor with EOP and tell the\n\t\t\t * chip to insert a final checksum.\n\t\t\t */\n\t\t\twxtd_t *td = &sc->tdescriptors[T_PREV_IDX(cidx)];\n\t\t\ttd->cmd = TXCMD_EOP|TXCMD_IFCS;\n\n\t\t\tsc->tbase[sc->tnxtfree].sidx = sc->tnxtfree;\n\t\t\tsc->tbase[sc->tnxtfree].eidx = cidx;\n\t\t\tsc->tbase[sc->tnxtfree].next = NULL;\n\t\t\tif (sc->tbsyf) {\n\t\t\t\tsc->tbsyl->next = &sc->tbase[sc->tnxtfree];\n\t\t\t} else {\n\t\t\t\tsc->tbsyf = &sc->tbase[sc->tnxtfree];\n\t\t\t}\n\t\t\tsc->tbsyl = &sc->tbase[sc->tnxtfree];\n\t\t\tsc->tnxtfree = cidx;\n\t\t\tsc->tactive = nactv;\n\t\t\tifp->if_timer = 10;\n\t\t\tWRITE_CSR(sc, WXREG_TDT, cidx);\n\t\t\tif (ifp->if_bpf)\n\t\t\t\tbpf_mtap(WX_BPFTAP_ARG(ifp), mb_head);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Otherwise, we couldn't send this packet for some reason.\n\t\t *\n\t\t * If don't have a descriptor available, and this is a\n\t\t * single mbuf packet, freeze output so that later we\n\t\t * can restart when we have more room. Otherwise, we'll\n\t\t * try and cluster the request. We've already tried to\n\t\t * garbage collect completed descriptors.\n\t\t */\n\t\tif (nactv == WX_MAX_TDESC && mb_head->m_next == NULL) {\n\t\t\tsc->wx_xmitputback++;\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tIF_PREPEND(&ifp->if_snd, mb_head);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Otherwise, it's either a fragment length somewhere in the\n\t\t * chain that isn't at least WX_MIN_XPKT_SIZE in length or\n\t\t * the number of fragments exceeds the number of descriptors\n\t\t * available.\n\t\t *\n\t\t * We could try a variety of strategies here- if this is\n\t\t * a length problem for single mbuf packet or a length problem\n\t\t * for the last mbuf in a chain (we could just try and adjust\n\t\t * it), but it's just simpler to try and cluster it.\n\t\t */\n\t\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\t\tif (m == NULL) {\n\t\t\tm_freem(mb_head);\n\t\t\tbreak;\n\t\t}\n\t\tMCLGET(m, M_DONTWAIT);\n\t\tif ((m->m_flags & M_EXT) == 0) {\n\t\t\tm_freem(m);\n\t\t\tm_freem(mb_head);\n\t\t\tbreak;\n\t\t}\n\t\tm_copydata(mb_head, 0, mb_head->m_pkthdr.len, mtod(m, caddr_t));\n\t\tm->m_pkthdr.len = m->m_len = mb_head->m_pkthdr.len;\n\t\tm_freem(mb_head);\n\t\tmb_head = m;\n\t\tsc->wx_xmitcluster++;\n\t\tgoto again;\n\t}\n\n\tif (sc->tactive == WX_MAX_TDESC) {\n\t\tsc->wx_xmitblocked++;\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wx_gc",
          "args": [
            "sc"
          ],
          "line": 1196
        },
        "resolved": true,
        "details": {
          "function_name": "wx_gc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "1402-1490",
          "snippet": "static void\nwx_gc(sc)\n\twx_softc_t *sc;\n{\n\tstruct ifnet *ifp = &sc->wx_if;\n\ttxpkt_t *txpkt = sc->tbsyf;\n\tu_int32_t tdh = READ_CSR(sc, WXREG_TDH);\n\tint s;\n\n\ts = splimp();\n\twhile (txpkt != NULL) {\n\t\tu_int32_t end = txpkt->eidx, cidx = tdh;\n\n\t\t/*\n\t\t * Normalize start..end indices to 2 *\n\t \t * WX_MAX_TDESC range to eliminate wrap.\n\t\t */\n\t\tif (txpkt->eidx < txpkt->sidx) {\n\t\t\tend += WX_MAX_TDESC;\n\t\t}\n\n\t\t/*\n\t\t * Normalize current chip index to 2 *\n\t \t * WX_MAX_TDESC range to eliminate wrap.\n\t\t */\n\t\tif (cidx < txpkt->sidx) {\n\t\t\tcidx += WX_MAX_TDESC;\n\t\t}\n\n\t\t/*\n\t\t * If the current chip index is between low and\n\t\t * high indices for this packet, it's not finished\n\t\t * transmitting yet. Because transmits are done FIFO,\n\t\t * this means we're done garbage collecting too.\n\t\t */\n\n\t\tif (txpkt->sidx <= cidx && cidx < txpkt->eidx) {\n\t\t\tif (sc->wx_debug) {\n\t\t\t\tprintf(\"%s: TXGC %d..%d TDH %d\\n\", sc->wx_name,\n\t\t\t\t    txpkt->sidx, txpkt->eidx, tdh);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tifp->if_opackets++;\n\n\t\tif (txpkt->dptr) {\n\t\t\t(void) m_freem(txpkt->dptr);\n\t\t} else {\n\t\t\tprintf(\"%s: null mbuf in gc\\n\", sc->wx_name);\n\t\t}\n\n\t\tfor (cidx = txpkt->sidx; cidx != txpkt->eidx;\n\t\t    cidx = T_NXT_IDX(cidx)) {\n\t\t\ttxpkt_t *tmp;\n\t\t\twxtd_t *td;\n\n\t\t\ttd = &sc->tdescriptors[cidx];\n\t\t\tif (td->status & TXSTS_EC) {\n\t\t\t\tprintf(\"%s: excess collisions\\n\", sc->wx_name);\n\t\t\t\tifp->if_collisions++;\n\t\t\t\tifp->if_oerrors++;\n\t\t\t}\n\t\t\tif (td->status & TXSTS_LC) {\n\t\t\t\tprintf(\"%s: lost carrier\\n\", sc->wx_name);\n\t\t\t\tifp->if_oerrors++;\n\t\t\t}\n\t\t\ttmp = &sc->tbase[cidx];\n\t\t\tif (sc->wx_debug) {\n\t\t\t\tprintf(\"%s: TXGC[%d] %p %d..%d done nact %d \"\n\t\t\t\t    \"TDH %d\\n\", sc->wx_name, cidx, tmp->dptr,\n\t\t\t\t    txpkt->sidx, txpkt->eidx, sc->tactive, tdh);\n\t\t\t}\n\t\t\ttmp->dptr = NULL;\n\t\t\tif (sc->tactive == 0) {\n\t\t\t\tprintf(\"%s: nactive < 0?\\n\", sc->wx_name);\n\t\t\t} else {\n\t\t\t\tsc->tactive -= 1;\n\t\t\t}\n\t\t\tbzero(td, sizeof (*td));\n\t\t}\n\t\tsc->tbsyf = txpkt->next;\n\t\ttxpkt = sc->tbsyf;\n\t}\n\tif (sc->tactive < WX_MAX_TDESC) {\n\t\tifp->if_timer = 0;\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t}\n\tsplx(s);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wx_gc",
            "wx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));",
            "wx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic void wx_gc;\nwx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));\nwx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic void\nwx_gc(sc)\n\twx_softc_t *sc;\n{\n\tstruct ifnet *ifp = &sc->wx_if;\n\ttxpkt_t *txpkt = sc->tbsyf;\n\tu_int32_t tdh = READ_CSR(sc, WXREG_TDH);\n\tint s;\n\n\ts = splimp();\n\twhile (txpkt != NULL) {\n\t\tu_int32_t end = txpkt->eidx, cidx = tdh;\n\n\t\t/*\n\t\t * Normalize start..end indices to 2 *\n\t \t * WX_MAX_TDESC range to eliminate wrap.\n\t\t */\n\t\tif (txpkt->eidx < txpkt->sidx) {\n\t\t\tend += WX_MAX_TDESC;\n\t\t}\n\n\t\t/*\n\t\t * Normalize current chip index to 2 *\n\t \t * WX_MAX_TDESC range to eliminate wrap.\n\t\t */\n\t\tif (cidx < txpkt->sidx) {\n\t\t\tcidx += WX_MAX_TDESC;\n\t\t}\n\n\t\t/*\n\t\t * If the current chip index is between low and\n\t\t * high indices for this packet, it's not finished\n\t\t * transmitting yet. Because transmits are done FIFO,\n\t\t * this means we're done garbage collecting too.\n\t\t */\n\n\t\tif (txpkt->sidx <= cidx && cidx < txpkt->eidx) {\n\t\t\tif (sc->wx_debug) {\n\t\t\t\tprintf(\"%s: TXGC %d..%d TDH %d\\n\", sc->wx_name,\n\t\t\t\t    txpkt->sidx, txpkt->eidx, tdh);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tifp->if_opackets++;\n\n\t\tif (txpkt->dptr) {\n\t\t\t(void) m_freem(txpkt->dptr);\n\t\t} else {\n\t\t\tprintf(\"%s: null mbuf in gc\\n\", sc->wx_name);\n\t\t}\n\n\t\tfor (cidx = txpkt->sidx; cidx != txpkt->eidx;\n\t\t    cidx = T_NXT_IDX(cidx)) {\n\t\t\ttxpkt_t *tmp;\n\t\t\twxtd_t *td;\n\n\t\t\ttd = &sc->tdescriptors[cidx];\n\t\t\tif (td->status & TXSTS_EC) {\n\t\t\t\tprintf(\"%s: excess collisions\\n\", sc->wx_name);\n\t\t\t\tifp->if_collisions++;\n\t\t\t\tifp->if_oerrors++;\n\t\t\t}\n\t\t\tif (td->status & TXSTS_LC) {\n\t\t\t\tprintf(\"%s: lost carrier\\n\", sc->wx_name);\n\t\t\t\tifp->if_oerrors++;\n\t\t\t}\n\t\t\ttmp = &sc->tbase[cidx];\n\t\t\tif (sc->wx_debug) {\n\t\t\t\tprintf(\"%s: TXGC[%d] %p %d..%d done nact %d \"\n\t\t\t\t    \"TDH %d\\n\", sc->wx_name, cidx, tmp->dptr,\n\t\t\t\t    txpkt->sidx, txpkt->eidx, sc->tactive, tdh);\n\t\t\t}\n\t\t\ttmp->dptr = NULL;\n\t\t\tif (sc->tactive == 0) {\n\t\t\t\tprintf(\"%s: nactive < 0?\\n\", sc->wx_name);\n\t\t\t} else {\n\t\t\t\tsc->tactive -= 1;\n\t\t\t}\n\t\t\tbzero(td, sizeof (*td));\n\t\t}\n\t\tsc->tbsyf = txpkt->next;\n\t\ttxpkt = sc->tbsyf;\n\t}\n\tif (sc->tactive < WX_MAX_TDESC) {\n\t\tifp->if_timer = 0;\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t}\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wx_handle_rxint",
          "args": [
            "sc"
          ],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "wx_handle_rxint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "1214-1400",
          "snippet": "static void\nwx_handle_rxint(sc)\n\twx_softc_t *sc;\n{\n\tstruct ether_header *eh;\n\tstruct mbuf *m0, *mb, *pending[WX_MAX_RDESC];\n\tstruct ifnet *ifp = &sc->wx_if;\n\tint npkts, ndesc, lidx, idx, tlen;\n\n\tfor (m0 = sc->rpending, tlen = ndesc = npkts = 0, idx = sc->rnxt,\n\t    lidx = R_PREV_IDX(idx); ndesc < WX_MAX_RDESC;\n\t    ndesc++, lidx = idx, idx = R_NXT_IDX(idx)) {\n\t\twxrd_t *rd;\n\t\trxpkt_t *rxpkt;\n\t\tint length, offset, lastframe;\n\n\t\trd = &sc->rdescriptors[idx];\n\t\tif ((rd->status & RDSTAT_DD) == 0) {\n\t\t\tif (m0) {\n\t\t\t\tif (sc->rpending == NULL) {\n\t\t\t\t\tm0->m_pkthdr.len = tlen;\n\t\t\t\t\tsc->rpending = m0;\n\t\t\t\t} else {\n\t\t\t\t\tm_freem(m0);\n\t\t\t\t}\n\t\t\t\tm0 = NULL;\n\t\t\t}\n\t\t\tif (sc->wx_debug) {\n\t\t\t\tprintf(\"WXRX: ndesc %d idx %d lidx %d\\n\",\n\t\t\t\t    ndesc, idx, lidx);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rd->errors != 0) {\n\t\t\tprintf(\"%s: packet with errors (%x)\\n\",\n\t\t\t    sc->wx_name, rd->errors);\n\t\t\trd->status = 0;\n\t\t\tifp->if_ierrors++;\n\t\t\tif (m0) {\n\t\t\t\tm_freem(m0);\n\t\t\t\tm0 = NULL;\n\t\t\t\tif (sc->rpending) {\n\t\t\t\t\tm_freem(sc->rpending);\n\t\t\t\t\tsc->rpending = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\n\t\trxpkt = &sc->rbase[idx];\n\t\tmb = rxpkt->dptr;\n\t\tif (mb == NULL) {\n\t\t\tprintf(\"%s: receive descriptor with no mbuf\\n\",\n\t\t\t    sc->wx_name);\n\t\t\t(void) wx_get_rbuf(sc, rxpkt);\n\t\t\trd->status = 0;\n\t\t\tifp->if_ierrors++;\n\t\t\tif (m0) {\n\t\t\t\tm_freem(m0);\n\t\t\t\tm0 = NULL;\n\t\t\t\tif (sc->rpending) {\n\t\t\t\t\tm_freem(sc->rpending);\n\t\t\t\t\tsc->rpending = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* XXX: Flush DMA for rxpkt */\n\n\t\tif (wx_get_rbuf(sc, rxpkt)) {\n\t\t\tsc->wx_rxnobuf++;\n\t\t\twx_rxdma_map(sc, rxpkt, mb);\n\t\t\tifp->if_ierrors++;\n\t\t\trd->status = 0;\n\t\t\tif (m0) {\n\t\t\t\tm_freem(m0);\n\t\t\t\tm0 = NULL;\n\t\t\t\tif (sc->rpending) {\n\t\t\t\t\tm_freem(sc->rpending);\n\t\t\t\t\tsc->rpending = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Save the completing packet's offset value and length\n\t\t * and install the new one into the descriptor.\n\t\t */\n\t\tlastframe = (rd->status & RDSTAT_EOP) != 0;\n\t\tlength = rd->length;\n\t\toffset = rd->address.lowpart & 0xff;\n\t\tbzero (rd, sizeof (*rd));\n\t\trd->address.lowpart = rxpkt->dma_addr + WX_RX_OFFSET_VALUE;\n\n\t\tmb->m_len = length;\n\t\tmb->m_data += offset;\n\t\tmb->m_next = NULL;\n\t\tif (m0 == NULL) {\n\t\t\tm0 = mb;\n\t\t\ttlen = length;\n\t\t} else if (m0 == sc->rpending) {\n\t\t\t/*\n\t\t\t * Pick up where we left off before. If\n\t\t\t * we have an offset (we're assuming the\n\t\t\t * first frame has an offset), then we've\n\t\t\t * lost sync somewhere along the line.\n\t\t\t */\n\t\t\tif (offset) {\n\t\t\t\tprintf(\"%s: lost sync with partial packet\\n\",\n\t\t\t\t    sc->wx_name);\n\t\t\t\tm_freem(sc->rpending);\n\t\t\t\tsc->rpending = NULL;\n\t\t\t\tm0 = mb;\n\t\t\t\ttlen = length;\n\t\t\t} else {\n\t\t\t\tsc->rpending = NULL;\n\t\t\t\ttlen = m0->m_pkthdr.len;\n\t\t\t}\n\t\t} else {\n\t\t\ttlen += length;\n\t\t}\n\n\t\tif (sc->wx_debug) {\n\t\t\tprintf(\"%s: RDESC[%d] len %d off %d lastframe %d\\n\",\n\t\t\t    sc->wx_name, idx, mb->m_len, offset, lastframe);\n\t\t}\n\t\tif (m0 != mb)\n\t\t\tm_cat(m0, mb);\n\t\tif (lastframe == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tm0->m_pkthdr.rcvif = ifp;\n\t\tm0->m_pkthdr.len = tlen - WX_CRC_LENGTH;\n\t\tmb->m_len -= WX_CRC_LENGTH;\n\n#ifdef __OpenBSD__\n\t\tpending[npkts++] = m0;\n#else\n\t\teh = mtod(m0, struct ether_header *);\n\t\tif ((ifp->if_flags & IFF_PROMISC) &&\n\t\t    (bcmp(eh->ether_dhost, sc->wx_enaddr, ETHER_ADDR_LEN) &&\n\t\t    (eh->ether_dhost[0] & 1) == 0)) {\n\t\t\tm_freem(m0);\n\t\t\tif (sc->rpending) {\n\t\t\t\tm_freem(sc->rpending);\n\t\t\t\tsc->rpending = NULL;\n\t\t\t}\n                } else {\n\t\t\tpending[npkts++] = m0;\n\t\t}\n#endif\n\t\tm0 = NULL;\n\t\ttlen = 0;\n\t}\n\n\tif (ndesc) {\n\t\tWRITE_CSR(sc, WXREG_RDT0, lidx);\n\t\tsc->rnxt = idx;\n\t}\n\n\tif (npkts) {\n\t\tsc->wx_rxintr++;\n\t}\n\n\tfor (idx = 0; idx < npkts; idx++) {\n\t\tmb = pending[idx];\n                if (ifp->if_bpf) {\n                        bpf_mtap(WX_BPFTAP_ARG(ifp), mb);\n\t\t}\n                ifp->if_ipackets++;\n\t\tif (sc->wx_debug) {\n\t\t\tprintf(\"%s: RECV packet length %d\\n\",\n\t\t\t    sc->wx_name, mb->m_pkthdr.len);\n\t\t}\n#if defined(__FreeBSD__) || defined(__OpenBSD__)\n\t\teh = mtod(mb, struct ether_header *);\n\t\tm_adj(mb, sizeof (struct ether_header));\n\t\tether_input(ifp, eh, mb);\n#else\n                (*ifp->if_input)(ifp, mb);\n#endif\n\t}\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wx_handle_rxint",
            "static int wx_get_rbuf",
            "static void wx_rxdma_map",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic void wx_handle_rxint;\nstatic int wx_get_rbuf;\nstatic void wx_rxdma_map;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic void\nwx_handle_rxint(sc)\n\twx_softc_t *sc;\n{\n\tstruct ether_header *eh;\n\tstruct mbuf *m0, *mb, *pending[WX_MAX_RDESC];\n\tstruct ifnet *ifp = &sc->wx_if;\n\tint npkts, ndesc, lidx, idx, tlen;\n\n\tfor (m0 = sc->rpending, tlen = ndesc = npkts = 0, idx = sc->rnxt,\n\t    lidx = R_PREV_IDX(idx); ndesc < WX_MAX_RDESC;\n\t    ndesc++, lidx = idx, idx = R_NXT_IDX(idx)) {\n\t\twxrd_t *rd;\n\t\trxpkt_t *rxpkt;\n\t\tint length, offset, lastframe;\n\n\t\trd = &sc->rdescriptors[idx];\n\t\tif ((rd->status & RDSTAT_DD) == 0) {\n\t\t\tif (m0) {\n\t\t\t\tif (sc->rpending == NULL) {\n\t\t\t\t\tm0->m_pkthdr.len = tlen;\n\t\t\t\t\tsc->rpending = m0;\n\t\t\t\t} else {\n\t\t\t\t\tm_freem(m0);\n\t\t\t\t}\n\t\t\t\tm0 = NULL;\n\t\t\t}\n\t\t\tif (sc->wx_debug) {\n\t\t\t\tprintf(\"WXRX: ndesc %d idx %d lidx %d\\n\",\n\t\t\t\t    ndesc, idx, lidx);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rd->errors != 0) {\n\t\t\tprintf(\"%s: packet with errors (%x)\\n\",\n\t\t\t    sc->wx_name, rd->errors);\n\t\t\trd->status = 0;\n\t\t\tifp->if_ierrors++;\n\t\t\tif (m0) {\n\t\t\t\tm_freem(m0);\n\t\t\t\tm0 = NULL;\n\t\t\t\tif (sc->rpending) {\n\t\t\t\t\tm_freem(sc->rpending);\n\t\t\t\t\tsc->rpending = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\n\t\trxpkt = &sc->rbase[idx];\n\t\tmb = rxpkt->dptr;\n\t\tif (mb == NULL) {\n\t\t\tprintf(\"%s: receive descriptor with no mbuf\\n\",\n\t\t\t    sc->wx_name);\n\t\t\t(void) wx_get_rbuf(sc, rxpkt);\n\t\t\trd->status = 0;\n\t\t\tifp->if_ierrors++;\n\t\t\tif (m0) {\n\t\t\t\tm_freem(m0);\n\t\t\t\tm0 = NULL;\n\t\t\t\tif (sc->rpending) {\n\t\t\t\t\tm_freem(sc->rpending);\n\t\t\t\t\tsc->rpending = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* XXX: Flush DMA for rxpkt */\n\n\t\tif (wx_get_rbuf(sc, rxpkt)) {\n\t\t\tsc->wx_rxnobuf++;\n\t\t\twx_rxdma_map(sc, rxpkt, mb);\n\t\t\tifp->if_ierrors++;\n\t\t\trd->status = 0;\n\t\t\tif (m0) {\n\t\t\t\tm_freem(m0);\n\t\t\t\tm0 = NULL;\n\t\t\t\tif (sc->rpending) {\n\t\t\t\t\tm_freem(sc->rpending);\n\t\t\t\t\tsc->rpending = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Save the completing packet's offset value and length\n\t\t * and install the new one into the descriptor.\n\t\t */\n\t\tlastframe = (rd->status & RDSTAT_EOP) != 0;\n\t\tlength = rd->length;\n\t\toffset = rd->address.lowpart & 0xff;\n\t\tbzero (rd, sizeof (*rd));\n\t\trd->address.lowpart = rxpkt->dma_addr + WX_RX_OFFSET_VALUE;\n\n\t\tmb->m_len = length;\n\t\tmb->m_data += offset;\n\t\tmb->m_next = NULL;\n\t\tif (m0 == NULL) {\n\t\t\tm0 = mb;\n\t\t\ttlen = length;\n\t\t} else if (m0 == sc->rpending) {\n\t\t\t/*\n\t\t\t * Pick up where we left off before. If\n\t\t\t * we have an offset (we're assuming the\n\t\t\t * first frame has an offset), then we've\n\t\t\t * lost sync somewhere along the line.\n\t\t\t */\n\t\t\tif (offset) {\n\t\t\t\tprintf(\"%s: lost sync with partial packet\\n\",\n\t\t\t\t    sc->wx_name);\n\t\t\t\tm_freem(sc->rpending);\n\t\t\t\tsc->rpending = NULL;\n\t\t\t\tm0 = mb;\n\t\t\t\ttlen = length;\n\t\t\t} else {\n\t\t\t\tsc->rpending = NULL;\n\t\t\t\ttlen = m0->m_pkthdr.len;\n\t\t\t}\n\t\t} else {\n\t\t\ttlen += length;\n\t\t}\n\n\t\tif (sc->wx_debug) {\n\t\t\tprintf(\"%s: RDESC[%d] len %d off %d lastframe %d\\n\",\n\t\t\t    sc->wx_name, idx, mb->m_len, offset, lastframe);\n\t\t}\n\t\tif (m0 != mb)\n\t\t\tm_cat(m0, mb);\n\t\tif (lastframe == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tm0->m_pkthdr.rcvif = ifp;\n\t\tm0->m_pkthdr.len = tlen - WX_CRC_LENGTH;\n\t\tmb->m_len -= WX_CRC_LENGTH;\n\n#ifdef __OpenBSD__\n\t\tpending[npkts++] = m0;\n#else\n\t\teh = mtod(m0, struct ether_header *);\n\t\tif ((ifp->if_flags & IFF_PROMISC) &&\n\t\t    (bcmp(eh->ether_dhost, sc->wx_enaddr, ETHER_ADDR_LEN) &&\n\t\t    (eh->ether_dhost[0] & 1) == 0)) {\n\t\t\tm_freem(m0);\n\t\t\tif (sc->rpending) {\n\t\t\t\tm_freem(sc->rpending);\n\t\t\t\tsc->rpending = NULL;\n\t\t\t}\n                } else {\n\t\t\tpending[npkts++] = m0;\n\t\t}\n#endif\n\t\tm0 = NULL;\n\t\ttlen = 0;\n\t}\n\n\tif (ndesc) {\n\t\tWRITE_CSR(sc, WXREG_RDT0, lidx);\n\t\tsc->rnxt = idx;\n\t}\n\n\tif (npkts) {\n\t\tsc->wx_rxintr++;\n\t}\n\n\tfor (idx = 0; idx < npkts; idx++) {\n\t\tmb = pending[idx];\n                if (ifp->if_bpf) {\n                        bpf_mtap(WX_BPFTAP_ARG(ifp), mb);\n\t\t}\n                ifp->if_ipackets++;\n\t\tif (sc->wx_debug) {\n\t\t\tprintf(\"%s: RECV packet length %d\\n\",\n\t\t\t    sc->wx_name, mb->m_pkthdr.len);\n\t\t}\n#if defined(__FreeBSD__) || defined(__OpenBSD__)\n\t\teh = mtod(mb, struct ether_header *);\n\t\tm_adj(mb, sizeof (struct ether_header));\n\t\tether_input(ifp, eh, mb);\n#else\n                (*ifp->if_input)(ifp, mb);\n#endif\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wx_handle_link_intr",
          "args": [
            "sc"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "wx_handle_link_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "1206-1212",
          "snippet": "static void\nwx_handle_link_intr(sc)\n\twx_softc_t *sc;\n{\n\tsc->wx_linkintr++;\n\tprintf(\"%s: link intr 0x%x\\n\", sc->wx_name, sc->wx_icr);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wx_handle_link_intr",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic void wx_handle_link_intr;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic void\nwx_handle_link_intr(sc)\n\twx_softc_t *sc;\n{\n\tsc->wx_linkintr++;\n\tprintf(\"%s: link intr 0x%x\\n\", sc->wx_name, sc->wx_icr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WX_DISABLE_INT",
          "args": [
            "sc"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_CSR",
          "args": [
            "sc",
            "WXREG_ICR"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic int wx_intr;\nstatic void wx_handle_link_intr;\nstatic void wx_handle_rxint;\nstatic void wx_gc;\nstatic void wx_start;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic int\nwx_intr(arg)\n\tvoid *arg;\n{\n\twx_softc_t *sc = arg;\n\tint claimed = 0;\n\n\t/*\n\t * Read interrupt cause register. Reading it clears bits.\n\t */\n\tsc->wx_icr = READ_CSR(sc, WXREG_ICR);\n\tif (sc->wx_icr) {\n\t\tclaimed++;\n\t\tWX_DISABLE_INT(sc);\n\t\tsc->wx_intr++;\n\t\tif (sc->wx_icr & (WXISR_LSC|WXISR_RXSEQ)) {\n\t\t\twx_handle_link_intr(sc);\n\t\t}\n\t\twx_handle_rxint(sc);\n\t\tif (sc->tactive) {\n\t\t\twx_gc(sc);\n\t\t}\n\t\tif (sc->wx_if.if_snd.ifq_head != NULL) {\n\t\t\twx_start(&sc->wx_if);\n\t\t}\n\t\tWX_ENABLE_INT(sc);\n\t}\n\treturn (claimed);\n}"
  },
  {
    "function_name": "wx_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "987-1171",
    "snippet": "static void\nwx_start(ifp)\n\tstruct ifnet *ifp;\n{\n\twx_softc_t *sc = SOFTC_IFP(ifp);\n\tu_int16_t cidx, nactv;\n\n\tnactv = sc->tactive;\n\twhile (nactv < WX_MAX_TDESC) {\n\t\tint ndesc;\n\t\tint gctried = 0;\n\t\tstruct mbuf *m, *mb_head;\n\n\t\tIF_DEQUEUE(&ifp->if_snd, mb_head);\n\t\tif (mb_head == NULL) {\n\t\t\tbreak;\n\t\t}\n\t\tsc->wx_xmitwanted++;\n\n\t\t/*\n\t\t * If we have a packet less than ethermin, pad it out.\n\t\t */\n\t\tif (mb_head->m_pkthdr.len < WX_MIN_RPKT_SIZE) {\n\t\t\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\t\t\tif (m == NULL) {\n\t\t\t\tm_freem(mb_head);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tm_copydata(mb_head, 0, mb_head->m_pkthdr.len,\n\t\t\t    mtod(m, caddr_t));\n\t\t\tm->m_pkthdr.len = m->m_len = WX_MIN_RPKT_SIZE;\n\t\t\tbzero(mtod(m, char *) + mb_head->m_pkthdr.len,\n\t\t\t     WX_MIN_RPKT_SIZE - mb_head->m_pkthdr.len);\n\t\t\tsc->wx_xmitpullup++;\n\t\t\tm_freem(mb_head);\n\t\t\tmb_head = m;\n\t\t}\nagain:\n\t\tcidx = sc->tnxtfree;\n\t\tnactv = sc->tactive;\n\n\n\t\t/*\n\t\t * Go through each of the mbufs in the chain and initialize\n\t\t * the transmit buffer descriptors with the physical address\n\t\t * and size of that mbuf. If we have a length less than our\n\t\t * minimum transmit size, we bail (to do a pullup). If we run\n\t\t * out of descriptors, we also bail and try and do a pullup.\n\t\t */\n\t\tfor (ndesc = 0, m = mb_head; m != NULL; m = m->m_next) {\n\t\t\tvm_offset_t vptr;\n\t\t\twxtd_t *td;\n\n\t\t\t/*\n\t\t\t * If this mbuf has no data, skip it.\n\t\t\t */\n\t\t\tif (m->m_len == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If this packet is too small for the chip's minimum,\n\t\t\t * break out to to cluster it.\n\t\t\t */\n\t\t\tif (m->m_len < WX_MIN_RPKT_SIZE) {\n\t\t\t\tsc->wx_xmitrunt++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Do we have a descriptor available for this mbuf?\n\t\t\t */\n\t\t\tif (++nactv == WX_MAX_TDESC) {\n\t\t\t\tif (gctried++ == 0) {\n\t\t\t\t\tsc->wx_xmitgc++;\n\t\t\t\t\twx_gc(sc);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsc->tbase[cidx].dptr = m;\n\t\t\ttd = &sc->tdescriptors[cidx];\n\t\t\ttd->length = m->m_len;\n\n\t\t\tvptr = mtod(m, vm_offset_t);\n\t\t\ttd->address.highpart = 0;\n\t\t\ttd->address.lowpart = vtophys(vptr);\n\n\t\t\ttd->cso = 0;\n\t\t\ttd->status = 0;\n\t\t\ttd->special = 0;\n\t\t\ttd->cmd = 0;\n\t\t\ttd->css = 0;\n\n\t\t\tif (sc->wx_debug) {\n\t\t\t\tprintf(\"%s: XMIT[%d] %p vptr %lx (length %d \"\n\t\t\t\t    \"DMA addr %x) idx %d\\n\", sc->wx_name,\n\t\t\t\t    ndesc, m, (long) vptr, td->length,\n\t\t\t\t    td->address.lowpart, cidx);\n\t\t\t}\n\t\t\tndesc++;\n\t\t\tcidx = T_NXT_IDX(cidx);\n\t\t}\n\n\t\t/*\n\t\t * If we get here and m is NULL, we can send\n\t\t * the the packet chain described by mb_head.\n\t\t */\n\t\tif (m == NULL) {\n\t\t\t/*\n\t\t\t * Mark the last descriptor with EOP and tell the\n\t\t\t * chip to insert a final checksum.\n\t\t\t */\n\t\t\twxtd_t *td = &sc->tdescriptors[T_PREV_IDX(cidx)];\n\t\t\ttd->cmd = TXCMD_EOP|TXCMD_IFCS;\n\n\t\t\tsc->tbase[sc->tnxtfree].sidx = sc->tnxtfree;\n\t\t\tsc->tbase[sc->tnxtfree].eidx = cidx;\n\t\t\tsc->tbase[sc->tnxtfree].next = NULL;\n\t\t\tif (sc->tbsyf) {\n\t\t\t\tsc->tbsyl->next = &sc->tbase[sc->tnxtfree];\n\t\t\t} else {\n\t\t\t\tsc->tbsyf = &sc->tbase[sc->tnxtfree];\n\t\t\t}\n\t\t\tsc->tbsyl = &sc->tbase[sc->tnxtfree];\n\t\t\tsc->tnxtfree = cidx;\n\t\t\tsc->tactive = nactv;\n\t\t\tifp->if_timer = 10;\n\t\t\tWRITE_CSR(sc, WXREG_TDT, cidx);\n\t\t\tif (ifp->if_bpf)\n\t\t\t\tbpf_mtap(WX_BPFTAP_ARG(ifp), mb_head);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Otherwise, we couldn't send this packet for some reason.\n\t\t *\n\t\t * If don't have a descriptor available, and this is a\n\t\t * single mbuf packet, freeze output so that later we\n\t\t * can restart when we have more room. Otherwise, we'll\n\t\t * try and cluster the request. We've already tried to\n\t\t * garbage collect completed descriptors.\n\t\t */\n\t\tif (nactv == WX_MAX_TDESC && mb_head->m_next == NULL) {\n\t\t\tsc->wx_xmitputback++;\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tIF_PREPEND(&ifp->if_snd, mb_head);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Otherwise, it's either a fragment length somewhere in the\n\t\t * chain that isn't at least WX_MIN_XPKT_SIZE in length or\n\t\t * the number of fragments exceeds the number of descriptors\n\t\t * available.\n\t\t *\n\t\t * We could try a variety of strategies here- if this is\n\t\t * a length problem for single mbuf packet or a length problem\n\t\t * for the last mbuf in a chain (we could just try and adjust\n\t\t * it), but it's just simpler to try and cluster it.\n\t\t */\n\t\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\t\tif (m == NULL) {\n\t\t\tm_freem(mb_head);\n\t\t\tbreak;\n\t\t}\n\t\tMCLGET(m, M_DONTWAIT);\n\t\tif ((m->m_flags & M_EXT) == 0) {\n\t\t\tm_freem(m);\n\t\t\tm_freem(mb_head);\n\t\t\tbreak;\n\t\t}\n\t\tm_copydata(mb_head, 0, mb_head->m_pkthdr.len, mtod(m, caddr_t));\n\t\tm->m_pkthdr.len = m->m_len = mb_head->m_pkthdr.len;\n\t\tm_freem(mb_head);\n\t\tmb_head = m;\n\t\tsc->wx_xmitcluster++;\n\t\tgoto again;\n\t}\n\n\tif (sc->tactive == WX_MAX_TDESC) {\n\t\tsc->wx_xmitblocked++;\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t}\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wx_gc",
      "static void wx_start",
      "wx_eeprom_sobits __P((wx_softc_t *, u_int16_t, u_int16_t));",
      "static INLINE u_int16_t",
      "wx_eeprom_sibits __P((wx_softc_t *));",
      "wx_eeprom_cleanup __P((wx_softc_t *));",
      "static INLINE u_int16_t",
      "wx_read_eeprom_word __P((wx_softc_t *, int));",
      "wx_mwi_whackon\t__P((wx_softc_t *));",
      "wx_mwi_unwhack\t__P((wx_softc_t *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "mb_head"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_copydata",
          "args": [
            "mb_head",
            "0",
            "mb_head->m_pkthdr.len",
            "mtod(m, caddr_t)"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "caddr_t"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "mb_head"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCLGET",
          "args": [
            "m",
            "M_DONTWAIT"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "mb_head"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGETHDR",
          "args": [
            "m",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_PREPEND",
          "args": [
            "&ifp->if_snd",
            "mb_head"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "WX_BPFTAP_ARG(ifp)",
            "mb_head"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WX_BPFTAP_ARG",
          "args": [
            "ifp"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_TDT",
            "cidx"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "T_PREV_IDX",
          "args": [
            "cidx"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "T_NXT_IDX",
          "args": [
            "cidx"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: XMIT[%d] %p vptr %lx (length %d \"\n\t\t\t\t    \"DMA addr %x) idx %d\\n\"",
            "sc->wx_name",
            "ndesc",
            "m",
            "(long) vptr",
            "td->length",
            "td->address.lowpart",
            "cidx"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "vptr"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "vm_offset_t"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wx_gc",
          "args": [
            "sc"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "wx_gc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "1402-1490",
          "snippet": "static void\nwx_gc(sc)\n\twx_softc_t *sc;\n{\n\tstruct ifnet *ifp = &sc->wx_if;\n\ttxpkt_t *txpkt = sc->tbsyf;\n\tu_int32_t tdh = READ_CSR(sc, WXREG_TDH);\n\tint s;\n\n\ts = splimp();\n\twhile (txpkt != NULL) {\n\t\tu_int32_t end = txpkt->eidx, cidx = tdh;\n\n\t\t/*\n\t\t * Normalize start..end indices to 2 *\n\t \t * WX_MAX_TDESC range to eliminate wrap.\n\t\t */\n\t\tif (txpkt->eidx < txpkt->sidx) {\n\t\t\tend += WX_MAX_TDESC;\n\t\t}\n\n\t\t/*\n\t\t * Normalize current chip index to 2 *\n\t \t * WX_MAX_TDESC range to eliminate wrap.\n\t\t */\n\t\tif (cidx < txpkt->sidx) {\n\t\t\tcidx += WX_MAX_TDESC;\n\t\t}\n\n\t\t/*\n\t\t * If the current chip index is between low and\n\t\t * high indices for this packet, it's not finished\n\t\t * transmitting yet. Because transmits are done FIFO,\n\t\t * this means we're done garbage collecting too.\n\t\t */\n\n\t\tif (txpkt->sidx <= cidx && cidx < txpkt->eidx) {\n\t\t\tif (sc->wx_debug) {\n\t\t\t\tprintf(\"%s: TXGC %d..%d TDH %d\\n\", sc->wx_name,\n\t\t\t\t    txpkt->sidx, txpkt->eidx, tdh);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tifp->if_opackets++;\n\n\t\tif (txpkt->dptr) {\n\t\t\t(void) m_freem(txpkt->dptr);\n\t\t} else {\n\t\t\tprintf(\"%s: null mbuf in gc\\n\", sc->wx_name);\n\t\t}\n\n\t\tfor (cidx = txpkt->sidx; cidx != txpkt->eidx;\n\t\t    cidx = T_NXT_IDX(cidx)) {\n\t\t\ttxpkt_t *tmp;\n\t\t\twxtd_t *td;\n\n\t\t\ttd = &sc->tdescriptors[cidx];\n\t\t\tif (td->status & TXSTS_EC) {\n\t\t\t\tprintf(\"%s: excess collisions\\n\", sc->wx_name);\n\t\t\t\tifp->if_collisions++;\n\t\t\t\tifp->if_oerrors++;\n\t\t\t}\n\t\t\tif (td->status & TXSTS_LC) {\n\t\t\t\tprintf(\"%s: lost carrier\\n\", sc->wx_name);\n\t\t\t\tifp->if_oerrors++;\n\t\t\t}\n\t\t\ttmp = &sc->tbase[cidx];\n\t\t\tif (sc->wx_debug) {\n\t\t\t\tprintf(\"%s: TXGC[%d] %p %d..%d done nact %d \"\n\t\t\t\t    \"TDH %d\\n\", sc->wx_name, cidx, tmp->dptr,\n\t\t\t\t    txpkt->sidx, txpkt->eidx, sc->tactive, tdh);\n\t\t\t}\n\t\t\ttmp->dptr = NULL;\n\t\t\tif (sc->tactive == 0) {\n\t\t\t\tprintf(\"%s: nactive < 0?\\n\", sc->wx_name);\n\t\t\t} else {\n\t\t\t\tsc->tactive -= 1;\n\t\t\t}\n\t\t\tbzero(td, sizeof (*td));\n\t\t}\n\t\tsc->tbsyf = txpkt->next;\n\t\ttxpkt = sc->tbsyf;\n\t}\n\tif (sc->tactive < WX_MAX_TDESC) {\n\t\tifp->if_timer = 0;\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t}\n\tsplx(s);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wx_gc",
            "wx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));",
            "wx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic void wx_gc;\nwx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));\nwx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic void\nwx_gc(sc)\n\twx_softc_t *sc;\n{\n\tstruct ifnet *ifp = &sc->wx_if;\n\ttxpkt_t *txpkt = sc->tbsyf;\n\tu_int32_t tdh = READ_CSR(sc, WXREG_TDH);\n\tint s;\n\n\ts = splimp();\n\twhile (txpkt != NULL) {\n\t\tu_int32_t end = txpkt->eidx, cidx = tdh;\n\n\t\t/*\n\t\t * Normalize start..end indices to 2 *\n\t \t * WX_MAX_TDESC range to eliminate wrap.\n\t\t */\n\t\tif (txpkt->eidx < txpkt->sidx) {\n\t\t\tend += WX_MAX_TDESC;\n\t\t}\n\n\t\t/*\n\t\t * Normalize current chip index to 2 *\n\t \t * WX_MAX_TDESC range to eliminate wrap.\n\t\t */\n\t\tif (cidx < txpkt->sidx) {\n\t\t\tcidx += WX_MAX_TDESC;\n\t\t}\n\n\t\t/*\n\t\t * If the current chip index is between low and\n\t\t * high indices for this packet, it's not finished\n\t\t * transmitting yet. Because transmits are done FIFO,\n\t\t * this means we're done garbage collecting too.\n\t\t */\n\n\t\tif (txpkt->sidx <= cidx && cidx < txpkt->eidx) {\n\t\t\tif (sc->wx_debug) {\n\t\t\t\tprintf(\"%s: TXGC %d..%d TDH %d\\n\", sc->wx_name,\n\t\t\t\t    txpkt->sidx, txpkt->eidx, tdh);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tifp->if_opackets++;\n\n\t\tif (txpkt->dptr) {\n\t\t\t(void) m_freem(txpkt->dptr);\n\t\t} else {\n\t\t\tprintf(\"%s: null mbuf in gc\\n\", sc->wx_name);\n\t\t}\n\n\t\tfor (cidx = txpkt->sidx; cidx != txpkt->eidx;\n\t\t    cidx = T_NXT_IDX(cidx)) {\n\t\t\ttxpkt_t *tmp;\n\t\t\twxtd_t *td;\n\n\t\t\ttd = &sc->tdescriptors[cidx];\n\t\t\tif (td->status & TXSTS_EC) {\n\t\t\t\tprintf(\"%s: excess collisions\\n\", sc->wx_name);\n\t\t\t\tifp->if_collisions++;\n\t\t\t\tifp->if_oerrors++;\n\t\t\t}\n\t\t\tif (td->status & TXSTS_LC) {\n\t\t\t\tprintf(\"%s: lost carrier\\n\", sc->wx_name);\n\t\t\t\tifp->if_oerrors++;\n\t\t\t}\n\t\t\ttmp = &sc->tbase[cidx];\n\t\t\tif (sc->wx_debug) {\n\t\t\t\tprintf(\"%s: TXGC[%d] %p %d..%d done nact %d \"\n\t\t\t\t    \"TDH %d\\n\", sc->wx_name, cidx, tmp->dptr,\n\t\t\t\t    txpkt->sidx, txpkt->eidx, sc->tactive, tdh);\n\t\t\t}\n\t\t\ttmp->dptr = NULL;\n\t\t\tif (sc->tactive == 0) {\n\t\t\t\tprintf(\"%s: nactive < 0?\\n\", sc->wx_name);\n\t\t\t} else {\n\t\t\t\tsc->tactive -= 1;\n\t\t\t}\n\t\t\tbzero(td, sizeof (*td));\n\t\t}\n\t\tsc->tbsyf = txpkt->next;\n\t\ttxpkt = sc->tbsyf;\n\t}\n\tif (sc->tactive < WX_MAX_TDESC) {\n\t\tifp->if_timer = 0;\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t}\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "mb_head"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_copydata",
          "args": [
            "mb_head",
            "0",
            "mb_head->m_pkthdr.len",
            "mtod(m, caddr_t)"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "caddr_t"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "mb_head"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGETHDR",
          "args": [
            "m",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "mb_head"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SOFTC_IFP",
          "args": [
            "ifp"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic void wx_gc;\nstatic void wx_start;\nwx_eeprom_sobits __P((wx_softc_t *, u_int16_t, u_int16_t));\nstatic INLINE u_int16_t;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nstatic INLINE u_int16_t;\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic void\nwx_start(ifp)\n\tstruct ifnet *ifp;\n{\n\twx_softc_t *sc = SOFTC_IFP(ifp);\n\tu_int16_t cidx, nactv;\n\n\tnactv = sc->tactive;\n\twhile (nactv < WX_MAX_TDESC) {\n\t\tint ndesc;\n\t\tint gctried = 0;\n\t\tstruct mbuf *m, *mb_head;\n\n\t\tIF_DEQUEUE(&ifp->if_snd, mb_head);\n\t\tif (mb_head == NULL) {\n\t\t\tbreak;\n\t\t}\n\t\tsc->wx_xmitwanted++;\n\n\t\t/*\n\t\t * If we have a packet less than ethermin, pad it out.\n\t\t */\n\t\tif (mb_head->m_pkthdr.len < WX_MIN_RPKT_SIZE) {\n\t\t\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\t\t\tif (m == NULL) {\n\t\t\t\tm_freem(mb_head);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tm_copydata(mb_head, 0, mb_head->m_pkthdr.len,\n\t\t\t    mtod(m, caddr_t));\n\t\t\tm->m_pkthdr.len = m->m_len = WX_MIN_RPKT_SIZE;\n\t\t\tbzero(mtod(m, char *) + mb_head->m_pkthdr.len,\n\t\t\t     WX_MIN_RPKT_SIZE - mb_head->m_pkthdr.len);\n\t\t\tsc->wx_xmitpullup++;\n\t\t\tm_freem(mb_head);\n\t\t\tmb_head = m;\n\t\t}\nagain:\n\t\tcidx = sc->tnxtfree;\n\t\tnactv = sc->tactive;\n\n\n\t\t/*\n\t\t * Go through each of the mbufs in the chain and initialize\n\t\t * the transmit buffer descriptors with the physical address\n\t\t * and size of that mbuf. If we have a length less than our\n\t\t * minimum transmit size, we bail (to do a pullup). If we run\n\t\t * out of descriptors, we also bail and try and do a pullup.\n\t\t */\n\t\tfor (ndesc = 0, m = mb_head; m != NULL; m = m->m_next) {\n\t\t\tvm_offset_t vptr;\n\t\t\twxtd_t *td;\n\n\t\t\t/*\n\t\t\t * If this mbuf has no data, skip it.\n\t\t\t */\n\t\t\tif (m->m_len == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If this packet is too small for the chip's minimum,\n\t\t\t * break out to to cluster it.\n\t\t\t */\n\t\t\tif (m->m_len < WX_MIN_RPKT_SIZE) {\n\t\t\t\tsc->wx_xmitrunt++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Do we have a descriptor available for this mbuf?\n\t\t\t */\n\t\t\tif (++nactv == WX_MAX_TDESC) {\n\t\t\t\tif (gctried++ == 0) {\n\t\t\t\t\tsc->wx_xmitgc++;\n\t\t\t\t\twx_gc(sc);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsc->tbase[cidx].dptr = m;\n\t\t\ttd = &sc->tdescriptors[cidx];\n\t\t\ttd->length = m->m_len;\n\n\t\t\tvptr = mtod(m, vm_offset_t);\n\t\t\ttd->address.highpart = 0;\n\t\t\ttd->address.lowpart = vtophys(vptr);\n\n\t\t\ttd->cso = 0;\n\t\t\ttd->status = 0;\n\t\t\ttd->special = 0;\n\t\t\ttd->cmd = 0;\n\t\t\ttd->css = 0;\n\n\t\t\tif (sc->wx_debug) {\n\t\t\t\tprintf(\"%s: XMIT[%d] %p vptr %lx (length %d \"\n\t\t\t\t    \"DMA addr %x) idx %d\\n\", sc->wx_name,\n\t\t\t\t    ndesc, m, (long) vptr, td->length,\n\t\t\t\t    td->address.lowpart, cidx);\n\t\t\t}\n\t\t\tndesc++;\n\t\t\tcidx = T_NXT_IDX(cidx);\n\t\t}\n\n\t\t/*\n\t\t * If we get here and m is NULL, we can send\n\t\t * the the packet chain described by mb_head.\n\t\t */\n\t\tif (m == NULL) {\n\t\t\t/*\n\t\t\t * Mark the last descriptor with EOP and tell the\n\t\t\t * chip to insert a final checksum.\n\t\t\t */\n\t\t\twxtd_t *td = &sc->tdescriptors[T_PREV_IDX(cidx)];\n\t\t\ttd->cmd = TXCMD_EOP|TXCMD_IFCS;\n\n\t\t\tsc->tbase[sc->tnxtfree].sidx = sc->tnxtfree;\n\t\t\tsc->tbase[sc->tnxtfree].eidx = cidx;\n\t\t\tsc->tbase[sc->tnxtfree].next = NULL;\n\t\t\tif (sc->tbsyf) {\n\t\t\t\tsc->tbsyl->next = &sc->tbase[sc->tnxtfree];\n\t\t\t} else {\n\t\t\t\tsc->tbsyf = &sc->tbase[sc->tnxtfree];\n\t\t\t}\n\t\t\tsc->tbsyl = &sc->tbase[sc->tnxtfree];\n\t\t\tsc->tnxtfree = cidx;\n\t\t\tsc->tactive = nactv;\n\t\t\tifp->if_timer = 10;\n\t\t\tWRITE_CSR(sc, WXREG_TDT, cidx);\n\t\t\tif (ifp->if_bpf)\n\t\t\t\tbpf_mtap(WX_BPFTAP_ARG(ifp), mb_head);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Otherwise, we couldn't send this packet for some reason.\n\t\t *\n\t\t * If don't have a descriptor available, and this is a\n\t\t * single mbuf packet, freeze output so that later we\n\t\t * can restart when we have more room. Otherwise, we'll\n\t\t * try and cluster the request. We've already tried to\n\t\t * garbage collect completed descriptors.\n\t\t */\n\t\tif (nactv == WX_MAX_TDESC && mb_head->m_next == NULL) {\n\t\t\tsc->wx_xmitputback++;\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\tIF_PREPEND(&ifp->if_snd, mb_head);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Otherwise, it's either a fragment length somewhere in the\n\t\t * chain that isn't at least WX_MIN_XPKT_SIZE in length or\n\t\t * the number of fragments exceeds the number of descriptors\n\t\t * available.\n\t\t *\n\t\t * We could try a variety of strategies here- if this is\n\t\t * a length problem for single mbuf packet or a length problem\n\t\t * for the last mbuf in a chain (we could just try and adjust\n\t\t * it), but it's just simpler to try and cluster it.\n\t\t */\n\t\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\t\tif (m == NULL) {\n\t\t\tm_freem(mb_head);\n\t\t\tbreak;\n\t\t}\n\t\tMCLGET(m, M_DONTWAIT);\n\t\tif ((m->m_flags & M_EXT) == 0) {\n\t\t\tm_freem(m);\n\t\t\tm_freem(mb_head);\n\t\t\tbreak;\n\t\t}\n\t\tm_copydata(mb_head, 0, mb_head->m_pkthdr.len, mtod(m, caddr_t));\n\t\tm->m_pkthdr.len = m->m_len = mb_head->m_pkthdr.len;\n\t\tm_freem(mb_head);\n\t\tmb_head = m;\n\t\tsc->wx_xmitcluster++;\n\t\tgoto again;\n\t}\n\n\tif (sc->tactive == WX_MAX_TDESC) {\n\t\tsc->wx_xmitblocked++;\n\t\tifp->if_flags |= IFF_OACTIVE;\n\t}\n}"
  },
  {
    "function_name": "wx_read_eeprom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "969-981",
    "snippet": "static void\nwx_read_eeprom(sc, data, offset, words)\n\twx_softc_t *sc;\n\tu_int16_t *data;\n\tint offset;\n\tint words;\n{\n\tint i;\n\tfor (i = 0; i < words; i++) {\n\t\t*data++ = wx_read_eeprom_word(sc, offset++);\n\t}\n\tsc->wx_cfg1 = wx_read_eeprom_word(sc, WX_EEPROM_CTLR1_OFF);\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "wx_eeprom_sobits __P((wx_softc_t *, u_int16_t, u_int16_t));",
      "static INLINE u_int16_t",
      "wx_eeprom_sibits __P((wx_softc_t *));",
      "wx_eeprom_cleanup __P((wx_softc_t *));",
      "static INLINE u_int16_t",
      "wx_read_eeprom_word __P((wx_softc_t *, int));",
      "static void wx_read_eeprom",
      "wx_mwi_whackon\t__P((wx_softc_t *));",
      "wx_mwi_unwhack\t__P((wx_softc_t *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wx_read_eeprom_word",
          "args": [
            "sc",
            "WX_EEPROM_CTLR1_OFF"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "wx_read_eeprom_word",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "955-967",
          "snippet": "static u_int16_t INLINE \nwx_read_eeprom_word(sc, offset)\n\twx_softc_t     *sc;\n\tint             offset;\n{\n\tu_int16_t       data;\n\tWRITE_CSR(sc, WXREG_EECDR, WXEECD_CS);\n\twx_eeprom_sobits(sc, EEPROM_READ_OPCODE, 3);\n\twx_eeprom_sobits(sc, offset, 6);\n\tdata = wx_eeprom_sibits(sc);\n\twx_eeprom_cleanup(sc);\n\treturn (data);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static INLINE void",
            "static INLINE void",
            "static INLINE void",
            "wx_eeprom_sobits __P((wx_softc_t *, u_int16_t, u_int16_t));",
            "static INLINE u_int16_t",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "static INLINE void",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "static INLINE u_int16_t",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "static INLINE void",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "static INLINE void",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic INLINE void;\nstatic INLINE void;\nstatic INLINE void;\nwx_eeprom_sobits __P((wx_softc_t *, u_int16_t, u_int16_t));\nstatic INLINE u_int16_t;\nwx_eeprom_sibits __P((wx_softc_t *));\nstatic INLINE void;\nwx_eeprom_cleanup __P((wx_softc_t *));\nstatic INLINE u_int16_t;\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic INLINE void;\nwx_mwi_whackon\t__P((wx_softc_t *));\nstatic INLINE void;\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic u_int16_t INLINE \nwx_read_eeprom_word(sc, offset)\n\twx_softc_t     *sc;\n\tint             offset;\n{\n\tu_int16_t       data;\n\tWRITE_CSR(sc, WXREG_EECDR, WXEECD_CS);\n\twx_eeprom_sobits(sc, EEPROM_READ_OPCODE, 3);\n\twx_eeprom_sobits(sc, offset, 6);\n\tdata = wx_eeprom_sibits(sc);\n\twx_eeprom_cleanup(sc);\n\treturn (data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nwx_eeprom_sobits __P((wx_softc_t *, u_int16_t, u_int16_t));\nstatic INLINE u_int16_t;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nstatic INLINE u_int16_t;\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic void wx_read_eeprom;\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic void\nwx_read_eeprom(sc, data, offset, words)\n\twx_softc_t *sc;\n\tu_int16_t *data;\n\tint offset;\n\tint words;\n{\n\tint i;\n\tfor (i = 0; i < words; i++) {\n\t\t*data++ = wx_read_eeprom_word(sc, offset++);\n\t}\n\tsc->wx_cfg1 = wx_read_eeprom_word(sc, WX_EEPROM_CTLR1_OFF);\n}"
  },
  {
    "function_name": "wx_read_eeprom_word",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "955-967",
    "snippet": "static u_int16_t INLINE \nwx_read_eeprom_word(sc, offset)\n\twx_softc_t     *sc;\n\tint             offset;\n{\n\tu_int16_t       data;\n\tWRITE_CSR(sc, WXREG_EECDR, WXEECD_CS);\n\twx_eeprom_sobits(sc, EEPROM_READ_OPCODE, 3);\n\twx_eeprom_sobits(sc, offset, 6);\n\tdata = wx_eeprom_sibits(sc);\n\twx_eeprom_cleanup(sc);\n\treturn (data);\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static INLINE void",
      "static INLINE void",
      "static INLINE void",
      "wx_eeprom_sobits __P((wx_softc_t *, u_int16_t, u_int16_t));",
      "static INLINE u_int16_t",
      "wx_eeprom_sibits __P((wx_softc_t *));",
      "static INLINE void",
      "wx_eeprom_cleanup __P((wx_softc_t *));",
      "static INLINE u_int16_t",
      "wx_read_eeprom_word __P((wx_softc_t *, int));",
      "static INLINE void",
      "wx_mwi_whackon\t__P((wx_softc_t *));",
      "static INLINE void",
      "wx_mwi_unwhack\t__P((wx_softc_t *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wx_eeprom_cleanup",
          "args": [
            "sc"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "wx_eeprom_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "944-953",
          "snippet": "static INLINE void\nwx_eeprom_cleanup(sc)\n\twx_softc_t     *sc;\n{\n\tu_int32_t regval;\n\tregval = READ_CSR(sc, WXREG_EECDR) & ~(WXEECD_DI|WXEECD_CS);\n\tWRITE_CSR(sc, WXREG_EECDR, regval); DELAY(50);\n\twx_eeprom_raise_clk(sc, regval);\n\twx_eeprom_lower_clk(sc, regval);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static INLINE void",
            "wx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));",
            "static INLINE void",
            "wx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));",
            "static INLINE void",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "static INLINE void",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "static INLINE void",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "static INLINE void",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic INLINE void;\nwx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));\nstatic INLINE void;\nwx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));\nstatic INLINE void;\nwx_eeprom_sibits __P((wx_softc_t *));\nstatic INLINE void;\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic INLINE void;\nwx_mwi_whackon\t__P((wx_softc_t *));\nstatic INLINE void;\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic INLINE void\nwx_eeprom_cleanup(sc)\n\twx_softc_t     *sc;\n{\n\tu_int32_t regval;\n\tregval = READ_CSR(sc, WXREG_EECDR) & ~(WXEECD_DI|WXEECD_CS);\n\tWRITE_CSR(sc, WXREG_EECDR, regval); DELAY(50);\n\twx_eeprom_raise_clk(sc, regval);\n\twx_eeprom_lower_clk(sc, regval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wx_eeprom_sibits",
          "args": [
            "sc"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "wx_eeprom_sibits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "921-940",
          "snippet": "static INLINE u_int16_t\nwx_eeprom_sibits(sc)\n\twx_softc_t     *sc;\n{\n\tunsigned int regval, i;\n\tu_int16_t data;\n\n\tdata = 0;\n\tregval = READ_CSR(sc, WXREG_EECDR) & ~(WXEECD_DI|WXEECD_DO);\n\tfor (i = 0; i != 16; i++) {\n\t\tdata <<= 1;\n\t\twx_eeprom_raise_clk(sc, regval);\n\t\tregval = READ_CSR(sc, WXREG_EECDR) & ~WXEECD_DI;\n\t\tif (regval & WXEECD_DO) {\n\t\t\tdata |= 1;\n\t\t}\n\t\twx_eeprom_lower_clk(sc, regval);\n\t}\n\treturn (data);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static INLINE void",
            "static INLINE void",
            "static INLINE void",
            "wx_eeprom_sobits __P((wx_softc_t *, u_int16_t, u_int16_t));",
            "static INLINE u_int16_t",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "static INLINE void",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "static INLINE u_int16_t",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "static INLINE void",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "static INLINE void",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic INLINE void;\nstatic INLINE void;\nstatic INLINE void;\nwx_eeprom_sobits __P((wx_softc_t *, u_int16_t, u_int16_t));\nstatic INLINE u_int16_t;\nwx_eeprom_sibits __P((wx_softc_t *));\nstatic INLINE void;\nwx_eeprom_cleanup __P((wx_softc_t *));\nstatic INLINE u_int16_t;\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic INLINE void;\nwx_mwi_whackon\t__P((wx_softc_t *));\nstatic INLINE void;\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic INLINE u_int16_t\nwx_eeprom_sibits(sc)\n\twx_softc_t     *sc;\n{\n\tunsigned int regval, i;\n\tu_int16_t data;\n\n\tdata = 0;\n\tregval = READ_CSR(sc, WXREG_EECDR) & ~(WXEECD_DI|WXEECD_DO);\n\tfor (i = 0; i != 16; i++) {\n\t\tdata <<= 1;\n\t\twx_eeprom_raise_clk(sc, regval);\n\t\tregval = READ_CSR(sc, WXREG_EECDR) & ~WXEECD_DI;\n\t\tif (regval & WXEECD_DO) {\n\t\t\tdata |= 1;\n\t\t}\n\t\twx_eeprom_lower_clk(sc, regval);\n\t}\n\treturn (data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wx_eeprom_sobits",
          "args": [
            "sc",
            "offset",
            "6"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "wx_eeprom_sobits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "896-918",
          "snippet": "static INLINE void\nwx_eeprom_sobits(sc, data, count)\n\twx_softc_t     *sc;\n\tu_int16_t\tdata;\n\tu_int16_t\tcount;\n{\n\tu_int32_t regval, mask;\n\n\tmask = 1 << (count - 1);\n\tregval = READ_CSR(sc, WXREG_EECDR) & ~(WXEECD_DI|WXEECD_DO);\n\n\tdo {\n\t\tif (data & mask)\n\t\t\tregval |= WXEECD_DI;\n\t\telse\n\t\t\tregval &= ~WXEECD_DI;\n\t\tWRITE_CSR(sc, WXREG_EECDR, regval); DELAY(50);\n\t\twx_eeprom_raise_clk(sc, regval);\n\t\twx_eeprom_lower_clk(sc, regval);\n\t\tmask >>= 1;\n\t} while (mask != 0);\n\tWRITE_CSR(sc, WXREG_EECDR, regval & ~WXEECD_DI);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static INLINE void",
            "wx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));",
            "static INLINE void",
            "wx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));",
            "static INLINE void",
            "wx_eeprom_sobits __P((wx_softc_t *, u_int16_t, u_int16_t));",
            "static INLINE u_int16_t",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "static INLINE void",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "static INLINE u_int16_t",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "static INLINE void",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "static INLINE void",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic INLINE void;\nwx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));\nstatic INLINE void;\nwx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));\nstatic INLINE void;\nwx_eeprom_sobits __P((wx_softc_t *, u_int16_t, u_int16_t));\nstatic INLINE u_int16_t;\nwx_eeprom_sibits __P((wx_softc_t *));\nstatic INLINE void;\nwx_eeprom_cleanup __P((wx_softc_t *));\nstatic INLINE u_int16_t;\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic INLINE void;\nwx_mwi_whackon\t__P((wx_softc_t *));\nstatic INLINE void;\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic INLINE void\nwx_eeprom_sobits(sc, data, count)\n\twx_softc_t     *sc;\n\tu_int16_t\tdata;\n\tu_int16_t\tcount;\n{\n\tu_int32_t regval, mask;\n\n\tmask = 1 << (count - 1);\n\tregval = READ_CSR(sc, WXREG_EECDR) & ~(WXEECD_DI|WXEECD_DO);\n\n\tdo {\n\t\tif (data & mask)\n\t\t\tregval |= WXEECD_DI;\n\t\telse\n\t\t\tregval &= ~WXEECD_DI;\n\t\tWRITE_CSR(sc, WXREG_EECDR, regval); DELAY(50);\n\t\twx_eeprom_raise_clk(sc, regval);\n\t\twx_eeprom_lower_clk(sc, regval);\n\t\tmask >>= 1;\n\t} while (mask != 0);\n\tWRITE_CSR(sc, WXREG_EECDR, regval & ~WXEECD_DI);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_EECDR",
            "WXEECD_CS"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic INLINE void;\nstatic INLINE void;\nstatic INLINE void;\nwx_eeprom_sobits __P((wx_softc_t *, u_int16_t, u_int16_t));\nstatic INLINE u_int16_t;\nwx_eeprom_sibits __P((wx_softc_t *));\nstatic INLINE void;\nwx_eeprom_cleanup __P((wx_softc_t *));\nstatic INLINE u_int16_t;\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic INLINE void;\nwx_mwi_whackon\t__P((wx_softc_t *));\nstatic INLINE void;\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic u_int16_t INLINE \nwx_read_eeprom_word(sc, offset)\n\twx_softc_t     *sc;\n\tint             offset;\n{\n\tu_int16_t       data;\n\tWRITE_CSR(sc, WXREG_EECDR, WXEECD_CS);\n\twx_eeprom_sobits(sc, EEPROM_READ_OPCODE, 3);\n\twx_eeprom_sobits(sc, offset, 6);\n\tdata = wx_eeprom_sibits(sc);\n\twx_eeprom_cleanup(sc);\n\treturn (data);\n}"
  },
  {
    "function_name": "wx_eeprom_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "944-953",
    "snippet": "static INLINE void\nwx_eeprom_cleanup(sc)\n\twx_softc_t     *sc;\n{\n\tu_int32_t regval;\n\tregval = READ_CSR(sc, WXREG_EECDR) & ~(WXEECD_DI|WXEECD_CS);\n\tWRITE_CSR(sc, WXREG_EECDR, regval); DELAY(50);\n\twx_eeprom_raise_clk(sc, regval);\n\twx_eeprom_lower_clk(sc, regval);\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static INLINE void",
      "wx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));",
      "static INLINE void",
      "wx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));",
      "static INLINE void",
      "wx_eeprom_sibits __P((wx_softc_t *));",
      "static INLINE void",
      "wx_eeprom_cleanup __P((wx_softc_t *));",
      "wx_read_eeprom_word __P((wx_softc_t *, int));",
      "static INLINE void",
      "wx_mwi_whackon\t__P((wx_softc_t *));",
      "static INLINE void",
      "wx_mwi_unwhack\t__P((wx_softc_t *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wx_eeprom_lower_clk",
          "args": [
            "sc",
            "regval"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "wx_eeprom_lower_clk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "887-894",
          "snippet": "static INLINE void\nwx_eeprom_lower_clk(sc, regval)\n\twx_softc_t     *sc;\n\tu_int32_t\tregval;\n{\n\tWRITE_CSR(sc, WXREG_EECDR, regval & ~WXEECD_SK);\n\tDELAY(50);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static INLINE void",
            "wx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));",
            "static INLINE void",
            "wx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));",
            "static INLINE void",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "static INLINE void",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "static INLINE void",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "static INLINE void",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic INLINE void;\nwx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));\nstatic INLINE void;\nwx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));\nstatic INLINE void;\nwx_eeprom_sibits __P((wx_softc_t *));\nstatic INLINE void;\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic INLINE void;\nwx_mwi_whackon\t__P((wx_softc_t *));\nstatic INLINE void;\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic INLINE void\nwx_eeprom_lower_clk(sc, regval)\n\twx_softc_t     *sc;\n\tu_int32_t\tregval;\n{\n\tWRITE_CSR(sc, WXREG_EECDR, regval & ~WXEECD_SK);\n\tDELAY(50);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wx_eeprom_raise_clk",
          "args": [
            "sc",
            "regval"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "wx_eeprom_raise_clk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "878-885",
          "snippet": "static INLINE void\nwx_eeprom_raise_clk(sc, regval)\n\twx_softc_t     *sc;\n\tu_int32_t\tregval;\n{\n\tWRITE_CSR(sc, WXREG_EECDR, regval | WXEECD_SK);\n\tDELAY(50);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static INLINE void",
            "wx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));",
            "static INLINE void",
            "wx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));",
            "static INLINE void",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "static INLINE void",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "static INLINE void",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "static INLINE void",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic INLINE void;\nwx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));\nstatic INLINE void;\nwx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));\nstatic INLINE void;\nwx_eeprom_sibits __P((wx_softc_t *));\nstatic INLINE void;\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic INLINE void;\nwx_mwi_whackon\t__P((wx_softc_t *));\nstatic INLINE void;\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic INLINE void\nwx_eeprom_raise_clk(sc, regval)\n\twx_softc_t     *sc;\n\tu_int32_t\tregval;\n{\n\tWRITE_CSR(sc, WXREG_EECDR, regval | WXEECD_SK);\n\tDELAY(50);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "50"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_EECDR",
            "regval"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_CSR",
          "args": [
            "sc",
            "WXREG_EECDR"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic INLINE void;\nwx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));\nstatic INLINE void;\nwx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));\nstatic INLINE void;\nwx_eeprom_sibits __P((wx_softc_t *));\nstatic INLINE void;\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic INLINE void;\nwx_mwi_whackon\t__P((wx_softc_t *));\nstatic INLINE void;\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic INLINE void\nwx_eeprom_cleanup(sc)\n\twx_softc_t     *sc;\n{\n\tu_int32_t regval;\n\tregval = READ_CSR(sc, WXREG_EECDR) & ~(WXEECD_DI|WXEECD_CS);\n\tWRITE_CSR(sc, WXREG_EECDR, regval); DELAY(50);\n\twx_eeprom_raise_clk(sc, regval);\n\twx_eeprom_lower_clk(sc, regval);\n}"
  },
  {
    "function_name": "wx_eeprom_sibits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "921-940",
    "snippet": "static INLINE u_int16_t\nwx_eeprom_sibits(sc)\n\twx_softc_t     *sc;\n{\n\tunsigned int regval, i;\n\tu_int16_t data;\n\n\tdata = 0;\n\tregval = READ_CSR(sc, WXREG_EECDR) & ~(WXEECD_DI|WXEECD_DO);\n\tfor (i = 0; i != 16; i++) {\n\t\tdata <<= 1;\n\t\twx_eeprom_raise_clk(sc, regval);\n\t\tregval = READ_CSR(sc, WXREG_EECDR) & ~WXEECD_DI;\n\t\tif (regval & WXEECD_DO) {\n\t\t\tdata |= 1;\n\t\t}\n\t\twx_eeprom_lower_clk(sc, regval);\n\t}\n\treturn (data);\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static INLINE void",
      "static INLINE void",
      "static INLINE void",
      "wx_eeprom_sobits __P((wx_softc_t *, u_int16_t, u_int16_t));",
      "static INLINE u_int16_t",
      "wx_eeprom_sibits __P((wx_softc_t *));",
      "static INLINE void",
      "wx_eeprom_cleanup __P((wx_softc_t *));",
      "static INLINE u_int16_t",
      "wx_read_eeprom_word __P((wx_softc_t *, int));",
      "static INLINE void",
      "wx_mwi_whackon\t__P((wx_softc_t *));",
      "static INLINE void",
      "wx_mwi_unwhack\t__P((wx_softc_t *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wx_eeprom_lower_clk",
          "args": [
            "sc",
            "regval"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "wx_eeprom_lower_clk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "887-894",
          "snippet": "static INLINE void\nwx_eeprom_lower_clk(sc, regval)\n\twx_softc_t     *sc;\n\tu_int32_t\tregval;\n{\n\tWRITE_CSR(sc, WXREG_EECDR, regval & ~WXEECD_SK);\n\tDELAY(50);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static INLINE void",
            "wx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));",
            "static INLINE void",
            "wx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));",
            "static INLINE void",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "static INLINE void",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "static INLINE void",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "static INLINE void",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic INLINE void;\nwx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));\nstatic INLINE void;\nwx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));\nstatic INLINE void;\nwx_eeprom_sibits __P((wx_softc_t *));\nstatic INLINE void;\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic INLINE void;\nwx_mwi_whackon\t__P((wx_softc_t *));\nstatic INLINE void;\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic INLINE void\nwx_eeprom_lower_clk(sc, regval)\n\twx_softc_t     *sc;\n\tu_int32_t\tregval;\n{\n\tWRITE_CSR(sc, WXREG_EECDR, regval & ~WXEECD_SK);\n\tDELAY(50);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_CSR",
          "args": [
            "sc",
            "WXREG_EECDR"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wx_eeprom_raise_clk",
          "args": [
            "sc",
            "regval"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "wx_eeprom_raise_clk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "878-885",
          "snippet": "static INLINE void\nwx_eeprom_raise_clk(sc, regval)\n\twx_softc_t     *sc;\n\tu_int32_t\tregval;\n{\n\tWRITE_CSR(sc, WXREG_EECDR, regval | WXEECD_SK);\n\tDELAY(50);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static INLINE void",
            "wx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));",
            "static INLINE void",
            "wx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));",
            "static INLINE void",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "static INLINE void",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "static INLINE void",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "static INLINE void",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic INLINE void;\nwx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));\nstatic INLINE void;\nwx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));\nstatic INLINE void;\nwx_eeprom_sibits __P((wx_softc_t *));\nstatic INLINE void;\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic INLINE void;\nwx_mwi_whackon\t__P((wx_softc_t *));\nstatic INLINE void;\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic INLINE void\nwx_eeprom_raise_clk(sc, regval)\n\twx_softc_t     *sc;\n\tu_int32_t\tregval;\n{\n\tWRITE_CSR(sc, WXREG_EECDR, regval | WXEECD_SK);\n\tDELAY(50);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_CSR",
          "args": [
            "sc",
            "WXREG_EECDR"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic INLINE void;\nstatic INLINE void;\nstatic INLINE void;\nwx_eeprom_sobits __P((wx_softc_t *, u_int16_t, u_int16_t));\nstatic INLINE u_int16_t;\nwx_eeprom_sibits __P((wx_softc_t *));\nstatic INLINE void;\nwx_eeprom_cleanup __P((wx_softc_t *));\nstatic INLINE u_int16_t;\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic INLINE void;\nwx_mwi_whackon\t__P((wx_softc_t *));\nstatic INLINE void;\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic INLINE u_int16_t\nwx_eeprom_sibits(sc)\n\twx_softc_t     *sc;\n{\n\tunsigned int regval, i;\n\tu_int16_t data;\n\n\tdata = 0;\n\tregval = READ_CSR(sc, WXREG_EECDR) & ~(WXEECD_DI|WXEECD_DO);\n\tfor (i = 0; i != 16; i++) {\n\t\tdata <<= 1;\n\t\twx_eeprom_raise_clk(sc, regval);\n\t\tregval = READ_CSR(sc, WXREG_EECDR) & ~WXEECD_DI;\n\t\tif (regval & WXEECD_DO) {\n\t\t\tdata |= 1;\n\t\t}\n\t\twx_eeprom_lower_clk(sc, regval);\n\t}\n\treturn (data);\n}"
  },
  {
    "function_name": "wx_eeprom_sobits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "896-918",
    "snippet": "static INLINE void\nwx_eeprom_sobits(sc, data, count)\n\twx_softc_t     *sc;\n\tu_int16_t\tdata;\n\tu_int16_t\tcount;\n{\n\tu_int32_t regval, mask;\n\n\tmask = 1 << (count - 1);\n\tregval = READ_CSR(sc, WXREG_EECDR) & ~(WXEECD_DI|WXEECD_DO);\n\n\tdo {\n\t\tif (data & mask)\n\t\t\tregval |= WXEECD_DI;\n\t\telse\n\t\t\tregval &= ~WXEECD_DI;\n\t\tWRITE_CSR(sc, WXREG_EECDR, regval); DELAY(50);\n\t\twx_eeprom_raise_clk(sc, regval);\n\t\twx_eeprom_lower_clk(sc, regval);\n\t\tmask >>= 1;\n\t} while (mask != 0);\n\tWRITE_CSR(sc, WXREG_EECDR, regval & ~WXEECD_DI);\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static INLINE void",
      "wx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));",
      "static INLINE void",
      "wx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));",
      "static INLINE void",
      "wx_eeprom_sobits __P((wx_softc_t *, u_int16_t, u_int16_t));",
      "static INLINE u_int16_t",
      "wx_eeprom_sibits __P((wx_softc_t *));",
      "static INLINE void",
      "wx_eeprom_cleanup __P((wx_softc_t *));",
      "static INLINE u_int16_t",
      "wx_read_eeprom_word __P((wx_softc_t *, int));",
      "static INLINE void",
      "wx_mwi_whackon\t__P((wx_softc_t *));",
      "static INLINE void",
      "wx_mwi_unwhack\t__P((wx_softc_t *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_EECDR",
            "regval & ~WXEECD_DI"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wx_eeprom_lower_clk",
          "args": [
            "sc",
            "regval"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "wx_eeprom_lower_clk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "887-894",
          "snippet": "static INLINE void\nwx_eeprom_lower_clk(sc, regval)\n\twx_softc_t     *sc;\n\tu_int32_t\tregval;\n{\n\tWRITE_CSR(sc, WXREG_EECDR, regval & ~WXEECD_SK);\n\tDELAY(50);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static INLINE void",
            "wx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));",
            "static INLINE void",
            "wx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));",
            "static INLINE void",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "static INLINE void",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "static INLINE void",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "static INLINE void",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic INLINE void;\nwx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));\nstatic INLINE void;\nwx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));\nstatic INLINE void;\nwx_eeprom_sibits __P((wx_softc_t *));\nstatic INLINE void;\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic INLINE void;\nwx_mwi_whackon\t__P((wx_softc_t *));\nstatic INLINE void;\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic INLINE void\nwx_eeprom_lower_clk(sc, regval)\n\twx_softc_t     *sc;\n\tu_int32_t\tregval;\n{\n\tWRITE_CSR(sc, WXREG_EECDR, regval & ~WXEECD_SK);\n\tDELAY(50);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wx_eeprom_raise_clk",
          "args": [
            "sc",
            "regval"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "wx_eeprom_raise_clk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "878-885",
          "snippet": "static INLINE void\nwx_eeprom_raise_clk(sc, regval)\n\twx_softc_t     *sc;\n\tu_int32_t\tregval;\n{\n\tWRITE_CSR(sc, WXREG_EECDR, regval | WXEECD_SK);\n\tDELAY(50);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static INLINE void",
            "wx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));",
            "static INLINE void",
            "wx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));",
            "static INLINE void",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "static INLINE void",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "static INLINE void",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "static INLINE void",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic INLINE void;\nwx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));\nstatic INLINE void;\nwx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));\nstatic INLINE void;\nwx_eeprom_sibits __P((wx_softc_t *));\nstatic INLINE void;\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic INLINE void;\nwx_mwi_whackon\t__P((wx_softc_t *));\nstatic INLINE void;\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic INLINE void\nwx_eeprom_raise_clk(sc, regval)\n\twx_softc_t     *sc;\n\tu_int32_t\tregval;\n{\n\tWRITE_CSR(sc, WXREG_EECDR, regval | WXEECD_SK);\n\tDELAY(50);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "50"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_EECDR",
            "regval"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_CSR",
          "args": [
            "sc",
            "WXREG_EECDR"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic INLINE void;\nwx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));\nstatic INLINE void;\nwx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));\nstatic INLINE void;\nwx_eeprom_sobits __P((wx_softc_t *, u_int16_t, u_int16_t));\nstatic INLINE u_int16_t;\nwx_eeprom_sibits __P((wx_softc_t *));\nstatic INLINE void;\nwx_eeprom_cleanup __P((wx_softc_t *));\nstatic INLINE u_int16_t;\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic INLINE void;\nwx_mwi_whackon\t__P((wx_softc_t *));\nstatic INLINE void;\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic INLINE void\nwx_eeprom_sobits(sc, data, count)\n\twx_softc_t     *sc;\n\tu_int16_t\tdata;\n\tu_int16_t\tcount;\n{\n\tu_int32_t regval, mask;\n\n\tmask = 1 << (count - 1);\n\tregval = READ_CSR(sc, WXREG_EECDR) & ~(WXEECD_DI|WXEECD_DO);\n\n\tdo {\n\t\tif (data & mask)\n\t\t\tregval |= WXEECD_DI;\n\t\telse\n\t\t\tregval &= ~WXEECD_DI;\n\t\tWRITE_CSR(sc, WXREG_EECDR, regval); DELAY(50);\n\t\twx_eeprom_raise_clk(sc, regval);\n\t\twx_eeprom_lower_clk(sc, regval);\n\t\tmask >>= 1;\n\t} while (mask != 0);\n\tWRITE_CSR(sc, WXREG_EECDR, regval & ~WXEECD_DI);\n}"
  },
  {
    "function_name": "wx_eeprom_lower_clk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "887-894",
    "snippet": "static INLINE void\nwx_eeprom_lower_clk(sc, regval)\n\twx_softc_t     *sc;\n\tu_int32_t\tregval;\n{\n\tWRITE_CSR(sc, WXREG_EECDR, regval & ~WXEECD_SK);\n\tDELAY(50);\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static INLINE void",
      "wx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));",
      "static INLINE void",
      "wx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));",
      "static INLINE void",
      "wx_eeprom_sibits __P((wx_softc_t *));",
      "static INLINE void",
      "wx_eeprom_cleanup __P((wx_softc_t *));",
      "wx_read_eeprom_word __P((wx_softc_t *, int));",
      "static INLINE void",
      "wx_mwi_whackon\t__P((wx_softc_t *));",
      "static INLINE void",
      "wx_mwi_unwhack\t__P((wx_softc_t *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "50"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_EECDR",
            "regval & ~WXEECD_SK"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic INLINE void;\nwx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));\nstatic INLINE void;\nwx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));\nstatic INLINE void;\nwx_eeprom_sibits __P((wx_softc_t *));\nstatic INLINE void;\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic INLINE void;\nwx_mwi_whackon\t__P((wx_softc_t *));\nstatic INLINE void;\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic INLINE void\nwx_eeprom_lower_clk(sc, regval)\n\twx_softc_t     *sc;\n\tu_int32_t\tregval;\n{\n\tWRITE_CSR(sc, WXREG_EECDR, regval & ~WXEECD_SK);\n\tDELAY(50);\n}"
  },
  {
    "function_name": "wx_eeprom_raise_clk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "878-885",
    "snippet": "static INLINE void\nwx_eeprom_raise_clk(sc, regval)\n\twx_softc_t     *sc;\n\tu_int32_t\tregval;\n{\n\tWRITE_CSR(sc, WXREG_EECDR, regval | WXEECD_SK);\n\tDELAY(50);\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static INLINE void",
      "wx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));",
      "static INLINE void",
      "wx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));",
      "static INLINE void",
      "wx_eeprom_sibits __P((wx_softc_t *));",
      "static INLINE void",
      "wx_eeprom_cleanup __P((wx_softc_t *));",
      "wx_read_eeprom_word __P((wx_softc_t *, int));",
      "static INLINE void",
      "wx_mwi_whackon\t__P((wx_softc_t *));",
      "static INLINE void",
      "wx_mwi_unwhack\t__P((wx_softc_t *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "50"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_CSR",
          "args": [
            "sc",
            "WXREG_EECDR",
            "regval | WXEECD_SK"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic INLINE void;\nwx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));\nstatic INLINE void;\nwx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));\nstatic INLINE void;\nwx_eeprom_sibits __P((wx_softc_t *));\nstatic INLINE void;\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic INLINE void;\nwx_mwi_whackon\t__P((wx_softc_t *));\nstatic INLINE void;\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic INLINE void\nwx_eeprom_raise_clk(sc, regval)\n\twx_softc_t     *sc;\n\tu_int32_t\tregval;\n{\n\tWRITE_CSR(sc, WXREG_EECDR, regval | WXEECD_SK);\n\tDELAY(50);\n}"
  },
  {
    "function_name": "wx_attach_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "778-872",
    "snippet": "static int\nwx_attach_common(sc)\n\twx_softc_t *sc;\n{\n\tsize_t len;\n\tu_int32_t tmp;\n\tint ll = 0;\n\n\t/*\n\t * First, reset the chip.\n\t */\n\twx_hw_stop(sc);\n\n\t/*\n\t * Second, validate our EEPROM.\n\t */\n\n\t/* TBD */\n\n\t/*\n\t * Third, read eeprom for our MAC address and other things.\n\t */\n\twx_read_eeprom(sc, (u_int16_t *)sc->wx_enaddr, WX_EEPROM_MAC_OFF, 3);\n\n\t/*\n\t * Fourth, establish some adapter parameters.\n\t */\n\tsc->wx_txint_delay = 128;\n\tifmedia_init(&sc->wx_media, IFM_IMASK, wx_ifmedia_upd, wx_ifmedia_sts);\n\tifmedia_add(&sc->wx_media, IFM_ETHER|IFM_1000_SX, 0, NULL);\n\tifmedia_add(&sc->wx_media, IFM_ETHER|IFM_1000_SX|IFM_FDX, 0, NULL);\n\tifmedia_set(&sc->wx_media, IFM_ETHER|IFM_1000_SX|IFM_FDX);\n\tsc->wx_media.ifm_media = sc->wx_media.ifm_cur->ifm_media;\n\tll += 1;\n\n\t/*\n\t * Fifth, establish a default device control register word.\n\t */\n\tsc->wx_dcr = 0;\n\tif (sc->wx_cfg1 & WX_EEPROM_CTLR1_FD)\n\t\tsc->wx_dcr |= WXDCR_FD;\n\tif (sc->wx_cfg1 & WX_EEPROM_CTLR1_ILOS)\n\t\tsc->wx_dcr |= WXDCR_ILOS;\n\n\ttmp = (sc->wx_cfg1 >> WX_EEPROM_CTLR1_SWDPIO_SHIFT) & WXDCR_SWDPIO_MASK;\n\tsc->wx_dcr |= (tmp << WXDCR_SWDPIO_SHIFT);\n\n\tif (sc->wx_no_ilos)\n\t\tsc->wx_dcr &= ~WXDCR_ILOS;\n\tif (sc->wx_ilos)\n\t\tsc->wx_dcr |= WXDCR_ILOS;\n\tif (sc->wx_no_flow == 0)\n\t\tsc->wx_dcr |= WXDCR_RFCE | WXDCR_TFCE;\n\n\n\t/*\n\t * Sixth, allocate various sw structures...\n\t */\n\tlen = sizeof (rxpkt_t) * WX_MAX_RDESC;\n\tsc->rbase = (rxpkt_t *) WXMALLOC(len);\n\tif (sc->rbase == NULL) {\n                goto fail;\n\t}\n        bzero(sc->rbase, len);\n\tll += 1;\n\n\tlen = sizeof (txpkt_t) * WX_MAX_TDESC;\n\tsc->tbase = (txpkt_t *) WXMALLOC(len);\n        if (sc->tbase == NULL) {\n                goto fail;\n\t}\n        bzero(sc->tbase, len);\n\tll += 1;\n\n\t/*\n\t * Seventh, allocate and dma map (platform dependent) descriptor rings.\n\t * They have to be aligned on a 4KB boundary.\n\t */\n\tif (wx_dring_setup(sc) == 0) {\n\t\treturn (0);\n\t}\n\nfail:\n\tprintf(\"%s: failed to do common attach (%d)\\n\", sc->wx_name, ll);\n\twx_dring_teardown(sc);\n\tif (sc->rbase) {\n\t\tWXFREE(sc->rbase);\n\t\tsc->rbase = NULL;\n\t}\n\tif (sc->tbase) {\n\t\tWXFREE(sc->tbase);\n\t\tsc->tbase = NULL;\n\t}\n\treturn (ENOMEM);\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int wx_ifmedia_upd",
      "static void wx_ifmedia_sts",
      "static void wx_hw_stop",
      "wx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));",
      "wx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));",
      "wx_eeprom_sobits __P((wx_softc_t *, u_int16_t, u_int16_t));",
      "static INLINE u_int16_t",
      "wx_eeprom_sibits __P((wx_softc_t *));",
      "wx_eeprom_cleanup __P((wx_softc_t *));",
      "static INLINE u_int16_t",
      "wx_read_eeprom_word __P((wx_softc_t *, int));",
      "static void wx_read_eeprom",
      "static int wx_attach_common",
      "wx_mwi_whackon\t__P((wx_softc_t *));",
      "wx_mwi_unwhack\t__P((wx_softc_t *));",
      "static int wx_dring_setup",
      "static void wx_dring_teardown"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WXFREE",
          "args": [
            "sc->tbase"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WXFREE",
          "args": [
            "sc->rbase"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wx_dring_teardown",
          "args": [
            "sc"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "wx_dring_teardown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "743-755",
          "snippet": "static void\nwx_dring_teardown(sc)\n\twx_softc_t *sc;\n{\n\tif (sc->rdescriptors) {\n\t\tWXFREE(sc->rdescriptors);\n\t\tsc->rdescriptors = NULL;\n\t}\n\tif (sc->tdescriptors) {\n\t\tWXFREE(sc->tdescriptors);\n\t\tsc->tdescriptors = NULL;\n\t}\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));",
            "static void wx_dring_teardown"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\nstatic void wx_dring_teardown;\n\nstatic void\nwx_dring_teardown(sc)\n\twx_softc_t *sc;\n{\n\tif (sc->rdescriptors) {\n\t\tWXFREE(sc->rdescriptors);\n\t\tsc->rdescriptors = NULL;\n\t}\n\tif (sc->tdescriptors) {\n\t\tWXFREE(sc->tdescriptors);\n\t\tsc->tdescriptors = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: failed to do common attach (%d)\\n\"",
            "sc->wx_name",
            "ll"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wx_dring_setup",
          "args": [
            "sc"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "wx_dring_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "709-741",
          "snippet": "static int\nwx_dring_setup(sc)\n\twx_softc_t *sc;\n{\n\tsize_t len;\n\n\tlen = sizeof (wxrd_t) * WX_MAX_RDESC;\n\tsc->rdescriptors = (wxrd_t *)\n\t    contigmalloc(len, M_DEVBUF, M_NOWAIT, 0, ~0, 4096, 0);\n\tif (sc->rdescriptors == NULL) {\n\t\tprintf(\"%s: could not allocate rcv descriptors\\n\", sc->wx_name);\n\t\treturn (-1);\n\t}\n\tif (((u_long)sc->rdescriptors) & 0xfff) {\n\t\tprintf(\"%s: rcv descriptors not 4KB aligned\\n\", sc->wx_name);\n\t\treturn (-1);\n\t}\n        bzero(sc->rdescriptors, len);\n\n\tlen = sizeof (wxtd_t) * WX_MAX_TDESC;\n\tsc->tdescriptors = (wxtd_t *)\n\t    contigmalloc(len, M_DEVBUF, M_NOWAIT, 0, ~0, 4096, 0);\n\tif (sc->tdescriptors == NULL) {\n\t\tprintf(\"%s: could not allocate xmt descriptors\\n\", sc->wx_name);\n\t\treturn (-1);\n\t}\n\tif (((u_long)sc->tdescriptors) & 0xfff) {\n\t\tprintf(\"%s: xmt descriptors not 4KB aligned\\n\", sc->wx_name);\n\t\treturn (-1);\n\t}\n        bzero(sc->tdescriptors, len);\n\treturn (0);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));",
            "static int wx_dring_setup"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\nstatic int wx_dring_setup;\n\nstatic int\nwx_dring_setup(sc)\n\twx_softc_t *sc;\n{\n\tsize_t len;\n\n\tlen = sizeof (wxrd_t) * WX_MAX_RDESC;\n\tsc->rdescriptors = (wxrd_t *)\n\t    contigmalloc(len, M_DEVBUF, M_NOWAIT, 0, ~0, 4096, 0);\n\tif (sc->rdescriptors == NULL) {\n\t\tprintf(\"%s: could not allocate rcv descriptors\\n\", sc->wx_name);\n\t\treturn (-1);\n\t}\n\tif (((u_long)sc->rdescriptors) & 0xfff) {\n\t\tprintf(\"%s: rcv descriptors not 4KB aligned\\n\", sc->wx_name);\n\t\treturn (-1);\n\t}\n        bzero(sc->rdescriptors, len);\n\n\tlen = sizeof (wxtd_t) * WX_MAX_TDESC;\n\tsc->tdescriptors = (wxtd_t *)\n\t    contigmalloc(len, M_DEVBUF, M_NOWAIT, 0, ~0, 4096, 0);\n\tif (sc->tdescriptors == NULL) {\n\t\tprintf(\"%s: could not allocate xmt descriptors\\n\", sc->wx_name);\n\t\treturn (-1);\n\t}\n\tif (((u_long)sc->tdescriptors) & 0xfff) {\n\t\tprintf(\"%s: xmt descriptors not 4KB aligned\\n\", sc->wx_name);\n\t\treturn (-1);\n\t}\n        bzero(sc->tdescriptors, len);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "sc->tbase",
            "len"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WXMALLOC",
          "args": [
            "len"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "sc->rbase",
            "len"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WXMALLOC",
          "args": [
            "len"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_set",
          "args": [
            "&sc->wx_media",
            "IFM_ETHER|IFM_1000_SX|IFM_FDX"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->wx_media",
            "IFM_ETHER|IFM_1000_SX|IFM_FDX",
            "0",
            "NULL"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->wx_media",
            "IFM_ETHER|IFM_1000_SX",
            "0",
            "NULL"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_init",
          "args": [
            "&sc->wx_media",
            "IFM_IMASK",
            "wx_ifmedia_upd",
            "wx_ifmedia_sts"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wx_read_eeprom",
          "args": [
            "sc",
            "(u_int16_t *)sc->wx_enaddr",
            "WX_EEPROM_MAC_OFF",
            "3"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "wx_read_eeprom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "969-981",
          "snippet": "static void\nwx_read_eeprom(sc, data, offset, words)\n\twx_softc_t *sc;\n\tu_int16_t *data;\n\tint offset;\n\tint words;\n{\n\tint i;\n\tfor (i = 0; i < words; i++) {\n\t\t*data++ = wx_read_eeprom_word(sc, offset++);\n\t}\n\tsc->wx_cfg1 = wx_read_eeprom_word(sc, WX_EEPROM_CTLR1_OFF);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "wx_eeprom_sobits __P((wx_softc_t *, u_int16_t, u_int16_t));",
            "static INLINE u_int16_t",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "static INLINE u_int16_t",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "static void wx_read_eeprom",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nwx_eeprom_sobits __P((wx_softc_t *, u_int16_t, u_int16_t));\nstatic INLINE u_int16_t;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nstatic INLINE u_int16_t;\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic void wx_read_eeprom;\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic void\nwx_read_eeprom(sc, data, offset, words)\n\twx_softc_t *sc;\n\tu_int16_t *data;\n\tint offset;\n\tint words;\n{\n\tint i;\n\tfor (i = 0; i < words; i++) {\n\t\t*data++ = wx_read_eeprom_word(sc, offset++);\n\t}\n\tsc->wx_cfg1 = wx_read_eeprom_word(sc, WX_EEPROM_CTLR1_OFF);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wx_hw_stop",
          "args": [
            "sc"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "wx_hw_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "1515-1531",
          "snippet": "static void\nwx_hw_stop(sc)\n\twx_softc_t *sc;\n{\n\tu_int32_t icr;\n\tif (sc->revision == 2) {\n\t\twx_mwi_whackon(sc);\n\t}\n\tWRITE_CSR(sc, WXREG_DCR, WXDCR_RST);\n\tDELAY(20 * 1000);\n\tWRITE_CSR(sc, WXREG_IMASK, ~0);\n\ticr = READ_CSR(sc, WXREG_ICR);\n\tif (sc->revision == 2) {\n\t\twx_mwi_unwhack(sc);\n\t}\n\tWX_DISABLE_INT(sc);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wx_hw_stop",
            "wx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));",
            "wx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic void wx_hw_stop;\nwx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));\nwx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic void\nwx_hw_stop(sc)\n\twx_softc_t *sc;\n{\n\tu_int32_t icr;\n\tif (sc->revision == 2) {\n\t\twx_mwi_whackon(sc);\n\t}\n\tWRITE_CSR(sc, WXREG_DCR, WXDCR_RST);\n\tDELAY(20 * 1000);\n\tWRITE_CSR(sc, WXREG_IMASK, ~0);\n\ticr = READ_CSR(sc, WXREG_ICR);\n\tif (sc->revision == 2) {\n\t\twx_mwi_unwhack(sc);\n\t}\n\tWX_DISABLE_INT(sc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic int wx_ifmedia_upd;\nstatic void wx_ifmedia_sts;\nstatic void wx_hw_stop;\nwx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));\nwx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));\nwx_eeprom_sobits __P((wx_softc_t *, u_int16_t, u_int16_t));\nstatic INLINE u_int16_t;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nstatic INLINE u_int16_t;\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic void wx_read_eeprom;\nstatic int wx_attach_common;\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\nstatic int wx_dring_setup;\nstatic void wx_dring_teardown;\n\nstatic int\nwx_attach_common(sc)\n\twx_softc_t *sc;\n{\n\tsize_t len;\n\tu_int32_t tmp;\n\tint ll = 0;\n\n\t/*\n\t * First, reset the chip.\n\t */\n\twx_hw_stop(sc);\n\n\t/*\n\t * Second, validate our EEPROM.\n\t */\n\n\t/* TBD */\n\n\t/*\n\t * Third, read eeprom for our MAC address and other things.\n\t */\n\twx_read_eeprom(sc, (u_int16_t *)sc->wx_enaddr, WX_EEPROM_MAC_OFF, 3);\n\n\t/*\n\t * Fourth, establish some adapter parameters.\n\t */\n\tsc->wx_txint_delay = 128;\n\tifmedia_init(&sc->wx_media, IFM_IMASK, wx_ifmedia_upd, wx_ifmedia_sts);\n\tifmedia_add(&sc->wx_media, IFM_ETHER|IFM_1000_SX, 0, NULL);\n\tifmedia_add(&sc->wx_media, IFM_ETHER|IFM_1000_SX|IFM_FDX, 0, NULL);\n\tifmedia_set(&sc->wx_media, IFM_ETHER|IFM_1000_SX|IFM_FDX);\n\tsc->wx_media.ifm_media = sc->wx_media.ifm_cur->ifm_media;\n\tll += 1;\n\n\t/*\n\t * Fifth, establish a default device control register word.\n\t */\n\tsc->wx_dcr = 0;\n\tif (sc->wx_cfg1 & WX_EEPROM_CTLR1_FD)\n\t\tsc->wx_dcr |= WXDCR_FD;\n\tif (sc->wx_cfg1 & WX_EEPROM_CTLR1_ILOS)\n\t\tsc->wx_dcr |= WXDCR_ILOS;\n\n\ttmp = (sc->wx_cfg1 >> WX_EEPROM_CTLR1_SWDPIO_SHIFT) & WXDCR_SWDPIO_MASK;\n\tsc->wx_dcr |= (tmp << WXDCR_SWDPIO_SHIFT);\n\n\tif (sc->wx_no_ilos)\n\t\tsc->wx_dcr &= ~WXDCR_ILOS;\n\tif (sc->wx_ilos)\n\t\tsc->wx_dcr |= WXDCR_ILOS;\n\tif (sc->wx_no_flow == 0)\n\t\tsc->wx_dcr |= WXDCR_RFCE | WXDCR_TFCE;\n\n\n\t/*\n\t * Sixth, allocate various sw structures...\n\t */\n\tlen = sizeof (rxpkt_t) * WX_MAX_RDESC;\n\tsc->rbase = (rxpkt_t *) WXMALLOC(len);\n\tif (sc->rbase == NULL) {\n                goto fail;\n\t}\n        bzero(sc->rbase, len);\n\tll += 1;\n\n\tlen = sizeof (txpkt_t) * WX_MAX_TDESC;\n\tsc->tbase = (txpkt_t *) WXMALLOC(len);\n        if (sc->tbase == NULL) {\n                goto fail;\n\t}\n        bzero(sc->tbase, len);\n\tll += 1;\n\n\t/*\n\t * Seventh, allocate and dma map (platform dependent) descriptor rings.\n\t * They have to be aligned on a 4KB boundary.\n\t */\n\tif (wx_dring_setup(sc) == 0) {\n\t\treturn (0);\n\t}\n\nfail:\n\tprintf(\"%s: failed to do common attach (%d)\\n\", sc->wx_name, ll);\n\twx_dring_teardown(sc);\n\tif (sc->rbase) {\n\t\tWXFREE(sc->rbase);\n\t\tsc->rbase = NULL;\n\t}\n\tif (sc->tbase) {\n\t\tWXFREE(sc->tbase);\n\t\tsc->tbase = NULL;\n\t}\n\treturn (ENOMEM);\n}"
  },
  {
    "function_name": "wx_dring_teardown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "743-755",
    "snippet": "static void\nwx_dring_teardown(sc)\n\twx_softc_t *sc;\n{\n\tif (sc->rdescriptors) {\n\t\tWXFREE(sc->rdescriptors);\n\t\tsc->rdescriptors = NULL;\n\t}\n\tif (sc->tdescriptors) {\n\t\tWXFREE(sc->tdescriptors);\n\t\tsc->tdescriptors = NULL;\n\t}\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "wx_eeprom_sibits __P((wx_softc_t *));",
      "wx_eeprom_cleanup __P((wx_softc_t *));",
      "wx_read_eeprom_word __P((wx_softc_t *, int));",
      "wx_mwi_whackon\t__P((wx_softc_t *));",
      "wx_mwi_unwhack\t__P((wx_softc_t *));",
      "static void wx_dring_teardown"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WXFREE",
          "args": [
            "sc->tdescriptors"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WXFREE",
          "args": [
            "sc->rdescriptors"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\nstatic void wx_dring_teardown;\n\nstatic void\nwx_dring_teardown(sc)\n\twx_softc_t *sc;\n{\n\tif (sc->rdescriptors) {\n\t\tWXFREE(sc->rdescriptors);\n\t\tsc->rdescriptors = NULL;\n\t}\n\tif (sc->tdescriptors) {\n\t\tWXFREE(sc->tdescriptors);\n\t\tsc->tdescriptors = NULL;\n\t}\n}"
  },
  {
    "function_name": "wx_dring_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "709-741",
    "snippet": "static int\nwx_dring_setup(sc)\n\twx_softc_t *sc;\n{\n\tsize_t len;\n\n\tlen = sizeof (wxrd_t) * WX_MAX_RDESC;\n\tsc->rdescriptors = (wxrd_t *)\n\t    contigmalloc(len, M_DEVBUF, M_NOWAIT, 0, ~0, 4096, 0);\n\tif (sc->rdescriptors == NULL) {\n\t\tprintf(\"%s: could not allocate rcv descriptors\\n\", sc->wx_name);\n\t\treturn (-1);\n\t}\n\tif (((u_long)sc->rdescriptors) & 0xfff) {\n\t\tprintf(\"%s: rcv descriptors not 4KB aligned\\n\", sc->wx_name);\n\t\treturn (-1);\n\t}\n        bzero(sc->rdescriptors, len);\n\n\tlen = sizeof (wxtd_t) * WX_MAX_TDESC;\n\tsc->tdescriptors = (wxtd_t *)\n\t    contigmalloc(len, M_DEVBUF, M_NOWAIT, 0, ~0, 4096, 0);\n\tif (sc->tdescriptors == NULL) {\n\t\tprintf(\"%s: could not allocate xmt descriptors\\n\", sc->wx_name);\n\t\treturn (-1);\n\t}\n\tif (((u_long)sc->tdescriptors) & 0xfff) {\n\t\tprintf(\"%s: xmt descriptors not 4KB aligned\\n\", sc->wx_name);\n\t\treturn (-1);\n\t}\n        bzero(sc->tdescriptors, len);\n\treturn (0);\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "wx_eeprom_sibits __P((wx_softc_t *));",
      "wx_eeprom_cleanup __P((wx_softc_t *));",
      "wx_read_eeprom_word __P((wx_softc_t *, int));",
      "wx_mwi_whackon\t__P((wx_softc_t *));",
      "wx_mwi_unwhack\t__P((wx_softc_t *));",
      "static int wx_dring_setup"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "sc->tdescriptors",
            "len"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: xmt descriptors not 4KB aligned\\n\"",
            "sc->wx_name"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "contigmalloc",
          "args": [
            "len",
            "M_DEVBUF",
            "M_NOWAIT",
            "0",
            "~0",
            "4096",
            "0"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "sc->rdescriptors",
            "len"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "contigmalloc",
          "args": [
            "len",
            "M_DEVBUF",
            "M_NOWAIT",
            "0",
            "~0",
            "4096",
            "0"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\nstatic int wx_dring_setup;\n\nstatic int\nwx_dring_setup(sc)\n\twx_softc_t *sc;\n{\n\tsize_t len;\n\n\tlen = sizeof (wxrd_t) * WX_MAX_RDESC;\n\tsc->rdescriptors = (wxrd_t *)\n\t    contigmalloc(len, M_DEVBUF, M_NOWAIT, 0, ~0, 4096, 0);\n\tif (sc->rdescriptors == NULL) {\n\t\tprintf(\"%s: could not allocate rcv descriptors\\n\", sc->wx_name);\n\t\treturn (-1);\n\t}\n\tif (((u_long)sc->rdescriptors) & 0xfff) {\n\t\tprintf(\"%s: rcv descriptors not 4KB aligned\\n\", sc->wx_name);\n\t\treturn (-1);\n\t}\n        bzero(sc->rdescriptors, len);\n\n\tlen = sizeof (wxtd_t) * WX_MAX_TDESC;\n\tsc->tdescriptors = (wxtd_t *)\n\t    contigmalloc(len, M_DEVBUF, M_NOWAIT, 0, ~0, 4096, 0);\n\tif (sc->tdescriptors == NULL) {\n\t\tprintf(\"%s: could not allocate xmt descriptors\\n\", sc->wx_name);\n\t\treturn (-1);\n\t}\n\tif (((u_long)sc->tdescriptors) & 0xfff) {\n\t\tprintf(\"%s: xmt descriptors not 4KB aligned\\n\", sc->wx_name);\n\t\treturn (-1);\n\t}\n        bzero(sc->tdescriptors, len);\n\treturn (0);\n}"
  },
  {
    "function_name": "wx_mwi_unwhack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "700-707",
    "snippet": "static INLINE void\nwx_mwi_unwhack(sc)\n\twx_softc_t *sc;\n{\n\tif (sc->wx_cmdw & MWI) {\n\t\tpci_write_config(sc->w.dev, PCIR_COMMAND, sc->wx_cmdw, 2);\n\t}\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static INLINE void",
      "static INLINE void",
      "static INLINE void",
      "wx_eeprom_sibits __P((wx_softc_t *));",
      "static INLINE void",
      "wx_eeprom_cleanup __P((wx_softc_t *));",
      "wx_read_eeprom_word __P((wx_softc_t *, int));",
      "static INLINE void",
      "wx_mwi_whackon\t__P((wx_softc_t *));",
      "static INLINE void",
      "wx_mwi_unwhack\t__P((wx_softc_t *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_write_config",
          "args": [
            "sc->w.dev",
            "PCIR_COMMAND",
            "sc->wx_cmdw",
            "2"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic INLINE void;\nstatic INLINE void;\nstatic INLINE void;\nwx_eeprom_sibits __P((wx_softc_t *));\nstatic INLINE void;\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic INLINE void;\nwx_mwi_whackon\t__P((wx_softc_t *));\nstatic INLINE void;\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic INLINE void\nwx_mwi_unwhack(sc)\n\twx_softc_t *sc;\n{\n\tif (sc->wx_cmdw & MWI) {\n\t\tpci_write_config(sc->w.dev, PCIR_COMMAND, sc->wx_cmdw, 2);\n\t}\n}"
  },
  {
    "function_name": "wx_mwi_whackon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "692-698",
    "snippet": "static INLINE void\nwx_mwi_whackon(sc)\n\twx_softc_t *sc;\n{\n\tsc->wx_cmdw = pci_read_config(sc->w.dev, PCIR_COMMAND, 2);\n\tpci_write_config(sc->w.dev, PCIR_COMMAND, sc->wx_cmdw & ~MWI, 2);\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static INLINE void",
      "static INLINE void",
      "static INLINE void",
      "wx_eeprom_sibits __P((wx_softc_t *));",
      "static INLINE void",
      "wx_eeprom_cleanup __P((wx_softc_t *));",
      "wx_read_eeprom_word __P((wx_softc_t *, int));",
      "static INLINE void",
      "wx_mwi_whackon\t__P((wx_softc_t *));",
      "static INLINE void",
      "wx_mwi_unwhack\t__P((wx_softc_t *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_write_config",
          "args": [
            "sc->w.dev",
            "PCIR_COMMAND",
            "sc->wx_cmdw & ~MWI",
            "2"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_read_config",
          "args": [
            "sc->w.dev",
            "PCIR_COMMAND",
            "2"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic INLINE void;\nstatic INLINE void;\nstatic INLINE void;\nwx_eeprom_sibits __P((wx_softc_t *));\nstatic INLINE void;\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic INLINE void;\nwx_mwi_whackon\t__P((wx_softc_t *));\nstatic INLINE void;\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic INLINE void\nwx_mwi_whackon(sc)\n\twx_softc_t *sc;\n{\n\tsc->wx_cmdw = pci_read_config(sc->w.dev, PCIR_COMMAND, 2);\n\tpci_write_config(sc->w.dev, PCIR_COMMAND, sc->wx_cmdw & ~MWI, 2);\n}"
  },
  {
    "function_name": "wx_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "685-690",
    "snippet": "static int\nwx_shutdown(device_t dev)\n{\n\twx_hw_stop((wx_softc_t *) device_get_softc(dev));\n\treturn (0);\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wx_hw_stop",
      "wx_eeprom_sibits __P((wx_softc_t *));",
      "wx_eeprom_cleanup __P((wx_softc_t *));",
      "wx_read_eeprom_word __P((wx_softc_t *, int));",
      "wx_mwi_whackon\t__P((wx_softc_t *));",
      "wx_mwi_unwhack\t__P((wx_softc_t *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wx_hw_stop",
          "args": [
            "(wx_softc_t *) device_get_softc(dev)"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "wx_hw_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "1515-1531",
          "snippet": "static void\nwx_hw_stop(sc)\n\twx_softc_t *sc;\n{\n\tu_int32_t icr;\n\tif (sc->revision == 2) {\n\t\twx_mwi_whackon(sc);\n\t}\n\tWRITE_CSR(sc, WXREG_DCR, WXDCR_RST);\n\tDELAY(20 * 1000);\n\tWRITE_CSR(sc, WXREG_IMASK, ~0);\n\ticr = READ_CSR(sc, WXREG_ICR);\n\tif (sc->revision == 2) {\n\t\twx_mwi_unwhack(sc);\n\t}\n\tWX_DISABLE_INT(sc);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wx_hw_stop",
            "wx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));",
            "wx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic void wx_hw_stop;\nwx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));\nwx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic void\nwx_hw_stop(sc)\n\twx_softc_t *sc;\n{\n\tu_int32_t icr;\n\tif (sc->revision == 2) {\n\t\twx_mwi_whackon(sc);\n\t}\n\tWRITE_CSR(sc, WXREG_DCR, WXDCR_RST);\n\tDELAY(20 * 1000);\n\tWRITE_CSR(sc, WXREG_IMASK, ~0);\n\ticr = READ_CSR(sc, WXREG_ICR);\n\tif (sc->revision == 2) {\n\t\twx_mwi_unwhack(sc);\n\t}\n\tWX_DISABLE_INT(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "device_get_softc",
          "args": [
            "dev"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic void wx_hw_stop;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic int\nwx_shutdown(device_t dev)\n{\n\twx_hw_stop((wx_softc_t *) device_get_softc(dev));\n\treturn (0);\n}"
  },
  {
    "function_name": "wx_detach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "671-683",
    "snippet": "static int\nwx_detach(device_t dev)\n{\n\twx_softc_t *sc = device_get_softc(dev);\n\tint s = splimp();\n\tif_detach(&sc->w.arpcom.ac_if);\n\twx_stop(sc);\n\tbus_teardown_intr(dev, sc->w.irq, sc->w.ih);\n\tbus_release_resource(dev, SYS_RES_IRQ, 0, sc->w.irq);\n\tbus_release_resource(dev, SYS_RES_MEMORY, WX_MMBA, sc->w.mem);\n\tsplx(s);\n\treturn (0);\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wx_stop",
      "wx_eeprom_sibits __P((wx_softc_t *));",
      "wx_eeprom_cleanup __P((wx_softc_t *));",
      "wx_read_eeprom_word __P((wx_softc_t *, int));",
      "wx_mwi_whackon\t__P((wx_softc_t *));",
      "wx_mwi_unwhack\t__P((wx_softc_t *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_release_resource",
          "args": [
            "dev",
            "SYS_RES_MEMORY",
            "WX_MMBA",
            "sc->w.mem"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_release_resource",
          "args": [
            "dev",
            "SYS_RES_IRQ",
            "0",
            "sc->w.irq"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_teardown_intr",
          "args": [
            "dev",
            "sc->w.irq",
            "sc->w.ih"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wx_stop",
          "args": [
            "sc"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "wx_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "1641-1690",
          "snippet": "static void\nwx_stop(sc)\n\twx_softc_t *sc;\n{\n\ttxpkt_t *txp;\n\trxpkt_t *rxp;\n\tstruct ifnet *ifp = &sc->wx_if;\n\n\t/*\n\t * Cancel stats updater.\n\t */\n\tUNTIMEOUT(wx_stats_update, sc, sc);\n\n\t/*\n\t * Reset the chip\n\t */\n\twx_hw_stop(sc);\n\n\t/*\n\t * Release any xmit buffers.\n\t */\n\tfor (txp = sc->tbase; txp && txp < &sc->tbase[WX_MAX_TDESC]; txp++) {\n\t\tif (txp->dptr) {\n\t\t\tm_free(txp->dptr);\n\t\t\ttxp->dptr = NULL;\n\t\t}\n\t}\n\n\t/*\n\t * Free all the receive buffers.\n\t */\n\tfor (rxp = sc->rbase; rxp && rxp < &sc->rbase[WX_MAX_RDESC]; rxp++) {\n\t\tif (rxp->dptr) {\n\t\t\tm_free(rxp->dptr);\n\t\t\trxp->dptr = NULL;\n\t\t}\n\t}\n\n\tif (sc->rpending) {\n\t\tm_freem(sc->rpending);\n\t\tsc->rpending = NULL;\n\t}\n\n\t/*\n\t * And we're outta here...\n\t */\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\tifp->if_timer = 0;\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wx_hw_stop",
            "static void wx_stop",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "static void wx_stats_update",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic void wx_hw_stop;\nstatic void wx_stop;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic void wx_stats_update;\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic void\nwx_stop(sc)\n\twx_softc_t *sc;\n{\n\ttxpkt_t *txp;\n\trxpkt_t *rxp;\n\tstruct ifnet *ifp = &sc->wx_if;\n\n\t/*\n\t * Cancel stats updater.\n\t */\n\tUNTIMEOUT(wx_stats_update, sc, sc);\n\n\t/*\n\t * Reset the chip\n\t */\n\twx_hw_stop(sc);\n\n\t/*\n\t * Release any xmit buffers.\n\t */\n\tfor (txp = sc->tbase; txp && txp < &sc->tbase[WX_MAX_TDESC]; txp++) {\n\t\tif (txp->dptr) {\n\t\t\tm_free(txp->dptr);\n\t\t\ttxp->dptr = NULL;\n\t\t}\n\t}\n\n\t/*\n\t * Free all the receive buffers.\n\t */\n\tfor (rxp = sc->rbase; rxp && rxp < &sc->rbase[WX_MAX_RDESC]; rxp++) {\n\t\tif (rxp->dptr) {\n\t\t\tm_free(rxp->dptr);\n\t\t\trxp->dptr = NULL;\n\t\t}\n\t}\n\n\tif (sc->rpending) {\n\t\tm_freem(sc->rpending);\n\t\tsc->rpending = NULL;\n\t}\n\n\t/*\n\t * And we're outta here...\n\t */\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\tifp->if_timer = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "if_detach",
          "args": [
            "&sc->w.arpcom.ac_if"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_get_softc",
          "args": [
            "dev"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic void wx_stop;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic int\nwx_detach(device_t dev)\n{\n\twx_softc_t *sc = device_get_softc(dev);\n\tint s = splimp();\n\tif_detach(&sc->w.arpcom.ac_if);\n\twx_stop(sc);\n\tbus_teardown_intr(dev, sc->w.irq, sc->w.ih);\n\tbus_release_resource(dev, SYS_RES_IRQ, 0, sc->w.irq);\n\tbus_release_resource(dev, SYS_RES_MEMORY, WX_MMBA, sc->w.mem);\n\tsplx(s);\n\treturn (0);\n}"
  },
  {
    "function_name": "wx_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "544-669",
    "snippet": "static int\nwx_attach(device_t dev)\n{\n\tint error = 0;\n\twx_softc_t *tmp, *sc = device_get_softc(dev);\n\tstruct ifnet *ifp;\n\tint s;\n\tu_long val;\n\tint rid;\n\n\tbzero(sc, sizeof (wx_softc_t));\n\n\tcallout_handle_init(&sc->w.sch);\n\tsc->w.dev = dev;\n\n\tif (getenv_int(\"wx_debug\", &rid)) {\n\t\tif (rid & (1 << device_get_unit(dev))) {\n\t\t\tsc->wx_debug = 1;\n\t\t}\n\t}\n\n\tif (getenv_int(\"wx_no_ilos\", &rid)) {\n\t\tif (rid & (1 << device_get_unit(dev))) {\n\t\t\tsc->wx_no_ilos = 1;\n\t\t}\n\t}\n\n\tif (getenv_int(\"wx_ilos\", &rid)) {\n\t\tif (rid & (1 << device_get_unit(dev))) {\n\t\t\tsc->wx_ilos = 1;\n\t\t}\n\t}\n\n\tif (getenv_int(\"wx_no_flow\", &rid)) {\n\t\tif (rid & (1 << device_get_unit(dev))) {\n\t\t\tsc->wx_no_flow = 1;\n\t\t}\n\t}\n\n\ts = splimp();\n\t/*\n\t * Enable bus mastering, make sure that the cache line size is right.\n\t */\n\tval = pci_read_config(dev, PCIR_COMMAND, 2);\n\tval |= (PCIM_CMD_MEMEN|PCIM_CMD_BUSMASTEREN);\n\tpci_write_config(dev, PCIR_COMMAND, val, 2);\n\n\tval = pci_read_config(dev, PCIR_CACHELNSZ, 1);\n\tif (val != 0x10) {\n\t\tpci_write_config(dev, PCIR_CACHELNSZ, 0x10, 1);\n\t}\n\n\t/*\n \t * get revision\n\t */\n\tsc->revision = pci_read_config(dev, PCIR_CLASS, 1);\n\n\t/*\n\t * Map control/status registers.\n\t */\n\trid = WX_MMBA;\n\tsc->w.mem = bus_alloc_resource(dev, SYS_RES_MEMORY,\n\t    &rid, 0, ~0, 1, RF_ACTIVE);\n\tif (!sc->w.mem) {\n\t\tdevice_printf(dev, \"could not map memory\\n\");\n\t\terror = ENXIO;\n\t\tgoto out;\n        }\n\tsc->w.st = rman_get_bustag(sc->w.mem);\n\tsc->w.sh = rman_get_bushandle(sc->w.mem);\n\n\trid = 0;\n\tsc->w.irq = bus_alloc_resource(dev, SYS_RES_IRQ,\n\t    &rid, 0, ~0, 1, RF_SHAREABLE | RF_ACTIVE);\n\tif (sc->w.irq == NULL) {\n\t\tdevice_printf(dev, \"could not map interrupt\\n\");\n\t\terror = ENXIO;\n\t\tgoto out;\n\t}\n\terror = bus_setup_intr(dev, sc->w.irq, INTR_TYPE_NET,\n\t    (void (*)(void *))wx_intr, sc, &sc->w.ih);\n\tif (error) {\n\t\tdevice_printf(dev, \"could not setup irq\\n\");\n\t\tgoto out;\n\t}\n\tif (wx_attach_common(sc)) {\n\t\tbus_teardown_intr(dev, sc->w.irq, sc->w.ih);\n\t\tbus_release_resource(dev, SYS_RES_IRQ, 0, sc->w.irq);\n\t\tbus_release_resource(dev, SYS_RES_MEMORY, WX_MMBA, sc->w.mem);\n\t\terror = ENXIO;\n\t\tgoto out;\n\t}\n\tdevice_printf(dev, \"Ethernet address %02x:%02x:%02x:%02x:%02x:%02x\\n\",\n\t    sc->w.arpcom.ac_enaddr[0], sc->w.arpcom.ac_enaddr[1],\n\t    sc->w.arpcom.ac_enaddr[2], sc->w.arpcom.ac_enaddr[3],\n\t    sc->w.arpcom.ac_enaddr[4], sc->w.arpcom.ac_enaddr[5]);\n\t(void) snprintf(sc->wx_name, sizeof (sc->wx_name) - 1, \"wx%d\",\n\t    device_get_unit(dev));\n\tifp = &sc->w.arpcom.ac_if;\n\tifp->if_unit = device_get_unit(dev);\n\tifp->if_name = \"wx\";\n\tifp->if_mtu = WX_MAXMTU;\n\tifp->if_output = ether_output;\n\tifp->if_baudrate = 1000000000;\n\tifp->if_init = (void (*)(void *))wx_init;\n\tifp->if_softc = sc;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;\n\tifp->if_ioctl = wx_ioctl;\n\tifp->if_start = wx_start;\n\tifp->if_watchdog = wx_watchdog;\n\tif_attach(ifp);\n\tifp->if_snd.ifq_maxlen = WX_MAX_TDESC - 1;\n\tether_ifattach(ifp);\n\tbpfattach(ifp, DLT_EN10MB, sizeof(struct ether_header));\n\ttmp = wxlist;\n\tif (tmp) {\n\t\twhile (tmp->wx_next)\n\t\t\ttmp = tmp->wx_next;\n\t\ttmp->wx_next = sc;\n\t} else {\n\t\twxlist = sc;\n\t}\nout:\n\tsplx(s);\n\treturn (error);\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [
      "#define\tWX_MAXMTU\tETHERMTU",
      "#define\tWX_MAXMTU\tJUMBOMTU"
    ],
    "globals_used": [
      "static int wx_intr",
      "static void wx_start",
      "static int wx_ioctl",
      "static int wx_init",
      "static void wx_watchdog",
      "wx_eeprom_sibits __P((wx_softc_t *));",
      "wx_eeprom_cleanup __P((wx_softc_t *));",
      "wx_read_eeprom_word __P((wx_softc_t *, int));",
      "static int wx_attach_common",
      "wx_mwi_whackon\t__P((wx_softc_t *));",
      "wx_mwi_unwhack\t__P((wx_softc_t *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpfattach",
          "args": [
            "ifp",
            "DLT_EN10MB",
            "sizeof(struct ether_header)"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ifattach",
          "args": [
            "ifp"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_attach",
          "args": [
            "ifp"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_get_unit",
          "args": [
            "dev"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "sc->wx_name",
            "sizeof (sc->wx_name) - 1",
            "\"wx%d\"",
            "device_get_unit(dev)"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_get_unit",
          "args": [
            "dev"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_printf",
          "args": [
            "dev",
            "\"Ethernet address %02x:%02x:%02x:%02x:%02x:%02x\\n\"",
            "sc->w.arpcom.ac_enaddr[0]",
            "sc->w.arpcom.ac_enaddr[1]",
            "sc->w.arpcom.ac_enaddr[2]",
            "sc->w.arpcom.ac_enaddr[3]",
            "sc->w.arpcom.ac_enaddr[4]",
            "sc->w.arpcom.ac_enaddr[5]"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_release_resource",
          "args": [
            "dev",
            "SYS_RES_MEMORY",
            "WX_MMBA",
            "sc->w.mem"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_release_resource",
          "args": [
            "dev",
            "SYS_RES_IRQ",
            "0",
            "sc->w.irq"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_teardown_intr",
          "args": [
            "dev",
            "sc->w.irq",
            "sc->w.ih"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wx_attach_common",
          "args": [
            "sc"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "wx_attach_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "778-872",
          "snippet": "static int\nwx_attach_common(sc)\n\twx_softc_t *sc;\n{\n\tsize_t len;\n\tu_int32_t tmp;\n\tint ll = 0;\n\n\t/*\n\t * First, reset the chip.\n\t */\n\twx_hw_stop(sc);\n\n\t/*\n\t * Second, validate our EEPROM.\n\t */\n\n\t/* TBD */\n\n\t/*\n\t * Third, read eeprom for our MAC address and other things.\n\t */\n\twx_read_eeprom(sc, (u_int16_t *)sc->wx_enaddr, WX_EEPROM_MAC_OFF, 3);\n\n\t/*\n\t * Fourth, establish some adapter parameters.\n\t */\n\tsc->wx_txint_delay = 128;\n\tifmedia_init(&sc->wx_media, IFM_IMASK, wx_ifmedia_upd, wx_ifmedia_sts);\n\tifmedia_add(&sc->wx_media, IFM_ETHER|IFM_1000_SX, 0, NULL);\n\tifmedia_add(&sc->wx_media, IFM_ETHER|IFM_1000_SX|IFM_FDX, 0, NULL);\n\tifmedia_set(&sc->wx_media, IFM_ETHER|IFM_1000_SX|IFM_FDX);\n\tsc->wx_media.ifm_media = sc->wx_media.ifm_cur->ifm_media;\n\tll += 1;\n\n\t/*\n\t * Fifth, establish a default device control register word.\n\t */\n\tsc->wx_dcr = 0;\n\tif (sc->wx_cfg1 & WX_EEPROM_CTLR1_FD)\n\t\tsc->wx_dcr |= WXDCR_FD;\n\tif (sc->wx_cfg1 & WX_EEPROM_CTLR1_ILOS)\n\t\tsc->wx_dcr |= WXDCR_ILOS;\n\n\ttmp = (sc->wx_cfg1 >> WX_EEPROM_CTLR1_SWDPIO_SHIFT) & WXDCR_SWDPIO_MASK;\n\tsc->wx_dcr |= (tmp << WXDCR_SWDPIO_SHIFT);\n\n\tif (sc->wx_no_ilos)\n\t\tsc->wx_dcr &= ~WXDCR_ILOS;\n\tif (sc->wx_ilos)\n\t\tsc->wx_dcr |= WXDCR_ILOS;\n\tif (sc->wx_no_flow == 0)\n\t\tsc->wx_dcr |= WXDCR_RFCE | WXDCR_TFCE;\n\n\n\t/*\n\t * Sixth, allocate various sw structures...\n\t */\n\tlen = sizeof (rxpkt_t) * WX_MAX_RDESC;\n\tsc->rbase = (rxpkt_t *) WXMALLOC(len);\n\tif (sc->rbase == NULL) {\n                goto fail;\n\t}\n        bzero(sc->rbase, len);\n\tll += 1;\n\n\tlen = sizeof (txpkt_t) * WX_MAX_TDESC;\n\tsc->tbase = (txpkt_t *) WXMALLOC(len);\n        if (sc->tbase == NULL) {\n                goto fail;\n\t}\n        bzero(sc->tbase, len);\n\tll += 1;\n\n\t/*\n\t * Seventh, allocate and dma map (platform dependent) descriptor rings.\n\t * They have to be aligned on a 4KB boundary.\n\t */\n\tif (wx_dring_setup(sc) == 0) {\n\t\treturn (0);\n\t}\n\nfail:\n\tprintf(\"%s: failed to do common attach (%d)\\n\", sc->wx_name, ll);\n\twx_dring_teardown(sc);\n\tif (sc->rbase) {\n\t\tWXFREE(sc->rbase);\n\t\tsc->rbase = NULL;\n\t}\n\tif (sc->tbase) {\n\t\tWXFREE(sc->tbase);\n\t\tsc->tbase = NULL;\n\t}\n\treturn (ENOMEM);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int wx_ifmedia_upd",
            "static void wx_ifmedia_sts",
            "static void wx_hw_stop",
            "wx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));",
            "wx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));",
            "wx_eeprom_sobits __P((wx_softc_t *, u_int16_t, u_int16_t));",
            "static INLINE u_int16_t",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "static INLINE u_int16_t",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "static void wx_read_eeprom",
            "static int wx_attach_common",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));",
            "static int wx_dring_setup",
            "static void wx_dring_teardown"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic int wx_ifmedia_upd;\nstatic void wx_ifmedia_sts;\nstatic void wx_hw_stop;\nwx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));\nwx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));\nwx_eeprom_sobits __P((wx_softc_t *, u_int16_t, u_int16_t));\nstatic INLINE u_int16_t;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nstatic INLINE u_int16_t;\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic void wx_read_eeprom;\nstatic int wx_attach_common;\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\nstatic int wx_dring_setup;\nstatic void wx_dring_teardown;\n\nstatic int\nwx_attach_common(sc)\n\twx_softc_t *sc;\n{\n\tsize_t len;\n\tu_int32_t tmp;\n\tint ll = 0;\n\n\t/*\n\t * First, reset the chip.\n\t */\n\twx_hw_stop(sc);\n\n\t/*\n\t * Second, validate our EEPROM.\n\t */\n\n\t/* TBD */\n\n\t/*\n\t * Third, read eeprom for our MAC address and other things.\n\t */\n\twx_read_eeprom(sc, (u_int16_t *)sc->wx_enaddr, WX_EEPROM_MAC_OFF, 3);\n\n\t/*\n\t * Fourth, establish some adapter parameters.\n\t */\n\tsc->wx_txint_delay = 128;\n\tifmedia_init(&sc->wx_media, IFM_IMASK, wx_ifmedia_upd, wx_ifmedia_sts);\n\tifmedia_add(&sc->wx_media, IFM_ETHER|IFM_1000_SX, 0, NULL);\n\tifmedia_add(&sc->wx_media, IFM_ETHER|IFM_1000_SX|IFM_FDX, 0, NULL);\n\tifmedia_set(&sc->wx_media, IFM_ETHER|IFM_1000_SX|IFM_FDX);\n\tsc->wx_media.ifm_media = sc->wx_media.ifm_cur->ifm_media;\n\tll += 1;\n\n\t/*\n\t * Fifth, establish a default device control register word.\n\t */\n\tsc->wx_dcr = 0;\n\tif (sc->wx_cfg1 & WX_EEPROM_CTLR1_FD)\n\t\tsc->wx_dcr |= WXDCR_FD;\n\tif (sc->wx_cfg1 & WX_EEPROM_CTLR1_ILOS)\n\t\tsc->wx_dcr |= WXDCR_ILOS;\n\n\ttmp = (sc->wx_cfg1 >> WX_EEPROM_CTLR1_SWDPIO_SHIFT) & WXDCR_SWDPIO_MASK;\n\tsc->wx_dcr |= (tmp << WXDCR_SWDPIO_SHIFT);\n\n\tif (sc->wx_no_ilos)\n\t\tsc->wx_dcr &= ~WXDCR_ILOS;\n\tif (sc->wx_ilos)\n\t\tsc->wx_dcr |= WXDCR_ILOS;\n\tif (sc->wx_no_flow == 0)\n\t\tsc->wx_dcr |= WXDCR_RFCE | WXDCR_TFCE;\n\n\n\t/*\n\t * Sixth, allocate various sw structures...\n\t */\n\tlen = sizeof (rxpkt_t) * WX_MAX_RDESC;\n\tsc->rbase = (rxpkt_t *) WXMALLOC(len);\n\tif (sc->rbase == NULL) {\n                goto fail;\n\t}\n        bzero(sc->rbase, len);\n\tll += 1;\n\n\tlen = sizeof (txpkt_t) * WX_MAX_TDESC;\n\tsc->tbase = (txpkt_t *) WXMALLOC(len);\n        if (sc->tbase == NULL) {\n                goto fail;\n\t}\n        bzero(sc->tbase, len);\n\tll += 1;\n\n\t/*\n\t * Seventh, allocate and dma map (platform dependent) descriptor rings.\n\t * They have to be aligned on a 4KB boundary.\n\t */\n\tif (wx_dring_setup(sc) == 0) {\n\t\treturn (0);\n\t}\n\nfail:\n\tprintf(\"%s: failed to do common attach (%d)\\n\", sc->wx_name, ll);\n\twx_dring_teardown(sc);\n\tif (sc->rbase) {\n\t\tWXFREE(sc->rbase);\n\t\tsc->rbase = NULL;\n\t}\n\tif (sc->tbase) {\n\t\tWXFREE(sc->tbase);\n\t\tsc->tbase = NULL;\n\t}\n\treturn (ENOMEM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "device_printf",
          "args": [
            "dev",
            "\"could not setup irq\\n\""
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_setup_intr",
          "args": [
            "dev",
            "sc->w.irq",
            "INTR_TYPE_NET",
            "(void (*)(void *))wx_intr",
            "sc",
            "&sc->w.ih"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_printf",
          "args": [
            "dev",
            "\"could not map interrupt\\n\""
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_alloc_resource",
          "args": [
            "dev",
            "SYS_RES_IRQ",
            "&rid",
            "0",
            "~0",
            "1",
            "RF_SHAREABLE | RF_ACTIVE"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rman_get_bushandle",
          "args": [
            "sc->w.mem"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rman_get_bustag",
          "args": [
            "sc->w.mem"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_printf",
          "args": [
            "dev",
            "\"could not map memory\\n\""
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_alloc_resource",
          "args": [
            "dev",
            "SYS_RES_MEMORY",
            "&rid",
            "0",
            "~0",
            "1",
            "RF_ACTIVE"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_read_config",
          "args": [
            "dev",
            "PCIR_CLASS",
            "1"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_write_config",
          "args": [
            "dev",
            "PCIR_CACHELNSZ",
            "0x10",
            "1"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_read_config",
          "args": [
            "dev",
            "PCIR_CACHELNSZ",
            "1"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_write_config",
          "args": [
            "dev",
            "PCIR_COMMAND",
            "val",
            "2"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_read_config",
          "args": [
            "dev",
            "PCIR_COMMAND",
            "2"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_get_unit",
          "args": [
            "dev"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv_int",
          "args": [
            "\"wx_no_flow\"",
            "&rid"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_get_unit",
          "args": [
            "dev"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv_int",
          "args": [
            "\"wx_ilos\"",
            "&rid"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_get_unit",
          "args": [
            "dev"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv_int",
          "args": [
            "\"wx_no_ilos\"",
            "&rid"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_get_unit",
          "args": [
            "dev"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv_int",
          "args": [
            "\"wx_debug\"",
            "&rid"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "callout_handle_init",
          "args": [
            "&sc->w.sch"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "sc",
            "sizeof (wx_softc_t)"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_get_softc",
          "args": [
            "dev"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\n#define\tWX_MAXMTU\tETHERMTU\n#define\tWX_MAXMTU\tJUMBOMTU\n\nstatic int wx_intr;\nstatic void wx_start;\nstatic int wx_ioctl;\nstatic int wx_init;\nstatic void wx_watchdog;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic int wx_attach_common;\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic int\nwx_attach(device_t dev)\n{\n\tint error = 0;\n\twx_softc_t *tmp, *sc = device_get_softc(dev);\n\tstruct ifnet *ifp;\n\tint s;\n\tu_long val;\n\tint rid;\n\n\tbzero(sc, sizeof (wx_softc_t));\n\n\tcallout_handle_init(&sc->w.sch);\n\tsc->w.dev = dev;\n\n\tif (getenv_int(\"wx_debug\", &rid)) {\n\t\tif (rid & (1 << device_get_unit(dev))) {\n\t\t\tsc->wx_debug = 1;\n\t\t}\n\t}\n\n\tif (getenv_int(\"wx_no_ilos\", &rid)) {\n\t\tif (rid & (1 << device_get_unit(dev))) {\n\t\t\tsc->wx_no_ilos = 1;\n\t\t}\n\t}\n\n\tif (getenv_int(\"wx_ilos\", &rid)) {\n\t\tif (rid & (1 << device_get_unit(dev))) {\n\t\t\tsc->wx_ilos = 1;\n\t\t}\n\t}\n\n\tif (getenv_int(\"wx_no_flow\", &rid)) {\n\t\tif (rid & (1 << device_get_unit(dev))) {\n\t\t\tsc->wx_no_flow = 1;\n\t\t}\n\t}\n\n\ts = splimp();\n\t/*\n\t * Enable bus mastering, make sure that the cache line size is right.\n\t */\n\tval = pci_read_config(dev, PCIR_COMMAND, 2);\n\tval |= (PCIM_CMD_MEMEN|PCIM_CMD_BUSMASTEREN);\n\tpci_write_config(dev, PCIR_COMMAND, val, 2);\n\n\tval = pci_read_config(dev, PCIR_CACHELNSZ, 1);\n\tif (val != 0x10) {\n\t\tpci_write_config(dev, PCIR_CACHELNSZ, 0x10, 1);\n\t}\n\n\t/*\n \t * get revision\n\t */\n\tsc->revision = pci_read_config(dev, PCIR_CLASS, 1);\n\n\t/*\n\t * Map control/status registers.\n\t */\n\trid = WX_MMBA;\n\tsc->w.mem = bus_alloc_resource(dev, SYS_RES_MEMORY,\n\t    &rid, 0, ~0, 1, RF_ACTIVE);\n\tif (!sc->w.mem) {\n\t\tdevice_printf(dev, \"could not map memory\\n\");\n\t\terror = ENXIO;\n\t\tgoto out;\n        }\n\tsc->w.st = rman_get_bustag(sc->w.mem);\n\tsc->w.sh = rman_get_bushandle(sc->w.mem);\n\n\trid = 0;\n\tsc->w.irq = bus_alloc_resource(dev, SYS_RES_IRQ,\n\t    &rid, 0, ~0, 1, RF_SHAREABLE | RF_ACTIVE);\n\tif (sc->w.irq == NULL) {\n\t\tdevice_printf(dev, \"could not map interrupt\\n\");\n\t\terror = ENXIO;\n\t\tgoto out;\n\t}\n\terror = bus_setup_intr(dev, sc->w.irq, INTR_TYPE_NET,\n\t    (void (*)(void *))wx_intr, sc, &sc->w.ih);\n\tif (error) {\n\t\tdevice_printf(dev, \"could not setup irq\\n\");\n\t\tgoto out;\n\t}\n\tif (wx_attach_common(sc)) {\n\t\tbus_teardown_intr(dev, sc->w.irq, sc->w.ih);\n\t\tbus_release_resource(dev, SYS_RES_IRQ, 0, sc->w.irq);\n\t\tbus_release_resource(dev, SYS_RES_MEMORY, WX_MMBA, sc->w.mem);\n\t\terror = ENXIO;\n\t\tgoto out;\n\t}\n\tdevice_printf(dev, \"Ethernet address %02x:%02x:%02x:%02x:%02x:%02x\\n\",\n\t    sc->w.arpcom.ac_enaddr[0], sc->w.arpcom.ac_enaddr[1],\n\t    sc->w.arpcom.ac_enaddr[2], sc->w.arpcom.ac_enaddr[3],\n\t    sc->w.arpcom.ac_enaddr[4], sc->w.arpcom.ac_enaddr[5]);\n\t(void) snprintf(sc->wx_name, sizeof (sc->wx_name) - 1, \"wx%d\",\n\t    device_get_unit(dev));\n\tifp = &sc->w.arpcom.ac_if;\n\tifp->if_unit = device_get_unit(dev);\n\tifp->if_name = \"wx\";\n\tifp->if_mtu = WX_MAXMTU;\n\tifp->if_output = ether_output;\n\tifp->if_baudrate = 1000000000;\n\tifp->if_init = (void (*)(void *))wx_init;\n\tifp->if_softc = sc;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;\n\tifp->if_ioctl = wx_ioctl;\n\tifp->if_start = wx_start;\n\tifp->if_watchdog = wx_watchdog;\n\tif_attach(ifp);\n\tifp->if_snd.ifq_maxlen = WX_MAX_TDESC - 1;\n\tether_ifattach(ifp);\n\tbpfattach(ifp, DLT_EN10MB, sizeof(struct ether_header));\n\ttmp = wxlist;\n\tif (tmp) {\n\t\twhile (tmp->wx_next)\n\t\t\ttmp = tmp->wx_next;\n\t\ttmp->wx_next = sc;\n\t} else {\n\t\twxlist = sc;\n\t}\nout:\n\tsplx(s);\n\treturn (error);\n}"
  },
  {
    "function_name": "wx_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "533-542",
    "snippet": "static int\nwx_probe(device_t dev)\n{\n\tif ((pci_get_vendor(dev) == WX_VENDOR_INTEL) &&\n\t    (pci_get_device(dev) == WX_PRODUCT_82452)) {\n\t\tdevice_set_desc(dev, \"Intel GigaBit Ethernet\");\n\t\treturn 0;\n\t}\n\treturn (ENXIO);\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "device_set_desc",
          "args": [
            "dev",
            "\"Intel GigaBit Ethernet\""
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_get_device",
          "args": [
            "dev"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_get_vendor",
          "args": [
            "dev"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic int\nwx_probe(device_t dev)\n{\n\tif ((pci_get_vendor(dev) == WX_VENDOR_INTEL) &&\n\t    (pci_get_device(dev) == WX_PRODUCT_82452)) {\n\t\tdevice_set_desc(dev, \"Intel GigaBit Ethernet\");\n\t\treturn 0;\n\t}\n\treturn (ENXIO);\n}"
  },
  {
    "function_name": "wx_mc_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "492-527",
    "snippet": "static int\nwx_mc_setup(sc)\n\twx_softc_t *sc;\n{\n\tstruct ifnet *ifp = &sc->wx_if;\n\tstruct ifmultiaddr *ifma;\n\n\t/*\n\t * XXX: drain TX queue- use a tsleep/wakeup until done.\n\t */\n\tif (sc->tactive) {\n\t\treturn (EBUSY);\n\t}\n\n\twx_stop(sc);\n\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\tsc->all_mcasts = 1;\n\t\treturn (wx_init(sc));\n\t}\n\n\tfor (ifma = ifp->if_multiaddrs.lh_first, sc->wx_nmca = 0;\n\t    ifma != NULL; ifma = ifma->ifma_link.le_next) {\n\t\tif (ifma->ifma_addr->sa_family != AF_LINK) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (sc->wx_nmca >= WX_RAL_TAB_SIZE-1) {\n\t\t\tsc->wx_nmca = 0;\n\t\t\tsc->all_mcasts = 1;\n\t\t\tbreak;\n\t\t}\n\t\tbcopy(LLADDR((struct sockaddr_dl *)ifma->ifma_addr),\n\t\t    (void *) &sc->wx_mcaddr[sc->wx_nmca++][0], 6);\n\t}\n\treturn (wx_init(sc));\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int wx_init",
      "static void wx_stop",
      "wx_eeprom_sibits __P((wx_softc_t *));",
      "wx_eeprom_cleanup __P((wx_softc_t *));",
      "wx_read_eeprom_word __P((wx_softc_t *, int));",
      "wx_mwi_whackon\t__P((wx_softc_t *));",
      "wx_mwi_unwhack\t__P((wx_softc_t *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wx_init",
          "args": [
            "sc"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "wx_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "1708-1835",
          "snippet": "static int\nwx_init(xsc)\n\tvoid *xsc;\n{\n\tstruct ifmedia *ifm;\n\twx_softc_t *sc = xsc;\n\tstruct ifnet *ifp = &sc->wx_if;\n\trxpkt_t *rxpkt;\n\twxrd_t *rd;\n\tsize_t len;\n\tint s, i, bflags;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel any pending I/O by resetting things.\n\t * wx_stop will free any allocated mbufs.\n\t */\n\twx_stop(sc);\n\n\t/*\n\t * Reset the hardware. All network addresses loaded here, but\n\t * neither the receiver nor the transmitter are enabled.\n\t */\n\n\tif (wx_hw_initialize(sc)) {\n\t\treturn (EIO);\n\t}\n\n\t/*\n\t * Set up the receive ring stuff.\n\t */\n\tlen = sizeof (wxrd_t) * WX_MAX_RDESC;\n\tbzero(sc->rdescriptors, len);\n\tfor (rxpkt = sc->rbase, i = 0; rxpkt != NULL && i < WX_MAX_RDESC;\n\t    i += RXINCR, rxpkt++) {\n\t\trd = &sc->rdescriptors[i];\n\t\tif (wx_get_rbuf(sc, rxpkt)) {\n\t\t\tbreak;\n\t\t}\n\t\trd->address.lowpart = rxpkt->dma_addr + WX_RX_OFFSET_VALUE;\n\t}\n\tif (i != WX_MAX_RDESC) {\n\t\tprintf(\"%s: could not set up rbufs\\n\", sc->wx_name);\n\t\twx_stop(sc);\n\t\treturn (ENOMEM);\n\t}\n\n\t/*\n\t * Set up transmit parameters and enable the transmitter.\n\t */\n\tsc->tnxtfree = sc->tactive = 0;\n\tsc->tbsyf = sc->tbsyl = NULL;\n\tWRITE_CSR(sc, WXREG_TCTL, 0);\n\tDELAY(5 * 1000);\n\tWRITE_CSR(sc, WXREG_TDBA_LO,\n\t\tvtophys((vm_offset_t)&sc->tdescriptors[0]));\n\tWRITE_CSR(sc, WXREG_TDBA_HI, 0);\n\tWRITE_CSR(sc, WXREG_TDLEN, WX_MAX_TDESC * sizeof (wxtd_t));\n\tWRITE_CSR(sc, WXREG_TDH, 0);\n\tWRITE_CSR(sc, WXREG_TDT, 0);\n\tWRITE_CSR(sc, WXREG_TQSA_HI, 0);\n\tWRITE_CSR(sc, WXREG_TQSA_LO, 0);\n\tWRITE_CSR(sc, WXREG_TIPG, WX_TIPG_DFLT);\n\tWRITE_CSR(sc, WXREG_TIDV, sc->wx_txint_delay);\n\tWRITE_CSR(sc, WXREG_TCTL, (WXTCTL_CT(WX_COLLISION_THRESHOLD) |\n\t    WXTCTL_COLD(WX_FDX_COLLISION_DX) | WXTCTL_EN));\n\t/*\n\t * Set up receive parameters and enable the receiver.\n\t */\n\n\tsc->rnxt = 0;\n\tWRITE_CSR(sc, WXREG_RCTL, 0);\n\tDELAY(5 * 1000);\n\tWRITE_CSR(sc, WXREG_RDTR0, WXRDTR_FPD);\n\tWRITE_CSR(sc, WXREG_RDBA0_LO,\n\t    vtophys((vm_offset_t)&sc->rdescriptors[0]));\n\tWRITE_CSR(sc, WXREG_RDBA0_HI, 0);\n\tWRITE_CSR(sc, WXREG_RDLEN0, WX_MAX_RDESC * sizeof (wxrd_t));\n\tWRITE_CSR(sc, WXREG_RDH0, 0);\n\tWRITE_CSR(sc, WXREG_RDT0, (WX_MAX_RDESC - RXINCR));\n\tWRITE_CSR(sc, WXREG_RDTR1, 0);\n\tWRITE_CSR(sc, WXREG_RDBA1_LO, 0);\n\tWRITE_CSR(sc, WXREG_RDBA1_HI, 0);\n\tWRITE_CSR(sc, WXREG_RDLEN1, 0);\n\tWRITE_CSR(sc, WXREG_RDH1, 0);\n\tWRITE_CSR(sc, WXREG_RDT1, 0);\n\n\tif (ifp->if_mtu > ETHERMTU) {\n\t\tprintf(\"%s: enabling for jumbo packets\\n\", sc->wx_name);\n\t\tbflags = WXRCTL_EN | WXRCTL_LPE | WXRCTL_2KRBUF;\n\t} else {\n\t\tbflags = WXRCTL_EN | WXRCTL_2KRBUF;\n\t}\n\n\tWRITE_CSR(sc, WXREG_RCTL, bflags |\n\t    ((ifp->if_flags & IFF_BROADCAST) ? WXRCTL_BAM : 0) |\n\t    ((ifp->if_flags & IFF_PROMISC) ? WXRCTL_UPE : 0) |\n\t    ((sc->all_mcasts) ? WXRCTL_MPE : 0));\n\n\t/*\n\t * Enable Interrupts\n\t */\n\tWX_ENABLE_INT(sc);\n\n\t/*\n\t * Mark that we're up and running...\n\t */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tifm = &sc->wx_media;\n\ti = ifm->ifm_media;\n\tifm->ifm_media = ifm->ifm_cur->ifm_media;\n\twx_ifmedia_upd(ifp);\n\tifm->ifm_media = i;\n\tsplx(s);\n\n\t/*\n\t * Start stats updater.\n\t */\n\tTIMEOUT(sc, wx_stats_update, sc, hz);\n\n\t/*\n\t * And we're outta here...\n\t */\n\treturn (0);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int wx_ifmedia_upd",
            "static int wx_init",
            "static int wx_hw_initialize",
            "static void wx_stop",
            "static int wx_get_rbuf",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "static void wx_stats_update",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic int wx_ifmedia_upd;\nstatic int wx_init;\nstatic int wx_hw_initialize;\nstatic void wx_stop;\nstatic int wx_get_rbuf;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic void wx_stats_update;\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic int\nwx_init(xsc)\n\tvoid *xsc;\n{\n\tstruct ifmedia *ifm;\n\twx_softc_t *sc = xsc;\n\tstruct ifnet *ifp = &sc->wx_if;\n\trxpkt_t *rxpkt;\n\twxrd_t *rd;\n\tsize_t len;\n\tint s, i, bflags;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel any pending I/O by resetting things.\n\t * wx_stop will free any allocated mbufs.\n\t */\n\twx_stop(sc);\n\n\t/*\n\t * Reset the hardware. All network addresses loaded here, but\n\t * neither the receiver nor the transmitter are enabled.\n\t */\n\n\tif (wx_hw_initialize(sc)) {\n\t\treturn (EIO);\n\t}\n\n\t/*\n\t * Set up the receive ring stuff.\n\t */\n\tlen = sizeof (wxrd_t) * WX_MAX_RDESC;\n\tbzero(sc->rdescriptors, len);\n\tfor (rxpkt = sc->rbase, i = 0; rxpkt != NULL && i < WX_MAX_RDESC;\n\t    i += RXINCR, rxpkt++) {\n\t\trd = &sc->rdescriptors[i];\n\t\tif (wx_get_rbuf(sc, rxpkt)) {\n\t\t\tbreak;\n\t\t}\n\t\trd->address.lowpart = rxpkt->dma_addr + WX_RX_OFFSET_VALUE;\n\t}\n\tif (i != WX_MAX_RDESC) {\n\t\tprintf(\"%s: could not set up rbufs\\n\", sc->wx_name);\n\t\twx_stop(sc);\n\t\treturn (ENOMEM);\n\t}\n\n\t/*\n\t * Set up transmit parameters and enable the transmitter.\n\t */\n\tsc->tnxtfree = sc->tactive = 0;\n\tsc->tbsyf = sc->tbsyl = NULL;\n\tWRITE_CSR(sc, WXREG_TCTL, 0);\n\tDELAY(5 * 1000);\n\tWRITE_CSR(sc, WXREG_TDBA_LO,\n\t\tvtophys((vm_offset_t)&sc->tdescriptors[0]));\n\tWRITE_CSR(sc, WXREG_TDBA_HI, 0);\n\tWRITE_CSR(sc, WXREG_TDLEN, WX_MAX_TDESC * sizeof (wxtd_t));\n\tWRITE_CSR(sc, WXREG_TDH, 0);\n\tWRITE_CSR(sc, WXREG_TDT, 0);\n\tWRITE_CSR(sc, WXREG_TQSA_HI, 0);\n\tWRITE_CSR(sc, WXREG_TQSA_LO, 0);\n\tWRITE_CSR(sc, WXREG_TIPG, WX_TIPG_DFLT);\n\tWRITE_CSR(sc, WXREG_TIDV, sc->wx_txint_delay);\n\tWRITE_CSR(sc, WXREG_TCTL, (WXTCTL_CT(WX_COLLISION_THRESHOLD) |\n\t    WXTCTL_COLD(WX_FDX_COLLISION_DX) | WXTCTL_EN));\n\t/*\n\t * Set up receive parameters and enable the receiver.\n\t */\n\n\tsc->rnxt = 0;\n\tWRITE_CSR(sc, WXREG_RCTL, 0);\n\tDELAY(5 * 1000);\n\tWRITE_CSR(sc, WXREG_RDTR0, WXRDTR_FPD);\n\tWRITE_CSR(sc, WXREG_RDBA0_LO,\n\t    vtophys((vm_offset_t)&sc->rdescriptors[0]));\n\tWRITE_CSR(sc, WXREG_RDBA0_HI, 0);\n\tWRITE_CSR(sc, WXREG_RDLEN0, WX_MAX_RDESC * sizeof (wxrd_t));\n\tWRITE_CSR(sc, WXREG_RDH0, 0);\n\tWRITE_CSR(sc, WXREG_RDT0, (WX_MAX_RDESC - RXINCR));\n\tWRITE_CSR(sc, WXREG_RDTR1, 0);\n\tWRITE_CSR(sc, WXREG_RDBA1_LO, 0);\n\tWRITE_CSR(sc, WXREG_RDBA1_HI, 0);\n\tWRITE_CSR(sc, WXREG_RDLEN1, 0);\n\tWRITE_CSR(sc, WXREG_RDH1, 0);\n\tWRITE_CSR(sc, WXREG_RDT1, 0);\n\n\tif (ifp->if_mtu > ETHERMTU) {\n\t\tprintf(\"%s: enabling for jumbo packets\\n\", sc->wx_name);\n\t\tbflags = WXRCTL_EN | WXRCTL_LPE | WXRCTL_2KRBUF;\n\t} else {\n\t\tbflags = WXRCTL_EN | WXRCTL_2KRBUF;\n\t}\n\n\tWRITE_CSR(sc, WXREG_RCTL, bflags |\n\t    ((ifp->if_flags & IFF_BROADCAST) ? WXRCTL_BAM : 0) |\n\t    ((ifp->if_flags & IFF_PROMISC) ? WXRCTL_UPE : 0) |\n\t    ((sc->all_mcasts) ? WXRCTL_MPE : 0));\n\n\t/*\n\t * Enable Interrupts\n\t */\n\tWX_ENABLE_INT(sc);\n\n\t/*\n\t * Mark that we're up and running...\n\t */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tifm = &sc->wx_media;\n\ti = ifm->ifm_media;\n\tifm->ifm_media = ifm->ifm_cur->ifm_media;\n\twx_ifmedia_upd(ifp);\n\tifm->ifm_media = i;\n\tsplx(s);\n\n\t/*\n\t * Start stats updater.\n\t */\n\tTIMEOUT(sc, wx_stats_update, sc, hz);\n\n\t/*\n\t * And we're outta here...\n\t */\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "LLADDR((struct sockaddr_dl *)ifma->ifma_addr)",
            "(void *) &sc->wx_mcaddr[sc->wx_nmca++][0]",
            "6"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "LLADDR",
          "args": [
            "(struct sockaddr_dl *)ifma->ifma_addr"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wx_stop",
          "args": [
            "sc"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "wx_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "1641-1690",
          "snippet": "static void\nwx_stop(sc)\n\twx_softc_t *sc;\n{\n\ttxpkt_t *txp;\n\trxpkt_t *rxp;\n\tstruct ifnet *ifp = &sc->wx_if;\n\n\t/*\n\t * Cancel stats updater.\n\t */\n\tUNTIMEOUT(wx_stats_update, sc, sc);\n\n\t/*\n\t * Reset the chip\n\t */\n\twx_hw_stop(sc);\n\n\t/*\n\t * Release any xmit buffers.\n\t */\n\tfor (txp = sc->tbase; txp && txp < &sc->tbase[WX_MAX_TDESC]; txp++) {\n\t\tif (txp->dptr) {\n\t\t\tm_free(txp->dptr);\n\t\t\ttxp->dptr = NULL;\n\t\t}\n\t}\n\n\t/*\n\t * Free all the receive buffers.\n\t */\n\tfor (rxp = sc->rbase; rxp && rxp < &sc->rbase[WX_MAX_RDESC]; rxp++) {\n\t\tif (rxp->dptr) {\n\t\t\tm_free(rxp->dptr);\n\t\t\trxp->dptr = NULL;\n\t\t}\n\t}\n\n\tif (sc->rpending) {\n\t\tm_freem(sc->rpending);\n\t\tsc->rpending = NULL;\n\t}\n\n\t/*\n\t * And we're outta here...\n\t */\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\tifp->if_timer = 0;\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wx_hw_stop",
            "static void wx_stop",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "static void wx_stats_update",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic void wx_hw_stop;\nstatic void wx_stop;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic void wx_stats_update;\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic void\nwx_stop(sc)\n\twx_softc_t *sc;\n{\n\ttxpkt_t *txp;\n\trxpkt_t *rxp;\n\tstruct ifnet *ifp = &sc->wx_if;\n\n\t/*\n\t * Cancel stats updater.\n\t */\n\tUNTIMEOUT(wx_stats_update, sc, sc);\n\n\t/*\n\t * Reset the chip\n\t */\n\twx_hw_stop(sc);\n\n\t/*\n\t * Release any xmit buffers.\n\t */\n\tfor (txp = sc->tbase; txp && txp < &sc->tbase[WX_MAX_TDESC]; txp++) {\n\t\tif (txp->dptr) {\n\t\t\tm_free(txp->dptr);\n\t\t\ttxp->dptr = NULL;\n\t\t}\n\t}\n\n\t/*\n\t * Free all the receive buffers.\n\t */\n\tfor (rxp = sc->rbase; rxp && rxp < &sc->rbase[WX_MAX_RDESC]; rxp++) {\n\t\tif (rxp->dptr) {\n\t\t\tm_free(rxp->dptr);\n\t\t\trxp->dptr = NULL;\n\t\t}\n\t}\n\n\tif (sc->rpending) {\n\t\tm_freem(sc->rpending);\n\t\tsc->rpending = NULL;\n\t}\n\n\t/*\n\t * And we're outta here...\n\t */\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\tifp->if_timer = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic int wx_init;\nstatic void wx_stop;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic int\nwx_mc_setup(sc)\n\twx_softc_t *sc;\n{\n\tstruct ifnet *ifp = &sc->wx_if;\n\tstruct ifmultiaddr *ifma;\n\n\t/*\n\t * XXX: drain TX queue- use a tsleep/wakeup until done.\n\t */\n\tif (sc->tactive) {\n\t\treturn (EBUSY);\n\t}\n\n\twx_stop(sc);\n\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\tsc->all_mcasts = 1;\n\t\treturn (wx_init(sc));\n\t}\n\n\tfor (ifma = ifp->if_multiaddrs.lh_first, sc->wx_nmca = 0;\n\t    ifma != NULL; ifma = ifma->ifma_link.le_next) {\n\t\tif (ifma->ifma_addr->sa_family != AF_LINK) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (sc->wx_nmca >= WX_RAL_TAB_SIZE-1) {\n\t\t\tsc->wx_nmca = 0;\n\t\t\tsc->all_mcasts = 1;\n\t\t\tbreak;\n\t\t}\n\t\tbcopy(LLADDR((struct sockaddr_dl *)ifma->ifma_addr),\n\t\t    (void *) &sc->wx_mcaddr[sc->wx_nmca++][0], 6);\n\t}\n\treturn (wx_init(sc));\n}"
  },
  {
    "function_name": "wx_dring_teardown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "471-483",
    "snippet": "static void\nwx_dring_teardown(sc)\n\twx_softc_t *sc;\n{\n\tif (sc->rdescriptors) {\n\t\tWXFREE(sc->rdescriptors);\n\t\tsc->rdescriptors = NULL;\n\t}\n\tif (sc->tdescriptors) {\n\t\tWXFREE(sc->tdescriptors);\n\t\tsc->tdescriptors = NULL;\n\t}\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "wx_eeprom_sibits __P((wx_softc_t *));",
      "wx_eeprom_cleanup __P((wx_softc_t *));",
      "wx_read_eeprom_word __P((wx_softc_t *, int));",
      "wx_mwi_whackon\t__P((wx_softc_t *));",
      "wx_mwi_unwhack\t__P((wx_softc_t *));",
      "static void wx_dring_teardown"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WXFREE",
          "args": [
            "sc->tdescriptors"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WXFREE",
          "args": [
            "sc->rdescriptors"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\nstatic void wx_dring_teardown;\n\nstatic void\nwx_dring_teardown(sc)\n\twx_softc_t *sc;\n{\n\tif (sc->rdescriptors) {\n\t\tWXFREE(sc->rdescriptors);\n\t\tsc->rdescriptors = NULL;\n\t}\n\tif (sc->tdescriptors) {\n\t\tWXFREE(sc->tdescriptors);\n\t\tsc->tdescriptors = NULL;\n\t}\n}"
  },
  {
    "function_name": "wx_dring_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "426-469",
    "snippet": "static int\nwx_dring_setup(sc)\n\twx_softc_t *sc;\n{\n\tsize_t len;\n\n\tlen = sizeof (wxrd_t) * WX_MAX_RDESC;\n\tif (len > NBPG) {\n\t\tprintf(\"%s: len (%lx) over a page for the receive ring\\n\",\n\t\t    sc->wx_name, len);\n\t\treturn (-1);\n\t}\n\tlen = NBPG;\n\tsc->rdescriptors = (wxrd_t *) WXMALLOC(len);\n\tif (sc->rdescriptors == NULL) {\n\t\tprintf(\"%s: could not allocate rcv descriptors\\n\", sc->wx_name);\n\t\treturn (-1);\n\t}\n\n\tif (((u_long)sc->rdescriptors) & 0xfff) {\n\t\tprintf(\"%s: rcv descriptors not 4KB aligned\\n\", sc->wx_name);\n\t\treturn (-1);\n\t}\n        bzero(sc->rdescriptors, len);\n\n\tlen = sizeof (wxtd_t) * WX_MAX_TDESC;\n\tif (len > NBPG) {\n\t\tprintf(\"%s: len (%lx) over a page for the xmit ring\\n\",\n\t\t    sc->wx_name, len);\n\t\treturn (-1);\n\t}\n\tlen = NBPG;\n\tsc->tdescriptors = (wxtd_t *) WXMALLOC(len);\n\tif (sc->tdescriptors == NULL) {\n\t\tprintf(\"%s: could not allocate xmt descriptors\\n\", sc->wx_name);\n\t\treturn (-1);\n\t}\n\tif (((u_long)sc->tdescriptors) & 0xfff) {\n\t\tprintf(\"%s: xmt descriptors not 4KB aligned\\n\", sc->wx_name);\n\t\treturn (-1);\n\t}\n        bzero(sc->tdescriptors, len);\n\treturn (0);\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "wx_eeprom_sibits __P((wx_softc_t *));",
      "wx_eeprom_cleanup __P((wx_softc_t *));",
      "wx_read_eeprom_word __P((wx_softc_t *, int));",
      "wx_mwi_whackon\t__P((wx_softc_t *));",
      "wx_mwi_unwhack\t__P((wx_softc_t *));",
      "static int wx_dring_setup"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "sc->tdescriptors",
            "len"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: xmt descriptors not 4KB aligned\\n\"",
            "sc->wx_name"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WXMALLOC",
          "args": [
            "len"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "sc->rdescriptors",
            "len"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WXMALLOC",
          "args": [
            "len"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\nstatic int wx_dring_setup;\n\nstatic int\nwx_dring_setup(sc)\n\twx_softc_t *sc;\n{\n\tsize_t len;\n\n\tlen = sizeof (wxrd_t) * WX_MAX_RDESC;\n\tif (len > NBPG) {\n\t\tprintf(\"%s: len (%lx) over a page for the receive ring\\n\",\n\t\t    sc->wx_name, len);\n\t\treturn (-1);\n\t}\n\tlen = NBPG;\n\tsc->rdescriptors = (wxrd_t *) WXMALLOC(len);\n\tif (sc->rdescriptors == NULL) {\n\t\tprintf(\"%s: could not allocate rcv descriptors\\n\", sc->wx_name);\n\t\treturn (-1);\n\t}\n\n\tif (((u_long)sc->rdescriptors) & 0xfff) {\n\t\tprintf(\"%s: rcv descriptors not 4KB aligned\\n\", sc->wx_name);\n\t\treturn (-1);\n\t}\n        bzero(sc->rdescriptors, len);\n\n\tlen = sizeof (wxtd_t) * WX_MAX_TDESC;\n\tif (len > NBPG) {\n\t\tprintf(\"%s: len (%lx) over a page for the xmit ring\\n\",\n\t\t    sc->wx_name, len);\n\t\treturn (-1);\n\t}\n\tlen = NBPG;\n\tsc->tdescriptors = (wxtd_t *) WXMALLOC(len);\n\tif (sc->tdescriptors == NULL) {\n\t\tprintf(\"%s: could not allocate xmt descriptors\\n\", sc->wx_name);\n\t\treturn (-1);\n\t}\n\tif (((u_long)sc->tdescriptors) & 0xfff) {\n\t\tprintf(\"%s: xmt descriptors not 4KB aligned\\n\", sc->wx_name);\n\t\treturn (-1);\n\t}\n        bzero(sc->tdescriptors, len);\n\treturn (0);\n}"
  },
  {
    "function_name": "wx_mwi_unwhack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "416-424",
    "snippet": "static INLINE void\nwx_mwi_unwhack(sc)\n\twx_softc_t *sc;\n{\n\tif (sc->wx_cmdw & MWI) {\n\t\tpci_conf_write(sc->w.pci_pc, sc->w.pci_tag,\n\t\t    PCI_COMMAND_STATUS_REG, sc->wx_cmdw & ~MWI);\n\t}\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static INLINE void",
      "static INLINE void",
      "static INLINE void",
      "wx_eeprom_sibits __P((wx_softc_t *));",
      "static INLINE void",
      "wx_eeprom_cleanup __P((wx_softc_t *));",
      "wx_read_eeprom_word __P((wx_softc_t *, int));",
      "static INLINE void",
      "wx_mwi_whackon\t__P((wx_softc_t *));",
      "static INLINE void",
      "wx_mwi_unwhack\t__P((wx_softc_t *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "sc->w.pci_pc",
            "sc->w.pci_tag",
            "PCI_COMMAND_STATUS_REG",
            "sc->wx_cmdw & ~MWI"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic INLINE void;\nstatic INLINE void;\nstatic INLINE void;\nwx_eeprom_sibits __P((wx_softc_t *));\nstatic INLINE void;\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic INLINE void;\nwx_mwi_whackon\t__P((wx_softc_t *));\nstatic INLINE void;\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic INLINE void\nwx_mwi_unwhack(sc)\n\twx_softc_t *sc;\n{\n\tif (sc->wx_cmdw & MWI) {\n\t\tpci_conf_write(sc->w.pci_pc, sc->w.pci_tag,\n\t\t    PCI_COMMAND_STATUS_REG, sc->wx_cmdw & ~MWI);\n\t}\n}"
  },
  {
    "function_name": "wx_mwi_whackon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "406-414",
    "snippet": "static INLINE void\nwx_mwi_whackon(sc)\n\twx_softc_t *sc;\n{\n\tsc->wx_cmdw =\n\t    pci_conf_read(sc->w.pci_pc, sc->w.pci_tag, PCI_COMMAND_STATUS_REG);\n\tpci_conf_write(sc->w.pci_pc, sc->w.pci_tag,\n\t    PCI_COMMAND_STATUS_REG, sc->wx_cmdw & ~MWI);\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static INLINE void",
      "static INLINE void",
      "static INLINE void",
      "wx_eeprom_sibits __P((wx_softc_t *));",
      "static INLINE void",
      "wx_eeprom_cleanup __P((wx_softc_t *));",
      "wx_read_eeprom_word __P((wx_softc_t *, int));",
      "static INLINE void",
      "wx_mwi_whackon\t__P((wx_softc_t *));",
      "static INLINE void",
      "wx_mwi_unwhack\t__P((wx_softc_t *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "sc->w.pci_pc",
            "sc->w.pci_tag",
            "PCI_COMMAND_STATUS_REG",
            "sc->wx_cmdw & ~MWI"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "sc->w.pci_pc",
            "sc->w.pci_tag",
            "PCI_COMMAND_STATUS_REG"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic INLINE void;\nstatic INLINE void;\nstatic INLINE void;\nwx_eeprom_sibits __P((wx_softc_t *));\nstatic INLINE void;\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic INLINE void;\nwx_mwi_whackon\t__P((wx_softc_t *));\nstatic INLINE void;\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic INLINE void\nwx_mwi_whackon(sc)\n\twx_softc_t *sc;\n{\n\tsc->wx_cmdw =\n\t    pci_conf_read(sc->w.pci_pc, sc->w.pci_tag, PCI_COMMAND_STATUS_REG);\n\tpci_conf_write(sc->w.pci_pc, sc->w.pci_tag,\n\t    PCI_COMMAND_STATUS_REG, sc->wx_cmdw & ~MWI);\n}"
  },
  {
    "function_name": "wx_mc_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "363-404",
    "snippet": "static int\nwx_mc_setup(sc)\n\twx_softc_t *sc;\n{\n\tstruct ifnet *ifp = &sc->wx_if;\n\tstruct ether_multistep step;\n\tstruct ether_multi *enm;\n\n\t/*\n\t * XXX: drain TX queue- use a tsleep/wakeup until done.\n\t */\n\tif (sc->tactive) {\n\t\treturn (EBUSY);\n\t}\n\n\twx_stop(sc);\n\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\tsc->all_mcasts = 1;\n\t\treturn (wx_init(sc));\n\t}\n\n#ifdef __OpenBSD__\n\tETHER_FIRST_MULTI(step, &sc->w.arpcom, enm);\n#else\n\tETHER_FIRST_MULTI(step, &sc->w.ethercom, enm);\n#endif\n\n\twhile (enm != NULL) {\n\t\tif (memcmp(enm->enm_addrlo, enm->enm_addrhi, 6) != 0)\n\t\t\tcontinue;\n\t\tif (sc->wx_nmca >= WX_RAL_TAB_SIZE-1) {\n\t\t\tsc->wx_nmca = 0;\n\t\t\tsc->all_mcasts = 1;\n\t\t\tbreak;\n\t\t}\n\t\tbcopy(enm->enm_addrlo, \n\t\t    (void *) &sc->wx_mcaddr[sc->wx_nmca++][0], 6);\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\treturn (wx_init(sc));\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int wx_init",
      "static void wx_stop",
      "wx_eeprom_sibits __P((wx_softc_t *));",
      "wx_eeprom_cleanup __P((wx_softc_t *));",
      "wx_read_eeprom_word __P((wx_softc_t *, int));",
      "wx_mwi_whackon\t__P((wx_softc_t *));",
      "wx_mwi_unwhack\t__P((wx_softc_t *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wx_init",
          "args": [
            "sc"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "wx_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "1708-1835",
          "snippet": "static int\nwx_init(xsc)\n\tvoid *xsc;\n{\n\tstruct ifmedia *ifm;\n\twx_softc_t *sc = xsc;\n\tstruct ifnet *ifp = &sc->wx_if;\n\trxpkt_t *rxpkt;\n\twxrd_t *rd;\n\tsize_t len;\n\tint s, i, bflags;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel any pending I/O by resetting things.\n\t * wx_stop will free any allocated mbufs.\n\t */\n\twx_stop(sc);\n\n\t/*\n\t * Reset the hardware. All network addresses loaded here, but\n\t * neither the receiver nor the transmitter are enabled.\n\t */\n\n\tif (wx_hw_initialize(sc)) {\n\t\treturn (EIO);\n\t}\n\n\t/*\n\t * Set up the receive ring stuff.\n\t */\n\tlen = sizeof (wxrd_t) * WX_MAX_RDESC;\n\tbzero(sc->rdescriptors, len);\n\tfor (rxpkt = sc->rbase, i = 0; rxpkt != NULL && i < WX_MAX_RDESC;\n\t    i += RXINCR, rxpkt++) {\n\t\trd = &sc->rdescriptors[i];\n\t\tif (wx_get_rbuf(sc, rxpkt)) {\n\t\t\tbreak;\n\t\t}\n\t\trd->address.lowpart = rxpkt->dma_addr + WX_RX_OFFSET_VALUE;\n\t}\n\tif (i != WX_MAX_RDESC) {\n\t\tprintf(\"%s: could not set up rbufs\\n\", sc->wx_name);\n\t\twx_stop(sc);\n\t\treturn (ENOMEM);\n\t}\n\n\t/*\n\t * Set up transmit parameters and enable the transmitter.\n\t */\n\tsc->tnxtfree = sc->tactive = 0;\n\tsc->tbsyf = sc->tbsyl = NULL;\n\tWRITE_CSR(sc, WXREG_TCTL, 0);\n\tDELAY(5 * 1000);\n\tWRITE_CSR(sc, WXREG_TDBA_LO,\n\t\tvtophys((vm_offset_t)&sc->tdescriptors[0]));\n\tWRITE_CSR(sc, WXREG_TDBA_HI, 0);\n\tWRITE_CSR(sc, WXREG_TDLEN, WX_MAX_TDESC * sizeof (wxtd_t));\n\tWRITE_CSR(sc, WXREG_TDH, 0);\n\tWRITE_CSR(sc, WXREG_TDT, 0);\n\tWRITE_CSR(sc, WXREG_TQSA_HI, 0);\n\tWRITE_CSR(sc, WXREG_TQSA_LO, 0);\n\tWRITE_CSR(sc, WXREG_TIPG, WX_TIPG_DFLT);\n\tWRITE_CSR(sc, WXREG_TIDV, sc->wx_txint_delay);\n\tWRITE_CSR(sc, WXREG_TCTL, (WXTCTL_CT(WX_COLLISION_THRESHOLD) |\n\t    WXTCTL_COLD(WX_FDX_COLLISION_DX) | WXTCTL_EN));\n\t/*\n\t * Set up receive parameters and enable the receiver.\n\t */\n\n\tsc->rnxt = 0;\n\tWRITE_CSR(sc, WXREG_RCTL, 0);\n\tDELAY(5 * 1000);\n\tWRITE_CSR(sc, WXREG_RDTR0, WXRDTR_FPD);\n\tWRITE_CSR(sc, WXREG_RDBA0_LO,\n\t    vtophys((vm_offset_t)&sc->rdescriptors[0]));\n\tWRITE_CSR(sc, WXREG_RDBA0_HI, 0);\n\tWRITE_CSR(sc, WXREG_RDLEN0, WX_MAX_RDESC * sizeof (wxrd_t));\n\tWRITE_CSR(sc, WXREG_RDH0, 0);\n\tWRITE_CSR(sc, WXREG_RDT0, (WX_MAX_RDESC - RXINCR));\n\tWRITE_CSR(sc, WXREG_RDTR1, 0);\n\tWRITE_CSR(sc, WXREG_RDBA1_LO, 0);\n\tWRITE_CSR(sc, WXREG_RDBA1_HI, 0);\n\tWRITE_CSR(sc, WXREG_RDLEN1, 0);\n\tWRITE_CSR(sc, WXREG_RDH1, 0);\n\tWRITE_CSR(sc, WXREG_RDT1, 0);\n\n\tif (ifp->if_mtu > ETHERMTU) {\n\t\tprintf(\"%s: enabling for jumbo packets\\n\", sc->wx_name);\n\t\tbflags = WXRCTL_EN | WXRCTL_LPE | WXRCTL_2KRBUF;\n\t} else {\n\t\tbflags = WXRCTL_EN | WXRCTL_2KRBUF;\n\t}\n\n\tWRITE_CSR(sc, WXREG_RCTL, bflags |\n\t    ((ifp->if_flags & IFF_BROADCAST) ? WXRCTL_BAM : 0) |\n\t    ((ifp->if_flags & IFF_PROMISC) ? WXRCTL_UPE : 0) |\n\t    ((sc->all_mcasts) ? WXRCTL_MPE : 0));\n\n\t/*\n\t * Enable Interrupts\n\t */\n\tWX_ENABLE_INT(sc);\n\n\t/*\n\t * Mark that we're up and running...\n\t */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tifm = &sc->wx_media;\n\ti = ifm->ifm_media;\n\tifm->ifm_media = ifm->ifm_cur->ifm_media;\n\twx_ifmedia_upd(ifp);\n\tifm->ifm_media = i;\n\tsplx(s);\n\n\t/*\n\t * Start stats updater.\n\t */\n\tTIMEOUT(sc, wx_stats_update, sc, hz);\n\n\t/*\n\t * And we're outta here...\n\t */\n\treturn (0);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int wx_ifmedia_upd",
            "static int wx_init",
            "static int wx_hw_initialize",
            "static void wx_stop",
            "static int wx_get_rbuf",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "static void wx_stats_update",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic int wx_ifmedia_upd;\nstatic int wx_init;\nstatic int wx_hw_initialize;\nstatic void wx_stop;\nstatic int wx_get_rbuf;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic void wx_stats_update;\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic int\nwx_init(xsc)\n\tvoid *xsc;\n{\n\tstruct ifmedia *ifm;\n\twx_softc_t *sc = xsc;\n\tstruct ifnet *ifp = &sc->wx_if;\n\trxpkt_t *rxpkt;\n\twxrd_t *rd;\n\tsize_t len;\n\tint s, i, bflags;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel any pending I/O by resetting things.\n\t * wx_stop will free any allocated mbufs.\n\t */\n\twx_stop(sc);\n\n\t/*\n\t * Reset the hardware. All network addresses loaded here, but\n\t * neither the receiver nor the transmitter are enabled.\n\t */\n\n\tif (wx_hw_initialize(sc)) {\n\t\treturn (EIO);\n\t}\n\n\t/*\n\t * Set up the receive ring stuff.\n\t */\n\tlen = sizeof (wxrd_t) * WX_MAX_RDESC;\n\tbzero(sc->rdescriptors, len);\n\tfor (rxpkt = sc->rbase, i = 0; rxpkt != NULL && i < WX_MAX_RDESC;\n\t    i += RXINCR, rxpkt++) {\n\t\trd = &sc->rdescriptors[i];\n\t\tif (wx_get_rbuf(sc, rxpkt)) {\n\t\t\tbreak;\n\t\t}\n\t\trd->address.lowpart = rxpkt->dma_addr + WX_RX_OFFSET_VALUE;\n\t}\n\tif (i != WX_MAX_RDESC) {\n\t\tprintf(\"%s: could not set up rbufs\\n\", sc->wx_name);\n\t\twx_stop(sc);\n\t\treturn (ENOMEM);\n\t}\n\n\t/*\n\t * Set up transmit parameters and enable the transmitter.\n\t */\n\tsc->tnxtfree = sc->tactive = 0;\n\tsc->tbsyf = sc->tbsyl = NULL;\n\tWRITE_CSR(sc, WXREG_TCTL, 0);\n\tDELAY(5 * 1000);\n\tWRITE_CSR(sc, WXREG_TDBA_LO,\n\t\tvtophys((vm_offset_t)&sc->tdescriptors[0]));\n\tWRITE_CSR(sc, WXREG_TDBA_HI, 0);\n\tWRITE_CSR(sc, WXREG_TDLEN, WX_MAX_TDESC * sizeof (wxtd_t));\n\tWRITE_CSR(sc, WXREG_TDH, 0);\n\tWRITE_CSR(sc, WXREG_TDT, 0);\n\tWRITE_CSR(sc, WXREG_TQSA_HI, 0);\n\tWRITE_CSR(sc, WXREG_TQSA_LO, 0);\n\tWRITE_CSR(sc, WXREG_TIPG, WX_TIPG_DFLT);\n\tWRITE_CSR(sc, WXREG_TIDV, sc->wx_txint_delay);\n\tWRITE_CSR(sc, WXREG_TCTL, (WXTCTL_CT(WX_COLLISION_THRESHOLD) |\n\t    WXTCTL_COLD(WX_FDX_COLLISION_DX) | WXTCTL_EN));\n\t/*\n\t * Set up receive parameters and enable the receiver.\n\t */\n\n\tsc->rnxt = 0;\n\tWRITE_CSR(sc, WXREG_RCTL, 0);\n\tDELAY(5 * 1000);\n\tWRITE_CSR(sc, WXREG_RDTR0, WXRDTR_FPD);\n\tWRITE_CSR(sc, WXREG_RDBA0_LO,\n\t    vtophys((vm_offset_t)&sc->rdescriptors[0]));\n\tWRITE_CSR(sc, WXREG_RDBA0_HI, 0);\n\tWRITE_CSR(sc, WXREG_RDLEN0, WX_MAX_RDESC * sizeof (wxrd_t));\n\tWRITE_CSR(sc, WXREG_RDH0, 0);\n\tWRITE_CSR(sc, WXREG_RDT0, (WX_MAX_RDESC - RXINCR));\n\tWRITE_CSR(sc, WXREG_RDTR1, 0);\n\tWRITE_CSR(sc, WXREG_RDBA1_LO, 0);\n\tWRITE_CSR(sc, WXREG_RDBA1_HI, 0);\n\tWRITE_CSR(sc, WXREG_RDLEN1, 0);\n\tWRITE_CSR(sc, WXREG_RDH1, 0);\n\tWRITE_CSR(sc, WXREG_RDT1, 0);\n\n\tif (ifp->if_mtu > ETHERMTU) {\n\t\tprintf(\"%s: enabling for jumbo packets\\n\", sc->wx_name);\n\t\tbflags = WXRCTL_EN | WXRCTL_LPE | WXRCTL_2KRBUF;\n\t} else {\n\t\tbflags = WXRCTL_EN | WXRCTL_2KRBUF;\n\t}\n\n\tWRITE_CSR(sc, WXREG_RCTL, bflags |\n\t    ((ifp->if_flags & IFF_BROADCAST) ? WXRCTL_BAM : 0) |\n\t    ((ifp->if_flags & IFF_PROMISC) ? WXRCTL_UPE : 0) |\n\t    ((sc->all_mcasts) ? WXRCTL_MPE : 0));\n\n\t/*\n\t * Enable Interrupts\n\t */\n\tWX_ENABLE_INT(sc);\n\n\t/*\n\t * Mark that we're up and running...\n\t */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tifm = &sc->wx_media;\n\ti = ifm->ifm_media;\n\tifm->ifm_media = ifm->ifm_cur->ifm_media;\n\twx_ifmedia_upd(ifp);\n\tifm->ifm_media = i;\n\tsplx(s);\n\n\t/*\n\t * Start stats updater.\n\t */\n\tTIMEOUT(sc, wx_stats_update, sc, hz);\n\n\t/*\n\t * And we're outta here...\n\t */\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ETHER_NEXT_MULTI",
          "args": [
            "step",
            "enm"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "enm->enm_addrlo",
            "(void *) &sc->wx_mcaddr[sc->wx_nmca++][0]",
            "6"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "enm->enm_addrlo",
            "enm->enm_addrhi",
            "6"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ETHER_FIRST_MULTI",
          "args": [
            "step",
            "&sc->w.ethercom",
            "enm"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ETHER_FIRST_MULTI",
          "args": [
            "step",
            "&sc->w.arpcom",
            "enm"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wx_stop",
          "args": [
            "sc"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "wx_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "1641-1690",
          "snippet": "static void\nwx_stop(sc)\n\twx_softc_t *sc;\n{\n\ttxpkt_t *txp;\n\trxpkt_t *rxp;\n\tstruct ifnet *ifp = &sc->wx_if;\n\n\t/*\n\t * Cancel stats updater.\n\t */\n\tUNTIMEOUT(wx_stats_update, sc, sc);\n\n\t/*\n\t * Reset the chip\n\t */\n\twx_hw_stop(sc);\n\n\t/*\n\t * Release any xmit buffers.\n\t */\n\tfor (txp = sc->tbase; txp && txp < &sc->tbase[WX_MAX_TDESC]; txp++) {\n\t\tif (txp->dptr) {\n\t\t\tm_free(txp->dptr);\n\t\t\ttxp->dptr = NULL;\n\t\t}\n\t}\n\n\t/*\n\t * Free all the receive buffers.\n\t */\n\tfor (rxp = sc->rbase; rxp && rxp < &sc->rbase[WX_MAX_RDESC]; rxp++) {\n\t\tif (rxp->dptr) {\n\t\t\tm_free(rxp->dptr);\n\t\t\trxp->dptr = NULL;\n\t\t}\n\t}\n\n\tif (sc->rpending) {\n\t\tm_freem(sc->rpending);\n\t\tsc->rpending = NULL;\n\t}\n\n\t/*\n\t * And we're outta here...\n\t */\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\tifp->if_timer = 0;\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wx_hw_stop",
            "static void wx_stop",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "static void wx_stats_update",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic void wx_hw_stop;\nstatic void wx_stop;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic void wx_stats_update;\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic void\nwx_stop(sc)\n\twx_softc_t *sc;\n{\n\ttxpkt_t *txp;\n\trxpkt_t *rxp;\n\tstruct ifnet *ifp = &sc->wx_if;\n\n\t/*\n\t * Cancel stats updater.\n\t */\n\tUNTIMEOUT(wx_stats_update, sc, sc);\n\n\t/*\n\t * Reset the chip\n\t */\n\twx_hw_stop(sc);\n\n\t/*\n\t * Release any xmit buffers.\n\t */\n\tfor (txp = sc->tbase; txp && txp < &sc->tbase[WX_MAX_TDESC]; txp++) {\n\t\tif (txp->dptr) {\n\t\t\tm_free(txp->dptr);\n\t\t\ttxp->dptr = NULL;\n\t\t}\n\t}\n\n\t/*\n\t * Free all the receive buffers.\n\t */\n\tfor (rxp = sc->rbase; rxp && rxp < &sc->rbase[WX_MAX_RDESC]; rxp++) {\n\t\tif (rxp->dptr) {\n\t\t\tm_free(rxp->dptr);\n\t\t\trxp->dptr = NULL;\n\t\t}\n\t}\n\n\tif (sc->rpending) {\n\t\tm_freem(sc->rpending);\n\t\tsc->rpending = NULL;\n\t}\n\n\t/*\n\t * And we're outta here...\n\t */\n\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\tifp->if_timer = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic int wx_init;\nstatic void wx_stop;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic int\nwx_mc_setup(sc)\n\twx_softc_t *sc;\n{\n\tstruct ifnet *ifp = &sc->wx_if;\n\tstruct ether_multistep step;\n\tstruct ether_multi *enm;\n\n\t/*\n\t * XXX: drain TX queue- use a tsleep/wakeup until done.\n\t */\n\tif (sc->tactive) {\n\t\treturn (EBUSY);\n\t}\n\n\twx_stop(sc);\n\n\tif (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {\n\t\tsc->all_mcasts = 1;\n\t\treturn (wx_init(sc));\n\t}\n\n#ifdef __OpenBSD__\n\tETHER_FIRST_MULTI(step, &sc->w.arpcom, enm);\n#else\n\tETHER_FIRST_MULTI(step, &sc->w.ethercom, enm);\n#endif\n\n\twhile (enm != NULL) {\n\t\tif (memcmp(enm->enm_addrlo, enm->enm_addrhi, 6) != 0)\n\t\t\tcontinue;\n\t\tif (sc->wx_nmca >= WX_RAL_TAB_SIZE-1) {\n\t\t\tsc->wx_nmca = 0;\n\t\t\tsc->all_mcasts = 1;\n\t\t\tbreak;\n\t\t}\n\t\tbcopy(enm->enm_addrlo, \n\t\t    (void *) &sc->wx_mcaddr[sc->wx_nmca++][0], 6);\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\treturn (wx_init(sc));\n}"
  },
  {
    "function_name": "wx_ether_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "303-356",
    "snippet": "static int\nwx_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tIOCTL_CMD_TYPE cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tint error = 0;\n\twx_softc_t *sc = SOFTC_IFP(ifp);\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\terror = wx_init(sc);\n\t\tif (error) {\n\t\t\tifp->if_flags &= ~IFF_UP;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n#ifdef __OpenBSD__\n\t\t\tarp_ifinit(&sc->w.arpcom, ifa);\n#else\n\t\t\tarp_ifinit(ifp, ifa);\n#endif\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t{\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t break;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int wx_init",
      "wx_eeprom_sibits __P((wx_softc_t *));",
      "wx_eeprom_cleanup __P((wx_softc_t *));",
      "wx_read_eeprom_word __P((wx_softc_t *, int));",
      "wx_mwi_whackon\t__P((wx_softc_t *));",
      "wx_mwi_unwhack\t__P((wx_softc_t *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "ina->x_host.c_host",
            "LLADDR(ifp->if_sadl)",
            "ifp->if_addrlen"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "LLADDR",
          "args": [
            "ifp->if_sadl"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LLADDR",
          "args": [
            "ifp->if_sadl"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_nullhost",
          "args": [
            "*ina"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IA_SNS",
          "args": [
            "ifa"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arp_ifinit",
          "args": [
            "ifp",
            "ifa"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "arp_ifinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_devar.h",
          "lines": "929-936",
          "snippet": "static void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}",
          "includes": [
            "#include <sys/devconf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/devconf.h>\n\nstatic void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wx_init",
          "args": [
            "sc"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "wx_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "1708-1835",
          "snippet": "static int\nwx_init(xsc)\n\tvoid *xsc;\n{\n\tstruct ifmedia *ifm;\n\twx_softc_t *sc = xsc;\n\tstruct ifnet *ifp = &sc->wx_if;\n\trxpkt_t *rxpkt;\n\twxrd_t *rd;\n\tsize_t len;\n\tint s, i, bflags;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel any pending I/O by resetting things.\n\t * wx_stop will free any allocated mbufs.\n\t */\n\twx_stop(sc);\n\n\t/*\n\t * Reset the hardware. All network addresses loaded here, but\n\t * neither the receiver nor the transmitter are enabled.\n\t */\n\n\tif (wx_hw_initialize(sc)) {\n\t\treturn (EIO);\n\t}\n\n\t/*\n\t * Set up the receive ring stuff.\n\t */\n\tlen = sizeof (wxrd_t) * WX_MAX_RDESC;\n\tbzero(sc->rdescriptors, len);\n\tfor (rxpkt = sc->rbase, i = 0; rxpkt != NULL && i < WX_MAX_RDESC;\n\t    i += RXINCR, rxpkt++) {\n\t\trd = &sc->rdescriptors[i];\n\t\tif (wx_get_rbuf(sc, rxpkt)) {\n\t\t\tbreak;\n\t\t}\n\t\trd->address.lowpart = rxpkt->dma_addr + WX_RX_OFFSET_VALUE;\n\t}\n\tif (i != WX_MAX_RDESC) {\n\t\tprintf(\"%s: could not set up rbufs\\n\", sc->wx_name);\n\t\twx_stop(sc);\n\t\treturn (ENOMEM);\n\t}\n\n\t/*\n\t * Set up transmit parameters and enable the transmitter.\n\t */\n\tsc->tnxtfree = sc->tactive = 0;\n\tsc->tbsyf = sc->tbsyl = NULL;\n\tWRITE_CSR(sc, WXREG_TCTL, 0);\n\tDELAY(5 * 1000);\n\tWRITE_CSR(sc, WXREG_TDBA_LO,\n\t\tvtophys((vm_offset_t)&sc->tdescriptors[0]));\n\tWRITE_CSR(sc, WXREG_TDBA_HI, 0);\n\tWRITE_CSR(sc, WXREG_TDLEN, WX_MAX_TDESC * sizeof (wxtd_t));\n\tWRITE_CSR(sc, WXREG_TDH, 0);\n\tWRITE_CSR(sc, WXREG_TDT, 0);\n\tWRITE_CSR(sc, WXREG_TQSA_HI, 0);\n\tWRITE_CSR(sc, WXREG_TQSA_LO, 0);\n\tWRITE_CSR(sc, WXREG_TIPG, WX_TIPG_DFLT);\n\tWRITE_CSR(sc, WXREG_TIDV, sc->wx_txint_delay);\n\tWRITE_CSR(sc, WXREG_TCTL, (WXTCTL_CT(WX_COLLISION_THRESHOLD) |\n\t    WXTCTL_COLD(WX_FDX_COLLISION_DX) | WXTCTL_EN));\n\t/*\n\t * Set up receive parameters and enable the receiver.\n\t */\n\n\tsc->rnxt = 0;\n\tWRITE_CSR(sc, WXREG_RCTL, 0);\n\tDELAY(5 * 1000);\n\tWRITE_CSR(sc, WXREG_RDTR0, WXRDTR_FPD);\n\tWRITE_CSR(sc, WXREG_RDBA0_LO,\n\t    vtophys((vm_offset_t)&sc->rdescriptors[0]));\n\tWRITE_CSR(sc, WXREG_RDBA0_HI, 0);\n\tWRITE_CSR(sc, WXREG_RDLEN0, WX_MAX_RDESC * sizeof (wxrd_t));\n\tWRITE_CSR(sc, WXREG_RDH0, 0);\n\tWRITE_CSR(sc, WXREG_RDT0, (WX_MAX_RDESC - RXINCR));\n\tWRITE_CSR(sc, WXREG_RDTR1, 0);\n\tWRITE_CSR(sc, WXREG_RDBA1_LO, 0);\n\tWRITE_CSR(sc, WXREG_RDBA1_HI, 0);\n\tWRITE_CSR(sc, WXREG_RDLEN1, 0);\n\tWRITE_CSR(sc, WXREG_RDH1, 0);\n\tWRITE_CSR(sc, WXREG_RDT1, 0);\n\n\tif (ifp->if_mtu > ETHERMTU) {\n\t\tprintf(\"%s: enabling for jumbo packets\\n\", sc->wx_name);\n\t\tbflags = WXRCTL_EN | WXRCTL_LPE | WXRCTL_2KRBUF;\n\t} else {\n\t\tbflags = WXRCTL_EN | WXRCTL_2KRBUF;\n\t}\n\n\tWRITE_CSR(sc, WXREG_RCTL, bflags |\n\t    ((ifp->if_flags & IFF_BROADCAST) ? WXRCTL_BAM : 0) |\n\t    ((ifp->if_flags & IFF_PROMISC) ? WXRCTL_UPE : 0) |\n\t    ((sc->all_mcasts) ? WXRCTL_MPE : 0));\n\n\t/*\n\t * Enable Interrupts\n\t */\n\tWX_ENABLE_INT(sc);\n\n\t/*\n\t * Mark that we're up and running...\n\t */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tifm = &sc->wx_media;\n\ti = ifm->ifm_media;\n\tifm->ifm_media = ifm->ifm_cur->ifm_media;\n\twx_ifmedia_upd(ifp);\n\tifm->ifm_media = i;\n\tsplx(s);\n\n\t/*\n\t * Start stats updater.\n\t */\n\tTIMEOUT(sc, wx_stats_update, sc, hz);\n\n\t/*\n\t * And we're outta here...\n\t */\n\treturn (0);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int wx_ifmedia_upd",
            "static int wx_init",
            "static int wx_hw_initialize",
            "static void wx_stop",
            "static int wx_get_rbuf",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "static void wx_stats_update",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic int wx_ifmedia_upd;\nstatic int wx_init;\nstatic int wx_hw_initialize;\nstatic void wx_stop;\nstatic int wx_get_rbuf;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic void wx_stats_update;\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic int\nwx_init(xsc)\n\tvoid *xsc;\n{\n\tstruct ifmedia *ifm;\n\twx_softc_t *sc = xsc;\n\tstruct ifnet *ifp = &sc->wx_if;\n\trxpkt_t *rxpkt;\n\twxrd_t *rd;\n\tsize_t len;\n\tint s, i, bflags;\n\n\ts = splimp();\n\n\t/*\n\t * Cancel any pending I/O by resetting things.\n\t * wx_stop will free any allocated mbufs.\n\t */\n\twx_stop(sc);\n\n\t/*\n\t * Reset the hardware. All network addresses loaded here, but\n\t * neither the receiver nor the transmitter are enabled.\n\t */\n\n\tif (wx_hw_initialize(sc)) {\n\t\treturn (EIO);\n\t}\n\n\t/*\n\t * Set up the receive ring stuff.\n\t */\n\tlen = sizeof (wxrd_t) * WX_MAX_RDESC;\n\tbzero(sc->rdescriptors, len);\n\tfor (rxpkt = sc->rbase, i = 0; rxpkt != NULL && i < WX_MAX_RDESC;\n\t    i += RXINCR, rxpkt++) {\n\t\trd = &sc->rdescriptors[i];\n\t\tif (wx_get_rbuf(sc, rxpkt)) {\n\t\t\tbreak;\n\t\t}\n\t\trd->address.lowpart = rxpkt->dma_addr + WX_RX_OFFSET_VALUE;\n\t}\n\tif (i != WX_MAX_RDESC) {\n\t\tprintf(\"%s: could not set up rbufs\\n\", sc->wx_name);\n\t\twx_stop(sc);\n\t\treturn (ENOMEM);\n\t}\n\n\t/*\n\t * Set up transmit parameters and enable the transmitter.\n\t */\n\tsc->tnxtfree = sc->tactive = 0;\n\tsc->tbsyf = sc->tbsyl = NULL;\n\tWRITE_CSR(sc, WXREG_TCTL, 0);\n\tDELAY(5 * 1000);\n\tWRITE_CSR(sc, WXREG_TDBA_LO,\n\t\tvtophys((vm_offset_t)&sc->tdescriptors[0]));\n\tWRITE_CSR(sc, WXREG_TDBA_HI, 0);\n\tWRITE_CSR(sc, WXREG_TDLEN, WX_MAX_TDESC * sizeof (wxtd_t));\n\tWRITE_CSR(sc, WXREG_TDH, 0);\n\tWRITE_CSR(sc, WXREG_TDT, 0);\n\tWRITE_CSR(sc, WXREG_TQSA_HI, 0);\n\tWRITE_CSR(sc, WXREG_TQSA_LO, 0);\n\tWRITE_CSR(sc, WXREG_TIPG, WX_TIPG_DFLT);\n\tWRITE_CSR(sc, WXREG_TIDV, sc->wx_txint_delay);\n\tWRITE_CSR(sc, WXREG_TCTL, (WXTCTL_CT(WX_COLLISION_THRESHOLD) |\n\t    WXTCTL_COLD(WX_FDX_COLLISION_DX) | WXTCTL_EN));\n\t/*\n\t * Set up receive parameters and enable the receiver.\n\t */\n\n\tsc->rnxt = 0;\n\tWRITE_CSR(sc, WXREG_RCTL, 0);\n\tDELAY(5 * 1000);\n\tWRITE_CSR(sc, WXREG_RDTR0, WXRDTR_FPD);\n\tWRITE_CSR(sc, WXREG_RDBA0_LO,\n\t    vtophys((vm_offset_t)&sc->rdescriptors[0]));\n\tWRITE_CSR(sc, WXREG_RDBA0_HI, 0);\n\tWRITE_CSR(sc, WXREG_RDLEN0, WX_MAX_RDESC * sizeof (wxrd_t));\n\tWRITE_CSR(sc, WXREG_RDH0, 0);\n\tWRITE_CSR(sc, WXREG_RDT0, (WX_MAX_RDESC - RXINCR));\n\tWRITE_CSR(sc, WXREG_RDTR1, 0);\n\tWRITE_CSR(sc, WXREG_RDBA1_LO, 0);\n\tWRITE_CSR(sc, WXREG_RDBA1_HI, 0);\n\tWRITE_CSR(sc, WXREG_RDLEN1, 0);\n\tWRITE_CSR(sc, WXREG_RDH1, 0);\n\tWRITE_CSR(sc, WXREG_RDT1, 0);\n\n\tif (ifp->if_mtu > ETHERMTU) {\n\t\tprintf(\"%s: enabling for jumbo packets\\n\", sc->wx_name);\n\t\tbflags = WXRCTL_EN | WXRCTL_LPE | WXRCTL_2KRBUF;\n\t} else {\n\t\tbflags = WXRCTL_EN | WXRCTL_2KRBUF;\n\t}\n\n\tWRITE_CSR(sc, WXREG_RCTL, bflags |\n\t    ((ifp->if_flags & IFF_BROADCAST) ? WXRCTL_BAM : 0) |\n\t    ((ifp->if_flags & IFF_PROMISC) ? WXRCTL_UPE : 0) |\n\t    ((sc->all_mcasts) ? WXRCTL_MPE : 0));\n\n\t/*\n\t * Enable Interrupts\n\t */\n\tWX_ENABLE_INT(sc);\n\n\t/*\n\t * Mark that we're up and running...\n\t */\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\n\tifm = &sc->wx_media;\n\ti = ifm->ifm_media;\n\tifm->ifm_media = ifm->ifm_cur->ifm_media;\n\twx_ifmedia_upd(ifp);\n\tifm->ifm_media = i;\n\tsplx(s);\n\n\t/*\n\t * Start stats updater.\n\t */\n\tTIMEOUT(sc, wx_stats_update, sc, hz);\n\n\t/*\n\t * And we're outta here...\n\t */\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SOFTC_IFP",
          "args": [
            "ifp"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic int wx_init;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic int\nwx_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tIOCTL_CMD_TYPE cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tint error = 0;\n\twx_softc_t *sc = SOFTC_IFP(ifp);\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\t\terror = wx_init(sc);\n\t\tif (error) {\n\t\t\tifp->if_flags &= ~IFF_UP;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n#ifdef __OpenBSD__\n\t\t\tarp_ifinit(&sc->w.arpcom, ifa);\n#else\n\t\t\tarp_ifinit(ifp, ifa);\n#endif\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t{\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t break;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "wx_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "296-301",
    "snippet": "static void\nwx_shutdown(sc)\n\tvoid *sc;\n{\n\twx_hw_stop((wx_softc_t *) sc);\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wx_hw_stop",
      "wx_eeprom_sibits __P((wx_softc_t *));",
      "wx_eeprom_cleanup __P((wx_softc_t *));",
      "wx_read_eeprom_word __P((wx_softc_t *, int));",
      "wx_mwi_whackon\t__P((wx_softc_t *));",
      "wx_mwi_unwhack\t__P((wx_softc_t *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wx_hw_stop",
          "args": [
            "(wx_softc_t *) sc"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "wx_hw_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "1515-1531",
          "snippet": "static void\nwx_hw_stop(sc)\n\twx_softc_t *sc;\n{\n\tu_int32_t icr;\n\tif (sc->revision == 2) {\n\t\twx_mwi_whackon(sc);\n\t}\n\tWRITE_CSR(sc, WXREG_DCR, WXDCR_RST);\n\tDELAY(20 * 1000);\n\tWRITE_CSR(sc, WXREG_IMASK, ~0);\n\ticr = READ_CSR(sc, WXREG_ICR);\n\tif (sc->revision == 2) {\n\t\twx_mwi_unwhack(sc);\n\t}\n\tWX_DISABLE_INT(sc);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wx_hw_stop",
            "wx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));",
            "wx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic void wx_hw_stop;\nwx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));\nwx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic void\nwx_hw_stop(sc)\n\twx_softc_t *sc;\n{\n\tu_int32_t icr;\n\tif (sc->revision == 2) {\n\t\twx_mwi_whackon(sc);\n\t}\n\tWRITE_CSR(sc, WXREG_DCR, WXDCR_RST);\n\tDELAY(20 * 1000);\n\tWRITE_CSR(sc, WXREG_IMASK, ~0);\n\ticr = READ_CSR(sc, WXREG_ICR);\n\tif (sc->revision == 2) {\n\t\twx_mwi_unwhack(sc);\n\t}\n\tWX_DISABLE_INT(sc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic void wx_hw_stop;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic void\nwx_shutdown(sc)\n\tvoid *sc;\n{\n\twx_hw_stop((wx_softc_t *) sc);\n}"
  },
  {
    "function_name": "wx_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "190-289",
    "snippet": "static void\nwx_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\twx_softc_t *tmp, *sc = (wx_softc_t *)self;\n\tstruct pci_attach_args *pa = aux;\n\tpci_chipset_tag_t pc = pa->pa_pc;\n\tpci_intr_handle_t ih;\n\tconst char *intrstr = NULL;\n\tu_int32_t data;\n\tstruct ifnet *ifp;\n\n\tsc->w.pci_pc = pa->pa_pc;\n\tsc->w.pci_tag = pa->pa_tag;\n\n\t/*\n\t * Map control/status registers.\n\t */\n\tif (pci_mapreg_map(pa, WX_MMBA, PCI_MAPREG_TYPE_MEM, 0,\n\t    &sc->w.st, &sc->w.sh, NULL, NULL)) {\n\t\tprintf(\": can't map registers\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * Allocate our interrupt.\n\t */\n\tif (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,\n\t    pa->pa_intrline, &ih)) {\n\t\tprintf(\"%s: couldn't map interrupt\\n\", sc->wx_name);\n\t\treturn;\n\t}\n\tintrstr = pci_intr_string(pc, ih);\n#if defined(__OpenBSD__)\n\tsc->w.ih = pci_intr_establish(pc, ih, IPL_NET, wx_intr, sc,\n\t    self->dv_xname);\n#else\n\tsc->w.ih = pci_intr_establish(pc, ih, IPL_NET, wx_intr, sc);\n#endif\n\tif (sc->w.ih == NULL) {\n\t\tprintf(\"couldn't establish interrupt\");\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\tsc->revision =\n\t\tpci_conf_read(pa->pa_pc, pa->pa_tag, PCI_CLASS_REG) & 0xff;\n\n\tdata = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_BHLC_REG);\n\tdata &= ~(PCI_CACHELINE_MASK << PCI_CACHELINE_SHIFT);\n\tdata |= (WX_CACHELINE_SIZE << PCI_CACHELINE_SHIFT);\n\tpci_conf_write(pa->pa_pc, pa->pa_tag, PCI_BHLC_REG, data);\n\n\tif (wx_attach_common(sc)) {\n\t\treturn;\n\t}\n\n\tprintf(\": %s, address %s\\n\", intrstr, ether_sprintf(sc->wx_enaddr));\n\n\tifp = &sc->wx_if;\n\tbcopy(sc->wx_name, ifp->if_xname, IFNAMSIZ);\n\tifp->if_mtu = WX_MAXMTU;\n\tifp->if_softc = sc;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;\n\tifp->if_ioctl = wx_ioctl;\n\tifp->if_start = wx_start;\n\tifp->if_watchdog = wx_watchdog;\n\n\t/*\n\t * Attach the interface.\n\t */\n\tif_attach(ifp);\n#ifdef __OpenBSD__\n\tether_ifattach(ifp);\n#else\n\tether_ifattach(ifp, sc->wx_enaddr);\n#endif\n\n#if\tNBPFILTER > 0\n\tbpfattach(&ifp->if_bpf, ifp, DLT_EN10MB,\n\t    sizeof (struct ether_header));\n#endif\n\t/*\n\t * Add shutdown hook so that DMA is disabled prior to reboot. Not\n\t * doing do could allow DMA to corrupt kernel memory during the\n\t * reboot before the driver initializes.\n\t */\n\tshutdownhook_establish(wx_shutdown, sc);\n\n\ttmp = wxlist;\n\tif (tmp) {\n\t\twhile (tmp->wx_next)\n\t\t\ttmp = tmp->wx_next;\n\t\ttmp->wx_next = sc;\n\t} else {\n\t\twxlist = sc;\n\t}\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [
      "#define\tWX_MAXMTU\tETHERMTU",
      "#define\tWX_MAXMTU\tJUMBOMTU"
    ],
    "globals_used": [
      "static int wx_intr",
      "static void wx_start",
      "static int wx_ioctl",
      "static void wx_watchdog",
      "wx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));",
      "wx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));",
      "wx_eeprom_sibits __P((wx_softc_t *));",
      "wx_eeprom_cleanup __P((wx_softc_t *));",
      "wx_read_eeprom_word __P((wx_softc_t *, int));",
      "static int wx_attach_common",
      "wx_mwi_whackon\t__P((wx_softc_t *));",
      "wx_mwi_unwhack\t__P((wx_softc_t *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "shutdownhook_establish",
          "args": [
            "wx_shutdown",
            "sc"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpfattach",
          "args": [
            "&ifp->if_bpf",
            "ifp",
            "DLT_EN10MB",
            "sizeof (struct ether_header)"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ifattach",
          "args": [
            "ifp",
            "sc->wx_enaddr"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ifattach",
          "args": [
            "ifp"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_attach",
          "args": [
            "ifp"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "sc->wx_name",
            "ifp->if_xname",
            "IFNAMSIZ"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\": %s, address %s\\n\"",
            "intrstr",
            "ether_sprintf(sc->wx_enaddr)"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_sprintf",
          "args": [
            "sc->wx_enaddr"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wx_attach_common",
          "args": [
            "sc"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "wx_attach_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
          "lines": "778-872",
          "snippet": "static int\nwx_attach_common(sc)\n\twx_softc_t *sc;\n{\n\tsize_t len;\n\tu_int32_t tmp;\n\tint ll = 0;\n\n\t/*\n\t * First, reset the chip.\n\t */\n\twx_hw_stop(sc);\n\n\t/*\n\t * Second, validate our EEPROM.\n\t */\n\n\t/* TBD */\n\n\t/*\n\t * Third, read eeprom for our MAC address and other things.\n\t */\n\twx_read_eeprom(sc, (u_int16_t *)sc->wx_enaddr, WX_EEPROM_MAC_OFF, 3);\n\n\t/*\n\t * Fourth, establish some adapter parameters.\n\t */\n\tsc->wx_txint_delay = 128;\n\tifmedia_init(&sc->wx_media, IFM_IMASK, wx_ifmedia_upd, wx_ifmedia_sts);\n\tifmedia_add(&sc->wx_media, IFM_ETHER|IFM_1000_SX, 0, NULL);\n\tifmedia_add(&sc->wx_media, IFM_ETHER|IFM_1000_SX|IFM_FDX, 0, NULL);\n\tifmedia_set(&sc->wx_media, IFM_ETHER|IFM_1000_SX|IFM_FDX);\n\tsc->wx_media.ifm_media = sc->wx_media.ifm_cur->ifm_media;\n\tll += 1;\n\n\t/*\n\t * Fifth, establish a default device control register word.\n\t */\n\tsc->wx_dcr = 0;\n\tif (sc->wx_cfg1 & WX_EEPROM_CTLR1_FD)\n\t\tsc->wx_dcr |= WXDCR_FD;\n\tif (sc->wx_cfg1 & WX_EEPROM_CTLR1_ILOS)\n\t\tsc->wx_dcr |= WXDCR_ILOS;\n\n\ttmp = (sc->wx_cfg1 >> WX_EEPROM_CTLR1_SWDPIO_SHIFT) & WXDCR_SWDPIO_MASK;\n\tsc->wx_dcr |= (tmp << WXDCR_SWDPIO_SHIFT);\n\n\tif (sc->wx_no_ilos)\n\t\tsc->wx_dcr &= ~WXDCR_ILOS;\n\tif (sc->wx_ilos)\n\t\tsc->wx_dcr |= WXDCR_ILOS;\n\tif (sc->wx_no_flow == 0)\n\t\tsc->wx_dcr |= WXDCR_RFCE | WXDCR_TFCE;\n\n\n\t/*\n\t * Sixth, allocate various sw structures...\n\t */\n\tlen = sizeof (rxpkt_t) * WX_MAX_RDESC;\n\tsc->rbase = (rxpkt_t *) WXMALLOC(len);\n\tif (sc->rbase == NULL) {\n                goto fail;\n\t}\n        bzero(sc->rbase, len);\n\tll += 1;\n\n\tlen = sizeof (txpkt_t) * WX_MAX_TDESC;\n\tsc->tbase = (txpkt_t *) WXMALLOC(len);\n        if (sc->tbase == NULL) {\n                goto fail;\n\t}\n        bzero(sc->tbase, len);\n\tll += 1;\n\n\t/*\n\t * Seventh, allocate and dma map (platform dependent) descriptor rings.\n\t * They have to be aligned on a 4KB boundary.\n\t */\n\tif (wx_dring_setup(sc) == 0) {\n\t\treturn (0);\n\t}\n\nfail:\n\tprintf(\"%s: failed to do common attach (%d)\\n\", sc->wx_name, ll);\n\twx_dring_teardown(sc);\n\tif (sc->rbase) {\n\t\tWXFREE(sc->rbase);\n\t\tsc->rbase = NULL;\n\t}\n\tif (sc->tbase) {\n\t\tWXFREE(sc->tbase);\n\t\tsc->tbase = NULL;\n\t}\n\treturn (ENOMEM);\n}",
          "includes": [
            "#include <pci/if_wxvar.h>",
            "#include <dev/pci/if_wxvar.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int wx_ifmedia_upd",
            "static void wx_ifmedia_sts",
            "static void wx_hw_stop",
            "wx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));",
            "wx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));",
            "wx_eeprom_sobits __P((wx_softc_t *, u_int16_t, u_int16_t));",
            "static INLINE u_int16_t",
            "wx_eeprom_sibits __P((wx_softc_t *));",
            "wx_eeprom_cleanup __P((wx_softc_t *));",
            "static INLINE u_int16_t",
            "wx_read_eeprom_word __P((wx_softc_t *, int));",
            "static void wx_read_eeprom",
            "static int wx_attach_common",
            "wx_mwi_whackon\t__P((wx_softc_t *));",
            "wx_mwi_unwhack\t__P((wx_softc_t *));",
            "static int wx_dring_setup",
            "static void wx_dring_teardown"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic int wx_ifmedia_upd;\nstatic void wx_ifmedia_sts;\nstatic void wx_hw_stop;\nwx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));\nwx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));\nwx_eeprom_sobits __P((wx_softc_t *, u_int16_t, u_int16_t));\nstatic INLINE u_int16_t;\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nstatic INLINE u_int16_t;\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic void wx_read_eeprom;\nstatic int wx_attach_common;\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\nstatic int wx_dring_setup;\nstatic void wx_dring_teardown;\n\nstatic int\nwx_attach_common(sc)\n\twx_softc_t *sc;\n{\n\tsize_t len;\n\tu_int32_t tmp;\n\tint ll = 0;\n\n\t/*\n\t * First, reset the chip.\n\t */\n\twx_hw_stop(sc);\n\n\t/*\n\t * Second, validate our EEPROM.\n\t */\n\n\t/* TBD */\n\n\t/*\n\t * Third, read eeprom for our MAC address and other things.\n\t */\n\twx_read_eeprom(sc, (u_int16_t *)sc->wx_enaddr, WX_EEPROM_MAC_OFF, 3);\n\n\t/*\n\t * Fourth, establish some adapter parameters.\n\t */\n\tsc->wx_txint_delay = 128;\n\tifmedia_init(&sc->wx_media, IFM_IMASK, wx_ifmedia_upd, wx_ifmedia_sts);\n\tifmedia_add(&sc->wx_media, IFM_ETHER|IFM_1000_SX, 0, NULL);\n\tifmedia_add(&sc->wx_media, IFM_ETHER|IFM_1000_SX|IFM_FDX, 0, NULL);\n\tifmedia_set(&sc->wx_media, IFM_ETHER|IFM_1000_SX|IFM_FDX);\n\tsc->wx_media.ifm_media = sc->wx_media.ifm_cur->ifm_media;\n\tll += 1;\n\n\t/*\n\t * Fifth, establish a default device control register word.\n\t */\n\tsc->wx_dcr = 0;\n\tif (sc->wx_cfg1 & WX_EEPROM_CTLR1_FD)\n\t\tsc->wx_dcr |= WXDCR_FD;\n\tif (sc->wx_cfg1 & WX_EEPROM_CTLR1_ILOS)\n\t\tsc->wx_dcr |= WXDCR_ILOS;\n\n\ttmp = (sc->wx_cfg1 >> WX_EEPROM_CTLR1_SWDPIO_SHIFT) & WXDCR_SWDPIO_MASK;\n\tsc->wx_dcr |= (tmp << WXDCR_SWDPIO_SHIFT);\n\n\tif (sc->wx_no_ilos)\n\t\tsc->wx_dcr &= ~WXDCR_ILOS;\n\tif (sc->wx_ilos)\n\t\tsc->wx_dcr |= WXDCR_ILOS;\n\tif (sc->wx_no_flow == 0)\n\t\tsc->wx_dcr |= WXDCR_RFCE | WXDCR_TFCE;\n\n\n\t/*\n\t * Sixth, allocate various sw structures...\n\t */\n\tlen = sizeof (rxpkt_t) * WX_MAX_RDESC;\n\tsc->rbase = (rxpkt_t *) WXMALLOC(len);\n\tif (sc->rbase == NULL) {\n                goto fail;\n\t}\n        bzero(sc->rbase, len);\n\tll += 1;\n\n\tlen = sizeof (txpkt_t) * WX_MAX_TDESC;\n\tsc->tbase = (txpkt_t *) WXMALLOC(len);\n        if (sc->tbase == NULL) {\n                goto fail;\n\t}\n        bzero(sc->tbase, len);\n\tll += 1;\n\n\t/*\n\t * Seventh, allocate and dma map (platform dependent) descriptor rings.\n\t * They have to be aligned on a 4KB boundary.\n\t */\n\tif (wx_dring_setup(sc) == 0) {\n\t\treturn (0);\n\t}\n\nfail:\n\tprintf(\"%s: failed to do common attach (%d)\\n\", sc->wx_name, ll);\n\twx_dring_teardown(sc);\n\tif (sc->rbase) {\n\t\tWXFREE(sc->rbase);\n\t\tsc->rbase = NULL;\n\t}\n\tif (sc->tbase) {\n\t\tWXFREE(sc->tbase);\n\t\tsc->tbase = NULL;\n\t}\n\treturn (ENOMEM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "PCI_BHLC_REG",
            "data"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "PCI_BHLC_REG"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "PCI_CLASS_REG"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_establish",
          "args": [
            "pc",
            "ih",
            "IPL_NET",
            "wx_intr",
            "sc"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_establish",
          "args": [
            "pc",
            "ih",
            "IPL_NET",
            "wx_intr",
            "sc",
            "self->dv_xname"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_string",
          "args": [
            "pc",
            "ih"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_map",
          "args": [
            "pc",
            "pa->pa_intrtag",
            "pa->pa_intrpin",
            "pa->pa_intrline",
            "&ih"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_mapreg_map",
          "args": [
            "pa",
            "WX_MMBA",
            "PCI_MAPREG_TYPE_MEM",
            "0",
            "&sc->w.st",
            "&sc->w.sh",
            "NULL",
            "NULL"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "pci_mapreg_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci_map.c",
          "lines": "230-275",
          "snippet": "int\npci_mapreg_map(pa, reg, type, busflags, tagp, handlep, basep, sizep)\n\tstruct pci_attach_args *pa;\n\tint reg, busflags;\n\tpcireg_t type;\n\tbus_space_tag_t *tagp;\n\tbus_space_handle_t *handlep;\n\tbus_addr_t *basep;\n\tbus_size_t *sizep;\n{\n\tbus_space_tag_t tag;\n\tbus_space_handle_t handle;\n\tbus_addr_t base;\n\tbus_size_t size;\n\tint flags;\n\n\tif (PCI_MAPREG_TYPE(type) == PCI_MAPREG_TYPE_IO) {\n\t\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_io_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t     &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_iot;\n\t} else {\n\t\tif ((pa->pa_flags & PCI_FLAGS_MEM_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_mem_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t      &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_memt;\n\t}\n\n\tif (bus_space_map(tag, base, size, busflags | flags, &handle))\n\t\treturn (1);\n\n\tif (tagp != 0)\n\t\t*tagp = tag;\n\tif (handlep != 0)\n\t\t*handlep = handle;\n\tif (basep != 0)\n\t\t*basep = base;\n\tif (sizep != 0)\n\t\t*sizep = size;\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nbsd_pci_io_find",
            "static int nbsd_pci_mem_find"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int nbsd_pci_io_find;\nstatic int nbsd_pci_mem_find;\n\nint\npci_mapreg_map(pa, reg, type, busflags, tagp, handlep, basep, sizep)\n\tstruct pci_attach_args *pa;\n\tint reg, busflags;\n\tpcireg_t type;\n\tbus_space_tag_t *tagp;\n\tbus_space_handle_t *handlep;\n\tbus_addr_t *basep;\n\tbus_size_t *sizep;\n{\n\tbus_space_tag_t tag;\n\tbus_space_handle_t handle;\n\tbus_addr_t base;\n\tbus_size_t size;\n\tint flags;\n\n\tif (PCI_MAPREG_TYPE(type) == PCI_MAPREG_TYPE_IO) {\n\t\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_io_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t     &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_iot;\n\t} else {\n\t\tif ((pa->pa_flags & PCI_FLAGS_MEM_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_mem_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t      &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_memt;\n\t}\n\n\tif (bus_space_map(tag, base, size, busflags | flags, &handle))\n\t\treturn (1);\n\n\tif (tagp != 0)\n\t\t*tagp = tag;\n\tif (handlep != 0)\n\t\t*handlep = handle;\n\tif (basep != 0)\n\t\t*basep = base;\n\tif (sizep != 0)\n\t\t*sizep = size;\n\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\n#define\tWX_MAXMTU\tETHERMTU\n#define\tWX_MAXMTU\tJUMBOMTU\n\nstatic int wx_intr;\nstatic void wx_start;\nstatic int wx_ioctl;\nstatic void wx_watchdog;\nwx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));\nwx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));\nwx_eeprom_sibits __P((wx_softc_t *));\nwx_eeprom_cleanup __P((wx_softc_t *));\nwx_read_eeprom_word __P((wx_softc_t *, int));\nstatic int wx_attach_common;\nwx_mwi_whackon\t__P((wx_softc_t *));\nwx_mwi_unwhack\t__P((wx_softc_t *));\n\nstatic void\nwx_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\twx_softc_t *tmp, *sc = (wx_softc_t *)self;\n\tstruct pci_attach_args *pa = aux;\n\tpci_chipset_tag_t pc = pa->pa_pc;\n\tpci_intr_handle_t ih;\n\tconst char *intrstr = NULL;\n\tu_int32_t data;\n\tstruct ifnet *ifp;\n\n\tsc->w.pci_pc = pa->pa_pc;\n\tsc->w.pci_tag = pa->pa_tag;\n\n\t/*\n\t * Map control/status registers.\n\t */\n\tif (pci_mapreg_map(pa, WX_MMBA, PCI_MAPREG_TYPE_MEM, 0,\n\t    &sc->w.st, &sc->w.sh, NULL, NULL)) {\n\t\tprintf(\": can't map registers\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * Allocate our interrupt.\n\t */\n\tif (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,\n\t    pa->pa_intrline, &ih)) {\n\t\tprintf(\"%s: couldn't map interrupt\\n\", sc->wx_name);\n\t\treturn;\n\t}\n\tintrstr = pci_intr_string(pc, ih);\n#if defined(__OpenBSD__)\n\tsc->w.ih = pci_intr_establish(pc, ih, IPL_NET, wx_intr, sc,\n\t    self->dv_xname);\n#else\n\tsc->w.ih = pci_intr_establish(pc, ih, IPL_NET, wx_intr, sc);\n#endif\n\tif (sc->w.ih == NULL) {\n\t\tprintf(\"couldn't establish interrupt\");\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\tsc->revision =\n\t\tpci_conf_read(pa->pa_pc, pa->pa_tag, PCI_CLASS_REG) & 0xff;\n\n\tdata = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_BHLC_REG);\n\tdata &= ~(PCI_CACHELINE_MASK << PCI_CACHELINE_SHIFT);\n\tdata |= (WX_CACHELINE_SIZE << PCI_CACHELINE_SHIFT);\n\tpci_conf_write(pa->pa_pc, pa->pa_tag, PCI_BHLC_REG, data);\n\n\tif (wx_attach_common(sc)) {\n\t\treturn;\n\t}\n\n\tprintf(\": %s, address %s\\n\", intrstr, ether_sprintf(sc->wx_enaddr));\n\n\tifp = &sc->wx_if;\n\tbcopy(sc->wx_name, ifp->if_xname, IFNAMSIZ);\n\tifp->if_mtu = WX_MAXMTU;\n\tifp->if_softc = sc;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;\n\tifp->if_ioctl = wx_ioctl;\n\tifp->if_start = wx_start;\n\tifp->if_watchdog = wx_watchdog;\n\n\t/*\n\t * Attach the interface.\n\t */\n\tif_attach(ifp);\n#ifdef __OpenBSD__\n\tether_ifattach(ifp);\n#else\n\tether_ifattach(ifp, sc->wx_enaddr);\n#endif\n\n#if\tNBPFILTER > 0\n\tbpfattach(&ifp->if_bpf, ifp, DLT_EN10MB,\n\t    sizeof (struct ether_header));\n#endif\n\t/*\n\t * Add shutdown hook so that DMA is disabled prior to reboot. Not\n\t * doing do could allow DMA to corrupt kernel memory during the\n\t * reboot before the driver initializes.\n\t */\n\tshutdownhook_establish(wx_shutdown, sc);\n\n\ttmp = wxlist;\n\tif (tmp) {\n\t\twhile (tmp->wx_next)\n\t\t\ttmp = tmp->wx_next;\n\t\ttmp->wx_next = sc;\n\t} else {\n\t\twxlist = sc;\n\t}\n}"
  },
  {
    "function_name": "wx_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "174-188",
    "snippet": "static int\nwx_match(parent, match, aux)\n\tstruct device *parent;\n\tMATCHARG match;\n\tvoid *aux;\n{\n\tstruct pci_attach_args *pa = aux;\n\tif (PCI_VENDOR(pa->pa_id) != WX_VENDOR_INTEL) {\n\t\treturn (0);\n\t}\n\tif (PCI_PRODUCT(pa->pa_id) != WX_PRODUCT_82452) {\n\t\treturn (0);\n\t}\n\treturn (1);\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [
      "#define\tMATCHARG\tstruct cfdata *",
      "#define\tMATCHARG\tvoid *"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PCI_PRODUCT",
          "args": [
            "pa->pa_id"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDOR",
          "args": [
            "pa->pa_id"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\n#define\tMATCHARG\tstruct cfdata *\n#define\tMATCHARG\tvoid *\n\nstatic int\nwx_match(parent, match, aux)\n\tstruct device *parent;\n\tMATCHARG match;\n\tvoid *aux;\n{\n\tstruct pci_attach_args *pa = aux;\n\tif (PCI_VENDOR(pa->pa_id) != WX_VENDOR_INTEL) {\n\t\treturn (0);\n\t}\n\tif (PCI_PRODUCT(pa->pa_id) != WX_PRODUCT_82452) {\n\t\treturn (0);\n\t}\n\treturn (1);\n}"
  },
  {
    "function_name": "_write_csr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "149-155",
    "snippet": "static INLINE void _write_csr(sc, reg, val)\n\tstruct wx_softc *sc;\n\tu_int32_t reg;\n\tu_int32_t val;\n{\n\tbus_space_write_4(sc->w.st, sc->w.sh, reg, val);\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static INLINE void",
      "wx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));",
      "static INLINE void",
      "wx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));",
      "static INLINE void",
      "static INLINE void",
      "static INLINE void",
      "static INLINE void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_4",
          "args": [
            "sc->w.st",
            "sc->w.sh",
            "reg",
            "val"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic INLINE void;\nwx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));\nstatic INLINE void;\nwx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));\nstatic INLINE void;\nstatic INLINE void;\nstatic INLINE void;\nstatic INLINE void;\n\nstatic INLINE void _write_csr(sc, reg, val)\n\tstruct wx_softc *sc;\n\tu_int32_t reg;\n\tu_int32_t val;\n{\n\tbus_space_write_4(sc->w.st, sc->w.sh, reg, val);\n}"
  },
  {
    "function_name": "_read_csr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_wx.c",
    "lines": "142-147",
    "snippet": "static INLINE u_int32_t _read_csr(sc, reg)\n\tstruct wx_softc *sc;\n\tu_int32_t reg;\n{\n\treturn bus_space_read_4(sc->w.st, sc->w.sh, reg);\n}",
    "includes": [
      "#include <pci/if_wxvar.h>",
      "#include <dev/pci/if_wxvar.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static INLINE void",
      "wx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));",
      "static INLINE void",
      "wx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));",
      "static INLINE void",
      "static INLINE void",
      "static INLINE void",
      "static INLINE void"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_read_4",
          "args": [
            "sc->w.st",
            "sc->w.sh",
            "reg"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pci/if_wxvar.h>\n#include <dev/pci/if_wxvar.h>\n\nstatic INLINE void;\nwx_eeprom_raise_clk __P((wx_softc_t *, u_int32_t));\nstatic INLINE void;\nwx_eeprom_lower_clk __P((wx_softc_t *, u_int32_t));\nstatic INLINE void;\nstatic INLINE void;\nstatic INLINE void;\nstatic INLINE void;\n\nstatic INLINE u_int32_t _read_csr(sc, reg)\n\tstruct wx_softc *sc;\n\tu_int32_t reg;\n{\n\treturn bus_space_read_4(sc->w.st, sc->w.sh, reg);\n}"
  }
]