[
  {
    "function_name": "iyprobemem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_iy.c",
    "lines": "1274-1347",
    "snippet": "void\niyprobemem(sc)\n\tstruct iy_softc *sc;\n{\n\tint iobase;\n\tint testing;\n\n\tiobase = sc->sc_iobase;\n\n\toutw(iobase + HOST_ADDR_REG, 4096-2);\n\toutw(iobase + MEM_PORT_REG, 0);\n\n\tfor (testing=65536; testing >= 4096; testing >>= 1) {\n\t\toutw(iobase + HOST_ADDR_REG, testing-2);\n\t\toutw(iobase + MEM_PORT_REG, 0xdead);\n\t\toutw(iobase + HOST_ADDR_REG, testing-2);\n\t\tif (inw(iobase + MEM_PORT_REG) != 0xdead) {\n#ifdef IYMEMDEBUG\n\t\t\tprintf(\"%s: Didn't keep 0xdead at 0x%x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, testing-2);\n#endif\n\t\t\tcontinue;\n\t\t}\n\n\t\toutw(iobase + HOST_ADDR_REG, testing-2);\n\t\toutw(iobase + MEM_PORT_REG, 0xbeef);\n\t\toutw(iobase + HOST_ADDR_REG, testing-2);\n\t\tif (inw(iobase + MEM_PORT_REG) != 0xbeef) {\n#ifdef IYMEMDEBUG\n\t\t\tprintf(\"%s: Didn't keep 0xbeef at 0x%x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, testing-2);\n#endif\n\t\t\tcontinue;\n\t\t}\n\n\t\toutw(iobase + HOST_ADDR_REG, 0);\n\t\toutw(iobase + MEM_PORT_REG, 0);\n\t\toutw(iobase + HOST_ADDR_REG, testing >> 1);\n\t\toutw(iobase + MEM_PORT_REG, testing >> 1);\n\t\toutw(iobase + HOST_ADDR_REG, 0);\n\t\tif (inw(iobase + MEM_PORT_REG) == (testing >> 1)) {\n#ifdef IYMEMDEBUG\n\t\t\tprintf(\"%s: 0x%x alias of 0x0\\n\",\n\t\t\t    sc->sc_dev.dv_xname, testing >> 1);\n#endif\n\t\t\tcontinue;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tsc->sram = testing;\n\n\tswitch(testing) {\n\t\tcase 65536:\n\t\t\t/* 4 NFS packets + overhead RX, 2 NFS + overhead TX  */\n\t\t\tsc->rx_size = 44*1024;\n\t\t\tbreak;\n\n\t\tcase 32768:\n\t\t\t/* 2 NFS packets + overhead RX, 1 NFS + overhead TX  */\n\t\t\tsc->rx_size = 22*1024;\n\t\t\tbreak;\n\n\t\tcase 16384:\n\t\t\t/* 1 NFS packet + overhead RX, 4 big packets TX */\n\t\t\tsc->rx_size = 10*1024;\n\t\t\tbreak;\n\t\tdefault:\t\n\t\t\tsc->rx_size = testing/2;\n\t\t\tbreak;\n\t}\n\tsc->tx_size = testing - sc->rx_size;\n}",
    "includes": [
      "#include <dev/ic/i82595reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void iyprobemem"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: 0x%x alias of 0x0\\n\"",
            "sc->sc_dev.dv_xname",
            "testing >> 1"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "iobase + MEM_PORT_REG"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "iobase + HOST_ADDR_REG",
            "0"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "iobase + MEM_PORT_REG",
            "testing >> 1"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "iobase + HOST_ADDR_REG",
            "testing >> 1"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "iobase + MEM_PORT_REG",
            "0"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "iobase + HOST_ADDR_REG",
            "0"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "iobase + MEM_PORT_REG"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "iobase + HOST_ADDR_REG",
            "testing-2"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "iobase + MEM_PORT_REG",
            "0xbeef"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "iobase + HOST_ADDR_REG",
            "testing-2"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "iobase + MEM_PORT_REG"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "iobase + HOST_ADDR_REG",
            "testing-2"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "iobase + MEM_PORT_REG",
            "0xdead"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "iobase + HOST_ADDR_REG",
            "testing-2"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "iobase + MEM_PORT_REG",
            "0"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "iobase + HOST_ADDR_REG",
            "4096-2"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82595reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid iyprobemem;\n\nvoid\niyprobemem(sc)\n\tstruct iy_softc *sc;\n{\n\tint iobase;\n\tint testing;\n\n\tiobase = sc->sc_iobase;\n\n\toutw(iobase + HOST_ADDR_REG, 4096-2);\n\toutw(iobase + MEM_PORT_REG, 0);\n\n\tfor (testing=65536; testing >= 4096; testing >>= 1) {\n\t\toutw(iobase + HOST_ADDR_REG, testing-2);\n\t\toutw(iobase + MEM_PORT_REG, 0xdead);\n\t\toutw(iobase + HOST_ADDR_REG, testing-2);\n\t\tif (inw(iobase + MEM_PORT_REG) != 0xdead) {\n#ifdef IYMEMDEBUG\n\t\t\tprintf(\"%s: Didn't keep 0xdead at 0x%x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, testing-2);\n#endif\n\t\t\tcontinue;\n\t\t}\n\n\t\toutw(iobase + HOST_ADDR_REG, testing-2);\n\t\toutw(iobase + MEM_PORT_REG, 0xbeef);\n\t\toutw(iobase + HOST_ADDR_REG, testing-2);\n\t\tif (inw(iobase + MEM_PORT_REG) != 0xbeef) {\n#ifdef IYMEMDEBUG\n\t\t\tprintf(\"%s: Didn't keep 0xbeef at 0x%x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, testing-2);\n#endif\n\t\t\tcontinue;\n\t\t}\n\n\t\toutw(iobase + HOST_ADDR_REG, 0);\n\t\toutw(iobase + MEM_PORT_REG, 0);\n\t\toutw(iobase + HOST_ADDR_REG, testing >> 1);\n\t\toutw(iobase + MEM_PORT_REG, testing >> 1);\n\t\toutw(iobase + HOST_ADDR_REG, 0);\n\t\tif (inw(iobase + MEM_PORT_REG) == (testing >> 1)) {\n#ifdef IYMEMDEBUG\n\t\t\tprintf(\"%s: 0x%x alias of 0x0\\n\",\n\t\t\t    sc->sc_dev.dv_xname, testing >> 1);\n#endif\n\t\t\tcontinue;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tsc->sram = testing;\n\n\tswitch(testing) {\n\t\tcase 65536:\n\t\t\t/* 4 NFS packets + overhead RX, 2 NFS + overhead TX  */\n\t\t\tsc->rx_size = 44*1024;\n\t\t\tbreak;\n\n\t\tcase 32768:\n\t\t\t/* 2 NFS packets + overhead RX, 1 NFS + overhead TX  */\n\t\t\tsc->rx_size = 22*1024;\n\t\t\tbreak;\n\n\t\tcase 16384:\n\t\t\t/* 1 NFS packet + overhead RX, 4 big packets TX */\n\t\t\tsc->rx_size = 10*1024;\n\t\t\tbreak;\n\t\tdefault:\t\n\t\t\tsc->rx_size = testing/2;\n\t\t\tbreak;\n\t}\n\tsc->tx_size = testing - sc->rx_size;\n}"
  },
  {
    "function_name": "iymbufempty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_iy.c",
    "lines": "1255-1272",
    "snippet": "void\niymbufempty(arg)\n\tvoid *arg;\n{\n\tstruct iy_softc *sc = (struct iy_softc *)arg;\n\tint s, i;\n\n\ts = splimp();\n\tfor (i = 0; i<MAX_MBS; i++) {\n\t\tif (sc->mb[i]) {\n\t\t\tm_freem(sc->mb[i]);\n\t\t\tsc->mb[i] = NULL;\n\t\t}\n\t}\n\tsc->last_mb = sc->next_mb = 0;\n\tuntimeout(iymbuffill, sc);\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/ic/i82595reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define MAX_MBS 8"
    ],
    "globals_used": [
      "void iymbuffill",
      "void iymbufempty"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "iymbuffill",
            "sc"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "sc->mb[i]"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82595reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define MAX_MBS 8\n\nvoid iymbuffill;\nvoid iymbufempty;\n\nvoid\niymbufempty(arg)\n\tvoid *arg;\n{\n\tstruct iy_softc *sc = (struct iy_softc *)arg;\n\tint s, i;\n\n\ts = splimp();\n\tfor (i = 0; i<MAX_MBS; i++) {\n\t\tif (sc->mb[i]) {\n\t\t\tm_freem(sc->mb[i]);\n\t\t\tsc->mb[i] = NULL;\n\t\t}\n\t}\n\tsc->last_mb = sc->next_mb = 0;\n\tuntimeout(iymbuffill, sc);\n\tsplx(s);\n}"
  },
  {
    "function_name": "iymbuffill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_iy.c",
    "lines": "1231-1252",
    "snippet": "void\niymbuffill(arg)\n\tvoid *arg;\n{\n\tstruct iy_softc *sc = (struct iy_softc *)arg;\n\tint s, i;\n\n\ts = splimp();\n\ti = sc->last_mb;\n\tdo {\n\t\tif (sc->mb[i] == NULL)\n\t\t\tMGET(sc->mb[i], M_DONTWAIT, MT_DATA);\n\t\tif (sc->mb[i] == NULL)\n\t\t\tbreak;\n\t\ti = (i + 1) % MAX_MBS;\n\t} while (i != sc->next_mb);\n\tsc->last_mb = i;\n\t/* If the queue was not filled, try again. */\n\tif (sc->last_mb != sc->next_mb)\n\t\ttimeout(iymbuffill, sc, 1);\n\tsplx(s); \n}",
    "includes": [
      "#include <dev/ic/i82595reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define MAX_MBS 8"
    ],
    "globals_used": [
      "void iymbuffill"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "iymbuffill",
            "sc",
            "1"
          ],
          "line": 1250
        },
        "resolved": true,
        "details": {
          "function_name": "bt_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "1300-1345",
          "snippet": "void\nbt_timeout(arg)\n\tvoid *arg;\n{\n\tstruct bt_ccb *ccb = arg;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct bt_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n#ifdef BTDIAG\n\t/*\n\t * If the ccb's mbx is not free, then the board has gone Far East?\n\t */\n\tbt_collect_mbo(sc);\n\tif (ccb->flags & CCB_SENDING) {\n\t\tprintf(\"%s: not taking commands!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n#endif\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (ccb->flags & CCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tccb->xs->error = XS_TIMEOUT;\n\t\tccb->timeout = BT_ABORT_TIMEOUT;\n\t\tccb->flags |= CCB_ABORT;\n\t\tbt_queue_ccb(sc, ccb);\n\t}\n\n\tsplx(s);\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tBT_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */"
          ],
          "globals_used": [
            "bt_finish_ccbs __P((struct bt_softc *));",
            "bt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "bt_init_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "void bt_queue_ccb",
            "void bt_collect_mbo",
            "void bt_timeout",
            "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
            "int flags;",
            "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tBT_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */\n\nbt_finish_ccbs __P((struct bt_softc *));\nbt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));\nbt_init_ccb __P((struct bt_softc *, struct bt_ccb *));\nvoid bt_queue_ccb;\nvoid bt_collect_mbo;\nvoid bt_timeout;\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nint flags;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nvoid\nbt_timeout(arg)\n\tvoid *arg;\n{\n\tstruct bt_ccb *ccb = arg;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct bt_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n#ifdef BTDIAG\n\t/*\n\t * If the ccb's mbx is not free, then the board has gone Far East?\n\t */\n\tbt_collect_mbo(sc);\n\tif (ccb->flags & CCB_SENDING) {\n\t\tprintf(\"%s: not taking commands!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n#endif\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (ccb->flags & CCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tccb->xs->error = XS_TIMEOUT;\n\t\tccb->timeout = BT_ABORT_TIMEOUT;\n\t\tccb->flags |= CCB_ABORT;\n\t\tbt_queue_ccb(sc, ccb);\n\t}\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MGET",
          "args": [
            "sc->mb[i]",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82595reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define MAX_MBS 8\n\nvoid iymbuffill;\n\nvoid\niymbuffill(arg)\n\tvoid *arg;\n{\n\tstruct iy_softc *sc = (struct iy_softc *)arg;\n\tint s, i;\n\n\ts = splimp();\n\ti = sc->last_mb;\n\tdo {\n\t\tif (sc->mb[i] == NULL)\n\t\t\tMGET(sc->mb[i], M_DONTWAIT, MT_DATA);\n\t\tif (sc->mb[i] == NULL)\n\t\t\tbreak;\n\t\ti = (i + 1) % MAX_MBS;\n\t} while (i != sc->next_mb);\n\tsc->last_mb = i;\n\t/* If the queue was not filled, try again. */\n\tif (sc->last_mb != sc->next_mb)\n\t\ttimeout(iymbuffill, sc, 1);\n\tsplx(s); \n}"
  },
  {
    "function_name": "print_rbd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_iy.c",
    "lines": "1218-1227",
    "snippet": "void\nprint_rbd(rbd)\n\tvolatile struct ie_recv_buf_desc *rbd;\n{\n\n\tprintf(\"RBD at %08lx:\\nactual %04x, next %04x, buffer %08x\\n\"\n\t    \"length %04x, mbz %04x\\n\", (u_long)rbd, rbd->ie_rbd_actual,\n\t    rbd->ie_rbd_next, rbd->ie_rbd_buffer, rbd->ie_rbd_length,\n\t    rbd->mbz);\n}",
    "includes": [
      "#include <dev/ic/i82595reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"RBD at %08lx:\\nactual %04x, next %04x, buffer %08x\\n\"\n\t    \"length %04x, mbz %04x\\n\"",
            "(u_long)rbd",
            "rbd->ie_rbd_actual",
            "rbd->ie_rbd_next",
            "rbd->ie_rbd_buffer",
            "rbd->ie_rbd_length",
            "rbd->mbz"
          ],
          "line": 1223
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82595reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\nprint_rbd(rbd)\n\tvolatile struct ie_recv_buf_desc *rbd;\n{\n\n\tprintf(\"RBD at %08lx:\\nactual %04x, next %04x, buffer %08x\\n\"\n\t    \"length %04x, mbz %04x\\n\", (u_long)rbd, rbd->ie_rbd_actual,\n\t    rbd->ie_rbd_next, rbd->ie_rbd_buffer, rbd->ie_rbd_length,\n\t    rbd->mbz);\n}"
  },
  {
    "function_name": "iy_mc_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_iy.c",
    "lines": "1189-1215",
    "snippet": "static void\niy_mc_reset(sc)\n\tstruct iy_softc *sc;\n{\n\tstruct ether_multi *enm;\n\tstruct ether_multistep step;\n\n\t/*\n\t * Step through the list of addresses.\n\t */\n\tsc->mcast_count = 0;\n\tETHER_FIRST_MULTI(step, &sc->sc_arpcom, enm);\n\twhile (enm) {\n\t\tif (sc->mcast_count >= MAXMCAST ||\n\t\t    bcmp(enm->enm_addrlo, enm->enm_addrhi, 6) != 0) {\n\t\t\tsc->sc_arpcom.ac_if.if_flags |= IFF_ALLMULTI;\n\t\t\tiyioctl(&sc->sc_arpcom.ac_if, SIOCSIFFLAGS, (void *)0);\n\t\t\tgoto setflag;\n\t\t}\n\n\t\tbcopy(enm->enm_addrlo, &sc->mcast_addrs[sc->mcast_count], 6);\n\t\tsc->mcast_count++;\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\tsetflag:\n\tsc->want_mcsetup = 1;\n}",
    "includes": [
      "#include <dev/ic/i82595reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int iyioctl"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ETHER_NEXT_MULTI",
          "args": [
            "step",
            "enm"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "enm->enm_addrlo",
            "&sc->mcast_addrs[sc->mcast_count]",
            "6"
          ],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "iyioctl",
          "args": [
            "&sc->sc_arpcom.ac_if",
            "SIOCSIFFLAGS",
            "(void *)0"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "iyioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_iy.c",
          "lines": "1073-1186",
          "snippet": "int\niyioctl(ifp, cmd, data)\n\tregister struct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct iy_softc *sc;\n\tstruct ifaddr *ifa;\n\tstruct ifreq *ifr;\n\tint s, error = 0;\n\n\tsc = ifp->if_softc;\n\tifa = (struct ifaddr *)data;\n\tifr = (struct ifreq *)data;\n\n#ifdef IYDEBUG\n\tprintf(\"iyioctl called with ifp 0x%p (%s) cmd 0x%x data 0x%p\\n\", \n\t    ifp, ifp->if_xname, cmd, data);\n#endif\n\n\ts = splimp();\n\n\tswitch (cmd) {\n\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tiyinit(sc);\n\t\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\t/* XXX - This code is probably wrong. */\n\t\tcase AF_NS:\n\t\t    {\n\t\t\tstruct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\n\t\t\tif (ns_nullhost(*ina))\n\t\t\t\tina->x_host =\n\t\t\t\t    *(union ns_host *)(sc->sc_arpcom.ac_enaddr);\n\t\t\telse\n\t\t\t\tbcopy(ina->x_host.c_host,\n\t\t\t\t    sc->sc_arpcom.ac_enaddr,\n\t\t\t\t    sizeof(sc->sc_arpcom.ac_enaddr));\n\t\t\t/* Set new address. */\n\t\t\tiyinit(sc);\n\t\t\tbreak;\n\t\t    }\n#endif /* NS */\n\t\tdefault:\n\t\t\tiyinit(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS:\n\t\tsc->promisc = ifp->if_flags & (IFF_PROMISC | IFF_ALLMULTI);\n\t\tif ((ifp->if_flags & IFF_UP) == 0 &&\n\t\t    (ifp->if_flags & IFF_RUNNING) != 0) {\n\t\t\t/*\n\t\t\t * If interface is marked down and it is running, then\n\t\t\t * stop it.\n\t\t\t */\n\t\t\tiystop(sc);\n\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\t} else if ((ifp->if_flags & IFF_UP) != 0 &&\n\t\t\t   (ifp->if_flags & IFF_RUNNING) == 0) {\n\t\t\t/*\n\t\t\t * If interface is marked up and it is stopped, then\n\t\t\t * start it.\n\t\t\t */\n\t\t\tiyinit(sc);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Reset the interface to pick up changes in any other\n\t\t\t * flags that affect hardware registers.\n\t\t\t */\n\t\t\tiystop(sc);\n\t\t\tiyinit(sc);\n\t\t}\n#ifdef IYDEBUGX\n\t\tif (ifp->if_flags & IFF_DEBUG)\n\t\t\tsc->sc_debug = IFY_ALL;\n\t\telse\n\t\t\tsc->sc_debug = 0;\n#endif\n\t\tbreak;\n\n#if 0 /* XXX */\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\terror = (cmd == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->sc_arpcom):\n\t\t    ether_delmulti(ifr, &sc->sc_arpcom);\n\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware filter\n\t\t\t * accordingly.\n\t\t\t */\n\t\t\tiy_mc_reset(sc); /* XXX */\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n#endif\n\tdefault:\n\t\terror = EINVAL;\n\t}\n\tsplx(s);\n\treturn error;\n}",
          "includes": [
            "#include <dev/ic/i82595reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int iyioctl",
            "void iyinit",
            "void iystop"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82595reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint iyioctl;\nvoid iyinit;\nvoid iystop;\n\nint\niyioctl(ifp, cmd, data)\n\tregister struct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct iy_softc *sc;\n\tstruct ifaddr *ifa;\n\tstruct ifreq *ifr;\n\tint s, error = 0;\n\n\tsc = ifp->if_softc;\n\tifa = (struct ifaddr *)data;\n\tifr = (struct ifreq *)data;\n\n#ifdef IYDEBUG\n\tprintf(\"iyioctl called with ifp 0x%p (%s) cmd 0x%x data 0x%p\\n\", \n\t    ifp, ifp->if_xname, cmd, data);\n#endif\n\n\ts = splimp();\n\n\tswitch (cmd) {\n\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tiyinit(sc);\n\t\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\t/* XXX - This code is probably wrong. */\n\t\tcase AF_NS:\n\t\t    {\n\t\t\tstruct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\n\t\t\tif (ns_nullhost(*ina))\n\t\t\t\tina->x_host =\n\t\t\t\t    *(union ns_host *)(sc->sc_arpcom.ac_enaddr);\n\t\t\telse\n\t\t\t\tbcopy(ina->x_host.c_host,\n\t\t\t\t    sc->sc_arpcom.ac_enaddr,\n\t\t\t\t    sizeof(sc->sc_arpcom.ac_enaddr));\n\t\t\t/* Set new address. */\n\t\t\tiyinit(sc);\n\t\t\tbreak;\n\t\t    }\n#endif /* NS */\n\t\tdefault:\n\t\t\tiyinit(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS:\n\t\tsc->promisc = ifp->if_flags & (IFF_PROMISC | IFF_ALLMULTI);\n\t\tif ((ifp->if_flags & IFF_UP) == 0 &&\n\t\t    (ifp->if_flags & IFF_RUNNING) != 0) {\n\t\t\t/*\n\t\t\t * If interface is marked down and it is running, then\n\t\t\t * stop it.\n\t\t\t */\n\t\t\tiystop(sc);\n\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\t} else if ((ifp->if_flags & IFF_UP) != 0 &&\n\t\t\t   (ifp->if_flags & IFF_RUNNING) == 0) {\n\t\t\t/*\n\t\t\t * If interface is marked up and it is stopped, then\n\t\t\t * start it.\n\t\t\t */\n\t\t\tiyinit(sc);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Reset the interface to pick up changes in any other\n\t\t\t * flags that affect hardware registers.\n\t\t\t */\n\t\t\tiystop(sc);\n\t\t\tiyinit(sc);\n\t\t}\n#ifdef IYDEBUGX\n\t\tif (ifp->if_flags & IFF_DEBUG)\n\t\t\tsc->sc_debug = IFY_ALL;\n\t\telse\n\t\t\tsc->sc_debug = 0;\n#endif\n\t\tbreak;\n\n#if 0 /* XXX */\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\terror = (cmd == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->sc_arpcom):\n\t\t    ether_delmulti(ifr, &sc->sc_arpcom);\n\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware filter\n\t\t\t * accordingly.\n\t\t\t */\n\t\t\tiy_mc_reset(sc); /* XXX */\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n#endif\n\tdefault:\n\t\terror = EINVAL;\n\t}\n\tsplx(s);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "enm->enm_addrlo",
            "enm->enm_addrhi",
            "6"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ETHER_FIRST_MULTI",
          "args": [
            "step",
            "&sc->sc_arpcom",
            "enm"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82595reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint iyioctl;\n\nstatic void\niy_mc_reset(sc)\n\tstruct iy_softc *sc;\n{\n\tstruct ether_multi *enm;\n\tstruct ether_multistep step;\n\n\t/*\n\t * Step through the list of addresses.\n\t */\n\tsc->mcast_count = 0;\n\tETHER_FIRST_MULTI(step, &sc->sc_arpcom, enm);\n\twhile (enm) {\n\t\tif (sc->mcast_count >= MAXMCAST ||\n\t\t    bcmp(enm->enm_addrlo, enm->enm_addrhi, 6) != 0) {\n\t\t\tsc->sc_arpcom.ac_if.if_flags |= IFF_ALLMULTI;\n\t\t\tiyioctl(&sc->sc_arpcom.ac_if, SIOCSIFFLAGS, (void *)0);\n\t\t\tgoto setflag;\n\t\t}\n\n\t\tbcopy(enm->enm_addrlo, &sc->mcast_addrs[sc->mcast_count], 6);\n\t\tsc->mcast_count++;\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\tsetflag:\n\tsc->want_mcsetup = 1;\n}"
  },
  {
    "function_name": "iyioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_iy.c",
    "lines": "1073-1186",
    "snippet": "int\niyioctl(ifp, cmd, data)\n\tregister struct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct iy_softc *sc;\n\tstruct ifaddr *ifa;\n\tstruct ifreq *ifr;\n\tint s, error = 0;\n\n\tsc = ifp->if_softc;\n\tifa = (struct ifaddr *)data;\n\tifr = (struct ifreq *)data;\n\n#ifdef IYDEBUG\n\tprintf(\"iyioctl called with ifp 0x%p (%s) cmd 0x%x data 0x%p\\n\", \n\t    ifp, ifp->if_xname, cmd, data);\n#endif\n\n\ts = splimp();\n\n\tswitch (cmd) {\n\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tiyinit(sc);\n\t\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\t/* XXX - This code is probably wrong. */\n\t\tcase AF_NS:\n\t\t    {\n\t\t\tstruct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\n\t\t\tif (ns_nullhost(*ina))\n\t\t\t\tina->x_host =\n\t\t\t\t    *(union ns_host *)(sc->sc_arpcom.ac_enaddr);\n\t\t\telse\n\t\t\t\tbcopy(ina->x_host.c_host,\n\t\t\t\t    sc->sc_arpcom.ac_enaddr,\n\t\t\t\t    sizeof(sc->sc_arpcom.ac_enaddr));\n\t\t\t/* Set new address. */\n\t\t\tiyinit(sc);\n\t\t\tbreak;\n\t\t    }\n#endif /* NS */\n\t\tdefault:\n\t\t\tiyinit(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS:\n\t\tsc->promisc = ifp->if_flags & (IFF_PROMISC | IFF_ALLMULTI);\n\t\tif ((ifp->if_flags & IFF_UP) == 0 &&\n\t\t    (ifp->if_flags & IFF_RUNNING) != 0) {\n\t\t\t/*\n\t\t\t * If interface is marked down and it is running, then\n\t\t\t * stop it.\n\t\t\t */\n\t\t\tiystop(sc);\n\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\t} else if ((ifp->if_flags & IFF_UP) != 0 &&\n\t\t\t   (ifp->if_flags & IFF_RUNNING) == 0) {\n\t\t\t/*\n\t\t\t * If interface is marked up and it is stopped, then\n\t\t\t * start it.\n\t\t\t */\n\t\t\tiyinit(sc);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Reset the interface to pick up changes in any other\n\t\t\t * flags that affect hardware registers.\n\t\t\t */\n\t\t\tiystop(sc);\n\t\t\tiyinit(sc);\n\t\t}\n#ifdef IYDEBUGX\n\t\tif (ifp->if_flags & IFF_DEBUG)\n\t\t\tsc->sc_debug = IFY_ALL;\n\t\telse\n\t\t\tsc->sc_debug = 0;\n#endif\n\t\tbreak;\n\n#if 0 /* XXX */\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\terror = (cmd == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->sc_arpcom):\n\t\t    ether_delmulti(ifr, &sc->sc_arpcom);\n\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware filter\n\t\t\t * accordingly.\n\t\t\t */\n\t\t\tiy_mc_reset(sc); /* XXX */\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n#endif\n\tdefault:\n\t\terror = EINVAL;\n\t}\n\tsplx(s);\n\treturn error;\n}",
    "includes": [
      "#include <dev/ic/i82595reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int iyioctl",
      "void iyinit",
      "void iystop"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iy_mc_reset",
          "args": [
            "sc"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "iy_mc_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_iy.c",
          "lines": "1189-1215",
          "snippet": "static void\niy_mc_reset(sc)\n\tstruct iy_softc *sc;\n{\n\tstruct ether_multi *enm;\n\tstruct ether_multistep step;\n\n\t/*\n\t * Step through the list of addresses.\n\t */\n\tsc->mcast_count = 0;\n\tETHER_FIRST_MULTI(step, &sc->sc_arpcom, enm);\n\twhile (enm) {\n\t\tif (sc->mcast_count >= MAXMCAST ||\n\t\t    bcmp(enm->enm_addrlo, enm->enm_addrhi, 6) != 0) {\n\t\t\tsc->sc_arpcom.ac_if.if_flags |= IFF_ALLMULTI;\n\t\t\tiyioctl(&sc->sc_arpcom.ac_if, SIOCSIFFLAGS, (void *)0);\n\t\t\tgoto setflag;\n\t\t}\n\n\t\tbcopy(enm->enm_addrlo, &sc->mcast_addrs[sc->mcast_count], 6);\n\t\tsc->mcast_count++;\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\tsetflag:\n\tsc->want_mcsetup = 1;\n}",
          "includes": [
            "#include <dev/ic/i82595reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int iyioctl"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82595reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint iyioctl;\n\nstatic void\niy_mc_reset(sc)\n\tstruct iy_softc *sc;\n{\n\tstruct ether_multi *enm;\n\tstruct ether_multistep step;\n\n\t/*\n\t * Step through the list of addresses.\n\t */\n\tsc->mcast_count = 0;\n\tETHER_FIRST_MULTI(step, &sc->sc_arpcom, enm);\n\twhile (enm) {\n\t\tif (sc->mcast_count >= MAXMCAST ||\n\t\t    bcmp(enm->enm_addrlo, enm->enm_addrhi, 6) != 0) {\n\t\t\tsc->sc_arpcom.ac_if.if_flags |= IFF_ALLMULTI;\n\t\t\tiyioctl(&sc->sc_arpcom.ac_if, SIOCSIFFLAGS, (void *)0);\n\t\t\tgoto setflag;\n\t\t}\n\n\t\tbcopy(enm->enm_addrlo, &sc->mcast_addrs[sc->mcast_count], 6);\n\t\tsc->mcast_count++;\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\tsetflag:\n\tsc->want_mcsetup = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_delmulti",
          "args": [
            "ifr",
            "&sc->sc_arpcom"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_addmulti",
          "args": [
            "ifr",
            "&sc->sc_arpcom"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iyinit",
          "args": [
            "sc"
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "iyinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_iy.c",
          "lines": "370-477",
          "snippet": "void\niyinit(sc)\nstruct iy_softc *sc;\n{\n\tint i;\n\tunsigned temp;\n\tstruct ifnet *ifp;\n\tint iobase;\n\n\tifp = &sc->sc_arpcom.ac_if;\n#ifdef IYDEBUG\n\tprintf(\"ifp is %p\\n\", ifp);\n#endif\n\tiobase = sc->sc_iobase;\n\n\toutb(iobase, BANK_SEL(2));\n\n\ttemp = inb(iobase + EEPROM_REG);\n\tif (temp & 0x10)\n\t\toutb(iobase + EEPROM_REG, temp & ~0x10);\n\t\n\tfor (i=0; i<6; ++i) {\n\t\toutb(iobase + I_ADD(i), sc->sc_arpcom.ac_enaddr[i]);\n\t}\n\n\ttemp = inb(iobase + REG1);\n\toutb(iobase + REG1, temp | XMT_CHAIN_INT | XMT_CHAIN_ERRSTOP |\n\t    RCV_DISCARD_BAD);\n\t\n\ttemp = inb(iobase + RECV_MODES_REG);\n\toutb(iobase + RECV_MODES_REG, temp | MATCH_BRDCST);\n#ifdef IYDEBUG\n\tprintf(\"%s: RECV_MODES were %b set to %b\\n\",\n\t    sc->sc_dev.dv_xname, \n\t    temp, \"\\020\\1PRMSC\\2NOBRDST\\3SEECRC\\4LENGTH\\5NOSaIns\\6MultiIA\",\n\t    temp|MATCH_BRDCST,\n\t    \"\\020\\1PRMSC\\2NOBRDST\\3SEECRC\\4LENGTH\\5NOSaIns\\6MultiIA\");\n#endif\n\n\n\tDELAY(500000); /* for the hardware to test for the connector */\n\n\ttemp = inb(iobase + MEDIA_SELECT);\n#ifdef IYDEBUG\n\tprintf(\"%s: media select was 0x%b\", sc->sc_dev.dv_xname,\n\t    temp, \"\\020\\1LnkInDis\\2PolCor\\3TPE\\4JabberDis\\5NoAport\\6BNC\");\n#endif\n\ttemp = (temp & TEST_MODE_MASK) /* | BNC_BIT XXX*/;\n\toutb(iobase + MEDIA_SELECT, temp);\n#ifdef IYDEBUG\n\tprintf(\"changed to 0x%b\\n\", \n\t    temp, \"\\020\\1LnkInDis\\2PolCor\\3TPE\\4JabberDis\\5NoAport\\6BNC\");\n#endif\n\n\toutb(iobase, BANK_SEL(1));\n\n\ttemp = inb(iobase + INT_NO_REG);\n\toutb(iobase + INT_NO_REG, (temp & 0xf8) | sc->mappedirq);\n\n#ifdef IYDEBUG\n\tprintf(\"%s: int no was %b\\n\", sc->sc_dev.dv_xname,\n\t    temp, \"\\020\\4bad_irq\\010flash/boot present\");\n\ttemp = inb(iobase + INT_NO_REG);\n\tprintf(\"%s: int no now 0x%02x\\n\", sc->sc_dev.dv_xname,\n\t    temp, \"\\020\\4BAD IRQ\\010flash/boot present\");\n#endif\n\n\n\toutb(iobase + RCV_LOWER_LIMIT_REG, 0);\n\toutb(iobase + RCV_UPPER_LIMIT_REG, (sc->rx_size - 2) >> 8);\n\toutb(iobase + XMT_LOWER_LIMIT_REG, sc->rx_size >> 8);\n\toutb(iobase + XMT_UPPER_LIMIT_REG, sc->sram >> 8);\n\n\ttemp = inb(iobase + REG1);\n#ifdef IYDEBUG\n\tprintf(\"%s: HW access is %b\\n\", sc->sc_dev.dv_xname, \n\t    temp, \"\\020\\2WORD_WIDTH\\010INT_ENABLE\");\n#endif\n\toutb(iobase + REG1, temp | INT_ENABLE); /* XXX what about WORD_WIDTH? */\n\n#ifdef IYDEBUG\n\ttemp = inb(iobase + REG1);\n\tprintf(\"%s: HW access is %b\\n\", sc->sc_dev.dv_xname, \n\t    temp, \"\\020\\2WORD_WIDTH\\010INT_ENABLE\");\n#endif\n\n\toutb(iobase, BANK_SEL(0));\n\n\toutb(iobase + INT_MASK_REG, ALL_INTS & ~(RX_BIT|TX_BIT));\n\toutb(iobase + STATUS_REG, ALL_INTS); /* clear ints */\n\n\toutw(iobase + RCV_START_LOW, 0);\n\toutw(iobase + RCV_STOP_LOW,  sc->rx_size - 2);\n\tsc->rx_start = 0;\n\n\toutb(iobase, SEL_RESET_CMD);\n\tDELAY(200);\n\n\toutw(iobase + XMT_ADDR_REG, sc->rx_size);\n\n\tsc->tx_start = sc->tx_end = sc->rx_size;\n\tsc->tx_last = 0;\n\n\toutb(iobase, RCV_ENABLE_CMD);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n}",
          "includes": [
            "#include <dev/ic/i82595reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void iyinit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82595reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid iyinit;\n\nvoid\niyinit(sc)\nstruct iy_softc *sc;\n{\n\tint i;\n\tunsigned temp;\n\tstruct ifnet *ifp;\n\tint iobase;\n\n\tifp = &sc->sc_arpcom.ac_if;\n#ifdef IYDEBUG\n\tprintf(\"ifp is %p\\n\", ifp);\n#endif\n\tiobase = sc->sc_iobase;\n\n\toutb(iobase, BANK_SEL(2));\n\n\ttemp = inb(iobase + EEPROM_REG);\n\tif (temp & 0x10)\n\t\toutb(iobase + EEPROM_REG, temp & ~0x10);\n\t\n\tfor (i=0; i<6; ++i) {\n\t\toutb(iobase + I_ADD(i), sc->sc_arpcom.ac_enaddr[i]);\n\t}\n\n\ttemp = inb(iobase + REG1);\n\toutb(iobase + REG1, temp | XMT_CHAIN_INT | XMT_CHAIN_ERRSTOP |\n\t    RCV_DISCARD_BAD);\n\t\n\ttemp = inb(iobase + RECV_MODES_REG);\n\toutb(iobase + RECV_MODES_REG, temp | MATCH_BRDCST);\n#ifdef IYDEBUG\n\tprintf(\"%s: RECV_MODES were %b set to %b\\n\",\n\t    sc->sc_dev.dv_xname, \n\t    temp, \"\\020\\1PRMSC\\2NOBRDST\\3SEECRC\\4LENGTH\\5NOSaIns\\6MultiIA\",\n\t    temp|MATCH_BRDCST,\n\t    \"\\020\\1PRMSC\\2NOBRDST\\3SEECRC\\4LENGTH\\5NOSaIns\\6MultiIA\");\n#endif\n\n\n\tDELAY(500000); /* for the hardware to test for the connector */\n\n\ttemp = inb(iobase + MEDIA_SELECT);\n#ifdef IYDEBUG\n\tprintf(\"%s: media select was 0x%b\", sc->sc_dev.dv_xname,\n\t    temp, \"\\020\\1LnkInDis\\2PolCor\\3TPE\\4JabberDis\\5NoAport\\6BNC\");\n#endif\n\ttemp = (temp & TEST_MODE_MASK) /* | BNC_BIT XXX*/;\n\toutb(iobase + MEDIA_SELECT, temp);\n#ifdef IYDEBUG\n\tprintf(\"changed to 0x%b\\n\", \n\t    temp, \"\\020\\1LnkInDis\\2PolCor\\3TPE\\4JabberDis\\5NoAport\\6BNC\");\n#endif\n\n\toutb(iobase, BANK_SEL(1));\n\n\ttemp = inb(iobase + INT_NO_REG);\n\toutb(iobase + INT_NO_REG, (temp & 0xf8) | sc->mappedirq);\n\n#ifdef IYDEBUG\n\tprintf(\"%s: int no was %b\\n\", sc->sc_dev.dv_xname,\n\t    temp, \"\\020\\4bad_irq\\010flash/boot present\");\n\ttemp = inb(iobase + INT_NO_REG);\n\tprintf(\"%s: int no now 0x%02x\\n\", sc->sc_dev.dv_xname,\n\t    temp, \"\\020\\4BAD IRQ\\010flash/boot present\");\n#endif\n\n\n\toutb(iobase + RCV_LOWER_LIMIT_REG, 0);\n\toutb(iobase + RCV_UPPER_LIMIT_REG, (sc->rx_size - 2) >> 8);\n\toutb(iobase + XMT_LOWER_LIMIT_REG, sc->rx_size >> 8);\n\toutb(iobase + XMT_UPPER_LIMIT_REG, sc->sram >> 8);\n\n\ttemp = inb(iobase + REG1);\n#ifdef IYDEBUG\n\tprintf(\"%s: HW access is %b\\n\", sc->sc_dev.dv_xname, \n\t    temp, \"\\020\\2WORD_WIDTH\\010INT_ENABLE\");\n#endif\n\toutb(iobase + REG1, temp | INT_ENABLE); /* XXX what about WORD_WIDTH? */\n\n#ifdef IYDEBUG\n\ttemp = inb(iobase + REG1);\n\tprintf(\"%s: HW access is %b\\n\", sc->sc_dev.dv_xname, \n\t    temp, \"\\020\\2WORD_WIDTH\\010INT_ENABLE\");\n#endif\n\n\toutb(iobase, BANK_SEL(0));\n\n\toutb(iobase + INT_MASK_REG, ALL_INTS & ~(RX_BIT|TX_BIT));\n\toutb(iobase + STATUS_REG, ALL_INTS); /* clear ints */\n\n\toutw(iobase + RCV_START_LOW, 0);\n\toutw(iobase + RCV_STOP_LOW,  sc->rx_size - 2);\n\tsc->rx_start = 0;\n\n\toutb(iobase, SEL_RESET_CMD);\n\tDELAY(200);\n\n\toutw(iobase + XMT_ADDR_REG, sc->rx_size);\n\n\tsc->tx_start = sc->tx_end = sc->rx_size;\n\tsc->tx_last = 0;\n\n\toutb(iobase, RCV_ENABLE_CMD);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iystop",
          "args": [
            "sc"
          ],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "iystop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_iy.c",
          "lines": "315-357",
          "snippet": "void\niystop(sc)\nstruct iy_softc *sc;\n{\n\tint iobase;\n#ifdef IYDEBUG\n\tu_int p, v;\n#endif\n\n\tiobase = sc->sc_iobase;\n\t\n\toutb(iobase + COMMAND_REG, RCV_DISABLE_CMD);\n\n\toutb(iobase + INT_MASK_REG, ALL_INTS);\n\toutb(iobase + STATUS_REG, ALL_INTS);\n\n\toutb(iobase + COMMAND_REG, RESET_CMD);\n\tdelay(200);\n#ifdef IYDEBUG \n\tprintf(\"%s: dumping tx chain (st 0x%x end 0x%x last 0x%x)\\n\", \n\t\t    sc->sc_dev.dv_xname, sc->tx_start, sc->tx_end, sc->tx_last);\n\tp = sc->tx_last;\n\tif (!p)\n\t\tp = sc->tx_start;\n\tdo {\n\t\toutw(iobase + HOST_ADDR_REG, p);\n\t\tv = inw(iobase + MEM_PORT_REG);\n\t\tprintf(\"0x%04x: %b \", p, v, \"\\020\\006Ab\\010Dn\");\n\t\tv = inw(iobase + MEM_PORT_REG);\n\t\tprintf(\"0x%b\", v, \"\\020\\6MAX_COL\\7HRT_BEAT\\010TX_DEF\\011UND_RUN\\012JERR\\013LST_CRS\\014LTCOL\\016TX_OK\\020COLL\");\n\t\tp = inw(iobase + MEM_PORT_REG);\n\t\tprintf(\" 0x%04x\", p);\n\t\tv = inw(iobase + MEM_PORT_REG);\n\t\tprintf(\" 0x%b\\n\", v, \"\\020\\020Ch\");\n\t\t\n\t} while (v & 0x8000);\n#endif\n\tsc->tx_start = sc->tx_end = sc->rx_size;\n\tsc->tx_last = 0;\n\tsc->sc_arpcom.ac_if.if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);\n\n\tiymbufempty((void *)sc);\n}",
          "includes": [
            "#include <dev/ic/i82595reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void iystop",
            "void iymbufempty"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82595reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid iystop;\nvoid iymbufempty;\n\nvoid\niystop(sc)\nstruct iy_softc *sc;\n{\n\tint iobase;\n#ifdef IYDEBUG\n\tu_int p, v;\n#endif\n\n\tiobase = sc->sc_iobase;\n\t\n\toutb(iobase + COMMAND_REG, RCV_DISABLE_CMD);\n\n\toutb(iobase + INT_MASK_REG, ALL_INTS);\n\toutb(iobase + STATUS_REG, ALL_INTS);\n\n\toutb(iobase + COMMAND_REG, RESET_CMD);\n\tdelay(200);\n#ifdef IYDEBUG \n\tprintf(\"%s: dumping tx chain (st 0x%x end 0x%x last 0x%x)\\n\", \n\t\t    sc->sc_dev.dv_xname, sc->tx_start, sc->tx_end, sc->tx_last);\n\tp = sc->tx_last;\n\tif (!p)\n\t\tp = sc->tx_start;\n\tdo {\n\t\toutw(iobase + HOST_ADDR_REG, p);\n\t\tv = inw(iobase + MEM_PORT_REG);\n\t\tprintf(\"0x%04x: %b \", p, v, \"\\020\\006Ab\\010Dn\");\n\t\tv = inw(iobase + MEM_PORT_REG);\n\t\tprintf(\"0x%b\", v, \"\\020\\6MAX_COL\\7HRT_BEAT\\010TX_DEF\\011UND_RUN\\012JERR\\013LST_CRS\\014LTCOL\\016TX_OK\\020COLL\");\n\t\tp = inw(iobase + MEM_PORT_REG);\n\t\tprintf(\" 0x%04x\", p);\n\t\tv = inw(iobase + MEM_PORT_REG);\n\t\tprintf(\" 0x%b\\n\", v, \"\\020\\020Ch\");\n\t\t\n\t} while (v & 0x8000);\n#endif\n\tsc->tx_start = sc->tx_end = sc->rx_size;\n\tsc->tx_last = 0;\n\tsc->sc_arpcom.ac_if.if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);\n\n\tiymbufempty((void *)sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "ina->x_host.c_host",
            "sc->sc_arpcom.ac_enaddr",
            "sizeof(sc->sc_arpcom.ac_enaddr)"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns_nullhost",
          "args": [
            "*ina"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IA_SNS",
          "args": [
            "ifa"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arp_ifinit",
          "args": [
            "&sc->sc_arpcom",
            "ifa"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "arp_ifinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_devar.h",
          "lines": "929-936",
          "snippet": "static void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}",
          "includes": [
            "#include <sys/devconf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/devconf.h>\n\nstatic void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"iyioctl called with ifp 0x%p (%s) cmd 0x%x data 0x%p\\n\"",
            "ifp",
            "ifp->if_xname",
            "cmd",
            "data"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82595reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint iyioctl;\nvoid iyinit;\nvoid iystop;\n\nint\niyioctl(ifp, cmd, data)\n\tregister struct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct iy_softc *sc;\n\tstruct ifaddr *ifa;\n\tstruct ifreq *ifr;\n\tint s, error = 0;\n\n\tsc = ifp->if_softc;\n\tifa = (struct ifaddr *)data;\n\tifr = (struct ifreq *)data;\n\n#ifdef IYDEBUG\n\tprintf(\"iyioctl called with ifp 0x%p (%s) cmd 0x%x data 0x%p\\n\", \n\t    ifp, ifp->if_xname, cmd, data);\n#endif\n\n\ts = splimp();\n\n\tswitch (cmd) {\n\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tiyinit(sc);\n\t\t\tarp_ifinit(&sc->sc_arpcom, ifa);\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\t/* XXX - This code is probably wrong. */\n\t\tcase AF_NS:\n\t\t    {\n\t\t\tstruct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\n\t\t\tif (ns_nullhost(*ina))\n\t\t\t\tina->x_host =\n\t\t\t\t    *(union ns_host *)(sc->sc_arpcom.ac_enaddr);\n\t\t\telse\n\t\t\t\tbcopy(ina->x_host.c_host,\n\t\t\t\t    sc->sc_arpcom.ac_enaddr,\n\t\t\t\t    sizeof(sc->sc_arpcom.ac_enaddr));\n\t\t\t/* Set new address. */\n\t\t\tiyinit(sc);\n\t\t\tbreak;\n\t\t    }\n#endif /* NS */\n\t\tdefault:\n\t\t\tiyinit(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS:\n\t\tsc->promisc = ifp->if_flags & (IFF_PROMISC | IFF_ALLMULTI);\n\t\tif ((ifp->if_flags & IFF_UP) == 0 &&\n\t\t    (ifp->if_flags & IFF_RUNNING) != 0) {\n\t\t\t/*\n\t\t\t * If interface is marked down and it is running, then\n\t\t\t * stop it.\n\t\t\t */\n\t\t\tiystop(sc);\n\t\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\t} else if ((ifp->if_flags & IFF_UP) != 0 &&\n\t\t\t   (ifp->if_flags & IFF_RUNNING) == 0) {\n\t\t\t/*\n\t\t\t * If interface is marked up and it is stopped, then\n\t\t\t * start it.\n\t\t\t */\n\t\t\tiyinit(sc);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Reset the interface to pick up changes in any other\n\t\t\t * flags that affect hardware registers.\n\t\t\t */\n\t\t\tiystop(sc);\n\t\t\tiyinit(sc);\n\t\t}\n#ifdef IYDEBUGX\n\t\tif (ifp->if_flags & IFF_DEBUG)\n\t\t\tsc->sc_debug = IFY_ALL;\n\t\telse\n\t\t\tsc->sc_debug = 0;\n#endif\n\t\tbreak;\n\n#if 0 /* XXX */\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\terror = (cmd == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->sc_arpcom):\n\t\t    ether_delmulti(ifr, &sc->sc_arpcom);\n\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware filter\n\t\t\t * accordingly.\n\t\t\t */\n\t\t\tiy_mc_reset(sc); /* XXX */\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n#endif\n\tdefault:\n\t\terror = EINVAL;\n\t}\n\tsplx(s);\n\treturn error;\n}"
  },
  {
    "function_name": "check_eh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_iy.c",
    "lines": "969-1070",
    "snippet": "static inline int\ncheck_eh(sc, eh, to_bpf)\n\tstruct iy_softc *sc;\n\tstruct ether_header *eh;\n\tint *to_bpf;\n{\n\tint i;\n\n\tswitch (sc->promisc) {\n\tcase IFF_ALLMULTI:\n\t\t/*\n\t\t * Receiving all multicasts, but no unicasts except those\n\t\t * destined for us.\n\t\t */\n#if NBPFILTER > 0\n\t\t*to_bpf = (sc->sc_arpcom.ac_if.iy_bpf != 0); /* BPF gets this packet if anybody cares */\n#endif\n\t\tif (eh->ether_dhost[0] & 1)\n\t\t\treturn 1;\n\t\tif (ether_equal(eh->ether_dhost, sc->sc_arpcom.ac_enaddr))\n\t\t\treturn 1;\n\t\treturn 0;\n\n\tcase IFF_PROMISC:\n\t\t/*\n\t\t * Receiving all packets.  These need to be passed on to BPF.\n\t\t */\n#if NBPFILTER > 0\n\t\t*to_bpf = (sc->sc_arpcom.ac_if.iy_bpf != 0);\n#endif\n\t\t/* If for us, accept and hand up to BPF */\n\t\tif (ether_equal(eh->ether_dhost, sc->sc_arpcom.ac_enaddr))\n\t\t\treturn 1;\n\n#if NBPFILTER > 0\n\t\tif (*to_bpf)\n\t\t\t*to_bpf = 2; /* we don't need to see it */\n#endif\n\n\t\t/*\n\t\t * Not a multicast, so BPF wants to see it but we don't.\n\t\t */\n\t\tif (!(eh->ether_dhost[0] & 1))\n\t\t\treturn 1;\n\n\t\t/*\n\t\t * If it's one of our multicast groups, accept it and pass it\n\t\t * up.\n\t\t */\n\t\tfor (i = 0; i < sc->mcast_count; i++) {\n\t\t\tif (ether_equal(eh->ether_dhost, (u_char *)&sc->mcast_addrs[i])) {\n#if NBPFILTER > 0\n\t\t\t\tif (*to_bpf)\n\t\t\t\t\t*to_bpf = 1;\n#endif\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn 1;\n\n\tcase IFF_ALLMULTI | IFF_PROMISC:\n\t\t/*\n\t\t * Acting as a multicast router, and BPF running at the same\n\t\t * time.  Whew!  (Hope this is a fast machine...)\n\t\t */\n#if NBPFILTER > 0\n\t\t*to_bpf = (sc->sc_arpcom.ac_if.iy_bpf != 0);\n#endif\n\t\t/* We want to see multicasts. */\n\t\tif (eh->ether_dhost[0] & 1)\n\t\t\treturn 1;\n\n\t\t/* We want to see our own packets */\n\t\tif (ether_equal(eh->ether_dhost, sc->sc_arpcom.ac_enaddr))\n\t\t\treturn 1;\n\n\t\t/* Anything else goes to BPF but nothing else. */\n#if NBPFILTER > 0\n\t\tif (*to_bpf)\n\t\t\t*to_bpf = 2;\n#endif\n\t\treturn 1;\n\n\tcase 0:\n\t\t/*\n\t\t * Only accept unicast packets destined for us, or multicasts\n\t\t * for groups that we belong to.  For now, we assume that the\n\t\t * '586 will only return packets that we asked it for.  This\n\t\t * isn't strictly true (it uses hashing for the multicast\n\t\t * filter), but it will do in this case, and we want to get out\n\t\t * of here as quickly as possible.\n\t\t */\n#if NBPFILTER > 0\n\t\t*to_bpf = (sc->sc_arpcom.ac_if.iy_bpf != 0);\n#endif\n\t\treturn 1;\n\t}\n\n#ifdef DIAGNOSTIC\n\tpanic(\"check_eh: impossible\");\n#endif\n}",
    "includes": [
      "#include <dev/ic/i82595reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"check_eh: impossible\""
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_equal",
          "args": [
            "eh->ether_dhost",
            "sc->sc_arpcom.ac_enaddr"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "ether_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_iy.c",
          "lines": "946-955",
          "snippet": "static inline int\nether_equal(one, two)\n\tu_char *one, *two;\n{\n\n\tif (one[0] != two[0] || one[1] != two[1] || one[2] != two[2] ||\n\t    one[3] != two[3] || one[4] != two[4] || one[5] != two[5])\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <dev/ic/i82595reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82595reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic inline int\nether_equal(one, two)\n\tu_char *one, *two;\n{\n\n\tif (one[0] != two[0] || one[1] != two[1] || one[2] != two[2] ||\n\t    one[3] != two[3] || one[4] != two[4] || one[5] != two[5])\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82595reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic inline int\ncheck_eh(sc, eh, to_bpf)\n\tstruct iy_softc *sc;\n\tstruct ether_header *eh;\n\tint *to_bpf;\n{\n\tint i;\n\n\tswitch (sc->promisc) {\n\tcase IFF_ALLMULTI:\n\t\t/*\n\t\t * Receiving all multicasts, but no unicasts except those\n\t\t * destined for us.\n\t\t */\n#if NBPFILTER > 0\n\t\t*to_bpf = (sc->sc_arpcom.ac_if.iy_bpf != 0); /* BPF gets this packet if anybody cares */\n#endif\n\t\tif (eh->ether_dhost[0] & 1)\n\t\t\treturn 1;\n\t\tif (ether_equal(eh->ether_dhost, sc->sc_arpcom.ac_enaddr))\n\t\t\treturn 1;\n\t\treturn 0;\n\n\tcase IFF_PROMISC:\n\t\t/*\n\t\t * Receiving all packets.  These need to be passed on to BPF.\n\t\t */\n#if NBPFILTER > 0\n\t\t*to_bpf = (sc->sc_arpcom.ac_if.iy_bpf != 0);\n#endif\n\t\t/* If for us, accept and hand up to BPF */\n\t\tif (ether_equal(eh->ether_dhost, sc->sc_arpcom.ac_enaddr))\n\t\t\treturn 1;\n\n#if NBPFILTER > 0\n\t\tif (*to_bpf)\n\t\t\t*to_bpf = 2; /* we don't need to see it */\n#endif\n\n\t\t/*\n\t\t * Not a multicast, so BPF wants to see it but we don't.\n\t\t */\n\t\tif (!(eh->ether_dhost[0] & 1))\n\t\t\treturn 1;\n\n\t\t/*\n\t\t * If it's one of our multicast groups, accept it and pass it\n\t\t * up.\n\t\t */\n\t\tfor (i = 0; i < sc->mcast_count; i++) {\n\t\t\tif (ether_equal(eh->ether_dhost, (u_char *)&sc->mcast_addrs[i])) {\n#if NBPFILTER > 0\n\t\t\t\tif (*to_bpf)\n\t\t\t\t\t*to_bpf = 1;\n#endif\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn 1;\n\n\tcase IFF_ALLMULTI | IFF_PROMISC:\n\t\t/*\n\t\t * Acting as a multicast router, and BPF running at the same\n\t\t * time.  Whew!  (Hope this is a fast machine...)\n\t\t */\n#if NBPFILTER > 0\n\t\t*to_bpf = (sc->sc_arpcom.ac_if.iy_bpf != 0);\n#endif\n\t\t/* We want to see multicasts. */\n\t\tif (eh->ether_dhost[0] & 1)\n\t\t\treturn 1;\n\n\t\t/* We want to see our own packets */\n\t\tif (ether_equal(eh->ether_dhost, sc->sc_arpcom.ac_enaddr))\n\t\t\treturn 1;\n\n\t\t/* Anything else goes to BPF but nothing else. */\n#if NBPFILTER > 0\n\t\tif (*to_bpf)\n\t\t\t*to_bpf = 2;\n#endif\n\t\treturn 1;\n\n\tcase 0:\n\t\t/*\n\t\t * Only accept unicast packets destined for us, or multicasts\n\t\t * for groups that we belong to.  For now, we assume that the\n\t\t * '586 will only return packets that we asked it for.  This\n\t\t * isn't strictly true (it uses hashing for the multicast\n\t\t * filter), but it will do in this case, and we want to get out\n\t\t * of here as quickly as possible.\n\t\t */\n#if NBPFILTER > 0\n\t\t*to_bpf = (sc->sc_arpcom.ac_if.iy_bpf != 0);\n#endif\n\t\treturn 1;\n\t}\n\n#ifdef DIAGNOSTIC\n\tpanic(\"check_eh: impossible\");\n#endif\n}"
  },
  {
    "function_name": "ether_equal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_iy.c",
    "lines": "946-955",
    "snippet": "static inline int\nether_equal(one, two)\n\tu_char *one, *two;\n{\n\n\tif (one[0] != two[0] || one[1] != two[1] || one[2] != two[2] ||\n\t    one[3] != two[3] || one[4] != two[4] || one[5] != two[5])\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include <dev/ic/i82595reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/ic/i82595reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic inline int\nether_equal(one, two)\n\tu_char *one, *two;\n{\n\n\tif (one[0] != two[0] || one[1] != two[1] || one[2] != two[2] ||\n\t    one[3] != two[3] || one[4] != two[4] || one[5] != two[5])\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "iy_intr_tx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_iy.c",
    "lines": "901-939",
    "snippet": "void\niy_intr_tx(sc)\nstruct iy_softc *sc;\n{\n\tint iobase;\n\tstruct ifnet *ifp;\n\tu_int txstatus, txstat2, txlen, txnext;\n\n\tifp = &sc->sc_arpcom.ac_if;\n\tiobase = sc->sc_iobase;\n\t\n\twhile (sc->tx_start != sc->tx_end) {\n\t\toutw(iobase + HOST_ADDR_REG, sc->tx_start);\n\t\ttxstatus = inw(iobase + MEM_PORT_REG);\n\t\tif ((txstatus & (TX_DONE|CMD_MASK)) != (TX_DONE|XMT_CMD))\n\t\t\tbreak;\n\n\t\ttxstat2 = inw(iobase + MEM_PORT_REG);\n\t\ttxnext = inw(iobase + MEM_PORT_REG);\n\t\ttxlen = inw(iobase + MEM_PORT_REG);\n#ifdef IYDEBUG\n\t\tprintf(\"txstat 0x%x stat2 0x%b next 0x%x len 0x%x\\n\",\n\t\t    txstatus, txstat2, \"\\020\\6MAX_COL\\7HRT_BEAT\\010TX_DEF\"\n\t\t    \"\\011UND_RUN\\012JERR\\013LST_CRS\\014LTCOL\\016TX_OK\\020COLL\",\n\t\t\ttxnext, txlen);\n#endif\n\t\tif (txlen & CHAIN)\n\t\t\tsc->tx_start = txnext;\n\t\telse\n\t\t\tsc->tx_start = sc->tx_end;\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t\t\n\t\tif ((txstat2 & 0x2000) == 0)\n\t\t\t++ifp->if_oerrors;\n\t\tif (txstat2 & 0x000f)\n\t\t\tifp->if_oerrors += txstat2 & 0x000f;\n\t}\n\tifp->if_flags &= ~IFF_OACTIVE;\n}",
    "includes": [
      "#include <dev/ic/i82595reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void iy_intr_tx"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"txstat 0x%x stat2 0x%b next 0x%x len 0x%x\\n\"",
            "txstatus",
            "txstat2",
            "\"\\020\\6MAX_COL\\7HRT_BEAT\\010TX_DEF\"\n\t\t    \"\\011UND_RUN\\012JERR\\013LST_CRS\\014LTCOL\\016TX_OK\\020COLL\"",
            "txnext",
            "txlen"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "iobase + MEM_PORT_REG"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "iobase + MEM_PORT_REG"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "iobase + MEM_PORT_REG"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "iobase + MEM_PORT_REG"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "iobase + HOST_ADDR_REG",
            "sc->tx_start"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82595reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid iy_intr_tx;\n\nvoid\niy_intr_tx(sc)\nstruct iy_softc *sc;\n{\n\tint iobase;\n\tstruct ifnet *ifp;\n\tu_int txstatus, txstat2, txlen, txnext;\n\n\tifp = &sc->sc_arpcom.ac_if;\n\tiobase = sc->sc_iobase;\n\t\n\twhile (sc->tx_start != sc->tx_end) {\n\t\toutw(iobase + HOST_ADDR_REG, sc->tx_start);\n\t\ttxstatus = inw(iobase + MEM_PORT_REG);\n\t\tif ((txstatus & (TX_DONE|CMD_MASK)) != (TX_DONE|XMT_CMD))\n\t\t\tbreak;\n\n\t\ttxstat2 = inw(iobase + MEM_PORT_REG);\n\t\ttxnext = inw(iobase + MEM_PORT_REG);\n\t\ttxlen = inw(iobase + MEM_PORT_REG);\n#ifdef IYDEBUG\n\t\tprintf(\"txstat 0x%x stat2 0x%b next 0x%x len 0x%x\\n\",\n\t\t    txstatus, txstat2, \"\\020\\6MAX_COL\\7HRT_BEAT\\010TX_DEF\"\n\t\t    \"\\011UND_RUN\\012JERR\\013LST_CRS\\014LTCOL\\016TX_OK\\020COLL\",\n\t\t\ttxnext, txlen);\n#endif\n\t\tif (txlen & CHAIN)\n\t\t\tsc->tx_start = txnext;\n\t\telse\n\t\t\tsc->tx_start = sc->tx_end;\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t\t\n\t\tif ((txstat2 & 0x2000) == 0)\n\t\t\t++ifp->if_oerrors;\n\t\tif (txstat2 & 0x000f)\n\t\t\tifp->if_oerrors += txstat2 & 0x000f;\n\t}\n\tifp->if_flags &= ~IFF_OACTIVE;\n}"
  },
  {
    "function_name": "iy_intr_rx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_iy.c",
    "lines": "861-899",
    "snippet": "void\niy_intr_rx(sc)\nstruct iy_softc *sc;\n{\n\tstruct ifnet *ifp;\n\tint iobase;\n\tu_int rxadrs, rxevnt, rxstatus, rxnext, rxlen;\n\n\tiobase = sc->sc_iobase;\n\tifp = &sc->sc_arpcom.ac_if;\n\n\trxadrs = sc->rx_start;\n\toutw(iobase + HOST_ADDR_REG, rxadrs);\n\trxevnt = inw(iobase + MEM_PORT_REG);\n\trxnext = 0;\n\t\n\twhile (rxevnt == RCV_DONE) {\n\t\trxstatus = inw(iobase + MEM_PORT_REG);\n\t\trxnext = inw(iobase + MEM_PORT_REG);\n\t\trxlen = inw(iobase + MEM_PORT_REG);\n#ifdef IYDEBUG\n\t\tprintf(\"%s: pck at 0x%04x stat %b next 0x%x len 0x%x\\n\",\n\t\t    sc->sc_dev.dv_xname, rxadrs, rxstatus,\n\t\t    \"\\020\\1RCLD\\2IA_MCH\\010SHORT\\011OVRN\\013ALGERR\"\n\t\t    \"\\014CRCERR\\015LENERR\\016RCVOK\\020TYP\",\n\t\t    rxnext, rxlen);\n#endif\n\t\tiyget(sc, iobase, rxlen);\n\n\t\t/* move stop address */\n\t\toutw(iobase + RCV_STOP_LOW,\n\t\t\t    rxnext == 0 ? sc->rx_size - 2 : rxnext - 2);\n\n\t\toutw(iobase + HOST_ADDR_REG, rxnext);\n\t\trxadrs = rxnext;\n\t\trxevnt = inw(iobase + MEM_PORT_REG);\n\t}\n\tsc->rx_start = rxnext;\n}",
    "includes": [
      "#include <dev/ic/i82595reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void iy_intr_rx",
      "void iyget"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "iobase + MEM_PORT_REG"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "iobase + HOST_ADDR_REG",
            "rxnext"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "iobase + RCV_STOP_LOW",
            "rxnext == 0 ? sc->rx_size - 2 : rxnext - 2"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iyget",
          "args": [
            "sc",
            "iobase",
            "rxlen"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "iyget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_iy.c",
          "lines": "778-860",
          "snippet": "void\niyget(sc, iobase, rxlen)\nstruct iy_softc *sc;\nint iobase, rxlen;\n{\n\tstruct mbuf *m, *top, **mp;\n\tstruct ether_header *eh;\n\tstruct ifnet *ifp;\n\tint len;\n\n\tifp = &sc->sc_arpcom.ac_if;\n\n\tm = sc->mb[sc->next_mb];\n\tsc->mb[sc->next_mb] = 0;\n\tif (m == 0) {\n\t\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\t\tif (m == 0)\n\t\t\tgoto dropped;\n\t} else {\n\t\tif (sc->last_mb == sc->next_mb)\n\t\t\ttimeout(iymbuffill, sc, 1);\n\t\tsc->next_mb = (sc->next_mb + 1) % MAX_MBS;\n\t\tm->m_data = m->m_pktdat;\n\t\tm->m_flags = M_PKTHDR;\n\t}\n\tm->m_pkthdr.rcvif = ifp;\n\tm->m_pkthdr.len = rxlen;\n\tlen = MHLEN;\n\ttop = 0;\n\tmp = &top;\n\n\twhile (rxlen > 0) {\n\t\tif (top) {\n\t\t\tm = sc->mb[sc->next_mb];\n\t\t\tsc->mb[sc->next_mb] = 0;\n\t\t\tif (m == 0) {\n\t\t\t\tMGET(m, M_DONTWAIT, MT_DATA);\n\t\t\t\tif (m == 0) {\n\t\t\t\t\tm_freem(top);\n\t\t\t\t\tgoto dropped;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsc->next_mb = (sc->next_mb + 1) % MAX_MBS;\n\t\t\t}\n\t\t\tlen = MLEN;\n\t\t}\n\t\tif (rxlen >= MINCLSIZE) {\n\t\t\tMCLGET(m, M_DONTWAIT);\n\t\t\tif (m->m_flags & M_EXT)\n\t\t\t\tlen = MCLBYTES;\n\t\t}\n\t\tlen = min(rxlen, len);\n\t\tif (len > 1) {\n\t\t\tlen &= ~1;\n\t\t\tinsw(iobase + MEM_PORT_REG, mtod(m, caddr_t), len/2);\n\t\t} else {\n#ifdef IYDEBUG\n\t\t\tprintf(\"%s: received odd mbuf\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\t\t*(mtod(m, caddr_t)) = inw(iobase + MEM_PORT_REG);\n\t\t}\n\t\tm->m_len = len;\n\t\trxlen -= len;\n\t\t*mp = m;\n\t\tmp = &m->m_next;\n\t}\n\t/* XXX receive the top here */\t\n\t++ifp->if_ipackets;\n\t\n\teh = mtod(top, struct ether_header *);\n\n#if NBPFILTER > 0\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, top);\n#endif\n\tm_adj(top, sizeof(struct ether_header));\n\tether_input(ifp, eh, top);\n\treturn;\n\ndropped:\n\t++ifp->if_ierrors;\n\treturn;\n}",
          "includes": [
            "#include <dev/ic/i82595reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define MAX_MBS 8"
          ],
          "globals_used": [
            "void iyget",
            "void iymbuffill"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82595reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define MAX_MBS 8\n\nvoid iyget;\nvoid iymbuffill;\n\nvoid\niyget(sc, iobase, rxlen)\nstruct iy_softc *sc;\nint iobase, rxlen;\n{\n\tstruct mbuf *m, *top, **mp;\n\tstruct ether_header *eh;\n\tstruct ifnet *ifp;\n\tint len;\n\n\tifp = &sc->sc_arpcom.ac_if;\n\n\tm = sc->mb[sc->next_mb];\n\tsc->mb[sc->next_mb] = 0;\n\tif (m == 0) {\n\t\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\t\tif (m == 0)\n\t\t\tgoto dropped;\n\t} else {\n\t\tif (sc->last_mb == sc->next_mb)\n\t\t\ttimeout(iymbuffill, sc, 1);\n\t\tsc->next_mb = (sc->next_mb + 1) % MAX_MBS;\n\t\tm->m_data = m->m_pktdat;\n\t\tm->m_flags = M_PKTHDR;\n\t}\n\tm->m_pkthdr.rcvif = ifp;\n\tm->m_pkthdr.len = rxlen;\n\tlen = MHLEN;\n\ttop = 0;\n\tmp = &top;\n\n\twhile (rxlen > 0) {\n\t\tif (top) {\n\t\t\tm = sc->mb[sc->next_mb];\n\t\t\tsc->mb[sc->next_mb] = 0;\n\t\t\tif (m == 0) {\n\t\t\t\tMGET(m, M_DONTWAIT, MT_DATA);\n\t\t\t\tif (m == 0) {\n\t\t\t\t\tm_freem(top);\n\t\t\t\t\tgoto dropped;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsc->next_mb = (sc->next_mb + 1) % MAX_MBS;\n\t\t\t}\n\t\t\tlen = MLEN;\n\t\t}\n\t\tif (rxlen >= MINCLSIZE) {\n\t\t\tMCLGET(m, M_DONTWAIT);\n\t\t\tif (m->m_flags & M_EXT)\n\t\t\t\tlen = MCLBYTES;\n\t\t}\n\t\tlen = min(rxlen, len);\n\t\tif (len > 1) {\n\t\t\tlen &= ~1;\n\t\t\tinsw(iobase + MEM_PORT_REG, mtod(m, caddr_t), len/2);\n\t\t} else {\n#ifdef IYDEBUG\n\t\t\tprintf(\"%s: received odd mbuf\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\t\t*(mtod(m, caddr_t)) = inw(iobase + MEM_PORT_REG);\n\t\t}\n\t\tm->m_len = len;\n\t\trxlen -= len;\n\t\t*mp = m;\n\t\tmp = &m->m_next;\n\t}\n\t/* XXX receive the top here */\t\n\t++ifp->if_ipackets;\n\t\n\teh = mtod(top, struct ether_header *);\n\n#if NBPFILTER > 0\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, top);\n#endif\n\tm_adj(top, sizeof(struct ether_header));\n\tether_input(ifp, eh, top);\n\treturn;\n\ndropped:\n\t++ifp->if_ierrors;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: pck at 0x%04x stat %b next 0x%x len 0x%x\\n\"",
            "sc->sc_dev.dv_xname",
            "rxadrs",
            "rxstatus",
            "\"\\020\\1RCLD\\2IA_MCH\\010SHORT\\011OVRN\\013ALGERR\"\n\t\t    \"\\014CRCERR\\015LENERR\\016RCVOK\\020TYP\"",
            "rxnext",
            "rxlen"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "iobase + MEM_PORT_REG"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "iobase + MEM_PORT_REG"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "iobase + MEM_PORT_REG"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "iobase + MEM_PORT_REG"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "iobase + HOST_ADDR_REG",
            "rxadrs"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82595reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid iy_intr_rx;\nvoid iyget;\n\nvoid\niy_intr_rx(sc)\nstruct iy_softc *sc;\n{\n\tstruct ifnet *ifp;\n\tint iobase;\n\tu_int rxadrs, rxevnt, rxstatus, rxnext, rxlen;\n\n\tiobase = sc->sc_iobase;\n\tifp = &sc->sc_arpcom.ac_if;\n\n\trxadrs = sc->rx_start;\n\toutw(iobase + HOST_ADDR_REG, rxadrs);\n\trxevnt = inw(iobase + MEM_PORT_REG);\n\trxnext = 0;\n\t\n\twhile (rxevnt == RCV_DONE) {\n\t\trxstatus = inw(iobase + MEM_PORT_REG);\n\t\trxnext = inw(iobase + MEM_PORT_REG);\n\t\trxlen = inw(iobase + MEM_PORT_REG);\n#ifdef IYDEBUG\n\t\tprintf(\"%s: pck at 0x%04x stat %b next 0x%x len 0x%x\\n\",\n\t\t    sc->sc_dev.dv_xname, rxadrs, rxstatus,\n\t\t    \"\\020\\1RCLD\\2IA_MCH\\010SHORT\\011OVRN\\013ALGERR\"\n\t\t    \"\\014CRCERR\\015LENERR\\016RCVOK\\020TYP\",\n\t\t    rxnext, rxlen);\n#endif\n\t\tiyget(sc, iobase, rxlen);\n\n\t\t/* move stop address */\n\t\toutw(iobase + RCV_STOP_LOW,\n\t\t\t    rxnext == 0 ? sc->rx_size - 2 : rxnext - 2);\n\n\t\toutw(iobase + HOST_ADDR_REG, rxnext);\n\t\trxadrs = rxnext;\n\t\trxevnt = inw(iobase + MEM_PORT_REG);\n\t}\n\tsc->rx_start = rxnext;\n}"
  },
  {
    "function_name": "iyget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_iy.c",
    "lines": "778-860",
    "snippet": "void\niyget(sc, iobase, rxlen)\nstruct iy_softc *sc;\nint iobase, rxlen;\n{\n\tstruct mbuf *m, *top, **mp;\n\tstruct ether_header *eh;\n\tstruct ifnet *ifp;\n\tint len;\n\n\tifp = &sc->sc_arpcom.ac_if;\n\n\tm = sc->mb[sc->next_mb];\n\tsc->mb[sc->next_mb] = 0;\n\tif (m == 0) {\n\t\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\t\tif (m == 0)\n\t\t\tgoto dropped;\n\t} else {\n\t\tif (sc->last_mb == sc->next_mb)\n\t\t\ttimeout(iymbuffill, sc, 1);\n\t\tsc->next_mb = (sc->next_mb + 1) % MAX_MBS;\n\t\tm->m_data = m->m_pktdat;\n\t\tm->m_flags = M_PKTHDR;\n\t}\n\tm->m_pkthdr.rcvif = ifp;\n\tm->m_pkthdr.len = rxlen;\n\tlen = MHLEN;\n\ttop = 0;\n\tmp = &top;\n\n\twhile (rxlen > 0) {\n\t\tif (top) {\n\t\t\tm = sc->mb[sc->next_mb];\n\t\t\tsc->mb[sc->next_mb] = 0;\n\t\t\tif (m == 0) {\n\t\t\t\tMGET(m, M_DONTWAIT, MT_DATA);\n\t\t\t\tif (m == 0) {\n\t\t\t\t\tm_freem(top);\n\t\t\t\t\tgoto dropped;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsc->next_mb = (sc->next_mb + 1) % MAX_MBS;\n\t\t\t}\n\t\t\tlen = MLEN;\n\t\t}\n\t\tif (rxlen >= MINCLSIZE) {\n\t\t\tMCLGET(m, M_DONTWAIT);\n\t\t\tif (m->m_flags & M_EXT)\n\t\t\t\tlen = MCLBYTES;\n\t\t}\n\t\tlen = min(rxlen, len);\n\t\tif (len > 1) {\n\t\t\tlen &= ~1;\n\t\t\tinsw(iobase + MEM_PORT_REG, mtod(m, caddr_t), len/2);\n\t\t} else {\n#ifdef IYDEBUG\n\t\t\tprintf(\"%s: received odd mbuf\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\t\t*(mtod(m, caddr_t)) = inw(iobase + MEM_PORT_REG);\n\t\t}\n\t\tm->m_len = len;\n\t\trxlen -= len;\n\t\t*mp = m;\n\t\tmp = &m->m_next;\n\t}\n\t/* XXX receive the top here */\t\n\t++ifp->if_ipackets;\n\t\n\teh = mtod(top, struct ether_header *);\n\n#if NBPFILTER > 0\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, top);\n#endif\n\tm_adj(top, sizeof(struct ether_header));\n\tether_input(ifp, eh, top);\n\treturn;\n\ndropped:\n\t++ifp->if_ierrors;\n\treturn;\n}",
    "includes": [
      "#include <dev/ic/i82595reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define MAX_MBS 8"
    ],
    "globals_used": [
      "void iyget",
      "void iymbuffill"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ether_input",
          "args": [
            "ifp",
            "eh",
            "top"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_adj",
          "args": [
            "top",
            "sizeof(struct ether_header)"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "top"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "top",
            "structether_header*"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "iobase + MEM_PORT_REG"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "caddr_t"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: received odd mbuf\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "insw",
          "args": [
            "iobase + MEM_PORT_REG",
            "mtod(m, caddr_t)",
            "len/2"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "caddr_t"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "rxlen",
            "len"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "btminphys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "1088-1096",
          "snippet": "void\nbtminphys(bp)\n\tstruct buf *bp;\n{\n\n\tif (bp->b_bcount > ((BT_NSEG - 1) << PGSHIFT))\n\t\tbp->b_bcount = ((BT_NSEG - 1) << PGSHIFT);\n\tminphys(bp);\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void btminphys"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid btminphys;\n\nvoid\nbtminphys(bp)\n\tstruct buf *bp;\n{\n\n\tif (bp->b_bcount > ((BT_NSEG - 1) << PGSHIFT))\n\t\tbp->b_bcount = ((BT_NSEG - 1) << PGSHIFT);\n\tminphys(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MCLGET",
          "args": [
            "m",
            "M_DONTWAIT"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "top"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGET",
          "args": [
            "m",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "iymbuffill",
            "sc",
            "1"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "bt_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "1300-1345",
          "snippet": "void\nbt_timeout(arg)\n\tvoid *arg;\n{\n\tstruct bt_ccb *ccb = arg;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct bt_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n#ifdef BTDIAG\n\t/*\n\t * If the ccb's mbx is not free, then the board has gone Far East?\n\t */\n\tbt_collect_mbo(sc);\n\tif (ccb->flags & CCB_SENDING) {\n\t\tprintf(\"%s: not taking commands!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n#endif\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (ccb->flags & CCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tccb->xs->error = XS_TIMEOUT;\n\t\tccb->timeout = BT_ABORT_TIMEOUT;\n\t\tccb->flags |= CCB_ABORT;\n\t\tbt_queue_ccb(sc, ccb);\n\t}\n\n\tsplx(s);\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tBT_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */"
          ],
          "globals_used": [
            "bt_finish_ccbs __P((struct bt_softc *));",
            "bt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "bt_init_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "void bt_queue_ccb",
            "void bt_collect_mbo",
            "void bt_timeout",
            "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
            "int flags;",
            "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tBT_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */\n\nbt_finish_ccbs __P((struct bt_softc *));\nbt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));\nbt_init_ccb __P((struct bt_softc *, struct bt_ccb *));\nvoid bt_queue_ccb;\nvoid bt_collect_mbo;\nvoid bt_timeout;\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nint flags;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nvoid\nbt_timeout(arg)\n\tvoid *arg;\n{\n\tstruct bt_ccb *ccb = arg;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct bt_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n#ifdef BTDIAG\n\t/*\n\t * If the ccb's mbx is not free, then the board has gone Far East?\n\t */\n\tbt_collect_mbo(sc);\n\tif (ccb->flags & CCB_SENDING) {\n\t\tprintf(\"%s: not taking commands!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n#endif\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (ccb->flags & CCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tccb->xs->error = XS_TIMEOUT;\n\t\tccb->timeout = BT_ABORT_TIMEOUT;\n\t\tccb->flags |= CCB_ABORT;\n\t\tbt_queue_ccb(sc, ccb);\n\t}\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MGETHDR",
          "args": [
            "m",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82595reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define MAX_MBS 8\n\nvoid iyget;\nvoid iymbuffill;\n\nvoid\niyget(sc, iobase, rxlen)\nstruct iy_softc *sc;\nint iobase, rxlen;\n{\n\tstruct mbuf *m, *top, **mp;\n\tstruct ether_header *eh;\n\tstruct ifnet *ifp;\n\tint len;\n\n\tifp = &sc->sc_arpcom.ac_if;\n\n\tm = sc->mb[sc->next_mb];\n\tsc->mb[sc->next_mb] = 0;\n\tif (m == 0) {\n\t\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\t\tif (m == 0)\n\t\t\tgoto dropped;\n\t} else {\n\t\tif (sc->last_mb == sc->next_mb)\n\t\t\ttimeout(iymbuffill, sc, 1);\n\t\tsc->next_mb = (sc->next_mb + 1) % MAX_MBS;\n\t\tm->m_data = m->m_pktdat;\n\t\tm->m_flags = M_PKTHDR;\n\t}\n\tm->m_pkthdr.rcvif = ifp;\n\tm->m_pkthdr.len = rxlen;\n\tlen = MHLEN;\n\ttop = 0;\n\tmp = &top;\n\n\twhile (rxlen > 0) {\n\t\tif (top) {\n\t\t\tm = sc->mb[sc->next_mb];\n\t\t\tsc->mb[sc->next_mb] = 0;\n\t\t\tif (m == 0) {\n\t\t\t\tMGET(m, M_DONTWAIT, MT_DATA);\n\t\t\t\tif (m == 0) {\n\t\t\t\t\tm_freem(top);\n\t\t\t\t\tgoto dropped;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsc->next_mb = (sc->next_mb + 1) % MAX_MBS;\n\t\t\t}\n\t\t\tlen = MLEN;\n\t\t}\n\t\tif (rxlen >= MINCLSIZE) {\n\t\t\tMCLGET(m, M_DONTWAIT);\n\t\t\tif (m->m_flags & M_EXT)\n\t\t\t\tlen = MCLBYTES;\n\t\t}\n\t\tlen = min(rxlen, len);\n\t\tif (len > 1) {\n\t\t\tlen &= ~1;\n\t\t\tinsw(iobase + MEM_PORT_REG, mtod(m, caddr_t), len/2);\n\t\t} else {\n#ifdef IYDEBUG\n\t\t\tprintf(\"%s: received odd mbuf\\n\", sc->sc_dev.dv_xname);\n#endif\n\t\t\t*(mtod(m, caddr_t)) = inw(iobase + MEM_PORT_REG);\n\t\t}\n\t\tm->m_len = len;\n\t\trxlen -= len;\n\t\t*mp = m;\n\t\tmp = &m->m_next;\n\t}\n\t/* XXX receive the top here */\t\n\t++ifp->if_ipackets;\n\t\n\teh = mtod(top, struct ether_header *);\n\n#if NBPFILTER > 0\n\tif (ifp->if_bpf)\n\t\tbpf_mtap(ifp->if_bpf, top);\n#endif\n\tm_adj(top, sizeof(struct ether_header));\n\tether_input(ifp, eh, top);\n\treturn;\n\ndropped:\n\t++ifp->if_ierrors;\n\treturn;\n}"
  },
  {
    "function_name": "iyintr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_iy.c",
    "lines": "744-776",
    "snippet": "int\niyintr(arg)\n\tvoid *arg;\n{\n\tstruct iy_softc *sc = arg;\n\tint iobase;\n\tregister u_short status;\n\n\tiobase = sc->sc_iobase;\n\tstatus = inb(iobase + STATUS_REG);\n#ifdef IYDEBUG\n\tif (status & ALL_INTS) {\n\t\tprintf(\"%s: got interupt %b\", sc->sc_dev.dv_xname, status,\n\t\t    \"\\020\\1RX_STP\\2RX\\3TX\\4EXEC\");\n\t\tif (status & EXEC_INT)\n\t\t\tprintf(\" event %b\\n\", inb(iobase),\n\t\t\t    \"\\020\\6ABORT\");\n\t\telse\n\t\t\tprintf(\"\\n\");\n\t}\n#endif\n\tif ((status & (RX_INT | TX_INT) == 0))\n\t\treturn 0;\n\n\tif (status & RX_INT) {\n\t\tiy_intr_rx(sc);\n\t\toutb(iobase + STATUS_REG, RX_INT);\n\t} else if (status & TX_INT) {\n\t\tiy_intr_tx(sc);\n\t\toutb(iobase + STATUS_REG, TX_INT);\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <dev/ic/i82595reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int iyintr",
      "void iy_intr_rx",
      "void iy_intr_tx"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "iobase + STATUS_REG",
            "TX_INT"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "iy_intr_tx",
          "args": [
            "sc"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "iy_intr_tx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_iy.c",
          "lines": "901-939",
          "snippet": "void\niy_intr_tx(sc)\nstruct iy_softc *sc;\n{\n\tint iobase;\n\tstruct ifnet *ifp;\n\tu_int txstatus, txstat2, txlen, txnext;\n\n\tifp = &sc->sc_arpcom.ac_if;\n\tiobase = sc->sc_iobase;\n\t\n\twhile (sc->tx_start != sc->tx_end) {\n\t\toutw(iobase + HOST_ADDR_REG, sc->tx_start);\n\t\ttxstatus = inw(iobase + MEM_PORT_REG);\n\t\tif ((txstatus & (TX_DONE|CMD_MASK)) != (TX_DONE|XMT_CMD))\n\t\t\tbreak;\n\n\t\ttxstat2 = inw(iobase + MEM_PORT_REG);\n\t\ttxnext = inw(iobase + MEM_PORT_REG);\n\t\ttxlen = inw(iobase + MEM_PORT_REG);\n#ifdef IYDEBUG\n\t\tprintf(\"txstat 0x%x stat2 0x%b next 0x%x len 0x%x\\n\",\n\t\t    txstatus, txstat2, \"\\020\\6MAX_COL\\7HRT_BEAT\\010TX_DEF\"\n\t\t    \"\\011UND_RUN\\012JERR\\013LST_CRS\\014LTCOL\\016TX_OK\\020COLL\",\n\t\t\ttxnext, txlen);\n#endif\n\t\tif (txlen & CHAIN)\n\t\t\tsc->tx_start = txnext;\n\t\telse\n\t\t\tsc->tx_start = sc->tx_end;\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t\t\n\t\tif ((txstat2 & 0x2000) == 0)\n\t\t\t++ifp->if_oerrors;\n\t\tif (txstat2 & 0x000f)\n\t\t\tifp->if_oerrors += txstat2 & 0x000f;\n\t}\n\tifp->if_flags &= ~IFF_OACTIVE;\n}",
          "includes": [
            "#include <dev/ic/i82595reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void iy_intr_tx"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82595reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid iy_intr_tx;\n\nvoid\niy_intr_tx(sc)\nstruct iy_softc *sc;\n{\n\tint iobase;\n\tstruct ifnet *ifp;\n\tu_int txstatus, txstat2, txlen, txnext;\n\n\tifp = &sc->sc_arpcom.ac_if;\n\tiobase = sc->sc_iobase;\n\t\n\twhile (sc->tx_start != sc->tx_end) {\n\t\toutw(iobase + HOST_ADDR_REG, sc->tx_start);\n\t\ttxstatus = inw(iobase + MEM_PORT_REG);\n\t\tif ((txstatus & (TX_DONE|CMD_MASK)) != (TX_DONE|XMT_CMD))\n\t\t\tbreak;\n\n\t\ttxstat2 = inw(iobase + MEM_PORT_REG);\n\t\ttxnext = inw(iobase + MEM_PORT_REG);\n\t\ttxlen = inw(iobase + MEM_PORT_REG);\n#ifdef IYDEBUG\n\t\tprintf(\"txstat 0x%x stat2 0x%b next 0x%x len 0x%x\\n\",\n\t\t    txstatus, txstat2, \"\\020\\6MAX_COL\\7HRT_BEAT\\010TX_DEF\"\n\t\t    \"\\011UND_RUN\\012JERR\\013LST_CRS\\014LTCOL\\016TX_OK\\020COLL\",\n\t\t\ttxnext, txlen);\n#endif\n\t\tif (txlen & CHAIN)\n\t\t\tsc->tx_start = txnext;\n\t\telse\n\t\t\tsc->tx_start = sc->tx_end;\n\t\tifp->if_flags &= ~IFF_OACTIVE;\n\t\t\n\t\tif ((txstat2 & 0x2000) == 0)\n\t\t\t++ifp->if_oerrors;\n\t\tif (txstat2 & 0x000f)\n\t\t\tifp->if_oerrors += txstat2 & 0x000f;\n\t}\n\tifp->if_flags &= ~IFF_OACTIVE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iy_intr_rx",
          "args": [
            "sc"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "iy_intr_rx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_iy.c",
          "lines": "861-899",
          "snippet": "void\niy_intr_rx(sc)\nstruct iy_softc *sc;\n{\n\tstruct ifnet *ifp;\n\tint iobase;\n\tu_int rxadrs, rxevnt, rxstatus, rxnext, rxlen;\n\n\tiobase = sc->sc_iobase;\n\tifp = &sc->sc_arpcom.ac_if;\n\n\trxadrs = sc->rx_start;\n\toutw(iobase + HOST_ADDR_REG, rxadrs);\n\trxevnt = inw(iobase + MEM_PORT_REG);\n\trxnext = 0;\n\t\n\twhile (rxevnt == RCV_DONE) {\n\t\trxstatus = inw(iobase + MEM_PORT_REG);\n\t\trxnext = inw(iobase + MEM_PORT_REG);\n\t\trxlen = inw(iobase + MEM_PORT_REG);\n#ifdef IYDEBUG\n\t\tprintf(\"%s: pck at 0x%04x stat %b next 0x%x len 0x%x\\n\",\n\t\t    sc->sc_dev.dv_xname, rxadrs, rxstatus,\n\t\t    \"\\020\\1RCLD\\2IA_MCH\\010SHORT\\011OVRN\\013ALGERR\"\n\t\t    \"\\014CRCERR\\015LENERR\\016RCVOK\\020TYP\",\n\t\t    rxnext, rxlen);\n#endif\n\t\tiyget(sc, iobase, rxlen);\n\n\t\t/* move stop address */\n\t\toutw(iobase + RCV_STOP_LOW,\n\t\t\t    rxnext == 0 ? sc->rx_size - 2 : rxnext - 2);\n\n\t\toutw(iobase + HOST_ADDR_REG, rxnext);\n\t\trxadrs = rxnext;\n\t\trxevnt = inw(iobase + MEM_PORT_REG);\n\t}\n\tsc->rx_start = rxnext;\n}",
          "includes": [
            "#include <dev/ic/i82595reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void iy_intr_rx",
            "void iyget"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82595reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid iy_intr_rx;\nvoid iyget;\n\nvoid\niy_intr_rx(sc)\nstruct iy_softc *sc;\n{\n\tstruct ifnet *ifp;\n\tint iobase;\n\tu_int rxadrs, rxevnt, rxstatus, rxnext, rxlen;\n\n\tiobase = sc->sc_iobase;\n\tifp = &sc->sc_arpcom.ac_if;\n\n\trxadrs = sc->rx_start;\n\toutw(iobase + HOST_ADDR_REG, rxadrs);\n\trxevnt = inw(iobase + MEM_PORT_REG);\n\trxnext = 0;\n\t\n\twhile (rxevnt == RCV_DONE) {\n\t\trxstatus = inw(iobase + MEM_PORT_REG);\n\t\trxnext = inw(iobase + MEM_PORT_REG);\n\t\trxlen = inw(iobase + MEM_PORT_REG);\n#ifdef IYDEBUG\n\t\tprintf(\"%s: pck at 0x%04x stat %b next 0x%x len 0x%x\\n\",\n\t\t    sc->sc_dev.dv_xname, rxadrs, rxstatus,\n\t\t    \"\\020\\1RCLD\\2IA_MCH\\010SHORT\\011OVRN\\013ALGERR\"\n\t\t    \"\\014CRCERR\\015LENERR\\016RCVOK\\020TYP\",\n\t\t    rxnext, rxlen);\n#endif\n\t\tiyget(sc, iobase, rxlen);\n\n\t\t/* move stop address */\n\t\toutw(iobase + RCV_STOP_LOW,\n\t\t\t    rxnext == 0 ? sc->rx_size - 2 : rxnext - 2);\n\n\t\toutw(iobase + HOST_ADDR_REG, rxnext);\n\t\trxadrs = rxnext;\n\t\trxevnt = inw(iobase + MEM_PORT_REG);\n\t}\n\tsc->rx_start = rxnext;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "iobase"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82595reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint iyintr;\nvoid iy_intr_rx;\nvoid iy_intr_tx;\n\nint\niyintr(arg)\n\tvoid *arg;\n{\n\tstruct iy_softc *sc = arg;\n\tint iobase;\n\tregister u_short status;\n\n\tiobase = sc->sc_iobase;\n\tstatus = inb(iobase + STATUS_REG);\n#ifdef IYDEBUG\n\tif (status & ALL_INTS) {\n\t\tprintf(\"%s: got interupt %b\", sc->sc_dev.dv_xname, status,\n\t\t    \"\\020\\1RX_STP\\2RX\\3TX\\4EXEC\");\n\t\tif (status & EXEC_INT)\n\t\t\tprintf(\" event %b\\n\", inb(iobase),\n\t\t\t    \"\\020\\6ABORT\");\n\t\telse\n\t\t\tprintf(\"\\n\");\n\t}\n#endif\n\tif ((status & (RX_INT | TX_INT) == 0))\n\t\treturn 0;\n\n\tif (status & RX_INT) {\n\t\tiy_intr_rx(sc);\n\t\toutb(iobase + STATUS_REG, RX_INT);\n\t} else if (status & TX_INT) {\n\t\tiy_intr_tx(sc);\n\t\toutb(iobase + STATUS_REG, TX_INT);\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "iywatchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_iy.c",
    "lines": "730-739",
    "snippet": "void\niywatchdog(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct iy_softc *sc = ifp->if_softc;\n\n\tlog(LOG_ERR, \"%s: device timeout\\n\", sc->sc_dev.dv_xname);\n\t++sc->sc_arpcom.ac_if.if_oerrors;\n\tiyreset(sc);\n}",
    "includes": [
      "#include <dev/ic/i82595reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void iywatchdog",
      "void iyreset"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iyreset",
          "args": [
            "sc"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "iyreset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_iy.c",
          "lines": "359-368",
          "snippet": "void\niyreset(sc)\nstruct iy_softc *sc;\n{\n\tint s;\n\ts = splimp();\n\tiystop(sc);\n\tiyinit(sc);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/i82595reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void iyinit",
            "void iystop",
            "void iyreset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82595reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid iyinit;\nvoid iystop;\nvoid iyreset;\n\nvoid\niyreset(sc)\nstruct iy_softc *sc;\n{\n\tint s;\n\ts = splimp();\n\tiystop(sc);\n\tiyinit(sc);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_ERR",
            "\"%s: device timeout\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_log_hard_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5909-5956",
          "snippet": "static void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "int\ti;",
            "ncb_p np = (struct ncb*) 0;",
            "int\ti;",
            "u_int8_t\tistat, dstat;",
            "u_int16_t\tsist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nint\ti;\nncb_p np = (struct ncb*) 0;\nint\ti;\nu_int8_t\tistat, dstat;\nu_int16_t\tsist;\n\nstatic void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82595reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid iywatchdog;\nvoid iyreset;\n\nvoid\niywatchdog(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct iy_softc *sc = ifp->if_softc;\n\n\tlog(LOG_ERR, \"%s: device timeout\\n\", sc->sc_dev.dv_xname);\n\t++sc->sc_arpcom.ac_if.if_oerrors;\n\tiyreset(sc);\n}"
  },
  {
    "function_name": "eepromread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_iy.c",
    "lines": "687-724",
    "snippet": "static u_int16_t\neepromread(io, offset)\n\tint io, offset;\n{\n\tvolatile int i;\n\tvolatile int j;\n\tvolatile u_int16_t readval;\n\tint eio = io+EEPROM_REG;\n\n\toutb(io, BANK_SEL(2));\n\tdelay(1);\n\toutb(io, EECS);\n\tdelay(1);\n\t\n\teepromwritebit(eio, EECS|EEDI);\n\teepromwritebit(eio, EECS|EEDI);\n\teepromwritebit(eio, EECS);\n\t\n\tfor (j=5; j>=0; --j) {\n\t\tif ((offset>>j) & 1) \n\t\t\teepromwritebit(eio, EECS|EEDI);\n\t\telse\n\t\t\teepromwritebit(eio, EECS);\n\t}\n\n\tfor (readval=0, i=0; i<16; ++i) {\n\t\treadval<<=1;\n\t\treadval |= eepromreadbit(eio);\n\t}\n\n\toutb(eio, 0|EESK);\n\tdelay(1);\n\toutb(eio, 0);\n\n\toutb(eio, BANK_SEL(0));\n\n\treturn readval;\n}",
    "includes": [
      "#include <dev/ic/i82595reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static u_int16_t eepromread"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "eio",
            "BANK_SEL(0)"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "BANK_SEL",
          "args": [
            "0"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eepromreadbit",
          "args": [
            "eio"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "eepromreadbit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_iy.c",
          "lines": "672-685",
          "snippet": "static __inline int\neepromreadbit(eio) \n\tint eio;\n{\n\tint b; \n\n\toutb(eio, EECS|EESK); \n\tdelay(1);\n\tb = inb(eio);\n\toutb(eio, EECS);\n\tdelay(1);\n\n\treturn ((b & EEDO) != 0);\n}",
          "includes": [
            "#include <dev/ic/i82595reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82595reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic __inline int\neepromreadbit(eio) \n\tint eio;\n{\n\tint b; \n\n\toutb(eio, EECS|EESK); \n\tdelay(1);\n\tb = inb(eio);\n\toutb(eio, EECS);\n\tdelay(1);\n\n\treturn ((b & EEDO) != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eepromwritebit",
          "args": [
            "eio",
            "EECS"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "eepromwritebit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_iy.c",
          "lines": "660-670",
          "snippet": "static __inline void\neepromwritebit(eio, what) \n\tint eio, what;\n{\n\toutb(eio, what);\n\tdelay(1);\n\toutb(eio, what|EESK);\n\tdelay(1);\n\toutb(eio, what);\n\tdelay(1);\n}",
          "includes": [
            "#include <dev/ic/i82595reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82595reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic __inline void\neepromwritebit(eio, what) \n\tint eio, what;\n{\n\toutb(eio, what);\n\tdelay(1);\n\toutb(eio, what|EESK);\n\tdelay(1);\n\toutb(eio, what);\n\tdelay(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BANK_SEL",
          "args": [
            "2"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82595reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic u_int16_t eepromread;\n\nstatic u_int16_t\neepromread(io, offset)\n\tint io, offset;\n{\n\tvolatile int i;\n\tvolatile int j;\n\tvolatile u_int16_t readval;\n\tint eio = io+EEPROM_REG;\n\n\toutb(io, BANK_SEL(2));\n\tdelay(1);\n\toutb(io, EECS);\n\tdelay(1);\n\t\n\teepromwritebit(eio, EECS|EEDI);\n\teepromwritebit(eio, EECS|EEDI);\n\teepromwritebit(eio, EECS);\n\t\n\tfor (j=5; j>=0; --j) {\n\t\tif ((offset>>j) & 1) \n\t\t\teepromwritebit(eio, EECS|EEDI);\n\t\telse\n\t\t\teepromwritebit(eio, EECS);\n\t}\n\n\tfor (readval=0, i=0; i<16; ++i) {\n\t\treadval<<=1;\n\t\treadval |= eepromreadbit(eio);\n\t}\n\n\toutb(eio, 0|EESK);\n\tdelay(1);\n\toutb(eio, 0);\n\n\toutb(eio, BANK_SEL(0));\n\n\treturn readval;\n}"
  },
  {
    "function_name": "eepromreadbit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_iy.c",
    "lines": "672-685",
    "snippet": "static __inline int\neepromreadbit(eio) \n\tint eio;\n{\n\tint b; \n\n\toutb(eio, EECS|EESK); \n\tdelay(1);\n\tb = inb(eio);\n\toutb(eio, EECS);\n\tdelay(1);\n\n\treturn ((b & EEDO) != 0);\n}",
    "includes": [
      "#include <dev/ic/i82595reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "eio",
            "EECS"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "eio"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82595reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic __inline int\neepromreadbit(eio) \n\tint eio;\n{\n\tint b; \n\n\toutb(eio, EECS|EESK); \n\tdelay(1);\n\tb = inb(eio);\n\toutb(eio, EECS);\n\tdelay(1);\n\n\treturn ((b & EEDO) != 0);\n}"
  },
  {
    "function_name": "eepromwritebit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_iy.c",
    "lines": "660-670",
    "snippet": "static __inline void\neepromwritebit(eio, what) \n\tint eio, what;\n{\n\toutb(eio, what);\n\tdelay(1);\n\toutb(eio, what|EESK);\n\tdelay(1);\n\toutb(eio, what);\n\tdelay(1);\n}",
    "includes": [
      "#include <dev/ic/i82595reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "eio",
            "what"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82595reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic __inline void\neepromwritebit(eio, what) \n\tint eio, what;\n{\n\toutb(eio, what);\n\tdelay(1);\n\toutb(eio, what|EESK);\n\tdelay(1);\n\toutb(eio, what);\n\tdelay(1);\n}"
  },
  {
    "function_name": "iystart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_iy.c",
    "lines": "479-657",
    "snippet": "void\niystart(ifp)\nstruct ifnet *ifp;\n{\n\tstruct iy_softc *sc;\n\tint iobase;\n\n\tstruct mbuf *m0, *m;\n\tu_int len, pad, last, end;\n\tu_int llen, residual;\n\tint avail;\n\tcaddr_t data;\n\tu_int16_t resval, stat;\n\n#ifdef IYDEBUG\n\tprintf(\"iystart called\\n\");\n#endif\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n                return;\n\n\tsc = ifp->if_softc;\n\tiobase = sc->sc_iobase;\n\n\twhile ((m0 = ifp->if_snd.ifq_head) != NULL) {\n#ifdef IYDEBUG\n\t\tprintf(\"%s: trying to write another packet to the hardware\\n\",\n\t\t    sc->sc_dev.dv_xname);\n#endif\n\n\t\t/* We need to use m->m_pkthdr.len, so require the header */\n\t\tif ((m0->m_flags & M_PKTHDR) == 0)\n\t\t\tpanic(\"iystart: no header mbuf\");\n\n\t\tlen = m0->m_pkthdr.len;\n\t\tpad = len & 1;\n\n#ifdef IYDEBUG\n\t\tprintf(\"%s: length is %d.\\n\", sc->sc_dev.dv_xname, len);\n#endif\n\t\tif (len < ETHER_MIN_LEN) {\n\t\t\tpad = ETHER_MIN_LEN - len;\n\t\t}\n\n        \tif (len + pad > ETHER_MAX_LEN) {\n        \t        /* packet is obviously too large: toss it */\n        \t        ++ifp->if_oerrors;\n        \t        IF_DEQUEUE(&ifp->if_snd, m0);\n        \t        m_freem(m0);\n\t\t\tcontinue;\n        \t}\n\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n\t\tavail = sc->tx_start - sc->tx_end;\n\t\tif (avail <= 0)\n\t\t\tavail += sc->tx_size;\n\n#ifdef IYDEBUG\n\t\tprintf(\"%s: avail is %d.\\n\", sc->sc_dev.dv_xname, avail);\n#endif\n\t\t/* \n\t\t * we MUST RUN at splnet here  --- \n\t\t * XXX todo: or even turn off the boards ints ??? hm... \n\t\t */\n\t\n       \t\t/* See if there is room to put another packet in the buffer. */\n\t\n\t\tif ((len+pad+2*I595_XMT_HDRLEN) > avail) {\n\t\t\tprintf(\"%s: len = %d, avail = %d, setting OACTIVE\\n\",\n\t\t\t    sc->sc_dev.dv_xname, len, avail);\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\treturn;\n\t\t}\n\t\n\t\t/* we know it fits in the hardware now, so dequeue it */\n\t\tIF_DEQUEUE(&ifp->if_snd, m0);\n\t\t\n\t\tlast = sc->tx_end;\n\t\tend = last + pad + len + I595_XMT_HDRLEN; \n\t\t\n\t\tif (end >= sc->sram) {\n\t\t\tif ((sc->sram - last) <= I595_XMT_HDRLEN) {\n\t\t\t\t/* keep header in one piece */\n\t\t\t\tlast = sc->rx_size;\n\t\t\t\tend = last + pad + len + I595_XMT_HDRLEN;\n\t\t\t} else\n\t\t\t\tend -= sc->tx_size;\n\t\t}\n\n\t\toutw(iobase + HOST_ADDR_REG, last);\n\t\toutw(iobase + MEM_PORT_REG, XMT_CMD);\n\t\toutw(iobase + MEM_PORT_REG, 0);\n\t\toutw(iobase + MEM_PORT_REG, 0);\n\t\toutw(iobase + MEM_PORT_REG, len + pad);\n\n\t\tresidual = resval = 0;\n\n\t\twhile ((m = m0)!=0) {\n\t\t\tdata = mtod(m, caddr_t);\n\t\t\tllen = m->m_len;\n\t\t\tif (residual) {\n#ifdef IYDEBUG\n\t\t\t\tprintf(\"%s: merging residual with next mbuf.\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n#endif\n\t\t\t\tresval |= *data << 8;\n\t\t\t\toutw(iobase + MEM_PORT_REG, resval);\n\t\t\t\t--llen;\n\t\t\t\t++data;\n\t\t\t}\n\t\t\tif (llen > 1)\n\t\t\t\toutsw(iobase + MEM_PORT_REG, data, llen>>1);\n\t\t\tresidual = llen & 1;\n\t\t\tif (residual) {\n\t\t\t\tresval = *(data + llen - 1);\n#ifdef IYDEBUG\n\t\t\t\tprintf(\"%s: got odd mbuf to send.\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n#endif\n\t\t\t}\n\n\t\t\tMFREE(m, m0);\n\t\t}\n\n\t\tif (residual)\n\t\t\toutw(iobase + MEM_PORT_REG, resval);\n\n\t\tpad >>= 1;\n\t\twhile (pad-- > 0)\n\t\t\toutw(iobase + MEM_PORT_REG, 0);\n\t\t\t\n#ifdef IYDEBUG\n\t\tprintf(\"%s: new last = 0x%x, end = 0x%x.\\n\",\n\t\t    sc->sc_dev.dv_xname, last, end);\n\t\tprintf(\"%s: old start = 0x%x, end = 0x%x, last = 0x%x\\n\",\n\t\t    sc->sc_dev.dv_xname, sc->tx_start, sc->tx_end, sc->tx_last);\n#endif\n\n\t\tif (sc->tx_start != sc->tx_end) {\n\t\t\toutw(iobase + HOST_ADDR_REG, sc->tx_last + XMT_COUNT);\n\t\t\tstat = inw(iobase + MEM_PORT_REG);\n\n\t\t\toutw(iobase + HOST_ADDR_REG, sc->tx_last + XMT_CHAIN);\n\t\t\toutw(iobase + MEM_PORT_REG, last);\n\t\t\toutw(iobase + MEM_PORT_REG, stat | CHAIN);\n#ifdef IYDEBUG\n\t\t\tprintf(\"%s: setting 0x%x to 0x%x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, sc->tx_last + XMT_COUNT, \n\t\t\t    stat | CHAIN);\n#endif\n\t\t}\n\t\tstat = inw(iobase + MEM_PORT_REG); /* dummy read */\n\n\t\t/* XXX todo: enable ints here if disabled */\n\t\t\n\t\t++ifp->if_opackets;\n\n\t\tif (sc->tx_start == sc->tx_end) {\n\t\t\toutw(iobase + XMT_ADDR_REG, last);\n\t\t\toutb(iobase, XMT_CMD);\n\t\t\tsc->tx_start = last;\n#ifdef IYDEBUG\n\t\t\tprintf(\"%s: writing 0x%x to XAR and giving XCMD\\n\",\n\t\t\t    sc->sc_dev.dv_xname, last);\n#endif\n\t\t} else {\n\t\t\toutb(iobase, RESUME_XMT_CMD);\n#ifdef IYDEBUG\n\t\t\tprintf(\"%s: giving RESUME_XCMD\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n#endif\n\t\t}\n\t\tsc->tx_last = last;\n\t\tsc->tx_end = end;\n\t}\n}",
    "includes": [
      "#include <dev/ic/i82595reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define\tETHER_MAX_LEN\t1518",
      "#define\tETHER_MIN_LEN\t64"
    ],
    "globals_used": [
      "void iystart"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: giving RESUME_XCMD\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "iobase",
            "RESUME_XMT_CMD"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "iobase + XMT_ADDR_REG",
            "last"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "iobase + MEM_PORT_REG"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "iobase + MEM_PORT_REG",
            "stat | CHAIN"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "iobase + MEM_PORT_REG",
            "last"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "iobase + HOST_ADDR_REG",
            "sc->tx_last + XMT_CHAIN"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "iobase + MEM_PORT_REG"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "iobase + HOST_ADDR_REG",
            "sc->tx_last + XMT_COUNT"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "iobase + MEM_PORT_REG",
            "0"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "iobase + MEM_PORT_REG",
            "resval"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MFREE",
          "args": [
            "m",
            "m0"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outsw",
          "args": [
            "iobase + MEM_PORT_REG",
            "data",
            "llen>>1"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "iobase + MEM_PORT_REG",
            "resval"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "caddr_t"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "iobase + MEM_PORT_REG",
            "len + pad"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "iobase + MEM_PORT_REG",
            "0"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "iobase + MEM_PORT_REG",
            "0"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "iobase + MEM_PORT_REG",
            "XMT_CMD"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "iobase + HOST_ADDR_REG",
            "last"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "m0"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "m0"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m0"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "m0"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"iystart: no header mbuf\""
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82595reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tETHER_MAX_LEN\t1518\n#define\tETHER_MIN_LEN\t64\n\nvoid iystart;\n\nvoid\niystart(ifp)\nstruct ifnet *ifp;\n{\n\tstruct iy_softc *sc;\n\tint iobase;\n\n\tstruct mbuf *m0, *m;\n\tu_int len, pad, last, end;\n\tu_int llen, residual;\n\tint avail;\n\tcaddr_t data;\n\tu_int16_t resval, stat;\n\n#ifdef IYDEBUG\n\tprintf(\"iystart called\\n\");\n#endif\n\tif ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)\n                return;\n\n\tsc = ifp->if_softc;\n\tiobase = sc->sc_iobase;\n\n\twhile ((m0 = ifp->if_snd.ifq_head) != NULL) {\n#ifdef IYDEBUG\n\t\tprintf(\"%s: trying to write another packet to the hardware\\n\",\n\t\t    sc->sc_dev.dv_xname);\n#endif\n\n\t\t/* We need to use m->m_pkthdr.len, so require the header */\n\t\tif ((m0->m_flags & M_PKTHDR) == 0)\n\t\t\tpanic(\"iystart: no header mbuf\");\n\n\t\tlen = m0->m_pkthdr.len;\n\t\tpad = len & 1;\n\n#ifdef IYDEBUG\n\t\tprintf(\"%s: length is %d.\\n\", sc->sc_dev.dv_xname, len);\n#endif\n\t\tif (len < ETHER_MIN_LEN) {\n\t\t\tpad = ETHER_MIN_LEN - len;\n\t\t}\n\n        \tif (len + pad > ETHER_MAX_LEN) {\n        \t        /* packet is obviously too large: toss it */\n        \t        ++ifp->if_oerrors;\n        \t        IF_DEQUEUE(&ifp->if_snd, m0);\n        \t        m_freem(m0);\n\t\t\tcontinue;\n        \t}\n\n#if NBPFILTER > 0\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, m0);\n#endif\n\n\t\tavail = sc->tx_start - sc->tx_end;\n\t\tif (avail <= 0)\n\t\t\tavail += sc->tx_size;\n\n#ifdef IYDEBUG\n\t\tprintf(\"%s: avail is %d.\\n\", sc->sc_dev.dv_xname, avail);\n#endif\n\t\t/* \n\t\t * we MUST RUN at splnet here  --- \n\t\t * XXX todo: or even turn off the boards ints ??? hm... \n\t\t */\n\t\n       \t\t/* See if there is room to put another packet in the buffer. */\n\t\n\t\tif ((len+pad+2*I595_XMT_HDRLEN) > avail) {\n\t\t\tprintf(\"%s: len = %d, avail = %d, setting OACTIVE\\n\",\n\t\t\t    sc->sc_dev.dv_xname, len, avail);\n\t\t\tifp->if_flags |= IFF_OACTIVE;\n\t\t\treturn;\n\t\t}\n\t\n\t\t/* we know it fits in the hardware now, so dequeue it */\n\t\tIF_DEQUEUE(&ifp->if_snd, m0);\n\t\t\n\t\tlast = sc->tx_end;\n\t\tend = last + pad + len + I595_XMT_HDRLEN; \n\t\t\n\t\tif (end >= sc->sram) {\n\t\t\tif ((sc->sram - last) <= I595_XMT_HDRLEN) {\n\t\t\t\t/* keep header in one piece */\n\t\t\t\tlast = sc->rx_size;\n\t\t\t\tend = last + pad + len + I595_XMT_HDRLEN;\n\t\t\t} else\n\t\t\t\tend -= sc->tx_size;\n\t\t}\n\n\t\toutw(iobase + HOST_ADDR_REG, last);\n\t\toutw(iobase + MEM_PORT_REG, XMT_CMD);\n\t\toutw(iobase + MEM_PORT_REG, 0);\n\t\toutw(iobase + MEM_PORT_REG, 0);\n\t\toutw(iobase + MEM_PORT_REG, len + pad);\n\n\t\tresidual = resval = 0;\n\n\t\twhile ((m = m0)!=0) {\n\t\t\tdata = mtod(m, caddr_t);\n\t\t\tllen = m->m_len;\n\t\t\tif (residual) {\n#ifdef IYDEBUG\n\t\t\t\tprintf(\"%s: merging residual with next mbuf.\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n#endif\n\t\t\t\tresval |= *data << 8;\n\t\t\t\toutw(iobase + MEM_PORT_REG, resval);\n\t\t\t\t--llen;\n\t\t\t\t++data;\n\t\t\t}\n\t\t\tif (llen > 1)\n\t\t\t\toutsw(iobase + MEM_PORT_REG, data, llen>>1);\n\t\t\tresidual = llen & 1;\n\t\t\tif (residual) {\n\t\t\t\tresval = *(data + llen - 1);\n#ifdef IYDEBUG\n\t\t\t\tprintf(\"%s: got odd mbuf to send.\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n#endif\n\t\t\t}\n\n\t\t\tMFREE(m, m0);\n\t\t}\n\n\t\tif (residual)\n\t\t\toutw(iobase + MEM_PORT_REG, resval);\n\n\t\tpad >>= 1;\n\t\twhile (pad-- > 0)\n\t\t\toutw(iobase + MEM_PORT_REG, 0);\n\t\t\t\n#ifdef IYDEBUG\n\t\tprintf(\"%s: new last = 0x%x, end = 0x%x.\\n\",\n\t\t    sc->sc_dev.dv_xname, last, end);\n\t\tprintf(\"%s: old start = 0x%x, end = 0x%x, last = 0x%x\\n\",\n\t\t    sc->sc_dev.dv_xname, sc->tx_start, sc->tx_end, sc->tx_last);\n#endif\n\n\t\tif (sc->tx_start != sc->tx_end) {\n\t\t\toutw(iobase + HOST_ADDR_REG, sc->tx_last + XMT_COUNT);\n\t\t\tstat = inw(iobase + MEM_PORT_REG);\n\n\t\t\toutw(iobase + HOST_ADDR_REG, sc->tx_last + XMT_CHAIN);\n\t\t\toutw(iobase + MEM_PORT_REG, last);\n\t\t\toutw(iobase + MEM_PORT_REG, stat | CHAIN);\n#ifdef IYDEBUG\n\t\t\tprintf(\"%s: setting 0x%x to 0x%x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, sc->tx_last + XMT_COUNT, \n\t\t\t    stat | CHAIN);\n#endif\n\t\t}\n\t\tstat = inw(iobase + MEM_PORT_REG); /* dummy read */\n\n\t\t/* XXX todo: enable ints here if disabled */\n\t\t\n\t\t++ifp->if_opackets;\n\n\t\tif (sc->tx_start == sc->tx_end) {\n\t\t\toutw(iobase + XMT_ADDR_REG, last);\n\t\t\toutb(iobase, XMT_CMD);\n\t\t\tsc->tx_start = last;\n#ifdef IYDEBUG\n\t\t\tprintf(\"%s: writing 0x%x to XAR and giving XCMD\\n\",\n\t\t\t    sc->sc_dev.dv_xname, last);\n#endif\n\t\t} else {\n\t\t\toutb(iobase, RESUME_XMT_CMD);\n#ifdef IYDEBUG\n\t\t\tprintf(\"%s: giving RESUME_XCMD\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n#endif\n\t\t}\n\t\tsc->tx_last = last;\n\t\tsc->tx_end = end;\n\t}\n}"
  },
  {
    "function_name": "iyinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_iy.c",
    "lines": "370-477",
    "snippet": "void\niyinit(sc)\nstruct iy_softc *sc;\n{\n\tint i;\n\tunsigned temp;\n\tstruct ifnet *ifp;\n\tint iobase;\n\n\tifp = &sc->sc_arpcom.ac_if;\n#ifdef IYDEBUG\n\tprintf(\"ifp is %p\\n\", ifp);\n#endif\n\tiobase = sc->sc_iobase;\n\n\toutb(iobase, BANK_SEL(2));\n\n\ttemp = inb(iobase + EEPROM_REG);\n\tif (temp & 0x10)\n\t\toutb(iobase + EEPROM_REG, temp & ~0x10);\n\t\n\tfor (i=0; i<6; ++i) {\n\t\toutb(iobase + I_ADD(i), sc->sc_arpcom.ac_enaddr[i]);\n\t}\n\n\ttemp = inb(iobase + REG1);\n\toutb(iobase + REG1, temp | XMT_CHAIN_INT | XMT_CHAIN_ERRSTOP |\n\t    RCV_DISCARD_BAD);\n\t\n\ttemp = inb(iobase + RECV_MODES_REG);\n\toutb(iobase + RECV_MODES_REG, temp | MATCH_BRDCST);\n#ifdef IYDEBUG\n\tprintf(\"%s: RECV_MODES were %b set to %b\\n\",\n\t    sc->sc_dev.dv_xname, \n\t    temp, \"\\020\\1PRMSC\\2NOBRDST\\3SEECRC\\4LENGTH\\5NOSaIns\\6MultiIA\",\n\t    temp|MATCH_BRDCST,\n\t    \"\\020\\1PRMSC\\2NOBRDST\\3SEECRC\\4LENGTH\\5NOSaIns\\6MultiIA\");\n#endif\n\n\n\tDELAY(500000); /* for the hardware to test for the connector */\n\n\ttemp = inb(iobase + MEDIA_SELECT);\n#ifdef IYDEBUG\n\tprintf(\"%s: media select was 0x%b\", sc->sc_dev.dv_xname,\n\t    temp, \"\\020\\1LnkInDis\\2PolCor\\3TPE\\4JabberDis\\5NoAport\\6BNC\");\n#endif\n\ttemp = (temp & TEST_MODE_MASK) /* | BNC_BIT XXX*/;\n\toutb(iobase + MEDIA_SELECT, temp);\n#ifdef IYDEBUG\n\tprintf(\"changed to 0x%b\\n\", \n\t    temp, \"\\020\\1LnkInDis\\2PolCor\\3TPE\\4JabberDis\\5NoAport\\6BNC\");\n#endif\n\n\toutb(iobase, BANK_SEL(1));\n\n\ttemp = inb(iobase + INT_NO_REG);\n\toutb(iobase + INT_NO_REG, (temp & 0xf8) | sc->mappedirq);\n\n#ifdef IYDEBUG\n\tprintf(\"%s: int no was %b\\n\", sc->sc_dev.dv_xname,\n\t    temp, \"\\020\\4bad_irq\\010flash/boot present\");\n\ttemp = inb(iobase + INT_NO_REG);\n\tprintf(\"%s: int no now 0x%02x\\n\", sc->sc_dev.dv_xname,\n\t    temp, \"\\020\\4BAD IRQ\\010flash/boot present\");\n#endif\n\n\n\toutb(iobase + RCV_LOWER_LIMIT_REG, 0);\n\toutb(iobase + RCV_UPPER_LIMIT_REG, (sc->rx_size - 2) >> 8);\n\toutb(iobase + XMT_LOWER_LIMIT_REG, sc->rx_size >> 8);\n\toutb(iobase + XMT_UPPER_LIMIT_REG, sc->sram >> 8);\n\n\ttemp = inb(iobase + REG1);\n#ifdef IYDEBUG\n\tprintf(\"%s: HW access is %b\\n\", sc->sc_dev.dv_xname, \n\t    temp, \"\\020\\2WORD_WIDTH\\010INT_ENABLE\");\n#endif\n\toutb(iobase + REG1, temp | INT_ENABLE); /* XXX what about WORD_WIDTH? */\n\n#ifdef IYDEBUG\n\ttemp = inb(iobase + REG1);\n\tprintf(\"%s: HW access is %b\\n\", sc->sc_dev.dv_xname, \n\t    temp, \"\\020\\2WORD_WIDTH\\010INT_ENABLE\");\n#endif\n\n\toutb(iobase, BANK_SEL(0));\n\n\toutb(iobase + INT_MASK_REG, ALL_INTS & ~(RX_BIT|TX_BIT));\n\toutb(iobase + STATUS_REG, ALL_INTS); /* clear ints */\n\n\toutw(iobase + RCV_START_LOW, 0);\n\toutw(iobase + RCV_STOP_LOW,  sc->rx_size - 2);\n\tsc->rx_start = 0;\n\n\toutb(iobase, SEL_RESET_CMD);\n\tDELAY(200);\n\n\toutw(iobase + XMT_ADDR_REG, sc->rx_size);\n\n\tsc->tx_start = sc->tx_end = sc->rx_size;\n\tsc->tx_last = 0;\n\n\toutb(iobase, RCV_ENABLE_CMD);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n}",
    "includes": [
      "#include <dev/ic/i82595reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void iyinit"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "iobase",
            "RCV_ENABLE_CMD"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "iobase + XMT_ADDR_REG",
            "sc->rx_size"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "200"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "iobase + RCV_STOP_LOW",
            "sc->rx_size - 2"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "iobase + RCV_START_LOW",
            "0"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BANK_SEL",
          "args": [
            "0"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: HW access is %b\\n\"",
            "sc->sc_dev.dv_xname",
            "temp",
            "\"\\020\\2WORD_WIDTH\\010INT_ENABLE\""
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "iobase + REG1"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BANK_SEL",
          "args": [
            "1"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "500000"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "I_ADD",
          "args": [
            "i"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BANK_SEL",
          "args": [
            "2"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82595reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid iyinit;\n\nvoid\niyinit(sc)\nstruct iy_softc *sc;\n{\n\tint i;\n\tunsigned temp;\n\tstruct ifnet *ifp;\n\tint iobase;\n\n\tifp = &sc->sc_arpcom.ac_if;\n#ifdef IYDEBUG\n\tprintf(\"ifp is %p\\n\", ifp);\n#endif\n\tiobase = sc->sc_iobase;\n\n\toutb(iobase, BANK_SEL(2));\n\n\ttemp = inb(iobase + EEPROM_REG);\n\tif (temp & 0x10)\n\t\toutb(iobase + EEPROM_REG, temp & ~0x10);\n\t\n\tfor (i=0; i<6; ++i) {\n\t\toutb(iobase + I_ADD(i), sc->sc_arpcom.ac_enaddr[i]);\n\t}\n\n\ttemp = inb(iobase + REG1);\n\toutb(iobase + REG1, temp | XMT_CHAIN_INT | XMT_CHAIN_ERRSTOP |\n\t    RCV_DISCARD_BAD);\n\t\n\ttemp = inb(iobase + RECV_MODES_REG);\n\toutb(iobase + RECV_MODES_REG, temp | MATCH_BRDCST);\n#ifdef IYDEBUG\n\tprintf(\"%s: RECV_MODES were %b set to %b\\n\",\n\t    sc->sc_dev.dv_xname, \n\t    temp, \"\\020\\1PRMSC\\2NOBRDST\\3SEECRC\\4LENGTH\\5NOSaIns\\6MultiIA\",\n\t    temp|MATCH_BRDCST,\n\t    \"\\020\\1PRMSC\\2NOBRDST\\3SEECRC\\4LENGTH\\5NOSaIns\\6MultiIA\");\n#endif\n\n\n\tDELAY(500000); /* for the hardware to test for the connector */\n\n\ttemp = inb(iobase + MEDIA_SELECT);\n#ifdef IYDEBUG\n\tprintf(\"%s: media select was 0x%b\", sc->sc_dev.dv_xname,\n\t    temp, \"\\020\\1LnkInDis\\2PolCor\\3TPE\\4JabberDis\\5NoAport\\6BNC\");\n#endif\n\ttemp = (temp & TEST_MODE_MASK) /* | BNC_BIT XXX*/;\n\toutb(iobase + MEDIA_SELECT, temp);\n#ifdef IYDEBUG\n\tprintf(\"changed to 0x%b\\n\", \n\t    temp, \"\\020\\1LnkInDis\\2PolCor\\3TPE\\4JabberDis\\5NoAport\\6BNC\");\n#endif\n\n\toutb(iobase, BANK_SEL(1));\n\n\ttemp = inb(iobase + INT_NO_REG);\n\toutb(iobase + INT_NO_REG, (temp & 0xf8) | sc->mappedirq);\n\n#ifdef IYDEBUG\n\tprintf(\"%s: int no was %b\\n\", sc->sc_dev.dv_xname,\n\t    temp, \"\\020\\4bad_irq\\010flash/boot present\");\n\ttemp = inb(iobase + INT_NO_REG);\n\tprintf(\"%s: int no now 0x%02x\\n\", sc->sc_dev.dv_xname,\n\t    temp, \"\\020\\4BAD IRQ\\010flash/boot present\");\n#endif\n\n\n\toutb(iobase + RCV_LOWER_LIMIT_REG, 0);\n\toutb(iobase + RCV_UPPER_LIMIT_REG, (sc->rx_size - 2) >> 8);\n\toutb(iobase + XMT_LOWER_LIMIT_REG, sc->rx_size >> 8);\n\toutb(iobase + XMT_UPPER_LIMIT_REG, sc->sram >> 8);\n\n\ttemp = inb(iobase + REG1);\n#ifdef IYDEBUG\n\tprintf(\"%s: HW access is %b\\n\", sc->sc_dev.dv_xname, \n\t    temp, \"\\020\\2WORD_WIDTH\\010INT_ENABLE\");\n#endif\n\toutb(iobase + REG1, temp | INT_ENABLE); /* XXX what about WORD_WIDTH? */\n\n#ifdef IYDEBUG\n\ttemp = inb(iobase + REG1);\n\tprintf(\"%s: HW access is %b\\n\", sc->sc_dev.dv_xname, \n\t    temp, \"\\020\\2WORD_WIDTH\\010INT_ENABLE\");\n#endif\n\n\toutb(iobase, BANK_SEL(0));\n\n\toutb(iobase + INT_MASK_REG, ALL_INTS & ~(RX_BIT|TX_BIT));\n\toutb(iobase + STATUS_REG, ALL_INTS); /* clear ints */\n\n\toutw(iobase + RCV_START_LOW, 0);\n\toutw(iobase + RCV_STOP_LOW,  sc->rx_size - 2);\n\tsc->rx_start = 0;\n\n\toutb(iobase, SEL_RESET_CMD);\n\tDELAY(200);\n\n\toutw(iobase + XMT_ADDR_REG, sc->rx_size);\n\n\tsc->tx_start = sc->tx_end = sc->rx_size;\n\tsc->tx_last = 0;\n\n\toutb(iobase, RCV_ENABLE_CMD);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n}"
  },
  {
    "function_name": "iyreset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_iy.c",
    "lines": "359-368",
    "snippet": "void\niyreset(sc)\nstruct iy_softc *sc;\n{\n\tint s;\n\ts = splimp();\n\tiystop(sc);\n\tiyinit(sc);\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/ic/i82595reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void iyinit",
      "void iystop",
      "void iyreset"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iyinit",
          "args": [
            "sc"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "iyinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_iy.c",
          "lines": "370-477",
          "snippet": "void\niyinit(sc)\nstruct iy_softc *sc;\n{\n\tint i;\n\tunsigned temp;\n\tstruct ifnet *ifp;\n\tint iobase;\n\n\tifp = &sc->sc_arpcom.ac_if;\n#ifdef IYDEBUG\n\tprintf(\"ifp is %p\\n\", ifp);\n#endif\n\tiobase = sc->sc_iobase;\n\n\toutb(iobase, BANK_SEL(2));\n\n\ttemp = inb(iobase + EEPROM_REG);\n\tif (temp & 0x10)\n\t\toutb(iobase + EEPROM_REG, temp & ~0x10);\n\t\n\tfor (i=0; i<6; ++i) {\n\t\toutb(iobase + I_ADD(i), sc->sc_arpcom.ac_enaddr[i]);\n\t}\n\n\ttemp = inb(iobase + REG1);\n\toutb(iobase + REG1, temp | XMT_CHAIN_INT | XMT_CHAIN_ERRSTOP |\n\t    RCV_DISCARD_BAD);\n\t\n\ttemp = inb(iobase + RECV_MODES_REG);\n\toutb(iobase + RECV_MODES_REG, temp | MATCH_BRDCST);\n#ifdef IYDEBUG\n\tprintf(\"%s: RECV_MODES were %b set to %b\\n\",\n\t    sc->sc_dev.dv_xname, \n\t    temp, \"\\020\\1PRMSC\\2NOBRDST\\3SEECRC\\4LENGTH\\5NOSaIns\\6MultiIA\",\n\t    temp|MATCH_BRDCST,\n\t    \"\\020\\1PRMSC\\2NOBRDST\\3SEECRC\\4LENGTH\\5NOSaIns\\6MultiIA\");\n#endif\n\n\n\tDELAY(500000); /* for the hardware to test for the connector */\n\n\ttemp = inb(iobase + MEDIA_SELECT);\n#ifdef IYDEBUG\n\tprintf(\"%s: media select was 0x%b\", sc->sc_dev.dv_xname,\n\t    temp, \"\\020\\1LnkInDis\\2PolCor\\3TPE\\4JabberDis\\5NoAport\\6BNC\");\n#endif\n\ttemp = (temp & TEST_MODE_MASK) /* | BNC_BIT XXX*/;\n\toutb(iobase + MEDIA_SELECT, temp);\n#ifdef IYDEBUG\n\tprintf(\"changed to 0x%b\\n\", \n\t    temp, \"\\020\\1LnkInDis\\2PolCor\\3TPE\\4JabberDis\\5NoAport\\6BNC\");\n#endif\n\n\toutb(iobase, BANK_SEL(1));\n\n\ttemp = inb(iobase + INT_NO_REG);\n\toutb(iobase + INT_NO_REG, (temp & 0xf8) | sc->mappedirq);\n\n#ifdef IYDEBUG\n\tprintf(\"%s: int no was %b\\n\", sc->sc_dev.dv_xname,\n\t    temp, \"\\020\\4bad_irq\\010flash/boot present\");\n\ttemp = inb(iobase + INT_NO_REG);\n\tprintf(\"%s: int no now 0x%02x\\n\", sc->sc_dev.dv_xname,\n\t    temp, \"\\020\\4BAD IRQ\\010flash/boot present\");\n#endif\n\n\n\toutb(iobase + RCV_LOWER_LIMIT_REG, 0);\n\toutb(iobase + RCV_UPPER_LIMIT_REG, (sc->rx_size - 2) >> 8);\n\toutb(iobase + XMT_LOWER_LIMIT_REG, sc->rx_size >> 8);\n\toutb(iobase + XMT_UPPER_LIMIT_REG, sc->sram >> 8);\n\n\ttemp = inb(iobase + REG1);\n#ifdef IYDEBUG\n\tprintf(\"%s: HW access is %b\\n\", sc->sc_dev.dv_xname, \n\t    temp, \"\\020\\2WORD_WIDTH\\010INT_ENABLE\");\n#endif\n\toutb(iobase + REG1, temp | INT_ENABLE); /* XXX what about WORD_WIDTH? */\n\n#ifdef IYDEBUG\n\ttemp = inb(iobase + REG1);\n\tprintf(\"%s: HW access is %b\\n\", sc->sc_dev.dv_xname, \n\t    temp, \"\\020\\2WORD_WIDTH\\010INT_ENABLE\");\n#endif\n\n\toutb(iobase, BANK_SEL(0));\n\n\toutb(iobase + INT_MASK_REG, ALL_INTS & ~(RX_BIT|TX_BIT));\n\toutb(iobase + STATUS_REG, ALL_INTS); /* clear ints */\n\n\toutw(iobase + RCV_START_LOW, 0);\n\toutw(iobase + RCV_STOP_LOW,  sc->rx_size - 2);\n\tsc->rx_start = 0;\n\n\toutb(iobase, SEL_RESET_CMD);\n\tDELAY(200);\n\n\toutw(iobase + XMT_ADDR_REG, sc->rx_size);\n\n\tsc->tx_start = sc->tx_end = sc->rx_size;\n\tsc->tx_last = 0;\n\n\toutb(iobase, RCV_ENABLE_CMD);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n}",
          "includes": [
            "#include <dev/ic/i82595reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void iyinit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82595reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid iyinit;\n\nvoid\niyinit(sc)\nstruct iy_softc *sc;\n{\n\tint i;\n\tunsigned temp;\n\tstruct ifnet *ifp;\n\tint iobase;\n\n\tifp = &sc->sc_arpcom.ac_if;\n#ifdef IYDEBUG\n\tprintf(\"ifp is %p\\n\", ifp);\n#endif\n\tiobase = sc->sc_iobase;\n\n\toutb(iobase, BANK_SEL(2));\n\n\ttemp = inb(iobase + EEPROM_REG);\n\tif (temp & 0x10)\n\t\toutb(iobase + EEPROM_REG, temp & ~0x10);\n\t\n\tfor (i=0; i<6; ++i) {\n\t\toutb(iobase + I_ADD(i), sc->sc_arpcom.ac_enaddr[i]);\n\t}\n\n\ttemp = inb(iobase + REG1);\n\toutb(iobase + REG1, temp | XMT_CHAIN_INT | XMT_CHAIN_ERRSTOP |\n\t    RCV_DISCARD_BAD);\n\t\n\ttemp = inb(iobase + RECV_MODES_REG);\n\toutb(iobase + RECV_MODES_REG, temp | MATCH_BRDCST);\n#ifdef IYDEBUG\n\tprintf(\"%s: RECV_MODES were %b set to %b\\n\",\n\t    sc->sc_dev.dv_xname, \n\t    temp, \"\\020\\1PRMSC\\2NOBRDST\\3SEECRC\\4LENGTH\\5NOSaIns\\6MultiIA\",\n\t    temp|MATCH_BRDCST,\n\t    \"\\020\\1PRMSC\\2NOBRDST\\3SEECRC\\4LENGTH\\5NOSaIns\\6MultiIA\");\n#endif\n\n\n\tDELAY(500000); /* for the hardware to test for the connector */\n\n\ttemp = inb(iobase + MEDIA_SELECT);\n#ifdef IYDEBUG\n\tprintf(\"%s: media select was 0x%b\", sc->sc_dev.dv_xname,\n\t    temp, \"\\020\\1LnkInDis\\2PolCor\\3TPE\\4JabberDis\\5NoAport\\6BNC\");\n#endif\n\ttemp = (temp & TEST_MODE_MASK) /* | BNC_BIT XXX*/;\n\toutb(iobase + MEDIA_SELECT, temp);\n#ifdef IYDEBUG\n\tprintf(\"changed to 0x%b\\n\", \n\t    temp, \"\\020\\1LnkInDis\\2PolCor\\3TPE\\4JabberDis\\5NoAport\\6BNC\");\n#endif\n\n\toutb(iobase, BANK_SEL(1));\n\n\ttemp = inb(iobase + INT_NO_REG);\n\toutb(iobase + INT_NO_REG, (temp & 0xf8) | sc->mappedirq);\n\n#ifdef IYDEBUG\n\tprintf(\"%s: int no was %b\\n\", sc->sc_dev.dv_xname,\n\t    temp, \"\\020\\4bad_irq\\010flash/boot present\");\n\ttemp = inb(iobase + INT_NO_REG);\n\tprintf(\"%s: int no now 0x%02x\\n\", sc->sc_dev.dv_xname,\n\t    temp, \"\\020\\4BAD IRQ\\010flash/boot present\");\n#endif\n\n\n\toutb(iobase + RCV_LOWER_LIMIT_REG, 0);\n\toutb(iobase + RCV_UPPER_LIMIT_REG, (sc->rx_size - 2) >> 8);\n\toutb(iobase + XMT_LOWER_LIMIT_REG, sc->rx_size >> 8);\n\toutb(iobase + XMT_UPPER_LIMIT_REG, sc->sram >> 8);\n\n\ttemp = inb(iobase + REG1);\n#ifdef IYDEBUG\n\tprintf(\"%s: HW access is %b\\n\", sc->sc_dev.dv_xname, \n\t    temp, \"\\020\\2WORD_WIDTH\\010INT_ENABLE\");\n#endif\n\toutb(iobase + REG1, temp | INT_ENABLE); /* XXX what about WORD_WIDTH? */\n\n#ifdef IYDEBUG\n\ttemp = inb(iobase + REG1);\n\tprintf(\"%s: HW access is %b\\n\", sc->sc_dev.dv_xname, \n\t    temp, \"\\020\\2WORD_WIDTH\\010INT_ENABLE\");\n#endif\n\n\toutb(iobase, BANK_SEL(0));\n\n\toutb(iobase + INT_MASK_REG, ALL_INTS & ~(RX_BIT|TX_BIT));\n\toutb(iobase + STATUS_REG, ALL_INTS); /* clear ints */\n\n\toutw(iobase + RCV_START_LOW, 0);\n\toutw(iobase + RCV_STOP_LOW,  sc->rx_size - 2);\n\tsc->rx_start = 0;\n\n\toutb(iobase, SEL_RESET_CMD);\n\tDELAY(200);\n\n\toutw(iobase + XMT_ADDR_REG, sc->rx_size);\n\n\tsc->tx_start = sc->tx_end = sc->rx_size;\n\tsc->tx_last = 0;\n\n\toutb(iobase, RCV_ENABLE_CMD);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iystop",
          "args": [
            "sc"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "iystop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_iy.c",
          "lines": "315-357",
          "snippet": "void\niystop(sc)\nstruct iy_softc *sc;\n{\n\tint iobase;\n#ifdef IYDEBUG\n\tu_int p, v;\n#endif\n\n\tiobase = sc->sc_iobase;\n\t\n\toutb(iobase + COMMAND_REG, RCV_DISABLE_CMD);\n\n\toutb(iobase + INT_MASK_REG, ALL_INTS);\n\toutb(iobase + STATUS_REG, ALL_INTS);\n\n\toutb(iobase + COMMAND_REG, RESET_CMD);\n\tdelay(200);\n#ifdef IYDEBUG \n\tprintf(\"%s: dumping tx chain (st 0x%x end 0x%x last 0x%x)\\n\", \n\t\t    sc->sc_dev.dv_xname, sc->tx_start, sc->tx_end, sc->tx_last);\n\tp = sc->tx_last;\n\tif (!p)\n\t\tp = sc->tx_start;\n\tdo {\n\t\toutw(iobase + HOST_ADDR_REG, p);\n\t\tv = inw(iobase + MEM_PORT_REG);\n\t\tprintf(\"0x%04x: %b \", p, v, \"\\020\\006Ab\\010Dn\");\n\t\tv = inw(iobase + MEM_PORT_REG);\n\t\tprintf(\"0x%b\", v, \"\\020\\6MAX_COL\\7HRT_BEAT\\010TX_DEF\\011UND_RUN\\012JERR\\013LST_CRS\\014LTCOL\\016TX_OK\\020COLL\");\n\t\tp = inw(iobase + MEM_PORT_REG);\n\t\tprintf(\" 0x%04x\", p);\n\t\tv = inw(iobase + MEM_PORT_REG);\n\t\tprintf(\" 0x%b\\n\", v, \"\\020\\020Ch\");\n\t\t\n\t} while (v & 0x8000);\n#endif\n\tsc->tx_start = sc->tx_end = sc->rx_size;\n\tsc->tx_last = 0;\n\tsc->sc_arpcom.ac_if.if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);\n\n\tiymbufempty((void *)sc);\n}",
          "includes": [
            "#include <dev/ic/i82595reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void iystop",
            "void iymbufempty"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82595reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid iystop;\nvoid iymbufempty;\n\nvoid\niystop(sc)\nstruct iy_softc *sc;\n{\n\tint iobase;\n#ifdef IYDEBUG\n\tu_int p, v;\n#endif\n\n\tiobase = sc->sc_iobase;\n\t\n\toutb(iobase + COMMAND_REG, RCV_DISABLE_CMD);\n\n\toutb(iobase + INT_MASK_REG, ALL_INTS);\n\toutb(iobase + STATUS_REG, ALL_INTS);\n\n\toutb(iobase + COMMAND_REG, RESET_CMD);\n\tdelay(200);\n#ifdef IYDEBUG \n\tprintf(\"%s: dumping tx chain (st 0x%x end 0x%x last 0x%x)\\n\", \n\t\t    sc->sc_dev.dv_xname, sc->tx_start, sc->tx_end, sc->tx_last);\n\tp = sc->tx_last;\n\tif (!p)\n\t\tp = sc->tx_start;\n\tdo {\n\t\toutw(iobase + HOST_ADDR_REG, p);\n\t\tv = inw(iobase + MEM_PORT_REG);\n\t\tprintf(\"0x%04x: %b \", p, v, \"\\020\\006Ab\\010Dn\");\n\t\tv = inw(iobase + MEM_PORT_REG);\n\t\tprintf(\"0x%b\", v, \"\\020\\6MAX_COL\\7HRT_BEAT\\010TX_DEF\\011UND_RUN\\012JERR\\013LST_CRS\\014LTCOL\\016TX_OK\\020COLL\");\n\t\tp = inw(iobase + MEM_PORT_REG);\n\t\tprintf(\" 0x%04x\", p);\n\t\tv = inw(iobase + MEM_PORT_REG);\n\t\tprintf(\" 0x%b\\n\", v, \"\\020\\020Ch\");\n\t\t\n\t} while (v & 0x8000);\n#endif\n\tsc->tx_start = sc->tx_end = sc->rx_size;\n\tsc->tx_last = 0;\n\tsc->sc_arpcom.ac_if.if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);\n\n\tiymbufempty((void *)sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82595reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid iyinit;\nvoid iystop;\nvoid iyreset;\n\nvoid\niyreset(sc)\nstruct iy_softc *sc;\n{\n\tint s;\n\ts = splimp();\n\tiystop(sc);\n\tiyinit(sc);\n\tsplx(s);\n}"
  },
  {
    "function_name": "iystop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_iy.c",
    "lines": "315-357",
    "snippet": "void\niystop(sc)\nstruct iy_softc *sc;\n{\n\tint iobase;\n#ifdef IYDEBUG\n\tu_int p, v;\n#endif\n\n\tiobase = sc->sc_iobase;\n\t\n\toutb(iobase + COMMAND_REG, RCV_DISABLE_CMD);\n\n\toutb(iobase + INT_MASK_REG, ALL_INTS);\n\toutb(iobase + STATUS_REG, ALL_INTS);\n\n\toutb(iobase + COMMAND_REG, RESET_CMD);\n\tdelay(200);\n#ifdef IYDEBUG \n\tprintf(\"%s: dumping tx chain (st 0x%x end 0x%x last 0x%x)\\n\", \n\t\t    sc->sc_dev.dv_xname, sc->tx_start, sc->tx_end, sc->tx_last);\n\tp = sc->tx_last;\n\tif (!p)\n\t\tp = sc->tx_start;\n\tdo {\n\t\toutw(iobase + HOST_ADDR_REG, p);\n\t\tv = inw(iobase + MEM_PORT_REG);\n\t\tprintf(\"0x%04x: %b \", p, v, \"\\020\\006Ab\\010Dn\");\n\t\tv = inw(iobase + MEM_PORT_REG);\n\t\tprintf(\"0x%b\", v, \"\\020\\6MAX_COL\\7HRT_BEAT\\010TX_DEF\\011UND_RUN\\012JERR\\013LST_CRS\\014LTCOL\\016TX_OK\\020COLL\");\n\t\tp = inw(iobase + MEM_PORT_REG);\n\t\tprintf(\" 0x%04x\", p);\n\t\tv = inw(iobase + MEM_PORT_REG);\n\t\tprintf(\" 0x%b\\n\", v, \"\\020\\020Ch\");\n\t\t\n\t} while (v & 0x8000);\n#endif\n\tsc->tx_start = sc->tx_end = sc->rx_size;\n\tsc->tx_last = 0;\n\tsc->sc_arpcom.ac_if.if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);\n\n\tiymbufempty((void *)sc);\n}",
    "includes": [
      "#include <dev/ic/i82595reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void iystop",
      "void iymbufempty"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iymbufempty",
          "args": [
            "(void *)sc"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "iymbufempty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_iy.c",
          "lines": "1255-1272",
          "snippet": "void\niymbufempty(arg)\n\tvoid *arg;\n{\n\tstruct iy_softc *sc = (struct iy_softc *)arg;\n\tint s, i;\n\n\ts = splimp();\n\tfor (i = 0; i<MAX_MBS; i++) {\n\t\tif (sc->mb[i]) {\n\t\t\tm_freem(sc->mb[i]);\n\t\t\tsc->mb[i] = NULL;\n\t\t}\n\t}\n\tsc->last_mb = sc->next_mb = 0;\n\tuntimeout(iymbuffill, sc);\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/i82595reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define MAX_MBS 8"
          ],
          "globals_used": [
            "void iymbuffill",
            "void iymbufempty"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82595reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define MAX_MBS 8\n\nvoid iymbuffill;\nvoid iymbufempty;\n\nvoid\niymbufempty(arg)\n\tvoid *arg;\n{\n\tstruct iy_softc *sc = (struct iy_softc *)arg;\n\tint s, i;\n\n\ts = splimp();\n\tfor (i = 0; i<MAX_MBS; i++) {\n\t\tif (sc->mb[i]) {\n\t\t\tm_freem(sc->mb[i]);\n\t\t\tsc->mb[i] = NULL;\n\t\t}\n\t}\n\tsc->last_mb = sc->next_mb = 0;\n\tuntimeout(iymbuffill, sc);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" 0x%b\\n\"",
            "v",
            "\"\\020\\020Ch\""
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "iobase + MEM_PORT_REG"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "iobase + MEM_PORT_REG"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "iobase + MEM_PORT_REG"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inw",
          "args": [
            "iobase + MEM_PORT_REG"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outw",
          "args": [
            "iobase + HOST_ADDR_REG",
            "p"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "200"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "iobase + COMMAND_REG",
            "RESET_CMD"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82595reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid iystop;\nvoid iymbufempty;\n\nvoid\niystop(sc)\nstruct iy_softc *sc;\n{\n\tint iobase;\n#ifdef IYDEBUG\n\tu_int p, v;\n#endif\n\n\tiobase = sc->sc_iobase;\n\t\n\toutb(iobase + COMMAND_REG, RCV_DISABLE_CMD);\n\n\toutb(iobase + INT_MASK_REG, ALL_INTS);\n\toutb(iobase + STATUS_REG, ALL_INTS);\n\n\toutb(iobase + COMMAND_REG, RESET_CMD);\n\tdelay(200);\n#ifdef IYDEBUG \n\tprintf(\"%s: dumping tx chain (st 0x%x end 0x%x last 0x%x)\\n\", \n\t\t    sc->sc_dev.dv_xname, sc->tx_start, sc->tx_end, sc->tx_last);\n\tp = sc->tx_last;\n\tif (!p)\n\t\tp = sc->tx_start;\n\tdo {\n\t\toutw(iobase + HOST_ADDR_REG, p);\n\t\tv = inw(iobase + MEM_PORT_REG);\n\t\tprintf(\"0x%04x: %b \", p, v, \"\\020\\006Ab\\010Dn\");\n\t\tv = inw(iobase + MEM_PORT_REG);\n\t\tprintf(\"0x%b\", v, \"\\020\\6MAX_COL\\7HRT_BEAT\\010TX_DEF\\011UND_RUN\\012JERR\\013LST_CRS\\014LTCOL\\016TX_OK\\020COLL\");\n\t\tp = inw(iobase + MEM_PORT_REG);\n\t\tprintf(\" 0x%04x\", p);\n\t\tv = inw(iobase + MEM_PORT_REG);\n\t\tprintf(\" 0x%b\\n\", v, \"\\020\\020Ch\");\n\t\t\n\t} while (v & 0x8000);\n#endif\n\tsc->tx_start = sc->tx_end = sc->rx_size;\n\tsc->tx_last = 0;\n\tsc->sc_arpcom.ac_if.if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);\n\n\tiymbufempty((void *)sc);\n}"
  },
  {
    "function_name": "iyattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_iy.c",
    "lines": "279-313",
    "snippet": "void\niyattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct iy_softc *sc = (void *)self;\n\tstruct isa_attach_args *ia = aux;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_start = iystart;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS;\n\t\t\t\t\t/* XXX todo: | IFF_MULTICAST */\n\tsc->sc_iobase = ia->ia_iobase;\n\n\tiyprobemem(sc);\n\n\tifp->if_ioctl = iyioctl;\n\tifp->if_watchdog = iywatchdog;\n\n\t/* Attach the interface. */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\tprintf(\": address %s, chip rev. %d, %d kB SRAM\\n\",\n\t    ether_sprintf(sc->sc_arpcom.ac_enaddr),\n\t    sc->hard_vers, sc->sram/1024);\n#if NBPFILTER > 0\n\tbpfattach(&sc->sc_arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,\n\t    sizeof(struct ether_header));\n#endif\n\n\tsc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE, \n\t    IPL_NET, iyintr, sc);\n}",
    "includes": [
      "#include <dev/ic/i82595reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void iywatchdog",
      "int iyioctl",
      "int iyintr",
      "void iystart",
      "void iyprobemem",
      "void iyattach"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "isa_intr_establish",
          "args": [
            "ia->ia_ic",
            "ia->ia_irq",
            "IST_EDGE",
            "IPL_NET",
            "iyintr",
            "sc"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpfattach",
          "args": [
            "&sc->sc_arpcom.ac_if.if_bpf",
            "ifp",
            "DLT_EN10MB",
            "sizeof(struct ether_header)"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\": address %s, chip rev. %d, %d kB SRAM\\n\"",
            "ether_sprintf(sc->sc_arpcom.ac_enaddr)",
            "sc->hard_vers",
            "sc->sram/1024"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_sprintf",
          "args": [
            "sc->sc_arpcom.ac_enaddr"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ifattach",
          "args": [
            "ifp"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_attach",
          "args": [
            "ifp"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iyprobemem",
          "args": [
            "sc"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "iyprobemem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_iy.c",
          "lines": "1274-1347",
          "snippet": "void\niyprobemem(sc)\n\tstruct iy_softc *sc;\n{\n\tint iobase;\n\tint testing;\n\n\tiobase = sc->sc_iobase;\n\n\toutw(iobase + HOST_ADDR_REG, 4096-2);\n\toutw(iobase + MEM_PORT_REG, 0);\n\n\tfor (testing=65536; testing >= 4096; testing >>= 1) {\n\t\toutw(iobase + HOST_ADDR_REG, testing-2);\n\t\toutw(iobase + MEM_PORT_REG, 0xdead);\n\t\toutw(iobase + HOST_ADDR_REG, testing-2);\n\t\tif (inw(iobase + MEM_PORT_REG) != 0xdead) {\n#ifdef IYMEMDEBUG\n\t\t\tprintf(\"%s: Didn't keep 0xdead at 0x%x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, testing-2);\n#endif\n\t\t\tcontinue;\n\t\t}\n\n\t\toutw(iobase + HOST_ADDR_REG, testing-2);\n\t\toutw(iobase + MEM_PORT_REG, 0xbeef);\n\t\toutw(iobase + HOST_ADDR_REG, testing-2);\n\t\tif (inw(iobase + MEM_PORT_REG) != 0xbeef) {\n#ifdef IYMEMDEBUG\n\t\t\tprintf(\"%s: Didn't keep 0xbeef at 0x%x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, testing-2);\n#endif\n\t\t\tcontinue;\n\t\t}\n\n\t\toutw(iobase + HOST_ADDR_REG, 0);\n\t\toutw(iobase + MEM_PORT_REG, 0);\n\t\toutw(iobase + HOST_ADDR_REG, testing >> 1);\n\t\toutw(iobase + MEM_PORT_REG, testing >> 1);\n\t\toutw(iobase + HOST_ADDR_REG, 0);\n\t\tif (inw(iobase + MEM_PORT_REG) == (testing >> 1)) {\n#ifdef IYMEMDEBUG\n\t\t\tprintf(\"%s: 0x%x alias of 0x0\\n\",\n\t\t\t    sc->sc_dev.dv_xname, testing >> 1);\n#endif\n\t\t\tcontinue;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tsc->sram = testing;\n\n\tswitch(testing) {\n\t\tcase 65536:\n\t\t\t/* 4 NFS packets + overhead RX, 2 NFS + overhead TX  */\n\t\t\tsc->rx_size = 44*1024;\n\t\t\tbreak;\n\n\t\tcase 32768:\n\t\t\t/* 2 NFS packets + overhead RX, 1 NFS + overhead TX  */\n\t\t\tsc->rx_size = 22*1024;\n\t\t\tbreak;\n\n\t\tcase 16384:\n\t\t\t/* 1 NFS packet + overhead RX, 4 big packets TX */\n\t\t\tsc->rx_size = 10*1024;\n\t\t\tbreak;\n\t\tdefault:\t\n\t\t\tsc->rx_size = testing/2;\n\t\t\tbreak;\n\t}\n\tsc->tx_size = testing - sc->rx_size;\n}",
          "includes": [
            "#include <dev/ic/i82595reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void iyprobemem"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82595reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid iyprobemem;\n\nvoid\niyprobemem(sc)\n\tstruct iy_softc *sc;\n{\n\tint iobase;\n\tint testing;\n\n\tiobase = sc->sc_iobase;\n\n\toutw(iobase + HOST_ADDR_REG, 4096-2);\n\toutw(iobase + MEM_PORT_REG, 0);\n\n\tfor (testing=65536; testing >= 4096; testing >>= 1) {\n\t\toutw(iobase + HOST_ADDR_REG, testing-2);\n\t\toutw(iobase + MEM_PORT_REG, 0xdead);\n\t\toutw(iobase + HOST_ADDR_REG, testing-2);\n\t\tif (inw(iobase + MEM_PORT_REG) != 0xdead) {\n#ifdef IYMEMDEBUG\n\t\t\tprintf(\"%s: Didn't keep 0xdead at 0x%x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, testing-2);\n#endif\n\t\t\tcontinue;\n\t\t}\n\n\t\toutw(iobase + HOST_ADDR_REG, testing-2);\n\t\toutw(iobase + MEM_PORT_REG, 0xbeef);\n\t\toutw(iobase + HOST_ADDR_REG, testing-2);\n\t\tif (inw(iobase + MEM_PORT_REG) != 0xbeef) {\n#ifdef IYMEMDEBUG\n\t\t\tprintf(\"%s: Didn't keep 0xbeef at 0x%x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, testing-2);\n#endif\n\t\t\tcontinue;\n\t\t}\n\n\t\toutw(iobase + HOST_ADDR_REG, 0);\n\t\toutw(iobase + MEM_PORT_REG, 0);\n\t\toutw(iobase + HOST_ADDR_REG, testing >> 1);\n\t\toutw(iobase + MEM_PORT_REG, testing >> 1);\n\t\toutw(iobase + HOST_ADDR_REG, 0);\n\t\tif (inw(iobase + MEM_PORT_REG) == (testing >> 1)) {\n#ifdef IYMEMDEBUG\n\t\t\tprintf(\"%s: 0x%x alias of 0x0\\n\",\n\t\t\t    sc->sc_dev.dv_xname, testing >> 1);\n#endif\n\t\t\tcontinue;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tsc->sram = testing;\n\n\tswitch(testing) {\n\t\tcase 65536:\n\t\t\t/* 4 NFS packets + overhead RX, 2 NFS + overhead TX  */\n\t\t\tsc->rx_size = 44*1024;\n\t\t\tbreak;\n\n\t\tcase 32768:\n\t\t\t/* 2 NFS packets + overhead RX, 1 NFS + overhead TX  */\n\t\t\tsc->rx_size = 22*1024;\n\t\t\tbreak;\n\n\t\tcase 16384:\n\t\t\t/* 1 NFS packet + overhead RX, 4 big packets TX */\n\t\t\tsc->rx_size = 10*1024;\n\t\t\tbreak;\n\t\tdefault:\t\n\t\t\tsc->rx_size = testing/2;\n\t\t\tbreak;\n\t}\n\tsc->tx_size = testing - sc->rx_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "sc->sc_dev.dv_xname",
            "ifp->if_xname",
            "IFNAMSIZ"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82595reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid iywatchdog;\nint iyioctl;\nint iyintr;\nvoid iystart;\nvoid iyprobemem;\nvoid iyattach;\n\nvoid\niyattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct iy_softc *sc = (void *)self;\n\tstruct isa_attach_args *ia = aux;\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_start = iystart;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS;\n\t\t\t\t\t/* XXX todo: | IFF_MULTICAST */\n\tsc->sc_iobase = ia->ia_iobase;\n\n\tiyprobemem(sc);\n\n\tifp->if_ioctl = iyioctl;\n\tifp->if_watchdog = iywatchdog;\n\n\t/* Attach the interface. */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\tprintf(\": address %s, chip rev. %d, %d kB SRAM\\n\",\n\t    ether_sprintf(sc->sc_arpcom.ac_enaddr),\n\t    sc->hard_vers, sc->sram/1024);\n#if NBPFILTER > 0\n\tbpfattach(&sc->sc_arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,\n\t    sizeof(struct ether_header));\n#endif\n\n\tsc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE, \n\t    IPL_NET, iyintr, sc);\n}"
  },
  {
    "function_name": "iyprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_iy.c",
    "lines": "173-277",
    "snippet": "int\niyprobe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct iy_softc *sc = match;\n\tstruct isa_attach_args *ia = aux;\n\n\tu_int16_t eaddr[8];\n\tint iobase;\n\tint i;\n\n\tu_int16_t checksum = 0;\n\tu_int16_t eepromtmp;\n\tu_int8_t c, d;\n\n\t\n\tiobase = ia->ia_iobase;\n\n\tif (iobase == -1)\n\t\treturn 0;\n\n\t/* try to find the round robin sig: */\n\n\t/* check here for addresses already given to other devices */\n\n\tc = inb(iobase + ID_REG);\n\tif (c & ID_REG_MASK != ID_REG_SIG)\n\t\treturn 0;\n\n\td = inb(iobase + ID_REG);\n\tif (d & ID_REG_MASK != ID_REG_SIG)\n\t\treturn 0;\n\n\tif (((d-c) & R_ROBIN_BITS) != 0x40)\n\t\treturn 0;\n\t\t\n\td = inb(iobase + ID_REG);\n\tif (d & ID_REG_MASK != ID_REG_SIG)\n\t\treturn 0;\n\n\tif (((d-c) & R_ROBIN_BITS) != 0x80)\n\t\treturn 0;\n\t\t\n\td = inb(iobase + ID_REG);\n\tif (d & ID_REG_MASK != ID_REG_SIG)\n\t\treturn 0;\n\n\tif (((d-c) & R_ROBIN_BITS) != 0xC0)\n\t\treturn 0;\n\t\t\n\td = inb(iobase + ID_REG);\n\tif (d & ID_REG_MASK != ID_REG_SIG)\n\t\treturn 0;\n\n\tif (((d-c) & R_ROBIN_BITS) != 0x00)\n\t\treturn 0;\n\t\t\n#ifdef IYDEBUG\n\t\tprintf(\"eepro_probe verified working ID reg.\\n\");\n#endif\n\t\n\tfor (i=0; i<64; ++i) {\n\t\teepromtmp = eepromread(iobase, i);\n\t\tchecksum += eepromtmp;\n\t\tif (i<(sizeof(eaddr)/sizeof(*eaddr)))\n\t\t\teaddr[i] = eepromtmp;\n\t}\n\tif (checksum != EEPP_CHKSUM)\n\t\tprintf(\"wrong EEPROM checksum 0x%x should be 0x%x\\n\",\n\t\t    checksum, EEPP_CHKSUM);\n\t\t\n\t\n\tif ((eaddr[EEPPEther0] != eepromread(iobase, EEPPEther0a)) &&\n\t    (eaddr[EEPPEther1] != eepromread(iobase, EEPPEther1a)) &&\n\t    (eaddr[EEPPEther2] != eepromread(iobase, EEPPEther2a)))\n\t\tprintf(\"EEPROM Ethernet address differs from copy\\n\");\n\t\n        sc->sc_arpcom.ac_enaddr[1] = eaddr[EEPPEther0] & 0xFF;\n        sc->sc_arpcom.ac_enaddr[0] = eaddr[EEPPEther0] >> 8;\n        sc->sc_arpcom.ac_enaddr[3] = eaddr[EEPPEther1] & 0xFF;\n        sc->sc_arpcom.ac_enaddr[2] = eaddr[EEPPEther1] >> 8;\n        sc->sc_arpcom.ac_enaddr[5] = eaddr[EEPPEther2] & 0xFF;\n        sc->sc_arpcom.ac_enaddr[4] = eaddr[EEPPEther2] >> 8;\n\t\n\tif (ia->ia_irq == IRQUNK)\n\t\tia->ia_irq = eepro_irqmap[eaddr[EEPPW1] & EEPP_Int];\n\n\tif (ia->ia_irq >= sizeof(eepro_revirqmap))\n\t\treturn 0;\n\n\tif ((sc->mappedirq = eepro_revirqmap[ia->ia_irq]) == -1)\n\t\treturn 0;\n\n\tsc->hard_vers = eaddr[EEPW6] & EEPP_BoardRev;\n\n\t/* now lets reset the chip */\n\t\n\toutb(iobase + COMMAND_REG, RESET_CMD);\n\tdelay(200);\n\t\n       \tia->ia_iobase = iobase;\n       \tia->ia_iosize = 16;\n\treturn 1;\t\t/* found */\n}",
    "includes": [
      "#include <dev/ic/i82595reg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/isa/isareg.h>",
      "#include <machine/pio.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <net/route.h>",
      "#include <net/netisr.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/buf.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int eepro_probe",
      "int iyprobe",
      "static u_int16_t eepromread",
      "static u_int8_t eepro_irqmap[] = EEPP_INTMAP;",
      "static u_int8_t eepro_revirqmap[] = EEPP_RINTMAP;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "200"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "outb",
          "args": [
            "iobase + COMMAND_REG",
            "RESET_CMD"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_outbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1718-1740",
          "snippet": "void\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_outbits",
            "void ee16_eeprom_clock",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_outbits;\nvoid ee16_eeprom_clock;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nvoid\nee16_eeprom_outbits(sc, edata, count)\n\tstruct ie_softc *sc;\n\tint edata, count;\n{\n\tint ectrl, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tectrl &= ~IEE16_ECTRL_EEDI;\n\t\tif (edata & (1 << i)) {\n\t\t\tectrl |= IEE16_ECTRL_EEDI;\n\t\t}\n\t\toutb(PORT + IEE16_ECTRL, ectrl);\n\t\tdelay(1);\t/* eeprom data must be setup for 0.4 uSec */\n\t\tee16_eeprom_clock(sc, 1);\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\tectrl &= ~IEE16_ECTRL_EEDI;\n\toutb(PORT + IEE16_ECTRL, ectrl);\n\tdelay(1);\t\t/* eeprom data must be held for 0.4 uSec */\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"EEPROM Ethernet address differs from copy\\n\""
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "eepromread",
          "args": [
            "iobase",
            "EEPPEther2a"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "eepromread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_iy.c",
          "lines": "687-724",
          "snippet": "static u_int16_t\neepromread(io, offset)\n\tint io, offset;\n{\n\tvolatile int i;\n\tvolatile int j;\n\tvolatile u_int16_t readval;\n\tint eio = io+EEPROM_REG;\n\n\toutb(io, BANK_SEL(2));\n\tdelay(1);\n\toutb(io, EECS);\n\tdelay(1);\n\t\n\teepromwritebit(eio, EECS|EEDI);\n\teepromwritebit(eio, EECS|EEDI);\n\teepromwritebit(eio, EECS);\n\t\n\tfor (j=5; j>=0; --j) {\n\t\tif ((offset>>j) & 1) \n\t\t\teepromwritebit(eio, EECS|EEDI);\n\t\telse\n\t\t\teepromwritebit(eio, EECS);\n\t}\n\n\tfor (readval=0, i=0; i<16; ++i) {\n\t\treadval<<=1;\n\t\treadval |= eepromreadbit(eio);\n\t}\n\n\toutb(eio, 0|EESK);\n\tdelay(1);\n\toutb(eio, 0);\n\n\toutb(eio, BANK_SEL(0));\n\n\treturn readval;\n}",
          "includes": [
            "#include <dev/ic/i82595reg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static u_int16_t eepromread"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/i82595reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic u_int16_t eepromread;\n\nstatic u_int16_t\neepromread(io, offset)\n\tint io, offset;\n{\n\tvolatile int i;\n\tvolatile int j;\n\tvolatile u_int16_t readval;\n\tint eio = io+EEPROM_REG;\n\n\toutb(io, BANK_SEL(2));\n\tdelay(1);\n\toutb(io, EECS);\n\tdelay(1);\n\t\n\teepromwritebit(eio, EECS|EEDI);\n\teepromwritebit(eio, EECS|EEDI);\n\teepromwritebit(eio, EECS);\n\t\n\tfor (j=5; j>=0; --j) {\n\t\tif ((offset>>j) & 1) \n\t\t\teepromwritebit(eio, EECS|EEDI);\n\t\telse\n\t\t\teepromwritebit(eio, EECS);\n\t}\n\n\tfor (readval=0, i=0; i<16; ++i) {\n\t\treadval<<=1;\n\t\treadval |= eepromreadbit(eio);\n\t}\n\n\toutb(eio, 0|EESK);\n\tdelay(1);\n\toutb(eio, 0);\n\n\toutb(eio, BANK_SEL(0));\n\n\treturn readval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inb",
          "args": [
            "iobase + ID_REG"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "ee16_eeprom_inbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_ie.c",
          "lines": "1742-1760",
          "snippet": "int\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}",
          "includes": [
            "#include <dev/isa/elink.h>",
            "#include <dev/isa/if_iee16.h>",
            "#include <dev/isa/if_ie507.h>",
            "#include <dev/isa/if_ieatt.h>",
            "#include <dev/ic/i82586reg.h>",
            "#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/pio.h>\t\t/* XXX convert this driver! */",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define PORT\tsc->sc_iobase"
          ],
          "globals_used": [
            "void ee16_eeprom_clock",
            "int ee16_eeprom_inbits",
            "struct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/elink.h>\n#include <dev/isa/if_iee16.h>\n#include <dev/isa/if_ie507.h>\n#include <dev/isa/if_ieatt.h>\n#include <dev/ic/i82586reg.h>\n#include <i386/isa/isa_machdep.h>\t/* XXX USES ISA HOLE DIRECTLY */\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/pio.h>\t\t/* XXX convert this driver! */\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define PORT\tsc->sc_iobase\n\nvoid ee16_eeprom_clock;\nint ee16_eeprom_inbits;\nstruct mbuf *\nieget(sc, ehp, to_bpf)\n\tstruct ie_softc *sc;\n\nint\nee16_eeprom_inbits(sc)\n\tstruct ie_softc *sc;\n{\n\tint ectrl, edata, i;\n\n\tectrl = inb(PORT + IEE16_ECTRL);\n\tectrl &= ~IEE16_RESET_ASIC;\n\tfor (edata = 0, i = 0; i < 16; i++) {\n\t\tedata = edata << 1;\n\t\tee16_eeprom_clock(sc, 1);\n\t\tectrl = inb(PORT + IEE16_ECTRL);\n\t\tif (ectrl & IEE16_ECTRL_EEDO) {\n\t\t\tedata |= 1;\n\t\t}\n\t\tee16_eeprom_clock(sc, 0);\n\t}\n\treturn (edata);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/i82595reg.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint eepro_probe;\nint iyprobe;\nstatic u_int16_t eepromread;\nstatic u_int8_t eepro_irqmap[] = EEPP_INTMAP;\nstatic u_int8_t eepro_revirqmap[] = EEPP_RINTMAP;\n\nint\niyprobe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct iy_softc *sc = match;\n\tstruct isa_attach_args *ia = aux;\n\n\tu_int16_t eaddr[8];\n\tint iobase;\n\tint i;\n\n\tu_int16_t checksum = 0;\n\tu_int16_t eepromtmp;\n\tu_int8_t c, d;\n\n\t\n\tiobase = ia->ia_iobase;\n\n\tif (iobase == -1)\n\t\treturn 0;\n\n\t/* try to find the round robin sig: */\n\n\t/* check here for addresses already given to other devices */\n\n\tc = inb(iobase + ID_REG);\n\tif (c & ID_REG_MASK != ID_REG_SIG)\n\t\treturn 0;\n\n\td = inb(iobase + ID_REG);\n\tif (d & ID_REG_MASK != ID_REG_SIG)\n\t\treturn 0;\n\n\tif (((d-c) & R_ROBIN_BITS) != 0x40)\n\t\treturn 0;\n\t\t\n\td = inb(iobase + ID_REG);\n\tif (d & ID_REG_MASK != ID_REG_SIG)\n\t\treturn 0;\n\n\tif (((d-c) & R_ROBIN_BITS) != 0x80)\n\t\treturn 0;\n\t\t\n\td = inb(iobase + ID_REG);\n\tif (d & ID_REG_MASK != ID_REG_SIG)\n\t\treturn 0;\n\n\tif (((d-c) & R_ROBIN_BITS) != 0xC0)\n\t\treturn 0;\n\t\t\n\td = inb(iobase + ID_REG);\n\tif (d & ID_REG_MASK != ID_REG_SIG)\n\t\treturn 0;\n\n\tif (((d-c) & R_ROBIN_BITS) != 0x00)\n\t\treturn 0;\n\t\t\n#ifdef IYDEBUG\n\t\tprintf(\"eepro_probe verified working ID reg.\\n\");\n#endif\n\t\n\tfor (i=0; i<64; ++i) {\n\t\teepromtmp = eepromread(iobase, i);\n\t\tchecksum += eepromtmp;\n\t\tif (i<(sizeof(eaddr)/sizeof(*eaddr)))\n\t\t\teaddr[i] = eepromtmp;\n\t}\n\tif (checksum != EEPP_CHKSUM)\n\t\tprintf(\"wrong EEPROM checksum 0x%x should be 0x%x\\n\",\n\t\t    checksum, EEPP_CHKSUM);\n\t\t\n\t\n\tif ((eaddr[EEPPEther0] != eepromread(iobase, EEPPEther0a)) &&\n\t    (eaddr[EEPPEther1] != eepromread(iobase, EEPPEther1a)) &&\n\t    (eaddr[EEPPEther2] != eepromread(iobase, EEPPEther2a)))\n\t\tprintf(\"EEPROM Ethernet address differs from copy\\n\");\n\t\n        sc->sc_arpcom.ac_enaddr[1] = eaddr[EEPPEther0] & 0xFF;\n        sc->sc_arpcom.ac_enaddr[0] = eaddr[EEPPEther0] >> 8;\n        sc->sc_arpcom.ac_enaddr[3] = eaddr[EEPPEther1] & 0xFF;\n        sc->sc_arpcom.ac_enaddr[2] = eaddr[EEPPEther1] >> 8;\n        sc->sc_arpcom.ac_enaddr[5] = eaddr[EEPPEther2] & 0xFF;\n        sc->sc_arpcom.ac_enaddr[4] = eaddr[EEPPEther2] >> 8;\n\t\n\tif (ia->ia_irq == IRQUNK)\n\t\tia->ia_irq = eepro_irqmap[eaddr[EEPPW1] & EEPP_Int];\n\n\tif (ia->ia_irq >= sizeof(eepro_revirqmap))\n\t\treturn 0;\n\n\tif ((sc->mappedirq = eepro_revirqmap[ia->ia_irq]) == -1)\n\t\treturn 0;\n\n\tsc->hard_vers = eaddr[EEPW6] & EEPP_BoardRev;\n\n\t/* now lets reset the chip */\n\t\n\toutb(iobase + COMMAND_REG, RESET_CMD);\n\tdelay(200);\n\t\n       \tia->ia_iobase = iobase;\n       \tia->ia_iosize = 16;\n\treturn 1;\t\t/* found */\n}"
  }
]