[
  {
    "function_name": "rln_isa_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_rln_isa.c",
    "lines": "100-146",
    "snippet": "static void\nrln_isa_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct rln_softc *sc = (void *)self;\n\tstruct isa_attach_args *ia = aux;\n\tint irq = ia->ia_irq;\n\tint mask;\n\tint i;\n\n\tif (irq == IRQUNK) {\n\t\t/* Allocate a valid IRQ. */\n\t\tmask = 0;\n\t\tfor (i = 0; i < NRLN_IRQ; i++)\n\t\t\tmask |= (1 << rln_irq[i]);\n\t\tif (isa_intr_alloc(ia->ia_ic, mask, IST_EDGE, &irq))\n\t\t\tpanic(\"rln_isa_attach: can't allocate irq\");\n\t} \n#ifdef DIAGNOSTIC\n\telse {\n\t\t/* Check given IRQ is valid. */\n\t\tfor (i = 0; i < NRLN_IRQ; i++)\n\t\t\tif (irq == rln_irq[i])\n\t\t\t\tbreak;\n\t\tif (i == NRLN_IRQ)\n\t\t\tprintf(\"rln_isa_probe: using invalid irq %d\\n\", irq);\n\t}\n#endif\n\n\tprintf(\":\");\n\n\tsc->sc_ih = isa_intr_establish(ia->ia_ic, irq, IST_EDGE,\n\t    IPL_NET, rlnintr, sc, sc->sc_dev.dv_xname);\n#ifdef DIAGNOSTIC\n\tif (sc->sc_ih == NULL)\n\t\tpanic(\"rln_isa_attach: couldn't establish interrupt\");\n#endif\n\n\t/* Tell the card which IRQ to use. */\n\tsc->sc_irq = irq;\n\tsc->sc_width = 0;\t/* re-probe width */\n\n\tprintf(\"%s: RangeLAN2 7100\", sc->sc_dev.dv_xname);\n\trlnconfig(sc);\n\tprintf(\"\\n\");\n}",
    "includes": [
      "#include <dev/isa/isavar.h>",
      "#include <dev/ic/rlnreg.h>",
      "#include <dev/ic/rlnvar.h>",
      "#include <dev/ic/rln.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define NRLN_IRQ\t(sizeof(rln_irq) / sizeof(rln_irq[0]))"
    ],
    "globals_used": [
      "static int rln_isa_probe",
      "static void rln_isa_attach",
      "static const int rln_irq[] = {\n\t3, 4, 5, 7, 10, 11, 12, 15\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rlnconfig",
          "args": [
            "sc"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "rlnconfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rln.c",
          "lines": "82-149",
          "snippet": "void\nrlnconfig(sc)\n\tstruct rln_softc * sc;\n{\n\tstruct ifnet *\tifp = &sc->sc_arpcom.ac_if;\n\tchar\t\tpromvers[7];\n\tint\t\ti;\n\n\tdprintf(\" [attach %p]\", sc);\n\n\t/* Use the flags supplied from config. */\n\tsc->sc_cardtype |= sc->sc_dev.dv_cfdata->cf_flags;\n\n\t/* Initialise values in the soft state. */\n\tsc->sc_pktseq = 0;\t/* rln_newseq() */\n\tsc->sc_txseq = 0;\n\tsc->sc_state = 0;\n\n\t/* Initialise user-configurable params. */\n\tsc->sc_param.rp_roam_config = RLN_ROAM_NORMAL;\n\tsc->sc_param.rp_security = RLN_SECURITY_DEFAULT;\n\tsc->sc_param.rp_station_type = RLN_STATIONTYPE_ALTMASTER;\n\tsc->sc_param.rp_domain = 0;\n\tsc->sc_param.rp_channel = 1;\n\tsc->sc_param.rp_subchannel = 1;\n\n\tbzero(sc->sc_param.rp_master, sizeof sc->sc_param.rp_master);\n\n\t/* Initialise the message mailboxes. */\n\tfor (i = 0; i < RLN_NMBOX; i++)\n\t\tsc->sc_mbox[i].mb_state = RLNMBOX_VOID;\n\n\t/* Probe for some properties. */\n\tprintf(\", %s-piece\", \n\t    (sc->sc_cardtype & RLN_CTYPE_ONE_PIECE) ? \"one\" : \"two\");\n\tif (sc->sc_cardtype & RLN_CTYPE_OEM)\n\t\tprintf(\" oem\");\n\tif (sc->sc_cardtype & RLN_CTYPE_UISA)\n\t\tprintf(\" micro-isa\");\n\n\t/* Read the card's PROM revision. */\n\tif (rln_getpromvers(sc, promvers, sizeof promvers)) {\n\t\tprintf(\": could not read PROM version\\n\");\n\t\treturn;\n\t}\n\tprintf(\", fw %.7s\", promvers);\n\n\t/* Fetch the card's MAC address. */\n\tif (rln_getenaddr(sc, sc->sc_arpcom.ac_enaddr)) {\n\t\tprintf(\": could not read MAC address\\n\");\n\t\treturn;\n\t}\n\tprintf(\", addr %s\", ether_sprintf(sc->sc_arpcom.ac_enaddr));\n\n\t/* Attach as a network interface. */\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_start = rlnstart;\n\tifp->if_ioctl = rlnioctl;\n\tifp->if_watchdog = rlnwatchdog;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS;\n\tifp->if_snd.ifq_maxlen = IFQ_MAXLEN;\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n#if NBPFILTER > 0\n\tbpfattach(&ifp->if_bpf, ifp, DLT_EN10MB, sizeof (struct ether_header));\n#endif\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\trlnstart",
            "void\trlnwatchdog",
            "int\trlnioctl",
            "int\trln_getenaddr",
            "int\trln_getpromvers",
            "struct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\trlnstart;\nvoid\trlnwatchdog;\nint\trlnioctl;\nint\trln_getenaddr;\nint\trln_getpromvers;\nstruct mbuf *\nrlnget(sc, hdr, totlen)\n\tstruct rln_softc *sc;\n\nvoid\nrlnconfig(sc)\n\tstruct rln_softc * sc;\n{\n\tstruct ifnet *\tifp = &sc->sc_arpcom.ac_if;\n\tchar\t\tpromvers[7];\n\tint\t\ti;\n\n\tdprintf(\" [attach %p]\", sc);\n\n\t/* Use the flags supplied from config. */\n\tsc->sc_cardtype |= sc->sc_dev.dv_cfdata->cf_flags;\n\n\t/* Initialise values in the soft state. */\n\tsc->sc_pktseq = 0;\t/* rln_newseq() */\n\tsc->sc_txseq = 0;\n\tsc->sc_state = 0;\n\n\t/* Initialise user-configurable params. */\n\tsc->sc_param.rp_roam_config = RLN_ROAM_NORMAL;\n\tsc->sc_param.rp_security = RLN_SECURITY_DEFAULT;\n\tsc->sc_param.rp_station_type = RLN_STATIONTYPE_ALTMASTER;\n\tsc->sc_param.rp_domain = 0;\n\tsc->sc_param.rp_channel = 1;\n\tsc->sc_param.rp_subchannel = 1;\n\n\tbzero(sc->sc_param.rp_master, sizeof sc->sc_param.rp_master);\n\n\t/* Initialise the message mailboxes. */\n\tfor (i = 0; i < RLN_NMBOX; i++)\n\t\tsc->sc_mbox[i].mb_state = RLNMBOX_VOID;\n\n\t/* Probe for some properties. */\n\tprintf(\", %s-piece\", \n\t    (sc->sc_cardtype & RLN_CTYPE_ONE_PIECE) ? \"one\" : \"two\");\n\tif (sc->sc_cardtype & RLN_CTYPE_OEM)\n\t\tprintf(\" oem\");\n\tif (sc->sc_cardtype & RLN_CTYPE_UISA)\n\t\tprintf(\" micro-isa\");\n\n\t/* Read the card's PROM revision. */\n\tif (rln_getpromvers(sc, promvers, sizeof promvers)) {\n\t\tprintf(\": could not read PROM version\\n\");\n\t\treturn;\n\t}\n\tprintf(\", fw %.7s\", promvers);\n\n\t/* Fetch the card's MAC address. */\n\tif (rln_getenaddr(sc, sc->sc_arpcom.ac_enaddr)) {\n\t\tprintf(\": could not read MAC address\\n\");\n\t\treturn;\n\t}\n\tprintf(\", addr %s\", ether_sprintf(sc->sc_arpcom.ac_enaddr));\n\n\t/* Attach as a network interface. */\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_start = rlnstart;\n\tifp->if_ioctl = rlnioctl;\n\tifp->if_watchdog = rlnwatchdog;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS;\n\tifp->if_snd.ifq_maxlen = IFQ_MAXLEN;\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n#if NBPFILTER > 0\n\tbpfattach(&ifp->if_bpf, ifp, DLT_EN10MB, sizeof (struct ether_header));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"rln_isa_attach: couldn't establish interrupt\""
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isa_intr_establish",
          "args": [
            "ia->ia_ic",
            "irq",
            "IST_EDGE",
            "IPL_NET",
            "rlnintr",
            "sc",
            "sc->sc_dev.dv_xname"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"rln_isa_attach: can't allocate irq\""
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isa_intr_alloc",
          "args": [
            "ia->ia_ic",
            "mask",
            "IST_EDGE",
            "&irq"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/isavar.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define NRLN_IRQ\t(sizeof(rln_irq) / sizeof(rln_irq[0]))\n\nstatic int rln_isa_probe;\nstatic void rln_isa_attach;\nstatic const int rln_irq[] = {\n\t3, 4, 5, 7, 10, 11, 12, 15\n};\n\nstatic void\nrln_isa_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct rln_softc *sc = (void *)self;\n\tstruct isa_attach_args *ia = aux;\n\tint irq = ia->ia_irq;\n\tint mask;\n\tint i;\n\n\tif (irq == IRQUNK) {\n\t\t/* Allocate a valid IRQ. */\n\t\tmask = 0;\n\t\tfor (i = 0; i < NRLN_IRQ; i++)\n\t\t\tmask |= (1 << rln_irq[i]);\n\t\tif (isa_intr_alloc(ia->ia_ic, mask, IST_EDGE, &irq))\n\t\t\tpanic(\"rln_isa_attach: can't allocate irq\");\n\t} \n#ifdef DIAGNOSTIC\n\telse {\n\t\t/* Check given IRQ is valid. */\n\t\tfor (i = 0; i < NRLN_IRQ; i++)\n\t\t\tif (irq == rln_irq[i])\n\t\t\t\tbreak;\n\t\tif (i == NRLN_IRQ)\n\t\t\tprintf(\"rln_isa_probe: using invalid irq %d\\n\", irq);\n\t}\n#endif\n\n\tprintf(\":\");\n\n\tsc->sc_ih = isa_intr_establish(ia->ia_ic, irq, IST_EDGE,\n\t    IPL_NET, rlnintr, sc, sc->sc_dev.dv_xname);\n#ifdef DIAGNOSTIC\n\tif (sc->sc_ih == NULL)\n\t\tpanic(\"rln_isa_attach: couldn't establish interrupt\");\n#endif\n\n\t/* Tell the card which IRQ to use. */\n\tsc->sc_irq = irq;\n\tsc->sc_width = 0;\t/* re-probe width */\n\n\tprintf(\"%s: RangeLAN2 7100\", sc->sc_dev.dv_xname);\n\trlnconfig(sc);\n\tprintf(\"\\n\");\n}"
  },
  {
    "function_name": "rln_isa_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_rln_isa.c",
    "lines": "69-98",
    "snippet": "static int\nrln_isa_probe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct isa_attach_args *ia = aux;\n\tstruct rln_softc *sc = match;\n\n\t/*\n\t * The i/o base addr is set by the dip switches\n\t * and must be specified in the kernel config.\n\t */\n\tif (ia->ia_iobase == IOBASEUNK)\n\t\treturn (0);\n\n\t/* Attempt a card reset through the io ports */\n\tsc->sc_iot = ia->ia_iot;\n\tsc->sc_width = 0;\t/* Force width probe */\n\tif (bus_space_map(sc->sc_iot, ia->ia_iobase, RLN_NPORTS, 0, \n\t    &sc->sc_ioh))\n\t\treturn (0);\n\n\tif (rln_reset(sc)) {\n\t\tbus_space_unmap(sc->sc_iot, sc->sc_ioh, RLN_NPORTS);\n\t\treturn (0);\n\t}\n\n\tia->ia_iosize = RLN_NPORTS;\n\treturn (1);\n}",
    "includes": [
      "#include <dev/isa/isavar.h>",
      "#include <dev/ic/rlnreg.h>",
      "#include <dev/ic/rlnvar.h>",
      "#include <dev/ic/rln.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/in.h>",
      "#include <net/if.h>",
      "#include <sys/queue.h>",
      "#include <sys/device.h>",
      "#include <sys/socket.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int rln_isa_probe"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "sc->sc_iot",
            "sc->sc_ioh",
            "RLN_NPORTS"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rln_reset",
          "args": [
            "sc"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "rln_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/rlnsubr.c",
          "lines": "77-163",
          "snippet": "int\nrln_reset(sc)\n\tstruct rln_softc * sc;\n{\n\tint\t\ts;\n\tint\t\ti;\n\tint\t\tstatus;\n\tu_int8_t\top = 0x00;\n\n\ts = splhigh();\n\tdprintf(\" R[\");\n\tif (sc->sc_cardtype & (RLN_CTYPE_UISA | RLN_CTYPE_ONE_PIECE))\n\t\top = 0x04;\n\tif (rln_status_read(sc) & RLN_STATUS_WAKEUP) {\n\t\trln_control_write(sc, op);\n\t\trln_control_write(sc, op | RLN_CONTROL_RESET);\n\t\tdprintf(\" 7ms\");\n\t\tDELAY(7000);\n\t\trln_control_write(sc, op);\n\t\tdprintf(\" 7ms\");\n\t\tDELAY(7000);\n\t}\n\trln_control_write(sc, op);\n\trln_control_write(sc, op);\n\trln_control_write(sc, op | RLN_CONTROL_BIT3);\n\tdprintf(\" 67ms\");\n\tDELAY(67000);\n\trln_status_write(sc, 0x00);\n\tif (sc->sc_cardtype & (RLN_CTYPE_UISA | RLN_CTYPE_ONE_PIECE))\n\t\trln_control_write(sc, 0x38); \n\t\t/* RLN_CONTROL_BIT3 | RLN_CONTROL_RESET | RLN_CONTROL_16BIT */\n\telse\n\t\trln_control_write(sc, 0x2c);\n\t\t/* RLN_CONTROL_BIT3 | RLN_CONTROL_BIT2  | RLN_CONTROL_16BIT */\n\tdprintf(\" 67ms\");\n\tDELAY(67000);\n\trln_data_write_2(sc, 0xaa55);\n\trln_status_write(sc, 0x5a);\n\tsplx(s);\n\tfor (i = 0; i < 200 * 10; i++) {\t/* Proxim says 200. */\n\t\tif ((status = rln_status_read(sc)) == 0x5a)\n\t\t\tbreak;\n\t\tDELAY(1000);\n\t}\n\tdprintf(\" (%dms)\", i);\n\ts = splhigh();\n\tif (status != 0x5a) {\n\t\tsplx(s);\n\t\t/* Only winge if bus width not yet probed */\n\t\tif (sc->sc_width != 0)\n\t\t\tprintf(\"%s: reset timeout\\n\", sc->sc_dev.dv_xname);\n\t\tdprintf(\"]=-1\");\n\t\treturn (-1);\n\t}\n\tif (sc->sc_width == 8) {\n\t\tif (sc->sc_cardtype & (RLN_CTYPE_UISA | RLN_CTYPE_ONE_PIECE))\n\t\t\trln_control_write(sc, RLN_CONTROL_BIT3);\n\t\telse\n\t\t\trln_control_write(sc, RLN_CONTROL_BIT3 | \n\t\t\t    RLN_CONTROL_BIT2);\n\t\trln_data_write_1(sc, 0x20);\n\t} else if (sc->sc_width == 16) {\n\t\trln_data_write_2(sc, 0x0000);\n\t} else {\n\t\tif (rln_data_read_2(sc) == 0x55aa) {\n\t\t\trln_data_write_2(sc, 0x0000);\n\t\t\tsc->sc_width = 16;\n\t\t} else {\n\t\t\tif (sc->sc_cardtype & (RLN_CTYPE_UISA | \n\t\t\t    RLN_CTYPE_ONE_PIECE))\n\t\t\t\trln_control_write(sc, RLN_CONTROL_BIT3);\n\t\t\telse\n\t\t\t\trln_control_write(sc, RLN_CONTROL_BIT3 | \n\t\t\t\t    RLN_CONTROL_BIT2);\n\t\t\trln_data_write_1(sc, 0x20);\n\t\t\tsc->sc_width = 8;\n\t\t}\n\t\t/* printf(\"%s: %d bit bus\\n\", sc->sc_dev.dv_xname, \n\t\t   sc->sc_width); */\n\t}\n\trln_status_write(sc, 0x00);\n\tsc->sc_intsel = 0;\n\trln_intsel_write(sc, sc->sc_irq);\n\tsplx(s);\n\tdprintf(\"]\");\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/rlncmd.h>",
            "#include <dev/ic/rlnreg.h>",
            "#include <dev/ic/rlnvar.h>",
            "#include <dev/ic/rln.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/rlncmd.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nrln_reset(sc)\n\tstruct rln_softc * sc;\n{\n\tint\t\ts;\n\tint\t\ti;\n\tint\t\tstatus;\n\tu_int8_t\top = 0x00;\n\n\ts = splhigh();\n\tdprintf(\" R[\");\n\tif (sc->sc_cardtype & (RLN_CTYPE_UISA | RLN_CTYPE_ONE_PIECE))\n\t\top = 0x04;\n\tif (rln_status_read(sc) & RLN_STATUS_WAKEUP) {\n\t\trln_control_write(sc, op);\n\t\trln_control_write(sc, op | RLN_CONTROL_RESET);\n\t\tdprintf(\" 7ms\");\n\t\tDELAY(7000);\n\t\trln_control_write(sc, op);\n\t\tdprintf(\" 7ms\");\n\t\tDELAY(7000);\n\t}\n\trln_control_write(sc, op);\n\trln_control_write(sc, op);\n\trln_control_write(sc, op | RLN_CONTROL_BIT3);\n\tdprintf(\" 67ms\");\n\tDELAY(67000);\n\trln_status_write(sc, 0x00);\n\tif (sc->sc_cardtype & (RLN_CTYPE_UISA | RLN_CTYPE_ONE_PIECE))\n\t\trln_control_write(sc, 0x38); \n\t\t/* RLN_CONTROL_BIT3 | RLN_CONTROL_RESET | RLN_CONTROL_16BIT */\n\telse\n\t\trln_control_write(sc, 0x2c);\n\t\t/* RLN_CONTROL_BIT3 | RLN_CONTROL_BIT2  | RLN_CONTROL_16BIT */\n\tdprintf(\" 67ms\");\n\tDELAY(67000);\n\trln_data_write_2(sc, 0xaa55);\n\trln_status_write(sc, 0x5a);\n\tsplx(s);\n\tfor (i = 0; i < 200 * 10; i++) {\t/* Proxim says 200. */\n\t\tif ((status = rln_status_read(sc)) == 0x5a)\n\t\t\tbreak;\n\t\tDELAY(1000);\n\t}\n\tdprintf(\" (%dms)\", i);\n\ts = splhigh();\n\tif (status != 0x5a) {\n\t\tsplx(s);\n\t\t/* Only winge if bus width not yet probed */\n\t\tif (sc->sc_width != 0)\n\t\t\tprintf(\"%s: reset timeout\\n\", sc->sc_dev.dv_xname);\n\t\tdprintf(\"]=-1\");\n\t\treturn (-1);\n\t}\n\tif (sc->sc_width == 8) {\n\t\tif (sc->sc_cardtype & (RLN_CTYPE_UISA | RLN_CTYPE_ONE_PIECE))\n\t\t\trln_control_write(sc, RLN_CONTROL_BIT3);\n\t\telse\n\t\t\trln_control_write(sc, RLN_CONTROL_BIT3 | \n\t\t\t    RLN_CONTROL_BIT2);\n\t\trln_data_write_1(sc, 0x20);\n\t} else if (sc->sc_width == 16) {\n\t\trln_data_write_2(sc, 0x0000);\n\t} else {\n\t\tif (rln_data_read_2(sc) == 0x55aa) {\n\t\t\trln_data_write_2(sc, 0x0000);\n\t\t\tsc->sc_width = 16;\n\t\t} else {\n\t\t\tif (sc->sc_cardtype & (RLN_CTYPE_UISA | \n\t\t\t    RLN_CTYPE_ONE_PIECE))\n\t\t\t\trln_control_write(sc, RLN_CONTROL_BIT3);\n\t\t\telse\n\t\t\t\trln_control_write(sc, RLN_CONTROL_BIT3 | \n\t\t\t\t    RLN_CONTROL_BIT2);\n\t\t\trln_data_write_1(sc, 0x20);\n\t\t\tsc->sc_width = 8;\n\t\t}\n\t\t/* printf(\"%s: %d bit bus\\n\", sc->sc_dev.dv_xname, \n\t\t   sc->sc_width); */\n\t}\n\trln_status_write(sc, 0x00);\n\tsc->sc_intsel = 0;\n\trln_intsel_write(sc, sc->sc_irq);\n\tsplx(s);\n\tdprintf(\"]\");\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "sc->sc_iot",
            "ia->ia_iobase",
            "RLN_NPORTS",
            "0",
            "&sc->sc_ioh"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/isavar.h>\n#include <dev/ic/rlnreg.h>\n#include <dev/ic/rlnvar.h>\n#include <dev/ic/rln.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic int rln_isa_probe;\n\nstatic int\nrln_isa_probe(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct isa_attach_args *ia = aux;\n\tstruct rln_softc *sc = match;\n\n\t/*\n\t * The i/o base addr is set by the dip switches\n\t * and must be specified in the kernel config.\n\t */\n\tif (ia->ia_iobase == IOBASEUNK)\n\t\treturn (0);\n\n\t/* Attempt a card reset through the io ports */\n\tsc->sc_iot = ia->ia_iot;\n\tsc->sc_width = 0;\t/* Force width probe */\n\tif (bus_space_map(sc->sc_iot, ia->ia_iobase, RLN_NPORTS, 0, \n\t    &sc->sc_ioh))\n\t\treturn (0);\n\n\tif (rln_reset(sc)) {\n\t\tbus_space_unmap(sc->sc_iot, sc->sc_ioh, RLN_NPORTS);\n\t\treturn (0);\n\t}\n\n\tia->ia_iosize = RLN_NPORTS;\n\treturn (1);\n}"
  }
]