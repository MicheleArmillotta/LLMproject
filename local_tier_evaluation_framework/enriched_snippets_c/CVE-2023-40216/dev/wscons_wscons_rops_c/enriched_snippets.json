[
  {
    "function_name": "rcons_alloc_attr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wscons_rops.c",
    "lines": "245-259",
    "snippet": "int\nrcons_alloc_attr(id, fg, bg, flags, attrp)\n\tvoid *id;\n\tint fg, bg, flags;\n\tlong *attrp;\n{\n\tif (flags & (WSATTR_HILIT | WSATTR_BLINK |\n\t\t     WSATTR_UNDERLINE | WSATTR_WSCOLORS))\n\t\treturn (EINVAL);\n\tif (flags & WSATTR_REVERSE)\n\t\t*attrp = 1;\n\telse\n\t\t*attrp = 0;\n\treturn (0);\n}",
    "includes": [
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wscons_raster.h>",
      "#include <dev/rcons/raster.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wscons_raster.h>\n#include <dev/rcons/raster.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nint\nrcons_alloc_attr(id, fg, bg, flags, attrp)\n\tvoid *id;\n\tint fg, bg, flags;\n\tlong *attrp;\n{\n\tif (flags & (WSATTR_HILIT | WSATTR_BLINK |\n\t\t     WSATTR_UNDERLINE | WSATTR_WSCOLORS))\n\t\treturn (EINVAL);\n\tif (flags & WSATTR_REVERSE)\n\t\t*attrp = 1;\n\telse\n\t\t*attrp = 0;\n\treturn (0);\n}"
  },
  {
    "function_name": "rcons_eraserows",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wscons_rops.c",
    "lines": "225-243",
    "snippet": "void\nrcons_eraserows(id, startrow, nrows, fillattr)\n\tvoid *id;\n\tint startrow, nrows;\n\tlong fillattr;\n{\n\tstruct rcons *rc = id;\n\tint starty, ny, op;\n\n\tstarty = rc->rc_yorigin + rc->rc_font->height * startrow;\n\tny = rc->rc_font->height * nrows;\n\n\top = RAS_CLEAR;\n\tif ((fillattr != 0) ^ ((rc->rc_bits & RC_INVERT) != 0))\n\t\top = RAS_NOT(op);\n\traster_op(rc->rc_sp, rc->rc_xorigin, starty,\n\t    rc->rc_raswidth, ny, op,\n\t    (struct raster *) 0, 0, 0);\n}",
    "includes": [
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wscons_raster.h>",
      "#include <dev/rcons/raster.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raster_op",
          "args": [
            "rc->rc_sp",
            "rc->rc_xorigin",
            "starty",
            "rc->rc_raswidth",
            "ny",
            "op",
            "(struct raster *) 0",
            "0",
            "0"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "raster_op_nosrc_noclip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/raster_op.c",
          "lines": "759-860",
          "snippet": "int\nraster_op_nosrc_noclip( dst, dx, dy, w, h, rop )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( dst->depth == 1 )\n\t{\n\t/* One-bit no-src blit. */\n\tu_int32_t* dstlin1;\n\tu_int32_t* dstlin2;\n\tu_int32_t* dstlin;\n\tint dstleftignore, dstrightignore, dstlongs;\n\tu_int32_t dl, lm, nlm, rm, nrm;\n\tregister u_int32_t* dstlong2;\n\tregister u_int32_t* dstlong;\n\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width clears. */\n\tif ( op == RAS_CLEAR && dst->width == w && dst->linelongs == w >> 5 )\n\t    {\n\t    bzero( (char*) dstlin1, h * dst->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tdstleftignore = ( dx & 31 );\n\tdstlongs = ( dstleftignore + w + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\tdstlin2 = dstlin1 + h * dst->linelongs;\n\tdstlin = dstlin1;\n\n\tif ( dstlongs == 1 )\n\t    {\n\t    /* It fits into a single longword. */\n\t    lm = leftmask[dstleftignore] | rightmask[dstrightignore];\n\t    nlm = ~lm;\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ dl = *dstlin;,\n\t\t/*d*/   dl,\n\t\t/*pst*/ *dstlin = ( *dstlin & lm ) | ( dl & nlm ); )\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\telse\n\t    {\n\t    lm = leftmask[dstleftignore];\n\t    rm = rightmask[dstrightignore];\n\t    nrm = ~rm;\n\t    nlm = ~lm;\n\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tdstlong = dstlin;\n\t\tdstlong2 = dstlong + dstlongs;\n\t\tif ( dstrightignore != 0 )\n\t\t    --dstlong2;\n\n\t\t/* Leading edge. */\n\t\tif ( dstleftignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t    ++dstlong;\n\t\t    }\n\n\t\t/* Main rop. */\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( dstlong != dstlong2 )\n\t\t\t    {,\n\t\t/*d*/       *dstlong,\n\t\t/*pst*/     ++dstlong;\n\t\t\t    } )\n\n\t\t/* Trailing edge. */\n\t\tif ( dstrightignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t    }\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}",
          "includes": [
            "#include \"raster.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"raster.h\"\n#include <dev/rcons/raster.h>\n#include <sys/types.h>\n\nint\nraster_op_nosrc_noclip( dst, dx, dy, w, h, rop )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( dst->depth == 1 )\n\t{\n\t/* One-bit no-src blit. */\n\tu_int32_t* dstlin1;\n\tu_int32_t* dstlin2;\n\tu_int32_t* dstlin;\n\tint dstleftignore, dstrightignore, dstlongs;\n\tu_int32_t dl, lm, nlm, rm, nrm;\n\tregister u_int32_t* dstlong2;\n\tregister u_int32_t* dstlong;\n\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width clears. */\n\tif ( op == RAS_CLEAR && dst->width == w && dst->linelongs == w >> 5 )\n\t    {\n\t    bzero( (char*) dstlin1, h * dst->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tdstleftignore = ( dx & 31 );\n\tdstlongs = ( dstleftignore + w + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\tdstlin2 = dstlin1 + h * dst->linelongs;\n\tdstlin = dstlin1;\n\n\tif ( dstlongs == 1 )\n\t    {\n\t    /* It fits into a single longword. */\n\t    lm = leftmask[dstleftignore] | rightmask[dstrightignore];\n\t    nlm = ~lm;\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ dl = *dstlin;,\n\t\t/*d*/   dl,\n\t\t/*pst*/ *dstlin = ( *dstlin & lm ) | ( dl & nlm ); )\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\telse\n\t    {\n\t    lm = leftmask[dstleftignore];\n\t    rm = rightmask[dstrightignore];\n\t    nrm = ~rm;\n\t    nlm = ~lm;\n\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tdstlong = dstlin;\n\t\tdstlong2 = dstlong + dstlongs;\n\t\tif ( dstrightignore != 0 )\n\t\t    --dstlong2;\n\n\t\t/* Leading edge. */\n\t\tif ( dstleftignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t    ++dstlong;\n\t\t    }\n\n\t\t/* Main rop. */\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( dstlong != dstlong2 )\n\t\t\t    {,\n\t\t/*d*/       *dstlong,\n\t\t/*pst*/     ++dstlong;\n\t\t\t    } )\n\n\t\t/* Trailing edge. */\n\t\tif ( dstrightignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t    }\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}"
        }
      },
      {
        "call_info": {
          "callee": "RAS_NOT",
          "args": [
            "op"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wscons_raster.h>\n#include <dev/rcons/raster.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nvoid\nrcons_eraserows(id, startrow, nrows, fillattr)\n\tvoid *id;\n\tint startrow, nrows;\n\tlong fillattr;\n{\n\tstruct rcons *rc = id;\n\tint starty, ny, op;\n\n\tstarty = rc->rc_yorigin + rc->rc_font->height * startrow;\n\tny = rc->rc_font->height * nrows;\n\n\top = RAS_CLEAR;\n\tif ((fillattr != 0) ^ ((rc->rc_bits & RC_INVERT) != 0))\n\t\top = RAS_NOT(op);\n\traster_op(rc->rc_sp, rc->rc_xorigin, starty,\n\t    rc->rc_raswidth, ny, op,\n\t    (struct raster *) 0, 0, 0);\n}"
  },
  {
    "function_name": "rcons_copyrows",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wscons_rops.c",
    "lines": "205-220",
    "snippet": "void\nrcons_copyrows(id, srcrow, dstrow, nrows)\n\tvoid *id;\n\tint srcrow, dstrow, nrows;\n{\n\tstruct rcons *rc = id;\n\tint srcy, dsty, ny;\n\n\tsrcy = rc->rc_yorigin + rc->rc_font->height * srcrow;\n\tdsty = rc->rc_yorigin + rc->rc_font->height * dstrow;\n\tny = rc->rc_font->height * nrows;\n\n\traster_op(rc->rc_sp, rc->rc_xorigin, dsty,\n\t    rc->rc_raswidth, ny, RAS_SRC,\n\t    rc->rc_sp, rc->rc_xorigin, srcy);\n}",
    "includes": [
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wscons_raster.h>",
      "#include <dev/rcons/raster.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raster_op",
          "args": [
            "rc->rc_sp",
            "rc->rc_xorigin",
            "dsty",
            "rc->rc_raswidth",
            "ny",
            "RAS_SRC",
            "rc->rc_sp",
            "rc->rc_xorigin",
            "srcy"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "raster_op_nosrc_noclip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/raster_op.c",
          "lines": "759-860",
          "snippet": "int\nraster_op_nosrc_noclip( dst, dx, dy, w, h, rop )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( dst->depth == 1 )\n\t{\n\t/* One-bit no-src blit. */\n\tu_int32_t* dstlin1;\n\tu_int32_t* dstlin2;\n\tu_int32_t* dstlin;\n\tint dstleftignore, dstrightignore, dstlongs;\n\tu_int32_t dl, lm, nlm, rm, nrm;\n\tregister u_int32_t* dstlong2;\n\tregister u_int32_t* dstlong;\n\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width clears. */\n\tif ( op == RAS_CLEAR && dst->width == w && dst->linelongs == w >> 5 )\n\t    {\n\t    bzero( (char*) dstlin1, h * dst->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tdstleftignore = ( dx & 31 );\n\tdstlongs = ( dstleftignore + w + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\tdstlin2 = dstlin1 + h * dst->linelongs;\n\tdstlin = dstlin1;\n\n\tif ( dstlongs == 1 )\n\t    {\n\t    /* It fits into a single longword. */\n\t    lm = leftmask[dstleftignore] | rightmask[dstrightignore];\n\t    nlm = ~lm;\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ dl = *dstlin;,\n\t\t/*d*/   dl,\n\t\t/*pst*/ *dstlin = ( *dstlin & lm ) | ( dl & nlm ); )\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\telse\n\t    {\n\t    lm = leftmask[dstleftignore];\n\t    rm = rightmask[dstrightignore];\n\t    nrm = ~rm;\n\t    nlm = ~lm;\n\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tdstlong = dstlin;\n\t\tdstlong2 = dstlong + dstlongs;\n\t\tif ( dstrightignore != 0 )\n\t\t    --dstlong2;\n\n\t\t/* Leading edge. */\n\t\tif ( dstleftignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t    ++dstlong;\n\t\t    }\n\n\t\t/* Main rop. */\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( dstlong != dstlong2 )\n\t\t\t    {,\n\t\t/*d*/       *dstlong,\n\t\t/*pst*/     ++dstlong;\n\t\t\t    } )\n\n\t\t/* Trailing edge. */\n\t\tif ( dstrightignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t    }\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}",
          "includes": [
            "#include \"raster.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"raster.h\"\n#include <dev/rcons/raster.h>\n#include <sys/types.h>\n\nint\nraster_op_nosrc_noclip( dst, dx, dy, w, h, rop )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( dst->depth == 1 )\n\t{\n\t/* One-bit no-src blit. */\n\tu_int32_t* dstlin1;\n\tu_int32_t* dstlin2;\n\tu_int32_t* dstlin;\n\tint dstleftignore, dstrightignore, dstlongs;\n\tu_int32_t dl, lm, nlm, rm, nrm;\n\tregister u_int32_t* dstlong2;\n\tregister u_int32_t* dstlong;\n\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width clears. */\n\tif ( op == RAS_CLEAR && dst->width == w && dst->linelongs == w >> 5 )\n\t    {\n\t    bzero( (char*) dstlin1, h * dst->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tdstleftignore = ( dx & 31 );\n\tdstlongs = ( dstleftignore + w + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\tdstlin2 = dstlin1 + h * dst->linelongs;\n\tdstlin = dstlin1;\n\n\tif ( dstlongs == 1 )\n\t    {\n\t    /* It fits into a single longword. */\n\t    lm = leftmask[dstleftignore] | rightmask[dstrightignore];\n\t    nlm = ~lm;\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ dl = *dstlin;,\n\t\t/*d*/   dl,\n\t\t/*pst*/ *dstlin = ( *dstlin & lm ) | ( dl & nlm ); )\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\telse\n\t    {\n\t    lm = leftmask[dstleftignore];\n\t    rm = rightmask[dstrightignore];\n\t    nrm = ~rm;\n\t    nlm = ~lm;\n\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tdstlong = dstlin;\n\t\tdstlong2 = dstlong + dstlongs;\n\t\tif ( dstrightignore != 0 )\n\t\t    --dstlong2;\n\n\t\t/* Leading edge. */\n\t\tif ( dstleftignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t    ++dstlong;\n\t\t    }\n\n\t\t/* Main rop. */\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( dstlong != dstlong2 )\n\t\t\t    {,\n\t\t/*d*/       *dstlong,\n\t\t/*pst*/     ++dstlong;\n\t\t\t    } )\n\n\t\t/* Trailing edge. */\n\t\tif ( dstrightignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t    }\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wscons_raster.h>\n#include <dev/rcons/raster.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nvoid\nrcons_copyrows(id, srcrow, dstrow, nrows)\n\tvoid *id;\n\tint srcrow, dstrow, nrows;\n{\n\tstruct rcons *rc = id;\n\tint srcy, dsty, ny;\n\n\tsrcy = rc->rc_yorigin + rc->rc_font->height * srcrow;\n\tdsty = rc->rc_yorigin + rc->rc_font->height * dstrow;\n\tny = rc->rc_font->height * nrows;\n\n\traster_op(rc->rc_sp, rc->rc_xorigin, dsty,\n\t    rc->rc_raswidth, ny, RAS_SRC,\n\t    rc->rc_sp, rc->rc_xorigin, srcy);\n}"
  },
  {
    "function_name": "rcons_erasecols",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wscons_rops.c",
    "lines": "181-200",
    "snippet": "void\nrcons_erasecols(id, row, startcol, ncols, fillattr)\n\tvoid *id;\n\tint row, startcol, ncols;\n\tlong fillattr;\n{\n\tstruct rcons *rc = id;\n\tint y, startx, nx, op;\n\n\ty = rc->rc_yorigin + rc->rc_font->height * row;\n\tstartx = rc->rc_xorigin + rc->rc_font->width * startcol;\n\tnx = rc->rc_font->width * ncols;\n\n\top = RAS_CLEAR;\n\tif ((fillattr != 0) ^ ((rc->rc_bits & RC_INVERT) != 0))\n\t\top = RAS_NOT(op);\n\traster_op(rc->rc_sp, startx, y,\n\t    nx, rc->rc_font->height, op,\n\t    (struct raster *) 0, 0, 0);\n}",
    "includes": [
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wscons_raster.h>",
      "#include <dev/rcons/raster.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raster_op",
          "args": [
            "rc->rc_sp",
            "startx",
            "y",
            "nx",
            "rc->rc_font->height",
            "op",
            "(struct raster *) 0",
            "0",
            "0"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "raster_op_nosrc_noclip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/raster_op.c",
          "lines": "759-860",
          "snippet": "int\nraster_op_nosrc_noclip( dst, dx, dy, w, h, rop )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( dst->depth == 1 )\n\t{\n\t/* One-bit no-src blit. */\n\tu_int32_t* dstlin1;\n\tu_int32_t* dstlin2;\n\tu_int32_t* dstlin;\n\tint dstleftignore, dstrightignore, dstlongs;\n\tu_int32_t dl, lm, nlm, rm, nrm;\n\tregister u_int32_t* dstlong2;\n\tregister u_int32_t* dstlong;\n\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width clears. */\n\tif ( op == RAS_CLEAR && dst->width == w && dst->linelongs == w >> 5 )\n\t    {\n\t    bzero( (char*) dstlin1, h * dst->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tdstleftignore = ( dx & 31 );\n\tdstlongs = ( dstleftignore + w + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\tdstlin2 = dstlin1 + h * dst->linelongs;\n\tdstlin = dstlin1;\n\n\tif ( dstlongs == 1 )\n\t    {\n\t    /* It fits into a single longword. */\n\t    lm = leftmask[dstleftignore] | rightmask[dstrightignore];\n\t    nlm = ~lm;\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ dl = *dstlin;,\n\t\t/*d*/   dl,\n\t\t/*pst*/ *dstlin = ( *dstlin & lm ) | ( dl & nlm ); )\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\telse\n\t    {\n\t    lm = leftmask[dstleftignore];\n\t    rm = rightmask[dstrightignore];\n\t    nrm = ~rm;\n\t    nlm = ~lm;\n\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tdstlong = dstlin;\n\t\tdstlong2 = dstlong + dstlongs;\n\t\tif ( dstrightignore != 0 )\n\t\t    --dstlong2;\n\n\t\t/* Leading edge. */\n\t\tif ( dstleftignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t    ++dstlong;\n\t\t    }\n\n\t\t/* Main rop. */\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( dstlong != dstlong2 )\n\t\t\t    {,\n\t\t/*d*/       *dstlong,\n\t\t/*pst*/     ++dstlong;\n\t\t\t    } )\n\n\t\t/* Trailing edge. */\n\t\tif ( dstrightignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t    }\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}",
          "includes": [
            "#include \"raster.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"raster.h\"\n#include <dev/rcons/raster.h>\n#include <sys/types.h>\n\nint\nraster_op_nosrc_noclip( dst, dx, dy, w, h, rop )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( dst->depth == 1 )\n\t{\n\t/* One-bit no-src blit. */\n\tu_int32_t* dstlin1;\n\tu_int32_t* dstlin2;\n\tu_int32_t* dstlin;\n\tint dstleftignore, dstrightignore, dstlongs;\n\tu_int32_t dl, lm, nlm, rm, nrm;\n\tregister u_int32_t* dstlong2;\n\tregister u_int32_t* dstlong;\n\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width clears. */\n\tif ( op == RAS_CLEAR && dst->width == w && dst->linelongs == w >> 5 )\n\t    {\n\t    bzero( (char*) dstlin1, h * dst->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tdstleftignore = ( dx & 31 );\n\tdstlongs = ( dstleftignore + w + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\tdstlin2 = dstlin1 + h * dst->linelongs;\n\tdstlin = dstlin1;\n\n\tif ( dstlongs == 1 )\n\t    {\n\t    /* It fits into a single longword. */\n\t    lm = leftmask[dstleftignore] | rightmask[dstrightignore];\n\t    nlm = ~lm;\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ dl = *dstlin;,\n\t\t/*d*/   dl,\n\t\t/*pst*/ *dstlin = ( *dstlin & lm ) | ( dl & nlm ); )\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\telse\n\t    {\n\t    lm = leftmask[dstleftignore];\n\t    rm = rightmask[dstrightignore];\n\t    nrm = ~rm;\n\t    nlm = ~lm;\n\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tdstlong = dstlin;\n\t\tdstlong2 = dstlong + dstlongs;\n\t\tif ( dstrightignore != 0 )\n\t\t    --dstlong2;\n\n\t\t/* Leading edge. */\n\t\tif ( dstleftignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t    ++dstlong;\n\t\t    }\n\n\t\t/* Main rop. */\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( dstlong != dstlong2 )\n\t\t\t    {,\n\t\t/*d*/       *dstlong,\n\t\t/*pst*/     ++dstlong;\n\t\t\t    } )\n\n\t\t/* Trailing edge. */\n\t\tif ( dstrightignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t    }\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}"
        }
      },
      {
        "call_info": {
          "callee": "RAS_NOT",
          "args": [
            "op"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wscons_raster.h>\n#include <dev/rcons/raster.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nvoid\nrcons_erasecols(id, row, startcol, ncols, fillattr)\n\tvoid *id;\n\tint row, startcol, ncols;\n\tlong fillattr;\n{\n\tstruct rcons *rc = id;\n\tint y, startx, nx, op;\n\n\ty = rc->rc_yorigin + rc->rc_font->height * row;\n\tstartx = rc->rc_xorigin + rc->rc_font->width * startcol;\n\tnx = rc->rc_font->width * ncols;\n\n\top = RAS_CLEAR;\n\tif ((fillattr != 0) ^ ((rc->rc_bits & RC_INVERT) != 0))\n\t\top = RAS_NOT(op);\n\traster_op(rc->rc_sp, startx, y,\n\t    nx, rc->rc_font->height, op,\n\t    (struct raster *) 0, 0, 0);\n}"
  },
  {
    "function_name": "rcons_copycols",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wscons_rops.c",
    "lines": "160-176",
    "snippet": "void\nrcons_copycols(id, row, srccol, dstcol, ncols)\n\tvoid *id;\n\tint row, srccol, dstcol, ncols;\n{\n\tstruct rcons *rc = id;\n\tint y, srcx, dstx, nx;\n\n\ty = rc->rc_yorigin + rc->rc_font->height * row;\n\tsrcx = rc->rc_xorigin + rc->rc_font->width * srccol;\n\tdstx = rc->rc_xorigin + rc->rc_font->width * dstcol;\n\tnx = rc->rc_font->width * ncols;\n\n\traster_op(rc->rc_sp, dstx, y,\n\t    nx, rc->rc_font->height, RAS_SRC,\n\t    rc->rc_sp, srcx, y);\n}",
    "includes": [
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wscons_raster.h>",
      "#include <dev/rcons/raster.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raster_op",
          "args": [
            "rc->rc_sp",
            "dstx",
            "y",
            "nx",
            "rc->rc_font->height",
            "RAS_SRC",
            "rc->rc_sp",
            "srcx",
            "y"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "raster_op_nosrc_noclip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/raster_op.c",
          "lines": "759-860",
          "snippet": "int\nraster_op_nosrc_noclip( dst, dx, dy, w, h, rop )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( dst->depth == 1 )\n\t{\n\t/* One-bit no-src blit. */\n\tu_int32_t* dstlin1;\n\tu_int32_t* dstlin2;\n\tu_int32_t* dstlin;\n\tint dstleftignore, dstrightignore, dstlongs;\n\tu_int32_t dl, lm, nlm, rm, nrm;\n\tregister u_int32_t* dstlong2;\n\tregister u_int32_t* dstlong;\n\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width clears. */\n\tif ( op == RAS_CLEAR && dst->width == w && dst->linelongs == w >> 5 )\n\t    {\n\t    bzero( (char*) dstlin1, h * dst->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tdstleftignore = ( dx & 31 );\n\tdstlongs = ( dstleftignore + w + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\tdstlin2 = dstlin1 + h * dst->linelongs;\n\tdstlin = dstlin1;\n\n\tif ( dstlongs == 1 )\n\t    {\n\t    /* It fits into a single longword. */\n\t    lm = leftmask[dstleftignore] | rightmask[dstrightignore];\n\t    nlm = ~lm;\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ dl = *dstlin;,\n\t\t/*d*/   dl,\n\t\t/*pst*/ *dstlin = ( *dstlin & lm ) | ( dl & nlm ); )\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\telse\n\t    {\n\t    lm = leftmask[dstleftignore];\n\t    rm = rightmask[dstrightignore];\n\t    nrm = ~rm;\n\t    nlm = ~lm;\n\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tdstlong = dstlin;\n\t\tdstlong2 = dstlong + dstlongs;\n\t\tif ( dstrightignore != 0 )\n\t\t    --dstlong2;\n\n\t\t/* Leading edge. */\n\t\tif ( dstleftignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t    ++dstlong;\n\t\t    }\n\n\t\t/* Main rop. */\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( dstlong != dstlong2 )\n\t\t\t    {,\n\t\t/*d*/       *dstlong,\n\t\t/*pst*/     ++dstlong;\n\t\t\t    } )\n\n\t\t/* Trailing edge. */\n\t\tif ( dstrightignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t    }\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}",
          "includes": [
            "#include \"raster.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"raster.h\"\n#include <dev/rcons/raster.h>\n#include <sys/types.h>\n\nint\nraster_op_nosrc_noclip( dst, dx, dy, w, h, rop )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( dst->depth == 1 )\n\t{\n\t/* One-bit no-src blit. */\n\tu_int32_t* dstlin1;\n\tu_int32_t* dstlin2;\n\tu_int32_t* dstlin;\n\tint dstleftignore, dstrightignore, dstlongs;\n\tu_int32_t dl, lm, nlm, rm, nrm;\n\tregister u_int32_t* dstlong2;\n\tregister u_int32_t* dstlong;\n\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width clears. */\n\tif ( op == RAS_CLEAR && dst->width == w && dst->linelongs == w >> 5 )\n\t    {\n\t    bzero( (char*) dstlin1, h * dst->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tdstleftignore = ( dx & 31 );\n\tdstlongs = ( dstleftignore + w + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\tdstlin2 = dstlin1 + h * dst->linelongs;\n\tdstlin = dstlin1;\n\n\tif ( dstlongs == 1 )\n\t    {\n\t    /* It fits into a single longword. */\n\t    lm = leftmask[dstleftignore] | rightmask[dstrightignore];\n\t    nlm = ~lm;\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ dl = *dstlin;,\n\t\t/*d*/   dl,\n\t\t/*pst*/ *dstlin = ( *dstlin & lm ) | ( dl & nlm ); )\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\telse\n\t    {\n\t    lm = leftmask[dstleftignore];\n\t    rm = rightmask[dstrightignore];\n\t    nrm = ~rm;\n\t    nlm = ~lm;\n\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tdstlong = dstlin;\n\t\tdstlong2 = dstlong + dstlongs;\n\t\tif ( dstrightignore != 0 )\n\t\t    --dstlong2;\n\n\t\t/* Leading edge. */\n\t\tif ( dstleftignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t    ++dstlong;\n\t\t    }\n\n\t\t/* Main rop. */\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( dstlong != dstlong2 )\n\t\t\t    {,\n\t\t/*d*/       *dstlong,\n\t\t/*pst*/     ++dstlong;\n\t\t\t    } )\n\n\t\t/* Trailing edge. */\n\t\tif ( dstrightignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t    }\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wscons_raster.h>\n#include <dev/rcons/raster.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nvoid\nrcons_copycols(id, row, srccol, dstcol, ncols)\n\tvoid *id;\n\tint row, srccol, dstcol, ncols;\n{\n\tstruct rcons *rc = id;\n\tint y, srcx, dstx, nx;\n\n\ty = rc->rc_yorigin + rc->rc_font->height * row;\n\tsrcx = rc->rc_xorigin + rc->rc_font->width * srccol;\n\tdstx = rc->rc_xorigin + rc->rc_font->width * dstcol;\n\tnx = rc->rc_font->width * ncols;\n\n\traster_op(rc->rc_sp, dstx, y,\n\t    nx, rc->rc_font->height, RAS_SRC,\n\t    rc->rc_sp, srcx, y);\n}"
  },
  {
    "function_name": "rcons_invert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wscons_rops.c",
    "lines": "140-155",
    "snippet": "void\nrcons_invert(id, inverted)\n\tvoid *id;\n\tint inverted;\n{\n\tstruct rcons *rc = id;\n\n\tif (((rc->rc_bits & RC_INVERT) != 0) ^ inverted) {\n\t\t/* Invert the display */\n\t\traster_op(rc->rc_sp, 0, 0, rc->rc_sp->width, rc->rc_sp->height,\n\t\t    RAS_INVERT, (struct raster *) 0, 0, 0);\n\n\t\t/* Swap things around */\n\t\trc->rc_bits ^= RC_INVERT;\n\t}\n}",
    "includes": [
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wscons_raster.h>",
      "#include <dev/rcons/raster.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raster_op",
          "args": [
            "rc->rc_sp",
            "0",
            "0",
            "rc->rc_sp->width",
            "rc->rc_sp->height",
            "RAS_INVERT",
            "(struct raster *) 0",
            "0",
            "0"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "raster_op_nosrc_noclip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/raster_op.c",
          "lines": "759-860",
          "snippet": "int\nraster_op_nosrc_noclip( dst, dx, dy, w, h, rop )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( dst->depth == 1 )\n\t{\n\t/* One-bit no-src blit. */\n\tu_int32_t* dstlin1;\n\tu_int32_t* dstlin2;\n\tu_int32_t* dstlin;\n\tint dstleftignore, dstrightignore, dstlongs;\n\tu_int32_t dl, lm, nlm, rm, nrm;\n\tregister u_int32_t* dstlong2;\n\tregister u_int32_t* dstlong;\n\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width clears. */\n\tif ( op == RAS_CLEAR && dst->width == w && dst->linelongs == w >> 5 )\n\t    {\n\t    bzero( (char*) dstlin1, h * dst->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tdstleftignore = ( dx & 31 );\n\tdstlongs = ( dstleftignore + w + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\tdstlin2 = dstlin1 + h * dst->linelongs;\n\tdstlin = dstlin1;\n\n\tif ( dstlongs == 1 )\n\t    {\n\t    /* It fits into a single longword. */\n\t    lm = leftmask[dstleftignore] | rightmask[dstrightignore];\n\t    nlm = ~lm;\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ dl = *dstlin;,\n\t\t/*d*/   dl,\n\t\t/*pst*/ *dstlin = ( *dstlin & lm ) | ( dl & nlm ); )\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\telse\n\t    {\n\t    lm = leftmask[dstleftignore];\n\t    rm = rightmask[dstrightignore];\n\t    nrm = ~rm;\n\t    nlm = ~lm;\n\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tdstlong = dstlin;\n\t\tdstlong2 = dstlong + dstlongs;\n\t\tif ( dstrightignore != 0 )\n\t\t    --dstlong2;\n\n\t\t/* Leading edge. */\n\t\tif ( dstleftignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t    ++dstlong;\n\t\t    }\n\n\t\t/* Main rop. */\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( dstlong != dstlong2 )\n\t\t\t    {,\n\t\t/*d*/       *dstlong,\n\t\t/*pst*/     ++dstlong;\n\t\t\t    } )\n\n\t\t/* Trailing edge. */\n\t\tif ( dstrightignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t    }\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}",
          "includes": [
            "#include \"raster.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"raster.h\"\n#include <dev/rcons/raster.h>\n#include <sys/types.h>\n\nint\nraster_op_nosrc_noclip( dst, dx, dy, w, h, rop )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( dst->depth == 1 )\n\t{\n\t/* One-bit no-src blit. */\n\tu_int32_t* dstlin1;\n\tu_int32_t* dstlin2;\n\tu_int32_t* dstlin;\n\tint dstleftignore, dstrightignore, dstlongs;\n\tu_int32_t dl, lm, nlm, rm, nrm;\n\tregister u_int32_t* dstlong2;\n\tregister u_int32_t* dstlong;\n\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width clears. */\n\tif ( op == RAS_CLEAR && dst->width == w && dst->linelongs == w >> 5 )\n\t    {\n\t    bzero( (char*) dstlin1, h * dst->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tdstleftignore = ( dx & 31 );\n\tdstlongs = ( dstleftignore + w + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\tdstlin2 = dstlin1 + h * dst->linelongs;\n\tdstlin = dstlin1;\n\n\tif ( dstlongs == 1 )\n\t    {\n\t    /* It fits into a single longword. */\n\t    lm = leftmask[dstleftignore] | rightmask[dstrightignore];\n\t    nlm = ~lm;\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ dl = *dstlin;,\n\t\t/*d*/   dl,\n\t\t/*pst*/ *dstlin = ( *dstlin & lm ) | ( dl & nlm ); )\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\telse\n\t    {\n\t    lm = leftmask[dstleftignore];\n\t    rm = rightmask[dstrightignore];\n\t    nrm = ~rm;\n\t    nlm = ~lm;\n\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tdstlong = dstlin;\n\t\tdstlong2 = dstlong + dstlongs;\n\t\tif ( dstrightignore != 0 )\n\t\t    --dstlong2;\n\n\t\t/* Leading edge. */\n\t\tif ( dstleftignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t    ++dstlong;\n\t\t    }\n\n\t\t/* Main rop. */\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( dstlong != dstlong2 )\n\t\t\t    {,\n\t\t/*d*/       *dstlong,\n\t\t/*pst*/     ++dstlong;\n\t\t\t    } )\n\n\t\t/* Trailing edge. */\n\t\tif ( dstrightignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t    }\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wscons_raster.h>\n#include <dev/rcons/raster.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nvoid\nrcons_invert(id, inverted)\n\tvoid *id;\n\tint inverted;\n{\n\tstruct rcons *rc = id;\n\n\tif (((rc->rc_bits & RC_INVERT) != 0) ^ inverted) {\n\t\t/* Invert the display */\n\t\traster_op(rc->rc_sp, 0, 0, rc->rc_sp->width, rc->rc_sp->height,\n\t\t    RAS_INVERT, (struct raster *) 0, 0, 0);\n\n\t\t/* Swap things around */\n\t\trc->rc_bits ^= RC_INVERT;\n\t}\n}"
  },
  {
    "function_name": "rcons_putchar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wscons_rops.c",
    "lines": "116-135",
    "snippet": "void\nrcons_putchar(id, row, col, uc, attr)\n\tvoid *id;\n\tint row, col;\n\tu_int uc;\n\tlong attr;\n{\n\tstruct rcons *rc = id;\n\tint x, y, op;\n\tu_char help;\n\n\tx = col * rc->rc_font->width + rc->rc_xorigin;\n\ty = row * rc->rc_font->height + rc->rc_font_ascent + rc->rc_yorigin;\n\n\top = RAS_SRC;\n\tif ((attr != 0) ^ ((rc->rc_bits & RC_INVERT) != 0))\n\t\top = RAS_NOT(op);\n\thelp = uc & 0xff;\n\traster_textn(rc->rc_sp, x, y, op, rc->rc_font, &help, 1);\n}",
    "includes": [
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wscons_raster.h>",
      "#include <dev/rcons/raster.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raster_textn",
          "args": [
            "rc->rc_sp",
            "x",
            "y",
            "op",
            "rc->rc_font",
            "&help",
            "1"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "raster_textn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/raster_text.c",
          "lines": "78-224",
          "snippet": "int\nraster_textn( r, x, y, rop, rf, text, n )\n    register struct raster* r;\n    int x, y;\n    int rop;\n    struct raster_font* rf;\n    unsigned char* text;\n    int n;\n    {\n    int clip;\n    int x1, y1;\n    struct raster_char* c;\n    struct raster* charrast;\n    int i;\n    register unsigned char ch;\n    int thisx, thisy;\n    int phase;\n\n    /* Check whether we can avoid clipping. */\n    clip = 0;\n    if ( rf->flags & RASFONT_FIXEDWIDTH &&\n\t rf->flags & RASFONT_NOVERTICALMOVEMENT )\n\t{\n\t/* This font is well-behaved, we can compute the extent cheaply. */\n\tc = &(rf->chars['@']);\n\tcharrast = c->r;\n\tif ( x + c->homex < 0 || y + c->homey < 0 ||\n\t     x + c->homex + n * c->nextx > r->width ||\n\t     y + c->homey + charrast->height > r->height )\n\t    clip = 1;\n\t}\n    else\n\t{\n\t/* Got to step through the string to compute the extent. */\n\tfor ( i = 0, x1 = x, y1 = y;\n\t      i < n;\n\t      ++i, x1 += c->nextx, y1 += c->nexty )\n\t    {\n\t    c = &(rf->chars[text[i]]);\n\t    charrast = c->r;\n\t    if ( charrast != (struct raster*) 0 )\n\t\t{\n\t\tif ( x1 + c->homex < 0 || y1 + c->homey < 0 ||\n\t\t     x1 + c->homex + charrast->width > r->width ||\n\t\t     y1 + c->homey + charrast->height > r->height )\n\t\t    {\n\t\t    clip = 1;\n\t\t    break;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n    /* Now display the text. */\n    for ( i = 0, x1 = x, y1 = y;\n\t  i < n;\n\t  ++i, x1 += c->nextx, y1 += c->nexty )\n\t{\n\tch = text[i];\n\tc = &(rf->chars[ch]);\n\tcharrast = c->r;\n\tif ( charrast != (struct raster*) 0 )\n\t    {\n\t    thisx = x1 + c->homex;\n\t    thisy = y1 + c->homey;\n\n\t    phase = 0;\n#ifdef COLORFONT_CACHE\n\t    if ( r->depth == 8 )\n\t\t{\n\t\t/* Initialize color font cache if necessary. */\n\t\tif ( rf->cache == (struct raster_fontcache*) -1 )\n\t\t    {\n\t\t    int c;\n\n\t\t    rf->cache = (struct raster_fontcache*)\n\t\t\tNEW( sizeof(struct raster_fontcache) );\n\t\t    if ( rf->cache != (struct raster_fontcache*) 0 )\n\t\t\tfor ( c = 0; c < 256; ++c )\n\t\t\t    rf->cache->cr[c] = (struct raster*) 0;\n\t\t    }\n\n\t\tif ( rf->cache != (struct raster_fontcache*) 0 )\n\t\t    {\n\t\t    int color;\n\t\t    struct raster* cr;\n\n\t\t    color = RAS_GETCOLOR( rop );\n\t\t    cr = rf->cache->cr[ch];\n\t\t    /* Is this character cached yet? */\n\t\t    if ( cr != (struct raster*) 0 )\n\t\t\t{\n\t\t\t/* Yes, but is it the right color? */\n\t\t\tif ( rf->cache->color[ch] == color )\n\t\t\t    {\n\t\t\t    /* Yes - switch rasters. */\n\t\t\t    charrast = cr;\n\t\t\t    }\n\t\t\telse\n\t\t\t    {\n\t\t\t    /* No, re-draw it. */\n\t\t\t    if ( raster_op_noclip(\n\t\t\t\t cr, 0, 0, charrast->width,\n\t\t\t\t charrast->height, rop, charrast, 0, 0 ) == 0 )\n\t\t\t\t{\n\t\t\t\trf->cache->color[ch] = color;\n\t\t\t\tcharrast = cr;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    else\n\t\t\t{\n\t\t\t/* It's not cached, so cache it. */\n\t\t\tcr = raster_alloc(\n\t\t\t    charrast->width, charrast->height, 8 );\n\t\t\tif ( cr != (struct raster*) 0 )\n\t\t\t    if ( raster_op_noclip(\n\t\t\t\t cr, 0, 0, charrast->width, charrast->height,\n\t\t\t\t rop, charrast, 0, 0 ) == 0 )\n\t\t\t\t{\n\t\t\t\trf->cache->color[ch] = color;\n\t\t\t\tcharrast = rf->cache->cr[ch] = cr;\n\t\t\t\t}\n\t\t\t}\n\t\t    }\n\t\t}\n#endif /*COLORFONT_CACHE*/\n\n\t    if ( clip )\n\t\t{\n\t\tif ( raster_op(\n\t\t\t r, thisx, thisy, charrast->width, charrast->height,\n\t\t\t rop, charrast, phase, 0 ) < 0 )\n\t\t    return -1;\n\t\t}\n\t    else\n\t\t{\n\t\tif ( raster_op_noclip(\n\t\t\t r, thisx, thisy, charrast->width, charrast->height,\n\t\t\t rop, charrast, phase, 0 ) < 0 )\n\t\t    return -1;\n\t\t}\n\t    }\n\t}\n\n    return 0;\n    }",
          "includes": [
            "#include <malloc.h>",
            "#include \"raster.h\"",
            "#include <string.h>",
            "#include <sys/types.h>",
            "#include <sys/malloc.h>",
            "#include <dev/rcons/raster.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <malloc.h>\n#include \"raster.h\"\n#include <string.h>\n#include <sys/types.h>\n#include <sys/malloc.h>\n#include <dev/rcons/raster.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nraster_textn( r, x, y, rop, rf, text, n )\n    register struct raster* r;\n    int x, y;\n    int rop;\n    struct raster_font* rf;\n    unsigned char* text;\n    int n;\n    {\n    int clip;\n    int x1, y1;\n    struct raster_char* c;\n    struct raster* charrast;\n    int i;\n    register unsigned char ch;\n    int thisx, thisy;\n    int phase;\n\n    /* Check whether we can avoid clipping. */\n    clip = 0;\n    if ( rf->flags & RASFONT_FIXEDWIDTH &&\n\t rf->flags & RASFONT_NOVERTICALMOVEMENT )\n\t{\n\t/* This font is well-behaved, we can compute the extent cheaply. */\n\tc = &(rf->chars['@']);\n\tcharrast = c->r;\n\tif ( x + c->homex < 0 || y + c->homey < 0 ||\n\t     x + c->homex + n * c->nextx > r->width ||\n\t     y + c->homey + charrast->height > r->height )\n\t    clip = 1;\n\t}\n    else\n\t{\n\t/* Got to step through the string to compute the extent. */\n\tfor ( i = 0, x1 = x, y1 = y;\n\t      i < n;\n\t      ++i, x1 += c->nextx, y1 += c->nexty )\n\t    {\n\t    c = &(rf->chars[text[i]]);\n\t    charrast = c->r;\n\t    if ( charrast != (struct raster*) 0 )\n\t\t{\n\t\tif ( x1 + c->homex < 0 || y1 + c->homey < 0 ||\n\t\t     x1 + c->homex + charrast->width > r->width ||\n\t\t     y1 + c->homey + charrast->height > r->height )\n\t\t    {\n\t\t    clip = 1;\n\t\t    break;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n    /* Now display the text. */\n    for ( i = 0, x1 = x, y1 = y;\n\t  i < n;\n\t  ++i, x1 += c->nextx, y1 += c->nexty )\n\t{\n\tch = text[i];\n\tc = &(rf->chars[ch]);\n\tcharrast = c->r;\n\tif ( charrast != (struct raster*) 0 )\n\t    {\n\t    thisx = x1 + c->homex;\n\t    thisy = y1 + c->homey;\n\n\t    phase = 0;\n#ifdef COLORFONT_CACHE\n\t    if ( r->depth == 8 )\n\t\t{\n\t\t/* Initialize color font cache if necessary. */\n\t\tif ( rf->cache == (struct raster_fontcache*) -1 )\n\t\t    {\n\t\t    int c;\n\n\t\t    rf->cache = (struct raster_fontcache*)\n\t\t\tNEW( sizeof(struct raster_fontcache) );\n\t\t    if ( rf->cache != (struct raster_fontcache*) 0 )\n\t\t\tfor ( c = 0; c < 256; ++c )\n\t\t\t    rf->cache->cr[c] = (struct raster*) 0;\n\t\t    }\n\n\t\tif ( rf->cache != (struct raster_fontcache*) 0 )\n\t\t    {\n\t\t    int color;\n\t\t    struct raster* cr;\n\n\t\t    color = RAS_GETCOLOR( rop );\n\t\t    cr = rf->cache->cr[ch];\n\t\t    /* Is this character cached yet? */\n\t\t    if ( cr != (struct raster*) 0 )\n\t\t\t{\n\t\t\t/* Yes, but is it the right color? */\n\t\t\tif ( rf->cache->color[ch] == color )\n\t\t\t    {\n\t\t\t    /* Yes - switch rasters. */\n\t\t\t    charrast = cr;\n\t\t\t    }\n\t\t\telse\n\t\t\t    {\n\t\t\t    /* No, re-draw it. */\n\t\t\t    if ( raster_op_noclip(\n\t\t\t\t cr, 0, 0, charrast->width,\n\t\t\t\t charrast->height, rop, charrast, 0, 0 ) == 0 )\n\t\t\t\t{\n\t\t\t\trf->cache->color[ch] = color;\n\t\t\t\tcharrast = cr;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    else\n\t\t\t{\n\t\t\t/* It's not cached, so cache it. */\n\t\t\tcr = raster_alloc(\n\t\t\t    charrast->width, charrast->height, 8 );\n\t\t\tif ( cr != (struct raster*) 0 )\n\t\t\t    if ( raster_op_noclip(\n\t\t\t\t cr, 0, 0, charrast->width, charrast->height,\n\t\t\t\t rop, charrast, 0, 0 ) == 0 )\n\t\t\t\t{\n\t\t\t\trf->cache->color[ch] = color;\n\t\t\t\tcharrast = rf->cache->cr[ch] = cr;\n\t\t\t\t}\n\t\t\t}\n\t\t    }\n\t\t}\n#endif /*COLORFONT_CACHE*/\n\n\t    if ( clip )\n\t\t{\n\t\tif ( raster_op(\n\t\t\t r, thisx, thisy, charrast->width, charrast->height,\n\t\t\t rop, charrast, phase, 0 ) < 0 )\n\t\t    return -1;\n\t\t}\n\t    else\n\t\t{\n\t\tif ( raster_op_noclip(\n\t\t\t r, thisx, thisy, charrast->width, charrast->height,\n\t\t\t rop, charrast, phase, 0 ) < 0 )\n\t\t    return -1;\n\t\t}\n\t    }\n\t}\n\n    return 0;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "RAS_NOT",
          "args": [
            "op"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wscons_raster.h>\n#include <dev/rcons/raster.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nvoid\nrcons_putchar(id, row, col, uc, attr)\n\tvoid *id;\n\tint row, col;\n\tu_int uc;\n\tlong attr;\n{\n\tstruct rcons *rc = id;\n\tint x, y, op;\n\tu_char help;\n\n\tx = col * rc->rc_font->width + rc->rc_xorigin;\n\ty = row * rc->rc_font->height + rc->rc_font_ascent + rc->rc_yorigin;\n\n\top = RAS_SRC;\n\tif ((attr != 0) ^ ((rc->rc_bits & RC_INVERT) != 0))\n\t\top = RAS_NOT(op);\n\thelp = uc & 0xff;\n\traster_textn(rc->rc_sp, x, y, op, rc->rc_font, &help, 1);\n}"
  },
  {
    "function_name": "rcons_mapchar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wscons_rops.c",
    "lines": "98-111",
    "snippet": "int\nrcons_mapchar(id, uni, index)\n\tvoid *id;\n\tint uni;\n\tunsigned int *index;\n{\n\n\tif (uni < 128) {\n\t\t*index = uni;\n\t\treturn (5);\n\t}\n\t*index = ' ';\n\treturn (0);\n}",
    "includes": [
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wscons_raster.h>",
      "#include <dev/rcons/raster.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wscons_raster.h>\n#include <dev/rcons/raster.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nint\nrcons_mapchar(id, uni, index)\n\tvoid *id;\n\tint uni;\n\tunsigned int *index;\n{\n\n\tif (uni < 128) {\n\t\t*index = uni;\n\t\treturn (5);\n\t}\n\t*index = ' ';\n\treturn (0);\n}"
  },
  {
    "function_name": "rcons_cursor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wscons_rops.c",
    "lines": "59-96",
    "snippet": "void\nrcons_cursor(id, on, row, col)\n\tvoid *id;\n\tint on, row, col;\n{\n\tstruct rcons *rc = id;\n\tint x, y;\n\n\t/* turn the cursor off */\n\tif (!on) {\n\t\t/* make sure it's on */\n\t\tif ((rc->rc_bits & RC_CURSOR) == 0)\n\t\t\treturn;\n\n\t\trow = *rc->rc_crowp;\n\t\tcol = *rc->rc_ccolp;\n\t} else {\n\t\t/* unpaint the old copy. */\n\t\t*rc->rc_crowp = row;\n\t\t*rc->rc_ccolp = col;\n\t}\n\n\tx = col * rc->rc_font->width + rc->rc_xorigin;\n\ty = row * rc->rc_font->height + rc->rc_yorigin;\n\n\traster_op(rc->rc_sp, x, y,\n#ifdef notdef\n\t    /* XXX This is the right way but too slow */\n\t    rc->rc_font->chars[(int)' '].r->width,\n\t    rc->rc_font->chars[(int)' '].r->height,\n#else\n\t    rc->rc_font->width, rc->rc_font->height,\n#endif\n\t    RAS_INVERT,\n\t    (struct raster *) 0, 0, 0);\n\n\trc->rc_bits ^= RC_CURSOR;\n}",
    "includes": [
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wscons_raster.h>",
      "#include <dev/rcons/raster.h>",
      "#include <sys/device.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raster_op",
          "args": [
            "rc->rc_sp",
            "x",
            "y",
            "#ifdef notdef/* XXX This is the right way but too slow */rc->rc_font->chars[(int)' '].r->width",
            "rc->rc_font->chars[(int)' '].r->height",
            "#elserc->rc_font->width",
            "rc->rc_font->height",
            "#endifRAS_INVERT",
            "(struct raster *) 0",
            "0",
            "0"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "raster_op_nosrc_noclip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/rcons/raster_op.c",
          "lines": "759-860",
          "snippet": "int\nraster_op_nosrc_noclip( dst, dx, dy, w, h, rop )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( dst->depth == 1 )\n\t{\n\t/* One-bit no-src blit. */\n\tu_int32_t* dstlin1;\n\tu_int32_t* dstlin2;\n\tu_int32_t* dstlin;\n\tint dstleftignore, dstrightignore, dstlongs;\n\tu_int32_t dl, lm, nlm, rm, nrm;\n\tregister u_int32_t* dstlong2;\n\tregister u_int32_t* dstlong;\n\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width clears. */\n\tif ( op == RAS_CLEAR && dst->width == w && dst->linelongs == w >> 5 )\n\t    {\n\t    bzero( (char*) dstlin1, h * dst->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tdstleftignore = ( dx & 31 );\n\tdstlongs = ( dstleftignore + w + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\tdstlin2 = dstlin1 + h * dst->linelongs;\n\tdstlin = dstlin1;\n\n\tif ( dstlongs == 1 )\n\t    {\n\t    /* It fits into a single longword. */\n\t    lm = leftmask[dstleftignore] | rightmask[dstrightignore];\n\t    nlm = ~lm;\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ dl = *dstlin;,\n\t\t/*d*/   dl,\n\t\t/*pst*/ *dstlin = ( *dstlin & lm ) | ( dl & nlm ); )\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\telse\n\t    {\n\t    lm = leftmask[dstleftignore];\n\t    rm = rightmask[dstrightignore];\n\t    nrm = ~rm;\n\t    nlm = ~lm;\n\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tdstlong = dstlin;\n\t\tdstlong2 = dstlong + dstlongs;\n\t\tif ( dstrightignore != 0 )\n\t\t    --dstlong2;\n\n\t\t/* Leading edge. */\n\t\tif ( dstleftignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t    ++dstlong;\n\t\t    }\n\n\t\t/* Main rop. */\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( dstlong != dstlong2 )\n\t\t\t    {,\n\t\t/*d*/       *dstlong,\n\t\t/*pst*/     ++dstlong;\n\t\t\t    } )\n\n\t\t/* Trailing edge. */\n\t\tif ( dstrightignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t    }\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}",
          "includes": [
            "#include \"raster.h\"",
            "#include <dev/rcons/raster.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"raster.h\"\n#include <dev/rcons/raster.h>\n#include <sys/types.h>\n\nint\nraster_op_nosrc_noclip( dst, dx, dy, w, h, rop )\n    struct raster* dst;\n    int dx, dy, w, h, rop;\n    {\n    int op;\n\n    op = RAS_GETOP( rop );\n\n    if ( dst->depth == 1 )\n\t{\n\t/* One-bit no-src blit. */\n\tu_int32_t* dstlin1;\n\tu_int32_t* dstlin2;\n\tu_int32_t* dstlin;\n\tint dstleftignore, dstrightignore, dstlongs;\n\tu_int32_t dl, lm, nlm, rm, nrm;\n\tregister u_int32_t* dstlong2;\n\tregister u_int32_t* dstlong;\n\n\tdstlin1 = RAS_ADDR( dst, dx, dy );\n\n#ifdef BCOPY_FASTER\n\t/* Special-case full-width clears. */\n\tif ( op == RAS_CLEAR && dst->width == w && dst->linelongs == w >> 5 )\n\t    {\n\t    bzero( (char*) dstlin1, h * dst->linelongs * sizeof(u_int32_t) );\n\t    return 0;\n\t    }\n#endif /*BCOPY_FASTER*/\n\n\tdstleftignore = ( dx & 31 );\n\tdstlongs = ( dstleftignore + w + 31 ) >> 5;\n\tdstrightignore = ( dstlongs * 32 - w - dstleftignore ) & 31;\n\n\tdstlin2 = dstlin1 + h * dst->linelongs;\n\tdstlin = dstlin1;\n\n\tif ( dstlongs == 1 )\n\t    {\n\t    /* It fits into a single longword. */\n\t    lm = leftmask[dstleftignore] | rightmask[dstrightignore];\n\t    nlm = ~lm;\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ dl = *dstlin;,\n\t\t/*d*/   dl,\n\t\t/*pst*/ *dstlin = ( *dstlin & lm ) | ( dl & nlm ); )\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\telse\n\t    {\n\t    lm = leftmask[dstleftignore];\n\t    rm = rightmask[dstrightignore];\n\t    nrm = ~rm;\n\t    nlm = ~lm;\n\n\t    while ( dstlin != dstlin2 )\n\t\t{\n\t\tdstlong = dstlin;\n\t\tdstlong2 = dstlong + dstlongs;\n\t\tif ( dstrightignore != 0 )\n\t\t    --dstlong2;\n\n\t\t/* Leading edge. */\n\t\tif ( dstleftignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( *dstlong & lm ) | ( dl & nlm ); )\n\t\t    ++dstlong;\n\t\t    }\n\n\t\t/* Main rop. */\n\t\tROP_DST(\n\t\t/*op*/  op,\n\t\t/*pre*/ while ( dstlong != dstlong2 )\n\t\t\t    {,\n\t\t/*d*/       *dstlong,\n\t\t/*pst*/     ++dstlong;\n\t\t\t    } )\n\n\t\t/* Trailing edge. */\n\t\tif ( dstrightignore != 0 )\n\t\t    {\n\t\t    ROP_DST(\n\t\t    /*op*/  op,\n\t\t    /*pre*/ dl = *dstlong;,\n\t\t    /*d*/   dl,\n\t\t    /*pst*/ *dstlong = ( dl & nrm ) | ( *dstlong & rm ); )\n\t\t    }\n\n\t\tdstlin += dst->linelongs;\n\t\t}\n\t    }\n\t}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wscons_raster.h>\n#include <dev/rcons/raster.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nvoid\nrcons_cursor(id, on, row, col)\n\tvoid *id;\n\tint on, row, col;\n{\n\tstruct rcons *rc = id;\n\tint x, y;\n\n\t/* turn the cursor off */\n\tif (!on) {\n\t\t/* make sure it's on */\n\t\tif ((rc->rc_bits & RC_CURSOR) == 0)\n\t\t\treturn;\n\n\t\trow = *rc->rc_crowp;\n\t\tcol = *rc->rc_ccolp;\n\t} else {\n\t\t/* unpaint the old copy. */\n\t\t*rc->rc_crowp = row;\n\t\t*rc->rc_ccolp = col;\n\t}\n\n\tx = col * rc->rc_font->width + rc->rc_xorigin;\n\ty = row * rc->rc_font->height + rc->rc_yorigin;\n\n\traster_op(rc->rc_sp, x, y,\n#ifdef notdef\n\t    /* XXX This is the right way but too slow */\n\t    rc->rc_font->chars[(int)' '].r->width,\n\t    rc->rc_font->chars[(int)' '].r->height,\n#else\n\t    rc->rc_font->width, rc->rc_font->height,\n#endif\n\t    RAS_INVERT,\n\t    (struct raster *) 0, 0, 0);\n\n\trc->rc_bits ^= RC_CURSOR;\n}"
  }
]