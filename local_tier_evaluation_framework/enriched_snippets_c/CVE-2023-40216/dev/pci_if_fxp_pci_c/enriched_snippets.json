[
  {
    "function_name": "fxp_pci_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_fxp_pci.c",
    "lines": "127-187",
    "snippet": "void\nfxp_pci_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct fxp_softc *sc = (struct fxp_softc *)self;\n\tstruct pci_attach_args *pa = aux;\n\tpci_chipset_tag_t pc = pa->pa_pc;\n\tpci_intr_handle_t ih;\n\tconst char *intrstr = NULL;\n\tu_int8_t enaddr[6];\n\tbus_space_tag_t iot = pa->pa_iot;\n\tbus_addr_t iobase;\n\tbus_size_t iosize;\n\tpcireg_t rev = PCI_REVISION(pa->pa_class);\n\n\tif (pci_io_find(pc, pa->pa_tag, FXP_PCI_IOBA, &iobase, &iosize)) {\n\t\tprintf(\": can't find i/o space\\n\");\n\t\treturn;\n\t}\n\n\tif (bus_space_map(iot, iobase, iosize, 0, &sc->sc_sh)) {\n\t\tprintf(\": can't map i/o space\\n\");\n\t\treturn;\n\t}\n\tsc->sc_st = iot;\n\n\t/*\n\t * Allocate our interrupt.\n\t */\n\tif (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,\n\t    pa->pa_intrline, &ih)) {\n\t\tprintf(\": couldn't map interrupt\\n\");\n\t\treturn;\n\t}\n\n\tintrstr = pci_intr_string(pc, ih);\n\tsc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, fxp_intr, sc,\n\t    self->dv_xname);\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\": couldn't establish interrupt\");\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * revisions\n\t * 2 = 82557\n\t * 4, 6 = 82558\n\t * 8 = 82559\n\t */\n\tsc->not_82557 = (rev >= 4) ? 1 : 0;\n\n\t/* Do generic parts of attach. */\n\tif (fxp_attach_common(sc, enaddr, intrstr)) {\n\t\t/* Failed! */\n\t\treturn;\n\t}\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/ic/fxpvar.h>",
      "#include <dev/ic/fxpreg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void fxp_pci_attach"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fxp_attach_common",
          "args": [
            "sc",
            "enaddr",
            "intrstr"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "fxp_attach_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
          "lines": "357-493",
          "snippet": "int\nfxp_attach_common(sc, enaddr, intrstr)\n\tstruct fxp_softc *sc;\n\tu_int8_t *enaddr;\n\tconst char *intrstr;\n{\n\tstruct ifnet *ifp;\n\tu_int16_t data;\n\tint i;\n\n\t/*\n\t * Reset to a stable state.\n\t */\n\tCSR_WRITE_4(sc, FXP_CSR_PORT, FXP_PORT_SELECTIVE_RESET);\n\tDELAY(10);\n\n\tsc->cbl_base = malloc(sizeof(struct fxp_cb_tx) * FXP_NTXCB,\n\t    M_DEVBUF, M_NOWAIT);\n\tif (sc->cbl_base == NULL)\n\t\tgoto fail;\n\n\tsc->fxp_stats = malloc(sizeof(struct fxp_stats), M_DEVBUF, M_NOWAIT);\n\tif (sc->fxp_stats == NULL)\n\t\tgoto fail;\n\tbzero(sc->fxp_stats, sizeof(struct fxp_stats));\n\n\tsc->mcsp = malloc(sizeof(struct fxp_cb_mcs), M_DEVBUF, M_NOWAIT);\n\tif (sc->mcsp == NULL)\n\t\tgoto fail;\n\n\t/*\n\t * Pre-allocate our receive buffers.\n\t */\n\tfor (i = 0; i < FXP_NRFABUFS; i++) {\n\t\tif (fxp_add_rfabuf(sc, NULL) != 0) {\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t/*\n\t * Find out how large of an SEEPROM we have.\n\t */\n\tfxp_autosize_eeprom(sc);\n\n\t/*\n\t * Get info about the primary PHY\n\t */\n\tfxp_read_eeprom(sc, (u_int16_t *)&data, 6, 1);\n\tsc->phy_primary_addr = data & 0xff;\n\tsc->phy_primary_device = (data >> 8) & 0x3f;\n\tsc->phy_10Mbps_only = data >> 15;\n\n\t/*\n\t * Read MAC address.\n\t */\n\tfxp_read_eeprom(sc, (u_int16_t *)enaddr, 0, 3);\n\n\tifp = &sc->arpcom.ac_if;\n\tbcopy(enaddr, sc->arpcom.ac_enaddr, ETHER_ADDR_LEN);\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;\n\tifp->if_ioctl = fxp_ioctl;\n\tifp->if_start = fxp_start;\n\tifp->if_watchdog = fxp_watchdog;\n\n\tprintf(\": %s, address %s\\n\", intrstr,\n\t    ether_sprintf(sc->arpcom.ac_enaddr));\n\n\t/*\n\t * Initialize our media structures and probe the MII.\n\t */\n\tsc->sc_mii.mii_ifp = ifp;\n\tsc->sc_mii.mii_readreg = fxp_mdi_read;\n\tsc->sc_mii.mii_writereg = fxp_mdi_write;\n\tsc->sc_mii.mii_statchg = fxp_statchg;\n\tifmedia_init(&sc->sc_mii.mii_media, 0, fxp_mediachange,\n\t    fxp_mediastatus);\n\tmii_phy_probe(&sc->sc_dev, &sc->sc_mii, 0xffffffff);\n\t/* If no phy found, just use auto mode */\n\tif (LIST_FIRST(&sc->sc_mii.mii_phys) == NULL) {\n\t\tifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER|IFM_MANUAL,\n\t\t    0, NULL);\n\t\tprintf(\"%s: no phy found, using manual mode\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t}\n\n\tif (ifmedia_match(&sc->sc_mii.mii_media, IFM_ETHER|IFM_MANUAL, 0))\n\t\tifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_MANUAL);\n\telse if (ifmedia_match(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO, 0))\n\t\tifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO);\n\telse\n\t\tifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_10_T);\n\n\t/*\n\t * Attach the interface.\n\t */\n\tif_attach(ifp);\n\t/*\n\t * Let the system queue as many packets as we have available\n\t * TX descriptors.\n\t */\n\tifp->if_snd.ifq_maxlen = FXP_NTXCB - 1;\n\tether_ifattach(ifp);\n#if NBPFILTER > 0\n\tbpfattach(&sc->arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,\n\t    sizeof(struct ether_header));\n#endif\n\n\t/*\n\t * Add shutdown hook so that DMA is disabled prior to reboot. Not\n\t * doing do could allow DMA to corrupt kernel memory during the\n\t * reboot before the driver initializes.\n\t */\n\tshutdownhook_establish(fxp_shutdown, sc);\n\n\t/*\n\t * Add suspend hook, for similiar reasons..\n\t */\n\tpowerhook_establish(fxp_power, sc);\n\n\treturn (0);\n\n fail:\n\tprintf(\"%s: Failed to malloc memory\\n\", sc->sc_dev.dv_xname);\n\tif (sc->cbl_base)\n\t\tfree(sc->cbl_base, M_DEVBUF);\n\tif (sc->fxp_stats)\n\t\tfree(sc->fxp_stats, M_DEVBUF);\n\tif (sc->mcsp)\n\t\tfree(sc->mcsp, M_DEVBUF);\n\t/* frees entire chain */\n\tif (sc->rfa_headm)\n\t\tm_freem(sc->rfa_headm);\n\n\treturn (ENOMEM);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/ic/fxpvar.h>",
            "#include <dev/ic/fxpreg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define FXP_NRFABUFS\t64",
            "#define FXP_NTXCB\t128"
          ],
          "globals_used": [
            "int fxp_mediachange",
            "void fxp_mediastatus",
            "void fxp_start",
            "int fxp_ioctl",
            "void fxp_watchdog",
            "int fxp_add_rfabuf",
            "int fxp_mdi_read",
            "void fxp_mdi_write",
            "void fxp_autosize_eeprom",
            "void fxp_statchg",
            "void fxp_read_eeprom",
            "void\tfxp_shutdown",
            "void\tfxp_power"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define FXP_NRFABUFS\t64\n#define FXP_NTXCB\t128\n\nint fxp_mediachange;\nvoid fxp_mediastatus;\nvoid fxp_start;\nint fxp_ioctl;\nvoid fxp_watchdog;\nint fxp_add_rfabuf;\nint fxp_mdi_read;\nvoid fxp_mdi_write;\nvoid fxp_autosize_eeprom;\nvoid fxp_statchg;\nvoid fxp_read_eeprom;\nvoid\tfxp_shutdown;\nvoid\tfxp_power;\n\nint\nfxp_attach_common(sc, enaddr, intrstr)\n\tstruct fxp_softc *sc;\n\tu_int8_t *enaddr;\n\tconst char *intrstr;\n{\n\tstruct ifnet *ifp;\n\tu_int16_t data;\n\tint i;\n\n\t/*\n\t * Reset to a stable state.\n\t */\n\tCSR_WRITE_4(sc, FXP_CSR_PORT, FXP_PORT_SELECTIVE_RESET);\n\tDELAY(10);\n\n\tsc->cbl_base = malloc(sizeof(struct fxp_cb_tx) * FXP_NTXCB,\n\t    M_DEVBUF, M_NOWAIT);\n\tif (sc->cbl_base == NULL)\n\t\tgoto fail;\n\n\tsc->fxp_stats = malloc(sizeof(struct fxp_stats), M_DEVBUF, M_NOWAIT);\n\tif (sc->fxp_stats == NULL)\n\t\tgoto fail;\n\tbzero(sc->fxp_stats, sizeof(struct fxp_stats));\n\n\tsc->mcsp = malloc(sizeof(struct fxp_cb_mcs), M_DEVBUF, M_NOWAIT);\n\tif (sc->mcsp == NULL)\n\t\tgoto fail;\n\n\t/*\n\t * Pre-allocate our receive buffers.\n\t */\n\tfor (i = 0; i < FXP_NRFABUFS; i++) {\n\t\tif (fxp_add_rfabuf(sc, NULL) != 0) {\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t/*\n\t * Find out how large of an SEEPROM we have.\n\t */\n\tfxp_autosize_eeprom(sc);\n\n\t/*\n\t * Get info about the primary PHY\n\t */\n\tfxp_read_eeprom(sc, (u_int16_t *)&data, 6, 1);\n\tsc->phy_primary_addr = data & 0xff;\n\tsc->phy_primary_device = (data >> 8) & 0x3f;\n\tsc->phy_10Mbps_only = data >> 15;\n\n\t/*\n\t * Read MAC address.\n\t */\n\tfxp_read_eeprom(sc, (u_int16_t *)enaddr, 0, 3);\n\n\tifp = &sc->arpcom.ac_if;\n\tbcopy(enaddr, sc->arpcom.ac_enaddr, ETHER_ADDR_LEN);\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;\n\tifp->if_ioctl = fxp_ioctl;\n\tifp->if_start = fxp_start;\n\tifp->if_watchdog = fxp_watchdog;\n\n\tprintf(\": %s, address %s\\n\", intrstr,\n\t    ether_sprintf(sc->arpcom.ac_enaddr));\n\n\t/*\n\t * Initialize our media structures and probe the MII.\n\t */\n\tsc->sc_mii.mii_ifp = ifp;\n\tsc->sc_mii.mii_readreg = fxp_mdi_read;\n\tsc->sc_mii.mii_writereg = fxp_mdi_write;\n\tsc->sc_mii.mii_statchg = fxp_statchg;\n\tifmedia_init(&sc->sc_mii.mii_media, 0, fxp_mediachange,\n\t    fxp_mediastatus);\n\tmii_phy_probe(&sc->sc_dev, &sc->sc_mii, 0xffffffff);\n\t/* If no phy found, just use auto mode */\n\tif (LIST_FIRST(&sc->sc_mii.mii_phys) == NULL) {\n\t\tifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER|IFM_MANUAL,\n\t\t    0, NULL);\n\t\tprintf(\"%s: no phy found, using manual mode\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t}\n\n\tif (ifmedia_match(&sc->sc_mii.mii_media, IFM_ETHER|IFM_MANUAL, 0))\n\t\tifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_MANUAL);\n\telse if (ifmedia_match(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO, 0))\n\t\tifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO);\n\telse\n\t\tifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_10_T);\n\n\t/*\n\t * Attach the interface.\n\t */\n\tif_attach(ifp);\n\t/*\n\t * Let the system queue as many packets as we have available\n\t * TX descriptors.\n\t */\n\tifp->if_snd.ifq_maxlen = FXP_NTXCB - 1;\n\tether_ifattach(ifp);\n#if NBPFILTER > 0\n\tbpfattach(&sc->arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,\n\t    sizeof(struct ether_header));\n#endif\n\n\t/*\n\t * Add shutdown hook so that DMA is disabled prior to reboot. Not\n\t * doing do could allow DMA to corrupt kernel memory during the\n\t * reboot before the driver initializes.\n\t */\n\tshutdownhook_establish(fxp_shutdown, sc);\n\n\t/*\n\t * Add suspend hook, for similiar reasons..\n\t */\n\tpowerhook_establish(fxp_power, sc);\n\n\treturn (0);\n\n fail:\n\tprintf(\"%s: Failed to malloc memory\\n\", sc->sc_dev.dv_xname);\n\tif (sc->cbl_base)\n\t\tfree(sc->cbl_base, M_DEVBUF);\n\tif (sc->fxp_stats)\n\t\tfree(sc->fxp_stats, M_DEVBUF);\n\tif (sc->mcsp)\n\t\tfree(sc->mcsp, M_DEVBUF);\n\t/* frees entire chain */\n\tif (sc->rfa_headm)\n\t\tm_freem(sc->rfa_headm);\n\n\treturn (ENOMEM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_intr_establish",
          "args": [
            "pc",
            "ih",
            "IPL_NET",
            "fxp_intr",
            "sc",
            "self->dv_xname"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_string",
          "args": [
            "pc",
            "ih"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_map",
          "args": [
            "pc",
            "pa->pa_intrtag",
            "pa->pa_intrpin",
            "pa->pa_intrline",
            "&ih"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "iot",
            "iobase",
            "iosize",
            "0",
            "&sc->sc_sh"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_io_find",
          "args": [
            "pc",
            "pa->pa_tag",
            "FXP_PCI_IOBA",
            "&iobase",
            "&iosize"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "pci_io_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci_map.c",
          "lines": "186-195",
          "snippet": "int\npci_io_find(pc, pcitag, reg, iobasep, iosizep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *iobasep;\n\tbus_size_t *iosizep;\n{\n\treturn (nbsd_pci_io_find(pc, pcitag, reg, 0, iobasep, iosizep, 0));\n}",
          "includes": [
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nbsd_pci_io_find"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int nbsd_pci_io_find;\n\nint\npci_io_find(pc, pcitag, reg, iobasep, iosizep)\n\tpci_chipset_tag_t pc;\n\tpcitag_t pcitag;\n\tint reg;\n\tbus_addr_t *iobasep;\n\tbus_size_t *iosizep;\n{\n\treturn (nbsd_pci_io_find(pc, pcitag, reg, 0, iobasep, iosizep, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PCI_REVISION",
          "args": [
            "pa->pa_class"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid fxp_pci_attach;\n\nvoid\nfxp_pci_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct fxp_softc *sc = (struct fxp_softc *)self;\n\tstruct pci_attach_args *pa = aux;\n\tpci_chipset_tag_t pc = pa->pa_pc;\n\tpci_intr_handle_t ih;\n\tconst char *intrstr = NULL;\n\tu_int8_t enaddr[6];\n\tbus_space_tag_t iot = pa->pa_iot;\n\tbus_addr_t iobase;\n\tbus_size_t iosize;\n\tpcireg_t rev = PCI_REVISION(pa->pa_class);\n\n\tif (pci_io_find(pc, pa->pa_tag, FXP_PCI_IOBA, &iobase, &iosize)) {\n\t\tprintf(\": can't find i/o space\\n\");\n\t\treturn;\n\t}\n\n\tif (bus_space_map(iot, iobase, iosize, 0, &sc->sc_sh)) {\n\t\tprintf(\": can't map i/o space\\n\");\n\t\treturn;\n\t}\n\tsc->sc_st = iot;\n\n\t/*\n\t * Allocate our interrupt.\n\t */\n\tif (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,\n\t    pa->pa_intrline, &ih)) {\n\t\tprintf(\": couldn't map interrupt\\n\");\n\t\treturn;\n\t}\n\n\tintrstr = pci_intr_string(pc, ih);\n\tsc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, fxp_intr, sc,\n\t    self->dv_xname);\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\": couldn't establish interrupt\");\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * revisions\n\t * 2 = 82557\n\t * 4, 6 = 82558\n\t * 8 = 82559\n\t */\n\tsc->not_82557 = (rev >= 4) ? 1 : 0;\n\n\t/* Do generic parts of attach. */\n\tif (fxp_attach_common(sc, enaddr, intrstr)) {\n\t\t/* Failed! */\n\t\treturn;\n\t}\n}"
  },
  {
    "function_name": "fxp_pci_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_fxp_pci.c",
    "lines": "107-125",
    "snippet": "int\nfxp_pci_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match;\n\tvoid *aux;\n{\n\tstruct pci_attach_args *pa = aux;\n\n\tif (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_INTEL)\n\t\treturn (0);\n\n\tswitch (PCI_PRODUCT(pa->pa_id)) {\n\tcase PCI_PRODUCT_INTEL_82557:\n\tcase PCI_PRODUCT_INTEL_82559:\n\t\treturn (1);\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/ic/fxpvar.h>",
      "#include <dev/ic/fxpreg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int fxp_pci_match"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PCI_PRODUCT",
          "args": [
            "pa->pa_id"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDOR",
          "args": [
            "pa->pa_id"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint fxp_pci_match;\n\nint\nfxp_pci_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match;\n\tvoid *aux;\n{\n\tstruct pci_attach_args *pa = aux;\n\n\tif (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_INTEL)\n\t\treturn (0);\n\n\tswitch (PCI_PRODUCT(pa->pa_id)) {\n\tcase PCI_PRODUCT_INTEL_82557:\n\tcase PCI_PRODUCT_INTEL_82559:\n\t\treturn (1);\n\t}\n\n\treturn (0);\n}"
  }
]