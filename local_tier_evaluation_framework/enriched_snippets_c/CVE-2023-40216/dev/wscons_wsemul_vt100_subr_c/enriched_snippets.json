[
  {
    "function_name": "vt100_decmode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsemul_vt100_subr.c",
    "lines": "779-856",
    "snippet": "static int\nvt100_decmode(edp, nr, op)\n\tstruct wsemul_vt100_emuldata *edp;\n\tint nr, op;\n{\n\tint res = 0; /* default: unknown */\n\tint flags;\n\n\tflags = edp->flags;\n\tswitch (nr) {\n\t    case 1: /* DECCKM application/nomal cursor keys */\n\t\tif (op == VTMODE_SET)\n\t\t\tflags |= VTFL_APPLCURSOR;\n\t\telse if (op == VTMODE_RESET)\n\t\t\tflags &= ~VTFL_APPLCURSOR;\n\t\tres = ((flags & VTFL_APPLCURSOR) ? 1 : 2);\n\t\tbreak;\n\t    case 2: /* DECANM ANSI vt100/vt52 */\n\t\tres = 3; /* permanently set ??? */\n\t\tbreak;\n\t    case 3: /* DECCOLM 132/80 cols */\n\t    case 4: /* DECSCLM smooth/jump scroll */\n\t    case 5: /* DECSCNM light/dark background */\n\t\tres = 4; /* all permanently reset ??? */\n\t\tbreak;\n\t    case 6: /* DECOM move within/outside margins */\n\t\tif (op == VTMODE_SET)\n\t\t\tflags |= VTFL_DECOM;\n\t\telse if (op == VTMODE_RESET)\n\t\t\tflags &= ~VTFL_DECOM;\n\t\tres = ((flags & VTFL_DECOM) ? 1 : 2);\n\t\tbreak;\n\t    case 7: /* DECAWM autowrap */\n\t\tif (op == VTMODE_SET)\n\t\t\tflags |= VTFL_DECAWM;\n\t\telse if (op == VTMODE_RESET)\n\t\t\tflags &= ~VTFL_DECAWM;\n\t\tres = ((flags & VTFL_DECAWM) ? 1 : 2);\n\t\tbreak;\n\t    case 8: /* DECARM keyboard autorepeat */\n\t\tbreak;\n\t    case 18: /* DECPFF print form feed */\n\t\tbreak;\n\t    case 19: /* DECPEX printer extent: screen/scrolling region */\n\t\tbreak;\n\t    case 25: /* DECTCEM text cursor on/off */\n\t\tif (op == VTMODE_SET)\n\t\t\tflags |= VTFL_CURSORON;\n\t\telse if (op == VTMODE_RESET)\n\t\t\tflags &= ~VTFL_CURSORON;\n\t\tif (flags != edp->flags)\n\t\t\t(*edp->emulops->cursor)(edp->emulcookie,\n\t\t\t\t\t\tflags & VTFL_CURSORON,\n\t\t\t\t\t\tedp->crow, edp->ccol);\n\t\tres = ((flags & VTFL_CURSORON) ? 1 : 2);\n\t\tbreak;\n\t    case 42: /* DECNRCM use 7-bit NRC /\n\t\t      7/8 bit from DEC multilingual or ISO-latin-1*/\n\t\tif (op == VTMODE_SET)\n\t\t\tflags |= VTFL_NATCHARSET;\n\t\telse if (op == VTMODE_RESET)\n\t\t\tflags &= ~VTFL_NATCHARSET;\n\t\tres = ((flags & VTFL_NATCHARSET) ? 1 : 2);\n\t\tbreak;\n\t    case 66: /* DECNKM numeric keypad */\n\t\tbreak;\n\t    case 68: /* DECKBUM keyboard usage data processing/typewriter */\n\t\tbreak;\n\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\tprintf(\"DEC mode %d unknown\\n\", nr);\n#endif\n\t\tbreak;\n\t}\n\tedp->flags = flags;\n\n\treturn (res);\n}",
    "includes": [
      "#include <dev/wscons/wsemul_vt100var.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define VTMODE_RESET 44",
      "#define VTMODE_SET 33"
    ],
    "globals_used": [
      "static int vt100_decmode"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"DEC mode %d unknown\\n\"",
            "nr"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "edp->emulcookie",
            "flags & VTFL_CURSORON",
            "edp->crow",
            "edp->ccol"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsemul_vt100var.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define VTMODE_RESET 44\n#define VTMODE_SET 33\n\nstatic int vt100_decmode;\n\nstatic int\nvt100_decmode(edp, nr, op)\n\tstruct wsemul_vt100_emuldata *edp;\n\tint nr, op;\n{\n\tint res = 0; /* default: unknown */\n\tint flags;\n\n\tflags = edp->flags;\n\tswitch (nr) {\n\t    case 1: /* DECCKM application/nomal cursor keys */\n\t\tif (op == VTMODE_SET)\n\t\t\tflags |= VTFL_APPLCURSOR;\n\t\telse if (op == VTMODE_RESET)\n\t\t\tflags &= ~VTFL_APPLCURSOR;\n\t\tres = ((flags & VTFL_APPLCURSOR) ? 1 : 2);\n\t\tbreak;\n\t    case 2: /* DECANM ANSI vt100/vt52 */\n\t\tres = 3; /* permanently set ??? */\n\t\tbreak;\n\t    case 3: /* DECCOLM 132/80 cols */\n\t    case 4: /* DECSCLM smooth/jump scroll */\n\t    case 5: /* DECSCNM light/dark background */\n\t\tres = 4; /* all permanently reset ??? */\n\t\tbreak;\n\t    case 6: /* DECOM move within/outside margins */\n\t\tif (op == VTMODE_SET)\n\t\t\tflags |= VTFL_DECOM;\n\t\telse if (op == VTMODE_RESET)\n\t\t\tflags &= ~VTFL_DECOM;\n\t\tres = ((flags & VTFL_DECOM) ? 1 : 2);\n\t\tbreak;\n\t    case 7: /* DECAWM autowrap */\n\t\tif (op == VTMODE_SET)\n\t\t\tflags |= VTFL_DECAWM;\n\t\telse if (op == VTMODE_RESET)\n\t\t\tflags &= ~VTFL_DECAWM;\n\t\tres = ((flags & VTFL_DECAWM) ? 1 : 2);\n\t\tbreak;\n\t    case 8: /* DECARM keyboard autorepeat */\n\t\tbreak;\n\t    case 18: /* DECPFF print form feed */\n\t\tbreak;\n\t    case 19: /* DECPEX printer extent: screen/scrolling region */\n\t\tbreak;\n\t    case 25: /* DECTCEM text cursor on/off */\n\t\tif (op == VTMODE_SET)\n\t\t\tflags |= VTFL_CURSORON;\n\t\telse if (op == VTMODE_RESET)\n\t\t\tflags &= ~VTFL_CURSORON;\n\t\tif (flags != edp->flags)\n\t\t\t(*edp->emulops->cursor)(edp->emulcookie,\n\t\t\t\t\t\tflags & VTFL_CURSORON,\n\t\t\t\t\t\tedp->crow, edp->ccol);\n\t\tres = ((flags & VTFL_CURSORON) ? 1 : 2);\n\t\tbreak;\n\t    case 42: /* DECNRCM use 7-bit NRC /\n\t\t      7/8 bit from DEC multilingual or ISO-latin-1*/\n\t\tif (op == VTMODE_SET)\n\t\t\tflags |= VTFL_NATCHARSET;\n\t\telse if (op == VTMODE_RESET)\n\t\t\tflags &= ~VTFL_NATCHARSET;\n\t\tres = ((flags & VTFL_NATCHARSET) ? 1 : 2);\n\t\tbreak;\n\t    case 66: /* DECNKM numeric keypad */\n\t\tbreak;\n\t    case 68: /* DECKBUM keyboard usage data processing/typewriter */\n\t\tbreak;\n\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\tprintf(\"DEC mode %d unknown\\n\", nr);\n#endif\n\t\tbreak;\n\t}\n\tedp->flags = flags;\n\n\treturn (res);\n}"
  },
  {
    "function_name": "vt100_ansimode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsemul_vt100_subr.c",
    "lines": "744-777",
    "snippet": "static int\nvt100_ansimode(edp, nr, op)\n\tstruct wsemul_vt100_emuldata *edp;\n\tint nr, op;\n{\n\tint res = 0; /* default: unknown */\n\n\tswitch (nr) {\n\t    case 2: /* KAM keyboard locked/unlocked */\n\t\tbreak;\n\t    case 3: /* CRM control representation */\n\t\tbreak;\n\t    case 4: /* IRM insert/replace characters */\n\t\tif (op == VTMODE_SET)\n\t\t\tedp->flags |= VTFL_INSERTMODE;\n\t\telse if (op == VTMODE_RESET)\n\t\t\tedp->flags &= ~VTFL_INSERTMODE;\n\t\tres = ((edp->flags & VTFL_INSERTMODE) ? 1 : 2);\n\t\tbreak;\n\t    case 10: /* HEM horizontal editing (permanently reset) */\n\t\tres = 4;\n\t\tbreak;\n\t    case 12: /* SRM local echo off/on */\n\t\tres = 4; /* permanently reset ??? */\n\t\tbreak;\n\t    case 20: /* LNM newline = newline/linefeed */\n\t\tbreak;\n\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\tprintf(\"ANSI mode %d unknown\\n\", nr);\n#endif\n\t}\n\treturn (res);\n}",
    "includes": [
      "#include <dev/wscons/wsemul_vt100var.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define VTMODE_RESET 44",
      "#define VTMODE_SET 33"
    ],
    "globals_used": [
      "static int vt100_ansimode"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ANSI mode %d unknown\\n\"",
            "nr"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsemul_vt100var.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define VTMODE_RESET 44\n#define VTMODE_SET 33\n\nstatic int vt100_ansimode;\n\nstatic int\nvt100_ansimode(edp, nr, op)\n\tstruct wsemul_vt100_emuldata *edp;\n\tint nr, op;\n{\n\tint res = 0; /* default: unknown */\n\n\tswitch (nr) {\n\t    case 2: /* KAM keyboard locked/unlocked */\n\t\tbreak;\n\t    case 3: /* CRM control representation */\n\t\tbreak;\n\t    case 4: /* IRM insert/replace characters */\n\t\tif (op == VTMODE_SET)\n\t\t\tedp->flags |= VTFL_INSERTMODE;\n\t\telse if (op == VTMODE_RESET)\n\t\t\tedp->flags &= ~VTFL_INSERTMODE;\n\t\tres = ((edp->flags & VTFL_INSERTMODE) ? 1 : 2);\n\t\tbreak;\n\t    case 10: /* HEM horizontal editing (permanently reset) */\n\t\tres = 4;\n\t\tbreak;\n\t    case 12: /* SRM local echo off/on */\n\t\tres = 4; /* permanently reset ??? */\n\t\tbreak;\n\t    case 20: /* LNM newline = newline/linefeed */\n\t\tbreak;\n\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\tprintf(\"ANSI mode %d unknown\\n\", nr);\n#endif\n\t}\n\treturn (res);\n}"
  },
  {
    "function_name": "wsemul_vt100_handle_dcs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsemul_vt100_subr.c",
    "lines": "704-742",
    "snippet": "void\nwsemul_vt100_handle_dcs(edp)\n\tstruct wsemul_vt100_emuldata *edp;\n{\n\tint i, pos;\n\n\tswitch (edp->dcstype) {\n\t    case 0: /* not handled */\n\t\treturn;\n\t    case DCSTYPE_TABRESTORE:\n\t\tKASSERT(edp->tabs != 0);\n\t\tbzero(edp->tabs, edp->ncols);\n\t\tpos = 0;\n\t\tfor (i = 0; i < edp->dcspos; i++) {\n\t\t\tchar c = edp->dcsarg[i];\n\t\t\tswitch (c) {\n\t\t\t    case '0': case '1': case '2': case '3': case '4':\n\t\t\t    case '5': case '6': case '7': case '8': case '9':\n\t\t\t\tpos = pos * 10 + (edp->dcsarg[i] - '0');\n\t\t\t\tbreak;\n\t\t\t    case '/':\n\t\t\t\tif (pos > 0)\n\t\t\t\t\tedp->tabs[pos - 1] = 1;\n\t\t\t\tpos = 0;\n\t\t\t\tbreak;\n\t\t\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\t\t\tprintf(\"unknown char %c in DCS\\n\", c);\n#endif\n\t\t\t}\n\t\t}\n\t\tif (pos > 0)\n\t\t\tedp->tabs[pos - 1] = 1;\n\t\tbreak;\n\t    default:\n\t\tpanic(\"wsemul_vt100_handle_dcs: bad type %d\", edp->dcstype);\n\t}\n\tedp->dcstype = 0;\n}",
    "includes": [
      "#include <dev/wscons/wsemul_vt100var.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"wsemul_vt100_handle_dcs: bad type %d\"",
            "edp->dcstype"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"unknown char %c in DCS\\n\"",
            "c"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "edp->tabs",
            "edp->ncols"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KASSERT",
          "args": [
            "edp->tabs != 0"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsemul_vt100var.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwsemul_vt100_handle_dcs(edp)\n\tstruct wsemul_vt100_emuldata *edp;\n{\n\tint i, pos;\n\n\tswitch (edp->dcstype) {\n\t    case 0: /* not handled */\n\t\treturn;\n\t    case DCSTYPE_TABRESTORE:\n\t\tKASSERT(edp->tabs != 0);\n\t\tbzero(edp->tabs, edp->ncols);\n\t\tpos = 0;\n\t\tfor (i = 0; i < edp->dcspos; i++) {\n\t\t\tchar c = edp->dcsarg[i];\n\t\t\tswitch (c) {\n\t\t\t    case '0': case '1': case '2': case '3': case '4':\n\t\t\t    case '5': case '6': case '7': case '8': case '9':\n\t\t\t\tpos = pos * 10 + (edp->dcsarg[i] - '0');\n\t\t\t\tbreak;\n\t\t\t    case '/':\n\t\t\t\tif (pos > 0)\n\t\t\t\t\tedp->tabs[pos - 1] = 1;\n\t\t\t\tpos = 0;\n\t\t\t\tbreak;\n\t\t\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\t\t\tprintf(\"unknown char %c in DCS\\n\", c);\n#endif\n\t\t\t}\n\t\t}\n\t\tif (pos > 0)\n\t\t\tedp->tabs[pos - 1] = 1;\n\t\tbreak;\n\t    default:\n\t\tpanic(\"wsemul_vt100_handle_dcs: bad type %d\", edp->dcstype);\n\t}\n\tedp->dcstype = 0;\n}"
  },
  {
    "function_name": "vt100_selectattribute",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsemul_vt100_subr.c",
    "lines": "629-698",
    "snippet": "static int\nvt100_selectattribute(edp, flags, fgcol, bgcol, attr, bkgdattr)\n\tstruct wsemul_vt100_emuldata *edp;\n\tint flags, fgcol, bgcol;\n\tlong *attr, *bkgdattr;\n{\n\tint error;\n\n\tif ((flags & WSATTR_WSCOLORS) &&\n\t    !(edp->scrcapabilities & WSSCREEN_WSCOLORS)) {\n\t\tflags &= ~WSATTR_WSCOLORS;\n#ifdef VT100_DEBUG\n\t\tprintf(\"colors ignored (impossible)\\n\");\n#endif\n\t}\n\terror = (*edp->emulops->alloc_attr)(edp->emulcookie, fgcol, bgcol,\n\t\t\t\t\t    flags & WSATTR_WSCOLORS, bkgdattr);\n\tif (error)\n\t\treturn (error);\n\n\tif ((flags & WSATTR_HILIT) &&\n\t    !(edp->scrcapabilities & WSSCREEN_HILIT)) {\n\t\tflags &= ~WSATTR_HILIT;\n\t\tif (edp->scrcapabilities & WSSCREEN_WSCOLORS) {\n\t\t\tfgcol = WSCOL_RED;\n\t\t\tflags |= WSATTR_WSCOLORS;\n\t\t} else {\n#ifdef VT100_DEBUG\n\t\t\tprintf(\"bold ignored (impossible)\\n\");\n#endif\n\t\t}\n\t}\n\tif ((flags & WSATTR_UNDERLINE) &&\n\t    !(edp->scrcapabilities & WSSCREEN_UNDERLINE)) {\n\t\tflags &= ~WSATTR_UNDERLINE;\n\t\tif (edp->scrcapabilities & WSSCREEN_WSCOLORS) {\n\t\t\tbgcol = WSCOL_BROWN;\n\t\t\tflags &= ~WSATTR_UNDERLINE;\n\t\t\tflags |= WSATTR_WSCOLORS;\n\t\t} else {\n#ifdef VT100_DEBUG\n\t\t\tprintf(\"underline ignored (impossible)\\n\");\n#endif\n\t\t}\n\t}\n\tif ((flags & WSATTR_BLINK) &&\n\t    !(edp->scrcapabilities & WSSCREEN_BLINK)) {\n\t\tflags &= ~WSATTR_BLINK;\n#ifdef VT100_DEBUG\n\t\tprintf(\"blink ignored (impossible)\\n\");\n#endif\n\t}\n\tif ((flags & WSATTR_REVERSE) &&\n\t    !(edp->scrcapabilities & WSSCREEN_REVERSE)) {\n\t\tflags &= ~WSATTR_REVERSE;\n\t\tif (edp->scrcapabilities & WSSCREEN_WSCOLORS) {\n\t\t\tint help;\n\t\t\thelp = bgcol;\n\t\t\tbgcol = fgcol;\n\t\t\tfgcol = help;\n\t\t\tflags |= WSATTR_WSCOLORS;\n\t\t} else {\n#ifdef VT100_DEBUG\n\t\t\tprintf(\"reverse ignored (impossible)\\n\");\n#endif\n\t\t}\n\t}\n\treturn ((*edp->emulops->alloc_attr)(edp->emulcookie, fgcol, bgcol,\n\t\t\t\t\t    flags, attr));\n}",
    "includes": [
      "#include <dev/wscons/wsemul_vt100var.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int vt100_selectattribute"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "edp->emulcookie",
            "fgcol",
            "bgcol",
            "flags",
            "attr"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"reverse ignored (impossible)\\n\""
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "edp->emulcookie",
            "fgcol",
            "bgcol",
            "flags & WSATTR_WSCOLORS",
            "bkgdattr"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsemul_vt100var.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int vt100_selectattribute;\n\nstatic int\nvt100_selectattribute(edp, flags, fgcol, bgcol, attr, bkgdattr)\n\tstruct wsemul_vt100_emuldata *edp;\n\tint flags, fgcol, bgcol;\n\tlong *attr, *bkgdattr;\n{\n\tint error;\n\n\tif ((flags & WSATTR_WSCOLORS) &&\n\t    !(edp->scrcapabilities & WSSCREEN_WSCOLORS)) {\n\t\tflags &= ~WSATTR_WSCOLORS;\n#ifdef VT100_DEBUG\n\t\tprintf(\"colors ignored (impossible)\\n\");\n#endif\n\t}\n\terror = (*edp->emulops->alloc_attr)(edp->emulcookie, fgcol, bgcol,\n\t\t\t\t\t    flags & WSATTR_WSCOLORS, bkgdattr);\n\tif (error)\n\t\treturn (error);\n\n\tif ((flags & WSATTR_HILIT) &&\n\t    !(edp->scrcapabilities & WSSCREEN_HILIT)) {\n\t\tflags &= ~WSATTR_HILIT;\n\t\tif (edp->scrcapabilities & WSSCREEN_WSCOLORS) {\n\t\t\tfgcol = WSCOL_RED;\n\t\t\tflags |= WSATTR_WSCOLORS;\n\t\t} else {\n#ifdef VT100_DEBUG\n\t\t\tprintf(\"bold ignored (impossible)\\n\");\n#endif\n\t\t}\n\t}\n\tif ((flags & WSATTR_UNDERLINE) &&\n\t    !(edp->scrcapabilities & WSSCREEN_UNDERLINE)) {\n\t\tflags &= ~WSATTR_UNDERLINE;\n\t\tif (edp->scrcapabilities & WSSCREEN_WSCOLORS) {\n\t\t\tbgcol = WSCOL_BROWN;\n\t\t\tflags &= ~WSATTR_UNDERLINE;\n\t\t\tflags |= WSATTR_WSCOLORS;\n\t\t} else {\n#ifdef VT100_DEBUG\n\t\t\tprintf(\"underline ignored (impossible)\\n\");\n#endif\n\t\t}\n\t}\n\tif ((flags & WSATTR_BLINK) &&\n\t    !(edp->scrcapabilities & WSSCREEN_BLINK)) {\n\t\tflags &= ~WSATTR_BLINK;\n#ifdef VT100_DEBUG\n\t\tprintf(\"blink ignored (impossible)\\n\");\n#endif\n\t}\n\tif ((flags & WSATTR_REVERSE) &&\n\t    !(edp->scrcapabilities & WSSCREEN_REVERSE)) {\n\t\tflags &= ~WSATTR_REVERSE;\n\t\tif (edp->scrcapabilities & WSSCREEN_WSCOLORS) {\n\t\t\tint help;\n\t\t\thelp = bgcol;\n\t\t\tbgcol = fgcol;\n\t\t\tfgcol = help;\n\t\t\tflags |= WSATTR_WSCOLORS;\n\t\t} else {\n#ifdef VT100_DEBUG\n\t\t\tprintf(\"reverse ignored (impossible)\\n\");\n#endif\n\t\t}\n\t}\n\treturn ((*edp->emulops->alloc_attr)(edp->emulcookie, fgcol, bgcol,\n\t\t\t\t\t    flags, attr));\n}"
  },
  {
    "function_name": "wsemul_vt100_handle_csi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsemul_vt100_subr.c",
    "lines": "195-622",
    "snippet": "void\nwsemul_vt100_handle_csi(edp, c)\n\tstruct wsemul_vt100_emuldata *edp;\n\tu_char c;\n{\n\tint n, help, flags, fgcol, bgcol;\n\tlong attr, bkgdattr;\n\n#define A3(a, b, c) (((a) << 16) | ((b) << 8) | (c))\n\tswitch (A3(edp->modif1, edp->modif2, c)) {\n\t    case A3('>', '\\0', 'c'): /* DA secondary */\n\t\twsdisplay_emulinput(edp->cbcookie, WSEMUL_VT_ID2,\n\t\t\t\t    sizeof(WSEMUL_VT_ID2));\n\t\tbreak;\n\n\t    case A3('\\0', '\\0', 'J'): /* ED selective erase in display */\n\t    case A3('?', '\\0', 'J'): /* DECSED selective erase in display */\n\t\twsemul_vt100_ed(edp, ARG(0));\n\t\tbreak;\n\t    case A3('\\0', '\\0', 'K'): /* EL selective erase in line */\n\t    case A3('?', '\\0', 'K'): /* DECSEL selective erase in line */\n\t\twsemul_vt100_el(edp, ARG(0));\n\t\tbreak;\n\t    case A3('\\0', '\\0', 'h'): /* SM */\n\t\tfor (n = 0; n < edp->nargs; n++)\n\t\t\tvt100_ansimode(edp, ARG(n), VTMODE_SET);\n\t\tbreak;\n\t    case A3('?', '\\0', 'h'): /* DECSM */\n\t\tfor (n = 0; n < edp->nargs; n++)\n\t\t\tvt100_decmode(edp, ARG(n), VTMODE_SET);\n\t\tbreak;\n\t    case A3('\\0', '\\0', 'l'): /* RM */\n\t\tfor (n = 0; n < edp->nargs; n++)\n\t\t\tvt100_ansimode(edp, ARG(n), VTMODE_RESET);\n\t\tbreak;;\n\t    case A3('?', '\\0', 'l'): /* DECRM */\n\t\tfor (n = 0; n < edp->nargs; n++)\n\t\t\tvt100_decmode(edp, ARG(n), VTMODE_RESET);\n\t\tbreak;;\n\t    case A3('\\0', '$', 'p'): /* DECRQM request mode ANSI */\n\t\tvt100_ansimode(edp, ARG(0), VTMODE_REPORT);\n\t\tbreak;\n\t    case A3('?', '$', 'p'): /* DECRQM request mode DEC */\n\t\tvt100_decmode(edp, ARG(0), VTMODE_REPORT);\n\t\tbreak;\n\t    case A3('\\0', '\\0', 'i'): /* MC printer controller mode */\n\t    case A3('?', '\\0', 'i'): /* MC printer controller mode */\n\t\tswitch (ARG(0)) {\n\t\t    case 0: /* print screen */\n\t\t    case 1: /* print cursor line */\n\t\t    case 4: /* off */\n\t\t    case 5: /* on */\n#ifdef VT100_PRINTNOTIMPL\n\t\t\tprintf(\"CSI%di ignored\\n\", ARG(0));\n#endif\n\t\t\tbreak;\n\t\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\t\tprintf(\"CSI%di unknown\\n\", ARG(0));\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n#define A2(a, b) (((a) << 8) | (b))\n\t    case A2('!', 'p'): /* DECSTR soft reset VT300 only */\n\t\twsemul_vt100_reset(edp);\n\t\tbreak;\n\n\t    case A2('\"', 'p'): /* DECSCL */\n\t\tswitch (ARG(0)) {\n\t\t    case 61: /* VT100 mode (no further arguments!) */\n\t\t\tbreak;\n\t\t    case 62:\n\t\t    case 63: /* VT300 mode */\n\t\t\tbreak;\n\t\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\t\tprintf(\"CSI%d\\\"p unknown\\n\", ARG(0));\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tswitch (ARG(1)) {\n\t\t    case 0:\n\t\t    case 2: /* 8-bit controls */\n#ifdef VT100_PRINTNOTIMPL\n\t\t\tprintf(\"CSI%d;%d\\\"p ignored\\n\", ARG(0), ARG(1));\n#endif\n\t\t\tbreak;\n\t\t    case 1: /* 7-bit controls */\n\t\t\tbreak;\n\t\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\t\tprintf(\"CSI%d;%d\\\"p unknown\\n\", ARG(0), ARG(1));\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t    case A2('\"', 'q'): /* DECSCA select character attribute VT300 */\n\t\tswitch (ARG(0)) {\n\t\t    case 0:\n\t\t    case 1: /* erasable */\n\t\t\tbreak;\n\t\t    case 2: /* not erasable */\n#ifdef VT100_PRINTNOTIMPL\n\t\t\tprintf(\"CSI2\\\"q ignored\\n\");\n#endif\n\t\t\tbreak;\n\t\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\t\tprintf(\"CSI%d\\\"q unknown\\n\", ARG(0));\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t    case A2('$', 'u'): /* DECRQTSR request terminal status report */\n\t\tswitch (ARG(0)) {\n\t\t    case 0: /* ignored */\n\t\t\tbreak;\n\t\t    case 1: /* terminal state report */\n#ifdef VT100_PRINTNOTIMPL\n\t\t\tprintf(\"CSI1$u ignored\\n\");\n#endif\n\t\t\tbreak;\n\t\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\t\tprintf(\"CSI%d$u unknown\\n\", ARG(0));\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t    case A2('$', 'w'): /* DECRQPSR request presentation status report\n\t\t\t\t(VT300 only) */\n\t\tswitch (ARG(0)) {\n\t\t    case 0: /* error */\n\t\t\tbreak;\n\t\t    case 1: /* cursor information report */\n#ifdef VT100_PRINTNOTIMPL\n\t\t\tprintf(\"CSI1$w ignored\\n\");\n#endif\n\t\t\tbreak;\n\t\t    case 2: /* tab stop report */\n\t\t\t{\n\t\t\tint i, n, ps = 0;\n\t\t\tchar buf[20];\n\t\t\tKASSERT(edp->tabs != 0);\n\t\t\twsdisplay_emulinput(edp->cbcookie, \"\\033P2$u\", 5);\n\t\t\tfor (i = 0; i < edp->ncols; i++)\n\t\t\t\tif (edp->tabs[i]) {\n\t\t\t\t\tn = sprintf(buf, \"%s%d\",\n\t\t\t\t\t\t    (ps ? \"/\" : \"\"), i + 1);\n\t\t\t\t\twsdisplay_emulinput(edp->cbcookie,\n\t\t\t\t\t\t\t    buf, n);\n\t\t\t\t\tps = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\twsdisplay_emulinput(edp->cbcookie, \"\\033\\\\\", 2);\n\t\t\tbreak;\n\t\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\t\tprintf(\"CSI%d$w unknown\\n\", ARG(0));\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t    case A2('$', '}'): /* DECSASD select active status display */\n\t\tswitch (ARG(0)) {\n\t\t    case 0: /* main display */\n\t\t    case 1: /* status line */\n#ifdef VT100_PRINTNOTIMPL\n\t\t\tprintf(\"CSI%d$} ignored\\n\", ARG(0));\n#endif\n\t\t\tbreak;\n\t\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\t\tprintf(\"CSI%d$} unknown\\n\", ARG(0));\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t    case A2('$', '~'): /* DECSSDD select status line type */\n\t\tswitch (ARG(0)) {\n\t\t    case 0: /* none */\n\t\t    case 1: /* indicator */\n\t\t    case 2: /* host-writable */\n#ifdef VT100_PRINTNOTIMPL\n\t\t\tprintf(\"CSI%d$~ ignored\\n\", ARG(0));\n#endif\n\t\t\tbreak;\n\t\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\t\tprintf(\"CSI%d$~ unknown\\n\", ARG(0));\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t    case A2('&', 'u'): /* DECRQUPSS request user preferred\n\t\t\t\t  supplemental set */\n\t\twsdisplay_emulinput(edp->emulcookie, \"\\033P0!u%5\\033\\\\\", 9);\n\t\tbreak;\n\n\t    case '@': /* ICH insert character VT300 only */\n\t\tn = min(DEF1_ARG(0), COLS_LEFT + 1);\n\t\thelp = NCOLS - (edp->ccol + n);\n\t\tif (help > 0)\n\t\t\tCOPYCOLS(edp->ccol, edp->ccol + n, help);\n\t\tERASECOLS(edp->ccol, n, edp->bkgdattr);\n\t\tbreak;\n\t    case 'A': /* CUU */\n\t\tedp->crow -= min(DEF1_ARG(0), ROWS_ABOVE);\n\t\tCHECK_DW;\n\t\tbreak;\n\t    case 'B': /* CUD */\n\t\tedp->crow += min(DEF1_ARG(0), ROWS_BELOW);\n\t\tCHECK_DW;\n\t\tbreak;\n\t    case 'C': /* CUF */\n\t\tedp->ccol += min(DEF1_ARG(0), COLS_LEFT);\n\t\tbreak;\n\t    case 'D': /* CUB */\n\t\tedp->ccol -= min(DEF1_ARG(0), edp->ccol);\n\t\tedp->flags &= ~VTFL_LASTCHAR;\n\t\tbreak;\n\t    case 'H': /* CUP */\n\t    case 'f': /* HVP */\n\t\tif (edp->flags & VTFL_DECOM)\n\t\t\tedp->crow = edp->scrreg_startrow +\n\t\t\t    min(DEF1_ARG(0), edp->scrreg_nrows) - 1;\n\t\telse\n\t\t\tedp->crow = min(DEF1_ARG(0), edp->nrows) - 1;\n\t\tCHECK_DW;\n\t\tedp->ccol = min(DEF1_ARG(1), NCOLS) - 1;\n\t\tedp->flags &= ~VTFL_LASTCHAR;\n\t\tbreak;\n\t    case 'L': /* IL insert line */\n\t    case 'M': /* DL delete line */\n\t\tn = min(DEF1_ARG(0), ROWS_BELOW + 1);\n\t\t{\n\t\tint savscrstartrow, savscrnrows;\n\t\tsavscrstartrow = edp->scrreg_startrow;\n\t\tsavscrnrows = edp->scrreg_nrows;\n\t\tedp->scrreg_nrows -= ROWS_ABOVE;\n\t\tedp->scrreg_startrow = edp->crow;\n\t\tif (c == 'L')\n\t\t\twsemul_vt100_scrolldown(edp, n);\n\t\telse\n\t\t\twsemul_vt100_scrollup(edp, n);\n\t\tedp->scrreg_startrow = savscrstartrow;\n\t\tedp->scrreg_nrows = savscrnrows;\n\t\t}\n\t\tbreak;\n\t    case 'P': /* DCH delete character */\n\t\tn = min(DEF1_ARG(0), COLS_LEFT + 1);\n\t\thelp = NCOLS - (edp->ccol + n);\n\t\tif (help > 0)\n\t\t\tCOPYCOLS(edp->ccol + n, edp->ccol, help);\n\t\tERASECOLS(NCOLS - n, n, edp->bkgdattr);\n\t\tbreak;\n\t    case 'X': /* ECH erase character */\n\t\tn = min(DEF1_ARG(0), COLS_LEFT + 1);\n\t\tERASECOLS(edp->ccol, n, edp->bkgdattr);\n\t\tbreak;\n\t    case 'c': /* DA primary */\n\t\tif (ARG(0) == 0)\n\t\t\twsdisplay_emulinput(edp->cbcookie, WSEMUL_VT_ID1,\n\t\t\t\t\t    sizeof(WSEMUL_VT_ID1));\n\t\tbreak;\n\t    case 'g': /* TBC */\n\t\tKASSERT(edp->tabs != 0);\n\t\tswitch (ARG(0)) {\n\t\t    case 0:\n\t\t\tedp->tabs[edp->ccol] = 0;\n\t\t\tbreak;\n\t\t    case 3:\n\t\t\tbzero(edp->tabs, edp->ncols);\n\t\t\tbreak;\n\t\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\t\tprintf(\"CSI%dg unknown\\n\", ARG(0));\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t    case 'm': /* SGR select graphic rendition */\n\t\tflags = edp->attrflags;\n\t\tfgcol = edp->fgcol;\n\t\tbgcol = edp->bgcol;\n\t\tfor (n = 0; n < edp->nargs; n++) {\n\t\t\tswitch (ARG(n)) {\n\t\t\t    case 0: /* reset */\n\t\t\t\tif (n == edp->nargs - 1) {\n\t\t\t\t\tedp->bkgdattr = edp->curattr = edp->defattr;\n\t\t\t\t\tedp->attrflags = 0;\n\t\t\t\t\tedp->fgcol = WSCOL_WHITE;\n\t\t\t\t\tedp->bgcol = WSCOL_BLACK;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tflags = 0;\n\t\t\t\tfgcol = WSCOL_WHITE;\n\t\t\t\tbgcol = WSCOL_BLACK;\n\t\t\t\tbreak;\n\t\t\t    case 1: /* bold */\n\t\t\t\tflags |= WSATTR_HILIT;\n\t\t\t\tbreak;\n\t\t\t    case 4: /* underline */\n\t\t\t\tflags |= WSATTR_UNDERLINE;\n\t\t\t\tbreak;\n\t\t\t    case 5: /* blink */\n\t\t\t\tflags |= WSATTR_BLINK;\n\t\t\t\tbreak;\n\t\t\t    case 7: /* reverse */\n\t\t\t\tflags |= WSATTR_REVERSE;\n\t\t\t\tbreak;\n\t\t\t    case 22: /* ~bold VT300 only */\n\t\t\t\tflags &= ~WSATTR_HILIT;\n\t\t\t\tbreak;\n\t\t\t    case 24: /* ~underline VT300 only */\n\t\t\t\tflags &= ~WSATTR_UNDERLINE;\n\t\t\t\tbreak;\n\t\t\t    case 25: /* ~blink VT300 only */\n\t\t\t\tflags &= ~WSATTR_BLINK;\n\t\t\t\tbreak;\n\t\t\t    case 27: /* ~reverse VT300 only */\n\t\t\t\tflags &= ~WSATTR_REVERSE;\n\t\t\t\tbreak;\n\t\t\t    case 30: case 31: case 32: case 33:\n\t\t\t    case 34: case 35: case 36: case 37:\n\t\t\t\t/* fg color */\n\t\t\t\tflags |= WSATTR_WSCOLORS;\n\t\t\t\tfgcol = ARG(n) - 30;\n\t\t\t\tbreak;\n\t\t\t    case 40: case 41: case 42: case 43:\n\t\t\t    case 44: case 45: case 46: case 47:\n\t\t\t\t/* bg color */\n\t\t\t\tflags |= WSATTR_WSCOLORS;\n\t\t\t\tbgcol = ARG(n) - 40;\n\t\t\t\tbreak;\n\t\t\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\t\t\tprintf(\"CSI%dm unknown\\n\", ARG(n));\n#endif\n\t\t\t}\n\t\t}\n\t\tif (vt100_selectattribute(edp, flags, fgcol, bgcol, &attr,\n\t\t    &bkgdattr)) {\n#ifdef VT100_DEBUG\n\t\t\tprintf(\"error allocating attr %d/%d/%x\\n\",\n\t\t\t       fgcol, bgcol, flags);\n#endif\n\t\t} else {\n\t\t\tedp->curattr = attr;\n\t\t\tedp->bkgdattr = bkgdattr;\n\t\t\tedp->attrflags = flags;\n\t\t\tedp->fgcol = fgcol;\n\t\t\tedp->bgcol = bgcol;\n\t\t}\n\t\tbreak;\n\t    case 'n': /* reports */\n\t\tswitch (ARG(0)) {\n\t\t    case 5: /* DSR operating status */\n\t\t\t/* 0 = OK, 3 = malfunction */\n\t\t\twsdisplay_emulinput(edp->cbcookie, \"\\033[0n\", 4);\n\t\t\tbreak;\n\t\t    case 6: { /* DSR cursor position report */\n\t\t\tchar buf[20];\n\t\t\tint row;\n\t\t\tif (edp->flags & VTFL_DECOM)\n\t\t\t\trow = ROWS_ABOVE;\n\t\t\telse\n\t\t\t\trow = edp->crow;\n\t\t\tn = sprintf(buf, \"\\033[%d;%dR\",\n\t\t\t\t    row + 1, edp->ccol + 1);\n\t\t\twsdisplay_emulinput(edp->cbcookie, buf, n);\n\t\t\t}\n\t\t\tbreak;\n\t\t    case 15: /* DSR printer status */\n\t\t\t/* 13 = no printer, 10 = ready, 11 = not ready */\n\t\t\twsdisplay_emulinput(edp->cbcookie, \"\\033[?13n\", 6);\n\t\t\tbreak;\n\t\t    case 25: /* UDK status - VT300 only */\n\t\t\t/* 20 = locked, 21 = unlocked */\n\t\t\twsdisplay_emulinput(edp->cbcookie, \"\\033[?21n\", 6);\n\t\t\tbreak;\n\t\t    case 26: /* keyboard dialect */\n\t\t\t/* 1 = north american , 7 = german */\n\t\t\twsdisplay_emulinput(edp->cbcookie, \"\\033[?27;1n\", 8);\n\t\t\tbreak;\n\t\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\t\tprintf(\"CSI%dn unknown\\n\", ARG(0));\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t    case 'r': /* DECSTBM set top/bottom margins */\n\t\thelp = min(DEF1_ARG(0), edp->nrows) - 1;\n\t\tn = min(DEFx_ARG(1, edp->nrows), edp->nrows) - help;\n\t\tif (n < 2) {\n\t\t\t/* minimal scrolling region has 2 lines */\n\t\t\treturn;\n\t\t} else {\n\t\t\tedp->scrreg_startrow = help;\n\t\t\tedp->scrreg_nrows = n;\n\t\t}\n\t\tedp->crow = ((edp->flags & VTFL_DECOM) ?\n\t\t\t     edp->scrreg_startrow : 0);\n\t\tedp->ccol = 0;\n\t\tbreak;\n\t    case 'y':\n\t\tswitch (ARG(0)) {\n\t\t    case 4: /* DECTST invoke confidence test */\n\t\t\t/* ignore */\n\t\t\tbreak;\n\t\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\t\tprintf(\"CSI%dy unknown\\n\", ARG(0));\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\tprintf(\"CSI%c (%d, %d) unknown\\n\", c, ARG(0), ARG(1));\n#endif\n\t}\n}",
    "includes": [
      "#include <dev/wscons/wsemul_vt100var.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define VTMODE_REPORT 55",
      "#define VTMODE_RESET 44",
      "#define VTMODE_SET 33"
    ],
    "globals_used": [
      "static int vt100_selectattribute",
      "static int vt100_ansimode",
      "static int vt100_decmode"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"CSI%c (%d, %d) unknown\\n\"",
            "c",
            "ARG(0)",
            "ARG(1)"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARG",
          "args": [
            "1"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARG",
          "args": [
            "0"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARG",
          "args": [
            "0"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARG",
          "args": [
            "0"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "DEFx_ARG(1, edp->nrows)",
            "edp->nrows"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "seq_do_timing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sequencer.c",
          "lines": "804-819",
          "snippet": "int\nseq_do_timing(sc, b)\n\tstruct sequencer_softc *sc;\n\tseq_event_rec *b;\n{\n\tunion {\n\t\tint32_t i;\n\t\tu_int8_t b[4];\n\t} u;\n\n\tu.b[0] = b->arr[4];\n\tu.b[1] = b->arr[5];\n\tu.b[2] = b->arr[6];\n\tu.b[3] = b->arr[7];\n\treturn (seq_timer(sc, SEQ_TCMD(b), u.i, b));\n}",
          "includes": [
            "#include \"midi.h\"",
            "#include <dev/sequencervar.h>",
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"midi.h\"\n#include <dev/sequencervar.h>\n#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n\nint\nseq_do_timing(sc, b)\n\tstruct sequencer_softc *sc;\n\tseq_event_rec *b;\n{\n\tunion {\n\t\tint32_t i;\n\t\tu_int8_t b[4];\n\t} u;\n\n\tu.b[0] = b->arr[4];\n\tu.b[1] = b->arr[5];\n\tu.b[2] = b->arr[6];\n\tu.b[3] = b->arr[7];\n\treturn (seq_timer(sc, SEQ_TCMD(b), u.i, b));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEFx_ARG",
          "args": [
            "1",
            "edp->nrows"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEF1_ARG",
          "args": [
            "0"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARG",
          "args": [
            "0"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsdisplay_emulinput",
          "args": [
            "edp->cbcookie",
            "\"\\033[?27;1n\"",
            "8"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "wsdisplay_emulinput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "1265-1285",
          "snippet": "void\nwsdisplay_emulinput(v, data, count)\n\tvoid *v;\n\tconst u_char *data;\n\tu_int count;\n{\n\tstruct wsscreen *scr = v;\n\tstruct tty *tp;\n\n\tif (v == NULL)\t\t\t/* console, before real attach */\n\t\treturn;\n\n\tif (scr->scr_flags & SCR_GRAPHICS) /* XXX can't happen */\n\t\treturn;\n\tif (!WSSCREEN_HAS_TTY(scr))\n\t\treturn;\n\n\ttp = scr->scr_tty;\n\twhile (count-- > 0)\n\t\t(*linesw[tp->t_line].l_rint)(*data++, tp);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [
            "#define SCR_GRAPHICS 4\t\t/* graphics mode, no text (emulation) output */"
          ],
          "globals_used": [
            "int console;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define SCR_GRAPHICS 4\t\t/* graphics mode, no text (emulation) output */\n\nint console;\n\nvoid\nwsdisplay_emulinput(v, data, count)\n\tvoid *v;\n\tconst u_char *data;\n\tu_int count;\n{\n\tstruct wsscreen *scr = v;\n\tstruct tty *tp;\n\n\tif (v == NULL)\t\t\t/* console, before real attach */\n\t\treturn;\n\n\tif (scr->scr_flags & SCR_GRAPHICS) /* XXX can't happen */\n\t\treturn;\n\tif (!WSSCREEN_HAS_TTY(scr))\n\t\treturn;\n\n\ttp = scr->scr_tty;\n\twhile (count-- > 0)\n\t\t(*linesw[tp->t_line].l_rint)(*data++, tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"\\033[%d;%dR\"",
            "row + 1",
            "edp->ccol + 1"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARG",
          "args": [
            "0"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vt100_selectattribute",
          "args": [
            "edp",
            "flags",
            "fgcol",
            "bgcol",
            "&attr",
            "&bkgdattr"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "vt100_selectattribute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsemul_vt100_subr.c",
          "lines": "629-698",
          "snippet": "static int\nvt100_selectattribute(edp, flags, fgcol, bgcol, attr, bkgdattr)\n\tstruct wsemul_vt100_emuldata *edp;\n\tint flags, fgcol, bgcol;\n\tlong *attr, *bkgdattr;\n{\n\tint error;\n\n\tif ((flags & WSATTR_WSCOLORS) &&\n\t    !(edp->scrcapabilities & WSSCREEN_WSCOLORS)) {\n\t\tflags &= ~WSATTR_WSCOLORS;\n#ifdef VT100_DEBUG\n\t\tprintf(\"colors ignored (impossible)\\n\");\n#endif\n\t}\n\terror = (*edp->emulops->alloc_attr)(edp->emulcookie, fgcol, bgcol,\n\t\t\t\t\t    flags & WSATTR_WSCOLORS, bkgdattr);\n\tif (error)\n\t\treturn (error);\n\n\tif ((flags & WSATTR_HILIT) &&\n\t    !(edp->scrcapabilities & WSSCREEN_HILIT)) {\n\t\tflags &= ~WSATTR_HILIT;\n\t\tif (edp->scrcapabilities & WSSCREEN_WSCOLORS) {\n\t\t\tfgcol = WSCOL_RED;\n\t\t\tflags |= WSATTR_WSCOLORS;\n\t\t} else {\n#ifdef VT100_DEBUG\n\t\t\tprintf(\"bold ignored (impossible)\\n\");\n#endif\n\t\t}\n\t}\n\tif ((flags & WSATTR_UNDERLINE) &&\n\t    !(edp->scrcapabilities & WSSCREEN_UNDERLINE)) {\n\t\tflags &= ~WSATTR_UNDERLINE;\n\t\tif (edp->scrcapabilities & WSSCREEN_WSCOLORS) {\n\t\t\tbgcol = WSCOL_BROWN;\n\t\t\tflags &= ~WSATTR_UNDERLINE;\n\t\t\tflags |= WSATTR_WSCOLORS;\n\t\t} else {\n#ifdef VT100_DEBUG\n\t\t\tprintf(\"underline ignored (impossible)\\n\");\n#endif\n\t\t}\n\t}\n\tif ((flags & WSATTR_BLINK) &&\n\t    !(edp->scrcapabilities & WSSCREEN_BLINK)) {\n\t\tflags &= ~WSATTR_BLINK;\n#ifdef VT100_DEBUG\n\t\tprintf(\"blink ignored (impossible)\\n\");\n#endif\n\t}\n\tif ((flags & WSATTR_REVERSE) &&\n\t    !(edp->scrcapabilities & WSSCREEN_REVERSE)) {\n\t\tflags &= ~WSATTR_REVERSE;\n\t\tif (edp->scrcapabilities & WSSCREEN_WSCOLORS) {\n\t\t\tint help;\n\t\t\thelp = bgcol;\n\t\t\tbgcol = fgcol;\n\t\t\tfgcol = help;\n\t\t\tflags |= WSATTR_WSCOLORS;\n\t\t} else {\n#ifdef VT100_DEBUG\n\t\t\tprintf(\"reverse ignored (impossible)\\n\");\n#endif\n\t\t}\n\t}\n\treturn ((*edp->emulops->alloc_attr)(edp->emulcookie, fgcol, bgcol,\n\t\t\t\t\t    flags, attr));\n}",
          "includes": [
            "#include <dev/wscons/wsemul_vt100var.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int vt100_selectattribute"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsemul_vt100var.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int vt100_selectattribute;\n\nstatic int\nvt100_selectattribute(edp, flags, fgcol, bgcol, attr, bkgdattr)\n\tstruct wsemul_vt100_emuldata *edp;\n\tint flags, fgcol, bgcol;\n\tlong *attr, *bkgdattr;\n{\n\tint error;\n\n\tif ((flags & WSATTR_WSCOLORS) &&\n\t    !(edp->scrcapabilities & WSSCREEN_WSCOLORS)) {\n\t\tflags &= ~WSATTR_WSCOLORS;\n#ifdef VT100_DEBUG\n\t\tprintf(\"colors ignored (impossible)\\n\");\n#endif\n\t}\n\terror = (*edp->emulops->alloc_attr)(edp->emulcookie, fgcol, bgcol,\n\t\t\t\t\t    flags & WSATTR_WSCOLORS, bkgdattr);\n\tif (error)\n\t\treturn (error);\n\n\tif ((flags & WSATTR_HILIT) &&\n\t    !(edp->scrcapabilities & WSSCREEN_HILIT)) {\n\t\tflags &= ~WSATTR_HILIT;\n\t\tif (edp->scrcapabilities & WSSCREEN_WSCOLORS) {\n\t\t\tfgcol = WSCOL_RED;\n\t\t\tflags |= WSATTR_WSCOLORS;\n\t\t} else {\n#ifdef VT100_DEBUG\n\t\t\tprintf(\"bold ignored (impossible)\\n\");\n#endif\n\t\t}\n\t}\n\tif ((flags & WSATTR_UNDERLINE) &&\n\t    !(edp->scrcapabilities & WSSCREEN_UNDERLINE)) {\n\t\tflags &= ~WSATTR_UNDERLINE;\n\t\tif (edp->scrcapabilities & WSSCREEN_WSCOLORS) {\n\t\t\tbgcol = WSCOL_BROWN;\n\t\t\tflags &= ~WSATTR_UNDERLINE;\n\t\t\tflags |= WSATTR_WSCOLORS;\n\t\t} else {\n#ifdef VT100_DEBUG\n\t\t\tprintf(\"underline ignored (impossible)\\n\");\n#endif\n\t\t}\n\t}\n\tif ((flags & WSATTR_BLINK) &&\n\t    !(edp->scrcapabilities & WSSCREEN_BLINK)) {\n\t\tflags &= ~WSATTR_BLINK;\n#ifdef VT100_DEBUG\n\t\tprintf(\"blink ignored (impossible)\\n\");\n#endif\n\t}\n\tif ((flags & WSATTR_REVERSE) &&\n\t    !(edp->scrcapabilities & WSSCREEN_REVERSE)) {\n\t\tflags &= ~WSATTR_REVERSE;\n\t\tif (edp->scrcapabilities & WSSCREEN_WSCOLORS) {\n\t\t\tint help;\n\t\t\thelp = bgcol;\n\t\t\tbgcol = fgcol;\n\t\t\tfgcol = help;\n\t\t\tflags |= WSATTR_WSCOLORS;\n\t\t} else {\n#ifdef VT100_DEBUG\n\t\t\tprintf(\"reverse ignored (impossible)\\n\");\n#endif\n\t\t}\n\t}\n\treturn ((*edp->emulops->alloc_attr)(edp->emulcookie, fgcol, bgcol,\n\t\t\t\t\t    flags, attr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARG",
          "args": [
            "n"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARG",
          "args": [
            "n"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARG",
          "args": [
            "n"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARG",
          "args": [
            "n"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARG",
          "args": [
            "0"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "edp->tabs",
            "edp->ncols"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARG",
          "args": [
            "0"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KASSERT",
          "args": [
            "edp->tabs != 0"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARG",
          "args": [
            "0"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERASECOLS",
          "args": [
            "edp->ccol",
            "n",
            "edp->bkgdattr"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEF1_ARG",
          "args": [
            "0"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERASECOLS",
          "args": [
            "NCOLS - n",
            "n",
            "edp->bkgdattr"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPYCOLS",
          "args": [
            "edp->ccol + n",
            "edp->ccol",
            "help"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEF1_ARG",
          "args": [
            "0"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsemul_vt100_scrollup",
          "args": [
            "edp",
            "n"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "wsemul_vt100_scrollup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsemul_vt100_subr.c",
          "lines": "55-82",
          "snippet": "void\nwsemul_vt100_scrollup(edp, n)\n\tstruct wsemul_vt100_emuldata *edp;\n\tint n;\n{\n\tint help;\n\n\tif (n > edp->scrreg_nrows)\n\t\tn = edp->scrreg_nrows;\n\n\thelp = edp->scrreg_nrows - n;\n\tif (help > 0) {\n\t\t(*edp->emulops->copyrows)(edp->emulcookie,\n\t\t\t\t\t  edp->scrreg_startrow + n,\n\t\t\t\t\t  edp->scrreg_startrow,\n\t\t\t\t\t  help);\n\t\tif (edp->dblwid)\n\t\t\tmemmove(&edp->dblwid[edp->scrreg_startrow],\n\t\t\t\t&edp->dblwid[edp->scrreg_startrow + n],\n\t\t\t\thelp);\n\t}\n\t(*edp->emulops->eraserows)(edp->emulcookie,\n\t\t\t\t   edp->scrreg_startrow + help, n,\n\t\t\t\t   edp->bkgdattr);\n\tif (edp->dblwid)\n\t\tbzero(&edp->dblwid[edp->scrreg_startrow + help], n);\n\tCHECK_DW;\n}",
          "includes": [
            "#include <dev/wscons/wsemul_vt100var.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsemul_vt100var.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwsemul_vt100_scrollup(edp, n)\n\tstruct wsemul_vt100_emuldata *edp;\n\tint n;\n{\n\tint help;\n\n\tif (n > edp->scrreg_nrows)\n\t\tn = edp->scrreg_nrows;\n\n\thelp = edp->scrreg_nrows - n;\n\tif (help > 0) {\n\t\t(*edp->emulops->copyrows)(edp->emulcookie,\n\t\t\t\t\t  edp->scrreg_startrow + n,\n\t\t\t\t\t  edp->scrreg_startrow,\n\t\t\t\t\t  help);\n\t\tif (edp->dblwid)\n\t\t\tmemmove(&edp->dblwid[edp->scrreg_startrow],\n\t\t\t\t&edp->dblwid[edp->scrreg_startrow + n],\n\t\t\t\thelp);\n\t}\n\t(*edp->emulops->eraserows)(edp->emulcookie,\n\t\t\t\t   edp->scrreg_startrow + help, n,\n\t\t\t\t   edp->bkgdattr);\n\tif (edp->dblwid)\n\t\tbzero(&edp->dblwid[edp->scrreg_startrow + help], n);\n\tCHECK_DW;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wsemul_vt100_scrolldown",
          "args": [
            "edp",
            "n"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "wsemul_vt100_scrolldown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsemul_vt100_subr.c",
          "lines": "87-114",
          "snippet": "void\nwsemul_vt100_scrolldown(edp, n)\n\tstruct wsemul_vt100_emuldata *edp;\n\tint n;\n{\n\tint help;\n\n\tif (n > edp->scrreg_nrows)\n\t\tn = edp->scrreg_nrows;\n\n\thelp = edp->scrreg_nrows - n;\n\tif (help > 0) {\n\t\t(*edp->emulops->copyrows)(edp->emulcookie,\n\t\t\t\t\t  edp->scrreg_startrow,\n\t\t\t\t\t  edp->scrreg_startrow + n,\n\t\t\t\t\t  help);\n\t\tif (edp->dblwid)\n\t\t\tmemmove(&edp->dblwid[edp->scrreg_startrow + n],\n\t\t\t\t&edp->dblwid[edp->scrreg_startrow],\n\t\t\t\thelp);\n\t}\n\t(*edp->emulops->eraserows)(edp->emulcookie,\n\t\t\t\t   edp->scrreg_startrow, n,\n\t\t\t\t   edp->bkgdattr);\n\tif (edp->dblwid)\n\t\tbzero(&edp->dblwid[edp->scrreg_startrow], n);\n\tCHECK_DW;\n}",
          "includes": [
            "#include <dev/wscons/wsemul_vt100var.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsemul_vt100var.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwsemul_vt100_scrolldown(edp, n)\n\tstruct wsemul_vt100_emuldata *edp;\n\tint n;\n{\n\tint help;\n\n\tif (n > edp->scrreg_nrows)\n\t\tn = edp->scrreg_nrows;\n\n\thelp = edp->scrreg_nrows - n;\n\tif (help > 0) {\n\t\t(*edp->emulops->copyrows)(edp->emulcookie,\n\t\t\t\t\t  edp->scrreg_startrow,\n\t\t\t\t\t  edp->scrreg_startrow + n,\n\t\t\t\t\t  help);\n\t\tif (edp->dblwid)\n\t\t\tmemmove(&edp->dblwid[edp->scrreg_startrow + n],\n\t\t\t\t&edp->dblwid[edp->scrreg_startrow],\n\t\t\t\thelp);\n\t}\n\t(*edp->emulops->eraserows)(edp->emulcookie,\n\t\t\t\t   edp->scrreg_startrow, n,\n\t\t\t\t   edp->bkgdattr);\n\tif (edp->dblwid)\n\t\tbzero(&edp->dblwid[edp->scrreg_startrow], n);\n\tCHECK_DW;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEF1_ARG",
          "args": [
            "0"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEF1_ARG",
          "args": [
            "1"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEF1_ARG",
          "args": [
            "0"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEF1_ARG",
          "args": [
            "0"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEF1_ARG",
          "args": [
            "0"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEF1_ARG",
          "args": [
            "0"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEF1_ARG",
          "args": [
            "0"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEF1_ARG",
          "args": [
            "0"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERASECOLS",
          "args": [
            "edp->ccol",
            "n",
            "edp->bkgdattr"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPYCOLS",
          "args": [
            "edp->ccol",
            "edp->ccol + n",
            "help"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEF1_ARG",
          "args": [
            "0"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "A2",
          "args": [
            "'&'",
            "'u'"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARG",
          "args": [
            "0"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARG",
          "args": [
            "0"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARG",
          "args": [
            "0"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "A2",
          "args": [
            "'$'",
            "'~'"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARG",
          "args": [
            "0"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARG",
          "args": [
            "0"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARG",
          "args": [
            "0"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "A2",
          "args": [
            "'$'",
            "'}'"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARG",
          "args": [
            "0"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%s%d\"",
            "(ps ? \"/\" : \"\")",
            "i + 1"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KASSERT",
          "args": [
            "edp->tabs != 0"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARG",
          "args": [
            "0"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "A2",
          "args": [
            "'$'",
            "'w'"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARG",
          "args": [
            "0"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARG",
          "args": [
            "0"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "A2",
          "args": [
            "'$'",
            "'u'"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARG",
          "args": [
            "0"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARG",
          "args": [
            "0"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "A2",
          "args": [
            "'\"'",
            "'q'"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARG",
          "args": [
            "1"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARG",
          "args": [
            "0"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARG",
          "args": [
            "1"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARG",
          "args": [
            "0"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARG",
          "args": [
            "1"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARG",
          "args": [
            "0"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARG",
          "args": [
            "0"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "A2",
          "args": [
            "'\"'",
            "'p'"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsemul_vt100_reset",
          "args": [
            "edp"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "wsemul_vt100_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsemul_vt100.c",
          "lines": "282-310",
          "snippet": "void\nwsemul_vt100_reset(edp)\n\tstruct wsemul_vt100_emuldata *edp;\n{\n\tint i;\n\n\tedp->state = VT100_EMUL_STATE_NORMAL;\n\tedp->flags = VTFL_DECAWM | VTFL_CURSORON;\n\tedp->bkgdattr = edp->curattr = edp->defattr;\n\tedp->attrflags = 0;\n\tedp->fgcol = WSCOL_WHITE;\n\tedp->bgcol = WSCOL_BLACK;\n\tedp->scrreg_startrow = 0;\n\tedp->scrreg_nrows = edp->nrows;\n\tif (edp->tabs) {\n\t\tbzero(edp->tabs, edp->ncols);\n\t\tfor (i = 8; i < edp->ncols; i += 8)\n\t\t\tedp->tabs[i] = 1;\n\t}\n\tedp->dcspos = 0;\n\tedp->dcstype = 0;\n\tedp->chartab_G[0] = 0;\n\tedp->chartab_G[1] = edp->nrctab; /* ??? */\n\tedp->chartab_G[2] = edp->isolatin1tab;\n\tedp->chartab_G[3] = edp->isolatin1tab;\n\tedp->chartab0 = 0;\n\tedp->chartab1 = 2;\n\tedp->sschartab = 0;\n}",
          "includes": [
            "#include <dev/wscons/ascii.h>",
            "#include <dev/wscons/wsemul_vt100var.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/time.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tVT100_EMUL_STATE_NORMAL\t\t0\t/* normal processing */"
          ],
          "globals_used": [
            "long defattr;",
            "long defattr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/ascii.h>\n#include <dev/wscons/wsemul_vt100var.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/fcntl.h>\n#include <sys/malloc.h>\n#include <sys/time.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tVT100_EMUL_STATE_NORMAL\t\t0\t/* normal processing */\n\nlong defattr;\nlong defattr;\n\nvoid\nwsemul_vt100_reset(edp)\n\tstruct wsemul_vt100_emuldata *edp;\n{\n\tint i;\n\n\tedp->state = VT100_EMUL_STATE_NORMAL;\n\tedp->flags = VTFL_DECAWM | VTFL_CURSORON;\n\tedp->bkgdattr = edp->curattr = edp->defattr;\n\tedp->attrflags = 0;\n\tedp->fgcol = WSCOL_WHITE;\n\tedp->bgcol = WSCOL_BLACK;\n\tedp->scrreg_startrow = 0;\n\tedp->scrreg_nrows = edp->nrows;\n\tif (edp->tabs) {\n\t\tbzero(edp->tabs, edp->ncols);\n\t\tfor (i = 8; i < edp->ncols; i += 8)\n\t\t\tedp->tabs[i] = 1;\n\t}\n\tedp->dcspos = 0;\n\tedp->dcstype = 0;\n\tedp->chartab_G[0] = 0;\n\tedp->chartab_G[1] = edp->nrctab; /* ??? */\n\tedp->chartab_G[2] = edp->isolatin1tab;\n\tedp->chartab_G[3] = edp->isolatin1tab;\n\tedp->chartab0 = 0;\n\tedp->chartab1 = 2;\n\tedp->sschartab = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "A2",
          "args": [
            "'!'",
            "'p'"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARG",
          "args": [
            "0"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARG",
          "args": [
            "0"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARG",
          "args": [
            "0"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "A3",
          "args": [
            "'?'",
            "'\\0'",
            "'i'"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "A3",
          "args": [
            "'\\0'",
            "'\\0'",
            "'i'"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vt100_decmode",
          "args": [
            "edp",
            "ARG(0)",
            "VTMODE_REPORT"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "vt100_decmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsemul_vt100_subr.c",
          "lines": "779-856",
          "snippet": "static int\nvt100_decmode(edp, nr, op)\n\tstruct wsemul_vt100_emuldata *edp;\n\tint nr, op;\n{\n\tint res = 0; /* default: unknown */\n\tint flags;\n\n\tflags = edp->flags;\n\tswitch (nr) {\n\t    case 1: /* DECCKM application/nomal cursor keys */\n\t\tif (op == VTMODE_SET)\n\t\t\tflags |= VTFL_APPLCURSOR;\n\t\telse if (op == VTMODE_RESET)\n\t\t\tflags &= ~VTFL_APPLCURSOR;\n\t\tres = ((flags & VTFL_APPLCURSOR) ? 1 : 2);\n\t\tbreak;\n\t    case 2: /* DECANM ANSI vt100/vt52 */\n\t\tres = 3; /* permanently set ??? */\n\t\tbreak;\n\t    case 3: /* DECCOLM 132/80 cols */\n\t    case 4: /* DECSCLM smooth/jump scroll */\n\t    case 5: /* DECSCNM light/dark background */\n\t\tres = 4; /* all permanently reset ??? */\n\t\tbreak;\n\t    case 6: /* DECOM move within/outside margins */\n\t\tif (op == VTMODE_SET)\n\t\t\tflags |= VTFL_DECOM;\n\t\telse if (op == VTMODE_RESET)\n\t\t\tflags &= ~VTFL_DECOM;\n\t\tres = ((flags & VTFL_DECOM) ? 1 : 2);\n\t\tbreak;\n\t    case 7: /* DECAWM autowrap */\n\t\tif (op == VTMODE_SET)\n\t\t\tflags |= VTFL_DECAWM;\n\t\telse if (op == VTMODE_RESET)\n\t\t\tflags &= ~VTFL_DECAWM;\n\t\tres = ((flags & VTFL_DECAWM) ? 1 : 2);\n\t\tbreak;\n\t    case 8: /* DECARM keyboard autorepeat */\n\t\tbreak;\n\t    case 18: /* DECPFF print form feed */\n\t\tbreak;\n\t    case 19: /* DECPEX printer extent: screen/scrolling region */\n\t\tbreak;\n\t    case 25: /* DECTCEM text cursor on/off */\n\t\tif (op == VTMODE_SET)\n\t\t\tflags |= VTFL_CURSORON;\n\t\telse if (op == VTMODE_RESET)\n\t\t\tflags &= ~VTFL_CURSORON;\n\t\tif (flags != edp->flags)\n\t\t\t(*edp->emulops->cursor)(edp->emulcookie,\n\t\t\t\t\t\tflags & VTFL_CURSORON,\n\t\t\t\t\t\tedp->crow, edp->ccol);\n\t\tres = ((flags & VTFL_CURSORON) ? 1 : 2);\n\t\tbreak;\n\t    case 42: /* DECNRCM use 7-bit NRC /\n\t\t      7/8 bit from DEC multilingual or ISO-latin-1*/\n\t\tif (op == VTMODE_SET)\n\t\t\tflags |= VTFL_NATCHARSET;\n\t\telse if (op == VTMODE_RESET)\n\t\t\tflags &= ~VTFL_NATCHARSET;\n\t\tres = ((flags & VTFL_NATCHARSET) ? 1 : 2);\n\t\tbreak;\n\t    case 66: /* DECNKM numeric keypad */\n\t\tbreak;\n\t    case 68: /* DECKBUM keyboard usage data processing/typewriter */\n\t\tbreak;\n\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\tprintf(\"DEC mode %d unknown\\n\", nr);\n#endif\n\t\tbreak;\n\t}\n\tedp->flags = flags;\n\n\treturn (res);\n}",
          "includes": [
            "#include <dev/wscons/wsemul_vt100var.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define VTMODE_RESET 44",
            "#define VTMODE_SET 33"
          ],
          "globals_used": [
            "static int vt100_decmode"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsemul_vt100var.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define VTMODE_RESET 44\n#define VTMODE_SET 33\n\nstatic int vt100_decmode;\n\nstatic int\nvt100_decmode(edp, nr, op)\n\tstruct wsemul_vt100_emuldata *edp;\n\tint nr, op;\n{\n\tint res = 0; /* default: unknown */\n\tint flags;\n\n\tflags = edp->flags;\n\tswitch (nr) {\n\t    case 1: /* DECCKM application/nomal cursor keys */\n\t\tif (op == VTMODE_SET)\n\t\t\tflags |= VTFL_APPLCURSOR;\n\t\telse if (op == VTMODE_RESET)\n\t\t\tflags &= ~VTFL_APPLCURSOR;\n\t\tres = ((flags & VTFL_APPLCURSOR) ? 1 : 2);\n\t\tbreak;\n\t    case 2: /* DECANM ANSI vt100/vt52 */\n\t\tres = 3; /* permanently set ??? */\n\t\tbreak;\n\t    case 3: /* DECCOLM 132/80 cols */\n\t    case 4: /* DECSCLM smooth/jump scroll */\n\t    case 5: /* DECSCNM light/dark background */\n\t\tres = 4; /* all permanently reset ??? */\n\t\tbreak;\n\t    case 6: /* DECOM move within/outside margins */\n\t\tif (op == VTMODE_SET)\n\t\t\tflags |= VTFL_DECOM;\n\t\telse if (op == VTMODE_RESET)\n\t\t\tflags &= ~VTFL_DECOM;\n\t\tres = ((flags & VTFL_DECOM) ? 1 : 2);\n\t\tbreak;\n\t    case 7: /* DECAWM autowrap */\n\t\tif (op == VTMODE_SET)\n\t\t\tflags |= VTFL_DECAWM;\n\t\telse if (op == VTMODE_RESET)\n\t\t\tflags &= ~VTFL_DECAWM;\n\t\tres = ((flags & VTFL_DECAWM) ? 1 : 2);\n\t\tbreak;\n\t    case 8: /* DECARM keyboard autorepeat */\n\t\tbreak;\n\t    case 18: /* DECPFF print form feed */\n\t\tbreak;\n\t    case 19: /* DECPEX printer extent: screen/scrolling region */\n\t\tbreak;\n\t    case 25: /* DECTCEM text cursor on/off */\n\t\tif (op == VTMODE_SET)\n\t\t\tflags |= VTFL_CURSORON;\n\t\telse if (op == VTMODE_RESET)\n\t\t\tflags &= ~VTFL_CURSORON;\n\t\tif (flags != edp->flags)\n\t\t\t(*edp->emulops->cursor)(edp->emulcookie,\n\t\t\t\t\t\tflags & VTFL_CURSORON,\n\t\t\t\t\t\tedp->crow, edp->ccol);\n\t\tres = ((flags & VTFL_CURSORON) ? 1 : 2);\n\t\tbreak;\n\t    case 42: /* DECNRCM use 7-bit NRC /\n\t\t      7/8 bit from DEC multilingual or ISO-latin-1*/\n\t\tif (op == VTMODE_SET)\n\t\t\tflags |= VTFL_NATCHARSET;\n\t\telse if (op == VTMODE_RESET)\n\t\t\tflags &= ~VTFL_NATCHARSET;\n\t\tres = ((flags & VTFL_NATCHARSET) ? 1 : 2);\n\t\tbreak;\n\t    case 66: /* DECNKM numeric keypad */\n\t\tbreak;\n\t    case 68: /* DECKBUM keyboard usage data processing/typewriter */\n\t\tbreak;\n\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\tprintf(\"DEC mode %d unknown\\n\", nr);\n#endif\n\t\tbreak;\n\t}\n\tedp->flags = flags;\n\n\treturn (res);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARG",
          "args": [
            "0"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "A3",
          "args": [
            "'?'",
            "'$'",
            "'p'"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vt100_ansimode",
          "args": [
            "edp",
            "ARG(0)",
            "VTMODE_REPORT"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "vt100_ansimode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsemul_vt100_subr.c",
          "lines": "744-777",
          "snippet": "static int\nvt100_ansimode(edp, nr, op)\n\tstruct wsemul_vt100_emuldata *edp;\n\tint nr, op;\n{\n\tint res = 0; /* default: unknown */\n\n\tswitch (nr) {\n\t    case 2: /* KAM keyboard locked/unlocked */\n\t\tbreak;\n\t    case 3: /* CRM control representation */\n\t\tbreak;\n\t    case 4: /* IRM insert/replace characters */\n\t\tif (op == VTMODE_SET)\n\t\t\tedp->flags |= VTFL_INSERTMODE;\n\t\telse if (op == VTMODE_RESET)\n\t\t\tedp->flags &= ~VTFL_INSERTMODE;\n\t\tres = ((edp->flags & VTFL_INSERTMODE) ? 1 : 2);\n\t\tbreak;\n\t    case 10: /* HEM horizontal editing (permanently reset) */\n\t\tres = 4;\n\t\tbreak;\n\t    case 12: /* SRM local echo off/on */\n\t\tres = 4; /* permanently reset ??? */\n\t\tbreak;\n\t    case 20: /* LNM newline = newline/linefeed */\n\t\tbreak;\n\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\tprintf(\"ANSI mode %d unknown\\n\", nr);\n#endif\n\t}\n\treturn (res);\n}",
          "includes": [
            "#include <dev/wscons/wsemul_vt100var.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define VTMODE_RESET 44",
            "#define VTMODE_SET 33"
          ],
          "globals_used": [
            "static int vt100_ansimode"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsemul_vt100var.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define VTMODE_RESET 44\n#define VTMODE_SET 33\n\nstatic int vt100_ansimode;\n\nstatic int\nvt100_ansimode(edp, nr, op)\n\tstruct wsemul_vt100_emuldata *edp;\n\tint nr, op;\n{\n\tint res = 0; /* default: unknown */\n\n\tswitch (nr) {\n\t    case 2: /* KAM keyboard locked/unlocked */\n\t\tbreak;\n\t    case 3: /* CRM control representation */\n\t\tbreak;\n\t    case 4: /* IRM insert/replace characters */\n\t\tif (op == VTMODE_SET)\n\t\t\tedp->flags |= VTFL_INSERTMODE;\n\t\telse if (op == VTMODE_RESET)\n\t\t\tedp->flags &= ~VTFL_INSERTMODE;\n\t\tres = ((edp->flags & VTFL_INSERTMODE) ? 1 : 2);\n\t\tbreak;\n\t    case 10: /* HEM horizontal editing (permanently reset) */\n\t\tres = 4;\n\t\tbreak;\n\t    case 12: /* SRM local echo off/on */\n\t\tres = 4; /* permanently reset ??? */\n\t\tbreak;\n\t    case 20: /* LNM newline = newline/linefeed */\n\t\tbreak;\n\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\tprintf(\"ANSI mode %d unknown\\n\", nr);\n#endif\n\t}\n\treturn (res);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARG",
          "args": [
            "0"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "A3",
          "args": [
            "'\\0'",
            "'$'",
            "'p'"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARG",
          "args": [
            "n"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "A3",
          "args": [
            "'?'",
            "'\\0'",
            "'l'"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARG",
          "args": [
            "n"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "A3",
          "args": [
            "'\\0'",
            "'\\0'",
            "'l'"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARG",
          "args": [
            "n"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "A3",
          "args": [
            "'?'",
            "'\\0'",
            "'h'"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARG",
          "args": [
            "n"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "A3",
          "args": [
            "'\\0'",
            "'\\0'",
            "'h'"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsemul_vt100_el",
          "args": [
            "edp",
            "ARG(0)"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "wsemul_vt100_el",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsemul_vt100_subr.c",
          "lines": "167-190",
          "snippet": "void\nwsemul_vt100_el(edp, arg)\n\tstruct wsemul_vt100_emuldata *edp;\n\tint arg;\n{\n\tswitch (arg) {\n\t    case 0: /* cursor to end */\n\t\tERASECOLS(edp->ccol, COLS_LEFT + 1, edp->bkgdattr);\n\t\tbreak;\n\t    case 1: /* beginning to cursor */\n\t\tERASECOLS(0, edp->ccol + 1, edp->bkgdattr);\n\t\tbreak;\n\t    case 2: /* complete line */\n\t\t(*edp->emulops->erasecols)(edp->emulcookie, edp->crow,\n\t\t\t\t\t   0, edp->ncols,\n\t\t\t\t\t   edp->bkgdattr);\n\t\tbreak;\n\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\tprintf(\"el(%d) unknown\\n\", arg);\n#endif\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include <dev/wscons/wsemul_vt100var.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsemul_vt100var.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwsemul_vt100_el(edp, arg)\n\tstruct wsemul_vt100_emuldata *edp;\n\tint arg;\n{\n\tswitch (arg) {\n\t    case 0: /* cursor to end */\n\t\tERASECOLS(edp->ccol, COLS_LEFT + 1, edp->bkgdattr);\n\t\tbreak;\n\t    case 1: /* beginning to cursor */\n\t\tERASECOLS(0, edp->ccol + 1, edp->bkgdattr);\n\t\tbreak;\n\t    case 2: /* complete line */\n\t\t(*edp->emulops->erasecols)(edp->emulcookie, edp->crow,\n\t\t\t\t\t   0, edp->ncols,\n\t\t\t\t\t   edp->bkgdattr);\n\t\tbreak;\n\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\tprintf(\"el(%d) unknown\\n\", arg);\n#endif\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARG",
          "args": [
            "0"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "A3",
          "args": [
            "'?'",
            "'\\0'",
            "'K'"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "A3",
          "args": [
            "'\\0'",
            "'\\0'",
            "'K'"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsemul_vt100_ed",
          "args": [
            "edp",
            "ARG(0)"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "wsemul_vt100_ed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsemul_vt100_subr.c",
          "lines": "119-162",
          "snippet": "void\nwsemul_vt100_ed(edp, arg)\n\tstruct wsemul_vt100_emuldata *edp;\n\tint arg;\n{\n\tint n;\n\n\tswitch (arg) {\n\t    case 0: /* cursor to end */\n\t\tERASECOLS(edp->ccol, COLS_LEFT + 1, edp->bkgdattr);\n\t\tn = edp->nrows - edp->crow - 1;\n\t\tif (n > 0) {\n\t\t\t(*edp->emulops->eraserows)(edp->emulcookie,\n\t\t\t\t\t\t   edp->crow + 1, n,\n\t\t\t\t\t\t   edp->bkgdattr);\n\t\t\tif (edp->dblwid)\n\t\t\t\tbzero(&edp->dblwid[edp->crow + 1], n);\n\t\t}\n\t\tbreak;\n\t    case 1: /* beginning to cursor */\n\t\tif (edp->crow > 0) {\n\t\t\t(*edp->emulops->eraserows)(edp->emulcookie,\n\t\t\t\t\t\t   0, edp->crow,\n\t\t\t\t\t\t   edp->bkgdattr);\n\t\t\tif (edp->dblwid)\n\t\t\t\tbzero(&edp->dblwid[0], edp->crow);\n\t\t}\n\t\tERASECOLS(0, edp->ccol + 1, edp->bkgdattr);\n\t\tbreak;\n\t    case 2: /* complete display */\n\t\t(*edp->emulops->eraserows)(edp->emulcookie,\n\t\t\t\t\t   0, edp->nrows,\n\t\t\t\t\t   edp->bkgdattr);\n\t\tif (edp->dblwid)\n\t\t\tbzero(&edp->dblwid[0], edp->nrows);\n\t\tbreak;\n\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\tprintf(\"ed(%d) unknown\\n\", arg);\n#endif\n\t\tbreak;\n\t}\n\tCHECK_DW;\n}",
          "includes": [
            "#include <dev/wscons/wsemul_vt100var.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsemul_vt100var.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwsemul_vt100_ed(edp, arg)\n\tstruct wsemul_vt100_emuldata *edp;\n\tint arg;\n{\n\tint n;\n\n\tswitch (arg) {\n\t    case 0: /* cursor to end */\n\t\tERASECOLS(edp->ccol, COLS_LEFT + 1, edp->bkgdattr);\n\t\tn = edp->nrows - edp->crow - 1;\n\t\tif (n > 0) {\n\t\t\t(*edp->emulops->eraserows)(edp->emulcookie,\n\t\t\t\t\t\t   edp->crow + 1, n,\n\t\t\t\t\t\t   edp->bkgdattr);\n\t\t\tif (edp->dblwid)\n\t\t\t\tbzero(&edp->dblwid[edp->crow + 1], n);\n\t\t}\n\t\tbreak;\n\t    case 1: /* beginning to cursor */\n\t\tif (edp->crow > 0) {\n\t\t\t(*edp->emulops->eraserows)(edp->emulcookie,\n\t\t\t\t\t\t   0, edp->crow,\n\t\t\t\t\t\t   edp->bkgdattr);\n\t\t\tif (edp->dblwid)\n\t\t\t\tbzero(&edp->dblwid[0], edp->crow);\n\t\t}\n\t\tERASECOLS(0, edp->ccol + 1, edp->bkgdattr);\n\t\tbreak;\n\t    case 2: /* complete display */\n\t\t(*edp->emulops->eraserows)(edp->emulcookie,\n\t\t\t\t\t   0, edp->nrows,\n\t\t\t\t\t   edp->bkgdattr);\n\t\tif (edp->dblwid)\n\t\t\tbzero(&edp->dblwid[0], edp->nrows);\n\t\tbreak;\n\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\tprintf(\"ed(%d) unknown\\n\", arg);\n#endif\n\t\tbreak;\n\t}\n\tCHECK_DW;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARG",
          "args": [
            "0"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "A3",
          "args": [
            "'?'",
            "'\\0'",
            "'J'"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "A3",
          "args": [
            "'\\0'",
            "'\\0'",
            "'J'"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "A3",
          "args": [
            "'>'",
            "'\\0'",
            "'c'"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "A3",
          "args": [
            "edp->modif1",
            "edp->modif2",
            "c"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsemul_vt100var.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define VTMODE_REPORT 55\n#define VTMODE_RESET 44\n#define VTMODE_SET 33\n\nstatic int vt100_selectattribute;\nstatic int vt100_ansimode;\nstatic int vt100_decmode;\n\nvoid\nwsemul_vt100_handle_csi(edp, c)\n\tstruct wsemul_vt100_emuldata *edp;\n\tu_char c;\n{\n\tint n, help, flags, fgcol, bgcol;\n\tlong attr, bkgdattr;\n\n#define A3(a, b, c) (((a) << 16) | ((b) << 8) | (c))\n\tswitch (A3(edp->modif1, edp->modif2, c)) {\n\t    case A3('>', '\\0', 'c'): /* DA secondary */\n\t\twsdisplay_emulinput(edp->cbcookie, WSEMUL_VT_ID2,\n\t\t\t\t    sizeof(WSEMUL_VT_ID2));\n\t\tbreak;\n\n\t    case A3('\\0', '\\0', 'J'): /* ED selective erase in display */\n\t    case A3('?', '\\0', 'J'): /* DECSED selective erase in display */\n\t\twsemul_vt100_ed(edp, ARG(0));\n\t\tbreak;\n\t    case A3('\\0', '\\0', 'K'): /* EL selective erase in line */\n\t    case A3('?', '\\0', 'K'): /* DECSEL selective erase in line */\n\t\twsemul_vt100_el(edp, ARG(0));\n\t\tbreak;\n\t    case A3('\\0', '\\0', 'h'): /* SM */\n\t\tfor (n = 0; n < edp->nargs; n++)\n\t\t\tvt100_ansimode(edp, ARG(n), VTMODE_SET);\n\t\tbreak;\n\t    case A3('?', '\\0', 'h'): /* DECSM */\n\t\tfor (n = 0; n < edp->nargs; n++)\n\t\t\tvt100_decmode(edp, ARG(n), VTMODE_SET);\n\t\tbreak;\n\t    case A3('\\0', '\\0', 'l'): /* RM */\n\t\tfor (n = 0; n < edp->nargs; n++)\n\t\t\tvt100_ansimode(edp, ARG(n), VTMODE_RESET);\n\t\tbreak;;\n\t    case A3('?', '\\0', 'l'): /* DECRM */\n\t\tfor (n = 0; n < edp->nargs; n++)\n\t\t\tvt100_decmode(edp, ARG(n), VTMODE_RESET);\n\t\tbreak;;\n\t    case A3('\\0', '$', 'p'): /* DECRQM request mode ANSI */\n\t\tvt100_ansimode(edp, ARG(0), VTMODE_REPORT);\n\t\tbreak;\n\t    case A3('?', '$', 'p'): /* DECRQM request mode DEC */\n\t\tvt100_decmode(edp, ARG(0), VTMODE_REPORT);\n\t\tbreak;\n\t    case A3('\\0', '\\0', 'i'): /* MC printer controller mode */\n\t    case A3('?', '\\0', 'i'): /* MC printer controller mode */\n\t\tswitch (ARG(0)) {\n\t\t    case 0: /* print screen */\n\t\t    case 1: /* print cursor line */\n\t\t    case 4: /* off */\n\t\t    case 5: /* on */\n#ifdef VT100_PRINTNOTIMPL\n\t\t\tprintf(\"CSI%di ignored\\n\", ARG(0));\n#endif\n\t\t\tbreak;\n\t\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\t\tprintf(\"CSI%di unknown\\n\", ARG(0));\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n#define A2(a, b) (((a) << 8) | (b))\n\t    case A2('!', 'p'): /* DECSTR soft reset VT300 only */\n\t\twsemul_vt100_reset(edp);\n\t\tbreak;\n\n\t    case A2('\"', 'p'): /* DECSCL */\n\t\tswitch (ARG(0)) {\n\t\t    case 61: /* VT100 mode (no further arguments!) */\n\t\t\tbreak;\n\t\t    case 62:\n\t\t    case 63: /* VT300 mode */\n\t\t\tbreak;\n\t\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\t\tprintf(\"CSI%d\\\"p unknown\\n\", ARG(0));\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tswitch (ARG(1)) {\n\t\t    case 0:\n\t\t    case 2: /* 8-bit controls */\n#ifdef VT100_PRINTNOTIMPL\n\t\t\tprintf(\"CSI%d;%d\\\"p ignored\\n\", ARG(0), ARG(1));\n#endif\n\t\t\tbreak;\n\t\t    case 1: /* 7-bit controls */\n\t\t\tbreak;\n\t\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\t\tprintf(\"CSI%d;%d\\\"p unknown\\n\", ARG(0), ARG(1));\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t    case A2('\"', 'q'): /* DECSCA select character attribute VT300 */\n\t\tswitch (ARG(0)) {\n\t\t    case 0:\n\t\t    case 1: /* erasable */\n\t\t\tbreak;\n\t\t    case 2: /* not erasable */\n#ifdef VT100_PRINTNOTIMPL\n\t\t\tprintf(\"CSI2\\\"q ignored\\n\");\n#endif\n\t\t\tbreak;\n\t\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\t\tprintf(\"CSI%d\\\"q unknown\\n\", ARG(0));\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t    case A2('$', 'u'): /* DECRQTSR request terminal status report */\n\t\tswitch (ARG(0)) {\n\t\t    case 0: /* ignored */\n\t\t\tbreak;\n\t\t    case 1: /* terminal state report */\n#ifdef VT100_PRINTNOTIMPL\n\t\t\tprintf(\"CSI1$u ignored\\n\");\n#endif\n\t\t\tbreak;\n\t\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\t\tprintf(\"CSI%d$u unknown\\n\", ARG(0));\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t    case A2('$', 'w'): /* DECRQPSR request presentation status report\n\t\t\t\t(VT300 only) */\n\t\tswitch (ARG(0)) {\n\t\t    case 0: /* error */\n\t\t\tbreak;\n\t\t    case 1: /* cursor information report */\n#ifdef VT100_PRINTNOTIMPL\n\t\t\tprintf(\"CSI1$w ignored\\n\");\n#endif\n\t\t\tbreak;\n\t\t    case 2: /* tab stop report */\n\t\t\t{\n\t\t\tint i, n, ps = 0;\n\t\t\tchar buf[20];\n\t\t\tKASSERT(edp->tabs != 0);\n\t\t\twsdisplay_emulinput(edp->cbcookie, \"\\033P2$u\", 5);\n\t\t\tfor (i = 0; i < edp->ncols; i++)\n\t\t\t\tif (edp->tabs[i]) {\n\t\t\t\t\tn = sprintf(buf, \"%s%d\",\n\t\t\t\t\t\t    (ps ? \"/\" : \"\"), i + 1);\n\t\t\t\t\twsdisplay_emulinput(edp->cbcookie,\n\t\t\t\t\t\t\t    buf, n);\n\t\t\t\t\tps = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\twsdisplay_emulinput(edp->cbcookie, \"\\033\\\\\", 2);\n\t\t\tbreak;\n\t\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\t\tprintf(\"CSI%d$w unknown\\n\", ARG(0));\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t    case A2('$', '}'): /* DECSASD select active status display */\n\t\tswitch (ARG(0)) {\n\t\t    case 0: /* main display */\n\t\t    case 1: /* status line */\n#ifdef VT100_PRINTNOTIMPL\n\t\t\tprintf(\"CSI%d$} ignored\\n\", ARG(0));\n#endif\n\t\t\tbreak;\n\t\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\t\tprintf(\"CSI%d$} unknown\\n\", ARG(0));\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t    case A2('$', '~'): /* DECSSDD select status line type */\n\t\tswitch (ARG(0)) {\n\t\t    case 0: /* none */\n\t\t    case 1: /* indicator */\n\t\t    case 2: /* host-writable */\n#ifdef VT100_PRINTNOTIMPL\n\t\t\tprintf(\"CSI%d$~ ignored\\n\", ARG(0));\n#endif\n\t\t\tbreak;\n\t\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\t\tprintf(\"CSI%d$~ unknown\\n\", ARG(0));\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t    case A2('&', 'u'): /* DECRQUPSS request user preferred\n\t\t\t\t  supplemental set */\n\t\twsdisplay_emulinput(edp->emulcookie, \"\\033P0!u%5\\033\\\\\", 9);\n\t\tbreak;\n\n\t    case '@': /* ICH insert character VT300 only */\n\t\tn = min(DEF1_ARG(0), COLS_LEFT + 1);\n\t\thelp = NCOLS - (edp->ccol + n);\n\t\tif (help > 0)\n\t\t\tCOPYCOLS(edp->ccol, edp->ccol + n, help);\n\t\tERASECOLS(edp->ccol, n, edp->bkgdattr);\n\t\tbreak;\n\t    case 'A': /* CUU */\n\t\tedp->crow -= min(DEF1_ARG(0), ROWS_ABOVE);\n\t\tCHECK_DW;\n\t\tbreak;\n\t    case 'B': /* CUD */\n\t\tedp->crow += min(DEF1_ARG(0), ROWS_BELOW);\n\t\tCHECK_DW;\n\t\tbreak;\n\t    case 'C': /* CUF */\n\t\tedp->ccol += min(DEF1_ARG(0), COLS_LEFT);\n\t\tbreak;\n\t    case 'D': /* CUB */\n\t\tedp->ccol -= min(DEF1_ARG(0), edp->ccol);\n\t\tedp->flags &= ~VTFL_LASTCHAR;\n\t\tbreak;\n\t    case 'H': /* CUP */\n\t    case 'f': /* HVP */\n\t\tif (edp->flags & VTFL_DECOM)\n\t\t\tedp->crow = edp->scrreg_startrow +\n\t\t\t    min(DEF1_ARG(0), edp->scrreg_nrows) - 1;\n\t\telse\n\t\t\tedp->crow = min(DEF1_ARG(0), edp->nrows) - 1;\n\t\tCHECK_DW;\n\t\tedp->ccol = min(DEF1_ARG(1), NCOLS) - 1;\n\t\tedp->flags &= ~VTFL_LASTCHAR;\n\t\tbreak;\n\t    case 'L': /* IL insert line */\n\t    case 'M': /* DL delete line */\n\t\tn = min(DEF1_ARG(0), ROWS_BELOW + 1);\n\t\t{\n\t\tint savscrstartrow, savscrnrows;\n\t\tsavscrstartrow = edp->scrreg_startrow;\n\t\tsavscrnrows = edp->scrreg_nrows;\n\t\tedp->scrreg_nrows -= ROWS_ABOVE;\n\t\tedp->scrreg_startrow = edp->crow;\n\t\tif (c == 'L')\n\t\t\twsemul_vt100_scrolldown(edp, n);\n\t\telse\n\t\t\twsemul_vt100_scrollup(edp, n);\n\t\tedp->scrreg_startrow = savscrstartrow;\n\t\tedp->scrreg_nrows = savscrnrows;\n\t\t}\n\t\tbreak;\n\t    case 'P': /* DCH delete character */\n\t\tn = min(DEF1_ARG(0), COLS_LEFT + 1);\n\t\thelp = NCOLS - (edp->ccol + n);\n\t\tif (help > 0)\n\t\t\tCOPYCOLS(edp->ccol + n, edp->ccol, help);\n\t\tERASECOLS(NCOLS - n, n, edp->bkgdattr);\n\t\tbreak;\n\t    case 'X': /* ECH erase character */\n\t\tn = min(DEF1_ARG(0), COLS_LEFT + 1);\n\t\tERASECOLS(edp->ccol, n, edp->bkgdattr);\n\t\tbreak;\n\t    case 'c': /* DA primary */\n\t\tif (ARG(0) == 0)\n\t\t\twsdisplay_emulinput(edp->cbcookie, WSEMUL_VT_ID1,\n\t\t\t\t\t    sizeof(WSEMUL_VT_ID1));\n\t\tbreak;\n\t    case 'g': /* TBC */\n\t\tKASSERT(edp->tabs != 0);\n\t\tswitch (ARG(0)) {\n\t\t    case 0:\n\t\t\tedp->tabs[edp->ccol] = 0;\n\t\t\tbreak;\n\t\t    case 3:\n\t\t\tbzero(edp->tabs, edp->ncols);\n\t\t\tbreak;\n\t\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\t\tprintf(\"CSI%dg unknown\\n\", ARG(0));\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t    case 'm': /* SGR select graphic rendition */\n\t\tflags = edp->attrflags;\n\t\tfgcol = edp->fgcol;\n\t\tbgcol = edp->bgcol;\n\t\tfor (n = 0; n < edp->nargs; n++) {\n\t\t\tswitch (ARG(n)) {\n\t\t\t    case 0: /* reset */\n\t\t\t\tif (n == edp->nargs - 1) {\n\t\t\t\t\tedp->bkgdattr = edp->curattr = edp->defattr;\n\t\t\t\t\tedp->attrflags = 0;\n\t\t\t\t\tedp->fgcol = WSCOL_WHITE;\n\t\t\t\t\tedp->bgcol = WSCOL_BLACK;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tflags = 0;\n\t\t\t\tfgcol = WSCOL_WHITE;\n\t\t\t\tbgcol = WSCOL_BLACK;\n\t\t\t\tbreak;\n\t\t\t    case 1: /* bold */\n\t\t\t\tflags |= WSATTR_HILIT;\n\t\t\t\tbreak;\n\t\t\t    case 4: /* underline */\n\t\t\t\tflags |= WSATTR_UNDERLINE;\n\t\t\t\tbreak;\n\t\t\t    case 5: /* blink */\n\t\t\t\tflags |= WSATTR_BLINK;\n\t\t\t\tbreak;\n\t\t\t    case 7: /* reverse */\n\t\t\t\tflags |= WSATTR_REVERSE;\n\t\t\t\tbreak;\n\t\t\t    case 22: /* ~bold VT300 only */\n\t\t\t\tflags &= ~WSATTR_HILIT;\n\t\t\t\tbreak;\n\t\t\t    case 24: /* ~underline VT300 only */\n\t\t\t\tflags &= ~WSATTR_UNDERLINE;\n\t\t\t\tbreak;\n\t\t\t    case 25: /* ~blink VT300 only */\n\t\t\t\tflags &= ~WSATTR_BLINK;\n\t\t\t\tbreak;\n\t\t\t    case 27: /* ~reverse VT300 only */\n\t\t\t\tflags &= ~WSATTR_REVERSE;\n\t\t\t\tbreak;\n\t\t\t    case 30: case 31: case 32: case 33:\n\t\t\t    case 34: case 35: case 36: case 37:\n\t\t\t\t/* fg color */\n\t\t\t\tflags |= WSATTR_WSCOLORS;\n\t\t\t\tfgcol = ARG(n) - 30;\n\t\t\t\tbreak;\n\t\t\t    case 40: case 41: case 42: case 43:\n\t\t\t    case 44: case 45: case 46: case 47:\n\t\t\t\t/* bg color */\n\t\t\t\tflags |= WSATTR_WSCOLORS;\n\t\t\t\tbgcol = ARG(n) - 40;\n\t\t\t\tbreak;\n\t\t\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\t\t\tprintf(\"CSI%dm unknown\\n\", ARG(n));\n#endif\n\t\t\t}\n\t\t}\n\t\tif (vt100_selectattribute(edp, flags, fgcol, bgcol, &attr,\n\t\t    &bkgdattr)) {\n#ifdef VT100_DEBUG\n\t\t\tprintf(\"error allocating attr %d/%d/%x\\n\",\n\t\t\t       fgcol, bgcol, flags);\n#endif\n\t\t} else {\n\t\t\tedp->curattr = attr;\n\t\t\tedp->bkgdattr = bkgdattr;\n\t\t\tedp->attrflags = flags;\n\t\t\tedp->fgcol = fgcol;\n\t\t\tedp->bgcol = bgcol;\n\t\t}\n\t\tbreak;\n\t    case 'n': /* reports */\n\t\tswitch (ARG(0)) {\n\t\t    case 5: /* DSR operating status */\n\t\t\t/* 0 = OK, 3 = malfunction */\n\t\t\twsdisplay_emulinput(edp->cbcookie, \"\\033[0n\", 4);\n\t\t\tbreak;\n\t\t    case 6: { /* DSR cursor position report */\n\t\t\tchar buf[20];\n\t\t\tint row;\n\t\t\tif (edp->flags & VTFL_DECOM)\n\t\t\t\trow = ROWS_ABOVE;\n\t\t\telse\n\t\t\t\trow = edp->crow;\n\t\t\tn = sprintf(buf, \"\\033[%d;%dR\",\n\t\t\t\t    row + 1, edp->ccol + 1);\n\t\t\twsdisplay_emulinput(edp->cbcookie, buf, n);\n\t\t\t}\n\t\t\tbreak;\n\t\t    case 15: /* DSR printer status */\n\t\t\t/* 13 = no printer, 10 = ready, 11 = not ready */\n\t\t\twsdisplay_emulinput(edp->cbcookie, \"\\033[?13n\", 6);\n\t\t\tbreak;\n\t\t    case 25: /* UDK status - VT300 only */\n\t\t\t/* 20 = locked, 21 = unlocked */\n\t\t\twsdisplay_emulinput(edp->cbcookie, \"\\033[?21n\", 6);\n\t\t\tbreak;\n\t\t    case 26: /* keyboard dialect */\n\t\t\t/* 1 = north american , 7 = german */\n\t\t\twsdisplay_emulinput(edp->cbcookie, \"\\033[?27;1n\", 8);\n\t\t\tbreak;\n\t\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\t\tprintf(\"CSI%dn unknown\\n\", ARG(0));\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t    case 'r': /* DECSTBM set top/bottom margins */\n\t\thelp = min(DEF1_ARG(0), edp->nrows) - 1;\n\t\tn = min(DEFx_ARG(1, edp->nrows), edp->nrows) - help;\n\t\tif (n < 2) {\n\t\t\t/* minimal scrolling region has 2 lines */\n\t\t\treturn;\n\t\t} else {\n\t\t\tedp->scrreg_startrow = help;\n\t\t\tedp->scrreg_nrows = n;\n\t\t}\n\t\tedp->crow = ((edp->flags & VTFL_DECOM) ?\n\t\t\t     edp->scrreg_startrow : 0);\n\t\tedp->ccol = 0;\n\t\tbreak;\n\t    case 'y':\n\t\tswitch (ARG(0)) {\n\t\t    case 4: /* DECTST invoke confidence test */\n\t\t\t/* ignore */\n\t\t\tbreak;\n\t\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\t\tprintf(\"CSI%dy unknown\\n\", ARG(0));\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\tprintf(\"CSI%c (%d, %d) unknown\\n\", c, ARG(0), ARG(1));\n#endif\n\t}\n}"
  },
  {
    "function_name": "wsemul_vt100_el",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsemul_vt100_subr.c",
    "lines": "167-190",
    "snippet": "void\nwsemul_vt100_el(edp, arg)\n\tstruct wsemul_vt100_emuldata *edp;\n\tint arg;\n{\n\tswitch (arg) {\n\t    case 0: /* cursor to end */\n\t\tERASECOLS(edp->ccol, COLS_LEFT + 1, edp->bkgdattr);\n\t\tbreak;\n\t    case 1: /* beginning to cursor */\n\t\tERASECOLS(0, edp->ccol + 1, edp->bkgdattr);\n\t\tbreak;\n\t    case 2: /* complete line */\n\t\t(*edp->emulops->erasecols)(edp->emulcookie, edp->crow,\n\t\t\t\t\t   0, edp->ncols,\n\t\t\t\t\t   edp->bkgdattr);\n\t\tbreak;\n\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\tprintf(\"el(%d) unknown\\n\", arg);\n#endif\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include <dev/wscons/wsemul_vt100var.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"el(%d) unknown\\n\"",
            "arg"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "edp->emulcookie",
            "edp->crow",
            "0",
            "edp->ncols",
            "edp->bkgdattr"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERASECOLS",
          "args": [
            "0",
            "edp->ccol + 1",
            "edp->bkgdattr"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERASECOLS",
          "args": [
            "edp->ccol",
            "COLS_LEFT + 1",
            "edp->bkgdattr"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsemul_vt100var.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwsemul_vt100_el(edp, arg)\n\tstruct wsemul_vt100_emuldata *edp;\n\tint arg;\n{\n\tswitch (arg) {\n\t    case 0: /* cursor to end */\n\t\tERASECOLS(edp->ccol, COLS_LEFT + 1, edp->bkgdattr);\n\t\tbreak;\n\t    case 1: /* beginning to cursor */\n\t\tERASECOLS(0, edp->ccol + 1, edp->bkgdattr);\n\t\tbreak;\n\t    case 2: /* complete line */\n\t\t(*edp->emulops->erasecols)(edp->emulcookie, edp->crow,\n\t\t\t\t\t   0, edp->ncols,\n\t\t\t\t\t   edp->bkgdattr);\n\t\tbreak;\n\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\tprintf(\"el(%d) unknown\\n\", arg);\n#endif\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "wsemul_vt100_ed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsemul_vt100_subr.c",
    "lines": "119-162",
    "snippet": "void\nwsemul_vt100_ed(edp, arg)\n\tstruct wsemul_vt100_emuldata *edp;\n\tint arg;\n{\n\tint n;\n\n\tswitch (arg) {\n\t    case 0: /* cursor to end */\n\t\tERASECOLS(edp->ccol, COLS_LEFT + 1, edp->bkgdattr);\n\t\tn = edp->nrows - edp->crow - 1;\n\t\tif (n > 0) {\n\t\t\t(*edp->emulops->eraserows)(edp->emulcookie,\n\t\t\t\t\t\t   edp->crow + 1, n,\n\t\t\t\t\t\t   edp->bkgdattr);\n\t\t\tif (edp->dblwid)\n\t\t\t\tbzero(&edp->dblwid[edp->crow + 1], n);\n\t\t}\n\t\tbreak;\n\t    case 1: /* beginning to cursor */\n\t\tif (edp->crow > 0) {\n\t\t\t(*edp->emulops->eraserows)(edp->emulcookie,\n\t\t\t\t\t\t   0, edp->crow,\n\t\t\t\t\t\t   edp->bkgdattr);\n\t\t\tif (edp->dblwid)\n\t\t\t\tbzero(&edp->dblwid[0], edp->crow);\n\t\t}\n\t\tERASECOLS(0, edp->ccol + 1, edp->bkgdattr);\n\t\tbreak;\n\t    case 2: /* complete display */\n\t\t(*edp->emulops->eraserows)(edp->emulcookie,\n\t\t\t\t\t   0, edp->nrows,\n\t\t\t\t\t   edp->bkgdattr);\n\t\tif (edp->dblwid)\n\t\t\tbzero(&edp->dblwid[0], edp->nrows);\n\t\tbreak;\n\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\tprintf(\"ed(%d) unknown\\n\", arg);\n#endif\n\t\tbreak;\n\t}\n\tCHECK_DW;\n}",
    "includes": [
      "#include <dev/wscons/wsemul_vt100var.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ed(%d) unknown\\n\"",
            "arg"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "&edp->dblwid[0]",
            "edp->nrows"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "edp->emulcookie",
            "0",
            "edp->nrows",
            "edp->bkgdattr"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERASECOLS",
          "args": [
            "0",
            "edp->ccol + 1",
            "edp->bkgdattr"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "&edp->dblwid[0]",
            "edp->crow"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "edp->emulcookie",
            "0",
            "edp->crow",
            "edp->bkgdattr"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "&edp->dblwid[edp->crow + 1]",
            "n"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "edp->emulcookie",
            "edp->crow + 1",
            "n",
            "edp->bkgdattr"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERASECOLS",
          "args": [
            "edp->ccol",
            "COLS_LEFT + 1",
            "edp->bkgdattr"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsemul_vt100var.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwsemul_vt100_ed(edp, arg)\n\tstruct wsemul_vt100_emuldata *edp;\n\tint arg;\n{\n\tint n;\n\n\tswitch (arg) {\n\t    case 0: /* cursor to end */\n\t\tERASECOLS(edp->ccol, COLS_LEFT + 1, edp->bkgdattr);\n\t\tn = edp->nrows - edp->crow - 1;\n\t\tif (n > 0) {\n\t\t\t(*edp->emulops->eraserows)(edp->emulcookie,\n\t\t\t\t\t\t   edp->crow + 1, n,\n\t\t\t\t\t\t   edp->bkgdattr);\n\t\t\tif (edp->dblwid)\n\t\t\t\tbzero(&edp->dblwid[edp->crow + 1], n);\n\t\t}\n\t\tbreak;\n\t    case 1: /* beginning to cursor */\n\t\tif (edp->crow > 0) {\n\t\t\t(*edp->emulops->eraserows)(edp->emulcookie,\n\t\t\t\t\t\t   0, edp->crow,\n\t\t\t\t\t\t   edp->bkgdattr);\n\t\t\tif (edp->dblwid)\n\t\t\t\tbzero(&edp->dblwid[0], edp->crow);\n\t\t}\n\t\tERASECOLS(0, edp->ccol + 1, edp->bkgdattr);\n\t\tbreak;\n\t    case 2: /* complete display */\n\t\t(*edp->emulops->eraserows)(edp->emulcookie,\n\t\t\t\t\t   0, edp->nrows,\n\t\t\t\t\t   edp->bkgdattr);\n\t\tif (edp->dblwid)\n\t\t\tbzero(&edp->dblwid[0], edp->nrows);\n\t\tbreak;\n\t    default:\n#ifdef VT100_PRINTUNKNOWN\n\t\tprintf(\"ed(%d) unknown\\n\", arg);\n#endif\n\t\tbreak;\n\t}\n\tCHECK_DW;\n}"
  },
  {
    "function_name": "wsemul_vt100_scrolldown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsemul_vt100_subr.c",
    "lines": "87-114",
    "snippet": "void\nwsemul_vt100_scrolldown(edp, n)\n\tstruct wsemul_vt100_emuldata *edp;\n\tint n;\n{\n\tint help;\n\n\tif (n > edp->scrreg_nrows)\n\t\tn = edp->scrreg_nrows;\n\n\thelp = edp->scrreg_nrows - n;\n\tif (help > 0) {\n\t\t(*edp->emulops->copyrows)(edp->emulcookie,\n\t\t\t\t\t  edp->scrreg_startrow,\n\t\t\t\t\t  edp->scrreg_startrow + n,\n\t\t\t\t\t  help);\n\t\tif (edp->dblwid)\n\t\t\tmemmove(&edp->dblwid[edp->scrreg_startrow + n],\n\t\t\t\t&edp->dblwid[edp->scrreg_startrow],\n\t\t\t\thelp);\n\t}\n\t(*edp->emulops->eraserows)(edp->emulcookie,\n\t\t\t\t   edp->scrreg_startrow, n,\n\t\t\t\t   edp->bkgdattr);\n\tif (edp->dblwid)\n\t\tbzero(&edp->dblwid[edp->scrreg_startrow], n);\n\tCHECK_DW;\n}",
    "includes": [
      "#include <dev/wscons/wsemul_vt100var.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "&edp->dblwid[edp->scrreg_startrow]",
            "n"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "edp->emulcookie",
            "edp->scrreg_startrow",
            "n",
            "edp->bkgdattr"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&edp->dblwid[edp->scrreg_startrow + n]",
            "&edp->dblwid[edp->scrreg_startrow]",
            "help"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "edp->emulcookie",
            "edp->scrreg_startrow",
            "edp->scrreg_startrow + n",
            "help"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsemul_vt100var.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwsemul_vt100_scrolldown(edp, n)\n\tstruct wsemul_vt100_emuldata *edp;\n\tint n;\n{\n\tint help;\n\n\tif (n > edp->scrreg_nrows)\n\t\tn = edp->scrreg_nrows;\n\n\thelp = edp->scrreg_nrows - n;\n\tif (help > 0) {\n\t\t(*edp->emulops->copyrows)(edp->emulcookie,\n\t\t\t\t\t  edp->scrreg_startrow,\n\t\t\t\t\t  edp->scrreg_startrow + n,\n\t\t\t\t\t  help);\n\t\tif (edp->dblwid)\n\t\t\tmemmove(&edp->dblwid[edp->scrreg_startrow + n],\n\t\t\t\t&edp->dblwid[edp->scrreg_startrow],\n\t\t\t\thelp);\n\t}\n\t(*edp->emulops->eraserows)(edp->emulcookie,\n\t\t\t\t   edp->scrreg_startrow, n,\n\t\t\t\t   edp->bkgdattr);\n\tif (edp->dblwid)\n\t\tbzero(&edp->dblwid[edp->scrreg_startrow], n);\n\tCHECK_DW;\n}"
  },
  {
    "function_name": "wsemul_vt100_scrollup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsemul_vt100_subr.c",
    "lines": "55-82",
    "snippet": "void\nwsemul_vt100_scrollup(edp, n)\n\tstruct wsemul_vt100_emuldata *edp;\n\tint n;\n{\n\tint help;\n\n\tif (n > edp->scrreg_nrows)\n\t\tn = edp->scrreg_nrows;\n\n\thelp = edp->scrreg_nrows - n;\n\tif (help > 0) {\n\t\t(*edp->emulops->copyrows)(edp->emulcookie,\n\t\t\t\t\t  edp->scrreg_startrow + n,\n\t\t\t\t\t  edp->scrreg_startrow,\n\t\t\t\t\t  help);\n\t\tif (edp->dblwid)\n\t\t\tmemmove(&edp->dblwid[edp->scrreg_startrow],\n\t\t\t\t&edp->dblwid[edp->scrreg_startrow + n],\n\t\t\t\thelp);\n\t}\n\t(*edp->emulops->eraserows)(edp->emulcookie,\n\t\t\t\t   edp->scrreg_startrow + help, n,\n\t\t\t\t   edp->bkgdattr);\n\tif (edp->dblwid)\n\t\tbzero(&edp->dblwid[edp->scrreg_startrow + help], n);\n\tCHECK_DW;\n}",
    "includes": [
      "#include <dev/wscons/wsemul_vt100var.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "&edp->dblwid[edp->scrreg_startrow + help]",
            "n"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "edp->emulcookie",
            "edp->scrreg_startrow + help",
            "n",
            "edp->bkgdattr"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&edp->dblwid[edp->scrreg_startrow]",
            "&edp->dblwid[edp->scrreg_startrow + n]",
            "help"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "edp->emulcookie",
            "edp->scrreg_startrow + n",
            "edp->scrreg_startrow",
            "help"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsemul_vt100var.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwsemul_vt100_scrollup(edp, n)\n\tstruct wsemul_vt100_emuldata *edp;\n\tint n;\n{\n\tint help;\n\n\tif (n > edp->scrreg_nrows)\n\t\tn = edp->scrreg_nrows;\n\n\thelp = edp->scrreg_nrows - n;\n\tif (help > 0) {\n\t\t(*edp->emulops->copyrows)(edp->emulcookie,\n\t\t\t\t\t  edp->scrreg_startrow + n,\n\t\t\t\t\t  edp->scrreg_startrow,\n\t\t\t\t\t  help);\n\t\tif (edp->dblwid)\n\t\t\tmemmove(&edp->dblwid[edp->scrreg_startrow],\n\t\t\t\t&edp->dblwid[edp->scrreg_startrow + n],\n\t\t\t\thelp);\n\t}\n\t(*edp->emulops->eraserows)(edp->emulcookie,\n\t\t\t\t   edp->scrreg_startrow + help, n,\n\t\t\t\t   edp->bkgdattr);\n\tif (edp->dblwid)\n\t\tbzero(&edp->dblwid[edp->scrreg_startrow + help], n);\n\tCHECK_DW;\n}"
  }
]