[
  {
    "function_name": "mcd_setlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
    "lines": "1804-1816",
    "snippet": "int\nmcd_setlock(sc, mode)\n\tstruct mcd_softc *sc;\n\tint mode;\n{\n\tstruct mcd_mbox mbx;\n\t\n\tmbx.cmd.opcode = MCD_CMDSETLOCK;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.lockmode);\n\tmbx.cmd.data.lockmode.mode = mode;\n\tmbx.res.length = 0;\n\treturn mcd_send(sc, &mbx, 1);\n}",
    "includes": [
      "#include <lib/libkern/libkern.h>",
      "#include <dev/isa/opti.h>",
      "#include <dev/isa/mcdreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/errno.h>",
      "#include <sys/cdio.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/uio.h>",
      "#include <sys/stat.h>",
      "#include <sys/buf.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int mcd_send",
      "int mcd_setlock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mcd_send",
          "args": [
            "sc",
            "&mbx",
            "1"
          ],
          "line": 1815
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1044-1077",
          "snippet": "int\nmcd_send(sc, mbx, diskin)\n\tstruct mcd_softc *sc;\n\tstruct mcd_mbox *mbx;\n\tint diskin;\n{\n\tint retry, i, error;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\t\n\tif (sc->debug) {\n\t\tprintf(\"%s: mcd_send: %d %02x\", sc->sc_dev.dv_xname,\n\t\t    mbx->cmd.length, (u_int)mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tprintf(\" %02x\", (u_int)mbx->cmd.data.raw.data[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tfor (retry = MCD_RETRIES; retry; retry--) {\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.data.raw.data[i]);\n\t\tif ((error = mcd_getresult(sc, &mbx->res)) == 0)\n\t\t\tbreak;\n\t\tif (error == EINVAL)\n\t\t\treturn error;\n\t}\n\tif (!retry)\n\t\treturn error;\n\tif (diskin && (sc->flags & MCDF_LOADED) == 0)\n\t\treturn EIO;\n\n\treturn 0;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MCD_RETRIES\t3",
            "#define\tMCDF_LOADED\t0x10\t/* parameters loaded */"
          ],
          "globals_used": [
            "int mcd_getresult",
            "int mcd_send"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MCD_RETRIES\t3\n#define\tMCDF_LOADED\t0x10\t/* parameters loaded */\n\nint mcd_getresult;\nint mcd_send;\n\nint\nmcd_send(sc, mbx, diskin)\n\tstruct mcd_softc *sc;\n\tstruct mcd_mbox *mbx;\n\tint diskin;\n{\n\tint retry, i, error;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\t\n\tif (sc->debug) {\n\t\tprintf(\"%s: mcd_send: %d %02x\", sc->sc_dev.dv_xname,\n\t\t    mbx->cmd.length, (u_int)mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tprintf(\" %02x\", (u_int)mbx->cmd.data.raw.data[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tfor (retry = MCD_RETRIES; retry; retry--) {\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.data.raw.data[i]);\n\t\tif ((error = mcd_getresult(sc, &mbx->res)) == 0)\n\t\t\tbreak;\n\t\tif (error == EINVAL)\n\t\t\treturn error;\n\t}\n\tif (!retry)\n\t\treturn error;\n\tif (diskin && (sc->flags & MCDF_LOADED) == 0)\n\t\treturn EIO;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint mcd_send;\nint mcd_setlock;\n\nint\nmcd_setlock(sc, mode)\n\tstruct mcd_softc *sc;\n\tint mode;\n{\n\tstruct mcd_mbox mbx;\n\t\n\tmbx.cmd.opcode = MCD_CMDSETLOCK;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.lockmode);\n\tmbx.cmd.data.lockmode.mode = mode;\n\tmbx.res.length = 0;\n\treturn mcd_send(sc, &mbx, 1);\n}"
  },
  {
    "function_name": "mcd_eject",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
    "lines": "1792-1802",
    "snippet": "int\nmcd_eject(sc)\n\tstruct mcd_softc *sc;\n{\n\tstruct mcd_mbox mbx;\n\n\tmbx.cmd.opcode = MCD_CMDEJECTDISK;\n\tmbx.cmd.length = 0;\n\tmbx.res.length = 0;\n\treturn mcd_send(sc, &mbx, 0);\n}",
    "includes": [
      "#include <lib/libkern/libkern.h>",
      "#include <dev/isa/opti.h>",
      "#include <dev/isa/mcdreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/errno.h>",
      "#include <sys/cdio.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/uio.h>",
      "#include <sys/stat.h>",
      "#include <sys/buf.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int mcd_eject",
      "int mcd_send"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mcd_send",
          "args": [
            "sc",
            "&mbx",
            "0"
          ],
          "line": 1801
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1044-1077",
          "snippet": "int\nmcd_send(sc, mbx, diskin)\n\tstruct mcd_softc *sc;\n\tstruct mcd_mbox *mbx;\n\tint diskin;\n{\n\tint retry, i, error;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\t\n\tif (sc->debug) {\n\t\tprintf(\"%s: mcd_send: %d %02x\", sc->sc_dev.dv_xname,\n\t\t    mbx->cmd.length, (u_int)mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tprintf(\" %02x\", (u_int)mbx->cmd.data.raw.data[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tfor (retry = MCD_RETRIES; retry; retry--) {\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.data.raw.data[i]);\n\t\tif ((error = mcd_getresult(sc, &mbx->res)) == 0)\n\t\t\tbreak;\n\t\tif (error == EINVAL)\n\t\t\treturn error;\n\t}\n\tif (!retry)\n\t\treturn error;\n\tif (diskin && (sc->flags & MCDF_LOADED) == 0)\n\t\treturn EIO;\n\n\treturn 0;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MCD_RETRIES\t3",
            "#define\tMCDF_LOADED\t0x10\t/* parameters loaded */"
          ],
          "globals_used": [
            "int mcd_getresult",
            "int mcd_send"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MCD_RETRIES\t3\n#define\tMCDF_LOADED\t0x10\t/* parameters loaded */\n\nint mcd_getresult;\nint mcd_send;\n\nint\nmcd_send(sc, mbx, diskin)\n\tstruct mcd_softc *sc;\n\tstruct mcd_mbox *mbx;\n\tint diskin;\n{\n\tint retry, i, error;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\t\n\tif (sc->debug) {\n\t\tprintf(\"%s: mcd_send: %d %02x\", sc->sc_dev.dv_xname,\n\t\t    mbx->cmd.length, (u_int)mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tprintf(\" %02x\", (u_int)mbx->cmd.data.raw.data[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tfor (retry = MCD_RETRIES; retry; retry--) {\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.data.raw.data[i]);\n\t\tif ((error = mcd_getresult(sc, &mbx->res)) == 0)\n\t\t\tbreak;\n\t\tif (error == EINVAL)\n\t\t\treturn error;\n\t}\n\tif (!retry)\n\t\treturn error;\n\tif (diskin && (sc->flags & MCDF_LOADED) == 0)\n\t\treturn EIO;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint mcd_eject;\nint mcd_send;\n\nint\nmcd_eject(sc)\n\tstruct mcd_softc *sc;\n{\n\tstruct mcd_mbox mbx;\n\n\tmbx.cmd.opcode = MCD_CMDEJECTDISK;\n\tmbx.cmd.length = 0;\n\tmbx.res.length = 0;\n\treturn mcd_send(sc, &mbx, 0);\n}"
  },
  {
    "function_name": "mcd_resume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
    "lines": "1774-1790",
    "snippet": "int\nmcd_resume(sc)\n\tstruct mcd_softc *sc;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (sc->audio_status != CD_AS_PLAY_PAUSED)\n\t\treturn EINVAL;\n\n\tif ((error = mcd_setmode(sc, MCD_MD_COOKED)) != 0)\n\t\treturn error;\n\n\tmbx.cmd = sc->lastpb;\n\tmbx.res.length = 0;\n\treturn mcd_send(sc, &mbx, 1);\n}",
    "includes": [
      "#include <lib/libkern/libkern.h>",
      "#include <dev/isa/opti.h>",
      "#include <dev/isa/mcdreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/errno.h>",
      "#include <sys/cdio.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/uio.h>",
      "#include <sys/stat.h>",
      "#include <sys/buf.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int mcd_resume",
      "int mcd_send",
      "int mcd_setmode"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mcd_send",
          "args": [
            "sc",
            "&mbx",
            "1"
          ],
          "line": 1789
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1044-1077",
          "snippet": "int\nmcd_send(sc, mbx, diskin)\n\tstruct mcd_softc *sc;\n\tstruct mcd_mbox *mbx;\n\tint diskin;\n{\n\tint retry, i, error;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\t\n\tif (sc->debug) {\n\t\tprintf(\"%s: mcd_send: %d %02x\", sc->sc_dev.dv_xname,\n\t\t    mbx->cmd.length, (u_int)mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tprintf(\" %02x\", (u_int)mbx->cmd.data.raw.data[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tfor (retry = MCD_RETRIES; retry; retry--) {\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.data.raw.data[i]);\n\t\tif ((error = mcd_getresult(sc, &mbx->res)) == 0)\n\t\t\tbreak;\n\t\tif (error == EINVAL)\n\t\t\treturn error;\n\t}\n\tif (!retry)\n\t\treturn error;\n\tif (diskin && (sc->flags & MCDF_LOADED) == 0)\n\t\treturn EIO;\n\n\treturn 0;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MCD_RETRIES\t3",
            "#define\tMCDF_LOADED\t0x10\t/* parameters loaded */"
          ],
          "globals_used": [
            "int mcd_getresult",
            "int mcd_send"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MCD_RETRIES\t3\n#define\tMCDF_LOADED\t0x10\t/* parameters loaded */\n\nint mcd_getresult;\nint mcd_send;\n\nint\nmcd_send(sc, mbx, diskin)\n\tstruct mcd_softc *sc;\n\tstruct mcd_mbox *mbx;\n\tint diskin;\n{\n\tint retry, i, error;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\t\n\tif (sc->debug) {\n\t\tprintf(\"%s: mcd_send: %d %02x\", sc->sc_dev.dv_xname,\n\t\t    mbx->cmd.length, (u_int)mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tprintf(\" %02x\", (u_int)mbx->cmd.data.raw.data[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tfor (retry = MCD_RETRIES; retry; retry--) {\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.data.raw.data[i]);\n\t\tif ((error = mcd_getresult(sc, &mbx->res)) == 0)\n\t\t\tbreak;\n\t\tif (error == EINVAL)\n\t\t\treturn error;\n\t}\n\tif (!retry)\n\t\treturn error;\n\tif (diskin && (sc->flags & MCDF_LOADED) == 0)\n\t\treturn EIO;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mcd_setmode",
          "args": [
            "sc",
            "MCD_MD_COOKED"
          ],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_setmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1312-1335",
          "snippet": "int\nmcd_setmode(sc, mode)\n\tstruct mcd_softc *sc;\n\tint mode;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (sc->lastmode == mode)\n\t\treturn 0;\n\tif (sc->debug)\n\t\tprintf(\"%s: setting mode to %d\\n\", sc->sc_dev.dv_xname, mode);\n\tsc->lastmode = MCD_MD_UNKNOWN;\n\n\tmbx.cmd.opcode = MCD_CMDSETMODE;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.datamode);\n\tmbx.cmd.data.datamode.mode = mode;\n\tmbx.res.length = 0;\n\tif ((error = mcd_send(sc, &mbx, 1)) != 0)\n\t\treturn error;\n\n\tsc->lastmode = mode;\n\treturn 0;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tMCD_MD_UNKNOWN\t-1"
          ],
          "globals_used": [
            "int mcd_send",
            "int mcd_setmode"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tMCD_MD_UNKNOWN\t-1\n\nint mcd_send;\nint mcd_setmode;\n\nint\nmcd_setmode(sc, mode)\n\tstruct mcd_softc *sc;\n\tint mode;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (sc->lastmode == mode)\n\t\treturn 0;\n\tif (sc->debug)\n\t\tprintf(\"%s: setting mode to %d\\n\", sc->sc_dev.dv_xname, mode);\n\tsc->lastmode = MCD_MD_UNKNOWN;\n\n\tmbx.cmd.opcode = MCD_CMDSETMODE;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.datamode);\n\tmbx.cmd.data.datamode.mode = mode;\n\tmbx.res.length = 0;\n\tif ((error = mcd_send(sc, &mbx, 1)) != 0)\n\t\treturn error;\n\n\tsc->lastmode = mode;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint mcd_resume;\nint mcd_send;\nint mcd_setmode;\n\nint\nmcd_resume(sc)\n\tstruct mcd_softc *sc;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (sc->audio_status != CD_AS_PLAY_PAUSED)\n\t\treturn EINVAL;\n\n\tif ((error = mcd_setmode(sc, MCD_MD_COOKED)) != 0)\n\t\treturn error;\n\n\tmbx.cmd = sc->lastpb;\n\tmbx.res.length = 0;\n\treturn mcd_send(sc, &mbx, 1);\n}"
  },
  {
    "function_name": "mcd_pause",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
    "lines": "1742-1772",
    "snippet": "int\nmcd_pause(sc)\n\tstruct mcd_softc *sc;\n{\n\tunion mcd_qchninfo q;\n\tint error;\n\n\t/* Verify current status. */\n\tif (sc->audio_status != CD_AS_PLAY_IN_PROGRESS)\t{\n\t\tprintf(\"%s: pause: attempted when not playing\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn EINVAL;\n\t}\n\n\t/* Get the current position. */\n\tif ((error = mcd_getqchan(sc, &q, CD_CURRENT_POSITION)) != 0)\n\t\treturn error;\n\n\t/* Copy it into lastpb. */\n\tsc->lastpb.data.seek.start_msf[0] = q.current.absolute_pos[0];\n\tsc->lastpb.data.seek.start_msf[1] = q.current.absolute_pos[1];\n\tsc->lastpb.data.seek.start_msf[2] = q.current.absolute_pos[2];\n\n\t/* Stop playing. */\n\tif ((error = mcd_stop(sc)) != 0)\n\t\treturn error;\n\n\t/* Set the proper status and exit. */\n\tsc->audio_status = CD_AS_PLAY_PAUSED;\n\treturn 0;\n}",
    "includes": [
      "#include <lib/libkern/libkern.h>",
      "#include <dev/isa/opti.h>",
      "#include <dev/isa/mcdreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/errno.h>",
      "#include <sys/cdio.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/uio.h>",
      "#include <sys/stat.h>",
      "#include <sys/buf.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int mcd_stop",
      "int mcd_pause",
      "int mcd_getqchan"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mcd_stop",
          "args": [
            "sc"
          ],
          "line": 1766
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1503-1521",
          "snippet": "int\nmcd_stop(sc)\n\tstruct mcd_softc *sc;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (sc->debug)\n\t\tprintf(\"%s: mcd_stop: stopping play\\n\", sc->sc_dev.dv_xname);\n\n\tmbx.cmd.opcode = MCD_CMDSTOPAUDIO;\n\tmbx.cmd.length = 0;\n\tmbx.res.length = 0;\n\tif ((error = mcd_send(sc, &mbx, 1)) != 0)\n\t\treturn error;\n\n\tsc->audio_status = CD_AS_PLAY_COMPLETED;\n\treturn 0;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int mcd_stop",
            "int mcd_send"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint mcd_stop;\nint mcd_send;\n\nint\nmcd_stop(sc)\n\tstruct mcd_softc *sc;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (sc->debug)\n\t\tprintf(\"%s: mcd_stop: stopping play\\n\", sc->sc_dev.dv_xname);\n\n\tmbx.cmd.opcode = MCD_CMDSTOPAUDIO;\n\tmbx.cmd.length = 0;\n\tmbx.res.length = 0;\n\tif ((error = mcd_send(sc, &mbx, 1)) != 0)\n\t\treturn error;\n\n\tsc->audio_status = CD_AS_PLAY_COMPLETED;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mcd_getqchan",
          "args": [
            "sc",
            "&q",
            "CD_CURRENT_POSITION"
          ],
          "line": 1757
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_getqchan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1523-1555",
          "snippet": "int\nmcd_getqchan(sc, q, qchn)\n\tstruct mcd_softc *sc;\n\tunion mcd_qchninfo *q;\n\tint qchn;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (qchn == CD_TRACK_INFO) {\n\t\tif ((error = mcd_setmode(sc, MCD_MD_TOC)) != 0)\n\t\t\treturn error;\n\t} else {\n\t\tif ((error = mcd_setmode(sc, MCD_MD_COOKED)) != 0)\n\t\t\treturn error;\n\t}\n\tif (qchn == CD_MEDIA_CATALOG) {\n\t\tif ((error = mcd_setupc(sc, MCD_UPC_ENABLE)) != 0)\n\t\t\treturn error;\n\t} else {\n\t\tif ((error = mcd_setupc(sc, MCD_UPC_DISABLE)) != 0)\n\t\t\treturn error;\n\t}\n\n\tmbx.cmd.opcode = MCD_CMDGETQCHN;\n\tmbx.cmd.length = 0;\n\tmbx.res.length = sizeof(mbx.res.data.qchninfo);\n\tif ((error = mcd_send(sc, &mbx, 1)) != 0)\n\t\treturn error;\n\n\t*q = mbx.res.data.qchninfo;\n\treturn 0;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int mcd_send",
            "int mcd_setmode",
            "int mcd_setupc",
            "int mcd_getqchan"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint mcd_send;\nint mcd_setmode;\nint mcd_setupc;\nint mcd_getqchan;\n\nint\nmcd_getqchan(sc, q, qchn)\n\tstruct mcd_softc *sc;\n\tunion mcd_qchninfo *q;\n\tint qchn;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (qchn == CD_TRACK_INFO) {\n\t\tif ((error = mcd_setmode(sc, MCD_MD_TOC)) != 0)\n\t\t\treturn error;\n\t} else {\n\t\tif ((error = mcd_setmode(sc, MCD_MD_COOKED)) != 0)\n\t\t\treturn error;\n\t}\n\tif (qchn == CD_MEDIA_CATALOG) {\n\t\tif ((error = mcd_setupc(sc, MCD_UPC_ENABLE)) != 0)\n\t\t\treturn error;\n\t} else {\n\t\tif ((error = mcd_setupc(sc, MCD_UPC_DISABLE)) != 0)\n\t\t\treturn error;\n\t}\n\n\tmbx.cmd.opcode = MCD_CMDGETQCHN;\n\tmbx.cmd.length = 0;\n\tmbx.res.length = sizeof(mbx.res.data.qchninfo);\n\tif ((error = mcd_send(sc, &mbx, 1)) != 0)\n\t\treturn error;\n\n\t*q = mbx.res.data.qchninfo;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: pause: attempted when not playing\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1751
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint mcd_stop;\nint mcd_pause;\nint mcd_getqchan;\n\nint\nmcd_pause(sc)\n\tstruct mcd_softc *sc;\n{\n\tunion mcd_qchninfo q;\n\tint error;\n\n\t/* Verify current status. */\n\tif (sc->audio_status != CD_AS_PLAY_IN_PROGRESS)\t{\n\t\tprintf(\"%s: pause: attempted when not playing\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn EINVAL;\n\t}\n\n\t/* Get the current position. */\n\tif ((error = mcd_getqchan(sc, &q, CD_CURRENT_POSITION)) != 0)\n\t\treturn error;\n\n\t/* Copy it into lastpb. */\n\tsc->lastpb.data.seek.start_msf[0] = q.current.absolute_pos[0];\n\tsc->lastpb.data.seek.start_msf[1] = q.current.absolute_pos[1];\n\tsc->lastpb.data.seek.start_msf[2] = q.current.absolute_pos[2];\n\n\t/* Stop playing. */\n\tif ((error = mcd_stop(sc)) != 0)\n\t\treturn error;\n\n\t/* Set the proper status and exit. */\n\tsc->audio_status = CD_AS_PLAY_PAUSED;\n\treturn 0;\n}"
  },
  {
    "function_name": "mcd_playblocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
    "lines": "1714-1740",
    "snippet": "int\nmcd_playblocks(sc, p)\n\tstruct mcd_softc *sc;\n\tstruct ioc_play_blocks *p;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (sc->debug)\n\t\tprintf(\"%s: playblocks: blkno %d length %d\\n\",\n\t\t    sc->sc_dev.dv_xname, p->blk, p->len);\n\n\tif (p->blk > sc->disksize || p->len > sc->disksize ||\n\t    (p->blk + p->len) > sc->disksize)\n\t\treturn 0;\n\n\tif ((error = mcd_setmode(sc, MCD_MD_COOKED)) != 0)\n\t\treturn error;\n\n\tmbx.cmd.opcode = MCD_CMDREADSINGLESPEED;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.play);\n\thsg2msf(p->blk, mbx.cmd.data.play.start_msf);\n\thsg2msf(p->blk + p->len, mbx.cmd.data.play.end_msf);\n\tsc->lastpb = mbx.cmd;\n\tmbx.res.length = 0;\n\treturn mcd_send(sc, &mbx, 1);\n}",
    "includes": [
      "#include <lib/libkern/libkern.h>",
      "#include <dev/isa/opti.h>",
      "#include <dev/isa/mcdreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/errno.h>",
      "#include <sys/cdio.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/uio.h>",
      "#include <sys/stat.h>",
      "#include <sys/buf.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void hsg2msf",
      "int mcd_playblocks",
      "int mcd_send",
      "int mcd_setmode"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mcd_send",
          "args": [
            "sc",
            "&mbx",
            "1"
          ],
          "line": 1739
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1044-1077",
          "snippet": "int\nmcd_send(sc, mbx, diskin)\n\tstruct mcd_softc *sc;\n\tstruct mcd_mbox *mbx;\n\tint diskin;\n{\n\tint retry, i, error;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\t\n\tif (sc->debug) {\n\t\tprintf(\"%s: mcd_send: %d %02x\", sc->sc_dev.dv_xname,\n\t\t    mbx->cmd.length, (u_int)mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tprintf(\" %02x\", (u_int)mbx->cmd.data.raw.data[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tfor (retry = MCD_RETRIES; retry; retry--) {\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.data.raw.data[i]);\n\t\tif ((error = mcd_getresult(sc, &mbx->res)) == 0)\n\t\t\tbreak;\n\t\tif (error == EINVAL)\n\t\t\treturn error;\n\t}\n\tif (!retry)\n\t\treturn error;\n\tif (diskin && (sc->flags & MCDF_LOADED) == 0)\n\t\treturn EIO;\n\n\treturn 0;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MCD_RETRIES\t3",
            "#define\tMCDF_LOADED\t0x10\t/* parameters loaded */"
          ],
          "globals_used": [
            "int mcd_getresult",
            "int mcd_send"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MCD_RETRIES\t3\n#define\tMCDF_LOADED\t0x10\t/* parameters loaded */\n\nint mcd_getresult;\nint mcd_send;\n\nint\nmcd_send(sc, mbx, diskin)\n\tstruct mcd_softc *sc;\n\tstruct mcd_mbox *mbx;\n\tint diskin;\n{\n\tint retry, i, error;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\t\n\tif (sc->debug) {\n\t\tprintf(\"%s: mcd_send: %d %02x\", sc->sc_dev.dv_xname,\n\t\t    mbx->cmd.length, (u_int)mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tprintf(\" %02x\", (u_int)mbx->cmd.data.raw.data[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tfor (retry = MCD_RETRIES; retry; retry--) {\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.data.raw.data[i]);\n\t\tif ((error = mcd_getresult(sc, &mbx->res)) == 0)\n\t\t\tbreak;\n\t\tif (error == EINVAL)\n\t\t\treturn error;\n\t}\n\tif (!retry)\n\t\treturn error;\n\tif (diskin && (sc->flags & MCDF_LOADED) == 0)\n\t\treturn EIO;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hsg2msf",
          "args": [
            "p->blk + p->len",
            "mbx.cmd.data.play.end_msf"
          ],
          "line": 1736
        },
        "resolved": true,
        "details": {
          "function_name": "hsg2msf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1079-1091",
          "snippet": "static void\nhsg2msf(hsg, msf)\n\tint hsg;\n\tbcd_t *msf;\n{\n\n\thsg += 150;\n\tF_msf(msf) = bin2bcd(hsg % 75);\n\thsg /= 75;\n\tS_msf(msf) = bin2bcd(hsg % 60);\n\thsg /= 60;\n\tM_msf(msf) = bin2bcd(hsg);\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void hsg2msf",
            "__P((int, bcd_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void hsg2msf;\n__P((int, bcd_t *));\n\nstatic void\nhsg2msf(hsg, msf)\n\tint hsg;\n\tbcd_t *msf;\n{\n\n\thsg += 150;\n\tF_msf(msf) = bin2bcd(hsg % 75);\n\thsg /= 75;\n\tS_msf(msf) = bin2bcd(hsg % 60);\n\thsg /= 60;\n\tM_msf(msf) = bin2bcd(hsg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mcd_setmode",
          "args": [
            "sc",
            "MCD_MD_COOKED"
          ],
          "line": 1730
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_setmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1312-1335",
          "snippet": "int\nmcd_setmode(sc, mode)\n\tstruct mcd_softc *sc;\n\tint mode;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (sc->lastmode == mode)\n\t\treturn 0;\n\tif (sc->debug)\n\t\tprintf(\"%s: setting mode to %d\\n\", sc->sc_dev.dv_xname, mode);\n\tsc->lastmode = MCD_MD_UNKNOWN;\n\n\tmbx.cmd.opcode = MCD_CMDSETMODE;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.datamode);\n\tmbx.cmd.data.datamode.mode = mode;\n\tmbx.res.length = 0;\n\tif ((error = mcd_send(sc, &mbx, 1)) != 0)\n\t\treturn error;\n\n\tsc->lastmode = mode;\n\treturn 0;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tMCD_MD_UNKNOWN\t-1"
          ],
          "globals_used": [
            "int mcd_send",
            "int mcd_setmode"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tMCD_MD_UNKNOWN\t-1\n\nint mcd_send;\nint mcd_setmode;\n\nint\nmcd_setmode(sc, mode)\n\tstruct mcd_softc *sc;\n\tint mode;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (sc->lastmode == mode)\n\t\treturn 0;\n\tif (sc->debug)\n\t\tprintf(\"%s: setting mode to %d\\n\", sc->sc_dev.dv_xname, mode);\n\tsc->lastmode = MCD_MD_UNKNOWN;\n\n\tmbx.cmd.opcode = MCD_CMDSETMODE;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.datamode);\n\tmbx.cmd.data.datamode.mode = mode;\n\tmbx.res.length = 0;\n\tif ((error = mcd_send(sc, &mbx, 1)) != 0)\n\t\treturn error;\n\n\tsc->lastmode = mode;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: playblocks: blkno %d length %d\\n\"",
            "sc->sc_dev.dv_xname",
            "p->blk",
            "p->len"
          ],
          "line": 1723
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void hsg2msf;\nint mcd_playblocks;\nint mcd_send;\nint mcd_setmode;\n\nint\nmcd_playblocks(sc, p)\n\tstruct mcd_softc *sc;\n\tstruct ioc_play_blocks *p;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (sc->debug)\n\t\tprintf(\"%s: playblocks: blkno %d length %d\\n\",\n\t\t    sc->sc_dev.dv_xname, p->blk, p->len);\n\n\tif (p->blk > sc->disksize || p->len > sc->disksize ||\n\t    (p->blk + p->len) > sc->disksize)\n\t\treturn 0;\n\n\tif ((error = mcd_setmode(sc, MCD_MD_COOKED)) != 0)\n\t\treturn error;\n\n\tmbx.cmd.opcode = MCD_CMDREADSINGLESPEED;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.play);\n\thsg2msf(p->blk, mbx.cmd.data.play.start_msf);\n\thsg2msf(p->blk + p->len, mbx.cmd.data.play.end_msf);\n\tsc->lastpb = mbx.cmd;\n\tmbx.res.length = 0;\n\treturn mcd_send(sc, &mbx, 1);\n}"
  },
  {
    "function_name": "mcd_playmsf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
    "lines": "1680-1712",
    "snippet": "int\nmcd_playmsf(sc, p)\n\tstruct mcd_softc *sc;\n\tstruct ioc_play_msf *p;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (sc->debug)\n\t\tprintf(\"%s: playmsf: from %d:%d.%d to %d:%d.%d\\n\",\n\t\t    sc->sc_dev.dv_xname,\n\t\t    p->start_m, p->start_s, p->start_f,\n\t\t    p->end_m, p->end_s, p->end_f);\n\n\tif ((p->start_m * 60 * 75 + p->start_s * 75 + p->start_f) >=\n\t    (p->end_m * 60 * 75 + p->end_s * 75 + p->end_f))\n\t\treturn EINVAL;\n\n\tif ((error = mcd_setmode(sc, MCD_MD_COOKED)) != 0)\n\t\treturn error;\n\n\tmbx.cmd.opcode = MCD_CMDREADSINGLESPEED;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.play);\n\tmbx.cmd.data.play.start_msf[0] = bin2bcd(p->start_m);\n\tmbx.cmd.data.play.start_msf[1] = bin2bcd(p->start_s);\n\tmbx.cmd.data.play.start_msf[2] = bin2bcd(p->start_f);\n\tmbx.cmd.data.play.end_msf[0] = bin2bcd(p->end_m);\n\tmbx.cmd.data.play.end_msf[1] = bin2bcd(p->end_s);\n\tmbx.cmd.data.play.end_msf[2] = bin2bcd(p->end_f);\n\tsc->lastpb = mbx.cmd;\n\tmbx.res.length = 0;\n\treturn mcd_send(sc, &mbx, 1);\n}",
    "includes": [
      "#include <lib/libkern/libkern.h>",
      "#include <dev/isa/opti.h>",
      "#include <dev/isa/mcdreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/errno.h>",
      "#include <sys/cdio.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/uio.h>",
      "#include <sys/stat.h>",
      "#include <sys/buf.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int mcd_playmsf",
      "int mcd_send",
      "int mcd_setmode"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mcd_send",
          "args": [
            "sc",
            "&mbx",
            "1"
          ],
          "line": 1711
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1044-1077",
          "snippet": "int\nmcd_send(sc, mbx, diskin)\n\tstruct mcd_softc *sc;\n\tstruct mcd_mbox *mbx;\n\tint diskin;\n{\n\tint retry, i, error;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\t\n\tif (sc->debug) {\n\t\tprintf(\"%s: mcd_send: %d %02x\", sc->sc_dev.dv_xname,\n\t\t    mbx->cmd.length, (u_int)mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tprintf(\" %02x\", (u_int)mbx->cmd.data.raw.data[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tfor (retry = MCD_RETRIES; retry; retry--) {\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.data.raw.data[i]);\n\t\tif ((error = mcd_getresult(sc, &mbx->res)) == 0)\n\t\t\tbreak;\n\t\tif (error == EINVAL)\n\t\t\treturn error;\n\t}\n\tif (!retry)\n\t\treturn error;\n\tif (diskin && (sc->flags & MCDF_LOADED) == 0)\n\t\treturn EIO;\n\n\treturn 0;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MCD_RETRIES\t3",
            "#define\tMCDF_LOADED\t0x10\t/* parameters loaded */"
          ],
          "globals_used": [
            "int mcd_getresult",
            "int mcd_send"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MCD_RETRIES\t3\n#define\tMCDF_LOADED\t0x10\t/* parameters loaded */\n\nint mcd_getresult;\nint mcd_send;\n\nint\nmcd_send(sc, mbx, diskin)\n\tstruct mcd_softc *sc;\n\tstruct mcd_mbox *mbx;\n\tint diskin;\n{\n\tint retry, i, error;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\t\n\tif (sc->debug) {\n\t\tprintf(\"%s: mcd_send: %d %02x\", sc->sc_dev.dv_xname,\n\t\t    mbx->cmd.length, (u_int)mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tprintf(\" %02x\", (u_int)mbx->cmd.data.raw.data[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tfor (retry = MCD_RETRIES; retry; retry--) {\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.data.raw.data[i]);\n\t\tif ((error = mcd_getresult(sc, &mbx->res)) == 0)\n\t\t\tbreak;\n\t\tif (error == EINVAL)\n\t\t\treturn error;\n\t}\n\tif (!retry)\n\t\treturn error;\n\tif (diskin && (sc->flags & MCDF_LOADED) == 0)\n\t\treturn EIO;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bin2bcd",
          "args": [
            "p->end_f"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bin2bcd",
          "args": [
            "p->end_s"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bin2bcd",
          "args": [
            "p->end_m"
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bin2bcd",
          "args": [
            "p->start_f"
          ],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bin2bcd",
          "args": [
            "p->start_s"
          ],
          "line": 1704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bin2bcd",
          "args": [
            "p->start_m"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mcd_setmode",
          "args": [
            "sc",
            "MCD_MD_COOKED"
          ],
          "line": 1698
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_setmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1312-1335",
          "snippet": "int\nmcd_setmode(sc, mode)\n\tstruct mcd_softc *sc;\n\tint mode;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (sc->lastmode == mode)\n\t\treturn 0;\n\tif (sc->debug)\n\t\tprintf(\"%s: setting mode to %d\\n\", sc->sc_dev.dv_xname, mode);\n\tsc->lastmode = MCD_MD_UNKNOWN;\n\n\tmbx.cmd.opcode = MCD_CMDSETMODE;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.datamode);\n\tmbx.cmd.data.datamode.mode = mode;\n\tmbx.res.length = 0;\n\tif ((error = mcd_send(sc, &mbx, 1)) != 0)\n\t\treturn error;\n\n\tsc->lastmode = mode;\n\treturn 0;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tMCD_MD_UNKNOWN\t-1"
          ],
          "globals_used": [
            "int mcd_send",
            "int mcd_setmode"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tMCD_MD_UNKNOWN\t-1\n\nint mcd_send;\nint mcd_setmode;\n\nint\nmcd_setmode(sc, mode)\n\tstruct mcd_softc *sc;\n\tint mode;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (sc->lastmode == mode)\n\t\treturn 0;\n\tif (sc->debug)\n\t\tprintf(\"%s: setting mode to %d\\n\", sc->sc_dev.dv_xname, mode);\n\tsc->lastmode = MCD_MD_UNKNOWN;\n\n\tmbx.cmd.opcode = MCD_CMDSETMODE;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.datamode);\n\tmbx.cmd.data.datamode.mode = mode;\n\tmbx.res.length = 0;\n\tif ((error = mcd_send(sc, &mbx, 1)) != 0)\n\t\treturn error;\n\n\tsc->lastmode = mode;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: playmsf: from %d:%d.%d to %d:%d.%d\\n\"",
            "sc->sc_dev.dv_xname",
            "p->start_m",
            "p->start_s",
            "p->start_f",
            "p->end_m",
            "p->end_s",
            "p->end_f"
          ],
          "line": 1689
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint mcd_playmsf;\nint mcd_send;\nint mcd_setmode;\n\nint\nmcd_playmsf(sc, p)\n\tstruct mcd_softc *sc;\n\tstruct ioc_play_msf *p;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (sc->debug)\n\t\tprintf(\"%s: playmsf: from %d:%d.%d to %d:%d.%d\\n\",\n\t\t    sc->sc_dev.dv_xname,\n\t\t    p->start_m, p->start_s, p->start_f,\n\t\t    p->end_m, p->end_s, p->end_f);\n\n\tif ((p->start_m * 60 * 75 + p->start_s * 75 + p->start_f) >=\n\t    (p->end_m * 60 * 75 + p->end_s * 75 + p->end_f))\n\t\treturn EINVAL;\n\n\tif ((error = mcd_setmode(sc, MCD_MD_COOKED)) != 0)\n\t\treturn error;\n\n\tmbx.cmd.opcode = MCD_CMDREADSINGLESPEED;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.play);\n\tmbx.cmd.data.play.start_msf[0] = bin2bcd(p->start_m);\n\tmbx.cmd.data.play.start_msf[1] = bin2bcd(p->start_s);\n\tmbx.cmd.data.play.start_msf[2] = bin2bcd(p->start_f);\n\tmbx.cmd.data.play.end_msf[0] = bin2bcd(p->end_m);\n\tmbx.cmd.data.play.end_msf[1] = bin2bcd(p->end_s);\n\tmbx.cmd.data.play.end_msf[2] = bin2bcd(p->end_f);\n\tsc->lastpb = mbx.cmd;\n\tmbx.res.length = 0;\n\treturn mcd_send(sc, &mbx, 1);\n}"
  },
  {
    "function_name": "mcd_playtracks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
    "lines": "1642-1678",
    "snippet": "int\nmcd_playtracks(sc, p)\n\tstruct mcd_softc *sc;\n\tstruct ioc_play_track *p;\n{\n\tstruct mcd_mbox mbx;\n\tint a = p->start_track;\n\tint z = p->end_track;\n\tint error;\n\n\tif (sc->debug)\n\t\tprintf(\"%s: playtracks: from %d:%d to %d:%d\\n\",\n\t\t    sc->sc_dev.dv_xname,\n\t\t    a, p->start_index, z, p->end_index);\n\n\tif (a < bcd2bin(sc->volinfo.trk_low) ||\n\t    a > bcd2bin(sc->volinfo.trk_high) ||\n\t    a > z ||\n\t    z < bcd2bin(sc->volinfo.trk_low) ||\n\t    z > bcd2bin(sc->volinfo.trk_high))\n\t\treturn EINVAL;\n\n\tif ((error = mcd_setmode(sc, MCD_MD_COOKED)) != 0)\n\t\treturn error;\n\n\tmbx.cmd.opcode = MCD_CMDREADSINGLESPEED;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.play);\n\tmbx.cmd.data.play.start_msf[0] = sc->toc[a].toc.absolute_pos[0];\n\tmbx.cmd.data.play.start_msf[1] = sc->toc[a].toc.absolute_pos[1];\n\tmbx.cmd.data.play.start_msf[2] = sc->toc[a].toc.absolute_pos[2];\n\tmbx.cmd.data.play.end_msf[0] = sc->toc[z+1].toc.absolute_pos[0];\n\tmbx.cmd.data.play.end_msf[1] = sc->toc[z+1].toc.absolute_pos[1];\n\tmbx.cmd.data.play.end_msf[2] = sc->toc[z+1].toc.absolute_pos[2];\n\tsc->lastpb = mbx.cmd;\n\tmbx.res.length = 0;\n\treturn mcd_send(sc, &mbx, 1);\n}",
    "includes": [
      "#include <lib/libkern/libkern.h>",
      "#include <dev/isa/opti.h>",
      "#include <dev/isa/mcdreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/errno.h>",
      "#include <sys/cdio.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/uio.h>",
      "#include <sys/stat.h>",
      "#include <sys/buf.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int mcd_playtracks",
      "int mcd_send",
      "int mcd_setmode"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mcd_send",
          "args": [
            "sc",
            "&mbx",
            "1"
          ],
          "line": 1677
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1044-1077",
          "snippet": "int\nmcd_send(sc, mbx, diskin)\n\tstruct mcd_softc *sc;\n\tstruct mcd_mbox *mbx;\n\tint diskin;\n{\n\tint retry, i, error;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\t\n\tif (sc->debug) {\n\t\tprintf(\"%s: mcd_send: %d %02x\", sc->sc_dev.dv_xname,\n\t\t    mbx->cmd.length, (u_int)mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tprintf(\" %02x\", (u_int)mbx->cmd.data.raw.data[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tfor (retry = MCD_RETRIES; retry; retry--) {\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.data.raw.data[i]);\n\t\tif ((error = mcd_getresult(sc, &mbx->res)) == 0)\n\t\t\tbreak;\n\t\tif (error == EINVAL)\n\t\t\treturn error;\n\t}\n\tif (!retry)\n\t\treturn error;\n\tif (diskin && (sc->flags & MCDF_LOADED) == 0)\n\t\treturn EIO;\n\n\treturn 0;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MCD_RETRIES\t3",
            "#define\tMCDF_LOADED\t0x10\t/* parameters loaded */"
          ],
          "globals_used": [
            "int mcd_getresult",
            "int mcd_send"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MCD_RETRIES\t3\n#define\tMCDF_LOADED\t0x10\t/* parameters loaded */\n\nint mcd_getresult;\nint mcd_send;\n\nint\nmcd_send(sc, mbx, diskin)\n\tstruct mcd_softc *sc;\n\tstruct mcd_mbox *mbx;\n\tint diskin;\n{\n\tint retry, i, error;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\t\n\tif (sc->debug) {\n\t\tprintf(\"%s: mcd_send: %d %02x\", sc->sc_dev.dv_xname,\n\t\t    mbx->cmd.length, (u_int)mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tprintf(\" %02x\", (u_int)mbx->cmd.data.raw.data[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tfor (retry = MCD_RETRIES; retry; retry--) {\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.data.raw.data[i]);\n\t\tif ((error = mcd_getresult(sc, &mbx->res)) == 0)\n\t\t\tbreak;\n\t\tif (error == EINVAL)\n\t\t\treturn error;\n\t}\n\tif (!retry)\n\t\treturn error;\n\tif (diskin && (sc->flags & MCDF_LOADED) == 0)\n\t\treturn EIO;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mcd_setmode",
          "args": [
            "sc",
            "MCD_MD_COOKED"
          ],
          "line": 1664
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_setmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1312-1335",
          "snippet": "int\nmcd_setmode(sc, mode)\n\tstruct mcd_softc *sc;\n\tint mode;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (sc->lastmode == mode)\n\t\treturn 0;\n\tif (sc->debug)\n\t\tprintf(\"%s: setting mode to %d\\n\", sc->sc_dev.dv_xname, mode);\n\tsc->lastmode = MCD_MD_UNKNOWN;\n\n\tmbx.cmd.opcode = MCD_CMDSETMODE;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.datamode);\n\tmbx.cmd.data.datamode.mode = mode;\n\tmbx.res.length = 0;\n\tif ((error = mcd_send(sc, &mbx, 1)) != 0)\n\t\treturn error;\n\n\tsc->lastmode = mode;\n\treturn 0;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tMCD_MD_UNKNOWN\t-1"
          ],
          "globals_used": [
            "int mcd_send",
            "int mcd_setmode"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tMCD_MD_UNKNOWN\t-1\n\nint mcd_send;\nint mcd_setmode;\n\nint\nmcd_setmode(sc, mode)\n\tstruct mcd_softc *sc;\n\tint mode;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (sc->lastmode == mode)\n\t\treturn 0;\n\tif (sc->debug)\n\t\tprintf(\"%s: setting mode to %d\\n\", sc->sc_dev.dv_xname, mode);\n\tsc->lastmode = MCD_MD_UNKNOWN;\n\n\tmbx.cmd.opcode = MCD_CMDSETMODE;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.datamode);\n\tmbx.cmd.data.datamode.mode = mode;\n\tmbx.res.length = 0;\n\tif ((error = mcd_send(sc, &mbx, 1)) != 0)\n\t\treturn error;\n\n\tsc->lastmode = mode;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcd2bin",
          "args": [
            "sc->volinfo.trk_high"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcd2bin",
          "args": [
            "sc->volinfo.trk_low"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcd2bin",
          "args": [
            "sc->volinfo.trk_high"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcd2bin",
          "args": [
            "sc->volinfo.trk_low"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: playtracks: from %d:%d to %d:%d\\n\"",
            "sc->sc_dev.dv_xname",
            "a",
            "p->start_index",
            "z",
            "p->end_index"
          ],
          "line": 1653
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint mcd_playtracks;\nint mcd_send;\nint mcd_setmode;\n\nint\nmcd_playtracks(sc, p)\n\tstruct mcd_softc *sc;\n\tstruct ioc_play_track *p;\n{\n\tstruct mcd_mbox mbx;\n\tint a = p->start_track;\n\tint z = p->end_track;\n\tint error;\n\n\tif (sc->debug)\n\t\tprintf(\"%s: playtracks: from %d:%d to %d:%d\\n\",\n\t\t    sc->sc_dev.dv_xname,\n\t\t    a, p->start_index, z, p->end_index);\n\n\tif (a < bcd2bin(sc->volinfo.trk_low) ||\n\t    a > bcd2bin(sc->volinfo.trk_high) ||\n\t    a > z ||\n\t    z < bcd2bin(sc->volinfo.trk_low) ||\n\t    z > bcd2bin(sc->volinfo.trk_high))\n\t\treturn EINVAL;\n\n\tif ((error = mcd_setmode(sc, MCD_MD_COOKED)) != 0)\n\t\treturn error;\n\n\tmbx.cmd.opcode = MCD_CMDREADSINGLESPEED;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.play);\n\tmbx.cmd.data.play.start_msf[0] = sc->toc[a].toc.absolute_pos[0];\n\tmbx.cmd.data.play.start_msf[1] = sc->toc[a].toc.absolute_pos[1];\n\tmbx.cmd.data.play.start_msf[2] = sc->toc[a].toc.absolute_pos[2];\n\tmbx.cmd.data.play.end_msf[0] = sc->toc[z+1].toc.absolute_pos[0];\n\tmbx.cmd.data.play.end_msf[1] = sc->toc[z+1].toc.absolute_pos[1];\n\tmbx.cmd.data.play.end_msf[2] = sc->toc[z+1].toc.absolute_pos[2];\n\tsc->lastpb = mbx.cmd;\n\tmbx.res.length = 0;\n\treturn mcd_send(sc, &mbx, 1);\n}"
  },
  {
    "function_name": "mcd_read_subchannel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
    "lines": "1557-1640",
    "snippet": "int\nmcd_read_subchannel(sc, ch)\n\tstruct mcd_softc *sc;\n\tstruct ioc_read_subchannel *ch;\n{\n\tint len = ch->data_len;\n\tunion mcd_qchninfo q;\n\tstruct cd_sub_channel_info data;\n\tdaddr_t lba;\n\tint error;\n\n\tif (sc->debug)\n\t\tprintf(\"%s: subchan: af=%d df=%d\\n\", sc->sc_dev.dv_xname,\n\t\t    ch->address_format, ch->data_format);\n\n\tif (len > sizeof(data) ||\n\t    len < sizeof(struct cd_sub_channel_header))\n\t\treturn EINVAL;\n\tif (ch->address_format != CD_MSF_FORMAT &&\n\t    ch->address_format != CD_LBA_FORMAT)\n\t\treturn EINVAL;\n\tif (ch->data_format != CD_CURRENT_POSITION &&\n\t    ch->data_format != CD_MEDIA_CATALOG)\n\t\treturn EINVAL;\n\n\tif ((error = mcd_getqchan(sc, &q, ch->data_format)) != 0)\n\t\treturn error;\n\n\tdata.header.audio_status = sc->audio_status;\n\tdata.what.media_catalog.data_format = ch->data_format;\n\n\tswitch (ch->data_format) {\n\tcase CD_MEDIA_CATALOG:\n\t\tdata.what.media_catalog.mc_valid = 1;\n#if 0\n\t\tdata.what.media_catalog.mc_number = \n#endif\n\t\tbreak;\n\n\tcase CD_CURRENT_POSITION:\n\t\tdata.what.position.track_number = bcd2bin(q.current.trk_no);\n\t\tdata.what.position.index_number = bcd2bin(q.current.idx_no);\n\t\tswitch (ch->address_format) {\n\t\tcase CD_MSF_FORMAT:\n\t\t\tdata.what.position.reladdr.addr[0] = 0;\n\t\t\tdata.what.position.reladdr.addr[1] =\n\t\t\t    bcd2bin(q.current.relative_pos[0]);\n\t\t\tdata.what.position.reladdr.addr[2] =\n\t\t\t    bcd2bin(q.current.relative_pos[1]);\n\t\t\tdata.what.position.reladdr.addr[3] =\n\t\t\t    bcd2bin(q.current.relative_pos[2]);\n\t\t\tdata.what.position.absaddr.addr[0] = 0;\n\t\t\tdata.what.position.absaddr.addr[1] =\n\t\t\t    bcd2bin(q.current.absolute_pos[0]);\n\t\t\tdata.what.position.absaddr.addr[2] =\n\t\t\t    bcd2bin(q.current.absolute_pos[1]);\n\t\t\tdata.what.position.absaddr.addr[3] =\n\t\t\t    bcd2bin(q.current.absolute_pos[2]);\n\t\t\tbreak;\n\t\tcase CD_LBA_FORMAT:\n\t\t\tlba = msf2hsg(q.current.relative_pos, 1);\n\t\t\t/*\n\t\t\t * Pre-gap has index number of 0, and decreasing MSF\n\t\t\t * address.  Must be converted to negative LBA, per\n\t\t\t * SCSI spec.\n\t\t\t */\n\t\t\tif (data.what.position.index_number == 0x00)\n\t\t\t\tlba = -lba;\n\t\t\tdata.what.position.reladdr.addr[0] = lba >> 24;\n\t\t\tdata.what.position.reladdr.addr[1] = lba >> 16;\n\t\t\tdata.what.position.reladdr.addr[2] = lba >> 8;\n\t\t\tdata.what.position.reladdr.addr[3] = lba;\n\t\t\tlba = msf2hsg(q.current.absolute_pos, 0);\n\t\t\tdata.what.position.absaddr.addr[0] = lba >> 24;\n\t\t\tdata.what.position.absaddr.addr[1] = lba >> 16;\n\t\t\tdata.what.position.absaddr.addr[2] = lba >> 8;\n\t\t\tdata.what.position.absaddr.addr[3] = lba;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn copyout(&data, ch->data, len);\n}",
    "includes": [
      "#include <lib/libkern/libkern.h>",
      "#include <dev/isa/opti.h>",
      "#include <dev/isa/mcdreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/errno.h>",
      "#include <sys/cdio.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/uio.h>",
      "#include <sys/stat.h>",
      "#include <sys/buf.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static daddr_t msf2hsg",
      "int mcd_read_subchannel",
      "int mcd_getqchan"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copyout",
          "args": [
            "&data",
            "ch->data",
            "len"
          ],
          "line": 1639
        },
        "resolved": true,
        "details": {
          "function_name": "audio_silence_copyout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "1249-1268",
          "snippet": "int\naudio_silence_copyout(sc, n, uio)\n\tstruct audio_softc *sc;\n\tint n;\n\tstruct uio *uio;\n{\n\tint error;\n\tint k;\n\tu_char zerobuf[128];\n\n\taudio_fill_silence(&sc->sc_rparams, zerobuf, sizeof zerobuf);\n\n\terror = 0;\n        while (n > 0 && uio->uio_resid > 0 && !error) {\n\t\tk = min(n, min(uio->uio_resid, sizeof zerobuf));\n\t\terror = uiomove(zerobuf, k, uio);\n\t\tn -= k;\n\t}\n        return (error);\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudio_silence_copyout(sc, n, uio)\n\tstruct audio_softc *sc;\n\tint n;\n\tstruct uio *uio;\n{\n\tint error;\n\tint k;\n\tu_char zerobuf[128];\n\n\taudio_fill_silence(&sc->sc_rparams, zerobuf, sizeof zerobuf);\n\n\terror = 0;\n        while (n > 0 && uio->uio_resid > 0 && !error) {\n\t\tk = min(n, min(uio->uio_resid, sizeof zerobuf));\n\t\terror = uiomove(zerobuf, k, uio);\n\t\tn -= k;\n\t}\n        return (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msf2hsg",
          "args": [
            "q.current.absolute_pos",
            "0"
          ],
          "line": 1629
        },
        "resolved": true,
        "details": {
          "function_name": "msf2hsg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1093-1106",
          "snippet": "static daddr_t\nmsf2hsg(msf, relative)\n\tbcd_t *msf;\n\tint relative;\n{\n\tdaddr_t blkno;\n\n\tblkno = bcd2bin(M_msf(msf)) * 75 * 60 +\n\t\tbcd2bin(S_msf(msf)) * 75 +\n\t\tbcd2bin(F_msf(msf));\n\tif (!relative)\n\t\tblkno -= 150;\n\treturn blkno;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__P((int, bcd_t *));",
            "static daddr_t msf2hsg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n__P((int, bcd_t *));\nstatic daddr_t msf2hsg;\n\nstatic daddr_t\nmsf2hsg(msf, relative)\n\tbcd_t *msf;\n\tint relative;\n{\n\tdaddr_t blkno;\n\n\tblkno = bcd2bin(M_msf(msf)) * 75 * 60 +\n\t\tbcd2bin(S_msf(msf)) * 75 +\n\t\tbcd2bin(F_msf(msf));\n\tif (!relative)\n\t\tblkno -= 150;\n\treturn blkno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcd2bin",
          "args": [
            "q.current.absolute_pos[2]"
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcd2bin",
          "args": [
            "q.current.absolute_pos[1]"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcd2bin",
          "args": [
            "q.current.absolute_pos[0]"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcd2bin",
          "args": [
            "q.current.relative_pos[2]"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcd2bin",
          "args": [
            "q.current.relative_pos[1]"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcd2bin",
          "args": [
            "q.current.relative_pos[0]"
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcd2bin",
          "args": [
            "q.current.idx_no"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcd2bin",
          "args": [
            "q.current.trk_no"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mcd_getqchan",
          "args": [
            "sc",
            "&q",
            "ch->data_format"
          ],
          "line": 1582
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_getqchan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1523-1555",
          "snippet": "int\nmcd_getqchan(sc, q, qchn)\n\tstruct mcd_softc *sc;\n\tunion mcd_qchninfo *q;\n\tint qchn;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (qchn == CD_TRACK_INFO) {\n\t\tif ((error = mcd_setmode(sc, MCD_MD_TOC)) != 0)\n\t\t\treturn error;\n\t} else {\n\t\tif ((error = mcd_setmode(sc, MCD_MD_COOKED)) != 0)\n\t\t\treturn error;\n\t}\n\tif (qchn == CD_MEDIA_CATALOG) {\n\t\tif ((error = mcd_setupc(sc, MCD_UPC_ENABLE)) != 0)\n\t\t\treturn error;\n\t} else {\n\t\tif ((error = mcd_setupc(sc, MCD_UPC_DISABLE)) != 0)\n\t\t\treturn error;\n\t}\n\n\tmbx.cmd.opcode = MCD_CMDGETQCHN;\n\tmbx.cmd.length = 0;\n\tmbx.res.length = sizeof(mbx.res.data.qchninfo);\n\tif ((error = mcd_send(sc, &mbx, 1)) != 0)\n\t\treturn error;\n\n\t*q = mbx.res.data.qchninfo;\n\treturn 0;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int mcd_send",
            "int mcd_setmode",
            "int mcd_setupc",
            "int mcd_getqchan"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint mcd_send;\nint mcd_setmode;\nint mcd_setupc;\nint mcd_getqchan;\n\nint\nmcd_getqchan(sc, q, qchn)\n\tstruct mcd_softc *sc;\n\tunion mcd_qchninfo *q;\n\tint qchn;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (qchn == CD_TRACK_INFO) {\n\t\tif ((error = mcd_setmode(sc, MCD_MD_TOC)) != 0)\n\t\t\treturn error;\n\t} else {\n\t\tif ((error = mcd_setmode(sc, MCD_MD_COOKED)) != 0)\n\t\t\treturn error;\n\t}\n\tif (qchn == CD_MEDIA_CATALOG) {\n\t\tif ((error = mcd_setupc(sc, MCD_UPC_ENABLE)) != 0)\n\t\t\treturn error;\n\t} else {\n\t\tif ((error = mcd_setupc(sc, MCD_UPC_DISABLE)) != 0)\n\t\t\treturn error;\n\t}\n\n\tmbx.cmd.opcode = MCD_CMDGETQCHN;\n\tmbx.cmd.length = 0;\n\tmbx.res.length = sizeof(mbx.res.data.qchninfo);\n\tif ((error = mcd_send(sc, &mbx, 1)) != 0)\n\t\treturn error;\n\n\t*q = mbx.res.data.qchninfo;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: subchan: af=%d df=%d\\n\"",
            "sc->sc_dev.dv_xname",
            "ch->address_format",
            "ch->data_format"
          ],
          "line": 1569
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic daddr_t msf2hsg;\nint mcd_read_subchannel;\nint mcd_getqchan;\n\nint\nmcd_read_subchannel(sc, ch)\n\tstruct mcd_softc *sc;\n\tstruct ioc_read_subchannel *ch;\n{\n\tint len = ch->data_len;\n\tunion mcd_qchninfo q;\n\tstruct cd_sub_channel_info data;\n\tdaddr_t lba;\n\tint error;\n\n\tif (sc->debug)\n\t\tprintf(\"%s: subchan: af=%d df=%d\\n\", sc->sc_dev.dv_xname,\n\t\t    ch->address_format, ch->data_format);\n\n\tif (len > sizeof(data) ||\n\t    len < sizeof(struct cd_sub_channel_header))\n\t\treturn EINVAL;\n\tif (ch->address_format != CD_MSF_FORMAT &&\n\t    ch->address_format != CD_LBA_FORMAT)\n\t\treturn EINVAL;\n\tif (ch->data_format != CD_CURRENT_POSITION &&\n\t    ch->data_format != CD_MEDIA_CATALOG)\n\t\treturn EINVAL;\n\n\tif ((error = mcd_getqchan(sc, &q, ch->data_format)) != 0)\n\t\treturn error;\n\n\tdata.header.audio_status = sc->audio_status;\n\tdata.what.media_catalog.data_format = ch->data_format;\n\n\tswitch (ch->data_format) {\n\tcase CD_MEDIA_CATALOG:\n\t\tdata.what.media_catalog.mc_valid = 1;\n#if 0\n\t\tdata.what.media_catalog.mc_number = \n#endif\n\t\tbreak;\n\n\tcase CD_CURRENT_POSITION:\n\t\tdata.what.position.track_number = bcd2bin(q.current.trk_no);\n\t\tdata.what.position.index_number = bcd2bin(q.current.idx_no);\n\t\tswitch (ch->address_format) {\n\t\tcase CD_MSF_FORMAT:\n\t\t\tdata.what.position.reladdr.addr[0] = 0;\n\t\t\tdata.what.position.reladdr.addr[1] =\n\t\t\t    bcd2bin(q.current.relative_pos[0]);\n\t\t\tdata.what.position.reladdr.addr[2] =\n\t\t\t    bcd2bin(q.current.relative_pos[1]);\n\t\t\tdata.what.position.reladdr.addr[3] =\n\t\t\t    bcd2bin(q.current.relative_pos[2]);\n\t\t\tdata.what.position.absaddr.addr[0] = 0;\n\t\t\tdata.what.position.absaddr.addr[1] =\n\t\t\t    bcd2bin(q.current.absolute_pos[0]);\n\t\t\tdata.what.position.absaddr.addr[2] =\n\t\t\t    bcd2bin(q.current.absolute_pos[1]);\n\t\t\tdata.what.position.absaddr.addr[3] =\n\t\t\t    bcd2bin(q.current.absolute_pos[2]);\n\t\t\tbreak;\n\t\tcase CD_LBA_FORMAT:\n\t\t\tlba = msf2hsg(q.current.relative_pos, 1);\n\t\t\t/*\n\t\t\t * Pre-gap has index number of 0, and decreasing MSF\n\t\t\t * address.  Must be converted to negative LBA, per\n\t\t\t * SCSI spec.\n\t\t\t */\n\t\t\tif (data.what.position.index_number == 0x00)\n\t\t\t\tlba = -lba;\n\t\t\tdata.what.position.reladdr.addr[0] = lba >> 24;\n\t\t\tdata.what.position.reladdr.addr[1] = lba >> 16;\n\t\t\tdata.what.position.reladdr.addr[2] = lba >> 8;\n\t\t\tdata.what.position.reladdr.addr[3] = lba;\n\t\t\tlba = msf2hsg(q.current.absolute_pos, 0);\n\t\t\tdata.what.position.absaddr.addr[0] = lba >> 24;\n\t\t\tdata.what.position.absaddr.addr[1] = lba >> 16;\n\t\t\tdata.what.position.absaddr.addr[2] = lba >> 8;\n\t\t\tdata.what.position.absaddr.addr[3] = lba;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn copyout(&data, ch->data, len);\n}"
  },
  {
    "function_name": "mcd_getqchan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
    "lines": "1523-1555",
    "snippet": "int\nmcd_getqchan(sc, q, qchn)\n\tstruct mcd_softc *sc;\n\tunion mcd_qchninfo *q;\n\tint qchn;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (qchn == CD_TRACK_INFO) {\n\t\tif ((error = mcd_setmode(sc, MCD_MD_TOC)) != 0)\n\t\t\treturn error;\n\t} else {\n\t\tif ((error = mcd_setmode(sc, MCD_MD_COOKED)) != 0)\n\t\t\treturn error;\n\t}\n\tif (qchn == CD_MEDIA_CATALOG) {\n\t\tif ((error = mcd_setupc(sc, MCD_UPC_ENABLE)) != 0)\n\t\t\treturn error;\n\t} else {\n\t\tif ((error = mcd_setupc(sc, MCD_UPC_DISABLE)) != 0)\n\t\t\treturn error;\n\t}\n\n\tmbx.cmd.opcode = MCD_CMDGETQCHN;\n\tmbx.cmd.length = 0;\n\tmbx.res.length = sizeof(mbx.res.data.qchninfo);\n\tif ((error = mcd_send(sc, &mbx, 1)) != 0)\n\t\treturn error;\n\n\t*q = mbx.res.data.qchninfo;\n\treturn 0;\n}",
    "includes": [
      "#include <lib/libkern/libkern.h>",
      "#include <dev/isa/opti.h>",
      "#include <dev/isa/mcdreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/errno.h>",
      "#include <sys/cdio.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/uio.h>",
      "#include <sys/stat.h>",
      "#include <sys/buf.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int mcd_send",
      "int mcd_setmode",
      "int mcd_setupc",
      "int mcd_getqchan"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mcd_send",
          "args": [
            "sc",
            "&mbx",
            "1"
          ],
          "line": 1550
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1044-1077",
          "snippet": "int\nmcd_send(sc, mbx, diskin)\n\tstruct mcd_softc *sc;\n\tstruct mcd_mbox *mbx;\n\tint diskin;\n{\n\tint retry, i, error;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\t\n\tif (sc->debug) {\n\t\tprintf(\"%s: mcd_send: %d %02x\", sc->sc_dev.dv_xname,\n\t\t    mbx->cmd.length, (u_int)mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tprintf(\" %02x\", (u_int)mbx->cmd.data.raw.data[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tfor (retry = MCD_RETRIES; retry; retry--) {\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.data.raw.data[i]);\n\t\tif ((error = mcd_getresult(sc, &mbx->res)) == 0)\n\t\t\tbreak;\n\t\tif (error == EINVAL)\n\t\t\treturn error;\n\t}\n\tif (!retry)\n\t\treturn error;\n\tif (diskin && (sc->flags & MCDF_LOADED) == 0)\n\t\treturn EIO;\n\n\treturn 0;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MCD_RETRIES\t3",
            "#define\tMCDF_LOADED\t0x10\t/* parameters loaded */"
          ],
          "globals_used": [
            "int mcd_getresult",
            "int mcd_send"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MCD_RETRIES\t3\n#define\tMCDF_LOADED\t0x10\t/* parameters loaded */\n\nint mcd_getresult;\nint mcd_send;\n\nint\nmcd_send(sc, mbx, diskin)\n\tstruct mcd_softc *sc;\n\tstruct mcd_mbox *mbx;\n\tint diskin;\n{\n\tint retry, i, error;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\t\n\tif (sc->debug) {\n\t\tprintf(\"%s: mcd_send: %d %02x\", sc->sc_dev.dv_xname,\n\t\t    mbx->cmd.length, (u_int)mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tprintf(\" %02x\", (u_int)mbx->cmd.data.raw.data[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tfor (retry = MCD_RETRIES; retry; retry--) {\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.data.raw.data[i]);\n\t\tif ((error = mcd_getresult(sc, &mbx->res)) == 0)\n\t\t\tbreak;\n\t\tif (error == EINVAL)\n\t\t\treturn error;\n\t}\n\tif (!retry)\n\t\treturn error;\n\tif (diskin && (sc->flags & MCDF_LOADED) == 0)\n\t\treturn EIO;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mcd_setupc",
          "args": [
            "sc",
            "MCD_UPC_DISABLE"
          ],
          "line": 1543
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_setupc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1337-1361",
          "snippet": "int\nmcd_setupc(sc, upc)\n\tstruct mcd_softc *sc;\n\tint upc;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (sc->lastupc == upc)\n\t\treturn 0;\n\tif (sc->debug)\n\t\tprintf(\"%s: setting upc to %d\\n\", sc->sc_dev.dv_xname, upc);\n\tsc->lastupc = MCD_UPC_UNKNOWN;\n\n\tmbx.cmd.opcode = MCD_CMDCONFIGDRIVE;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.config) - 1;\n\tmbx.cmd.data.config.subcommand = MCD_CF_READUPC;\n\tmbx.cmd.data.config.data1 = upc;\n\tmbx.res.length = 0;\n\tif ((error = mcd_send(sc, &mbx, 1)) != 0)\n\t\treturn error;\n\n\tsc->lastupc = upc;\n\treturn 0;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tMCD_UPC_UNKNOWN\t-1"
          ],
          "globals_used": [
            "int mcd_send",
            "int mcd_setupc"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tMCD_UPC_UNKNOWN\t-1\n\nint mcd_send;\nint mcd_setupc;\n\nint\nmcd_setupc(sc, upc)\n\tstruct mcd_softc *sc;\n\tint upc;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (sc->lastupc == upc)\n\t\treturn 0;\n\tif (sc->debug)\n\t\tprintf(\"%s: setting upc to %d\\n\", sc->sc_dev.dv_xname, upc);\n\tsc->lastupc = MCD_UPC_UNKNOWN;\n\n\tmbx.cmd.opcode = MCD_CMDCONFIGDRIVE;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.config) - 1;\n\tmbx.cmd.data.config.subcommand = MCD_CF_READUPC;\n\tmbx.cmd.data.config.data1 = upc;\n\tmbx.res.length = 0;\n\tif ((error = mcd_send(sc, &mbx, 1)) != 0)\n\t\treturn error;\n\n\tsc->lastupc = upc;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mcd_setmode",
          "args": [
            "sc",
            "MCD_MD_COOKED"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_setmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1312-1335",
          "snippet": "int\nmcd_setmode(sc, mode)\n\tstruct mcd_softc *sc;\n\tint mode;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (sc->lastmode == mode)\n\t\treturn 0;\n\tif (sc->debug)\n\t\tprintf(\"%s: setting mode to %d\\n\", sc->sc_dev.dv_xname, mode);\n\tsc->lastmode = MCD_MD_UNKNOWN;\n\n\tmbx.cmd.opcode = MCD_CMDSETMODE;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.datamode);\n\tmbx.cmd.data.datamode.mode = mode;\n\tmbx.res.length = 0;\n\tif ((error = mcd_send(sc, &mbx, 1)) != 0)\n\t\treturn error;\n\n\tsc->lastmode = mode;\n\treturn 0;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tMCD_MD_UNKNOWN\t-1"
          ],
          "globals_used": [
            "int mcd_send",
            "int mcd_setmode"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tMCD_MD_UNKNOWN\t-1\n\nint mcd_send;\nint mcd_setmode;\n\nint\nmcd_setmode(sc, mode)\n\tstruct mcd_softc *sc;\n\tint mode;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (sc->lastmode == mode)\n\t\treturn 0;\n\tif (sc->debug)\n\t\tprintf(\"%s: setting mode to %d\\n\", sc->sc_dev.dv_xname, mode);\n\tsc->lastmode = MCD_MD_UNKNOWN;\n\n\tmbx.cmd.opcode = MCD_CMDSETMODE;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.datamode);\n\tmbx.cmd.data.datamode.mode = mode;\n\tmbx.res.length = 0;\n\tif ((error = mcd_send(sc, &mbx, 1)) != 0)\n\t\treturn error;\n\n\tsc->lastmode = mode;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint mcd_send;\nint mcd_setmode;\nint mcd_setupc;\nint mcd_getqchan;\n\nint\nmcd_getqchan(sc, q, qchn)\n\tstruct mcd_softc *sc;\n\tunion mcd_qchninfo *q;\n\tint qchn;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (qchn == CD_TRACK_INFO) {\n\t\tif ((error = mcd_setmode(sc, MCD_MD_TOC)) != 0)\n\t\t\treturn error;\n\t} else {\n\t\tif ((error = mcd_setmode(sc, MCD_MD_COOKED)) != 0)\n\t\t\treturn error;\n\t}\n\tif (qchn == CD_MEDIA_CATALOG) {\n\t\tif ((error = mcd_setupc(sc, MCD_UPC_ENABLE)) != 0)\n\t\t\treturn error;\n\t} else {\n\t\tif ((error = mcd_setupc(sc, MCD_UPC_DISABLE)) != 0)\n\t\t\treturn error;\n\t}\n\n\tmbx.cmd.opcode = MCD_CMDGETQCHN;\n\tmbx.cmd.length = 0;\n\tmbx.res.length = sizeof(mbx.res.data.qchninfo);\n\tif ((error = mcd_send(sc, &mbx, 1)) != 0)\n\t\treturn error;\n\n\t*q = mbx.res.data.qchninfo;\n\treturn 0;\n}"
  },
  {
    "function_name": "mcd_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
    "lines": "1503-1521",
    "snippet": "int\nmcd_stop(sc)\n\tstruct mcd_softc *sc;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (sc->debug)\n\t\tprintf(\"%s: mcd_stop: stopping play\\n\", sc->sc_dev.dv_xname);\n\n\tmbx.cmd.opcode = MCD_CMDSTOPAUDIO;\n\tmbx.cmd.length = 0;\n\tmbx.res.length = 0;\n\tif ((error = mcd_send(sc, &mbx, 1)) != 0)\n\t\treturn error;\n\n\tsc->audio_status = CD_AS_PLAY_COMPLETED;\n\treturn 0;\n}",
    "includes": [
      "#include <lib/libkern/libkern.h>",
      "#include <dev/isa/opti.h>",
      "#include <dev/isa/mcdreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/errno.h>",
      "#include <sys/cdio.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/uio.h>",
      "#include <sys/stat.h>",
      "#include <sys/buf.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int mcd_stop",
      "int mcd_send"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mcd_send",
          "args": [
            "sc",
            "&mbx",
            "1"
          ],
          "line": 1516
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1044-1077",
          "snippet": "int\nmcd_send(sc, mbx, diskin)\n\tstruct mcd_softc *sc;\n\tstruct mcd_mbox *mbx;\n\tint diskin;\n{\n\tint retry, i, error;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\t\n\tif (sc->debug) {\n\t\tprintf(\"%s: mcd_send: %d %02x\", sc->sc_dev.dv_xname,\n\t\t    mbx->cmd.length, (u_int)mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tprintf(\" %02x\", (u_int)mbx->cmd.data.raw.data[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tfor (retry = MCD_RETRIES; retry; retry--) {\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.data.raw.data[i]);\n\t\tif ((error = mcd_getresult(sc, &mbx->res)) == 0)\n\t\t\tbreak;\n\t\tif (error == EINVAL)\n\t\t\treturn error;\n\t}\n\tif (!retry)\n\t\treturn error;\n\tif (diskin && (sc->flags & MCDF_LOADED) == 0)\n\t\treturn EIO;\n\n\treturn 0;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MCD_RETRIES\t3",
            "#define\tMCDF_LOADED\t0x10\t/* parameters loaded */"
          ],
          "globals_used": [
            "int mcd_getresult",
            "int mcd_send"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MCD_RETRIES\t3\n#define\tMCDF_LOADED\t0x10\t/* parameters loaded */\n\nint mcd_getresult;\nint mcd_send;\n\nint\nmcd_send(sc, mbx, diskin)\n\tstruct mcd_softc *sc;\n\tstruct mcd_mbox *mbx;\n\tint diskin;\n{\n\tint retry, i, error;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\t\n\tif (sc->debug) {\n\t\tprintf(\"%s: mcd_send: %d %02x\", sc->sc_dev.dv_xname,\n\t\t    mbx->cmd.length, (u_int)mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tprintf(\" %02x\", (u_int)mbx->cmd.data.raw.data[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tfor (retry = MCD_RETRIES; retry; retry--) {\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.data.raw.data[i]);\n\t\tif ((error = mcd_getresult(sc, &mbx->res)) == 0)\n\t\t\tbreak;\n\t\tif (error == EINVAL)\n\t\t\treturn error;\n\t}\n\tif (!retry)\n\t\treturn error;\n\tif (diskin && (sc->flags & MCDF_LOADED) == 0)\n\t\treturn EIO;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: mcd_stop: stopping play\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint mcd_stop;\nint mcd_send;\n\nint\nmcd_stop(sc)\n\tstruct mcd_softc *sc;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (sc->debug)\n\t\tprintf(\"%s: mcd_stop: stopping play\\n\", sc->sc_dev.dv_xname);\n\n\tmbx.cmd.opcode = MCD_CMDSTOPAUDIO;\n\tmbx.cmd.length = 0;\n\tmbx.res.length = 0;\n\tif ((error = mcd_send(sc, &mbx, 1)) != 0)\n\t\treturn error;\n\n\tsc->audio_status = CD_AS_PLAY_COMPLETED;\n\treturn 0;\n}"
  },
  {
    "function_name": "mcd_toc_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
    "lines": "1434-1501",
    "snippet": "int\nmcd_toc_entries(sc, te)\n\tstruct mcd_softc *sc;\n\tstruct ioc_read_toc_entry *te;\n{\n\tint len = te->data_len;\n\tstruct ret_toc {\n\t\tstruct ioc_toc_header header;\n\t\tstruct cd_toc_entry entries[MCD_MAXTOCS];\n\t} data;\n\tu_char trk;\n\tdaddr_t lba;\n\tint error, n;\n\n\tif (len > sizeof(data.entries) ||\n\t    len < sizeof(struct cd_toc_entry))\n\t\treturn EINVAL;\n\tif (te->address_format != CD_MSF_FORMAT &&\n\t    te->address_format != CD_LBA_FORMAT)\n\t\treturn EINVAL;\n\n\t/* Copy the TOC header. */\n\tif ((error = mcd_toc_header(sc, &data.header)) != 0)\n\t\treturn error;\n\n\t/* Verify starting track. */\n\ttrk = te->starting_track;\n\tif (trk == 0x00)\n\t\ttrk = data.header.starting_track;\n\telse if (trk == 0xaa)\n\t\ttrk = data.header.ending_track + 1;\n\telse if (trk < data.header.starting_track ||\n\t\t trk > data.header.ending_track + 1)\n\t\treturn EINVAL;\n\n\t/* Copy the TOC data. */\n\tfor (n = 0; trk <= data.header.ending_track + 1; trk++) {\n\t\tif (sc->toc[trk].toc.idx_no == 0x00)\n\t\t\tcontinue;\n\t\tdata.entries[n].control = sc->toc[trk].toc.control;\n\t\tdata.entries[n].addr_type = sc->toc[trk].toc.addr_type;\n\t\tdata.entries[n].track = bcd2bin(sc->toc[trk].toc.idx_no);\n\t\tswitch (te->address_format) {\n\t\tcase CD_MSF_FORMAT:\n\t\t\tdata.entries[n].addr.addr[0] = 0;\n\t\t\tdata.entries[n].addr.addr[1] =\n\t\t\t    bcd2bin(sc->toc[trk].toc.absolute_pos[0]);\n\t\t\tdata.entries[n].addr.addr[2] =\n\t\t\t    bcd2bin(sc->toc[trk].toc.absolute_pos[1]);\n\t\t\tdata.entries[n].addr.addr[3] =\n\t\t\t    bcd2bin(sc->toc[trk].toc.absolute_pos[2]);\n\t\t\tbreak;\n\t\tcase CD_LBA_FORMAT:\n\t\t\tlba = msf2hsg(sc->toc[trk].toc.absolute_pos, 0);\n\t\t\tdata.entries[n].addr.addr[0] = lba >> 24;\n\t\t\tdata.entries[n].addr.addr[1] = lba >> 16;\n\t\t\tdata.entries[n].addr.addr[2] = lba >> 8;\n\t\t\tdata.entries[n].addr.addr[3] = lba;\n\t\t\tbreak;\n\t\t}\n\t\tn++;\n\t}\n\n\tlen = min(len, n * sizeof(struct cd_toc_entry));\n\n\t/* Copy the data back. */\n\treturn copyout(&data.entries[0], te->data, len);\n}",
    "includes": [
      "#include <lib/libkern/libkern.h>",
      "#include <dev/isa/opti.h>",
      "#include <dev/isa/mcdreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/errno.h>",
      "#include <sys/cdio.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/uio.h>",
      "#include <sys/stat.h>",
      "#include <sys/buf.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define MCD_MAXTOCS\t104\t/* from the Linux driver */"
    ],
    "globals_used": [
      "static daddr_t msf2hsg",
      "int mcd_toc_header",
      "int mcd_toc_entries"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copyout",
          "args": [
            "&data.entries[0]",
            "te->data",
            "len"
          ],
          "line": 1500
        },
        "resolved": true,
        "details": {
          "function_name": "audio_silence_copyout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "1249-1268",
          "snippet": "int\naudio_silence_copyout(sc, n, uio)\n\tstruct audio_softc *sc;\n\tint n;\n\tstruct uio *uio;\n{\n\tint error;\n\tint k;\n\tu_char zerobuf[128];\n\n\taudio_fill_silence(&sc->sc_rparams, zerobuf, sizeof zerobuf);\n\n\terror = 0;\n        while (n > 0 && uio->uio_resid > 0 && !error) {\n\t\tk = min(n, min(uio->uio_resid, sizeof zerobuf));\n\t\terror = uiomove(zerobuf, k, uio);\n\t\tn -= k;\n\t}\n        return (error);\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudio_silence_copyout(sc, n, uio)\n\tstruct audio_softc *sc;\n\tint n;\n\tstruct uio *uio;\n{\n\tint error;\n\tint k;\n\tu_char zerobuf[128];\n\n\taudio_fill_silence(&sc->sc_rparams, zerobuf, sizeof zerobuf);\n\n\terror = 0;\n        while (n > 0 && uio->uio_resid > 0 && !error) {\n\t\tk = min(n, min(uio->uio_resid, sizeof zerobuf));\n\t\terror = uiomove(zerobuf, k, uio);\n\t\tn -= k;\n\t}\n        return (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "len",
            "n * sizeof(struct cd_toc_entry)"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "btminphys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "1088-1096",
          "snippet": "void\nbtminphys(bp)\n\tstruct buf *bp;\n{\n\n\tif (bp->b_bcount > ((BT_NSEG - 1) << PGSHIFT))\n\t\tbp->b_bcount = ((BT_NSEG - 1) << PGSHIFT);\n\tminphys(bp);\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void btminphys"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid btminphys;\n\nvoid\nbtminphys(bp)\n\tstruct buf *bp;\n{\n\n\tif (bp->b_bcount > ((BT_NSEG - 1) << PGSHIFT))\n\t\tbp->b_bcount = ((BT_NSEG - 1) << PGSHIFT);\n\tminphys(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msf2hsg",
          "args": [
            "sc->toc[trk].toc.absolute_pos",
            "0"
          ],
          "line": 1487
        },
        "resolved": true,
        "details": {
          "function_name": "msf2hsg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1093-1106",
          "snippet": "static daddr_t\nmsf2hsg(msf, relative)\n\tbcd_t *msf;\n\tint relative;\n{\n\tdaddr_t blkno;\n\n\tblkno = bcd2bin(M_msf(msf)) * 75 * 60 +\n\t\tbcd2bin(S_msf(msf)) * 75 +\n\t\tbcd2bin(F_msf(msf));\n\tif (!relative)\n\t\tblkno -= 150;\n\treturn blkno;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__P((int, bcd_t *));",
            "static daddr_t msf2hsg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n__P((int, bcd_t *));\nstatic daddr_t msf2hsg;\n\nstatic daddr_t\nmsf2hsg(msf, relative)\n\tbcd_t *msf;\n\tint relative;\n{\n\tdaddr_t blkno;\n\n\tblkno = bcd2bin(M_msf(msf)) * 75 * 60 +\n\t\tbcd2bin(S_msf(msf)) * 75 +\n\t\tbcd2bin(F_msf(msf));\n\tif (!relative)\n\t\tblkno -= 150;\n\treturn blkno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcd2bin",
          "args": [
            "sc->toc[trk].toc.absolute_pos[2]"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcd2bin",
          "args": [
            "sc->toc[trk].toc.absolute_pos[1]"
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcd2bin",
          "args": [
            "sc->toc[trk].toc.absolute_pos[0]"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcd2bin",
          "args": [
            "sc->toc[trk].toc.idx_no"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mcd_toc_header",
          "args": [
            "sc",
            "&data.header"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_toc_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1363-1378",
          "snippet": "int\nmcd_toc_header(sc, th)\n\tstruct mcd_softc *sc;\n\tstruct ioc_toc_header *th;\n{\n\n\tif (sc->debug)\n\t\tprintf(\"%s: mcd_toc_header: reading toc header\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\n\tth->len = msf2hsg(sc->volinfo.vol_msf, 0);\n\tth->starting_track = bcd2bin(sc->volinfo.trk_low);\n\tth->ending_track = bcd2bin(sc->volinfo.trk_high);\n\n\treturn 0;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static daddr_t msf2hsg",
            "int mcd_toc_header"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic daddr_t msf2hsg;\nint mcd_toc_header;\n\nint\nmcd_toc_header(sc, th)\n\tstruct mcd_softc *sc;\n\tstruct ioc_toc_header *th;\n{\n\n\tif (sc->debug)\n\t\tprintf(\"%s: mcd_toc_header: reading toc header\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\n\tth->len = msf2hsg(sc->volinfo.vol_msf, 0);\n\tth->starting_track = bcd2bin(sc->volinfo.trk_low);\n\tth->ending_track = bcd2bin(sc->volinfo.trk_high);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MCD_MAXTOCS\t104\t/* from the Linux driver */\n\nstatic daddr_t msf2hsg;\nint mcd_toc_header;\nint mcd_toc_entries;\n\nint\nmcd_toc_entries(sc, te)\n\tstruct mcd_softc *sc;\n\tstruct ioc_read_toc_entry *te;\n{\n\tint len = te->data_len;\n\tstruct ret_toc {\n\t\tstruct ioc_toc_header header;\n\t\tstruct cd_toc_entry entries[MCD_MAXTOCS];\n\t} data;\n\tu_char trk;\n\tdaddr_t lba;\n\tint error, n;\n\n\tif (len > sizeof(data.entries) ||\n\t    len < sizeof(struct cd_toc_entry))\n\t\treturn EINVAL;\n\tif (te->address_format != CD_MSF_FORMAT &&\n\t    te->address_format != CD_LBA_FORMAT)\n\t\treturn EINVAL;\n\n\t/* Copy the TOC header. */\n\tif ((error = mcd_toc_header(sc, &data.header)) != 0)\n\t\treturn error;\n\n\t/* Verify starting track. */\n\ttrk = te->starting_track;\n\tif (trk == 0x00)\n\t\ttrk = data.header.starting_track;\n\telse if (trk == 0xaa)\n\t\ttrk = data.header.ending_track + 1;\n\telse if (trk < data.header.starting_track ||\n\t\t trk > data.header.ending_track + 1)\n\t\treturn EINVAL;\n\n\t/* Copy the TOC data. */\n\tfor (n = 0; trk <= data.header.ending_track + 1; trk++) {\n\t\tif (sc->toc[trk].toc.idx_no == 0x00)\n\t\t\tcontinue;\n\t\tdata.entries[n].control = sc->toc[trk].toc.control;\n\t\tdata.entries[n].addr_type = sc->toc[trk].toc.addr_type;\n\t\tdata.entries[n].track = bcd2bin(sc->toc[trk].toc.idx_no);\n\t\tswitch (te->address_format) {\n\t\tcase CD_MSF_FORMAT:\n\t\t\tdata.entries[n].addr.addr[0] = 0;\n\t\t\tdata.entries[n].addr.addr[1] =\n\t\t\t    bcd2bin(sc->toc[trk].toc.absolute_pos[0]);\n\t\t\tdata.entries[n].addr.addr[2] =\n\t\t\t    bcd2bin(sc->toc[trk].toc.absolute_pos[1]);\n\t\t\tdata.entries[n].addr.addr[3] =\n\t\t\t    bcd2bin(sc->toc[trk].toc.absolute_pos[2]);\n\t\t\tbreak;\n\t\tcase CD_LBA_FORMAT:\n\t\t\tlba = msf2hsg(sc->toc[trk].toc.absolute_pos, 0);\n\t\t\tdata.entries[n].addr.addr[0] = lba >> 24;\n\t\t\tdata.entries[n].addr.addr[1] = lba >> 16;\n\t\t\tdata.entries[n].addr.addr[2] = lba >> 8;\n\t\t\tdata.entries[n].addr.addr[3] = lba;\n\t\t\tbreak;\n\t\t}\n\t\tn++;\n\t}\n\n\tlen = min(len, n * sizeof(struct cd_toc_entry));\n\n\t/* Copy the data back. */\n\treturn copyout(&data.entries[0], te->data, len);\n}"
  },
  {
    "function_name": "mcd_read_toc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
    "lines": "1380-1432",
    "snippet": "int\nmcd_read_toc(sc)\n\tstruct mcd_softc *sc;\n{\n\tstruct ioc_toc_header th;\n\tunion mcd_qchninfo q;\n\tint error, trk, idx, retry;\n\n\tif ((error = mcd_toc_header(sc, &th)) != 0)\n\t\treturn error;\n\n\tif ((error = mcd_stop(sc)) != 0)\n\t\treturn error;\n\n\tif (sc->debug)\n\t\tprintf(\"%s: read_toc: reading qchannel info\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\n\tfor (trk = th.starting_track; trk <= th.ending_track; trk++)\n\t\tsc->toc[trk].toc.idx_no = 0x00;\n\ttrk = th.ending_track - th.starting_track + 1;\n\tfor (retry = 300; retry && trk > 0; retry--) {\n\t\tif (mcd_getqchan(sc, &q, CD_TRACK_INFO) != 0)\n\t\t\tbreak;\n\t\tif (q.toc.trk_no != 0x00 || q.toc.idx_no == 0x00)\n\t\t\tcontinue;\n\t\tidx = bcd2bin(q.toc.idx_no);\n\t\tif (idx < MCD_MAXTOCS &&\n\t\t    sc->toc[idx].toc.idx_no == 0x00) {\n\t\t\tsc->toc[idx] = q;\n\t\t\ttrk--;\n\t\t}\n\t}\n\n\t/* Inform the drive that we're finished so it turns off the light. */\n\tif ((error = mcd_setmode(sc, MCD_MD_COOKED)) != 0)\n\t\treturn error;\n\n\tif (trk != 0)\n\t\treturn EINVAL;\n\n\t/* Add a fake last+1 for mcd_playtracks(). */\n\tidx = th.ending_track + 1;\n\tsc->toc[idx].toc.control = sc->toc[idx-1].toc.control;\n\tsc->toc[idx].toc.addr_type = sc->toc[idx-1].toc.addr_type;\n\tsc->toc[idx].toc.trk_no = 0x00;\n\tsc->toc[idx].toc.idx_no = 0xaa;\n\tsc->toc[idx].toc.absolute_pos[0] = sc->volinfo.vol_msf[0];\n\tsc->toc[idx].toc.absolute_pos[1] = sc->volinfo.vol_msf[1];\n\tsc->toc[idx].toc.absolute_pos[2] = sc->volinfo.vol_msf[2];\n\n\treturn 0;\n}",
    "includes": [
      "#include <lib/libkern/libkern.h>",
      "#include <dev/isa/opti.h>",
      "#include <dev/isa/mcdreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/errno.h>",
      "#include <sys/cdio.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/uio.h>",
      "#include <sys/stat.h>",
      "#include <sys/buf.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define MCD_MAXTOCS\t104\t/* from the Linux driver */"
    ],
    "globals_used": [
      "int mcd_playtracks",
      "int mcd_stop",
      "int mcd_toc_header",
      "int mcd_setmode",
      "int mcd_read_toc",
      "int mcd_getqchan"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mcd_setmode",
          "args": [
            "sc",
            "MCD_MD_COOKED"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_setmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1312-1335",
          "snippet": "int\nmcd_setmode(sc, mode)\n\tstruct mcd_softc *sc;\n\tint mode;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (sc->lastmode == mode)\n\t\treturn 0;\n\tif (sc->debug)\n\t\tprintf(\"%s: setting mode to %d\\n\", sc->sc_dev.dv_xname, mode);\n\tsc->lastmode = MCD_MD_UNKNOWN;\n\n\tmbx.cmd.opcode = MCD_CMDSETMODE;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.datamode);\n\tmbx.cmd.data.datamode.mode = mode;\n\tmbx.res.length = 0;\n\tif ((error = mcd_send(sc, &mbx, 1)) != 0)\n\t\treturn error;\n\n\tsc->lastmode = mode;\n\treturn 0;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tMCD_MD_UNKNOWN\t-1"
          ],
          "globals_used": [
            "int mcd_send",
            "int mcd_setmode"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tMCD_MD_UNKNOWN\t-1\n\nint mcd_send;\nint mcd_setmode;\n\nint\nmcd_setmode(sc, mode)\n\tstruct mcd_softc *sc;\n\tint mode;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (sc->lastmode == mode)\n\t\treturn 0;\n\tif (sc->debug)\n\t\tprintf(\"%s: setting mode to %d\\n\", sc->sc_dev.dv_xname, mode);\n\tsc->lastmode = MCD_MD_UNKNOWN;\n\n\tmbx.cmd.opcode = MCD_CMDSETMODE;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.datamode);\n\tmbx.cmd.data.datamode.mode = mode;\n\tmbx.res.length = 0;\n\tif ((error = mcd_send(sc, &mbx, 1)) != 0)\n\t\treturn error;\n\n\tsc->lastmode = mode;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcd2bin",
          "args": [
            "q.toc.idx_no"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mcd_getqchan",
          "args": [
            "sc",
            "&q",
            "CD_TRACK_INFO"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_getqchan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1523-1555",
          "snippet": "int\nmcd_getqchan(sc, q, qchn)\n\tstruct mcd_softc *sc;\n\tunion mcd_qchninfo *q;\n\tint qchn;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (qchn == CD_TRACK_INFO) {\n\t\tif ((error = mcd_setmode(sc, MCD_MD_TOC)) != 0)\n\t\t\treturn error;\n\t} else {\n\t\tif ((error = mcd_setmode(sc, MCD_MD_COOKED)) != 0)\n\t\t\treturn error;\n\t}\n\tif (qchn == CD_MEDIA_CATALOG) {\n\t\tif ((error = mcd_setupc(sc, MCD_UPC_ENABLE)) != 0)\n\t\t\treturn error;\n\t} else {\n\t\tif ((error = mcd_setupc(sc, MCD_UPC_DISABLE)) != 0)\n\t\t\treturn error;\n\t}\n\n\tmbx.cmd.opcode = MCD_CMDGETQCHN;\n\tmbx.cmd.length = 0;\n\tmbx.res.length = sizeof(mbx.res.data.qchninfo);\n\tif ((error = mcd_send(sc, &mbx, 1)) != 0)\n\t\treturn error;\n\n\t*q = mbx.res.data.qchninfo;\n\treturn 0;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int mcd_send",
            "int mcd_setmode",
            "int mcd_setupc",
            "int mcd_getqchan"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint mcd_send;\nint mcd_setmode;\nint mcd_setupc;\nint mcd_getqchan;\n\nint\nmcd_getqchan(sc, q, qchn)\n\tstruct mcd_softc *sc;\n\tunion mcd_qchninfo *q;\n\tint qchn;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (qchn == CD_TRACK_INFO) {\n\t\tif ((error = mcd_setmode(sc, MCD_MD_TOC)) != 0)\n\t\t\treturn error;\n\t} else {\n\t\tif ((error = mcd_setmode(sc, MCD_MD_COOKED)) != 0)\n\t\t\treturn error;\n\t}\n\tif (qchn == CD_MEDIA_CATALOG) {\n\t\tif ((error = mcd_setupc(sc, MCD_UPC_ENABLE)) != 0)\n\t\t\treturn error;\n\t} else {\n\t\tif ((error = mcd_setupc(sc, MCD_UPC_DISABLE)) != 0)\n\t\t\treturn error;\n\t}\n\n\tmbx.cmd.opcode = MCD_CMDGETQCHN;\n\tmbx.cmd.length = 0;\n\tmbx.res.length = sizeof(mbx.res.data.qchninfo);\n\tif ((error = mcd_send(sc, &mbx, 1)) != 0)\n\t\treturn error;\n\n\t*q = mbx.res.data.qchninfo;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: read_toc: reading qchannel info\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1395
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mcd_stop",
          "args": [
            "sc"
          ],
          "line": 1391
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1503-1521",
          "snippet": "int\nmcd_stop(sc)\n\tstruct mcd_softc *sc;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (sc->debug)\n\t\tprintf(\"%s: mcd_stop: stopping play\\n\", sc->sc_dev.dv_xname);\n\n\tmbx.cmd.opcode = MCD_CMDSTOPAUDIO;\n\tmbx.cmd.length = 0;\n\tmbx.res.length = 0;\n\tif ((error = mcd_send(sc, &mbx, 1)) != 0)\n\t\treturn error;\n\n\tsc->audio_status = CD_AS_PLAY_COMPLETED;\n\treturn 0;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int mcd_stop",
            "int mcd_send"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint mcd_stop;\nint mcd_send;\n\nint\nmcd_stop(sc)\n\tstruct mcd_softc *sc;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (sc->debug)\n\t\tprintf(\"%s: mcd_stop: stopping play\\n\", sc->sc_dev.dv_xname);\n\n\tmbx.cmd.opcode = MCD_CMDSTOPAUDIO;\n\tmbx.cmd.length = 0;\n\tmbx.res.length = 0;\n\tif ((error = mcd_send(sc, &mbx, 1)) != 0)\n\t\treturn error;\n\n\tsc->audio_status = CD_AS_PLAY_COMPLETED;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mcd_toc_header",
          "args": [
            "sc",
            "&th"
          ],
          "line": 1388
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_toc_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1363-1378",
          "snippet": "int\nmcd_toc_header(sc, th)\n\tstruct mcd_softc *sc;\n\tstruct ioc_toc_header *th;\n{\n\n\tif (sc->debug)\n\t\tprintf(\"%s: mcd_toc_header: reading toc header\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\n\tth->len = msf2hsg(sc->volinfo.vol_msf, 0);\n\tth->starting_track = bcd2bin(sc->volinfo.trk_low);\n\tth->ending_track = bcd2bin(sc->volinfo.trk_high);\n\n\treturn 0;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static daddr_t msf2hsg",
            "int mcd_toc_header"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic daddr_t msf2hsg;\nint mcd_toc_header;\n\nint\nmcd_toc_header(sc, th)\n\tstruct mcd_softc *sc;\n\tstruct ioc_toc_header *th;\n{\n\n\tif (sc->debug)\n\t\tprintf(\"%s: mcd_toc_header: reading toc header\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\n\tth->len = msf2hsg(sc->volinfo.vol_msf, 0);\n\tth->starting_track = bcd2bin(sc->volinfo.trk_low);\n\tth->ending_track = bcd2bin(sc->volinfo.trk_high);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MCD_MAXTOCS\t104\t/* from the Linux driver */\n\nint mcd_playtracks;\nint mcd_stop;\nint mcd_toc_header;\nint mcd_setmode;\nint mcd_read_toc;\nint mcd_getqchan;\n\nint\nmcd_read_toc(sc)\n\tstruct mcd_softc *sc;\n{\n\tstruct ioc_toc_header th;\n\tunion mcd_qchninfo q;\n\tint error, trk, idx, retry;\n\n\tif ((error = mcd_toc_header(sc, &th)) != 0)\n\t\treturn error;\n\n\tif ((error = mcd_stop(sc)) != 0)\n\t\treturn error;\n\n\tif (sc->debug)\n\t\tprintf(\"%s: read_toc: reading qchannel info\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\n\tfor (trk = th.starting_track; trk <= th.ending_track; trk++)\n\t\tsc->toc[trk].toc.idx_no = 0x00;\n\ttrk = th.ending_track - th.starting_track + 1;\n\tfor (retry = 300; retry && trk > 0; retry--) {\n\t\tif (mcd_getqchan(sc, &q, CD_TRACK_INFO) != 0)\n\t\t\tbreak;\n\t\tif (q.toc.trk_no != 0x00 || q.toc.idx_no == 0x00)\n\t\t\tcontinue;\n\t\tidx = bcd2bin(q.toc.idx_no);\n\t\tif (idx < MCD_MAXTOCS &&\n\t\t    sc->toc[idx].toc.idx_no == 0x00) {\n\t\t\tsc->toc[idx] = q;\n\t\t\ttrk--;\n\t\t}\n\t}\n\n\t/* Inform the drive that we're finished so it turns off the light. */\n\tif ((error = mcd_setmode(sc, MCD_MD_COOKED)) != 0)\n\t\treturn error;\n\n\tif (trk != 0)\n\t\treturn EINVAL;\n\n\t/* Add a fake last+1 for mcd_playtracks(). */\n\tidx = th.ending_track + 1;\n\tsc->toc[idx].toc.control = sc->toc[idx-1].toc.control;\n\tsc->toc[idx].toc.addr_type = sc->toc[idx-1].toc.addr_type;\n\tsc->toc[idx].toc.trk_no = 0x00;\n\tsc->toc[idx].toc.idx_no = 0xaa;\n\tsc->toc[idx].toc.absolute_pos[0] = sc->volinfo.vol_msf[0];\n\tsc->toc[idx].toc.absolute_pos[1] = sc->volinfo.vol_msf[1];\n\tsc->toc[idx].toc.absolute_pos[2] = sc->volinfo.vol_msf[2];\n\n\treturn 0;\n}"
  },
  {
    "function_name": "mcd_toc_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
    "lines": "1363-1378",
    "snippet": "int\nmcd_toc_header(sc, th)\n\tstruct mcd_softc *sc;\n\tstruct ioc_toc_header *th;\n{\n\n\tif (sc->debug)\n\t\tprintf(\"%s: mcd_toc_header: reading toc header\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\n\tth->len = msf2hsg(sc->volinfo.vol_msf, 0);\n\tth->starting_track = bcd2bin(sc->volinfo.trk_low);\n\tth->ending_track = bcd2bin(sc->volinfo.trk_high);\n\n\treturn 0;\n}",
    "includes": [
      "#include <lib/libkern/libkern.h>",
      "#include <dev/isa/opti.h>",
      "#include <dev/isa/mcdreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/errno.h>",
      "#include <sys/cdio.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/uio.h>",
      "#include <sys/stat.h>",
      "#include <sys/buf.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static daddr_t msf2hsg",
      "int mcd_toc_header"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bcd2bin",
          "args": [
            "sc->volinfo.trk_high"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcd2bin",
          "args": [
            "sc->volinfo.trk_low"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msf2hsg",
          "args": [
            "sc->volinfo.vol_msf",
            "0"
          ],
          "line": 1373
        },
        "resolved": true,
        "details": {
          "function_name": "msf2hsg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1093-1106",
          "snippet": "static daddr_t\nmsf2hsg(msf, relative)\n\tbcd_t *msf;\n\tint relative;\n{\n\tdaddr_t blkno;\n\n\tblkno = bcd2bin(M_msf(msf)) * 75 * 60 +\n\t\tbcd2bin(S_msf(msf)) * 75 +\n\t\tbcd2bin(F_msf(msf));\n\tif (!relative)\n\t\tblkno -= 150;\n\treturn blkno;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__P((int, bcd_t *));",
            "static daddr_t msf2hsg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n__P((int, bcd_t *));\nstatic daddr_t msf2hsg;\n\nstatic daddr_t\nmsf2hsg(msf, relative)\n\tbcd_t *msf;\n\tint relative;\n{\n\tdaddr_t blkno;\n\n\tblkno = bcd2bin(M_msf(msf)) * 75 * 60 +\n\t\tbcd2bin(S_msf(msf)) * 75 +\n\t\tbcd2bin(F_msf(msf));\n\tif (!relative)\n\t\tblkno -= 150;\n\treturn blkno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: mcd_toc_header: reading toc header\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1370
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic daddr_t msf2hsg;\nint mcd_toc_header;\n\nint\nmcd_toc_header(sc, th)\n\tstruct mcd_softc *sc;\n\tstruct ioc_toc_header *th;\n{\n\n\tif (sc->debug)\n\t\tprintf(\"%s: mcd_toc_header: reading toc header\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\n\tth->len = msf2hsg(sc->volinfo.vol_msf, 0);\n\tth->starting_track = bcd2bin(sc->volinfo.trk_low);\n\tth->ending_track = bcd2bin(sc->volinfo.trk_high);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "mcd_setupc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
    "lines": "1337-1361",
    "snippet": "int\nmcd_setupc(sc, upc)\n\tstruct mcd_softc *sc;\n\tint upc;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (sc->lastupc == upc)\n\t\treturn 0;\n\tif (sc->debug)\n\t\tprintf(\"%s: setting upc to %d\\n\", sc->sc_dev.dv_xname, upc);\n\tsc->lastupc = MCD_UPC_UNKNOWN;\n\n\tmbx.cmd.opcode = MCD_CMDCONFIGDRIVE;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.config) - 1;\n\tmbx.cmd.data.config.subcommand = MCD_CF_READUPC;\n\tmbx.cmd.data.config.data1 = upc;\n\tmbx.res.length = 0;\n\tif ((error = mcd_send(sc, &mbx, 1)) != 0)\n\t\treturn error;\n\n\tsc->lastupc = upc;\n\treturn 0;\n}",
    "includes": [
      "#include <lib/libkern/libkern.h>",
      "#include <dev/isa/opti.h>",
      "#include <dev/isa/mcdreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/errno.h>",
      "#include <sys/cdio.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/uio.h>",
      "#include <sys/stat.h>",
      "#include <sys/buf.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tMCD_UPC_UNKNOWN\t-1"
    ],
    "globals_used": [
      "int mcd_send",
      "int mcd_setupc"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mcd_send",
          "args": [
            "sc",
            "&mbx",
            "1"
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1044-1077",
          "snippet": "int\nmcd_send(sc, mbx, diskin)\n\tstruct mcd_softc *sc;\n\tstruct mcd_mbox *mbx;\n\tint diskin;\n{\n\tint retry, i, error;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\t\n\tif (sc->debug) {\n\t\tprintf(\"%s: mcd_send: %d %02x\", sc->sc_dev.dv_xname,\n\t\t    mbx->cmd.length, (u_int)mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tprintf(\" %02x\", (u_int)mbx->cmd.data.raw.data[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tfor (retry = MCD_RETRIES; retry; retry--) {\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.data.raw.data[i]);\n\t\tif ((error = mcd_getresult(sc, &mbx->res)) == 0)\n\t\t\tbreak;\n\t\tif (error == EINVAL)\n\t\t\treturn error;\n\t}\n\tif (!retry)\n\t\treturn error;\n\tif (diskin && (sc->flags & MCDF_LOADED) == 0)\n\t\treturn EIO;\n\n\treturn 0;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MCD_RETRIES\t3",
            "#define\tMCDF_LOADED\t0x10\t/* parameters loaded */"
          ],
          "globals_used": [
            "int mcd_getresult",
            "int mcd_send"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MCD_RETRIES\t3\n#define\tMCDF_LOADED\t0x10\t/* parameters loaded */\n\nint mcd_getresult;\nint mcd_send;\n\nint\nmcd_send(sc, mbx, diskin)\n\tstruct mcd_softc *sc;\n\tstruct mcd_mbox *mbx;\n\tint diskin;\n{\n\tint retry, i, error;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\t\n\tif (sc->debug) {\n\t\tprintf(\"%s: mcd_send: %d %02x\", sc->sc_dev.dv_xname,\n\t\t    mbx->cmd.length, (u_int)mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tprintf(\" %02x\", (u_int)mbx->cmd.data.raw.data[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tfor (retry = MCD_RETRIES; retry; retry--) {\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.data.raw.data[i]);\n\t\tif ((error = mcd_getresult(sc, &mbx->res)) == 0)\n\t\t\tbreak;\n\t\tif (error == EINVAL)\n\t\t\treturn error;\n\t}\n\tif (!retry)\n\t\treturn error;\n\tif (diskin && (sc->flags & MCDF_LOADED) == 0)\n\t\treturn EIO;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: setting upc to %d\\n\"",
            "sc->sc_dev.dv_xname",
            "upc"
          ],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tMCD_UPC_UNKNOWN\t-1\n\nint mcd_send;\nint mcd_setupc;\n\nint\nmcd_setupc(sc, upc)\n\tstruct mcd_softc *sc;\n\tint upc;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (sc->lastupc == upc)\n\t\treturn 0;\n\tif (sc->debug)\n\t\tprintf(\"%s: setting upc to %d\\n\", sc->sc_dev.dv_xname, upc);\n\tsc->lastupc = MCD_UPC_UNKNOWN;\n\n\tmbx.cmd.opcode = MCD_CMDCONFIGDRIVE;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.config) - 1;\n\tmbx.cmd.data.config.subcommand = MCD_CF_READUPC;\n\tmbx.cmd.data.config.data1 = upc;\n\tmbx.res.length = 0;\n\tif ((error = mcd_send(sc, &mbx, 1)) != 0)\n\t\treturn error;\n\n\tsc->lastupc = upc;\n\treturn 0;\n}"
  },
  {
    "function_name": "mcd_setmode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
    "lines": "1312-1335",
    "snippet": "int\nmcd_setmode(sc, mode)\n\tstruct mcd_softc *sc;\n\tint mode;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (sc->lastmode == mode)\n\t\treturn 0;\n\tif (sc->debug)\n\t\tprintf(\"%s: setting mode to %d\\n\", sc->sc_dev.dv_xname, mode);\n\tsc->lastmode = MCD_MD_UNKNOWN;\n\n\tmbx.cmd.opcode = MCD_CMDSETMODE;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.datamode);\n\tmbx.cmd.data.datamode.mode = mode;\n\tmbx.res.length = 0;\n\tif ((error = mcd_send(sc, &mbx, 1)) != 0)\n\t\treturn error;\n\n\tsc->lastmode = mode;\n\treturn 0;\n}",
    "includes": [
      "#include <lib/libkern/libkern.h>",
      "#include <dev/isa/opti.h>",
      "#include <dev/isa/mcdreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/errno.h>",
      "#include <sys/cdio.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/uio.h>",
      "#include <sys/stat.h>",
      "#include <sys/buf.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tMCD_MD_UNKNOWN\t-1"
    ],
    "globals_used": [
      "int mcd_send",
      "int mcd_setmode"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mcd_send",
          "args": [
            "sc",
            "&mbx",
            "1"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1044-1077",
          "snippet": "int\nmcd_send(sc, mbx, diskin)\n\tstruct mcd_softc *sc;\n\tstruct mcd_mbox *mbx;\n\tint diskin;\n{\n\tint retry, i, error;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\t\n\tif (sc->debug) {\n\t\tprintf(\"%s: mcd_send: %d %02x\", sc->sc_dev.dv_xname,\n\t\t    mbx->cmd.length, (u_int)mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tprintf(\" %02x\", (u_int)mbx->cmd.data.raw.data[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tfor (retry = MCD_RETRIES; retry; retry--) {\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.data.raw.data[i]);\n\t\tif ((error = mcd_getresult(sc, &mbx->res)) == 0)\n\t\t\tbreak;\n\t\tif (error == EINVAL)\n\t\t\treturn error;\n\t}\n\tif (!retry)\n\t\treturn error;\n\tif (diskin && (sc->flags & MCDF_LOADED) == 0)\n\t\treturn EIO;\n\n\treturn 0;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MCD_RETRIES\t3",
            "#define\tMCDF_LOADED\t0x10\t/* parameters loaded */"
          ],
          "globals_used": [
            "int mcd_getresult",
            "int mcd_send"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MCD_RETRIES\t3\n#define\tMCDF_LOADED\t0x10\t/* parameters loaded */\n\nint mcd_getresult;\nint mcd_send;\n\nint\nmcd_send(sc, mbx, diskin)\n\tstruct mcd_softc *sc;\n\tstruct mcd_mbox *mbx;\n\tint diskin;\n{\n\tint retry, i, error;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\t\n\tif (sc->debug) {\n\t\tprintf(\"%s: mcd_send: %d %02x\", sc->sc_dev.dv_xname,\n\t\t    mbx->cmd.length, (u_int)mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tprintf(\" %02x\", (u_int)mbx->cmd.data.raw.data[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tfor (retry = MCD_RETRIES; retry; retry--) {\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.data.raw.data[i]);\n\t\tif ((error = mcd_getresult(sc, &mbx->res)) == 0)\n\t\t\tbreak;\n\t\tif (error == EINVAL)\n\t\t\treturn error;\n\t}\n\tif (!retry)\n\t\treturn error;\n\tif (diskin && (sc->flags & MCDF_LOADED) == 0)\n\t\treturn EIO;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: setting mode to %d\\n\"",
            "sc->sc_dev.dv_xname",
            "mode"
          ],
          "line": 1323
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tMCD_MD_UNKNOWN\t-1\n\nint mcd_send;\nint mcd_setmode;\n\nint\nmcd_setmode(sc, mode)\n\tstruct mcd_softc *sc;\n\tint mode;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (sc->lastmode == mode)\n\t\treturn 0;\n\tif (sc->debug)\n\t\tprintf(\"%s: setting mode to %d\\n\", sc->sc_dev.dv_xname, mode);\n\tsc->lastmode = MCD_MD_UNKNOWN;\n\n\tmbx.cmd.opcode = MCD_CMDSETMODE;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.datamode);\n\tmbx.cmd.data.datamode.mode = mode;\n\tmbx.res.length = 0;\n\tif ((error = mcd_send(sc, &mbx, 1)) != 0)\n\t\treturn error;\n\n\tsc->lastmode = mode;\n\treturn 0;\n}"
  },
  {
    "function_name": "mcd_hard_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
    "lines": "1298-1310",
    "snippet": "int\nmcd_hard_reset(sc)\n\tstruct mcd_softc *sc;\n{\n\tstruct mcd_mbox mbx;\n\n\tmcd_soft_reset(sc);\n\n\tmbx.cmd.opcode = MCD_CMDRESET;\n\tmbx.cmd.length = 0;\n\tmbx.res.length = 0;\n\treturn mcd_send(sc, &mbx, 0);\n}",
    "includes": [
      "#include <lib/libkern/libkern.h>",
      "#include <dev/isa/opti.h>",
      "#include <dev/isa/mcdreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/errno.h>",
      "#include <sys/cdio.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/uio.h>",
      "#include <sys/stat.h>",
      "#include <sys/buf.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int mcd_send",
      "void mcd_soft_reset",
      "int mcd_hard_reset"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mcd_send",
          "args": [
            "sc",
            "&mbx",
            "0"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1044-1077",
          "snippet": "int\nmcd_send(sc, mbx, diskin)\n\tstruct mcd_softc *sc;\n\tstruct mcd_mbox *mbx;\n\tint diskin;\n{\n\tint retry, i, error;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\t\n\tif (sc->debug) {\n\t\tprintf(\"%s: mcd_send: %d %02x\", sc->sc_dev.dv_xname,\n\t\t    mbx->cmd.length, (u_int)mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tprintf(\" %02x\", (u_int)mbx->cmd.data.raw.data[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tfor (retry = MCD_RETRIES; retry; retry--) {\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.data.raw.data[i]);\n\t\tif ((error = mcd_getresult(sc, &mbx->res)) == 0)\n\t\t\tbreak;\n\t\tif (error == EINVAL)\n\t\t\treturn error;\n\t}\n\tif (!retry)\n\t\treturn error;\n\tif (diskin && (sc->flags & MCDF_LOADED) == 0)\n\t\treturn EIO;\n\n\treturn 0;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MCD_RETRIES\t3",
            "#define\tMCDF_LOADED\t0x10\t/* parameters loaded */"
          ],
          "globals_used": [
            "int mcd_getresult",
            "int mcd_send"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MCD_RETRIES\t3\n#define\tMCDF_LOADED\t0x10\t/* parameters loaded */\n\nint mcd_getresult;\nint mcd_send;\n\nint\nmcd_send(sc, mbx, diskin)\n\tstruct mcd_softc *sc;\n\tstruct mcd_mbox *mbx;\n\tint diskin;\n{\n\tint retry, i, error;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\t\n\tif (sc->debug) {\n\t\tprintf(\"%s: mcd_send: %d %02x\", sc->sc_dev.dv_xname,\n\t\t    mbx->cmd.length, (u_int)mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tprintf(\" %02x\", (u_int)mbx->cmd.data.raw.data[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tfor (retry = MCD_RETRIES; retry; retry--) {\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.data.raw.data[i]);\n\t\tif ((error = mcd_getresult(sc, &mbx->res)) == 0)\n\t\t\tbreak;\n\t\tif (error == EINVAL)\n\t\t\treturn error;\n\t}\n\tif (!retry)\n\t\treturn error;\n\tif (diskin && (sc->flags & MCDF_LOADED) == 0)\n\t\treturn EIO;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mcd_soft_reset",
          "args": [
            "sc"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_soft_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1285-1296",
          "snippet": "void\nmcd_soft_reset(sc)\n\tstruct mcd_softc *sc;\n{\n\n\tsc->debug = 0;\n\tsc->flags = 0;\n\tsc->lastmode = MCD_MD_UNKNOWN;\n\tsc->lastupc = MCD_UPC_UNKNOWN;\n\tsc->audio_status = CD_AS_AUDIO_INVALID;\n\tbus_space_write_1(sc->sc_iot, sc->sc_ioh, MCD_CTL2, 0x0c); /* XXX */\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tMCD_UPC_UNKNOWN\t-1",
            "#define\tMCD_MD_UNKNOWN\t-1"
          ],
          "globals_used": [
            "void mcd_soft_reset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tMCD_UPC_UNKNOWN\t-1\n#define\tMCD_MD_UNKNOWN\t-1\n\nvoid mcd_soft_reset;\n\nvoid\nmcd_soft_reset(sc)\n\tstruct mcd_softc *sc;\n{\n\n\tsc->debug = 0;\n\tsc->flags = 0;\n\tsc->lastmode = MCD_MD_UNKNOWN;\n\tsc->lastupc = MCD_UPC_UNKNOWN;\n\tsc->audio_status = CD_AS_AUDIO_INVALID;\n\tbus_space_write_1(sc->sc_iot, sc->sc_ioh, MCD_CTL2, 0x0c); /* XXX */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint mcd_send;\nvoid mcd_soft_reset;\nint mcd_hard_reset;\n\nint\nmcd_hard_reset(sc)\n\tstruct mcd_softc *sc;\n{\n\tstruct mcd_mbox mbx;\n\n\tmcd_soft_reset(sc);\n\n\tmbx.cmd.opcode = MCD_CMDRESET;\n\tmbx.cmd.length = 0;\n\tmbx.res.length = 0;\n\treturn mcd_send(sc, &mbx, 0);\n}"
  },
  {
    "function_name": "mcd_soft_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
    "lines": "1285-1296",
    "snippet": "void\nmcd_soft_reset(sc)\n\tstruct mcd_softc *sc;\n{\n\n\tsc->debug = 0;\n\tsc->flags = 0;\n\tsc->lastmode = MCD_MD_UNKNOWN;\n\tsc->lastupc = MCD_UPC_UNKNOWN;\n\tsc->audio_status = CD_AS_AUDIO_INVALID;\n\tbus_space_write_1(sc->sc_iot, sc->sc_ioh, MCD_CTL2, 0x0c); /* XXX */\n}",
    "includes": [
      "#include <lib/libkern/libkern.h>",
      "#include <dev/isa/opti.h>",
      "#include <dev/isa/mcdreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/errno.h>",
      "#include <sys/cdio.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/uio.h>",
      "#include <sys/stat.h>",
      "#include <sys/buf.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tMCD_UPC_UNKNOWN\t-1",
      "#define\tMCD_MD_UNKNOWN\t-1"
    ],
    "globals_used": [
      "void mcd_soft_reset"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "sc->sc_iot",
            "sc->sc_ioh",
            "MCD_CTL2",
            "0x0c"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tMCD_UPC_UNKNOWN\t-1\n#define\tMCD_MD_UNKNOWN\t-1\n\nvoid mcd_soft_reset;\n\nvoid\nmcd_soft_reset(sc)\n\tstruct mcd_softc *sc;\n{\n\n\tsc->debug = 0;\n\tsc->flags = 0;\n\tsc->lastmode = MCD_MD_UNKNOWN;\n\tsc->lastupc = MCD_UPC_UNKNOWN;\n\tsc->audio_status = CD_AS_AUDIO_INVALID;\n\tbus_space_write_1(sc->sc_iot, sc->sc_ioh, MCD_CTL2, 0x0c); /* XXX */\n}"
  },
  {
    "function_name": "mcdintr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
    "lines": "1126-1283",
    "snippet": "int\nmcdintr(arg)\n\tvoid *arg;\n{\n\tstruct mcd_softc *sc = arg;\n\tstruct mcd_mbx *mbx = &sc->mbx;\n\tstruct buf *bp = mbx->bp;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tint i;\n\tu_char x;\n\tbcd_t msf[3];\n\n\tswitch (mbx->state) {\n\tcase MCD_S_IDLE:\n\t\treturn 0;\n\n\tcase MCD_S_BEGIN:\n\ttryagain:\n\t\tif (mbx->mode == sc->lastmode)\n\t\t\tgoto firstblock;\n\n\t\tsc->lastmode = MCD_MD_UNKNOWN;\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, MCD_CMDSETMODE);\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->mode);\n\n\t\tmbx->count = RDELAY_WAITMODE;\n\t\tmbx->state = MCD_S_WAITMODE;\n\n\tcase MCD_S_WAITMODE:\n\t\tuntimeout(mcd_pseudointr, sc);\n\t\tfor (i = 20; i; i--) {\n\t\t\tx = bus_space_read_1(iot, ioh, MCD_XFER);\n\t\t\tif ((x & MCD_XF_STATUSUNAVAIL) == 0)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (i == 0)\n\t\t\tgoto hold;\n\t\tsc->status = bus_space_read_1(iot, ioh, MCD_STATUS);\n\t\tmcd_setflags(sc);\n\t\tif ((sc->flags & MCDF_LOADED) == 0)\n\t\t\tgoto changed;\n\t\tMCD_TRACE(\"doread: got WAITMODE delay=%d\\n\",\n\t\t    RDELAY_WAITMODE - mbx->count, 0, 0, 0);\n\n\t\tsc->lastmode = mbx->mode;\n\n\tfirstblock:\n\t\tMCD_TRACE(\"doread: read blkno=%d for bp=0x%x\\n\", mbx->blkno,\n\t\t    bp, 0, 0);\n\n\t\t/* Build parameter block. */\n\t\thsg2msf(mbx->blkno, msf);\n\n\t\t/* Send the read command. */\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, sc->readcmd);\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, msf[0]);\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, msf[1]);\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, msf[2]);\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, 0);\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, 0);\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->nblk);\n\n\t\tmbx->count = RDELAY_WAITREAD;\n\t\tmbx->state = MCD_S_WAITREAD;\n\n\tcase MCD_S_WAITREAD:\n\t\tuntimeout(mcd_pseudointr, sc);\n\tnextblock:\n\tloop:\n\t\tfor (i = 20; i; i--) {\n\t\t\tx = bus_space_read_1(iot, ioh, MCD_XFER);\n\t\t\tif ((x & MCD_XF_DATAUNAVAIL) == 0)\n\t\t\t\tgoto gotblock;\n\t\t\tif ((x & MCD_XF_STATUSUNAVAIL) == 0)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (i == 0)\n\t\t\tgoto hold;\n\t\tsc->status = bus_space_read_1(iot, ioh, MCD_STATUS);\n\t\tmcd_setflags(sc);\n\t\tif ((sc->flags & MCDF_LOADED) == 0)\n\t\t\tgoto changed;\n#if 0\n\t\tprintf(\"%s: got status byte %02x during read\\n\",\n\t\t    sc->sc_dev.dv_xname, (u_int)sc->status);\n#endif\n\t\tgoto loop;\n\n\tgotblock:\n\t\tMCD_TRACE(\"doread: got data delay=%d\\n\",\n\t\t    RDELAY_WAITREAD - mbx->count, 0, 0, 0);\n\n\t\t/* Data is ready. */\n\t\tbus_space_write_1(iot, ioh, MCD_CTL2, 0x04);\t/* XXX */\n\t\tbus_space_read_multi_1(iot, ioh, MCD_RDATA,\n\t\t    bp->b_data + mbx->skip, mbx->sz);\n\t\tbus_space_write_1(iot, ioh, MCD_CTL2, 0x0c);\t/* XXX */\n\t\tmbx->blkno += 1;\n\t\tmbx->skip += mbx->sz;\n\t\tif (--mbx->nblk > 0)\n\t\t\tgoto nextblock;\n\n\t\tmbx->state = MCD_S_IDLE;\n\n\t\t/* Return buffer. */\n\t\tbp->b_resid = 0;\n\t\tdisk_unbusy(&sc->sc_dk, bp->b_bcount);\n\t\tbiodone(bp);\n\n\t\tmcdstart(sc);\n\t\treturn 1;\n\n\thold:\n\t\tif (mbx->count-- < 0) {\n\t\t\tprintf(\"%s: timeout in state %d\",\n\t\t\t    sc->sc_dev.dv_xname, mbx->state);\n\t\t\tgoto readerr;\n\t\t}\n\n#if 0\n\t\tprintf(\"%s: sleep in state %d\\n\", sc->sc_dev.dv_xname,\n\t\t    mbx->state);\n#endif\n\t\ttimeout(mcd_pseudointr, sc, hz / 100);\n\t\treturn -1;\n\t}\n\nreaderr:\n\tif (mbx->retry-- > 0) {\n\t\tprintf(\"; retrying\\n\");\n\t\tgoto tryagain;\n\t} else\n\t\tprintf(\"; giving up\\n\");\n\nchanged:\n\t/* Invalidate the buffer. */\n\tbp->b_flags |= B_ERROR;\n\tbp->b_resid = bp->b_bcount - mbx->skip;\n\tdisk_unbusy(&sc->sc_dk, (bp->b_bcount - bp->b_resid));\n\tbiodone(bp);\n\n\tmcdstart(sc);\n\treturn -1;\n\n#ifdef notyet\n\tprintf(\"%s: unit timeout; resetting\\n\", sc->sc_dev.dv_xname);\n\tbus_space_write_1(iot, ioh, MCD_RESET, MCD_CMDRESET);\n\tdelay(300000);\n\t(void) mcd_getstat(sc, 1);\n\t(void) mcd_getstat(sc, 1);\n\t/*sc->status &= ~MCD_ST_DSKCHNG; */\n\tsc->debug = 1; /* preventive set debug mode */\n#endif\n}",
    "includes": [
      "#include <lib/libkern/libkern.h>",
      "#include <dev/isa/opti.h>",
      "#include <dev/isa/mcdreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/errno.h>",
      "#include <sys/cdio.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/uio.h>",
      "#include <sys/stat.h>",
      "#include <sys/buf.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define RDELAY_WAITREAD\t800",
      "#define RDELAY_WAITMODE\t300",
      "#define\tMCD_MD_UNKNOWN\t-1",
      "#define\tMCDF_LOADED\t0x10\t/* parameters loaded */",
      "#define MCD_S_WAITREAD\t3",
      "#define MCD_S_WAITMODE\t2",
      "#define MCD_S_BEGIN\t1",
      "#define\tMCD_S_IDLE\t0"
    ],
    "globals_used": [
      "static void hsg2msf",
      "__P((int, bcd_t *));",
      "int mcd_getstat",
      "void mcd_setflags",
      "int mcdintr",
      "void\tmcdstart",
      "void\tmcd_pseudointr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mcd_getstat",
          "args": [
            "sc",
            "1"
          ],
          "line": 1279
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_getstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "951-961",
          "snippet": "int\nmcd_getstat(sc)\n\tstruct mcd_softc *sc;\n{\n\tstruct mcd_mbox mbx;\n\n\tmbx.cmd.opcode = MCD_CMDGETSTAT;\n\tmbx.cmd.length = 0;\n\tmbx.res.length = 0;\n\treturn mcd_send(sc, &mbx, 1);\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int mcd_getstat",
            "int mcd_send"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint mcd_getstat;\nint mcd_send;\n\nint\nmcd_getstat(sc)\n\tstruct mcd_softc *sc;\n{\n\tstruct mcd_mbox mbx;\n\n\tmbx.cmd.opcode = MCD_CMDGETSTAT;\n\tmbx.cmd.length = 0;\n\tmbx.res.length = 0;\n\treturn mcd_send(sc, &mbx, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "300000"
          ],
          "line": 1277
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "MCD_RESET",
            "MCD_CMDRESET"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: unit timeout; resetting\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mcdstart",
          "args": [
            "sc"
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "mcdstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "516-572",
          "snippet": "void\nmcdstart(sc)\n\tstruct mcd_softc *sc;\n{\n\tstruct buf *bp, *dp = &sc->buf_queue;\n\tint s;\n\t\nloop:\n\ts = splbio();\n\n\tbp = dp->b_actf;\n\tif (bp == NULL) {\n\t\t/* Nothing to do. */\n\t\tdp->b_active = 0;\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Block found to process; dequeue. */\n\tMCD_TRACE(\"start: found block bp=0x%x\\n\", bp, 0, 0, 0);\n\tdp->b_actf = bp->b_actf;\n\tsplx(s);\n\n\t/* Changed media? */\n\tif ((sc->flags & MCDF_LOADED) == 0) {\n\t\tMCD_TRACE(\"start: drive not valid\\n\", 0, 0, 0, 0);\n\t\tbp->b_error = EIO;\n\t\tbp->b_flags |= B_ERROR;\n\t\tbiodone(bp);\n\t\tgoto loop;\n\t}\n\n\tdp->b_active = 1;\n\n\t/* Instrumentation. */\n\ts = splbio();\n\tdisk_busy(&sc->sc_dk);\n\tsplx(s);\n\n\tsc->mbx.retry = MCD_RDRETRIES;\n\tsc->mbx.bp = bp;\n\tsc->mbx.blkno = bp->b_blkno / (sc->blksize / DEV_BSIZE);\n\tif (MCDPART(bp->b_dev) != RAW_PART) {\n\t\tstruct partition *p;\n\t\tp = &sc->sc_dk.dk_label->d_partitions[MCDPART(bp->b_dev)];\n\t\tsc->mbx.blkno += p->p_offset;\n\t}\n\tsc->mbx.nblk = bp->b_bcount / sc->blksize;\n\tsc->mbx.sz = sc->blksize;\n\tsc->mbx.skip = 0;\n\tsc->mbx.state = MCD_S_BEGIN;\n\tsc->mbx.mode = MCD_MD_COOKED;\n\n\ts = splbio();\n\t(void) mcdintr(sc);\n\tsplx(s);\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MCD_RDRETRIES\t3",
            "#define\tMCDF_LOADED\t0x10\t/* parameters loaded */",
            "#define MCD_S_BEGIN\t1"
          ],
          "globals_used": [
            "int mcdintr",
            "void\tmcdstart"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MCD_RDRETRIES\t3\n#define\tMCDF_LOADED\t0x10\t/* parameters loaded */\n#define MCD_S_BEGIN\t1\n\nint mcdintr;\nvoid\tmcdstart;\n\nvoid\nmcdstart(sc)\n\tstruct mcd_softc *sc;\n{\n\tstruct buf *bp, *dp = &sc->buf_queue;\n\tint s;\n\t\nloop:\n\ts = splbio();\n\n\tbp = dp->b_actf;\n\tif (bp == NULL) {\n\t\t/* Nothing to do. */\n\t\tdp->b_active = 0;\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Block found to process; dequeue. */\n\tMCD_TRACE(\"start: found block bp=0x%x\\n\", bp, 0, 0, 0);\n\tdp->b_actf = bp->b_actf;\n\tsplx(s);\n\n\t/* Changed media? */\n\tif ((sc->flags & MCDF_LOADED) == 0) {\n\t\tMCD_TRACE(\"start: drive not valid\\n\", 0, 0, 0, 0);\n\t\tbp->b_error = EIO;\n\t\tbp->b_flags |= B_ERROR;\n\t\tbiodone(bp);\n\t\tgoto loop;\n\t}\n\n\tdp->b_active = 1;\n\n\t/* Instrumentation. */\n\ts = splbio();\n\tdisk_busy(&sc->sc_dk);\n\tsplx(s);\n\n\tsc->mbx.retry = MCD_RDRETRIES;\n\tsc->mbx.bp = bp;\n\tsc->mbx.blkno = bp->b_blkno / (sc->blksize / DEV_BSIZE);\n\tif (MCDPART(bp->b_dev) != RAW_PART) {\n\t\tstruct partition *p;\n\t\tp = &sc->sc_dk.dk_label->d_partitions[MCDPART(bp->b_dev)];\n\t\tsc->mbx.blkno += p->p_offset;\n\t}\n\tsc->mbx.nblk = bp->b_bcount / sc->blksize;\n\tsc->mbx.sz = sc->blksize;\n\tsc->mbx.skip = 0;\n\tsc->mbx.state = MCD_S_BEGIN;\n\tsc->mbx.mode = MCD_MD_COOKED;\n\n\ts = splbio();\n\t(void) mcdintr(sc);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "biodone",
          "args": [
            "bp"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_unbusy",
          "args": [
            "&sc->sc_dk",
            "(bp->b_bcount - bp->b_resid)"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "mcd_pseudointr",
            "sc",
            "hz / 100"
          ],
          "line": 1253
        },
        "resolved": true,
        "details": {
          "function_name": "bt_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/bt.c",
          "lines": "1300-1345",
          "snippet": "void\nbt_timeout(arg)\n\tvoid *arg;\n{\n\tstruct bt_ccb *ccb = arg;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct bt_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n#ifdef BTDIAG\n\t/*\n\t * If the ccb's mbx is not free, then the board has gone Far East?\n\t */\n\tbt_collect_mbo(sc);\n\tif (ccb->flags & CCB_SENDING) {\n\t\tprintf(\"%s: not taking commands!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n#endif\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (ccb->flags & CCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tccb->xs->error = XS_TIMEOUT;\n\t\tccb->timeout = BT_ABORT_TIMEOUT;\n\t\tccb->flags |= CCB_ABORT;\n\t\tbt_queue_ccb(sc, ccb);\n\t}\n\n\tsplx(s);\n}",
          "includes": [
            "#include \"bt.h\"",
            "#include \"aha.h\"",
            "#include <dev/isa/btreg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/pio.h>",
            "#include <machine/intr.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tBT_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */"
          ],
          "globals_used": [
            "bt_finish_ccbs __P((struct bt_softc *));",
            "bt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "bt_init_ccb __P((struct bt_softc *, struct bt_ccb *));",
            "void bt_queue_ccb",
            "void bt_collect_mbo",
            "void bt_timeout",
            "struct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;",
            "int flags;",
            "struct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bt.h\"\n#include \"aha.h\"\n#include <dev/isa/btreg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/pio.h>\n#include <machine/intr.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tBT_ABORT_TIMEOUT\t2000\t/* time to wait for abort (mSec) */\n\nbt_finish_ccbs __P((struct bt_softc *));\nbt_reset_ccb __P((struct bt_softc *, struct bt_ccb *));\nbt_init_ccb __P((struct bt_softc *, struct bt_ccb *));\nvoid bt_queue_ccb;\nvoid bt_collect_mbo;\nvoid bt_timeout;\nstruct bt_ccb *\nbt_get_ccb(sc, flags)\n\tstruct bt_softc *sc;\nint flags;\nstruct bt_ccb *\nbt_ccb_phys_kv(sc, ccb_phys)\n\tstruct bt_softc *sc;\n\nvoid\nbt_timeout(arg)\n\tvoid *arg;\n{\n\tstruct bt_ccb *ccb = arg;\n\tstruct scsi_xfer *xs = ccb->xs;\n\tstruct scsi_link *sc_link = xs->sc_link;\n\tstruct bt_softc *sc = sc_link->adapter_softc;\n\tint s;\n\n\tsc_print_addr(sc_link);\n\tprintf(\"timed out\");\n\n\ts = splbio();\n\n#ifdef BTDIAG\n\t/*\n\t * If the ccb's mbx is not free, then the board has gone Far East?\n\t */\n\tbt_collect_mbo(sc);\n\tif (ccb->flags & CCB_SENDING) {\n\t\tprintf(\"%s: not taking commands!\\n\", sc->sc_dev.dv_xname);\n\t\tDebugger();\n\t}\n#endif\n\n\t/*\n\t * If it has been through before, then\n\t * a previous abort has failed, don't\n\t * try abort again\n\t */\n\tif (ccb->flags & CCB_ABORT) {\n\t\t/* abort timed out */\n\t\tprintf(\" AGAIN\\n\");\n\t\t/* XXX Must reset! */\n\t} else {\n\t\t/* abort the operation that has timed out */\n\t\tprintf(\"\\n\");\n\t\tccb->xs->error = XS_TIMEOUT;\n\t\tccb->timeout = BT_ABORT_TIMEOUT;\n\t\tccb->flags |= CCB_ABORT;\n\t\tbt_queue_ccb(sc, ccb);\n\t}\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "biodone",
          "args": [
            "bp"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_unbusy",
          "args": [
            "&sc->sc_dk",
            "bp->b_bcount"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "MCD_CTL2",
            "0x0c"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_multi_1",
          "args": [
            "iot",
            "ioh",
            "MCD_RDATA",
            "bp->b_data + mbx->skip",
            "mbx->sz"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "MCD_CTL2",
            "0x04"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCD_TRACE",
          "args": [
            "\"doread: got data delay=%d\\n\"",
            "RDELAY_WAITREAD - mbx->count",
            "0",
            "0",
            "0"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mcd_setflags",
          "args": [
            "sc"
          ],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_setflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1019-1042",
          "snippet": "void\nmcd_setflags(sc)\n\tstruct mcd_softc *sc;\n{\n\n\t/* Check flags. */\n\tif ((sc->flags & MCDF_LOADED) != 0 &&\n\t    (sc->status & (MCD_ST_DSKCHNG | MCD_ST_DSKIN | MCD_ST_DOOROPEN)) !=\n\t    MCD_ST_DSKIN) {\n\t\tif ((sc->status & MCD_ST_DOOROPEN) != 0)\n\t\t\tprintf(\"%s: door open\\n\", sc->sc_dev.dv_xname);\n\t\telse if ((sc->status & MCD_ST_DSKIN) == 0)\n\t\t\tprintf(\"%s: no disk present\\n\", sc->sc_dev.dv_xname);\n\t\telse if ((sc->status & MCD_ST_DSKCHNG) != 0)\n\t\t\tprintf(\"%s: media change\\n\", sc->sc_dev.dv_xname);\n\t\tsc->flags &= ~MCDF_LOADED;\n\t}\n\n\tif ((sc->status & MCD_ST_AUDIOBSY) != 0)\n\t\tsc->audio_status = CD_AS_PLAY_IN_PROGRESS;\n\telse if (sc->audio_status == CD_AS_PLAY_IN_PROGRESS ||\n\t\t sc->audio_status == CD_AS_AUDIO_INVALID)\n\t\tsc->audio_status = CD_AS_PLAY_COMPLETED;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tMCDF_LOADED\t0x10\t/* parameters loaded */"
          ],
          "globals_used": [
            "void mcd_setflags"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tMCDF_LOADED\t0x10\t/* parameters loaded */\n\nvoid mcd_setflags;\n\nvoid\nmcd_setflags(sc)\n\tstruct mcd_softc *sc;\n{\n\n\t/* Check flags. */\n\tif ((sc->flags & MCDF_LOADED) != 0 &&\n\t    (sc->status & (MCD_ST_DSKCHNG | MCD_ST_DSKIN | MCD_ST_DOOROPEN)) !=\n\t    MCD_ST_DSKIN) {\n\t\tif ((sc->status & MCD_ST_DOOROPEN) != 0)\n\t\t\tprintf(\"%s: door open\\n\", sc->sc_dev.dv_xname);\n\t\telse if ((sc->status & MCD_ST_DSKIN) == 0)\n\t\t\tprintf(\"%s: no disk present\\n\", sc->sc_dev.dv_xname);\n\t\telse if ((sc->status & MCD_ST_DSKCHNG) != 0)\n\t\t\tprintf(\"%s: media change\\n\", sc->sc_dev.dv_xname);\n\t\tsc->flags &= ~MCDF_LOADED;\n\t}\n\n\tif ((sc->status & MCD_ST_AUDIOBSY) != 0)\n\t\tsc->audio_status = CD_AS_PLAY_IN_PROGRESS;\n\telse if (sc->audio_status == CD_AS_PLAY_IN_PROGRESS ||\n\t\t sc->audio_status == CD_AS_AUDIO_INVALID)\n\t\tsc->audio_status = CD_AS_PLAY_COMPLETED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "MCD_STATUS"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "MCD_XFER"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "mcd_pseudointr",
            "sc"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "MCD_COMMAND",
            "mbx->nblk"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "MCD_COMMAND",
            "0"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "MCD_COMMAND",
            "0"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "MCD_COMMAND",
            "msf[2]"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "MCD_COMMAND",
            "msf[1]"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "MCD_COMMAND",
            "msf[0]"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "MCD_COMMAND",
            "sc->readcmd"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hsg2msf",
          "args": [
            "mbx->blkno",
            "msf"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "hsg2msf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1079-1091",
          "snippet": "static void\nhsg2msf(hsg, msf)\n\tint hsg;\n\tbcd_t *msf;\n{\n\n\thsg += 150;\n\tF_msf(msf) = bin2bcd(hsg % 75);\n\thsg /= 75;\n\tS_msf(msf) = bin2bcd(hsg % 60);\n\thsg /= 60;\n\tM_msf(msf) = bin2bcd(hsg);\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void hsg2msf",
            "__P((int, bcd_t *));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void hsg2msf;\n__P((int, bcd_t *));\n\nstatic void\nhsg2msf(hsg, msf)\n\tint hsg;\n\tbcd_t *msf;\n{\n\n\thsg += 150;\n\tF_msf(msf) = bin2bcd(hsg % 75);\n\thsg /= 75;\n\tS_msf(msf) = bin2bcd(hsg % 60);\n\thsg /= 60;\n\tM_msf(msf) = bin2bcd(hsg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MCD_TRACE",
          "args": [
            "\"doread: read blkno=%d for bp=0x%x\\n\"",
            "mbx->blkno",
            "bp",
            "0",
            "0"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCD_TRACE",
          "args": [
            "\"doread: got WAITMODE delay=%d\\n\"",
            "RDELAY_WAITMODE - mbx->count",
            "0",
            "0",
            "0"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "MCD_STATUS"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "MCD_XFER"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "mcd_pseudointr",
            "sc"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "MCD_COMMAND",
            "mbx->mode"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "MCD_COMMAND",
            "MCD_CMDSETMODE"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define RDELAY_WAITREAD\t800\n#define RDELAY_WAITMODE\t300\n#define\tMCD_MD_UNKNOWN\t-1\n#define\tMCDF_LOADED\t0x10\t/* parameters loaded */\n#define MCD_S_WAITREAD\t3\n#define MCD_S_WAITMODE\t2\n#define MCD_S_BEGIN\t1\n#define\tMCD_S_IDLE\t0\n\nstatic void hsg2msf;\n__P((int, bcd_t *));\nint mcd_getstat;\nvoid mcd_setflags;\nint mcdintr;\nvoid\tmcdstart;\nvoid\tmcd_pseudointr;\n\nint\nmcdintr(arg)\n\tvoid *arg;\n{\n\tstruct mcd_softc *sc = arg;\n\tstruct mcd_mbx *mbx = &sc->mbx;\n\tstruct buf *bp = mbx->bp;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tint i;\n\tu_char x;\n\tbcd_t msf[3];\n\n\tswitch (mbx->state) {\n\tcase MCD_S_IDLE:\n\t\treturn 0;\n\n\tcase MCD_S_BEGIN:\n\ttryagain:\n\t\tif (mbx->mode == sc->lastmode)\n\t\t\tgoto firstblock;\n\n\t\tsc->lastmode = MCD_MD_UNKNOWN;\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, MCD_CMDSETMODE);\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->mode);\n\n\t\tmbx->count = RDELAY_WAITMODE;\n\t\tmbx->state = MCD_S_WAITMODE;\n\n\tcase MCD_S_WAITMODE:\n\t\tuntimeout(mcd_pseudointr, sc);\n\t\tfor (i = 20; i; i--) {\n\t\t\tx = bus_space_read_1(iot, ioh, MCD_XFER);\n\t\t\tif ((x & MCD_XF_STATUSUNAVAIL) == 0)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (i == 0)\n\t\t\tgoto hold;\n\t\tsc->status = bus_space_read_1(iot, ioh, MCD_STATUS);\n\t\tmcd_setflags(sc);\n\t\tif ((sc->flags & MCDF_LOADED) == 0)\n\t\t\tgoto changed;\n\t\tMCD_TRACE(\"doread: got WAITMODE delay=%d\\n\",\n\t\t    RDELAY_WAITMODE - mbx->count, 0, 0, 0);\n\n\t\tsc->lastmode = mbx->mode;\n\n\tfirstblock:\n\t\tMCD_TRACE(\"doread: read blkno=%d for bp=0x%x\\n\", mbx->blkno,\n\t\t    bp, 0, 0);\n\n\t\t/* Build parameter block. */\n\t\thsg2msf(mbx->blkno, msf);\n\n\t\t/* Send the read command. */\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, sc->readcmd);\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, msf[0]);\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, msf[1]);\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, msf[2]);\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, 0);\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, 0);\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->nblk);\n\n\t\tmbx->count = RDELAY_WAITREAD;\n\t\tmbx->state = MCD_S_WAITREAD;\n\n\tcase MCD_S_WAITREAD:\n\t\tuntimeout(mcd_pseudointr, sc);\n\tnextblock:\n\tloop:\n\t\tfor (i = 20; i; i--) {\n\t\t\tx = bus_space_read_1(iot, ioh, MCD_XFER);\n\t\t\tif ((x & MCD_XF_DATAUNAVAIL) == 0)\n\t\t\t\tgoto gotblock;\n\t\t\tif ((x & MCD_XF_STATUSUNAVAIL) == 0)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (i == 0)\n\t\t\tgoto hold;\n\t\tsc->status = bus_space_read_1(iot, ioh, MCD_STATUS);\n\t\tmcd_setflags(sc);\n\t\tif ((sc->flags & MCDF_LOADED) == 0)\n\t\t\tgoto changed;\n#if 0\n\t\tprintf(\"%s: got status byte %02x during read\\n\",\n\t\t    sc->sc_dev.dv_xname, (u_int)sc->status);\n#endif\n\t\tgoto loop;\n\n\tgotblock:\n\t\tMCD_TRACE(\"doread: got data delay=%d\\n\",\n\t\t    RDELAY_WAITREAD - mbx->count, 0, 0, 0);\n\n\t\t/* Data is ready. */\n\t\tbus_space_write_1(iot, ioh, MCD_CTL2, 0x04);\t/* XXX */\n\t\tbus_space_read_multi_1(iot, ioh, MCD_RDATA,\n\t\t    bp->b_data + mbx->skip, mbx->sz);\n\t\tbus_space_write_1(iot, ioh, MCD_CTL2, 0x0c);\t/* XXX */\n\t\tmbx->blkno += 1;\n\t\tmbx->skip += mbx->sz;\n\t\tif (--mbx->nblk > 0)\n\t\t\tgoto nextblock;\n\n\t\tmbx->state = MCD_S_IDLE;\n\n\t\t/* Return buffer. */\n\t\tbp->b_resid = 0;\n\t\tdisk_unbusy(&sc->sc_dk, bp->b_bcount);\n\t\tbiodone(bp);\n\n\t\tmcdstart(sc);\n\t\treturn 1;\n\n\thold:\n\t\tif (mbx->count-- < 0) {\n\t\t\tprintf(\"%s: timeout in state %d\",\n\t\t\t    sc->sc_dev.dv_xname, mbx->state);\n\t\t\tgoto readerr;\n\t\t}\n\n#if 0\n\t\tprintf(\"%s: sleep in state %d\\n\", sc->sc_dev.dv_xname,\n\t\t    mbx->state);\n#endif\n\t\ttimeout(mcd_pseudointr, sc, hz / 100);\n\t\treturn -1;\n\t}\n\nreaderr:\n\tif (mbx->retry-- > 0) {\n\t\tprintf(\"; retrying\\n\");\n\t\tgoto tryagain;\n\t} else\n\t\tprintf(\"; giving up\\n\");\n\nchanged:\n\t/* Invalidate the buffer. */\n\tbp->b_flags |= B_ERROR;\n\tbp->b_resid = bp->b_bcount - mbx->skip;\n\tdisk_unbusy(&sc->sc_dk, (bp->b_bcount - bp->b_resid));\n\tbiodone(bp);\n\n\tmcdstart(sc);\n\treturn -1;\n\n#ifdef notyet\n\tprintf(\"%s: unit timeout; resetting\\n\", sc->sc_dev.dv_xname);\n\tbus_space_write_1(iot, ioh, MCD_RESET, MCD_CMDRESET);\n\tdelay(300000);\n\t(void) mcd_getstat(sc, 1);\n\t(void) mcd_getstat(sc, 1);\n\t/*sc->status &= ~MCD_ST_DSKCHNG; */\n\tsc->debug = 1; /* preventive set debug mode */\n#endif\n}"
  },
  {
    "function_name": "mcd_pseudointr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
    "lines": "1108-1118",
    "snippet": "void\nmcd_pseudointr(v)\n\tvoid *v;\n{\n\tstruct mcd_softc *sc = v;\n\tint s;\n\n\ts = splbio();\n\t(void) mcdintr(sc);\n\tsplx(s);\n}",
    "includes": [
      "#include <lib/libkern/libkern.h>",
      "#include <dev/isa/opti.h>",
      "#include <dev/isa/mcdreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/errno.h>",
      "#include <sys/cdio.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/uio.h>",
      "#include <sys/stat.h>",
      "#include <sys/buf.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int mcdintr",
      "void\tmcd_pseudointr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mcdintr",
          "args": [
            "sc"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "mcdintr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1126-1283",
          "snippet": "int\nmcdintr(arg)\n\tvoid *arg;\n{\n\tstruct mcd_softc *sc = arg;\n\tstruct mcd_mbx *mbx = &sc->mbx;\n\tstruct buf *bp = mbx->bp;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tint i;\n\tu_char x;\n\tbcd_t msf[3];\n\n\tswitch (mbx->state) {\n\tcase MCD_S_IDLE:\n\t\treturn 0;\n\n\tcase MCD_S_BEGIN:\n\ttryagain:\n\t\tif (mbx->mode == sc->lastmode)\n\t\t\tgoto firstblock;\n\n\t\tsc->lastmode = MCD_MD_UNKNOWN;\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, MCD_CMDSETMODE);\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->mode);\n\n\t\tmbx->count = RDELAY_WAITMODE;\n\t\tmbx->state = MCD_S_WAITMODE;\n\n\tcase MCD_S_WAITMODE:\n\t\tuntimeout(mcd_pseudointr, sc);\n\t\tfor (i = 20; i; i--) {\n\t\t\tx = bus_space_read_1(iot, ioh, MCD_XFER);\n\t\t\tif ((x & MCD_XF_STATUSUNAVAIL) == 0)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (i == 0)\n\t\t\tgoto hold;\n\t\tsc->status = bus_space_read_1(iot, ioh, MCD_STATUS);\n\t\tmcd_setflags(sc);\n\t\tif ((sc->flags & MCDF_LOADED) == 0)\n\t\t\tgoto changed;\n\t\tMCD_TRACE(\"doread: got WAITMODE delay=%d\\n\",\n\t\t    RDELAY_WAITMODE - mbx->count, 0, 0, 0);\n\n\t\tsc->lastmode = mbx->mode;\n\n\tfirstblock:\n\t\tMCD_TRACE(\"doread: read blkno=%d for bp=0x%x\\n\", mbx->blkno,\n\t\t    bp, 0, 0);\n\n\t\t/* Build parameter block. */\n\t\thsg2msf(mbx->blkno, msf);\n\n\t\t/* Send the read command. */\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, sc->readcmd);\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, msf[0]);\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, msf[1]);\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, msf[2]);\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, 0);\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, 0);\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->nblk);\n\n\t\tmbx->count = RDELAY_WAITREAD;\n\t\tmbx->state = MCD_S_WAITREAD;\n\n\tcase MCD_S_WAITREAD:\n\t\tuntimeout(mcd_pseudointr, sc);\n\tnextblock:\n\tloop:\n\t\tfor (i = 20; i; i--) {\n\t\t\tx = bus_space_read_1(iot, ioh, MCD_XFER);\n\t\t\tif ((x & MCD_XF_DATAUNAVAIL) == 0)\n\t\t\t\tgoto gotblock;\n\t\t\tif ((x & MCD_XF_STATUSUNAVAIL) == 0)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (i == 0)\n\t\t\tgoto hold;\n\t\tsc->status = bus_space_read_1(iot, ioh, MCD_STATUS);\n\t\tmcd_setflags(sc);\n\t\tif ((sc->flags & MCDF_LOADED) == 0)\n\t\t\tgoto changed;\n#if 0\n\t\tprintf(\"%s: got status byte %02x during read\\n\",\n\t\t    sc->sc_dev.dv_xname, (u_int)sc->status);\n#endif\n\t\tgoto loop;\n\n\tgotblock:\n\t\tMCD_TRACE(\"doread: got data delay=%d\\n\",\n\t\t    RDELAY_WAITREAD - mbx->count, 0, 0, 0);\n\n\t\t/* Data is ready. */\n\t\tbus_space_write_1(iot, ioh, MCD_CTL2, 0x04);\t/* XXX */\n\t\tbus_space_read_multi_1(iot, ioh, MCD_RDATA,\n\t\t    bp->b_data + mbx->skip, mbx->sz);\n\t\tbus_space_write_1(iot, ioh, MCD_CTL2, 0x0c);\t/* XXX */\n\t\tmbx->blkno += 1;\n\t\tmbx->skip += mbx->sz;\n\t\tif (--mbx->nblk > 0)\n\t\t\tgoto nextblock;\n\n\t\tmbx->state = MCD_S_IDLE;\n\n\t\t/* Return buffer. */\n\t\tbp->b_resid = 0;\n\t\tdisk_unbusy(&sc->sc_dk, bp->b_bcount);\n\t\tbiodone(bp);\n\n\t\tmcdstart(sc);\n\t\treturn 1;\n\n\thold:\n\t\tif (mbx->count-- < 0) {\n\t\t\tprintf(\"%s: timeout in state %d\",\n\t\t\t    sc->sc_dev.dv_xname, mbx->state);\n\t\t\tgoto readerr;\n\t\t}\n\n#if 0\n\t\tprintf(\"%s: sleep in state %d\\n\", sc->sc_dev.dv_xname,\n\t\t    mbx->state);\n#endif\n\t\ttimeout(mcd_pseudointr, sc, hz / 100);\n\t\treturn -1;\n\t}\n\nreaderr:\n\tif (mbx->retry-- > 0) {\n\t\tprintf(\"; retrying\\n\");\n\t\tgoto tryagain;\n\t} else\n\t\tprintf(\"; giving up\\n\");\n\nchanged:\n\t/* Invalidate the buffer. */\n\tbp->b_flags |= B_ERROR;\n\tbp->b_resid = bp->b_bcount - mbx->skip;\n\tdisk_unbusy(&sc->sc_dk, (bp->b_bcount - bp->b_resid));\n\tbiodone(bp);\n\n\tmcdstart(sc);\n\treturn -1;\n\n#ifdef notyet\n\tprintf(\"%s: unit timeout; resetting\\n\", sc->sc_dev.dv_xname);\n\tbus_space_write_1(iot, ioh, MCD_RESET, MCD_CMDRESET);\n\tdelay(300000);\n\t(void) mcd_getstat(sc, 1);\n\t(void) mcd_getstat(sc, 1);\n\t/*sc->status &= ~MCD_ST_DSKCHNG; */\n\tsc->debug = 1; /* preventive set debug mode */\n#endif\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define RDELAY_WAITREAD\t800",
            "#define RDELAY_WAITMODE\t300",
            "#define\tMCD_MD_UNKNOWN\t-1",
            "#define\tMCDF_LOADED\t0x10\t/* parameters loaded */",
            "#define MCD_S_WAITREAD\t3",
            "#define MCD_S_WAITMODE\t2",
            "#define MCD_S_BEGIN\t1",
            "#define\tMCD_S_IDLE\t0"
          ],
          "globals_used": [
            "static void hsg2msf",
            "__P((int, bcd_t *));",
            "int mcd_getstat",
            "void mcd_setflags",
            "int mcdintr",
            "void\tmcdstart",
            "void\tmcd_pseudointr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define RDELAY_WAITREAD\t800\n#define RDELAY_WAITMODE\t300\n#define\tMCD_MD_UNKNOWN\t-1\n#define\tMCDF_LOADED\t0x10\t/* parameters loaded */\n#define MCD_S_WAITREAD\t3\n#define MCD_S_WAITMODE\t2\n#define MCD_S_BEGIN\t1\n#define\tMCD_S_IDLE\t0\n\nstatic void hsg2msf;\n__P((int, bcd_t *));\nint mcd_getstat;\nvoid mcd_setflags;\nint mcdintr;\nvoid\tmcdstart;\nvoid\tmcd_pseudointr;\n\nint\nmcdintr(arg)\n\tvoid *arg;\n{\n\tstruct mcd_softc *sc = arg;\n\tstruct mcd_mbx *mbx = &sc->mbx;\n\tstruct buf *bp = mbx->bp;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tint i;\n\tu_char x;\n\tbcd_t msf[3];\n\n\tswitch (mbx->state) {\n\tcase MCD_S_IDLE:\n\t\treturn 0;\n\n\tcase MCD_S_BEGIN:\n\ttryagain:\n\t\tif (mbx->mode == sc->lastmode)\n\t\t\tgoto firstblock;\n\n\t\tsc->lastmode = MCD_MD_UNKNOWN;\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, MCD_CMDSETMODE);\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->mode);\n\n\t\tmbx->count = RDELAY_WAITMODE;\n\t\tmbx->state = MCD_S_WAITMODE;\n\n\tcase MCD_S_WAITMODE:\n\t\tuntimeout(mcd_pseudointr, sc);\n\t\tfor (i = 20; i; i--) {\n\t\t\tx = bus_space_read_1(iot, ioh, MCD_XFER);\n\t\t\tif ((x & MCD_XF_STATUSUNAVAIL) == 0)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (i == 0)\n\t\t\tgoto hold;\n\t\tsc->status = bus_space_read_1(iot, ioh, MCD_STATUS);\n\t\tmcd_setflags(sc);\n\t\tif ((sc->flags & MCDF_LOADED) == 0)\n\t\t\tgoto changed;\n\t\tMCD_TRACE(\"doread: got WAITMODE delay=%d\\n\",\n\t\t    RDELAY_WAITMODE - mbx->count, 0, 0, 0);\n\n\t\tsc->lastmode = mbx->mode;\n\n\tfirstblock:\n\t\tMCD_TRACE(\"doread: read blkno=%d for bp=0x%x\\n\", mbx->blkno,\n\t\t    bp, 0, 0);\n\n\t\t/* Build parameter block. */\n\t\thsg2msf(mbx->blkno, msf);\n\n\t\t/* Send the read command. */\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, sc->readcmd);\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, msf[0]);\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, msf[1]);\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, msf[2]);\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, 0);\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, 0);\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->nblk);\n\n\t\tmbx->count = RDELAY_WAITREAD;\n\t\tmbx->state = MCD_S_WAITREAD;\n\n\tcase MCD_S_WAITREAD:\n\t\tuntimeout(mcd_pseudointr, sc);\n\tnextblock:\n\tloop:\n\t\tfor (i = 20; i; i--) {\n\t\t\tx = bus_space_read_1(iot, ioh, MCD_XFER);\n\t\t\tif ((x & MCD_XF_DATAUNAVAIL) == 0)\n\t\t\t\tgoto gotblock;\n\t\t\tif ((x & MCD_XF_STATUSUNAVAIL) == 0)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (i == 0)\n\t\t\tgoto hold;\n\t\tsc->status = bus_space_read_1(iot, ioh, MCD_STATUS);\n\t\tmcd_setflags(sc);\n\t\tif ((sc->flags & MCDF_LOADED) == 0)\n\t\t\tgoto changed;\n#if 0\n\t\tprintf(\"%s: got status byte %02x during read\\n\",\n\t\t    sc->sc_dev.dv_xname, (u_int)sc->status);\n#endif\n\t\tgoto loop;\n\n\tgotblock:\n\t\tMCD_TRACE(\"doread: got data delay=%d\\n\",\n\t\t    RDELAY_WAITREAD - mbx->count, 0, 0, 0);\n\n\t\t/* Data is ready. */\n\t\tbus_space_write_1(iot, ioh, MCD_CTL2, 0x04);\t/* XXX */\n\t\tbus_space_read_multi_1(iot, ioh, MCD_RDATA,\n\t\t    bp->b_data + mbx->skip, mbx->sz);\n\t\tbus_space_write_1(iot, ioh, MCD_CTL2, 0x0c);\t/* XXX */\n\t\tmbx->blkno += 1;\n\t\tmbx->skip += mbx->sz;\n\t\tif (--mbx->nblk > 0)\n\t\t\tgoto nextblock;\n\n\t\tmbx->state = MCD_S_IDLE;\n\n\t\t/* Return buffer. */\n\t\tbp->b_resid = 0;\n\t\tdisk_unbusy(&sc->sc_dk, bp->b_bcount);\n\t\tbiodone(bp);\n\n\t\tmcdstart(sc);\n\t\treturn 1;\n\n\thold:\n\t\tif (mbx->count-- < 0) {\n\t\t\tprintf(\"%s: timeout in state %d\",\n\t\t\t    sc->sc_dev.dv_xname, mbx->state);\n\t\t\tgoto readerr;\n\t\t}\n\n#if 0\n\t\tprintf(\"%s: sleep in state %d\\n\", sc->sc_dev.dv_xname,\n\t\t    mbx->state);\n#endif\n\t\ttimeout(mcd_pseudointr, sc, hz / 100);\n\t\treturn -1;\n\t}\n\nreaderr:\n\tif (mbx->retry-- > 0) {\n\t\tprintf(\"; retrying\\n\");\n\t\tgoto tryagain;\n\t} else\n\t\tprintf(\"; giving up\\n\");\n\nchanged:\n\t/* Invalidate the buffer. */\n\tbp->b_flags |= B_ERROR;\n\tbp->b_resid = bp->b_bcount - mbx->skip;\n\tdisk_unbusy(&sc->sc_dk, (bp->b_bcount - bp->b_resid));\n\tbiodone(bp);\n\n\tmcdstart(sc);\n\treturn -1;\n\n#ifdef notyet\n\tprintf(\"%s: unit timeout; resetting\\n\", sc->sc_dev.dv_xname);\n\tbus_space_write_1(iot, ioh, MCD_RESET, MCD_CMDRESET);\n\tdelay(300000);\n\t(void) mcd_getstat(sc, 1);\n\t(void) mcd_getstat(sc, 1);\n\t/*sc->status &= ~MCD_ST_DSKCHNG; */\n\tsc->debug = 1; /* preventive set debug mode */\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint mcdintr;\nvoid\tmcd_pseudointr;\n\nvoid\nmcd_pseudointr(v)\n\tvoid *v;\n{\n\tstruct mcd_softc *sc = v;\n\tint s;\n\n\ts = splbio();\n\t(void) mcdintr(sc);\n\tsplx(s);\n}"
  },
  {
    "function_name": "msf2hsg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
    "lines": "1093-1106",
    "snippet": "static daddr_t\nmsf2hsg(msf, relative)\n\tbcd_t *msf;\n\tint relative;\n{\n\tdaddr_t blkno;\n\n\tblkno = bcd2bin(M_msf(msf)) * 75 * 60 +\n\t\tbcd2bin(S_msf(msf)) * 75 +\n\t\tbcd2bin(F_msf(msf));\n\tif (!relative)\n\t\tblkno -= 150;\n\treturn blkno;\n}",
    "includes": [
      "#include <lib/libkern/libkern.h>",
      "#include <dev/isa/opti.h>",
      "#include <dev/isa/mcdreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/errno.h>",
      "#include <sys/cdio.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/uio.h>",
      "#include <sys/stat.h>",
      "#include <sys/buf.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__P((int, bcd_t *));",
      "static daddr_t msf2hsg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bcd2bin",
          "args": [
            "F_msf(msf)"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F_msf",
          "args": [
            "msf"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcd2bin",
          "args": [
            "S_msf(msf)"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_msf",
          "args": [
            "msf"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcd2bin",
          "args": [
            "M_msf(msf)"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_msf",
          "args": [
            "msf"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n__P((int, bcd_t *));\nstatic daddr_t msf2hsg;\n\nstatic daddr_t\nmsf2hsg(msf, relative)\n\tbcd_t *msf;\n\tint relative;\n{\n\tdaddr_t blkno;\n\n\tblkno = bcd2bin(M_msf(msf)) * 75 * 60 +\n\t\tbcd2bin(S_msf(msf)) * 75 +\n\t\tbcd2bin(F_msf(msf));\n\tif (!relative)\n\t\tblkno -= 150;\n\treturn blkno;\n}"
  },
  {
    "function_name": "hsg2msf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
    "lines": "1079-1091",
    "snippet": "static void\nhsg2msf(hsg, msf)\n\tint hsg;\n\tbcd_t *msf;\n{\n\n\thsg += 150;\n\tF_msf(msf) = bin2bcd(hsg % 75);\n\thsg /= 75;\n\tS_msf(msf) = bin2bcd(hsg % 60);\n\thsg /= 60;\n\tM_msf(msf) = bin2bcd(hsg);\n}",
    "includes": [
      "#include <lib/libkern/libkern.h>",
      "#include <dev/isa/opti.h>",
      "#include <dev/isa/mcdreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/errno.h>",
      "#include <sys/cdio.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/uio.h>",
      "#include <sys/stat.h>",
      "#include <sys/buf.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void hsg2msf",
      "__P((int, bcd_t *));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bin2bcd",
          "args": [
            "hsg"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_msf",
          "args": [
            "msf"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bin2bcd",
          "args": [
            "hsg % 60"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_msf",
          "args": [
            "msf"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bin2bcd",
          "args": [
            "hsg % 75"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F_msf",
          "args": [
            "msf"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void hsg2msf;\n__P((int, bcd_t *));\n\nstatic void\nhsg2msf(hsg, msf)\n\tint hsg;\n\tbcd_t *msf;\n{\n\n\thsg += 150;\n\tF_msf(msf) = bin2bcd(hsg % 75);\n\thsg /= 75;\n\tS_msf(msf) = bin2bcd(hsg % 60);\n\thsg /= 60;\n\tM_msf(msf) = bin2bcd(hsg);\n}"
  },
  {
    "function_name": "mcd_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
    "lines": "1044-1077",
    "snippet": "int\nmcd_send(sc, mbx, diskin)\n\tstruct mcd_softc *sc;\n\tstruct mcd_mbox *mbx;\n\tint diskin;\n{\n\tint retry, i, error;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\t\n\tif (sc->debug) {\n\t\tprintf(\"%s: mcd_send: %d %02x\", sc->sc_dev.dv_xname,\n\t\t    mbx->cmd.length, (u_int)mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tprintf(\" %02x\", (u_int)mbx->cmd.data.raw.data[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tfor (retry = MCD_RETRIES; retry; retry--) {\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.data.raw.data[i]);\n\t\tif ((error = mcd_getresult(sc, &mbx->res)) == 0)\n\t\t\tbreak;\n\t\tif (error == EINVAL)\n\t\t\treturn error;\n\t}\n\tif (!retry)\n\t\treturn error;\n\tif (diskin && (sc->flags & MCDF_LOADED) == 0)\n\t\treturn EIO;\n\n\treturn 0;\n}",
    "includes": [
      "#include <lib/libkern/libkern.h>",
      "#include <dev/isa/opti.h>",
      "#include <dev/isa/mcdreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/errno.h>",
      "#include <sys/cdio.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/uio.h>",
      "#include <sys/stat.h>",
      "#include <sys/buf.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define MCD_RETRIES\t3",
      "#define\tMCDF_LOADED\t0x10\t/* parameters loaded */"
    ],
    "globals_used": [
      "int mcd_getresult",
      "int mcd_send"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mcd_getresult",
          "args": [
            "sc",
            "&mbx->res"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_getresult",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "963-1017",
          "snippet": "int\nmcd_getresult(sc, res)\n\tstruct mcd_softc *sc;\n\tstruct mcd_result *res;\n{\n\tint i, x;\n\n\tif (sc->debug)\n\t\tprintf(\"%s: mcd_getresult: %d\", sc->sc_dev.dv_xname,\n\t\t    res->length);\n\n\tif ((x = mcd_getreply(sc)) < 0) {\n\t\tif (sc->debug)\n\t\t\tprintf(\" timeout\\n\");\n\t\telse if (sc->probe)\n\t\t\tprintf(\"%s: timeout in getresult\\n\", sc->sc_dev.dv_xname);\n\t\treturn EIO;\n\t}\n\tif (sc->debug)\n\t\tprintf(\" %02x\", (u_int)x);\n\tsc->status = x;\n\tmcd_setflags(sc);\n\n\tif ((sc->status & MCD_ST_CMDCHECK) != 0)\n\t\treturn EINVAL;\n\n\tfor (i = 0; i < res->length; i++) {\n\t\tif ((x = mcd_getreply(sc)) < 0) {\n\t\t\tif (sc->debug)\n\t\t\t\tprintf(\" timeout\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"%s: timeout in getresult\\n\", sc->sc_dev.dv_xname);\n\t\t\treturn EIO;\n\t\t}\n\t\tif (sc->debug)\n\t\t\tprintf(\" %02x\", (u_int)x);\n\t\tres->data.raw.data[i] = x;\n\t}\n\n\tif (sc->debug)\n\t\tprintf(\" succeeded\\n\");\n\n#ifdef MCDDEBUG\n\tdelay(10);\n\twhile ((bus_space_read_1(sc->sc_iot, sc->sc_ioh, MCD_XFER) &\n\t    MCD_XF_STATUSUNAVAIL) == 0) {\n\t\tx = bus_space_read_1(sc->sc_iot, sc->sc_ioh, MCD_STATUS);\n\t\tprintf(\"%s: got extra byte %02x during getstatus\\n\",\n\t\t    sc->sc_dev.dv_xname, (u_int)x);\n\t\tdelay(10);\n\t}\n#endif\n\n\treturn 0;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int mcd_getreply",
            "int mcd_getresult",
            "void mcd_setflags"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint mcd_getreply;\nint mcd_getresult;\nvoid mcd_setflags;\n\nint\nmcd_getresult(sc, res)\n\tstruct mcd_softc *sc;\n\tstruct mcd_result *res;\n{\n\tint i, x;\n\n\tif (sc->debug)\n\t\tprintf(\"%s: mcd_getresult: %d\", sc->sc_dev.dv_xname,\n\t\t    res->length);\n\n\tif ((x = mcd_getreply(sc)) < 0) {\n\t\tif (sc->debug)\n\t\t\tprintf(\" timeout\\n\");\n\t\telse if (sc->probe)\n\t\t\tprintf(\"%s: timeout in getresult\\n\", sc->sc_dev.dv_xname);\n\t\treturn EIO;\n\t}\n\tif (sc->debug)\n\t\tprintf(\" %02x\", (u_int)x);\n\tsc->status = x;\n\tmcd_setflags(sc);\n\n\tif ((sc->status & MCD_ST_CMDCHECK) != 0)\n\t\treturn EINVAL;\n\n\tfor (i = 0; i < res->length; i++) {\n\t\tif ((x = mcd_getreply(sc)) < 0) {\n\t\t\tif (sc->debug)\n\t\t\t\tprintf(\" timeout\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"%s: timeout in getresult\\n\", sc->sc_dev.dv_xname);\n\t\t\treturn EIO;\n\t\t}\n\t\tif (sc->debug)\n\t\t\tprintf(\" %02x\", (u_int)x);\n\t\tres->data.raw.data[i] = x;\n\t}\n\n\tif (sc->debug)\n\t\tprintf(\" succeeded\\n\");\n\n#ifdef MCDDEBUG\n\tdelay(10);\n\twhile ((bus_space_read_1(sc->sc_iot, sc->sc_ioh, MCD_XFER) &\n\t    MCD_XF_STATUSUNAVAIL) == 0) {\n\t\tx = bus_space_read_1(sc->sc_iot, sc->sc_ioh, MCD_STATUS);\n\t\tprintf(\"%s: got extra byte %02x during getstatus\\n\",\n\t\t    sc->sc_dev.dv_xname, (u_int)x);\n\t\tdelay(10);\n\t}\n#endif\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "MCD_COMMAND",
            "mbx->cmd.data.raw.data[i]"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "MCD_COMMAND",
            "mbx->cmd.opcode"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MCD_RETRIES\t3\n#define\tMCDF_LOADED\t0x10\t/* parameters loaded */\n\nint mcd_getresult;\nint mcd_send;\n\nint\nmcd_send(sc, mbx, diskin)\n\tstruct mcd_softc *sc;\n\tstruct mcd_mbox *mbx;\n\tint diskin;\n{\n\tint retry, i, error;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\t\n\tif (sc->debug) {\n\t\tprintf(\"%s: mcd_send: %d %02x\", sc->sc_dev.dv_xname,\n\t\t    mbx->cmd.length, (u_int)mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tprintf(\" %02x\", (u_int)mbx->cmd.data.raw.data[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tfor (retry = MCD_RETRIES; retry; retry--) {\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.data.raw.data[i]);\n\t\tif ((error = mcd_getresult(sc, &mbx->res)) == 0)\n\t\t\tbreak;\n\t\tif (error == EINVAL)\n\t\t\treturn error;\n\t}\n\tif (!retry)\n\t\treturn error;\n\tif (diskin && (sc->flags & MCDF_LOADED) == 0)\n\t\treturn EIO;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "mcd_setflags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
    "lines": "1019-1042",
    "snippet": "void\nmcd_setflags(sc)\n\tstruct mcd_softc *sc;\n{\n\n\t/* Check flags. */\n\tif ((sc->flags & MCDF_LOADED) != 0 &&\n\t    (sc->status & (MCD_ST_DSKCHNG | MCD_ST_DSKIN | MCD_ST_DOOROPEN)) !=\n\t    MCD_ST_DSKIN) {\n\t\tif ((sc->status & MCD_ST_DOOROPEN) != 0)\n\t\t\tprintf(\"%s: door open\\n\", sc->sc_dev.dv_xname);\n\t\telse if ((sc->status & MCD_ST_DSKIN) == 0)\n\t\t\tprintf(\"%s: no disk present\\n\", sc->sc_dev.dv_xname);\n\t\telse if ((sc->status & MCD_ST_DSKCHNG) != 0)\n\t\t\tprintf(\"%s: media change\\n\", sc->sc_dev.dv_xname);\n\t\tsc->flags &= ~MCDF_LOADED;\n\t}\n\n\tif ((sc->status & MCD_ST_AUDIOBSY) != 0)\n\t\tsc->audio_status = CD_AS_PLAY_IN_PROGRESS;\n\telse if (sc->audio_status == CD_AS_PLAY_IN_PROGRESS ||\n\t\t sc->audio_status == CD_AS_AUDIO_INVALID)\n\t\tsc->audio_status = CD_AS_PLAY_COMPLETED;\n}",
    "includes": [
      "#include <lib/libkern/libkern.h>",
      "#include <dev/isa/opti.h>",
      "#include <dev/isa/mcdreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/errno.h>",
      "#include <sys/cdio.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/uio.h>",
      "#include <sys/stat.h>",
      "#include <sys/buf.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tMCDF_LOADED\t0x10\t/* parameters loaded */"
    ],
    "globals_used": [
      "void mcd_setflags"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: media change\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tMCDF_LOADED\t0x10\t/* parameters loaded */\n\nvoid mcd_setflags;\n\nvoid\nmcd_setflags(sc)\n\tstruct mcd_softc *sc;\n{\n\n\t/* Check flags. */\n\tif ((sc->flags & MCDF_LOADED) != 0 &&\n\t    (sc->status & (MCD_ST_DSKCHNG | MCD_ST_DSKIN | MCD_ST_DOOROPEN)) !=\n\t    MCD_ST_DSKIN) {\n\t\tif ((sc->status & MCD_ST_DOOROPEN) != 0)\n\t\t\tprintf(\"%s: door open\\n\", sc->sc_dev.dv_xname);\n\t\telse if ((sc->status & MCD_ST_DSKIN) == 0)\n\t\t\tprintf(\"%s: no disk present\\n\", sc->sc_dev.dv_xname);\n\t\telse if ((sc->status & MCD_ST_DSKCHNG) != 0)\n\t\t\tprintf(\"%s: media change\\n\", sc->sc_dev.dv_xname);\n\t\tsc->flags &= ~MCDF_LOADED;\n\t}\n\n\tif ((sc->status & MCD_ST_AUDIOBSY) != 0)\n\t\tsc->audio_status = CD_AS_PLAY_IN_PROGRESS;\n\telse if (sc->audio_status == CD_AS_PLAY_IN_PROGRESS ||\n\t\t sc->audio_status == CD_AS_AUDIO_INVALID)\n\t\tsc->audio_status = CD_AS_PLAY_COMPLETED;\n}"
  },
  {
    "function_name": "mcd_getresult",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
    "lines": "963-1017",
    "snippet": "int\nmcd_getresult(sc, res)\n\tstruct mcd_softc *sc;\n\tstruct mcd_result *res;\n{\n\tint i, x;\n\n\tif (sc->debug)\n\t\tprintf(\"%s: mcd_getresult: %d\", sc->sc_dev.dv_xname,\n\t\t    res->length);\n\n\tif ((x = mcd_getreply(sc)) < 0) {\n\t\tif (sc->debug)\n\t\t\tprintf(\" timeout\\n\");\n\t\telse if (sc->probe)\n\t\t\tprintf(\"%s: timeout in getresult\\n\", sc->sc_dev.dv_xname);\n\t\treturn EIO;\n\t}\n\tif (sc->debug)\n\t\tprintf(\" %02x\", (u_int)x);\n\tsc->status = x;\n\tmcd_setflags(sc);\n\n\tif ((sc->status & MCD_ST_CMDCHECK) != 0)\n\t\treturn EINVAL;\n\n\tfor (i = 0; i < res->length; i++) {\n\t\tif ((x = mcd_getreply(sc)) < 0) {\n\t\t\tif (sc->debug)\n\t\t\t\tprintf(\" timeout\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"%s: timeout in getresult\\n\", sc->sc_dev.dv_xname);\n\t\t\treturn EIO;\n\t\t}\n\t\tif (sc->debug)\n\t\t\tprintf(\" %02x\", (u_int)x);\n\t\tres->data.raw.data[i] = x;\n\t}\n\n\tif (sc->debug)\n\t\tprintf(\" succeeded\\n\");\n\n#ifdef MCDDEBUG\n\tdelay(10);\n\twhile ((bus_space_read_1(sc->sc_iot, sc->sc_ioh, MCD_XFER) &\n\t    MCD_XF_STATUSUNAVAIL) == 0) {\n\t\tx = bus_space_read_1(sc->sc_iot, sc->sc_ioh, MCD_STATUS);\n\t\tprintf(\"%s: got extra byte %02x during getstatus\\n\",\n\t\t    sc->sc_dev.dv_xname, (u_int)x);\n\t\tdelay(10);\n\t}\n#endif\n\n\treturn 0;\n}",
    "includes": [
      "#include <lib/libkern/libkern.h>",
      "#include <dev/isa/opti.h>",
      "#include <dev/isa/mcdreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/errno.h>",
      "#include <sys/cdio.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/uio.h>",
      "#include <sys/stat.h>",
      "#include <sys/buf.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int mcd_getreply",
      "int mcd_getresult",
      "void mcd_setflags"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "10"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: got extra byte %02x during getstatus\\n\"",
            "sc->sc_dev.dv_xname",
            "(u_int)x"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "sc->sc_iot",
            "sc->sc_ioh",
            "MCD_STATUS"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "sc->sc_iot",
            "sc->sc_ioh",
            "MCD_XFER"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mcd_getreply",
          "args": [
            "sc"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_getreply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "929-949",
          "snippet": "int\nmcd_getreply(sc)\n\tstruct mcd_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i;\n\n\t/* Wait until xfer port senses data ready. */\n\tfor (i = DELAY_GETREPLY; i; i--) {\n\t\tif ((bus_space_read_1(iot, ioh, MCD_XFER) &\n\t\t    MCD_XF_STATUSUNAVAIL) == 0)\n\t\t\tbreak;\n\t\tdelay(DELAY_GRANULARITY);\n\t}\n\tif (!i)\n\t\treturn -1;\n\n\t/* Get the data. */\n\treturn bus_space_read_1(iot, ioh, MCD_STATUS);\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DELAY_GETREPLY\t\t100000\t/* 100000 * 25us */",
            "#define\tDELAY_GRANULARITY\t25\t/* 25us */"
          ],
          "globals_used": [
            "int mcd_getreply"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DELAY_GETREPLY\t\t100000\t/* 100000 * 25us */\n#define\tDELAY_GRANULARITY\t25\t/* 25us */\n\nint mcd_getreply;\n\nint\nmcd_getreply(sc)\n\tstruct mcd_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i;\n\n\t/* Wait until xfer port senses data ready. */\n\tfor (i = DELAY_GETREPLY; i; i--) {\n\t\tif ((bus_space_read_1(iot, ioh, MCD_XFER) &\n\t\t    MCD_XF_STATUSUNAVAIL) == 0)\n\t\t\tbreak;\n\t\tdelay(DELAY_GRANULARITY);\n\t}\n\tif (!i)\n\t\treturn -1;\n\n\t/* Get the data. */\n\treturn bus_space_read_1(iot, ioh, MCD_STATUS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mcd_setflags",
          "args": [
            "sc"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_setflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1019-1042",
          "snippet": "void\nmcd_setflags(sc)\n\tstruct mcd_softc *sc;\n{\n\n\t/* Check flags. */\n\tif ((sc->flags & MCDF_LOADED) != 0 &&\n\t    (sc->status & (MCD_ST_DSKCHNG | MCD_ST_DSKIN | MCD_ST_DOOROPEN)) !=\n\t    MCD_ST_DSKIN) {\n\t\tif ((sc->status & MCD_ST_DOOROPEN) != 0)\n\t\t\tprintf(\"%s: door open\\n\", sc->sc_dev.dv_xname);\n\t\telse if ((sc->status & MCD_ST_DSKIN) == 0)\n\t\t\tprintf(\"%s: no disk present\\n\", sc->sc_dev.dv_xname);\n\t\telse if ((sc->status & MCD_ST_DSKCHNG) != 0)\n\t\t\tprintf(\"%s: media change\\n\", sc->sc_dev.dv_xname);\n\t\tsc->flags &= ~MCDF_LOADED;\n\t}\n\n\tif ((sc->status & MCD_ST_AUDIOBSY) != 0)\n\t\tsc->audio_status = CD_AS_PLAY_IN_PROGRESS;\n\telse if (sc->audio_status == CD_AS_PLAY_IN_PROGRESS ||\n\t\t sc->audio_status == CD_AS_AUDIO_INVALID)\n\t\tsc->audio_status = CD_AS_PLAY_COMPLETED;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tMCDF_LOADED\t0x10\t/* parameters loaded */"
          ],
          "globals_used": [
            "void mcd_setflags"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tMCDF_LOADED\t0x10\t/* parameters loaded */\n\nvoid mcd_setflags;\n\nvoid\nmcd_setflags(sc)\n\tstruct mcd_softc *sc;\n{\n\n\t/* Check flags. */\n\tif ((sc->flags & MCDF_LOADED) != 0 &&\n\t    (sc->status & (MCD_ST_DSKCHNG | MCD_ST_DSKIN | MCD_ST_DOOROPEN)) !=\n\t    MCD_ST_DSKIN) {\n\t\tif ((sc->status & MCD_ST_DOOROPEN) != 0)\n\t\t\tprintf(\"%s: door open\\n\", sc->sc_dev.dv_xname);\n\t\telse if ((sc->status & MCD_ST_DSKIN) == 0)\n\t\t\tprintf(\"%s: no disk present\\n\", sc->sc_dev.dv_xname);\n\t\telse if ((sc->status & MCD_ST_DSKCHNG) != 0)\n\t\t\tprintf(\"%s: media change\\n\", sc->sc_dev.dv_xname);\n\t\tsc->flags &= ~MCDF_LOADED;\n\t}\n\n\tif ((sc->status & MCD_ST_AUDIOBSY) != 0)\n\t\tsc->audio_status = CD_AS_PLAY_IN_PROGRESS;\n\telse if (sc->audio_status == CD_AS_PLAY_IN_PROGRESS ||\n\t\t sc->audio_status == CD_AS_AUDIO_INVALID)\n\t\tsc->audio_status = CD_AS_PLAY_COMPLETED;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint mcd_getreply;\nint mcd_getresult;\nvoid mcd_setflags;\n\nint\nmcd_getresult(sc, res)\n\tstruct mcd_softc *sc;\n\tstruct mcd_result *res;\n{\n\tint i, x;\n\n\tif (sc->debug)\n\t\tprintf(\"%s: mcd_getresult: %d\", sc->sc_dev.dv_xname,\n\t\t    res->length);\n\n\tif ((x = mcd_getreply(sc)) < 0) {\n\t\tif (sc->debug)\n\t\t\tprintf(\" timeout\\n\");\n\t\telse if (sc->probe)\n\t\t\tprintf(\"%s: timeout in getresult\\n\", sc->sc_dev.dv_xname);\n\t\treturn EIO;\n\t}\n\tif (sc->debug)\n\t\tprintf(\" %02x\", (u_int)x);\n\tsc->status = x;\n\tmcd_setflags(sc);\n\n\tif ((sc->status & MCD_ST_CMDCHECK) != 0)\n\t\treturn EINVAL;\n\n\tfor (i = 0; i < res->length; i++) {\n\t\tif ((x = mcd_getreply(sc)) < 0) {\n\t\t\tif (sc->debug)\n\t\t\t\tprintf(\" timeout\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"%s: timeout in getresult\\n\", sc->sc_dev.dv_xname);\n\t\t\treturn EIO;\n\t\t}\n\t\tif (sc->debug)\n\t\t\tprintf(\" %02x\", (u_int)x);\n\t\tres->data.raw.data[i] = x;\n\t}\n\n\tif (sc->debug)\n\t\tprintf(\" succeeded\\n\");\n\n#ifdef MCDDEBUG\n\tdelay(10);\n\twhile ((bus_space_read_1(sc->sc_iot, sc->sc_ioh, MCD_XFER) &\n\t    MCD_XF_STATUSUNAVAIL) == 0) {\n\t\tx = bus_space_read_1(sc->sc_iot, sc->sc_ioh, MCD_STATUS);\n\t\tprintf(\"%s: got extra byte %02x during getstatus\\n\",\n\t\t    sc->sc_dev.dv_xname, (u_int)x);\n\t\tdelay(10);\n\t}\n#endif\n\n\treturn 0;\n}"
  },
  {
    "function_name": "mcd_getstat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
    "lines": "951-961",
    "snippet": "int\nmcd_getstat(sc)\n\tstruct mcd_softc *sc;\n{\n\tstruct mcd_mbox mbx;\n\n\tmbx.cmd.opcode = MCD_CMDGETSTAT;\n\tmbx.cmd.length = 0;\n\tmbx.res.length = 0;\n\treturn mcd_send(sc, &mbx, 1);\n}",
    "includes": [
      "#include <lib/libkern/libkern.h>",
      "#include <dev/isa/opti.h>",
      "#include <dev/isa/mcdreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/errno.h>",
      "#include <sys/cdio.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/uio.h>",
      "#include <sys/stat.h>",
      "#include <sys/buf.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int mcd_getstat",
      "int mcd_send"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mcd_send",
          "args": [
            "sc",
            "&mbx",
            "1"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1044-1077",
          "snippet": "int\nmcd_send(sc, mbx, diskin)\n\tstruct mcd_softc *sc;\n\tstruct mcd_mbox *mbx;\n\tint diskin;\n{\n\tint retry, i, error;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\t\n\tif (sc->debug) {\n\t\tprintf(\"%s: mcd_send: %d %02x\", sc->sc_dev.dv_xname,\n\t\t    mbx->cmd.length, (u_int)mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tprintf(\" %02x\", (u_int)mbx->cmd.data.raw.data[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tfor (retry = MCD_RETRIES; retry; retry--) {\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.data.raw.data[i]);\n\t\tif ((error = mcd_getresult(sc, &mbx->res)) == 0)\n\t\t\tbreak;\n\t\tif (error == EINVAL)\n\t\t\treturn error;\n\t}\n\tif (!retry)\n\t\treturn error;\n\tif (diskin && (sc->flags & MCDF_LOADED) == 0)\n\t\treturn EIO;\n\n\treturn 0;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MCD_RETRIES\t3",
            "#define\tMCDF_LOADED\t0x10\t/* parameters loaded */"
          ],
          "globals_used": [
            "int mcd_getresult",
            "int mcd_send"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MCD_RETRIES\t3\n#define\tMCDF_LOADED\t0x10\t/* parameters loaded */\n\nint mcd_getresult;\nint mcd_send;\n\nint\nmcd_send(sc, mbx, diskin)\n\tstruct mcd_softc *sc;\n\tstruct mcd_mbox *mbx;\n\tint diskin;\n{\n\tint retry, i, error;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\t\n\tif (sc->debug) {\n\t\tprintf(\"%s: mcd_send: %d %02x\", sc->sc_dev.dv_xname,\n\t\t    mbx->cmd.length, (u_int)mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tprintf(\" %02x\", (u_int)mbx->cmd.data.raw.data[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tfor (retry = MCD_RETRIES; retry; retry--) {\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.data.raw.data[i]);\n\t\tif ((error = mcd_getresult(sc, &mbx->res)) == 0)\n\t\t\tbreak;\n\t\tif (error == EINVAL)\n\t\t\treturn error;\n\t}\n\tif (!retry)\n\t\treturn error;\n\tif (diskin && (sc->flags & MCDF_LOADED) == 0)\n\t\treturn EIO;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint mcd_getstat;\nint mcd_send;\n\nint\nmcd_getstat(sc)\n\tstruct mcd_softc *sc;\n{\n\tstruct mcd_mbox mbx;\n\n\tmbx.cmd.opcode = MCD_CMDGETSTAT;\n\tmbx.cmd.length = 0;\n\tmbx.res.length = 0;\n\treturn mcd_send(sc, &mbx, 1);\n}"
  },
  {
    "function_name": "mcd_getreply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
    "lines": "929-949",
    "snippet": "int\nmcd_getreply(sc)\n\tstruct mcd_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i;\n\n\t/* Wait until xfer port senses data ready. */\n\tfor (i = DELAY_GETREPLY; i; i--) {\n\t\tif ((bus_space_read_1(iot, ioh, MCD_XFER) &\n\t\t    MCD_XF_STATUSUNAVAIL) == 0)\n\t\t\tbreak;\n\t\tdelay(DELAY_GRANULARITY);\n\t}\n\tif (!i)\n\t\treturn -1;\n\n\t/* Get the data. */\n\treturn bus_space_read_1(iot, ioh, MCD_STATUS);\n}",
    "includes": [
      "#include <lib/libkern/libkern.h>",
      "#include <dev/isa/opti.h>",
      "#include <dev/isa/mcdreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/errno.h>",
      "#include <sys/cdio.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/uio.h>",
      "#include <sys/stat.h>",
      "#include <sys/buf.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define DELAY_GETREPLY\t\t100000\t/* 100000 * 25us */",
      "#define\tDELAY_GRANULARITY\t25\t/* 25us */"
    ],
    "globals_used": [
      "int mcd_getreply"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "MCD_STATUS"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "DELAY_GRANULARITY"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "MCD_XFER"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DELAY_GETREPLY\t\t100000\t/* 100000 * 25us */\n#define\tDELAY_GRANULARITY\t25\t/* 25us */\n\nint mcd_getreply;\n\nint\nmcd_getreply(sc)\n\tstruct mcd_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint i;\n\n\t/* Wait until xfer port senses data ready. */\n\tfor (i = DELAY_GETREPLY; i; i--) {\n\t\tif ((bus_space_read_1(iot, ioh, MCD_XFER) &\n\t\t    MCD_XF_STATUSUNAVAIL) == 0)\n\t\t\tbreak;\n\t\tdelay(DELAY_GRANULARITY);\n\t}\n\tif (!i)\n\t\treturn -1;\n\n\t/* Get the data. */\n\treturn bus_space_read_1(iot, ioh, MCD_STATUS);\n}"
  },
  {
    "function_name": "mcd_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
    "lines": "813-885",
    "snippet": "int\nmcd_find(iot, ioh, sc)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tstruct mcd_softc *sc;\n{\n\tint i;\n\tstruct mcd_mbox mbx;\n\n        sc->sc_iot = iot;\n\tsc->sc_ioh = ioh;\n\n\t/* Send a reset. */\n\tbus_space_write_1(iot, ioh, MCD_RESET, 0);\n\tdelay(1000000);\n\t/* Get any pending status and throw away. */\n\tfor (i = 10; i; i--)\n\t\tbus_space_read_1(iot, ioh, MCD_STATUS);\n\tdelay(1000);\n\n\t/* Send get status command. */\n\tmbx.cmd.opcode = MCD_CMDGETSTAT;\n\tmbx.cmd.length = 0;\n\tmbx.res.length = 0;\n\tif (mcd_send(sc, &mbx, 0) != 0)\n\t\treturn 0;\n\n\t/* Get info about the drive. */\n\tmbx.cmd.opcode = MCD_CMDCONTINFO;\n\tmbx.cmd.length = 0;\n\tmbx.res.length = sizeof(mbx.res.data.continfo);\n\tif (mcd_send(sc, &mbx, 0) != 0)\n\t\treturn 0;\n\n\t/*\n\t * The following is code which is not guaranteed to work for all\n\t * drives, because the meaning of the expected 'M' is not clear\n\t * (M_itsumi is an obvious assumption, but I don't trust that).\n\t * Also, the original hack had a bogus condition that always\n\t * returned true.\n\t *\n\t * Note:  Which models support interrupts?  >=LU005S?\n\t */\n\tsc->readcmd = MCD_CMDREADSINGLESPEED;\n\tswitch (mbx.res.data.continfo.code) {\n\tcase 'M':\n\t\tif (mbx.res.data.continfo.version <= 2)\n\t\t\tsc->type = \"LU002S\";\n\t\telse if (mbx.res.data.continfo.version <= 5)\n\t\t\tsc->type = \"LU005S\";\n\t\telse\n\t\t\tsc->type = \"LU006S\";\n\t\tbreak;\n\tcase 'F':\n\t\tsc->type = \"FX001\";\n\t\tbreak;\n\tcase 'D':\n\t\tsc->type = \"FX001D\";\n\t\tsc->readcmd = MCD_CMDREADDOUBLESPEED;\n\t\tbreak;\n\tdefault:\n#ifdef MCDDEBUG\n\t\tprintf(\"%s: unrecognized drive version %c%02x; will try to use it anyway\\n\",\n\t\t    sc->sc_dev.dv_xname,\n\t\t    mbx.res.data.continfo.code, mbx.res.data.continfo.version);\n#endif\n\t\tsc->type = 0;\n\t\tbreak;\n\t}\n\n\treturn 1;\n\n}",
    "includes": [
      "#include <lib/libkern/libkern.h>",
      "#include <dev/isa/opti.h>",
      "#include <dev/isa/mcdreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/errno.h>",
      "#include <sys/cdio.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/uio.h>",
      "#include <sys/stat.h>",
      "#include <sys/buf.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int mcd_send",
      "int mcd_find"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: unrecognized drive version %c%02x; will try to use it anyway\\n\"",
            "sc->sc_dev.dv_xname",
            "mbx.res.data.continfo.code",
            "mbx.res.data.continfo.version"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mcd_send",
          "args": [
            "sc",
            "&mbx",
            "0"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1044-1077",
          "snippet": "int\nmcd_send(sc, mbx, diskin)\n\tstruct mcd_softc *sc;\n\tstruct mcd_mbox *mbx;\n\tint diskin;\n{\n\tint retry, i, error;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\t\n\tif (sc->debug) {\n\t\tprintf(\"%s: mcd_send: %d %02x\", sc->sc_dev.dv_xname,\n\t\t    mbx->cmd.length, (u_int)mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tprintf(\" %02x\", (u_int)mbx->cmd.data.raw.data[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tfor (retry = MCD_RETRIES; retry; retry--) {\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.data.raw.data[i]);\n\t\tif ((error = mcd_getresult(sc, &mbx->res)) == 0)\n\t\t\tbreak;\n\t\tif (error == EINVAL)\n\t\t\treturn error;\n\t}\n\tif (!retry)\n\t\treturn error;\n\tif (diskin && (sc->flags & MCDF_LOADED) == 0)\n\t\treturn EIO;\n\n\treturn 0;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MCD_RETRIES\t3",
            "#define\tMCDF_LOADED\t0x10\t/* parameters loaded */"
          ],
          "globals_used": [
            "int mcd_getresult",
            "int mcd_send"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MCD_RETRIES\t3\n#define\tMCDF_LOADED\t0x10\t/* parameters loaded */\n\nint mcd_getresult;\nint mcd_send;\n\nint\nmcd_send(sc, mbx, diskin)\n\tstruct mcd_softc *sc;\n\tstruct mcd_mbox *mbx;\n\tint diskin;\n{\n\tint retry, i, error;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\t\n\tif (sc->debug) {\n\t\tprintf(\"%s: mcd_send: %d %02x\", sc->sc_dev.dv_xname,\n\t\t    mbx->cmd.length, (u_int)mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tprintf(\" %02x\", (u_int)mbx->cmd.data.raw.data[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tfor (retry = MCD_RETRIES; retry; retry--) {\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.data.raw.data[i]);\n\t\tif ((error = mcd_getresult(sc, &mbx->res)) == 0)\n\t\t\tbreak;\n\t\tif (error == EINVAL)\n\t\t\treturn error;\n\t}\n\tif (!retry)\n\t\treturn error;\n\tif (diskin && (sc->flags & MCDF_LOADED) == 0)\n\t\treturn EIO;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1000"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "MCD_STATUS"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "MCD_RESET",
            "0"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint mcd_send;\nint mcd_find;\n\nint\nmcd_find(iot, ioh, sc)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tstruct mcd_softc *sc;\n{\n\tint i;\n\tstruct mcd_mbox mbx;\n\n        sc->sc_iot = iot;\n\tsc->sc_ioh = ioh;\n\n\t/* Send a reset. */\n\tbus_space_write_1(iot, ioh, MCD_RESET, 0);\n\tdelay(1000000);\n\t/* Get any pending status and throw away. */\n\tfor (i = 10; i; i--)\n\t\tbus_space_read_1(iot, ioh, MCD_STATUS);\n\tdelay(1000);\n\n\t/* Send get status command. */\n\tmbx.cmd.opcode = MCD_CMDGETSTAT;\n\tmbx.cmd.length = 0;\n\tmbx.res.length = 0;\n\tif (mcd_send(sc, &mbx, 0) != 0)\n\t\treturn 0;\n\n\t/* Get info about the drive. */\n\tmbx.cmd.opcode = MCD_CMDCONTINFO;\n\tmbx.cmd.length = 0;\n\tmbx.res.length = sizeof(mbx.res.data.continfo);\n\tif (mcd_send(sc, &mbx, 0) != 0)\n\t\treturn 0;\n\n\t/*\n\t * The following is code which is not guaranteed to work for all\n\t * drives, because the meaning of the expected 'M' is not clear\n\t * (M_itsumi is an obvious assumption, but I don't trust that).\n\t * Also, the original hack had a bogus condition that always\n\t * returned true.\n\t *\n\t * Note:  Which models support interrupts?  >=LU005S?\n\t */\n\tsc->readcmd = MCD_CMDREADSINGLESPEED;\n\tswitch (mbx.res.data.continfo.code) {\n\tcase 'M':\n\t\tif (mbx.res.data.continfo.version <= 2)\n\t\t\tsc->type = \"LU002S\";\n\t\telse if (mbx.res.data.continfo.version <= 5)\n\t\t\tsc->type = \"LU005S\";\n\t\telse\n\t\t\tsc->type = \"LU006S\";\n\t\tbreak;\n\tcase 'F':\n\t\tsc->type = \"FX001\";\n\t\tbreak;\n\tcase 'D':\n\t\tsc->type = \"FX001D\";\n\t\tsc->readcmd = MCD_CMDREADDOUBLESPEED;\n\t\tbreak;\n\tdefault:\n#ifdef MCDDEBUG\n\t\tprintf(\"%s: unrecognized drive version %c%02x; will try to use it anyway\\n\",\n\t\t    sc->sc_dev.dv_xname,\n\t\t    mbx.res.data.continfo.code, mbx.res.data.continfo.version);\n#endif\n\t\tsc->type = 0;\n\t\tbreak;\n\t}\n\n\treturn 1;\n\n}"
  },
  {
    "function_name": "mcddump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
    "lines": "798-808",
    "snippet": "int\nmcddump(dev, blkno, va, size)\n\tdev_t dev;\n\tdaddr_t blkno;\n\tcaddr_t va;\n\tsize_t size;\n{\n\n\t/* Not implemented. */\n\treturn ENXIO;\n}",
    "includes": [
      "#include <lib/libkern/libkern.h>",
      "#include <dev/isa/opti.h>",
      "#include <dev/isa/mcdreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/errno.h>",
      "#include <sys/cdio.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/uio.h>",
      "#include <sys/stat.h>",
      "#include <sys/buf.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nmcddump(dev, blkno, va, size)\n\tdev_t dev;\n\tdaddr_t blkno;\n\tcaddr_t va;\n\tsize_t size;\n{\n\n\t/* Not implemented. */\n\treturn ENXIO;\n}"
  },
  {
    "function_name": "mcdsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
    "lines": "789-796",
    "snippet": "int\nmcdsize(dev)\n\tdev_t dev;\n{\n\n\t/* CD-ROMs are read-only. */\n\treturn -1;\n}",
    "includes": [
      "#include <lib/libkern/libkern.h>",
      "#include <dev/isa/opti.h>",
      "#include <dev/isa/mcdreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/errno.h>",
      "#include <sys/cdio.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/uio.h>",
      "#include <sys/stat.h>",
      "#include <sys/buf.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nmcdsize(dev)\n\tdev_t dev;\n{\n\n\t/* CD-ROMs are read-only. */\n\treturn -1;\n}"
  },
  {
    "function_name": "mcd_get_parms",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
    "lines": "762-787",
    "snippet": "int\nmcd_get_parms(sc)\n\tstruct mcd_softc *sc;\n{\n\tstruct mcd_mbox mbx;\n\tdaddr_t size;\n\tint error;\n\n\t/* Send volume info command. */\n\tmbx.cmd.opcode = MCD_CMDGETVOLINFO;\n\tmbx.cmd.length = 0;\n\tmbx.res.length = sizeof(mbx.res.data.volinfo);\n\tif ((error = mcd_send(sc, &mbx, 1)) != 0)\n\t\treturn error;\n\n\tif (mbx.res.data.volinfo.trk_low == 0x00 &&\n\t    mbx.res.data.volinfo.trk_high == 0x00)\n\t\treturn EINVAL;\n\n\t/* Volinfo is OK. */\n\tsc->volinfo = mbx.res.data.volinfo;\n\tsc->blksize = MCD_BLKSIZE_COOKED;\n\tsize = msf2hsg(sc->volinfo.vol_msf, 0);\n\tsc->disksize = size * (MCD_BLKSIZE_COOKED / DEV_BSIZE);\n\treturn 0;\n}",
    "includes": [
      "#include <lib/libkern/libkern.h>",
      "#include <dev/isa/opti.h>",
      "#include <dev/isa/mcdreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/errno.h>",
      "#include <sys/cdio.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/uio.h>",
      "#include <sys/stat.h>",
      "#include <sys/buf.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static daddr_t msf2hsg",
      "int mcd_send",
      "int\tmcd_get_parms"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "msf2hsg",
          "args": [
            "sc->volinfo.vol_msf",
            "0"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "msf2hsg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1093-1106",
          "snippet": "static daddr_t\nmsf2hsg(msf, relative)\n\tbcd_t *msf;\n\tint relative;\n{\n\tdaddr_t blkno;\n\n\tblkno = bcd2bin(M_msf(msf)) * 75 * 60 +\n\t\tbcd2bin(S_msf(msf)) * 75 +\n\t\tbcd2bin(F_msf(msf));\n\tif (!relative)\n\t\tblkno -= 150;\n\treturn blkno;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__P((int, bcd_t *));",
            "static daddr_t msf2hsg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n__P((int, bcd_t *));\nstatic daddr_t msf2hsg;\n\nstatic daddr_t\nmsf2hsg(msf, relative)\n\tbcd_t *msf;\n\tint relative;\n{\n\tdaddr_t blkno;\n\n\tblkno = bcd2bin(M_msf(msf)) * 75 * 60 +\n\t\tbcd2bin(S_msf(msf)) * 75 +\n\t\tbcd2bin(F_msf(msf));\n\tif (!relative)\n\t\tblkno -= 150;\n\treturn blkno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mcd_send",
          "args": [
            "sc",
            "&mbx",
            "1"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1044-1077",
          "snippet": "int\nmcd_send(sc, mbx, diskin)\n\tstruct mcd_softc *sc;\n\tstruct mcd_mbox *mbx;\n\tint diskin;\n{\n\tint retry, i, error;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\t\n\tif (sc->debug) {\n\t\tprintf(\"%s: mcd_send: %d %02x\", sc->sc_dev.dv_xname,\n\t\t    mbx->cmd.length, (u_int)mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tprintf(\" %02x\", (u_int)mbx->cmd.data.raw.data[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tfor (retry = MCD_RETRIES; retry; retry--) {\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.data.raw.data[i]);\n\t\tif ((error = mcd_getresult(sc, &mbx->res)) == 0)\n\t\t\tbreak;\n\t\tif (error == EINVAL)\n\t\t\treturn error;\n\t}\n\tif (!retry)\n\t\treturn error;\n\tif (diskin && (sc->flags & MCDF_LOADED) == 0)\n\t\treturn EIO;\n\n\treturn 0;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MCD_RETRIES\t3",
            "#define\tMCDF_LOADED\t0x10\t/* parameters loaded */"
          ],
          "globals_used": [
            "int mcd_getresult",
            "int mcd_send"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MCD_RETRIES\t3\n#define\tMCDF_LOADED\t0x10\t/* parameters loaded */\n\nint mcd_getresult;\nint mcd_send;\n\nint\nmcd_send(sc, mbx, diskin)\n\tstruct mcd_softc *sc;\n\tstruct mcd_mbox *mbx;\n\tint diskin;\n{\n\tint retry, i, error;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\t\n\tif (sc->debug) {\n\t\tprintf(\"%s: mcd_send: %d %02x\", sc->sc_dev.dv_xname,\n\t\t    mbx->cmd.length, (u_int)mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tprintf(\" %02x\", (u_int)mbx->cmd.data.raw.data[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tfor (retry = MCD_RETRIES; retry; retry--) {\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.data.raw.data[i]);\n\t\tif ((error = mcd_getresult(sc, &mbx->res)) == 0)\n\t\t\tbreak;\n\t\tif (error == EINVAL)\n\t\t\treturn error;\n\t}\n\tif (!retry)\n\t\treturn error;\n\tif (diskin && (sc->flags & MCDF_LOADED) == 0)\n\t\treturn EIO;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic daddr_t msf2hsg;\nint mcd_send;\nint\tmcd_get_parms;\n\nint\nmcd_get_parms(sc)\n\tstruct mcd_softc *sc;\n{\n\tstruct mcd_mbox mbx;\n\tdaddr_t size;\n\tint error;\n\n\t/* Send volume info command. */\n\tmbx.cmd.opcode = MCD_CMDGETVOLINFO;\n\tmbx.cmd.length = 0;\n\tmbx.res.length = sizeof(mbx.res.data.volinfo);\n\tif ((error = mcd_send(sc, &mbx, 1)) != 0)\n\t\treturn error;\n\n\tif (mbx.res.data.volinfo.trk_low == 0x00 &&\n\t    mbx.res.data.volinfo.trk_high == 0x00)\n\t\treturn EINVAL;\n\n\t/* Volinfo is OK. */\n\tsc->volinfo = mbx.res.data.volinfo;\n\tsc->blksize = MCD_BLKSIZE_COOKED;\n\tsize = msf2hsg(sc->volinfo.vol_msf, 0);\n\tsc->disksize = size * (MCD_BLKSIZE_COOKED / DEV_BSIZE);\n\treturn 0;\n}"
  },
  {
    "function_name": "mcdgetdisklabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
    "lines": "710-760",
    "snippet": "void\nmcdgetdisklabel(dev, sc, lp, clp, spoofonly)\n\tdev_t dev;\n\tstruct mcd_softc *sc;\n\tstruct disklabel *lp;\n\tstruct cpu_disklabel *clp;\n\tint spoofonly;\n{\n\tchar *errstring;\n\t\n\tbzero(lp, sizeof(struct disklabel));\n\tbzero(clp, sizeof(struct cpu_disklabel));\n\n\tlp->d_secsize = sc->blksize;\n\tlp->d_ntracks = 1;\n\tlp->d_nsectors = 100;\n\tlp->d_ncylinders = (sc->disksize / 100) + 1;\n\tlp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;\n\tif (lp->d_secpercyl == 0) {\n\t\tlp->d_secpercyl = 100;\n\t\t/* as long as it's not 0 - readdisklabel divides by it */\n\t}\n\n\tstrncpy(lp->d_typename, \"Mitsumi CD-ROM\", 16);\n\tlp->d_type = DTYPE_SCSI;\t/* XXX */\n\tstrncpy(lp->d_packname, \"fictitious\", 16);\n\tlp->d_secperunit = sc->disksize;\n\tlp->d_rpm = 300;\n\tlp->d_interleave = 1;\n\tlp->d_flags = D_REMOVABLE;\n\n\tlp->d_partitions[RAW_PART].p_offset = 0;\n\tlp->d_partitions[RAW_PART].p_size =\n\t    lp->d_secperunit * (lp->d_secsize / DEV_BSIZE);\n\tlp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;\n\tlp->d_npartitions = RAW_PART + 1;\n\n\tlp->d_magic = DISKMAGIC;\n\tlp->d_magic2 = DISKMAGIC;\n\tlp->d_checksum = dkcksum(lp);\n\n\t/*\n\t * Call the generic disklabel extraction routine\n\t */\n\terrstring = readdisklabel(MCDLABELDEV(dev), mcdstrategy, lp, clp,\n\t    spoofonly);\n\tif (errstring) {\n\t\t/*printf(\"%s: %s\\n\", sc->sc_dev.dv_xname, errstring);*/\n\t\treturn;\n\t}\n}",
    "includes": [
      "#include <lib/libkern/libkern.h>",
      "#include <dev/isa/opti.h>",
      "#include <dev/isa/mcdreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/errno.h>",
      "#include <sys/cdio.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/uio.h>",
      "#include <sys/stat.h>",
      "#include <sys/buf.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tmcdgetdisklabel",
      "void\tmcdstrategy"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "readdisklabel",
          "args": [
            "MCDLABELDEV(dev)",
            "mcdstrategy",
            "lp",
            "clp",
            "spoofonly"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCDLABELDEV",
          "args": [
            "dev"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dkcksum",
          "args": [
            "lp"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "lp->d_packname",
            "\"fictitious\"",
            "16"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "lp->d_typename",
            "\"Mitsumi CD-ROM\"",
            "16"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "clp",
            "sizeof(struct cpu_disklabel)"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "lp",
            "sizeof(struct disklabel)"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tmcdgetdisklabel;\nvoid\tmcdstrategy;\n\nvoid\nmcdgetdisklabel(dev, sc, lp, clp, spoofonly)\n\tdev_t dev;\n\tstruct mcd_softc *sc;\n\tstruct disklabel *lp;\n\tstruct cpu_disklabel *clp;\n\tint spoofonly;\n{\n\tchar *errstring;\n\t\n\tbzero(lp, sizeof(struct disklabel));\n\tbzero(clp, sizeof(struct cpu_disklabel));\n\n\tlp->d_secsize = sc->blksize;\n\tlp->d_ntracks = 1;\n\tlp->d_nsectors = 100;\n\tlp->d_ncylinders = (sc->disksize / 100) + 1;\n\tlp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;\n\tif (lp->d_secpercyl == 0) {\n\t\tlp->d_secpercyl = 100;\n\t\t/* as long as it's not 0 - readdisklabel divides by it */\n\t}\n\n\tstrncpy(lp->d_typename, \"Mitsumi CD-ROM\", 16);\n\tlp->d_type = DTYPE_SCSI;\t/* XXX */\n\tstrncpy(lp->d_packname, \"fictitious\", 16);\n\tlp->d_secperunit = sc->disksize;\n\tlp->d_rpm = 300;\n\tlp->d_interleave = 1;\n\tlp->d_flags = D_REMOVABLE;\n\n\tlp->d_partitions[RAW_PART].p_offset = 0;\n\tlp->d_partitions[RAW_PART].p_size =\n\t    lp->d_secperunit * (lp->d_secsize / DEV_BSIZE);\n\tlp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;\n\tlp->d_npartitions = RAW_PART + 1;\n\n\tlp->d_magic = DISKMAGIC;\n\tlp->d_magic2 = DISKMAGIC;\n\tlp->d_checksum = dkcksum(lp);\n\n\t/*\n\t * Call the generic disklabel extraction routine\n\t */\n\terrstring = readdisklabel(MCDLABELDEV(dev), mcdstrategy, lp, clp,\n\t    spoofonly);\n\tif (errstring) {\n\t\t/*printf(\"%s: %s\\n\", sc->sc_dev.dv_xname, errstring);*/\n\t\treturn;\n\t}\n}"
  },
  {
    "function_name": "mcdioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
    "lines": "594-708",
    "snippet": "int\nmcdioctl(dev, cmd, addr, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t addr;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct mcd_softc *sc = mcd_cd.cd_devs[MCDUNIT(dev)];\n\tint error;\n\t\n\tMCD_TRACE(\"ioctl: cmd=0x%x\\n\", cmd, 0, 0, 0);\n\n\tif ((sc->flags & MCDF_LOADED) == 0)\n\t\treturn EIO;\n\n\tswitch (cmd) {\n\tcase DIOCRLDINFO:\n\t\tmcdgetdisklabel(dev, sc, sc->sc_dk.dk_label,\n\t\t    sc->sc_dk.dk_cpulabel, 0);\n\t\treturn 0;\n\tcase DIOCGDINFO:\n\tcase DIOCGPDINFO:\n\t\t*(struct disklabel *)addr = *(sc->sc_dk.dk_label);\n\t\treturn 0;\n\n\tcase DIOCGPART:\n\t\t((struct partinfo *)addr)->disklab = sc->sc_dk.dk_label;\n\t\t((struct partinfo *)addr)->part =\n\t\t    &sc->sc_dk.dk_label->d_partitions[MCDPART(dev)];\n\t\treturn 0;\n\n\tcase DIOCWDINFO:\n\tcase DIOCSDINFO:\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn EBADF;\n\n\t\tif ((error = mcdlock(sc)) != 0)\n\t\t\treturn error;\n\t\tsc->flags |= MCDF_LABELLING;\n\n\t\terror = setdisklabel(sc->sc_dk.dk_label,\n\t\t    (struct disklabel *)addr, /*sc->sc_dk.dk_openmask : */0,\n\t\t    sc->sc_dk.dk_cpulabel);\n\t\tif (error == 0) {\n\t\t}\n\n\t\tsc->flags &= ~MCDF_LABELLING;\n\t\tmcdunlock(sc);\n\t\treturn error;\n\n\tcase DIOCWLABEL:\n\t\treturn EBADF;\n\n\tcase CDIOCPLAYTRACKS:\n\t\treturn mcd_playtracks(sc, (struct ioc_play_track *)addr);\n\tcase CDIOCPLAYMSF:\n\t\treturn mcd_playmsf(sc, (struct ioc_play_msf *)addr);\n\tcase CDIOCPLAYBLOCKS:\n\t\treturn mcd_playblocks(sc, (struct ioc_play_blocks *)addr);\n\tcase CDIOCREADSUBCHANNEL:\n\t\treturn mcd_read_subchannel(sc, (struct ioc_read_subchannel *)addr);\n\tcase CDIOREADTOCHEADER:\n\t\treturn mcd_toc_header(sc, (struct ioc_toc_header *)addr);\n\tcase CDIOREADTOCENTRYS:\n\t\treturn mcd_toc_entries(sc, (struct ioc_read_toc_entry *)addr);\n\tcase CDIOCSETPATCH:\n\tcase CDIOCGETVOL:\n\tcase CDIOCSETVOL:\n\tcase CDIOCSETMONO:\n\tcase CDIOCSETSTEREO:\n\tcase CDIOCSETMUTE:\n\tcase CDIOCSETLEFT:\n\tcase CDIOCSETRIGHT:\n\t\treturn EINVAL;\n\tcase CDIOCRESUME:\n\t\treturn mcd_resume(sc);\n\tcase CDIOCPAUSE:\n\t\treturn mcd_pause(sc);\n\tcase CDIOCSTART:\n\t\treturn EINVAL;\n\tcase CDIOCSTOP:\n\t\treturn mcd_stop(sc);\n\tcase MTIOCTOP:\n\t\tif (((struct mtop *)addr)->mt_op != MTOFFL)\n\t\t\treturn EIO;\n\t\t/* FALLTHROUGH */\n\tcase CDIOCEJECT: /* FALLTHROUGH */\n\tcase DIOCEJECT:\n\t\tsc->flags |= MCDF_EJECTING;\n\t\treturn (0);\n\tcase CDIOCALLOW:\n\t\treturn mcd_setlock(sc, MCD_LK_UNLOCK);\n\tcase CDIOCPREVENT:\n\t\treturn mcd_setlock(sc, MCD_LK_LOCK);\n\tcase DIOCLOCK:\n\t\treturn mcd_setlock(sc,\n\t\t    (*(int *)addr) ? MCD_LK_LOCK : MCD_LK_UNLOCK);\n\tcase CDIOCSETDEBUG:\n\t\tsc->debug = 1;\n\t\treturn 0;\n\tcase CDIOCCLRDEBUG:\n\t\tsc->debug = 0;\n\t\treturn 0;\n\tcase CDIOCRESET:\n\t\treturn mcd_hard_reset(sc);\n\n\tdefault:\n\t\treturn ENOTTY;\n\t}\n\n#ifdef DIAGNOSTIC\n\tpanic(\"mcdioctl: impossible\");\n#endif\n}",
    "includes": [
      "#include <lib/libkern/libkern.h>",
      "#include <dev/isa/opti.h>",
      "#include <dev/isa/mcdreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/errno.h>",
      "#include <sys/cdio.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/uio.h>",
      "#include <sys/stat.h>",
      "#include <sys/buf.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tMCDF_EJECTING\t0x20\t/* please eject at close */",
      "#define\tMCDF_LOADED\t0x10\t/* parameters loaded */",
      "#define\tMCDF_LABELLING\t0x08\t/* writing label */"
    ],
    "globals_used": [
      "int mcd_playtracks",
      "int mcd_playmsf",
      "int mcd_playblocks",
      "int mcd_stop",
      "int mcd_read_subchannel",
      "int mcd_pause",
      "int mcd_resume",
      "int mcd_toc_header",
      "int mcd_toc_entries",
      "int mcd_hard_reset",
      "int mcd_setlock",
      "struct cfdriver mcd_cd = {\n\tNULL, \"mcd\", DV_DISK\n};",
      "void\tmcdgetdisklabel",
      "int\tmcdlock",
      "void\tmcdunlock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"mcdioctl: impossible\""
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mcd_hard_reset",
          "args": [
            "sc"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_hard_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1298-1310",
          "snippet": "int\nmcd_hard_reset(sc)\n\tstruct mcd_softc *sc;\n{\n\tstruct mcd_mbox mbx;\n\n\tmcd_soft_reset(sc);\n\n\tmbx.cmd.opcode = MCD_CMDRESET;\n\tmbx.cmd.length = 0;\n\tmbx.res.length = 0;\n\treturn mcd_send(sc, &mbx, 0);\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int mcd_send",
            "void mcd_soft_reset",
            "int mcd_hard_reset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint mcd_send;\nvoid mcd_soft_reset;\nint mcd_hard_reset;\n\nint\nmcd_hard_reset(sc)\n\tstruct mcd_softc *sc;\n{\n\tstruct mcd_mbox mbx;\n\n\tmcd_soft_reset(sc);\n\n\tmbx.cmd.opcode = MCD_CMDRESET;\n\tmbx.cmd.length = 0;\n\tmbx.res.length = 0;\n\treturn mcd_send(sc, &mbx, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mcd_setlock",
          "args": [
            "sc",
            "(*(int *)addr) ? MCD_LK_LOCK : MCD_LK_UNLOCK"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_setlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1804-1816",
          "snippet": "int\nmcd_setlock(sc, mode)\n\tstruct mcd_softc *sc;\n\tint mode;\n{\n\tstruct mcd_mbox mbx;\n\t\n\tmbx.cmd.opcode = MCD_CMDSETLOCK;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.lockmode);\n\tmbx.cmd.data.lockmode.mode = mode;\n\tmbx.res.length = 0;\n\treturn mcd_send(sc, &mbx, 1);\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int mcd_send",
            "int mcd_setlock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint mcd_send;\nint mcd_setlock;\n\nint\nmcd_setlock(sc, mode)\n\tstruct mcd_softc *sc;\n\tint mode;\n{\n\tstruct mcd_mbox mbx;\n\t\n\tmbx.cmd.opcode = MCD_CMDSETLOCK;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.lockmode);\n\tmbx.cmd.data.lockmode.mode = mode;\n\tmbx.res.length = 0;\n\treturn mcd_send(sc, &mbx, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mcd_stop",
          "args": [
            "sc"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1503-1521",
          "snippet": "int\nmcd_stop(sc)\n\tstruct mcd_softc *sc;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (sc->debug)\n\t\tprintf(\"%s: mcd_stop: stopping play\\n\", sc->sc_dev.dv_xname);\n\n\tmbx.cmd.opcode = MCD_CMDSTOPAUDIO;\n\tmbx.cmd.length = 0;\n\tmbx.res.length = 0;\n\tif ((error = mcd_send(sc, &mbx, 1)) != 0)\n\t\treturn error;\n\n\tsc->audio_status = CD_AS_PLAY_COMPLETED;\n\treturn 0;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int mcd_stop",
            "int mcd_send"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint mcd_stop;\nint mcd_send;\n\nint\nmcd_stop(sc)\n\tstruct mcd_softc *sc;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (sc->debug)\n\t\tprintf(\"%s: mcd_stop: stopping play\\n\", sc->sc_dev.dv_xname);\n\n\tmbx.cmd.opcode = MCD_CMDSTOPAUDIO;\n\tmbx.cmd.length = 0;\n\tmbx.res.length = 0;\n\tif ((error = mcd_send(sc, &mbx, 1)) != 0)\n\t\treturn error;\n\n\tsc->audio_status = CD_AS_PLAY_COMPLETED;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mcd_pause",
          "args": [
            "sc"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_pause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1742-1772",
          "snippet": "int\nmcd_pause(sc)\n\tstruct mcd_softc *sc;\n{\n\tunion mcd_qchninfo q;\n\tint error;\n\n\t/* Verify current status. */\n\tif (sc->audio_status != CD_AS_PLAY_IN_PROGRESS)\t{\n\t\tprintf(\"%s: pause: attempted when not playing\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn EINVAL;\n\t}\n\n\t/* Get the current position. */\n\tif ((error = mcd_getqchan(sc, &q, CD_CURRENT_POSITION)) != 0)\n\t\treturn error;\n\n\t/* Copy it into lastpb. */\n\tsc->lastpb.data.seek.start_msf[0] = q.current.absolute_pos[0];\n\tsc->lastpb.data.seek.start_msf[1] = q.current.absolute_pos[1];\n\tsc->lastpb.data.seek.start_msf[2] = q.current.absolute_pos[2];\n\n\t/* Stop playing. */\n\tif ((error = mcd_stop(sc)) != 0)\n\t\treturn error;\n\n\t/* Set the proper status and exit. */\n\tsc->audio_status = CD_AS_PLAY_PAUSED;\n\treturn 0;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int mcd_stop",
            "int mcd_pause",
            "int mcd_getqchan"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint mcd_stop;\nint mcd_pause;\nint mcd_getqchan;\n\nint\nmcd_pause(sc)\n\tstruct mcd_softc *sc;\n{\n\tunion mcd_qchninfo q;\n\tint error;\n\n\t/* Verify current status. */\n\tif (sc->audio_status != CD_AS_PLAY_IN_PROGRESS)\t{\n\t\tprintf(\"%s: pause: attempted when not playing\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\treturn EINVAL;\n\t}\n\n\t/* Get the current position. */\n\tif ((error = mcd_getqchan(sc, &q, CD_CURRENT_POSITION)) != 0)\n\t\treturn error;\n\n\t/* Copy it into lastpb. */\n\tsc->lastpb.data.seek.start_msf[0] = q.current.absolute_pos[0];\n\tsc->lastpb.data.seek.start_msf[1] = q.current.absolute_pos[1];\n\tsc->lastpb.data.seek.start_msf[2] = q.current.absolute_pos[2];\n\n\t/* Stop playing. */\n\tif ((error = mcd_stop(sc)) != 0)\n\t\treturn error;\n\n\t/* Set the proper status and exit. */\n\tsc->audio_status = CD_AS_PLAY_PAUSED;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mcd_resume",
          "args": [
            "sc"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_resume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1774-1790",
          "snippet": "int\nmcd_resume(sc)\n\tstruct mcd_softc *sc;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (sc->audio_status != CD_AS_PLAY_PAUSED)\n\t\treturn EINVAL;\n\n\tif ((error = mcd_setmode(sc, MCD_MD_COOKED)) != 0)\n\t\treturn error;\n\n\tmbx.cmd = sc->lastpb;\n\tmbx.res.length = 0;\n\treturn mcd_send(sc, &mbx, 1);\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int mcd_resume",
            "int mcd_send",
            "int mcd_setmode"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint mcd_resume;\nint mcd_send;\nint mcd_setmode;\n\nint\nmcd_resume(sc)\n\tstruct mcd_softc *sc;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (sc->audio_status != CD_AS_PLAY_PAUSED)\n\t\treturn EINVAL;\n\n\tif ((error = mcd_setmode(sc, MCD_MD_COOKED)) != 0)\n\t\treturn error;\n\n\tmbx.cmd = sc->lastpb;\n\tmbx.res.length = 0;\n\treturn mcd_send(sc, &mbx, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mcd_toc_entries",
          "args": [
            "sc",
            "(struct ioc_read_toc_entry *)addr"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_toc_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1434-1501",
          "snippet": "int\nmcd_toc_entries(sc, te)\n\tstruct mcd_softc *sc;\n\tstruct ioc_read_toc_entry *te;\n{\n\tint len = te->data_len;\n\tstruct ret_toc {\n\t\tstruct ioc_toc_header header;\n\t\tstruct cd_toc_entry entries[MCD_MAXTOCS];\n\t} data;\n\tu_char trk;\n\tdaddr_t lba;\n\tint error, n;\n\n\tif (len > sizeof(data.entries) ||\n\t    len < sizeof(struct cd_toc_entry))\n\t\treturn EINVAL;\n\tif (te->address_format != CD_MSF_FORMAT &&\n\t    te->address_format != CD_LBA_FORMAT)\n\t\treturn EINVAL;\n\n\t/* Copy the TOC header. */\n\tif ((error = mcd_toc_header(sc, &data.header)) != 0)\n\t\treturn error;\n\n\t/* Verify starting track. */\n\ttrk = te->starting_track;\n\tif (trk == 0x00)\n\t\ttrk = data.header.starting_track;\n\telse if (trk == 0xaa)\n\t\ttrk = data.header.ending_track + 1;\n\telse if (trk < data.header.starting_track ||\n\t\t trk > data.header.ending_track + 1)\n\t\treturn EINVAL;\n\n\t/* Copy the TOC data. */\n\tfor (n = 0; trk <= data.header.ending_track + 1; trk++) {\n\t\tif (sc->toc[trk].toc.idx_no == 0x00)\n\t\t\tcontinue;\n\t\tdata.entries[n].control = sc->toc[trk].toc.control;\n\t\tdata.entries[n].addr_type = sc->toc[trk].toc.addr_type;\n\t\tdata.entries[n].track = bcd2bin(sc->toc[trk].toc.idx_no);\n\t\tswitch (te->address_format) {\n\t\tcase CD_MSF_FORMAT:\n\t\t\tdata.entries[n].addr.addr[0] = 0;\n\t\t\tdata.entries[n].addr.addr[1] =\n\t\t\t    bcd2bin(sc->toc[trk].toc.absolute_pos[0]);\n\t\t\tdata.entries[n].addr.addr[2] =\n\t\t\t    bcd2bin(sc->toc[trk].toc.absolute_pos[1]);\n\t\t\tdata.entries[n].addr.addr[3] =\n\t\t\t    bcd2bin(sc->toc[trk].toc.absolute_pos[2]);\n\t\t\tbreak;\n\t\tcase CD_LBA_FORMAT:\n\t\t\tlba = msf2hsg(sc->toc[trk].toc.absolute_pos, 0);\n\t\t\tdata.entries[n].addr.addr[0] = lba >> 24;\n\t\t\tdata.entries[n].addr.addr[1] = lba >> 16;\n\t\t\tdata.entries[n].addr.addr[2] = lba >> 8;\n\t\t\tdata.entries[n].addr.addr[3] = lba;\n\t\t\tbreak;\n\t\t}\n\t\tn++;\n\t}\n\n\tlen = min(len, n * sizeof(struct cd_toc_entry));\n\n\t/* Copy the data back. */\n\treturn copyout(&data.entries[0], te->data, len);\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MCD_MAXTOCS\t104\t/* from the Linux driver */"
          ],
          "globals_used": [
            "static daddr_t msf2hsg",
            "int mcd_toc_header",
            "int mcd_toc_entries"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MCD_MAXTOCS\t104\t/* from the Linux driver */\n\nstatic daddr_t msf2hsg;\nint mcd_toc_header;\nint mcd_toc_entries;\n\nint\nmcd_toc_entries(sc, te)\n\tstruct mcd_softc *sc;\n\tstruct ioc_read_toc_entry *te;\n{\n\tint len = te->data_len;\n\tstruct ret_toc {\n\t\tstruct ioc_toc_header header;\n\t\tstruct cd_toc_entry entries[MCD_MAXTOCS];\n\t} data;\n\tu_char trk;\n\tdaddr_t lba;\n\tint error, n;\n\n\tif (len > sizeof(data.entries) ||\n\t    len < sizeof(struct cd_toc_entry))\n\t\treturn EINVAL;\n\tif (te->address_format != CD_MSF_FORMAT &&\n\t    te->address_format != CD_LBA_FORMAT)\n\t\treturn EINVAL;\n\n\t/* Copy the TOC header. */\n\tif ((error = mcd_toc_header(sc, &data.header)) != 0)\n\t\treturn error;\n\n\t/* Verify starting track. */\n\ttrk = te->starting_track;\n\tif (trk == 0x00)\n\t\ttrk = data.header.starting_track;\n\telse if (trk == 0xaa)\n\t\ttrk = data.header.ending_track + 1;\n\telse if (trk < data.header.starting_track ||\n\t\t trk > data.header.ending_track + 1)\n\t\treturn EINVAL;\n\n\t/* Copy the TOC data. */\n\tfor (n = 0; trk <= data.header.ending_track + 1; trk++) {\n\t\tif (sc->toc[trk].toc.idx_no == 0x00)\n\t\t\tcontinue;\n\t\tdata.entries[n].control = sc->toc[trk].toc.control;\n\t\tdata.entries[n].addr_type = sc->toc[trk].toc.addr_type;\n\t\tdata.entries[n].track = bcd2bin(sc->toc[trk].toc.idx_no);\n\t\tswitch (te->address_format) {\n\t\tcase CD_MSF_FORMAT:\n\t\t\tdata.entries[n].addr.addr[0] = 0;\n\t\t\tdata.entries[n].addr.addr[1] =\n\t\t\t    bcd2bin(sc->toc[trk].toc.absolute_pos[0]);\n\t\t\tdata.entries[n].addr.addr[2] =\n\t\t\t    bcd2bin(sc->toc[trk].toc.absolute_pos[1]);\n\t\t\tdata.entries[n].addr.addr[3] =\n\t\t\t    bcd2bin(sc->toc[trk].toc.absolute_pos[2]);\n\t\t\tbreak;\n\t\tcase CD_LBA_FORMAT:\n\t\t\tlba = msf2hsg(sc->toc[trk].toc.absolute_pos, 0);\n\t\t\tdata.entries[n].addr.addr[0] = lba >> 24;\n\t\t\tdata.entries[n].addr.addr[1] = lba >> 16;\n\t\t\tdata.entries[n].addr.addr[2] = lba >> 8;\n\t\t\tdata.entries[n].addr.addr[3] = lba;\n\t\t\tbreak;\n\t\t}\n\t\tn++;\n\t}\n\n\tlen = min(len, n * sizeof(struct cd_toc_entry));\n\n\t/* Copy the data back. */\n\treturn copyout(&data.entries[0], te->data, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mcd_toc_header",
          "args": [
            "sc",
            "(struct ioc_toc_header *)addr"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_toc_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1363-1378",
          "snippet": "int\nmcd_toc_header(sc, th)\n\tstruct mcd_softc *sc;\n\tstruct ioc_toc_header *th;\n{\n\n\tif (sc->debug)\n\t\tprintf(\"%s: mcd_toc_header: reading toc header\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\n\tth->len = msf2hsg(sc->volinfo.vol_msf, 0);\n\tth->starting_track = bcd2bin(sc->volinfo.trk_low);\n\tth->ending_track = bcd2bin(sc->volinfo.trk_high);\n\n\treturn 0;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static daddr_t msf2hsg",
            "int mcd_toc_header"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic daddr_t msf2hsg;\nint mcd_toc_header;\n\nint\nmcd_toc_header(sc, th)\n\tstruct mcd_softc *sc;\n\tstruct ioc_toc_header *th;\n{\n\n\tif (sc->debug)\n\t\tprintf(\"%s: mcd_toc_header: reading toc header\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\n\tth->len = msf2hsg(sc->volinfo.vol_msf, 0);\n\tth->starting_track = bcd2bin(sc->volinfo.trk_low);\n\tth->ending_track = bcd2bin(sc->volinfo.trk_high);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mcd_read_subchannel",
          "args": [
            "sc",
            "(struct ioc_read_subchannel *)addr"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_read_subchannel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1557-1640",
          "snippet": "int\nmcd_read_subchannel(sc, ch)\n\tstruct mcd_softc *sc;\n\tstruct ioc_read_subchannel *ch;\n{\n\tint len = ch->data_len;\n\tunion mcd_qchninfo q;\n\tstruct cd_sub_channel_info data;\n\tdaddr_t lba;\n\tint error;\n\n\tif (sc->debug)\n\t\tprintf(\"%s: subchan: af=%d df=%d\\n\", sc->sc_dev.dv_xname,\n\t\t    ch->address_format, ch->data_format);\n\n\tif (len > sizeof(data) ||\n\t    len < sizeof(struct cd_sub_channel_header))\n\t\treturn EINVAL;\n\tif (ch->address_format != CD_MSF_FORMAT &&\n\t    ch->address_format != CD_LBA_FORMAT)\n\t\treturn EINVAL;\n\tif (ch->data_format != CD_CURRENT_POSITION &&\n\t    ch->data_format != CD_MEDIA_CATALOG)\n\t\treturn EINVAL;\n\n\tif ((error = mcd_getqchan(sc, &q, ch->data_format)) != 0)\n\t\treturn error;\n\n\tdata.header.audio_status = sc->audio_status;\n\tdata.what.media_catalog.data_format = ch->data_format;\n\n\tswitch (ch->data_format) {\n\tcase CD_MEDIA_CATALOG:\n\t\tdata.what.media_catalog.mc_valid = 1;\n#if 0\n\t\tdata.what.media_catalog.mc_number = \n#endif\n\t\tbreak;\n\n\tcase CD_CURRENT_POSITION:\n\t\tdata.what.position.track_number = bcd2bin(q.current.trk_no);\n\t\tdata.what.position.index_number = bcd2bin(q.current.idx_no);\n\t\tswitch (ch->address_format) {\n\t\tcase CD_MSF_FORMAT:\n\t\t\tdata.what.position.reladdr.addr[0] = 0;\n\t\t\tdata.what.position.reladdr.addr[1] =\n\t\t\t    bcd2bin(q.current.relative_pos[0]);\n\t\t\tdata.what.position.reladdr.addr[2] =\n\t\t\t    bcd2bin(q.current.relative_pos[1]);\n\t\t\tdata.what.position.reladdr.addr[3] =\n\t\t\t    bcd2bin(q.current.relative_pos[2]);\n\t\t\tdata.what.position.absaddr.addr[0] = 0;\n\t\t\tdata.what.position.absaddr.addr[1] =\n\t\t\t    bcd2bin(q.current.absolute_pos[0]);\n\t\t\tdata.what.position.absaddr.addr[2] =\n\t\t\t    bcd2bin(q.current.absolute_pos[1]);\n\t\t\tdata.what.position.absaddr.addr[3] =\n\t\t\t    bcd2bin(q.current.absolute_pos[2]);\n\t\t\tbreak;\n\t\tcase CD_LBA_FORMAT:\n\t\t\tlba = msf2hsg(q.current.relative_pos, 1);\n\t\t\t/*\n\t\t\t * Pre-gap has index number of 0, and decreasing MSF\n\t\t\t * address.  Must be converted to negative LBA, per\n\t\t\t * SCSI spec.\n\t\t\t */\n\t\t\tif (data.what.position.index_number == 0x00)\n\t\t\t\tlba = -lba;\n\t\t\tdata.what.position.reladdr.addr[0] = lba >> 24;\n\t\t\tdata.what.position.reladdr.addr[1] = lba >> 16;\n\t\t\tdata.what.position.reladdr.addr[2] = lba >> 8;\n\t\t\tdata.what.position.reladdr.addr[3] = lba;\n\t\t\tlba = msf2hsg(q.current.absolute_pos, 0);\n\t\t\tdata.what.position.absaddr.addr[0] = lba >> 24;\n\t\t\tdata.what.position.absaddr.addr[1] = lba >> 16;\n\t\t\tdata.what.position.absaddr.addr[2] = lba >> 8;\n\t\t\tdata.what.position.absaddr.addr[3] = lba;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn copyout(&data, ch->data, len);\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static daddr_t msf2hsg",
            "int mcd_read_subchannel",
            "int mcd_getqchan"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic daddr_t msf2hsg;\nint mcd_read_subchannel;\nint mcd_getqchan;\n\nint\nmcd_read_subchannel(sc, ch)\n\tstruct mcd_softc *sc;\n\tstruct ioc_read_subchannel *ch;\n{\n\tint len = ch->data_len;\n\tunion mcd_qchninfo q;\n\tstruct cd_sub_channel_info data;\n\tdaddr_t lba;\n\tint error;\n\n\tif (sc->debug)\n\t\tprintf(\"%s: subchan: af=%d df=%d\\n\", sc->sc_dev.dv_xname,\n\t\t    ch->address_format, ch->data_format);\n\n\tif (len > sizeof(data) ||\n\t    len < sizeof(struct cd_sub_channel_header))\n\t\treturn EINVAL;\n\tif (ch->address_format != CD_MSF_FORMAT &&\n\t    ch->address_format != CD_LBA_FORMAT)\n\t\treturn EINVAL;\n\tif (ch->data_format != CD_CURRENT_POSITION &&\n\t    ch->data_format != CD_MEDIA_CATALOG)\n\t\treturn EINVAL;\n\n\tif ((error = mcd_getqchan(sc, &q, ch->data_format)) != 0)\n\t\treturn error;\n\n\tdata.header.audio_status = sc->audio_status;\n\tdata.what.media_catalog.data_format = ch->data_format;\n\n\tswitch (ch->data_format) {\n\tcase CD_MEDIA_CATALOG:\n\t\tdata.what.media_catalog.mc_valid = 1;\n#if 0\n\t\tdata.what.media_catalog.mc_number = \n#endif\n\t\tbreak;\n\n\tcase CD_CURRENT_POSITION:\n\t\tdata.what.position.track_number = bcd2bin(q.current.trk_no);\n\t\tdata.what.position.index_number = bcd2bin(q.current.idx_no);\n\t\tswitch (ch->address_format) {\n\t\tcase CD_MSF_FORMAT:\n\t\t\tdata.what.position.reladdr.addr[0] = 0;\n\t\t\tdata.what.position.reladdr.addr[1] =\n\t\t\t    bcd2bin(q.current.relative_pos[0]);\n\t\t\tdata.what.position.reladdr.addr[2] =\n\t\t\t    bcd2bin(q.current.relative_pos[1]);\n\t\t\tdata.what.position.reladdr.addr[3] =\n\t\t\t    bcd2bin(q.current.relative_pos[2]);\n\t\t\tdata.what.position.absaddr.addr[0] = 0;\n\t\t\tdata.what.position.absaddr.addr[1] =\n\t\t\t    bcd2bin(q.current.absolute_pos[0]);\n\t\t\tdata.what.position.absaddr.addr[2] =\n\t\t\t    bcd2bin(q.current.absolute_pos[1]);\n\t\t\tdata.what.position.absaddr.addr[3] =\n\t\t\t    bcd2bin(q.current.absolute_pos[2]);\n\t\t\tbreak;\n\t\tcase CD_LBA_FORMAT:\n\t\t\tlba = msf2hsg(q.current.relative_pos, 1);\n\t\t\t/*\n\t\t\t * Pre-gap has index number of 0, and decreasing MSF\n\t\t\t * address.  Must be converted to negative LBA, per\n\t\t\t * SCSI spec.\n\t\t\t */\n\t\t\tif (data.what.position.index_number == 0x00)\n\t\t\t\tlba = -lba;\n\t\t\tdata.what.position.reladdr.addr[0] = lba >> 24;\n\t\t\tdata.what.position.reladdr.addr[1] = lba >> 16;\n\t\t\tdata.what.position.reladdr.addr[2] = lba >> 8;\n\t\t\tdata.what.position.reladdr.addr[3] = lba;\n\t\t\tlba = msf2hsg(q.current.absolute_pos, 0);\n\t\t\tdata.what.position.absaddr.addr[0] = lba >> 24;\n\t\t\tdata.what.position.absaddr.addr[1] = lba >> 16;\n\t\t\tdata.what.position.absaddr.addr[2] = lba >> 8;\n\t\t\tdata.what.position.absaddr.addr[3] = lba;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn copyout(&data, ch->data, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mcd_playblocks",
          "args": [
            "sc",
            "(struct ioc_play_blocks *)addr"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_playblocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1714-1740",
          "snippet": "int\nmcd_playblocks(sc, p)\n\tstruct mcd_softc *sc;\n\tstruct ioc_play_blocks *p;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (sc->debug)\n\t\tprintf(\"%s: playblocks: blkno %d length %d\\n\",\n\t\t    sc->sc_dev.dv_xname, p->blk, p->len);\n\n\tif (p->blk > sc->disksize || p->len > sc->disksize ||\n\t    (p->blk + p->len) > sc->disksize)\n\t\treturn 0;\n\n\tif ((error = mcd_setmode(sc, MCD_MD_COOKED)) != 0)\n\t\treturn error;\n\n\tmbx.cmd.opcode = MCD_CMDREADSINGLESPEED;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.play);\n\thsg2msf(p->blk, mbx.cmd.data.play.start_msf);\n\thsg2msf(p->blk + p->len, mbx.cmd.data.play.end_msf);\n\tsc->lastpb = mbx.cmd;\n\tmbx.res.length = 0;\n\treturn mcd_send(sc, &mbx, 1);\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void hsg2msf",
            "int mcd_playblocks",
            "int mcd_send",
            "int mcd_setmode"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void hsg2msf;\nint mcd_playblocks;\nint mcd_send;\nint mcd_setmode;\n\nint\nmcd_playblocks(sc, p)\n\tstruct mcd_softc *sc;\n\tstruct ioc_play_blocks *p;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (sc->debug)\n\t\tprintf(\"%s: playblocks: blkno %d length %d\\n\",\n\t\t    sc->sc_dev.dv_xname, p->blk, p->len);\n\n\tif (p->blk > sc->disksize || p->len > sc->disksize ||\n\t    (p->blk + p->len) > sc->disksize)\n\t\treturn 0;\n\n\tif ((error = mcd_setmode(sc, MCD_MD_COOKED)) != 0)\n\t\treturn error;\n\n\tmbx.cmd.opcode = MCD_CMDREADSINGLESPEED;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.play);\n\thsg2msf(p->blk, mbx.cmd.data.play.start_msf);\n\thsg2msf(p->blk + p->len, mbx.cmd.data.play.end_msf);\n\tsc->lastpb = mbx.cmd;\n\tmbx.res.length = 0;\n\treturn mcd_send(sc, &mbx, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mcd_playmsf",
          "args": [
            "sc",
            "(struct ioc_play_msf *)addr"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_playmsf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1680-1712",
          "snippet": "int\nmcd_playmsf(sc, p)\n\tstruct mcd_softc *sc;\n\tstruct ioc_play_msf *p;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (sc->debug)\n\t\tprintf(\"%s: playmsf: from %d:%d.%d to %d:%d.%d\\n\",\n\t\t    sc->sc_dev.dv_xname,\n\t\t    p->start_m, p->start_s, p->start_f,\n\t\t    p->end_m, p->end_s, p->end_f);\n\n\tif ((p->start_m * 60 * 75 + p->start_s * 75 + p->start_f) >=\n\t    (p->end_m * 60 * 75 + p->end_s * 75 + p->end_f))\n\t\treturn EINVAL;\n\n\tif ((error = mcd_setmode(sc, MCD_MD_COOKED)) != 0)\n\t\treturn error;\n\n\tmbx.cmd.opcode = MCD_CMDREADSINGLESPEED;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.play);\n\tmbx.cmd.data.play.start_msf[0] = bin2bcd(p->start_m);\n\tmbx.cmd.data.play.start_msf[1] = bin2bcd(p->start_s);\n\tmbx.cmd.data.play.start_msf[2] = bin2bcd(p->start_f);\n\tmbx.cmd.data.play.end_msf[0] = bin2bcd(p->end_m);\n\tmbx.cmd.data.play.end_msf[1] = bin2bcd(p->end_s);\n\tmbx.cmd.data.play.end_msf[2] = bin2bcd(p->end_f);\n\tsc->lastpb = mbx.cmd;\n\tmbx.res.length = 0;\n\treturn mcd_send(sc, &mbx, 1);\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int mcd_playmsf",
            "int mcd_send",
            "int mcd_setmode"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint mcd_playmsf;\nint mcd_send;\nint mcd_setmode;\n\nint\nmcd_playmsf(sc, p)\n\tstruct mcd_softc *sc;\n\tstruct ioc_play_msf *p;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (sc->debug)\n\t\tprintf(\"%s: playmsf: from %d:%d.%d to %d:%d.%d\\n\",\n\t\t    sc->sc_dev.dv_xname,\n\t\t    p->start_m, p->start_s, p->start_f,\n\t\t    p->end_m, p->end_s, p->end_f);\n\n\tif ((p->start_m * 60 * 75 + p->start_s * 75 + p->start_f) >=\n\t    (p->end_m * 60 * 75 + p->end_s * 75 + p->end_f))\n\t\treturn EINVAL;\n\n\tif ((error = mcd_setmode(sc, MCD_MD_COOKED)) != 0)\n\t\treturn error;\n\n\tmbx.cmd.opcode = MCD_CMDREADSINGLESPEED;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.play);\n\tmbx.cmd.data.play.start_msf[0] = bin2bcd(p->start_m);\n\tmbx.cmd.data.play.start_msf[1] = bin2bcd(p->start_s);\n\tmbx.cmd.data.play.start_msf[2] = bin2bcd(p->start_f);\n\tmbx.cmd.data.play.end_msf[0] = bin2bcd(p->end_m);\n\tmbx.cmd.data.play.end_msf[1] = bin2bcd(p->end_s);\n\tmbx.cmd.data.play.end_msf[2] = bin2bcd(p->end_f);\n\tsc->lastpb = mbx.cmd;\n\tmbx.res.length = 0;\n\treturn mcd_send(sc, &mbx, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mcd_playtracks",
          "args": [
            "sc",
            "(struct ioc_play_track *)addr"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_playtracks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1642-1678",
          "snippet": "int\nmcd_playtracks(sc, p)\n\tstruct mcd_softc *sc;\n\tstruct ioc_play_track *p;\n{\n\tstruct mcd_mbox mbx;\n\tint a = p->start_track;\n\tint z = p->end_track;\n\tint error;\n\n\tif (sc->debug)\n\t\tprintf(\"%s: playtracks: from %d:%d to %d:%d\\n\",\n\t\t    sc->sc_dev.dv_xname,\n\t\t    a, p->start_index, z, p->end_index);\n\n\tif (a < bcd2bin(sc->volinfo.trk_low) ||\n\t    a > bcd2bin(sc->volinfo.trk_high) ||\n\t    a > z ||\n\t    z < bcd2bin(sc->volinfo.trk_low) ||\n\t    z > bcd2bin(sc->volinfo.trk_high))\n\t\treturn EINVAL;\n\n\tif ((error = mcd_setmode(sc, MCD_MD_COOKED)) != 0)\n\t\treturn error;\n\n\tmbx.cmd.opcode = MCD_CMDREADSINGLESPEED;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.play);\n\tmbx.cmd.data.play.start_msf[0] = sc->toc[a].toc.absolute_pos[0];\n\tmbx.cmd.data.play.start_msf[1] = sc->toc[a].toc.absolute_pos[1];\n\tmbx.cmd.data.play.start_msf[2] = sc->toc[a].toc.absolute_pos[2];\n\tmbx.cmd.data.play.end_msf[0] = sc->toc[z+1].toc.absolute_pos[0];\n\tmbx.cmd.data.play.end_msf[1] = sc->toc[z+1].toc.absolute_pos[1];\n\tmbx.cmd.data.play.end_msf[2] = sc->toc[z+1].toc.absolute_pos[2];\n\tsc->lastpb = mbx.cmd;\n\tmbx.res.length = 0;\n\treturn mcd_send(sc, &mbx, 1);\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int mcd_playtracks",
            "int mcd_send",
            "int mcd_setmode"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint mcd_playtracks;\nint mcd_send;\nint mcd_setmode;\n\nint\nmcd_playtracks(sc, p)\n\tstruct mcd_softc *sc;\n\tstruct ioc_play_track *p;\n{\n\tstruct mcd_mbox mbx;\n\tint a = p->start_track;\n\tint z = p->end_track;\n\tint error;\n\n\tif (sc->debug)\n\t\tprintf(\"%s: playtracks: from %d:%d to %d:%d\\n\",\n\t\t    sc->sc_dev.dv_xname,\n\t\t    a, p->start_index, z, p->end_index);\n\n\tif (a < bcd2bin(sc->volinfo.trk_low) ||\n\t    a > bcd2bin(sc->volinfo.trk_high) ||\n\t    a > z ||\n\t    z < bcd2bin(sc->volinfo.trk_low) ||\n\t    z > bcd2bin(sc->volinfo.trk_high))\n\t\treturn EINVAL;\n\n\tif ((error = mcd_setmode(sc, MCD_MD_COOKED)) != 0)\n\t\treturn error;\n\n\tmbx.cmd.opcode = MCD_CMDREADSINGLESPEED;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.play);\n\tmbx.cmd.data.play.start_msf[0] = sc->toc[a].toc.absolute_pos[0];\n\tmbx.cmd.data.play.start_msf[1] = sc->toc[a].toc.absolute_pos[1];\n\tmbx.cmd.data.play.start_msf[2] = sc->toc[a].toc.absolute_pos[2];\n\tmbx.cmd.data.play.end_msf[0] = sc->toc[z+1].toc.absolute_pos[0];\n\tmbx.cmd.data.play.end_msf[1] = sc->toc[z+1].toc.absolute_pos[1];\n\tmbx.cmd.data.play.end_msf[2] = sc->toc[z+1].toc.absolute_pos[2];\n\tsc->lastpb = mbx.cmd;\n\tmbx.res.length = 0;\n\treturn mcd_send(sc, &mbx, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mcdunlock",
          "args": [
            "sc"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "mcdunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "302-312",
          "snippet": "void\nmcdunlock(sc)\n\tstruct mcd_softc *sc;\n{\n\n\tsc->flags &= ~MCDF_LOCKED;\n\tif ((sc->flags & MCDF_WANTED) != 0) {\n\t\tsc->flags &= ~MCDF_WANTED;\n\t\twakeup(sc);\n\t}\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tMCDF_WANTED\t0x02",
            "#define\tMCDF_LOCKED\t0x01"
          ],
          "globals_used": [
            "void\tmcdunlock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tMCDF_WANTED\t0x02\n#define\tMCDF_LOCKED\t0x01\n\nvoid\tmcdunlock;\n\nvoid\nmcdunlock(sc)\n\tstruct mcd_softc *sc;\n{\n\n\tsc->flags &= ~MCDF_LOCKED;\n\tif ((sc->flags & MCDF_WANTED) != 0) {\n\t\tsc->flags &= ~MCDF_WANTED;\n\t\twakeup(sc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setdisklabel",
          "args": [
            "sc->sc_dk.dk_label",
            "(struct disklabel *)addr",
            "/*sc->sc_dk.dk_openmask : */0",
            "sc->sc_dk.dk_cpulabel"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mcdlock",
          "args": [
            "sc"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "mcdlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "284-297",
          "snippet": "int\nmcdlock(sc)\n\tstruct mcd_softc *sc;\n{\n\tint error;\n\n\twhile ((sc->flags & MCDF_LOCKED) != 0) {\n\t\tsc->flags |= MCDF_WANTED;\n\t\tif ((error = tsleep(sc, PRIBIO | PCATCH, \"mcdlck\", 0)) != 0)\n\t\t\treturn error;\n\t}\n\tsc->flags |= MCDF_LOCKED;\n\treturn 0;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tMCDF_WANTED\t0x02",
            "#define\tMCDF_LOCKED\t0x01"
          ],
          "globals_used": [
            "int\tmcdlock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tMCDF_WANTED\t0x02\n#define\tMCDF_LOCKED\t0x01\n\nint\tmcdlock;\n\nint\nmcdlock(sc)\n\tstruct mcd_softc *sc;\n{\n\tint error;\n\n\twhile ((sc->flags & MCDF_LOCKED) != 0) {\n\t\tsc->flags |= MCDF_WANTED;\n\t\tif ((error = tsleep(sc, PRIBIO | PCATCH, \"mcdlck\", 0)) != 0)\n\t\t\treturn error;\n\t}\n\tsc->flags |= MCDF_LOCKED;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MCDPART",
          "args": [
            "dev"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mcdgetdisklabel",
          "args": [
            "dev",
            "sc",
            "sc->sc_dk.dk_label",
            "sc->sc_dk.dk_cpulabel",
            "0"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "mcdgetdisklabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "710-760",
          "snippet": "void\nmcdgetdisklabel(dev, sc, lp, clp, spoofonly)\n\tdev_t dev;\n\tstruct mcd_softc *sc;\n\tstruct disklabel *lp;\n\tstruct cpu_disklabel *clp;\n\tint spoofonly;\n{\n\tchar *errstring;\n\t\n\tbzero(lp, sizeof(struct disklabel));\n\tbzero(clp, sizeof(struct cpu_disklabel));\n\n\tlp->d_secsize = sc->blksize;\n\tlp->d_ntracks = 1;\n\tlp->d_nsectors = 100;\n\tlp->d_ncylinders = (sc->disksize / 100) + 1;\n\tlp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;\n\tif (lp->d_secpercyl == 0) {\n\t\tlp->d_secpercyl = 100;\n\t\t/* as long as it's not 0 - readdisklabel divides by it */\n\t}\n\n\tstrncpy(lp->d_typename, \"Mitsumi CD-ROM\", 16);\n\tlp->d_type = DTYPE_SCSI;\t/* XXX */\n\tstrncpy(lp->d_packname, \"fictitious\", 16);\n\tlp->d_secperunit = sc->disksize;\n\tlp->d_rpm = 300;\n\tlp->d_interleave = 1;\n\tlp->d_flags = D_REMOVABLE;\n\n\tlp->d_partitions[RAW_PART].p_offset = 0;\n\tlp->d_partitions[RAW_PART].p_size =\n\t    lp->d_secperunit * (lp->d_secsize / DEV_BSIZE);\n\tlp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;\n\tlp->d_npartitions = RAW_PART + 1;\n\n\tlp->d_magic = DISKMAGIC;\n\tlp->d_magic2 = DISKMAGIC;\n\tlp->d_checksum = dkcksum(lp);\n\n\t/*\n\t * Call the generic disklabel extraction routine\n\t */\n\terrstring = readdisklabel(MCDLABELDEV(dev), mcdstrategy, lp, clp,\n\t    spoofonly);\n\tif (errstring) {\n\t\t/*printf(\"%s: %s\\n\", sc->sc_dev.dv_xname, errstring);*/\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tmcdgetdisklabel",
            "void\tmcdstrategy"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tmcdgetdisklabel;\nvoid\tmcdstrategy;\n\nvoid\nmcdgetdisklabel(dev, sc, lp, clp, spoofonly)\n\tdev_t dev;\n\tstruct mcd_softc *sc;\n\tstruct disklabel *lp;\n\tstruct cpu_disklabel *clp;\n\tint spoofonly;\n{\n\tchar *errstring;\n\t\n\tbzero(lp, sizeof(struct disklabel));\n\tbzero(clp, sizeof(struct cpu_disklabel));\n\n\tlp->d_secsize = sc->blksize;\n\tlp->d_ntracks = 1;\n\tlp->d_nsectors = 100;\n\tlp->d_ncylinders = (sc->disksize / 100) + 1;\n\tlp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;\n\tif (lp->d_secpercyl == 0) {\n\t\tlp->d_secpercyl = 100;\n\t\t/* as long as it's not 0 - readdisklabel divides by it */\n\t}\n\n\tstrncpy(lp->d_typename, \"Mitsumi CD-ROM\", 16);\n\tlp->d_type = DTYPE_SCSI;\t/* XXX */\n\tstrncpy(lp->d_packname, \"fictitious\", 16);\n\tlp->d_secperunit = sc->disksize;\n\tlp->d_rpm = 300;\n\tlp->d_interleave = 1;\n\tlp->d_flags = D_REMOVABLE;\n\n\tlp->d_partitions[RAW_PART].p_offset = 0;\n\tlp->d_partitions[RAW_PART].p_size =\n\t    lp->d_secperunit * (lp->d_secsize / DEV_BSIZE);\n\tlp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;\n\tlp->d_npartitions = RAW_PART + 1;\n\n\tlp->d_magic = DISKMAGIC;\n\tlp->d_magic2 = DISKMAGIC;\n\tlp->d_checksum = dkcksum(lp);\n\n\t/*\n\t * Call the generic disklabel extraction routine\n\t */\n\terrstring = readdisklabel(MCDLABELDEV(dev), mcdstrategy, lp, clp,\n\t    spoofonly);\n\tif (errstring) {\n\t\t/*printf(\"%s: %s\\n\", sc->sc_dev.dv_xname, errstring);*/\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MCD_TRACE",
          "args": [
            "\"ioctl: cmd=0x%x\\n\"",
            "cmd",
            "0",
            "0",
            "0"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCDUNIT",
          "args": [
            "dev"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tMCDF_EJECTING\t0x20\t/* please eject at close */\n#define\tMCDF_LOADED\t0x10\t/* parameters loaded */\n#define\tMCDF_LABELLING\t0x08\t/* writing label */\n\nint mcd_playtracks;\nint mcd_playmsf;\nint mcd_playblocks;\nint mcd_stop;\nint mcd_read_subchannel;\nint mcd_pause;\nint mcd_resume;\nint mcd_toc_header;\nint mcd_toc_entries;\nint mcd_hard_reset;\nint mcd_setlock;\nstruct cfdriver mcd_cd = {\n\tNULL, \"mcd\", DV_DISK\n};\nvoid\tmcdgetdisklabel;\nint\tmcdlock;\nvoid\tmcdunlock;\n\nint\nmcdioctl(dev, cmd, addr, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t addr;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct mcd_softc *sc = mcd_cd.cd_devs[MCDUNIT(dev)];\n\tint error;\n\t\n\tMCD_TRACE(\"ioctl: cmd=0x%x\\n\", cmd, 0, 0, 0);\n\n\tif ((sc->flags & MCDF_LOADED) == 0)\n\t\treturn EIO;\n\n\tswitch (cmd) {\n\tcase DIOCRLDINFO:\n\t\tmcdgetdisklabel(dev, sc, sc->sc_dk.dk_label,\n\t\t    sc->sc_dk.dk_cpulabel, 0);\n\t\treturn 0;\n\tcase DIOCGDINFO:\n\tcase DIOCGPDINFO:\n\t\t*(struct disklabel *)addr = *(sc->sc_dk.dk_label);\n\t\treturn 0;\n\n\tcase DIOCGPART:\n\t\t((struct partinfo *)addr)->disklab = sc->sc_dk.dk_label;\n\t\t((struct partinfo *)addr)->part =\n\t\t    &sc->sc_dk.dk_label->d_partitions[MCDPART(dev)];\n\t\treturn 0;\n\n\tcase DIOCWDINFO:\n\tcase DIOCSDINFO:\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn EBADF;\n\n\t\tif ((error = mcdlock(sc)) != 0)\n\t\t\treturn error;\n\t\tsc->flags |= MCDF_LABELLING;\n\n\t\terror = setdisklabel(sc->sc_dk.dk_label,\n\t\t    (struct disklabel *)addr, /*sc->sc_dk.dk_openmask : */0,\n\t\t    sc->sc_dk.dk_cpulabel);\n\t\tif (error == 0) {\n\t\t}\n\n\t\tsc->flags &= ~MCDF_LABELLING;\n\t\tmcdunlock(sc);\n\t\treturn error;\n\n\tcase DIOCWLABEL:\n\t\treturn EBADF;\n\n\tcase CDIOCPLAYTRACKS:\n\t\treturn mcd_playtracks(sc, (struct ioc_play_track *)addr);\n\tcase CDIOCPLAYMSF:\n\t\treturn mcd_playmsf(sc, (struct ioc_play_msf *)addr);\n\tcase CDIOCPLAYBLOCKS:\n\t\treturn mcd_playblocks(sc, (struct ioc_play_blocks *)addr);\n\tcase CDIOCREADSUBCHANNEL:\n\t\treturn mcd_read_subchannel(sc, (struct ioc_read_subchannel *)addr);\n\tcase CDIOREADTOCHEADER:\n\t\treturn mcd_toc_header(sc, (struct ioc_toc_header *)addr);\n\tcase CDIOREADTOCENTRYS:\n\t\treturn mcd_toc_entries(sc, (struct ioc_read_toc_entry *)addr);\n\tcase CDIOCSETPATCH:\n\tcase CDIOCGETVOL:\n\tcase CDIOCSETVOL:\n\tcase CDIOCSETMONO:\n\tcase CDIOCSETSTEREO:\n\tcase CDIOCSETMUTE:\n\tcase CDIOCSETLEFT:\n\tcase CDIOCSETRIGHT:\n\t\treturn EINVAL;\n\tcase CDIOCRESUME:\n\t\treturn mcd_resume(sc);\n\tcase CDIOCPAUSE:\n\t\treturn mcd_pause(sc);\n\tcase CDIOCSTART:\n\t\treturn EINVAL;\n\tcase CDIOCSTOP:\n\t\treturn mcd_stop(sc);\n\tcase MTIOCTOP:\n\t\tif (((struct mtop *)addr)->mt_op != MTOFFL)\n\t\t\treturn EIO;\n\t\t/* FALLTHROUGH */\n\tcase CDIOCEJECT: /* FALLTHROUGH */\n\tcase DIOCEJECT:\n\t\tsc->flags |= MCDF_EJECTING;\n\t\treturn (0);\n\tcase CDIOCALLOW:\n\t\treturn mcd_setlock(sc, MCD_LK_UNLOCK);\n\tcase CDIOCPREVENT:\n\t\treturn mcd_setlock(sc, MCD_LK_LOCK);\n\tcase DIOCLOCK:\n\t\treturn mcd_setlock(sc,\n\t\t    (*(int *)addr) ? MCD_LK_LOCK : MCD_LK_UNLOCK);\n\tcase CDIOCSETDEBUG:\n\t\tsc->debug = 1;\n\t\treturn 0;\n\tcase CDIOCCLRDEBUG:\n\t\tsc->debug = 0;\n\t\treturn 0;\n\tcase CDIOCRESET:\n\t\treturn mcd_hard_reset(sc);\n\n\tdefault:\n\t\treturn ENOTTY;\n\t}\n\n#ifdef DIAGNOSTIC\n\tpanic(\"mcdioctl: impossible\");\n#endif\n}"
  },
  {
    "function_name": "mcdwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
    "lines": "584-592",
    "snippet": "int\nmcdwrite(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\n\treturn (physio(mcdstrategy, NULL, dev, B_WRITE, minphys, uio));\n}",
    "includes": [
      "#include <lib/libkern/libkern.h>",
      "#include <dev/isa/opti.h>",
      "#include <dev/isa/mcdreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/errno.h>",
      "#include <sys/cdio.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/uio.h>",
      "#include <sys/stat.h>",
      "#include <sys/buf.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tmcdstrategy"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "physio",
          "args": [
            "mcdstrategy",
            "NULL",
            "dev",
            "B_WRITE",
            "minphys",
            "uio"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tmcdstrategy;\n\nint\nmcdwrite(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\n\treturn (physio(mcdstrategy, NULL, dev, B_WRITE, minphys, uio));\n}"
  },
  {
    "function_name": "mcdread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
    "lines": "574-582",
    "snippet": "int\nmcdread(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\n\treturn (physio(mcdstrategy, NULL, dev, B_READ, minphys, uio));\n}",
    "includes": [
      "#include <lib/libkern/libkern.h>",
      "#include <dev/isa/opti.h>",
      "#include <dev/isa/mcdreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/errno.h>",
      "#include <sys/cdio.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/uio.h>",
      "#include <sys/stat.h>",
      "#include <sys/buf.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tmcdstrategy"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "physio",
          "args": [
            "mcdstrategy",
            "NULL",
            "dev",
            "B_READ",
            "minphys",
            "uio"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tmcdstrategy;\n\nint\nmcdread(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\n\treturn (physio(mcdstrategy, NULL, dev, B_READ, minphys, uio));\n}"
  },
  {
    "function_name": "mcdstart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
    "lines": "516-572",
    "snippet": "void\nmcdstart(sc)\n\tstruct mcd_softc *sc;\n{\n\tstruct buf *bp, *dp = &sc->buf_queue;\n\tint s;\n\t\nloop:\n\ts = splbio();\n\n\tbp = dp->b_actf;\n\tif (bp == NULL) {\n\t\t/* Nothing to do. */\n\t\tdp->b_active = 0;\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Block found to process; dequeue. */\n\tMCD_TRACE(\"start: found block bp=0x%x\\n\", bp, 0, 0, 0);\n\tdp->b_actf = bp->b_actf;\n\tsplx(s);\n\n\t/* Changed media? */\n\tif ((sc->flags & MCDF_LOADED) == 0) {\n\t\tMCD_TRACE(\"start: drive not valid\\n\", 0, 0, 0, 0);\n\t\tbp->b_error = EIO;\n\t\tbp->b_flags |= B_ERROR;\n\t\tbiodone(bp);\n\t\tgoto loop;\n\t}\n\n\tdp->b_active = 1;\n\n\t/* Instrumentation. */\n\ts = splbio();\n\tdisk_busy(&sc->sc_dk);\n\tsplx(s);\n\n\tsc->mbx.retry = MCD_RDRETRIES;\n\tsc->mbx.bp = bp;\n\tsc->mbx.blkno = bp->b_blkno / (sc->blksize / DEV_BSIZE);\n\tif (MCDPART(bp->b_dev) != RAW_PART) {\n\t\tstruct partition *p;\n\t\tp = &sc->sc_dk.dk_label->d_partitions[MCDPART(bp->b_dev)];\n\t\tsc->mbx.blkno += p->p_offset;\n\t}\n\tsc->mbx.nblk = bp->b_bcount / sc->blksize;\n\tsc->mbx.sz = sc->blksize;\n\tsc->mbx.skip = 0;\n\tsc->mbx.state = MCD_S_BEGIN;\n\tsc->mbx.mode = MCD_MD_COOKED;\n\n\ts = splbio();\n\t(void) mcdintr(sc);\n\tsplx(s);\n}",
    "includes": [
      "#include <lib/libkern/libkern.h>",
      "#include <dev/isa/opti.h>",
      "#include <dev/isa/mcdreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/errno.h>",
      "#include <sys/cdio.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/uio.h>",
      "#include <sys/stat.h>",
      "#include <sys/buf.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define MCD_RDRETRIES\t3",
      "#define\tMCDF_LOADED\t0x10\t/* parameters loaded */",
      "#define MCD_S_BEGIN\t1"
    ],
    "globals_used": [
      "int mcdintr",
      "void\tmcdstart"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mcdintr",
          "args": [
            "sc"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "mcdintr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1126-1283",
          "snippet": "int\nmcdintr(arg)\n\tvoid *arg;\n{\n\tstruct mcd_softc *sc = arg;\n\tstruct mcd_mbx *mbx = &sc->mbx;\n\tstruct buf *bp = mbx->bp;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tint i;\n\tu_char x;\n\tbcd_t msf[3];\n\n\tswitch (mbx->state) {\n\tcase MCD_S_IDLE:\n\t\treturn 0;\n\n\tcase MCD_S_BEGIN:\n\ttryagain:\n\t\tif (mbx->mode == sc->lastmode)\n\t\t\tgoto firstblock;\n\n\t\tsc->lastmode = MCD_MD_UNKNOWN;\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, MCD_CMDSETMODE);\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->mode);\n\n\t\tmbx->count = RDELAY_WAITMODE;\n\t\tmbx->state = MCD_S_WAITMODE;\n\n\tcase MCD_S_WAITMODE:\n\t\tuntimeout(mcd_pseudointr, sc);\n\t\tfor (i = 20; i; i--) {\n\t\t\tx = bus_space_read_1(iot, ioh, MCD_XFER);\n\t\t\tif ((x & MCD_XF_STATUSUNAVAIL) == 0)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (i == 0)\n\t\t\tgoto hold;\n\t\tsc->status = bus_space_read_1(iot, ioh, MCD_STATUS);\n\t\tmcd_setflags(sc);\n\t\tif ((sc->flags & MCDF_LOADED) == 0)\n\t\t\tgoto changed;\n\t\tMCD_TRACE(\"doread: got WAITMODE delay=%d\\n\",\n\t\t    RDELAY_WAITMODE - mbx->count, 0, 0, 0);\n\n\t\tsc->lastmode = mbx->mode;\n\n\tfirstblock:\n\t\tMCD_TRACE(\"doread: read blkno=%d for bp=0x%x\\n\", mbx->blkno,\n\t\t    bp, 0, 0);\n\n\t\t/* Build parameter block. */\n\t\thsg2msf(mbx->blkno, msf);\n\n\t\t/* Send the read command. */\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, sc->readcmd);\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, msf[0]);\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, msf[1]);\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, msf[2]);\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, 0);\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, 0);\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->nblk);\n\n\t\tmbx->count = RDELAY_WAITREAD;\n\t\tmbx->state = MCD_S_WAITREAD;\n\n\tcase MCD_S_WAITREAD:\n\t\tuntimeout(mcd_pseudointr, sc);\n\tnextblock:\n\tloop:\n\t\tfor (i = 20; i; i--) {\n\t\t\tx = bus_space_read_1(iot, ioh, MCD_XFER);\n\t\t\tif ((x & MCD_XF_DATAUNAVAIL) == 0)\n\t\t\t\tgoto gotblock;\n\t\t\tif ((x & MCD_XF_STATUSUNAVAIL) == 0)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (i == 0)\n\t\t\tgoto hold;\n\t\tsc->status = bus_space_read_1(iot, ioh, MCD_STATUS);\n\t\tmcd_setflags(sc);\n\t\tif ((sc->flags & MCDF_LOADED) == 0)\n\t\t\tgoto changed;\n#if 0\n\t\tprintf(\"%s: got status byte %02x during read\\n\",\n\t\t    sc->sc_dev.dv_xname, (u_int)sc->status);\n#endif\n\t\tgoto loop;\n\n\tgotblock:\n\t\tMCD_TRACE(\"doread: got data delay=%d\\n\",\n\t\t    RDELAY_WAITREAD - mbx->count, 0, 0, 0);\n\n\t\t/* Data is ready. */\n\t\tbus_space_write_1(iot, ioh, MCD_CTL2, 0x04);\t/* XXX */\n\t\tbus_space_read_multi_1(iot, ioh, MCD_RDATA,\n\t\t    bp->b_data + mbx->skip, mbx->sz);\n\t\tbus_space_write_1(iot, ioh, MCD_CTL2, 0x0c);\t/* XXX */\n\t\tmbx->blkno += 1;\n\t\tmbx->skip += mbx->sz;\n\t\tif (--mbx->nblk > 0)\n\t\t\tgoto nextblock;\n\n\t\tmbx->state = MCD_S_IDLE;\n\n\t\t/* Return buffer. */\n\t\tbp->b_resid = 0;\n\t\tdisk_unbusy(&sc->sc_dk, bp->b_bcount);\n\t\tbiodone(bp);\n\n\t\tmcdstart(sc);\n\t\treturn 1;\n\n\thold:\n\t\tif (mbx->count-- < 0) {\n\t\t\tprintf(\"%s: timeout in state %d\",\n\t\t\t    sc->sc_dev.dv_xname, mbx->state);\n\t\t\tgoto readerr;\n\t\t}\n\n#if 0\n\t\tprintf(\"%s: sleep in state %d\\n\", sc->sc_dev.dv_xname,\n\t\t    mbx->state);\n#endif\n\t\ttimeout(mcd_pseudointr, sc, hz / 100);\n\t\treturn -1;\n\t}\n\nreaderr:\n\tif (mbx->retry-- > 0) {\n\t\tprintf(\"; retrying\\n\");\n\t\tgoto tryagain;\n\t} else\n\t\tprintf(\"; giving up\\n\");\n\nchanged:\n\t/* Invalidate the buffer. */\n\tbp->b_flags |= B_ERROR;\n\tbp->b_resid = bp->b_bcount - mbx->skip;\n\tdisk_unbusy(&sc->sc_dk, (bp->b_bcount - bp->b_resid));\n\tbiodone(bp);\n\n\tmcdstart(sc);\n\treturn -1;\n\n#ifdef notyet\n\tprintf(\"%s: unit timeout; resetting\\n\", sc->sc_dev.dv_xname);\n\tbus_space_write_1(iot, ioh, MCD_RESET, MCD_CMDRESET);\n\tdelay(300000);\n\t(void) mcd_getstat(sc, 1);\n\t(void) mcd_getstat(sc, 1);\n\t/*sc->status &= ~MCD_ST_DSKCHNG; */\n\tsc->debug = 1; /* preventive set debug mode */\n#endif\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define RDELAY_WAITREAD\t800",
            "#define RDELAY_WAITMODE\t300",
            "#define\tMCD_MD_UNKNOWN\t-1",
            "#define\tMCDF_LOADED\t0x10\t/* parameters loaded */",
            "#define MCD_S_WAITREAD\t3",
            "#define MCD_S_WAITMODE\t2",
            "#define MCD_S_BEGIN\t1",
            "#define\tMCD_S_IDLE\t0"
          ],
          "globals_used": [
            "static void hsg2msf",
            "__P((int, bcd_t *));",
            "int mcd_getstat",
            "void mcd_setflags",
            "int mcdintr",
            "void\tmcdstart",
            "void\tmcd_pseudointr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define RDELAY_WAITREAD\t800\n#define RDELAY_WAITMODE\t300\n#define\tMCD_MD_UNKNOWN\t-1\n#define\tMCDF_LOADED\t0x10\t/* parameters loaded */\n#define MCD_S_WAITREAD\t3\n#define MCD_S_WAITMODE\t2\n#define MCD_S_BEGIN\t1\n#define\tMCD_S_IDLE\t0\n\nstatic void hsg2msf;\n__P((int, bcd_t *));\nint mcd_getstat;\nvoid mcd_setflags;\nint mcdintr;\nvoid\tmcdstart;\nvoid\tmcd_pseudointr;\n\nint\nmcdintr(arg)\n\tvoid *arg;\n{\n\tstruct mcd_softc *sc = arg;\n\tstruct mcd_mbx *mbx = &sc->mbx;\n\tstruct buf *bp = mbx->bp;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tint i;\n\tu_char x;\n\tbcd_t msf[3];\n\n\tswitch (mbx->state) {\n\tcase MCD_S_IDLE:\n\t\treturn 0;\n\n\tcase MCD_S_BEGIN:\n\ttryagain:\n\t\tif (mbx->mode == sc->lastmode)\n\t\t\tgoto firstblock;\n\n\t\tsc->lastmode = MCD_MD_UNKNOWN;\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, MCD_CMDSETMODE);\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->mode);\n\n\t\tmbx->count = RDELAY_WAITMODE;\n\t\tmbx->state = MCD_S_WAITMODE;\n\n\tcase MCD_S_WAITMODE:\n\t\tuntimeout(mcd_pseudointr, sc);\n\t\tfor (i = 20; i; i--) {\n\t\t\tx = bus_space_read_1(iot, ioh, MCD_XFER);\n\t\t\tif ((x & MCD_XF_STATUSUNAVAIL) == 0)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (i == 0)\n\t\t\tgoto hold;\n\t\tsc->status = bus_space_read_1(iot, ioh, MCD_STATUS);\n\t\tmcd_setflags(sc);\n\t\tif ((sc->flags & MCDF_LOADED) == 0)\n\t\t\tgoto changed;\n\t\tMCD_TRACE(\"doread: got WAITMODE delay=%d\\n\",\n\t\t    RDELAY_WAITMODE - mbx->count, 0, 0, 0);\n\n\t\tsc->lastmode = mbx->mode;\n\n\tfirstblock:\n\t\tMCD_TRACE(\"doread: read blkno=%d for bp=0x%x\\n\", mbx->blkno,\n\t\t    bp, 0, 0);\n\n\t\t/* Build parameter block. */\n\t\thsg2msf(mbx->blkno, msf);\n\n\t\t/* Send the read command. */\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, sc->readcmd);\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, msf[0]);\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, msf[1]);\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, msf[2]);\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, 0);\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, 0);\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->nblk);\n\n\t\tmbx->count = RDELAY_WAITREAD;\n\t\tmbx->state = MCD_S_WAITREAD;\n\n\tcase MCD_S_WAITREAD:\n\t\tuntimeout(mcd_pseudointr, sc);\n\tnextblock:\n\tloop:\n\t\tfor (i = 20; i; i--) {\n\t\t\tx = bus_space_read_1(iot, ioh, MCD_XFER);\n\t\t\tif ((x & MCD_XF_DATAUNAVAIL) == 0)\n\t\t\t\tgoto gotblock;\n\t\t\tif ((x & MCD_XF_STATUSUNAVAIL) == 0)\n\t\t\t\tbreak;\n\t\t\tdelay(50);\n\t\t}\n\t\tif (i == 0)\n\t\t\tgoto hold;\n\t\tsc->status = bus_space_read_1(iot, ioh, MCD_STATUS);\n\t\tmcd_setflags(sc);\n\t\tif ((sc->flags & MCDF_LOADED) == 0)\n\t\t\tgoto changed;\n#if 0\n\t\tprintf(\"%s: got status byte %02x during read\\n\",\n\t\t    sc->sc_dev.dv_xname, (u_int)sc->status);\n#endif\n\t\tgoto loop;\n\n\tgotblock:\n\t\tMCD_TRACE(\"doread: got data delay=%d\\n\",\n\t\t    RDELAY_WAITREAD - mbx->count, 0, 0, 0);\n\n\t\t/* Data is ready. */\n\t\tbus_space_write_1(iot, ioh, MCD_CTL2, 0x04);\t/* XXX */\n\t\tbus_space_read_multi_1(iot, ioh, MCD_RDATA,\n\t\t    bp->b_data + mbx->skip, mbx->sz);\n\t\tbus_space_write_1(iot, ioh, MCD_CTL2, 0x0c);\t/* XXX */\n\t\tmbx->blkno += 1;\n\t\tmbx->skip += mbx->sz;\n\t\tif (--mbx->nblk > 0)\n\t\t\tgoto nextblock;\n\n\t\tmbx->state = MCD_S_IDLE;\n\n\t\t/* Return buffer. */\n\t\tbp->b_resid = 0;\n\t\tdisk_unbusy(&sc->sc_dk, bp->b_bcount);\n\t\tbiodone(bp);\n\n\t\tmcdstart(sc);\n\t\treturn 1;\n\n\thold:\n\t\tif (mbx->count-- < 0) {\n\t\t\tprintf(\"%s: timeout in state %d\",\n\t\t\t    sc->sc_dev.dv_xname, mbx->state);\n\t\t\tgoto readerr;\n\t\t}\n\n#if 0\n\t\tprintf(\"%s: sleep in state %d\\n\", sc->sc_dev.dv_xname,\n\t\t    mbx->state);\n#endif\n\t\ttimeout(mcd_pseudointr, sc, hz / 100);\n\t\treturn -1;\n\t}\n\nreaderr:\n\tif (mbx->retry-- > 0) {\n\t\tprintf(\"; retrying\\n\");\n\t\tgoto tryagain;\n\t} else\n\t\tprintf(\"; giving up\\n\");\n\nchanged:\n\t/* Invalidate the buffer. */\n\tbp->b_flags |= B_ERROR;\n\tbp->b_resid = bp->b_bcount - mbx->skip;\n\tdisk_unbusy(&sc->sc_dk, (bp->b_bcount - bp->b_resid));\n\tbiodone(bp);\n\n\tmcdstart(sc);\n\treturn -1;\n\n#ifdef notyet\n\tprintf(\"%s: unit timeout; resetting\\n\", sc->sc_dev.dv_xname);\n\tbus_space_write_1(iot, ioh, MCD_RESET, MCD_CMDRESET);\n\tdelay(300000);\n\t(void) mcd_getstat(sc, 1);\n\t(void) mcd_getstat(sc, 1);\n\t/*sc->status &= ~MCD_ST_DSKCHNG; */\n\tsc->debug = 1; /* preventive set debug mode */\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCDPART",
          "args": [
            "bp->b_dev"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCDPART",
          "args": [
            "bp->b_dev"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_busy",
          "args": [
            "&sc->sc_dk"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "biodone",
          "args": [
            "bp"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCD_TRACE",
          "args": [
            "\"start: drive not valid\\n\"",
            "0",
            "0",
            "0",
            "0"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCD_TRACE",
          "args": [
            "\"start: found block bp=0x%x\\n\"",
            "bp",
            "0",
            "0",
            "0"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MCD_RDRETRIES\t3\n#define\tMCDF_LOADED\t0x10\t/* parameters loaded */\n#define MCD_S_BEGIN\t1\n\nint mcdintr;\nvoid\tmcdstart;\n\nvoid\nmcdstart(sc)\n\tstruct mcd_softc *sc;\n{\n\tstruct buf *bp, *dp = &sc->buf_queue;\n\tint s;\n\t\nloop:\n\ts = splbio();\n\n\tbp = dp->b_actf;\n\tif (bp == NULL) {\n\t\t/* Nothing to do. */\n\t\tdp->b_active = 0;\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Block found to process; dequeue. */\n\tMCD_TRACE(\"start: found block bp=0x%x\\n\", bp, 0, 0, 0);\n\tdp->b_actf = bp->b_actf;\n\tsplx(s);\n\n\t/* Changed media? */\n\tif ((sc->flags & MCDF_LOADED) == 0) {\n\t\tMCD_TRACE(\"start: drive not valid\\n\", 0, 0, 0, 0);\n\t\tbp->b_error = EIO;\n\t\tbp->b_flags |= B_ERROR;\n\t\tbiodone(bp);\n\t\tgoto loop;\n\t}\n\n\tdp->b_active = 1;\n\n\t/* Instrumentation. */\n\ts = splbio();\n\tdisk_busy(&sc->sc_dk);\n\tsplx(s);\n\n\tsc->mbx.retry = MCD_RDRETRIES;\n\tsc->mbx.bp = bp;\n\tsc->mbx.blkno = bp->b_blkno / (sc->blksize / DEV_BSIZE);\n\tif (MCDPART(bp->b_dev) != RAW_PART) {\n\t\tstruct partition *p;\n\t\tp = &sc->sc_dk.dk_label->d_partitions[MCDPART(bp->b_dev)];\n\t\tsc->mbx.blkno += p->p_offset;\n\t}\n\tsc->mbx.nblk = bp->b_bcount / sc->blksize;\n\tsc->mbx.sz = sc->blksize;\n\tsc->mbx.skip = 0;\n\tsc->mbx.state = MCD_S_BEGIN;\n\tsc->mbx.mode = MCD_MD_COOKED;\n\n\ts = splbio();\n\t(void) mcdintr(sc);\n\tsplx(s);\n}"
  },
  {
    "function_name": "mcdstrategy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
    "lines": "462-514",
    "snippet": "void\nmcdstrategy(bp)\n\tstruct buf *bp;\n{\n\tstruct mcd_softc *sc = mcd_cd.cd_devs[MCDUNIT(bp->b_dev)];\n\tint s;\n\t\n\t/* Test validity. */\n\tMCD_TRACE(\"strategy: buf=0x%lx blkno=%ld bcount=%ld\\n\", bp,\n\t    bp->b_blkno, bp->b_bcount, 0);\n\tif (bp->b_blkno < 0 ||\n\t    (bp->b_bcount % sc->blksize) != 0) {\n\t\tprintf(\"%s: strategy: blkno = %d bcount = %ld\\n\",\n\t\t    sc->sc_dev.dv_xname, bp->b_blkno, bp->b_bcount);\n\t\tbp->b_error = EINVAL;\n\t\tgoto bad;\n\t}\n\n\t/* If device invalidated (e.g. media change, door open), error. */\n\tif ((sc->flags & MCDF_LOADED) == 0) {\n\t\tMCD_TRACE(\"strategy: drive not valid\\n\", 0, 0, 0, 0);\n\t\tbp->b_error = EIO;\n\t\tgoto bad;\n\t}\n\n\t/* No data to read. */\n\tif (bp->b_bcount == 0)\n\t\tgoto done;\n\t\n\t/*\n\t * Do bounds checking, adjust transfer. if error, process.\n\t * If end of partition, just return.\n\t */\n\tif (MCDPART(bp->b_dev) != RAW_PART &&\n\t    bounds_check_with_label(bp, sc->sc_dk.dk_label,\n\t    sc->sc_dk.dk_cpulabel,\n\t    (sc->flags & (MCDF_WLABEL|MCDF_LABELLING)) != 0) <= 0)\n\t\tgoto done;\n\t\n\t/* Queue it. */\n\ts = splbio();\n\tdisksort(&sc->buf_queue, bp);\n\tsplx(s);\n\tif (!sc->buf_queue.b_active)\n\t\tmcdstart(sc);\n\treturn;\n\nbad:\n\tbp->b_flags |= B_ERROR;\ndone:\n\tbp->b_resid = bp->b_bcount;\n\tbiodone(bp);\n}",
    "includes": [
      "#include <lib/libkern/libkern.h>",
      "#include <dev/isa/opti.h>",
      "#include <dev/isa/mcdreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/errno.h>",
      "#include <sys/cdio.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/uio.h>",
      "#include <sys/stat.h>",
      "#include <sys/buf.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tMCDF_LOADED\t0x10\t/* parameters loaded */",
      "#define\tMCDF_LABELLING\t0x08\t/* writing label */",
      "#define\tMCDF_WLABEL\t0x04\t/* label is writable */"
    ],
    "globals_used": [
      "struct cfdriver mcd_cd = {\n\tNULL, \"mcd\", DV_DISK\n};",
      "void\tmcdstrategy",
      "void\tmcdstart"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "biodone",
          "args": [
            "bp"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mcdstart",
          "args": [
            "sc"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "mcdstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "516-572",
          "snippet": "void\nmcdstart(sc)\n\tstruct mcd_softc *sc;\n{\n\tstruct buf *bp, *dp = &sc->buf_queue;\n\tint s;\n\t\nloop:\n\ts = splbio();\n\n\tbp = dp->b_actf;\n\tif (bp == NULL) {\n\t\t/* Nothing to do. */\n\t\tdp->b_active = 0;\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Block found to process; dequeue. */\n\tMCD_TRACE(\"start: found block bp=0x%x\\n\", bp, 0, 0, 0);\n\tdp->b_actf = bp->b_actf;\n\tsplx(s);\n\n\t/* Changed media? */\n\tif ((sc->flags & MCDF_LOADED) == 0) {\n\t\tMCD_TRACE(\"start: drive not valid\\n\", 0, 0, 0, 0);\n\t\tbp->b_error = EIO;\n\t\tbp->b_flags |= B_ERROR;\n\t\tbiodone(bp);\n\t\tgoto loop;\n\t}\n\n\tdp->b_active = 1;\n\n\t/* Instrumentation. */\n\ts = splbio();\n\tdisk_busy(&sc->sc_dk);\n\tsplx(s);\n\n\tsc->mbx.retry = MCD_RDRETRIES;\n\tsc->mbx.bp = bp;\n\tsc->mbx.blkno = bp->b_blkno / (sc->blksize / DEV_BSIZE);\n\tif (MCDPART(bp->b_dev) != RAW_PART) {\n\t\tstruct partition *p;\n\t\tp = &sc->sc_dk.dk_label->d_partitions[MCDPART(bp->b_dev)];\n\t\tsc->mbx.blkno += p->p_offset;\n\t}\n\tsc->mbx.nblk = bp->b_bcount / sc->blksize;\n\tsc->mbx.sz = sc->blksize;\n\tsc->mbx.skip = 0;\n\tsc->mbx.state = MCD_S_BEGIN;\n\tsc->mbx.mode = MCD_MD_COOKED;\n\n\ts = splbio();\n\t(void) mcdintr(sc);\n\tsplx(s);\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MCD_RDRETRIES\t3",
            "#define\tMCDF_LOADED\t0x10\t/* parameters loaded */",
            "#define MCD_S_BEGIN\t1"
          ],
          "globals_used": [
            "int mcdintr",
            "void\tmcdstart"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MCD_RDRETRIES\t3\n#define\tMCDF_LOADED\t0x10\t/* parameters loaded */\n#define MCD_S_BEGIN\t1\n\nint mcdintr;\nvoid\tmcdstart;\n\nvoid\nmcdstart(sc)\n\tstruct mcd_softc *sc;\n{\n\tstruct buf *bp, *dp = &sc->buf_queue;\n\tint s;\n\t\nloop:\n\ts = splbio();\n\n\tbp = dp->b_actf;\n\tif (bp == NULL) {\n\t\t/* Nothing to do. */\n\t\tdp->b_active = 0;\n\t\tsplx(s);\n\t\treturn;\n\t}\n\n\t/* Block found to process; dequeue. */\n\tMCD_TRACE(\"start: found block bp=0x%x\\n\", bp, 0, 0, 0);\n\tdp->b_actf = bp->b_actf;\n\tsplx(s);\n\n\t/* Changed media? */\n\tif ((sc->flags & MCDF_LOADED) == 0) {\n\t\tMCD_TRACE(\"start: drive not valid\\n\", 0, 0, 0, 0);\n\t\tbp->b_error = EIO;\n\t\tbp->b_flags |= B_ERROR;\n\t\tbiodone(bp);\n\t\tgoto loop;\n\t}\n\n\tdp->b_active = 1;\n\n\t/* Instrumentation. */\n\ts = splbio();\n\tdisk_busy(&sc->sc_dk);\n\tsplx(s);\n\n\tsc->mbx.retry = MCD_RDRETRIES;\n\tsc->mbx.bp = bp;\n\tsc->mbx.blkno = bp->b_blkno / (sc->blksize / DEV_BSIZE);\n\tif (MCDPART(bp->b_dev) != RAW_PART) {\n\t\tstruct partition *p;\n\t\tp = &sc->sc_dk.dk_label->d_partitions[MCDPART(bp->b_dev)];\n\t\tsc->mbx.blkno += p->p_offset;\n\t}\n\tsc->mbx.nblk = bp->b_bcount / sc->blksize;\n\tsc->mbx.sz = sc->blksize;\n\tsc->mbx.skip = 0;\n\tsc->mbx.state = MCD_S_BEGIN;\n\tsc->mbx.mode = MCD_MD_COOKED;\n\n\ts = splbio();\n\t(void) mcdintr(sc);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disksort",
          "args": [
            "&sc->buf_queue",
            "bp"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bounds_check_with_label",
          "args": [
            "bp",
            "sc->sc_dk.dk_label",
            "sc->sc_dk.dk_cpulabel",
            "(sc->flags & (MCDF_WLABEL|MCDF_LABELLING)) != 0"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCDPART",
          "args": [
            "bp->b_dev"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCD_TRACE",
          "args": [
            "\"strategy: drive not valid\\n\"",
            "0",
            "0",
            "0",
            "0"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: strategy: blkno = %d bcount = %ld\\n\"",
            "sc->sc_dev.dv_xname",
            "bp->b_blkno",
            "bp->b_bcount"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MCD_TRACE",
          "args": [
            "\"strategy: buf=0x%lx blkno=%ld bcount=%ld\\n\"",
            "bp",
            "bp->b_blkno",
            "bp->b_bcount",
            "0"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCDUNIT",
          "args": [
            "bp->b_dev"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tMCDF_LOADED\t0x10\t/* parameters loaded */\n#define\tMCDF_LABELLING\t0x08\t/* writing label */\n#define\tMCDF_WLABEL\t0x04\t/* label is writable */\n\nstruct cfdriver mcd_cd = {\n\tNULL, \"mcd\", DV_DISK\n};\nvoid\tmcdstrategy;\nvoid\tmcdstart;\n\nvoid\nmcdstrategy(bp)\n\tstruct buf *bp;\n{\n\tstruct mcd_softc *sc = mcd_cd.cd_devs[MCDUNIT(bp->b_dev)];\n\tint s;\n\t\n\t/* Test validity. */\n\tMCD_TRACE(\"strategy: buf=0x%lx blkno=%ld bcount=%ld\\n\", bp,\n\t    bp->b_blkno, bp->b_bcount, 0);\n\tif (bp->b_blkno < 0 ||\n\t    (bp->b_bcount % sc->blksize) != 0) {\n\t\tprintf(\"%s: strategy: blkno = %d bcount = %ld\\n\",\n\t\t    sc->sc_dev.dv_xname, bp->b_blkno, bp->b_bcount);\n\t\tbp->b_error = EINVAL;\n\t\tgoto bad;\n\t}\n\n\t/* If device invalidated (e.g. media change, door open), error. */\n\tif ((sc->flags & MCDF_LOADED) == 0) {\n\t\tMCD_TRACE(\"strategy: drive not valid\\n\", 0, 0, 0, 0);\n\t\tbp->b_error = EIO;\n\t\tgoto bad;\n\t}\n\n\t/* No data to read. */\n\tif (bp->b_bcount == 0)\n\t\tgoto done;\n\t\n\t/*\n\t * Do bounds checking, adjust transfer. if error, process.\n\t * If end of partition, just return.\n\t */\n\tif (MCDPART(bp->b_dev) != RAW_PART &&\n\t    bounds_check_with_label(bp, sc->sc_dk.dk_label,\n\t    sc->sc_dk.dk_cpulabel,\n\t    (sc->flags & (MCDF_WLABEL|MCDF_LABELLING)) != 0) <= 0)\n\t\tgoto done;\n\t\n\t/* Queue it. */\n\ts = splbio();\n\tdisksort(&sc->buf_queue, bp);\n\tsplx(s);\n\tif (!sc->buf_queue.b_active)\n\t\tmcdstart(sc);\n\treturn;\n\nbad:\n\tbp->b_flags |= B_ERROR;\ndone:\n\tbp->b_resid = bp->b_bcount;\n\tbiodone(bp);\n}"
  },
  {
    "function_name": "mcdclose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
    "lines": "421-460",
    "snippet": "int\nmcdclose(dev, flag, fmt, p)\n\tdev_t dev;\n\tint flag, fmt;\n\tstruct proc *p;\n{\n\tstruct mcd_softc *sc = mcd_cd.cd_devs[MCDUNIT(dev)];\n\tint part = MCDPART(dev);\n\tint error;\n\t\n\tMCD_TRACE(\"close: partition=%d\\n\", part, 0, 0, 0);\n\n\tif ((error = mcdlock(sc)) != 0)\n\t\treturn error;\n\n\tswitch (fmt) {\n\tcase S_IFCHR:\n\t\tsc->sc_dk.dk_copenmask &= ~(1 << part);\n\t\tbreak;\n\tcase S_IFBLK:\n\t\tsc->sc_dk.dk_bopenmask &= ~(1 << part);\n\t\tbreak;\n\t}\n\tsc->sc_dk.dk_openmask = sc->sc_dk.dk_copenmask | sc->sc_dk.dk_bopenmask;\n\n\tif (sc->sc_dk.dk_openmask == 0) {\n\t\t/* XXXX Must wait for I/O to complete! */\n\n#if 0\n\t\t(void) mcd_setmode(sc, MCD_MD_SLEEP);\n#endif\n\t\t(void) mcd_setlock(sc, MCD_LK_UNLOCK);\n\t\tif (sc->flags & MCDF_EJECTING) {\n\t\t\tmcd_eject(sc);\n\t\t\tsc->flags &= ~MCDF_EJECTING;\n\t\t}\n\t}\n\tmcdunlock(sc);\n\treturn 0;\n}",
    "includes": [
      "#include <lib/libkern/libkern.h>",
      "#include <dev/isa/opti.h>",
      "#include <dev/isa/mcdreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/errno.h>",
      "#include <sys/cdio.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/uio.h>",
      "#include <sys/stat.h>",
      "#include <sys/buf.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tMCDF_EJECTING\t0x20\t/* please eject at close */"
    ],
    "globals_used": [
      "int mcd_eject",
      "int mcd_setmode",
      "int mcd_setlock",
      "struct cfdriver mcd_cd = {\n\tNULL, \"mcd\", DV_DISK\n};",
      "int\tmcdlock",
      "void\tmcdunlock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mcdunlock",
          "args": [
            "sc"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "mcdunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "302-312",
          "snippet": "void\nmcdunlock(sc)\n\tstruct mcd_softc *sc;\n{\n\n\tsc->flags &= ~MCDF_LOCKED;\n\tif ((sc->flags & MCDF_WANTED) != 0) {\n\t\tsc->flags &= ~MCDF_WANTED;\n\t\twakeup(sc);\n\t}\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tMCDF_WANTED\t0x02",
            "#define\tMCDF_LOCKED\t0x01"
          ],
          "globals_used": [
            "void\tmcdunlock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tMCDF_WANTED\t0x02\n#define\tMCDF_LOCKED\t0x01\n\nvoid\tmcdunlock;\n\nvoid\nmcdunlock(sc)\n\tstruct mcd_softc *sc;\n{\n\n\tsc->flags &= ~MCDF_LOCKED;\n\tif ((sc->flags & MCDF_WANTED) != 0) {\n\t\tsc->flags &= ~MCDF_WANTED;\n\t\twakeup(sc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mcd_eject",
          "args": [
            "sc"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_eject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1792-1802",
          "snippet": "int\nmcd_eject(sc)\n\tstruct mcd_softc *sc;\n{\n\tstruct mcd_mbox mbx;\n\n\tmbx.cmd.opcode = MCD_CMDEJECTDISK;\n\tmbx.cmd.length = 0;\n\tmbx.res.length = 0;\n\treturn mcd_send(sc, &mbx, 0);\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int mcd_eject",
            "int mcd_send"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint mcd_eject;\nint mcd_send;\n\nint\nmcd_eject(sc)\n\tstruct mcd_softc *sc;\n{\n\tstruct mcd_mbox mbx;\n\n\tmbx.cmd.opcode = MCD_CMDEJECTDISK;\n\tmbx.cmd.length = 0;\n\tmbx.res.length = 0;\n\treturn mcd_send(sc, &mbx, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mcd_setlock",
          "args": [
            "sc",
            "MCD_LK_UNLOCK"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_setlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1804-1816",
          "snippet": "int\nmcd_setlock(sc, mode)\n\tstruct mcd_softc *sc;\n\tint mode;\n{\n\tstruct mcd_mbox mbx;\n\t\n\tmbx.cmd.opcode = MCD_CMDSETLOCK;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.lockmode);\n\tmbx.cmd.data.lockmode.mode = mode;\n\tmbx.res.length = 0;\n\treturn mcd_send(sc, &mbx, 1);\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int mcd_send",
            "int mcd_setlock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint mcd_send;\nint mcd_setlock;\n\nint\nmcd_setlock(sc, mode)\n\tstruct mcd_softc *sc;\n\tint mode;\n{\n\tstruct mcd_mbox mbx;\n\t\n\tmbx.cmd.opcode = MCD_CMDSETLOCK;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.lockmode);\n\tmbx.cmd.data.lockmode.mode = mode;\n\tmbx.res.length = 0;\n\treturn mcd_send(sc, &mbx, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mcd_setmode",
          "args": [
            "sc",
            "MCD_MD_SLEEP"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_setmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1312-1335",
          "snippet": "int\nmcd_setmode(sc, mode)\n\tstruct mcd_softc *sc;\n\tint mode;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (sc->lastmode == mode)\n\t\treturn 0;\n\tif (sc->debug)\n\t\tprintf(\"%s: setting mode to %d\\n\", sc->sc_dev.dv_xname, mode);\n\tsc->lastmode = MCD_MD_UNKNOWN;\n\n\tmbx.cmd.opcode = MCD_CMDSETMODE;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.datamode);\n\tmbx.cmd.data.datamode.mode = mode;\n\tmbx.res.length = 0;\n\tif ((error = mcd_send(sc, &mbx, 1)) != 0)\n\t\treturn error;\n\n\tsc->lastmode = mode;\n\treturn 0;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tMCD_MD_UNKNOWN\t-1"
          ],
          "globals_used": [
            "int mcd_send",
            "int mcd_setmode"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tMCD_MD_UNKNOWN\t-1\n\nint mcd_send;\nint mcd_setmode;\n\nint\nmcd_setmode(sc, mode)\n\tstruct mcd_softc *sc;\n\tint mode;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (sc->lastmode == mode)\n\t\treturn 0;\n\tif (sc->debug)\n\t\tprintf(\"%s: setting mode to %d\\n\", sc->sc_dev.dv_xname, mode);\n\tsc->lastmode = MCD_MD_UNKNOWN;\n\n\tmbx.cmd.opcode = MCD_CMDSETMODE;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.datamode);\n\tmbx.cmd.data.datamode.mode = mode;\n\tmbx.res.length = 0;\n\tif ((error = mcd_send(sc, &mbx, 1)) != 0)\n\t\treturn error;\n\n\tsc->lastmode = mode;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mcdlock",
          "args": [
            "sc"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "mcdlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "284-297",
          "snippet": "int\nmcdlock(sc)\n\tstruct mcd_softc *sc;\n{\n\tint error;\n\n\twhile ((sc->flags & MCDF_LOCKED) != 0) {\n\t\tsc->flags |= MCDF_WANTED;\n\t\tif ((error = tsleep(sc, PRIBIO | PCATCH, \"mcdlck\", 0)) != 0)\n\t\t\treturn error;\n\t}\n\tsc->flags |= MCDF_LOCKED;\n\treturn 0;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tMCDF_WANTED\t0x02",
            "#define\tMCDF_LOCKED\t0x01"
          ],
          "globals_used": [
            "int\tmcdlock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tMCDF_WANTED\t0x02\n#define\tMCDF_LOCKED\t0x01\n\nint\tmcdlock;\n\nint\nmcdlock(sc)\n\tstruct mcd_softc *sc;\n{\n\tint error;\n\n\twhile ((sc->flags & MCDF_LOCKED) != 0) {\n\t\tsc->flags |= MCDF_WANTED;\n\t\tif ((error = tsleep(sc, PRIBIO | PCATCH, \"mcdlck\", 0)) != 0)\n\t\t\treturn error;\n\t}\n\tsc->flags |= MCDF_LOCKED;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MCD_TRACE",
          "args": [
            "\"close: partition=%d\\n\"",
            "part",
            "0",
            "0",
            "0"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCDPART",
          "args": [
            "dev"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCDUNIT",
          "args": [
            "dev"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tMCDF_EJECTING\t0x20\t/* please eject at close */\n\nint mcd_eject;\nint mcd_setmode;\nint mcd_setlock;\nstruct cfdriver mcd_cd = {\n\tNULL, \"mcd\", DV_DISK\n};\nint\tmcdlock;\nvoid\tmcdunlock;\n\nint\nmcdclose(dev, flag, fmt, p)\n\tdev_t dev;\n\tint flag, fmt;\n\tstruct proc *p;\n{\n\tstruct mcd_softc *sc = mcd_cd.cd_devs[MCDUNIT(dev)];\n\tint part = MCDPART(dev);\n\tint error;\n\t\n\tMCD_TRACE(\"close: partition=%d\\n\", part, 0, 0, 0);\n\n\tif ((error = mcdlock(sc)) != 0)\n\t\treturn error;\n\n\tswitch (fmt) {\n\tcase S_IFCHR:\n\t\tsc->sc_dk.dk_copenmask &= ~(1 << part);\n\t\tbreak;\n\tcase S_IFBLK:\n\t\tsc->sc_dk.dk_bopenmask &= ~(1 << part);\n\t\tbreak;\n\t}\n\tsc->sc_dk.dk_openmask = sc->sc_dk.dk_copenmask | sc->sc_dk.dk_bopenmask;\n\n\tif (sc->sc_dk.dk_openmask == 0) {\n\t\t/* XXXX Must wait for I/O to complete! */\n\n#if 0\n\t\t(void) mcd_setmode(sc, MCD_MD_SLEEP);\n#endif\n\t\t(void) mcd_setlock(sc, MCD_LK_UNLOCK);\n\t\tif (sc->flags & MCDF_EJECTING) {\n\t\t\tmcd_eject(sc);\n\t\t\tsc->flags &= ~MCDF_EJECTING;\n\t\t}\n\t}\n\tmcdunlock(sc);\n\treturn 0;\n}"
  },
  {
    "function_name": "mcdopen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
    "lines": "314-419",
    "snippet": "int\nmcdopen(dev, flag, fmt, p)\n\tdev_t dev;\n\tint flag, fmt;\n\tstruct proc *p;\n{\n\tint error;\n\tint unit, part;\n\tstruct mcd_softc *sc;\n\n\tunit = MCDUNIT(dev);\n\tif (unit >= mcd_cd.cd_ndevs)\n\t\treturn ENXIO;\n\tsc = mcd_cd.cd_devs[unit];\n\tif (!sc)\n\t\treturn ENXIO;\n\n\tif ((error = mcdlock(sc)) != 0)\n\t\treturn error;\n\n\tif (sc->sc_dk.dk_openmask != 0) {\n\t\t/*\n\t\t * If any partition is open, but the disk has been invalidated,\n\t\t * disallow further opens.\n\t\t */\n\t\tif ((sc->flags & MCDF_LOADED) == 0) {\n\t\t\terror = EIO;\n\t\t\tgoto bad3;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Lock the drawer.  This will also notice any pending disk\n\t\t * change or door open indicator and clear the MCDF_LOADED bit\n\t\t * if necessary.\n\t\t */\n\t\t(void) mcd_setlock(sc, MCD_LK_LOCK);\n\n\t\tif ((sc->flags & MCDF_LOADED) == 0) {\n\t\t\t/* Partially reset the state. */\n\t\t\tsc->lastmode = MCD_MD_UNKNOWN;\n\t\t\tsc->lastupc = MCD_UPC_UNKNOWN;\n\n\t\t\tsc->flags |= MCDF_LOADED;\n\n\t\t\t/* Set the mode, causing the disk to spin up. */\n\t\t\tif ((error = mcd_setmode(sc, MCD_MD_COOKED)) != 0)\n\t\t\t\tgoto bad2;\n\n\t\t\t/* Load the physical device parameters. */\n\t\t\tif (mcd_get_parms(sc) != 0) {\n\t\t\t\terror = ENXIO;\n\t\t\t\tgoto bad2;\n\t\t\t}\n\n\t\t\t/* Read the table of contents. */\n\t\t\tif ((error = mcd_read_toc(sc)) != 0)\n\t\t\t\tgoto bad2;\n\n\t\t\t/* Fabricate a disk label. */\n\t\t\tmcdgetdisklabel(dev, sc, sc->sc_dk.dk_label,\n\t\t\t    sc->sc_dk.dk_cpulabel, 0);\n\t\t}\n\t}\n\n\tMCD_TRACE(\"open: partition=%d disksize=%d blksize=%d\\n\", part,\n\t    sc->disksize, sc->blksize, 0);\n\n\tpart = MCDPART(dev);\n\t\n\t/* Check that the partition exists. */\n\tif (part != RAW_PART &&\n\t    (part >= sc->sc_dk.dk_label->d_npartitions ||\n\t     sc->sc_dk.dk_label->d_partitions[part].p_fstype == FS_UNUSED)) {\n\t\terror = ENXIO;\n\t\tgoto bad;\n\t}\n\n\t/* Insure only one open at a time. */\n\tswitch (fmt) {\n\tcase S_IFCHR:\n\t\tsc->sc_dk.dk_copenmask |= (1 << part);\n\t\tbreak;\n\tcase S_IFBLK:\n\t\tsc->sc_dk.dk_bopenmask |= (1 << part);\n\t\tbreak;\n\t}\n\tsc->sc_dk.dk_openmask = sc->sc_dk.dk_copenmask | sc->sc_dk.dk_bopenmask;\n\n\tmcdunlock(sc);\n\treturn 0;\n\nbad2:\n\tsc->flags &= ~MCDF_LOADED;\n\nbad:\n\tif (sc->sc_dk.dk_openmask == 0) {\n#if 0\n\t\t(void) mcd_setmode(sc, MCD_MD_SLEEP);\n#endif\n\t\t(void) mcd_setlock(sc, MCD_LK_UNLOCK);\n\t}\n\nbad3:\n\tmcdunlock(sc);\n\treturn error;\n}",
    "includes": [
      "#include <lib/libkern/libkern.h>",
      "#include <dev/isa/opti.h>",
      "#include <dev/isa/mcdreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/errno.h>",
      "#include <sys/cdio.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/uio.h>",
      "#include <sys/stat.h>",
      "#include <sys/buf.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tMCD_UPC_UNKNOWN\t-1",
      "#define\tMCD_MD_UNKNOWN\t-1",
      "#define\tMCDF_LOADED\t0x10\t/* parameters loaded */"
    ],
    "globals_used": [
      "int mcd_setmode",
      "int mcd_read_toc",
      "int mcd_setlock",
      "struct cfdriver mcd_cd = {\n\tNULL, \"mcd\", DV_DISK\n};",
      "void\tmcdgetdisklabel",
      "int\tmcd_get_parms",
      "int\tmcdlock",
      "void\tmcdunlock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mcdunlock",
          "args": [
            "sc"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "mcdunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "302-312",
          "snippet": "void\nmcdunlock(sc)\n\tstruct mcd_softc *sc;\n{\n\n\tsc->flags &= ~MCDF_LOCKED;\n\tif ((sc->flags & MCDF_WANTED) != 0) {\n\t\tsc->flags &= ~MCDF_WANTED;\n\t\twakeup(sc);\n\t}\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tMCDF_WANTED\t0x02",
            "#define\tMCDF_LOCKED\t0x01"
          ],
          "globals_used": [
            "void\tmcdunlock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tMCDF_WANTED\t0x02\n#define\tMCDF_LOCKED\t0x01\n\nvoid\tmcdunlock;\n\nvoid\nmcdunlock(sc)\n\tstruct mcd_softc *sc;\n{\n\n\tsc->flags &= ~MCDF_LOCKED;\n\tif ((sc->flags & MCDF_WANTED) != 0) {\n\t\tsc->flags &= ~MCDF_WANTED;\n\t\twakeup(sc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mcd_setlock",
          "args": [
            "sc",
            "MCD_LK_UNLOCK"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_setlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1804-1816",
          "snippet": "int\nmcd_setlock(sc, mode)\n\tstruct mcd_softc *sc;\n\tint mode;\n{\n\tstruct mcd_mbox mbx;\n\t\n\tmbx.cmd.opcode = MCD_CMDSETLOCK;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.lockmode);\n\tmbx.cmd.data.lockmode.mode = mode;\n\tmbx.res.length = 0;\n\treturn mcd_send(sc, &mbx, 1);\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int mcd_send",
            "int mcd_setlock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint mcd_send;\nint mcd_setlock;\n\nint\nmcd_setlock(sc, mode)\n\tstruct mcd_softc *sc;\n\tint mode;\n{\n\tstruct mcd_mbox mbx;\n\t\n\tmbx.cmd.opcode = MCD_CMDSETLOCK;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.lockmode);\n\tmbx.cmd.data.lockmode.mode = mode;\n\tmbx.res.length = 0;\n\treturn mcd_send(sc, &mbx, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mcd_setmode",
          "args": [
            "sc",
            "MCD_MD_SLEEP"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_setmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1312-1335",
          "snippet": "int\nmcd_setmode(sc, mode)\n\tstruct mcd_softc *sc;\n\tint mode;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (sc->lastmode == mode)\n\t\treturn 0;\n\tif (sc->debug)\n\t\tprintf(\"%s: setting mode to %d\\n\", sc->sc_dev.dv_xname, mode);\n\tsc->lastmode = MCD_MD_UNKNOWN;\n\n\tmbx.cmd.opcode = MCD_CMDSETMODE;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.datamode);\n\tmbx.cmd.data.datamode.mode = mode;\n\tmbx.res.length = 0;\n\tif ((error = mcd_send(sc, &mbx, 1)) != 0)\n\t\treturn error;\n\n\tsc->lastmode = mode;\n\treturn 0;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tMCD_MD_UNKNOWN\t-1"
          ],
          "globals_used": [
            "int mcd_send",
            "int mcd_setmode"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tMCD_MD_UNKNOWN\t-1\n\nint mcd_send;\nint mcd_setmode;\n\nint\nmcd_setmode(sc, mode)\n\tstruct mcd_softc *sc;\n\tint mode;\n{\n\tstruct mcd_mbox mbx;\n\tint error;\n\n\tif (sc->lastmode == mode)\n\t\treturn 0;\n\tif (sc->debug)\n\t\tprintf(\"%s: setting mode to %d\\n\", sc->sc_dev.dv_xname, mode);\n\tsc->lastmode = MCD_MD_UNKNOWN;\n\n\tmbx.cmd.opcode = MCD_CMDSETMODE;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.datamode);\n\tmbx.cmd.data.datamode.mode = mode;\n\tmbx.res.length = 0;\n\tif ((error = mcd_send(sc, &mbx, 1)) != 0)\n\t\treturn error;\n\n\tsc->lastmode = mode;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MCDPART",
          "args": [
            "dev"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCD_TRACE",
          "args": [
            "\"open: partition=%d disksize=%d blksize=%d\\n\"",
            "part",
            "sc->disksize",
            "sc->blksize",
            "0"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mcdgetdisklabel",
          "args": [
            "dev",
            "sc",
            "sc->sc_dk.dk_label",
            "sc->sc_dk.dk_cpulabel",
            "0"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "mcdgetdisklabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "710-760",
          "snippet": "void\nmcdgetdisklabel(dev, sc, lp, clp, spoofonly)\n\tdev_t dev;\n\tstruct mcd_softc *sc;\n\tstruct disklabel *lp;\n\tstruct cpu_disklabel *clp;\n\tint spoofonly;\n{\n\tchar *errstring;\n\t\n\tbzero(lp, sizeof(struct disklabel));\n\tbzero(clp, sizeof(struct cpu_disklabel));\n\n\tlp->d_secsize = sc->blksize;\n\tlp->d_ntracks = 1;\n\tlp->d_nsectors = 100;\n\tlp->d_ncylinders = (sc->disksize / 100) + 1;\n\tlp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;\n\tif (lp->d_secpercyl == 0) {\n\t\tlp->d_secpercyl = 100;\n\t\t/* as long as it's not 0 - readdisklabel divides by it */\n\t}\n\n\tstrncpy(lp->d_typename, \"Mitsumi CD-ROM\", 16);\n\tlp->d_type = DTYPE_SCSI;\t/* XXX */\n\tstrncpy(lp->d_packname, \"fictitious\", 16);\n\tlp->d_secperunit = sc->disksize;\n\tlp->d_rpm = 300;\n\tlp->d_interleave = 1;\n\tlp->d_flags = D_REMOVABLE;\n\n\tlp->d_partitions[RAW_PART].p_offset = 0;\n\tlp->d_partitions[RAW_PART].p_size =\n\t    lp->d_secperunit * (lp->d_secsize / DEV_BSIZE);\n\tlp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;\n\tlp->d_npartitions = RAW_PART + 1;\n\n\tlp->d_magic = DISKMAGIC;\n\tlp->d_magic2 = DISKMAGIC;\n\tlp->d_checksum = dkcksum(lp);\n\n\t/*\n\t * Call the generic disklabel extraction routine\n\t */\n\terrstring = readdisklabel(MCDLABELDEV(dev), mcdstrategy, lp, clp,\n\t    spoofonly);\n\tif (errstring) {\n\t\t/*printf(\"%s: %s\\n\", sc->sc_dev.dv_xname, errstring);*/\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tmcdgetdisklabel",
            "void\tmcdstrategy"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tmcdgetdisklabel;\nvoid\tmcdstrategy;\n\nvoid\nmcdgetdisklabel(dev, sc, lp, clp, spoofonly)\n\tdev_t dev;\n\tstruct mcd_softc *sc;\n\tstruct disklabel *lp;\n\tstruct cpu_disklabel *clp;\n\tint spoofonly;\n{\n\tchar *errstring;\n\t\n\tbzero(lp, sizeof(struct disklabel));\n\tbzero(clp, sizeof(struct cpu_disklabel));\n\n\tlp->d_secsize = sc->blksize;\n\tlp->d_ntracks = 1;\n\tlp->d_nsectors = 100;\n\tlp->d_ncylinders = (sc->disksize / 100) + 1;\n\tlp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;\n\tif (lp->d_secpercyl == 0) {\n\t\tlp->d_secpercyl = 100;\n\t\t/* as long as it's not 0 - readdisklabel divides by it */\n\t}\n\n\tstrncpy(lp->d_typename, \"Mitsumi CD-ROM\", 16);\n\tlp->d_type = DTYPE_SCSI;\t/* XXX */\n\tstrncpy(lp->d_packname, \"fictitious\", 16);\n\tlp->d_secperunit = sc->disksize;\n\tlp->d_rpm = 300;\n\tlp->d_interleave = 1;\n\tlp->d_flags = D_REMOVABLE;\n\n\tlp->d_partitions[RAW_PART].p_offset = 0;\n\tlp->d_partitions[RAW_PART].p_size =\n\t    lp->d_secperunit * (lp->d_secsize / DEV_BSIZE);\n\tlp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;\n\tlp->d_npartitions = RAW_PART + 1;\n\n\tlp->d_magic = DISKMAGIC;\n\tlp->d_magic2 = DISKMAGIC;\n\tlp->d_checksum = dkcksum(lp);\n\n\t/*\n\t * Call the generic disklabel extraction routine\n\t */\n\terrstring = readdisklabel(MCDLABELDEV(dev), mcdstrategy, lp, clp,\n\t    spoofonly);\n\tif (errstring) {\n\t\t/*printf(\"%s: %s\\n\", sc->sc_dev.dv_xname, errstring);*/\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mcd_read_toc",
          "args": [
            "sc"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_read_toc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1380-1432",
          "snippet": "int\nmcd_read_toc(sc)\n\tstruct mcd_softc *sc;\n{\n\tstruct ioc_toc_header th;\n\tunion mcd_qchninfo q;\n\tint error, trk, idx, retry;\n\n\tif ((error = mcd_toc_header(sc, &th)) != 0)\n\t\treturn error;\n\n\tif ((error = mcd_stop(sc)) != 0)\n\t\treturn error;\n\n\tif (sc->debug)\n\t\tprintf(\"%s: read_toc: reading qchannel info\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\n\tfor (trk = th.starting_track; trk <= th.ending_track; trk++)\n\t\tsc->toc[trk].toc.idx_no = 0x00;\n\ttrk = th.ending_track - th.starting_track + 1;\n\tfor (retry = 300; retry && trk > 0; retry--) {\n\t\tif (mcd_getqchan(sc, &q, CD_TRACK_INFO) != 0)\n\t\t\tbreak;\n\t\tif (q.toc.trk_no != 0x00 || q.toc.idx_no == 0x00)\n\t\t\tcontinue;\n\t\tidx = bcd2bin(q.toc.idx_no);\n\t\tif (idx < MCD_MAXTOCS &&\n\t\t    sc->toc[idx].toc.idx_no == 0x00) {\n\t\t\tsc->toc[idx] = q;\n\t\t\ttrk--;\n\t\t}\n\t}\n\n\t/* Inform the drive that we're finished so it turns off the light. */\n\tif ((error = mcd_setmode(sc, MCD_MD_COOKED)) != 0)\n\t\treturn error;\n\n\tif (trk != 0)\n\t\treturn EINVAL;\n\n\t/* Add a fake last+1 for mcd_playtracks(). */\n\tidx = th.ending_track + 1;\n\tsc->toc[idx].toc.control = sc->toc[idx-1].toc.control;\n\tsc->toc[idx].toc.addr_type = sc->toc[idx-1].toc.addr_type;\n\tsc->toc[idx].toc.trk_no = 0x00;\n\tsc->toc[idx].toc.idx_no = 0xaa;\n\tsc->toc[idx].toc.absolute_pos[0] = sc->volinfo.vol_msf[0];\n\tsc->toc[idx].toc.absolute_pos[1] = sc->volinfo.vol_msf[1];\n\tsc->toc[idx].toc.absolute_pos[2] = sc->volinfo.vol_msf[2];\n\n\treturn 0;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MCD_MAXTOCS\t104\t/* from the Linux driver */"
          ],
          "globals_used": [
            "int mcd_playtracks",
            "int mcd_stop",
            "int mcd_toc_header",
            "int mcd_setmode",
            "int mcd_read_toc",
            "int mcd_getqchan"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MCD_MAXTOCS\t104\t/* from the Linux driver */\n\nint mcd_playtracks;\nint mcd_stop;\nint mcd_toc_header;\nint mcd_setmode;\nint mcd_read_toc;\nint mcd_getqchan;\n\nint\nmcd_read_toc(sc)\n\tstruct mcd_softc *sc;\n{\n\tstruct ioc_toc_header th;\n\tunion mcd_qchninfo q;\n\tint error, trk, idx, retry;\n\n\tif ((error = mcd_toc_header(sc, &th)) != 0)\n\t\treturn error;\n\n\tif ((error = mcd_stop(sc)) != 0)\n\t\treturn error;\n\n\tif (sc->debug)\n\t\tprintf(\"%s: read_toc: reading qchannel info\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\n\tfor (trk = th.starting_track; trk <= th.ending_track; trk++)\n\t\tsc->toc[trk].toc.idx_no = 0x00;\n\ttrk = th.ending_track - th.starting_track + 1;\n\tfor (retry = 300; retry && trk > 0; retry--) {\n\t\tif (mcd_getqchan(sc, &q, CD_TRACK_INFO) != 0)\n\t\t\tbreak;\n\t\tif (q.toc.trk_no != 0x00 || q.toc.idx_no == 0x00)\n\t\t\tcontinue;\n\t\tidx = bcd2bin(q.toc.idx_no);\n\t\tif (idx < MCD_MAXTOCS &&\n\t\t    sc->toc[idx].toc.idx_no == 0x00) {\n\t\t\tsc->toc[idx] = q;\n\t\t\ttrk--;\n\t\t}\n\t}\n\n\t/* Inform the drive that we're finished so it turns off the light. */\n\tif ((error = mcd_setmode(sc, MCD_MD_COOKED)) != 0)\n\t\treturn error;\n\n\tif (trk != 0)\n\t\treturn EINVAL;\n\n\t/* Add a fake last+1 for mcd_playtracks(). */\n\tidx = th.ending_track + 1;\n\tsc->toc[idx].toc.control = sc->toc[idx-1].toc.control;\n\tsc->toc[idx].toc.addr_type = sc->toc[idx-1].toc.addr_type;\n\tsc->toc[idx].toc.trk_no = 0x00;\n\tsc->toc[idx].toc.idx_no = 0xaa;\n\tsc->toc[idx].toc.absolute_pos[0] = sc->volinfo.vol_msf[0];\n\tsc->toc[idx].toc.absolute_pos[1] = sc->volinfo.vol_msf[1];\n\tsc->toc[idx].toc.absolute_pos[2] = sc->volinfo.vol_msf[2];\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mcd_get_parms",
          "args": [
            "sc"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_get_parms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "762-787",
          "snippet": "int\nmcd_get_parms(sc)\n\tstruct mcd_softc *sc;\n{\n\tstruct mcd_mbox mbx;\n\tdaddr_t size;\n\tint error;\n\n\t/* Send volume info command. */\n\tmbx.cmd.opcode = MCD_CMDGETVOLINFO;\n\tmbx.cmd.length = 0;\n\tmbx.res.length = sizeof(mbx.res.data.volinfo);\n\tif ((error = mcd_send(sc, &mbx, 1)) != 0)\n\t\treturn error;\n\n\tif (mbx.res.data.volinfo.trk_low == 0x00 &&\n\t    mbx.res.data.volinfo.trk_high == 0x00)\n\t\treturn EINVAL;\n\n\t/* Volinfo is OK. */\n\tsc->volinfo = mbx.res.data.volinfo;\n\tsc->blksize = MCD_BLKSIZE_COOKED;\n\tsize = msf2hsg(sc->volinfo.vol_msf, 0);\n\tsc->disksize = size * (MCD_BLKSIZE_COOKED / DEV_BSIZE);\n\treturn 0;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static daddr_t msf2hsg",
            "int mcd_send",
            "int\tmcd_get_parms"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic daddr_t msf2hsg;\nint mcd_send;\nint\tmcd_get_parms;\n\nint\nmcd_get_parms(sc)\n\tstruct mcd_softc *sc;\n{\n\tstruct mcd_mbox mbx;\n\tdaddr_t size;\n\tint error;\n\n\t/* Send volume info command. */\n\tmbx.cmd.opcode = MCD_CMDGETVOLINFO;\n\tmbx.cmd.length = 0;\n\tmbx.res.length = sizeof(mbx.res.data.volinfo);\n\tif ((error = mcd_send(sc, &mbx, 1)) != 0)\n\t\treturn error;\n\n\tif (mbx.res.data.volinfo.trk_low == 0x00 &&\n\t    mbx.res.data.volinfo.trk_high == 0x00)\n\t\treturn EINVAL;\n\n\t/* Volinfo is OK. */\n\tsc->volinfo = mbx.res.data.volinfo;\n\tsc->blksize = MCD_BLKSIZE_COOKED;\n\tsize = msf2hsg(sc->volinfo.vol_msf, 0);\n\tsc->disksize = size * (MCD_BLKSIZE_COOKED / DEV_BSIZE);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mcdlock",
          "args": [
            "sc"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "mcdlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "284-297",
          "snippet": "int\nmcdlock(sc)\n\tstruct mcd_softc *sc;\n{\n\tint error;\n\n\twhile ((sc->flags & MCDF_LOCKED) != 0) {\n\t\tsc->flags |= MCDF_WANTED;\n\t\tif ((error = tsleep(sc, PRIBIO | PCATCH, \"mcdlck\", 0)) != 0)\n\t\t\treturn error;\n\t}\n\tsc->flags |= MCDF_LOCKED;\n\treturn 0;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tMCDF_WANTED\t0x02",
            "#define\tMCDF_LOCKED\t0x01"
          ],
          "globals_used": [
            "int\tmcdlock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tMCDF_WANTED\t0x02\n#define\tMCDF_LOCKED\t0x01\n\nint\tmcdlock;\n\nint\nmcdlock(sc)\n\tstruct mcd_softc *sc;\n{\n\tint error;\n\n\twhile ((sc->flags & MCDF_LOCKED) != 0) {\n\t\tsc->flags |= MCDF_WANTED;\n\t\tif ((error = tsleep(sc, PRIBIO | PCATCH, \"mcdlck\", 0)) != 0)\n\t\t\treturn error;\n\t}\n\tsc->flags |= MCDF_LOCKED;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MCDUNIT",
          "args": [
            "dev"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tMCD_UPC_UNKNOWN\t-1\n#define\tMCD_MD_UNKNOWN\t-1\n#define\tMCDF_LOADED\t0x10\t/* parameters loaded */\n\nint mcd_setmode;\nint mcd_read_toc;\nint mcd_setlock;\nstruct cfdriver mcd_cd = {\n\tNULL, \"mcd\", DV_DISK\n};\nvoid\tmcdgetdisklabel;\nint\tmcd_get_parms;\nint\tmcdlock;\nvoid\tmcdunlock;\n\nint\nmcdopen(dev, flag, fmt, p)\n\tdev_t dev;\n\tint flag, fmt;\n\tstruct proc *p;\n{\n\tint error;\n\tint unit, part;\n\tstruct mcd_softc *sc;\n\n\tunit = MCDUNIT(dev);\n\tif (unit >= mcd_cd.cd_ndevs)\n\t\treturn ENXIO;\n\tsc = mcd_cd.cd_devs[unit];\n\tif (!sc)\n\t\treturn ENXIO;\n\n\tif ((error = mcdlock(sc)) != 0)\n\t\treturn error;\n\n\tif (sc->sc_dk.dk_openmask != 0) {\n\t\t/*\n\t\t * If any partition is open, but the disk has been invalidated,\n\t\t * disallow further opens.\n\t\t */\n\t\tif ((sc->flags & MCDF_LOADED) == 0) {\n\t\t\terror = EIO;\n\t\t\tgoto bad3;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Lock the drawer.  This will also notice any pending disk\n\t\t * change or door open indicator and clear the MCDF_LOADED bit\n\t\t * if necessary.\n\t\t */\n\t\t(void) mcd_setlock(sc, MCD_LK_LOCK);\n\n\t\tif ((sc->flags & MCDF_LOADED) == 0) {\n\t\t\t/* Partially reset the state. */\n\t\t\tsc->lastmode = MCD_MD_UNKNOWN;\n\t\t\tsc->lastupc = MCD_UPC_UNKNOWN;\n\n\t\t\tsc->flags |= MCDF_LOADED;\n\n\t\t\t/* Set the mode, causing the disk to spin up. */\n\t\t\tif ((error = mcd_setmode(sc, MCD_MD_COOKED)) != 0)\n\t\t\t\tgoto bad2;\n\n\t\t\t/* Load the physical device parameters. */\n\t\t\tif (mcd_get_parms(sc) != 0) {\n\t\t\t\terror = ENXIO;\n\t\t\t\tgoto bad2;\n\t\t\t}\n\n\t\t\t/* Read the table of contents. */\n\t\t\tif ((error = mcd_read_toc(sc)) != 0)\n\t\t\t\tgoto bad2;\n\n\t\t\t/* Fabricate a disk label. */\n\t\t\tmcdgetdisklabel(dev, sc, sc->sc_dk.dk_label,\n\t\t\t    sc->sc_dk.dk_cpulabel, 0);\n\t\t}\n\t}\n\n\tMCD_TRACE(\"open: partition=%d disksize=%d blksize=%d\\n\", part,\n\t    sc->disksize, sc->blksize, 0);\n\n\tpart = MCDPART(dev);\n\t\n\t/* Check that the partition exists. */\n\tif (part != RAW_PART &&\n\t    (part >= sc->sc_dk.dk_label->d_npartitions ||\n\t     sc->sc_dk.dk_label->d_partitions[part].p_fstype == FS_UNUSED)) {\n\t\terror = ENXIO;\n\t\tgoto bad;\n\t}\n\n\t/* Insure only one open at a time. */\n\tswitch (fmt) {\n\tcase S_IFCHR:\n\t\tsc->sc_dk.dk_copenmask |= (1 << part);\n\t\tbreak;\n\tcase S_IFBLK:\n\t\tsc->sc_dk.dk_bopenmask |= (1 << part);\n\t\tbreak;\n\t}\n\tsc->sc_dk.dk_openmask = sc->sc_dk.dk_copenmask | sc->sc_dk.dk_bopenmask;\n\n\tmcdunlock(sc);\n\treturn 0;\n\nbad2:\n\tsc->flags &= ~MCDF_LOADED;\n\nbad:\n\tif (sc->sc_dk.dk_openmask == 0) {\n#if 0\n\t\t(void) mcd_setmode(sc, MCD_MD_SLEEP);\n#endif\n\t\t(void) mcd_setlock(sc, MCD_LK_UNLOCK);\n\t}\n\nbad3:\n\tmcdunlock(sc);\n\treturn error;\n}"
  },
  {
    "function_name": "mcdunlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
    "lines": "302-312",
    "snippet": "void\nmcdunlock(sc)\n\tstruct mcd_softc *sc;\n{\n\n\tsc->flags &= ~MCDF_LOCKED;\n\tif ((sc->flags & MCDF_WANTED) != 0) {\n\t\tsc->flags &= ~MCDF_WANTED;\n\t\twakeup(sc);\n\t}\n}",
    "includes": [
      "#include <lib/libkern/libkern.h>",
      "#include <dev/isa/opti.h>",
      "#include <dev/isa/mcdreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/errno.h>",
      "#include <sys/cdio.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/uio.h>",
      "#include <sys/stat.h>",
      "#include <sys/buf.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tMCDF_WANTED\t0x02",
      "#define\tMCDF_LOCKED\t0x01"
    ],
    "globals_used": [
      "void\tmcdunlock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "sc"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tMCDF_WANTED\t0x02\n#define\tMCDF_LOCKED\t0x01\n\nvoid\tmcdunlock;\n\nvoid\nmcdunlock(sc)\n\tstruct mcd_softc *sc;\n{\n\n\tsc->flags &= ~MCDF_LOCKED;\n\tif ((sc->flags & MCDF_WANTED) != 0) {\n\t\tsc->flags &= ~MCDF_WANTED;\n\t\twakeup(sc);\n\t}\n}"
  },
  {
    "function_name": "mcdlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
    "lines": "284-297",
    "snippet": "int\nmcdlock(sc)\n\tstruct mcd_softc *sc;\n{\n\tint error;\n\n\twhile ((sc->flags & MCDF_LOCKED) != 0) {\n\t\tsc->flags |= MCDF_WANTED;\n\t\tif ((error = tsleep(sc, PRIBIO | PCATCH, \"mcdlck\", 0)) != 0)\n\t\t\treturn error;\n\t}\n\tsc->flags |= MCDF_LOCKED;\n\treturn 0;\n}",
    "includes": [
      "#include <lib/libkern/libkern.h>",
      "#include <dev/isa/opti.h>",
      "#include <dev/isa/mcdreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/errno.h>",
      "#include <sys/cdio.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/uio.h>",
      "#include <sys/stat.h>",
      "#include <sys/buf.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tMCDF_WANTED\t0x02",
      "#define\tMCDF_LOCKED\t0x01"
    ],
    "globals_used": [
      "int\tmcdlock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "sc",
            "PRIBIO | PCATCH",
            "\"mcdlck\"",
            "0"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tMCDF_WANTED\t0x02\n#define\tMCDF_LOCKED\t0x01\n\nint\tmcdlock;\n\nint\nmcdlock(sc)\n\tstruct mcd_softc *sc;\n{\n\tint error;\n\n\twhile ((sc->flags & MCDF_LOCKED) != 0) {\n\t\tsc->flags |= MCDF_WANTED;\n\t\tif ((error = tsleep(sc, PRIBIO | PCATCH, \"mcdlck\", 0)) != 0)\n\t\t\treturn error;\n\t}\n\tsc->flags |= MCDF_LOCKED;\n\treturn 0;\n}"
  },
  {
    "function_name": "mcdattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
    "lines": "224-276",
    "snippet": "void\nmcdattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct mcd_softc *sc = (void *)self;\n\tstruct isa_attach_args *ia = aux;\n\tbus_space_tag_t iot = ia->ia_iot;\n\tbus_space_handle_t ioh;\n\tstruct mcd_mbox mbx;\n\n\t/* Map i/o space */\n\tif (bus_space_map(iot, ia->ia_iobase, MCD_NPORT, 0, &ioh)) {\n\t\tprintf(\": can't map i/o space\\n\");\n\t\treturn;\n\t}\n\n\tsc->sc_iot = iot;\n\tsc->sc_ioh = ioh;\n\n\tsc->probe = 0;\n\tsc->debug = 0;\n\n\tif (!mcd_find(iot, ioh, sc)) {\n\t\tprintf(\": mcd_find failed\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * Initialize and attach the disk structure.\n\t */\n\tsc->sc_dk.dk_driver = &mcddkdriver;\n\tsc->sc_dk.dk_name = sc->sc_dev.dv_xname;\n\tdisk_attach(&sc->sc_dk);\n\n\tdk_establish(&sc->sc_dk, &sc->sc_dev);\n\n\tprintf(\": model %s\\n\", sc->type != 0 ? sc->type : \"unknown\");\n\n\t(void) mcd_setlock(sc, MCD_LK_UNLOCK);\n\n\tmbx.cmd.opcode = MCD_CMDCONFIGDRIVE;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.config) - 1;\n\tmbx.cmd.data.config.subcommand = MCD_CF_IRQENABLE;\n\tmbx.cmd.data.config.data1 = 0x01;\n\tmbx.res.length = 0;\n\t(void) mcd_send(sc, &mbx, 0);\n\n\tmcd_soft_reset(sc);\n\n\tsc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,\n\t    IPL_BIO, mcdintr, sc, sc->sc_dev.dv_xname);\n}",
    "includes": [
      "#include <lib/libkern/libkern.h>",
      "#include <dev/isa/opti.h>",
      "#include <dev/isa/mcdreg.h>",
      "#include <dev/isa/isavar.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/disk.h>",
      "#include <sys/device.h>",
      "#include <sys/disklabel.h>",
      "#include <sys/errno.h>",
      "#include <sys/cdio.h>",
      "#include <sys/mtio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/uio.h>",
      "#include <sys/stat.h>",
      "#include <sys/buf.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int mcd_send",
      "int mcdintr",
      "void mcd_soft_reset",
      "int mcd_setlock",
      "int mcd_find",
      "void mcdattach",
      "struct dkdriver mcddkdriver = { mcdstrategy };",
      "void *aux;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "isa_intr_establish",
          "args": [
            "ia->ia_ic",
            "ia->ia_irq",
            "IST_EDGE",
            "IPL_BIO",
            "mcdintr",
            "sc",
            "sc->sc_dev.dv_xname"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mcd_soft_reset",
          "args": [
            "sc"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_soft_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1285-1296",
          "snippet": "void\nmcd_soft_reset(sc)\n\tstruct mcd_softc *sc;\n{\n\n\tsc->debug = 0;\n\tsc->flags = 0;\n\tsc->lastmode = MCD_MD_UNKNOWN;\n\tsc->lastupc = MCD_UPC_UNKNOWN;\n\tsc->audio_status = CD_AS_AUDIO_INVALID;\n\tbus_space_write_1(sc->sc_iot, sc->sc_ioh, MCD_CTL2, 0x0c); /* XXX */\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tMCD_UPC_UNKNOWN\t-1",
            "#define\tMCD_MD_UNKNOWN\t-1"
          ],
          "globals_used": [
            "void mcd_soft_reset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tMCD_UPC_UNKNOWN\t-1\n#define\tMCD_MD_UNKNOWN\t-1\n\nvoid mcd_soft_reset;\n\nvoid\nmcd_soft_reset(sc)\n\tstruct mcd_softc *sc;\n{\n\n\tsc->debug = 0;\n\tsc->flags = 0;\n\tsc->lastmode = MCD_MD_UNKNOWN;\n\tsc->lastupc = MCD_UPC_UNKNOWN;\n\tsc->audio_status = CD_AS_AUDIO_INVALID;\n\tbus_space_write_1(sc->sc_iot, sc->sc_ioh, MCD_CTL2, 0x0c); /* XXX */\n}"
        }
      },
      {
        "call_info": {
          "callee": "mcd_send",
          "args": [
            "sc",
            "&mbx",
            "0"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1044-1077",
          "snippet": "int\nmcd_send(sc, mbx, diskin)\n\tstruct mcd_softc *sc;\n\tstruct mcd_mbox *mbx;\n\tint diskin;\n{\n\tint retry, i, error;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\t\n\tif (sc->debug) {\n\t\tprintf(\"%s: mcd_send: %d %02x\", sc->sc_dev.dv_xname,\n\t\t    mbx->cmd.length, (u_int)mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tprintf(\" %02x\", (u_int)mbx->cmd.data.raw.data[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tfor (retry = MCD_RETRIES; retry; retry--) {\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.data.raw.data[i]);\n\t\tif ((error = mcd_getresult(sc, &mbx->res)) == 0)\n\t\t\tbreak;\n\t\tif (error == EINVAL)\n\t\t\treturn error;\n\t}\n\tif (!retry)\n\t\treturn error;\n\tif (diskin && (sc->flags & MCDF_LOADED) == 0)\n\t\treturn EIO;\n\n\treturn 0;\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MCD_RETRIES\t3",
            "#define\tMCDF_LOADED\t0x10\t/* parameters loaded */"
          ],
          "globals_used": [
            "int mcd_getresult",
            "int mcd_send"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MCD_RETRIES\t3\n#define\tMCDF_LOADED\t0x10\t/* parameters loaded */\n\nint mcd_getresult;\nint mcd_send;\n\nint\nmcd_send(sc, mbx, diskin)\n\tstruct mcd_softc *sc;\n\tstruct mcd_mbox *mbx;\n\tint diskin;\n{\n\tint retry, i, error;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\t\n\tif (sc->debug) {\n\t\tprintf(\"%s: mcd_send: %d %02x\", sc->sc_dev.dv_xname,\n\t\t    mbx->cmd.length, (u_int)mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tprintf(\" %02x\", (u_int)mbx->cmd.data.raw.data[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tfor (retry = MCD_RETRIES; retry; retry--) {\n\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.opcode);\n\t\tfor (i = 0; i < mbx->cmd.length; i++)\n\t\t\tbus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.data.raw.data[i]);\n\t\tif ((error = mcd_getresult(sc, &mbx->res)) == 0)\n\t\t\tbreak;\n\t\tif (error == EINVAL)\n\t\t\treturn error;\n\t}\n\tif (!retry)\n\t\treturn error;\n\tif (diskin && (sc->flags & MCDF_LOADED) == 0)\n\t\treturn EIO;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mcd_setlock",
          "args": [
            "sc",
            "MCD_LK_UNLOCK"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_setlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "1804-1816",
          "snippet": "int\nmcd_setlock(sc, mode)\n\tstruct mcd_softc *sc;\n\tint mode;\n{\n\tstruct mcd_mbox mbx;\n\t\n\tmbx.cmd.opcode = MCD_CMDSETLOCK;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.lockmode);\n\tmbx.cmd.data.lockmode.mode = mode;\n\tmbx.res.length = 0;\n\treturn mcd_send(sc, &mbx, 1);\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int mcd_send",
            "int mcd_setlock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint mcd_send;\nint mcd_setlock;\n\nint\nmcd_setlock(sc, mode)\n\tstruct mcd_softc *sc;\n\tint mode;\n{\n\tstruct mcd_mbox mbx;\n\t\n\tmbx.cmd.opcode = MCD_CMDSETLOCK;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.lockmode);\n\tmbx.cmd.data.lockmode.mode = mode;\n\tmbx.res.length = 0;\n\treturn mcd_send(sc, &mbx, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\": model %s\\n\"",
            "sc->type != 0 ? sc->type : \"unknown\""
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dk_establish",
          "args": [
            "&sc->sc_dk",
            "&sc->sc_dev"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_attach",
          "args": [
            "&sc->sc_dk"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mcd_find",
          "args": [
            "iot",
            "ioh",
            "sc"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "mcd_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/mcd.c",
          "lines": "813-885",
          "snippet": "int\nmcd_find(iot, ioh, sc)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tstruct mcd_softc *sc;\n{\n\tint i;\n\tstruct mcd_mbox mbx;\n\n        sc->sc_iot = iot;\n\tsc->sc_ioh = ioh;\n\n\t/* Send a reset. */\n\tbus_space_write_1(iot, ioh, MCD_RESET, 0);\n\tdelay(1000000);\n\t/* Get any pending status and throw away. */\n\tfor (i = 10; i; i--)\n\t\tbus_space_read_1(iot, ioh, MCD_STATUS);\n\tdelay(1000);\n\n\t/* Send get status command. */\n\tmbx.cmd.opcode = MCD_CMDGETSTAT;\n\tmbx.cmd.length = 0;\n\tmbx.res.length = 0;\n\tif (mcd_send(sc, &mbx, 0) != 0)\n\t\treturn 0;\n\n\t/* Get info about the drive. */\n\tmbx.cmd.opcode = MCD_CMDCONTINFO;\n\tmbx.cmd.length = 0;\n\tmbx.res.length = sizeof(mbx.res.data.continfo);\n\tif (mcd_send(sc, &mbx, 0) != 0)\n\t\treturn 0;\n\n\t/*\n\t * The following is code which is not guaranteed to work for all\n\t * drives, because the meaning of the expected 'M' is not clear\n\t * (M_itsumi is an obvious assumption, but I don't trust that).\n\t * Also, the original hack had a bogus condition that always\n\t * returned true.\n\t *\n\t * Note:  Which models support interrupts?  >=LU005S?\n\t */\n\tsc->readcmd = MCD_CMDREADSINGLESPEED;\n\tswitch (mbx.res.data.continfo.code) {\n\tcase 'M':\n\t\tif (mbx.res.data.continfo.version <= 2)\n\t\t\tsc->type = \"LU002S\";\n\t\telse if (mbx.res.data.continfo.version <= 5)\n\t\t\tsc->type = \"LU005S\";\n\t\telse\n\t\t\tsc->type = \"LU006S\";\n\t\tbreak;\n\tcase 'F':\n\t\tsc->type = \"FX001\";\n\t\tbreak;\n\tcase 'D':\n\t\tsc->type = \"FX001D\";\n\t\tsc->readcmd = MCD_CMDREADDOUBLESPEED;\n\t\tbreak;\n\tdefault:\n#ifdef MCDDEBUG\n\t\tprintf(\"%s: unrecognized drive version %c%02x; will try to use it anyway\\n\",\n\t\t    sc->sc_dev.dv_xname,\n\t\t    mbx.res.data.continfo.code, mbx.res.data.continfo.version);\n#endif\n\t\tsc->type = 0;\n\t\tbreak;\n\t}\n\n\treturn 1;\n\n}",
          "includes": [
            "#include <lib/libkern/libkern.h>",
            "#include <dev/isa/opti.h>",
            "#include <dev/isa/mcdreg.h>",
            "#include <dev/isa/isavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/disk.h>",
            "#include <sys/device.h>",
            "#include <sys/disklabel.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdio.h>",
            "#include <sys/mtio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/uio.h>",
            "#include <sys/stat.h>",
            "#include <sys/buf.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int mcd_send",
            "int mcd_find"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint mcd_send;\nint mcd_find;\n\nint\nmcd_find(iot, ioh, sc)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tstruct mcd_softc *sc;\n{\n\tint i;\n\tstruct mcd_mbox mbx;\n\n        sc->sc_iot = iot;\n\tsc->sc_ioh = ioh;\n\n\t/* Send a reset. */\n\tbus_space_write_1(iot, ioh, MCD_RESET, 0);\n\tdelay(1000000);\n\t/* Get any pending status and throw away. */\n\tfor (i = 10; i; i--)\n\t\tbus_space_read_1(iot, ioh, MCD_STATUS);\n\tdelay(1000);\n\n\t/* Send get status command. */\n\tmbx.cmd.opcode = MCD_CMDGETSTAT;\n\tmbx.cmd.length = 0;\n\tmbx.res.length = 0;\n\tif (mcd_send(sc, &mbx, 0) != 0)\n\t\treturn 0;\n\n\t/* Get info about the drive. */\n\tmbx.cmd.opcode = MCD_CMDCONTINFO;\n\tmbx.cmd.length = 0;\n\tmbx.res.length = sizeof(mbx.res.data.continfo);\n\tif (mcd_send(sc, &mbx, 0) != 0)\n\t\treturn 0;\n\n\t/*\n\t * The following is code which is not guaranteed to work for all\n\t * drives, because the meaning of the expected 'M' is not clear\n\t * (M_itsumi is an obvious assumption, but I don't trust that).\n\t * Also, the original hack had a bogus condition that always\n\t * returned true.\n\t *\n\t * Note:  Which models support interrupts?  >=LU005S?\n\t */\n\tsc->readcmd = MCD_CMDREADSINGLESPEED;\n\tswitch (mbx.res.data.continfo.code) {\n\tcase 'M':\n\t\tif (mbx.res.data.continfo.version <= 2)\n\t\t\tsc->type = \"LU002S\";\n\t\telse if (mbx.res.data.continfo.version <= 5)\n\t\t\tsc->type = \"LU005S\";\n\t\telse\n\t\t\tsc->type = \"LU006S\";\n\t\tbreak;\n\tcase 'F':\n\t\tsc->type = \"FX001\";\n\t\tbreak;\n\tcase 'D':\n\t\tsc->type = \"FX001D\";\n\t\tsc->readcmd = MCD_CMDREADDOUBLESPEED;\n\t\tbreak;\n\tdefault:\n#ifdef MCDDEBUG\n\t\tprintf(\"%s: unrecognized drive version %c%02x; will try to use it anyway\\n\",\n\t\t    sc->sc_dev.dv_xname,\n\t\t    mbx.res.data.continfo.code, mbx.res.data.continfo.version);\n#endif\n\t\tsc->type = 0;\n\t\tbreak;\n\t}\n\n\treturn 1;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "iot",
            "ia->ia_iobase",
            "MCD_NPORT",
            "0",
            "&ioh"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <lib/libkern/libkern.h>\n#include <dev/isa/opti.h>\n#include <dev/isa/mcdreg.h>\n#include <dev/isa/isavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/disk.h>\n#include <sys/device.h>\n#include <sys/disklabel.h>\n#include <sys/errno.h>\n#include <sys/cdio.h>\n#include <sys/mtio.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/buf.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint mcd_send;\nint mcdintr;\nvoid mcd_soft_reset;\nint mcd_setlock;\nint mcd_find;\nvoid mcdattach;\nstruct dkdriver mcddkdriver = { mcdstrategy };\nvoid *aux;\n\nvoid\nmcdattach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct mcd_softc *sc = (void *)self;\n\tstruct isa_attach_args *ia = aux;\n\tbus_space_tag_t iot = ia->ia_iot;\n\tbus_space_handle_t ioh;\n\tstruct mcd_mbox mbx;\n\n\t/* Map i/o space */\n\tif (bus_space_map(iot, ia->ia_iobase, MCD_NPORT, 0, &ioh)) {\n\t\tprintf(\": can't map i/o space\\n\");\n\t\treturn;\n\t}\n\n\tsc->sc_iot = iot;\n\tsc->sc_ioh = ioh;\n\n\tsc->probe = 0;\n\tsc->debug = 0;\n\n\tif (!mcd_find(iot, ioh, sc)) {\n\t\tprintf(\": mcd_find failed\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * Initialize and attach the disk structure.\n\t */\n\tsc->sc_dk.dk_driver = &mcddkdriver;\n\tsc->sc_dk.dk_name = sc->sc_dev.dv_xname;\n\tdisk_attach(&sc->sc_dk);\n\n\tdk_establish(&sc->sc_dk, &sc->sc_dev);\n\n\tprintf(\": model %s\\n\", sc->type != 0 ? sc->type : \"unknown\");\n\n\t(void) mcd_setlock(sc, MCD_LK_UNLOCK);\n\n\tmbx.cmd.opcode = MCD_CMDCONFIGDRIVE;\n\tmbx.cmd.length = sizeof(mbx.cmd.data.config) - 1;\n\tmbx.cmd.data.config.subcommand = MCD_CF_IRQENABLE;\n\tmbx.cmd.data.config.data1 = 0x01;\n\tmbx.res.length = 0;\n\t(void) mcd_send(sc, &mbx, 0);\n\n\tmcd_soft_reset(sc);\n\n\tsc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,\n\t    IPL_BIO, mcdintr, sc, sc->sc_dev.dv_xname);\n}"
  }
]