[
  {
    "function_name": "rf_ParityLoggingDagSelect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_paritylogging.c",
    "lines": "915-1050",
    "snippet": "void \nrf_ParityLoggingDagSelect(\n    RF_Raid_t * raidPtr,\n    RF_IoType_t type,\n    RF_AccessStripeMap_t * asmp,\n    RF_VoidFuncPtr * createFunc)\n{\n\tRF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);\n\tRF_PhysDiskAddr_t *failedPDA = NULL;\n\tRF_RowCol_t frow, fcol;\n\tRF_RowStatus_t rstat;\n\tint     prior_recon;\n\n\tRF_ASSERT(RF_IO_IS_R_OR_W(type));\n\n\tif (asmp->numDataFailed + asmp->numParityFailed > 1) {\n\t\tRF_ERRORMSG(\"Multiple disks failed in a single group!  Aborting I/O operation.\\n\");\n\t\t /* *infoFunc = */ *createFunc = NULL;\n\t\treturn;\n\t} else\n\t\tif (asmp->numDataFailed + asmp->numParityFailed == 1) {\n\n\t\t\t/* if under recon & already reconstructed, redirect\n\t\t\t * the access to the spare drive and eliminate the\n\t\t\t * failure indication */\n\t\t\tfailedPDA = asmp->failedPDAs[0];\n\t\t\tfrow = failedPDA->row;\n\t\t\tfcol = failedPDA->col;\n\t\t\trstat = raidPtr->status[failedPDA->row];\n\t\t\tprior_recon = (rstat == rf_rs_reconfigured) || (\n\t\t\t    (rstat == rf_rs_reconstructing) ?\n\t\t\t    rf_CheckRUReconstructed(raidPtr->reconControl[frow]->reconMap, failedPDA->startSector) : 0\n\t\t\t    );\n\t\t\tif (prior_recon) {\n\t\t\t\tRF_RowCol_t or = failedPDA->row, oc = failedPDA->col;\n\t\t\t\tRF_SectorNum_t oo = failedPDA->startSector;\n\t\t\t\tif (layoutPtr->map->flags & \n\t\t\t\t    RF_DISTRIBUTE_SPARE) {\t\n\t\t\t\t\t/* redirect to dist spare space */\n\n\t\t\t\t\tif (failedPDA == asmp->parityInfo) {\n\n\t\t\t\t\t\t/* parity has failed */\n\t\t\t\t\t\t(layoutPtr->map->MapParity) (raidPtr, failedPDA->raidAddress, &failedPDA->row,\n\t\t\t\t\t\t    &failedPDA->col, &failedPDA->startSector, RF_REMAP);\n\n\t\t\t\t\t\tif (asmp->parityInfo->next) {\t/* redir 2nd component,\n\t\t\t\t\t\t\t\t\t\t * if any */\n\t\t\t\t\t\t\tRF_PhysDiskAddr_t *p = asmp->parityInfo->next;\n\t\t\t\t\t\t\tRF_SectorNum_t SUoffs = p->startSector % layoutPtr->sectorsPerStripeUnit;\n\t\t\t\t\t\t\tp->row = failedPDA->row;\n\t\t\t\t\t\t\tp->col = failedPDA->col;\n\t\t\t\t\t\t\tp->startSector = rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr, failedPDA->startSector) +\n\t\t\t\t\t\t\t    SUoffs;\t/* cheating:\n\t\t\t\t\t\t\t\t\t * startSector is not\n\t\t\t\t\t\t\t\t\t * really a RAID address */\n\t\t\t\t\t\t}\n\t\t\t\t\t} else\n\t\t\t\t\t\tif (asmp->parityInfo->next && failedPDA == asmp->parityInfo->next) {\n\t\t\t\t\t\t\tRF_ASSERT(0);\t/* should not ever\n\t\t\t\t\t\t\t\t\t * happen */\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t/* data has failed */\n\t\t\t\t\t\t\t(layoutPtr->map->MapSector) (raidPtr, failedPDA->raidAddress, &failedPDA->row,\n\t\t\t\t\t\t\t    &failedPDA->col, &failedPDA->startSector, RF_REMAP);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t} else {\t\n\t\t\t\t\t/* redirect to dedicated spare space */\n\n\t\t\t\t\tfailedPDA->row = raidPtr->Disks[frow][fcol].spareRow;\n\t\t\t\t\tfailedPDA->col = raidPtr->Disks[frow][fcol].spareCol;\n\n\t\t\t\t\t/* the parity may have two distinct\n\t\t\t\t\t * components, both of which may need\n\t\t\t\t\t * to be redirected */\n\t\t\t\t\tif (asmp->parityInfo->next) {\n\t\t\t\t\t\tif (failedPDA == asmp->parityInfo) {\n\t\t\t\t\t\t\tfailedPDA->next->row = failedPDA->row;\n\t\t\t\t\t\t\tfailedPDA->next->col = failedPDA->col;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tif (failedPDA == asmp->parityInfo->next) {\t/* paranoid:  should never occur */\n\t\t\t\t\t\t\t\tasmp->parityInfo->row = failedPDA->row;\n\t\t\t\t\t\t\t\tasmp->parityInfo->col = failedPDA->col;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tRF_ASSERT(failedPDA->col != -1);\n\n\t\t\t\tif (rf_dagDebug || rf_mapDebug) {\n\t\t\t\t\tprintf(\"raid%d: Redirected type '%c' r %d c %d o %ld -> r %d c %d o %ld\\n\",\n\t\t\t\t\t    raidPtr->raidid, type, or, oc, (long) oo, failedPDA->row, failedPDA->col, (long) failedPDA->startSector);\n\t\t\t\t}\n\t\t\t\tasmp->numDataFailed = asmp->numParityFailed = 0;\n\t\t\t}\n\t\t}\n\tif (type == RF_IO_TYPE_READ) {\n\n\t\tif (asmp->numDataFailed == 0)\n\t\t\t*createFunc = (RF_VoidFuncPtr) rf_CreateFaultFreeReadDAG;\n\t\telse\n\t\t\t*createFunc = (RF_VoidFuncPtr) rf_CreateRaidFiveDegradedReadDAG;\n\n\t} else {\n\n\n\t\t/* if mirroring, always use large writes.  If the access\n\t\t * requires two distinct parity updates, always do a small\n\t\t * write.  If the stripe contains a failure but the access\n\t\t * does not, do a small write. The first conditional\n\t\t * (numStripeUnitsAccessed <= numDataCol/2) uses a\n\t\t * less-than-or-equal rather than just a less-than because\n\t\t * when G is 3 or 4, numDataCol/2 is 1, and I want\n\t\t * single-stripe-unit updates to use just one disk. */\n\t\tif ((asmp->numDataFailed + asmp->numParityFailed) == 0) {\n\t\t\tif (((asmp->numStripeUnitsAccessed <= \n\t\t\t      (layoutPtr->numDataCol / 2)) && \n\t\t\t     (layoutPtr->numDataCol != 1)) ||\n\t\t\t    (asmp->parityInfo->next != NULL) || \n\t\t\t    rf_CheckStripeForFailures(raidPtr, asmp)) {\n\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_CreateParityLoggingSmallWriteDAG;\n\t\t\t} else\n\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_CreateParityLoggingLargeWriteDAG;\n\t\t} else\n\t\t\tif (asmp->numParityFailed == 1)\n\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_CreateNonRedundantWriteDAG;\n\t\t\telse\n\t\t\t\tif (asmp->numStripeUnitsAccessed != 1 && failedPDA->numSector != layoutPtr->sectorsPerStripeUnit)\n\t\t\t\t\t*createFunc = NULL;\n\t\t\t\telse\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_CreateDegradedWriteDAG;\n\t}\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_parityloggingdags.h\"",
      "#include \"rf_paritylogging.h\"",
      "#include \"rf_paritylogDiskMgr.h\"",
      "#include \"rf_paritylog.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_CheckStripeForFailures",
          "args": [
            "raidPtr",
            "asmp"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "rf_CheckStripeForFailures",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_map.c",
          "lines": "608-655",
          "snippet": "int \nrf_CheckStripeForFailures(raidPtr, asmap)\n\tRF_Raid_t *raidPtr;\n\tRF_AccessStripeMap_t *asmap;\n{\n\tRF_RowCol_t trow, tcol, prow, pcol, *diskids, row, i;\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_StripeCount_t stripeOffset;\n\tint     numFailures;\n\tRF_RaidAddr_t sosAddr;\n\tRF_SectorNum_t diskOffset, poffset;\n\tRF_RowCol_t testrow;\n\n\t/* quick out in the fault-free case.  */\n\tRF_LOCK_MUTEX(raidPtr->mutex);\n\tnumFailures = raidPtr->numFailures;\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\tif (numFailures == 0)\n\t\treturn (0);\n\n\tsosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, asmap->raidAddress);\n\trow = asmap->physInfo->row;\n\t(layoutPtr->map->IdentifyStripe) (raidPtr, asmap->raidAddress, &diskids, &testrow);\n\t(layoutPtr->map->MapParity) (raidPtr, asmap->raidAddress, &prow, &pcol, &poffset, 0);\t/* get pcol */\n\n\t/* this need not be true if we've redirected the access to a spare in\n\t * another row RF_ASSERT(row == testrow); */\n\tstripeOffset = 0;\n\tfor (i = 0; i < layoutPtr->numDataCol + layoutPtr->numParityCol; i++) {\n\t\tif (diskids[i] != pcol) {\n\t\t\tif (RF_DEAD_DISK(raidPtr->Disks[testrow][diskids[i]].status)) {\n\t\t\t\tif (raidPtr->status[testrow] != rf_rs_reconstructing)\n\t\t\t\t\treturn (1);\n\t\t\t\tRF_ASSERT(raidPtr->reconControl[testrow]->fcol == diskids[i]);\n\t\t\t\tlayoutPtr->map->MapSector(raidPtr,\n\t\t\t\t    sosAddr + stripeOffset * layoutPtr->sectorsPerStripeUnit,\n\t\t\t\t    &trow, &tcol, &diskOffset, 0);\n\t\t\t\tRF_ASSERT((trow == testrow) && (tcol == diskids[i]));\n\t\t\t\tif (!rf_CheckRUReconstructed(raidPtr->reconControl[testrow]->reconMap, diskOffset))\n\t\t\t\t\treturn (1);\n\t\t\t\tasmap->flags |= RF_ASM_REDIR_LARGE_WRITE;\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tstripeOffset++;\n\t\t}\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "RF_AccessStripeMapHeader_t *\nrf_MapAccess(raidPtr, raidAddress, numBlocks, buffer, remap)\n\tRF_Raid_t *raidPtr;",
            "RF_RaidAddr_t raidAddress;",
            "RF_AccessStripeMap_t *\nrf_DuplicateASM(asmap)\n\tRF_AccessStripeMap_t *asmap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nRF_AccessStripeMapHeader_t *\nrf_MapAccess(raidPtr, raidAddress, numBlocks, buffer, remap)\n\tRF_Raid_t *raidPtr;\nRF_RaidAddr_t raidAddress;\nRF_AccessStripeMap_t *\nrf_DuplicateASM(asmap)\n\tRF_AccessStripeMap_t *asmap;\n\nint \nrf_CheckStripeForFailures(raidPtr, asmap)\n\tRF_Raid_t *raidPtr;\n\tRF_AccessStripeMap_t *asmap;\n{\n\tRF_RowCol_t trow, tcol, prow, pcol, *diskids, row, i;\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_StripeCount_t stripeOffset;\n\tint     numFailures;\n\tRF_RaidAddr_t sosAddr;\n\tRF_SectorNum_t diskOffset, poffset;\n\tRF_RowCol_t testrow;\n\n\t/* quick out in the fault-free case.  */\n\tRF_LOCK_MUTEX(raidPtr->mutex);\n\tnumFailures = raidPtr->numFailures;\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\tif (numFailures == 0)\n\t\treturn (0);\n\n\tsosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, asmap->raidAddress);\n\trow = asmap->physInfo->row;\n\t(layoutPtr->map->IdentifyStripe) (raidPtr, asmap->raidAddress, &diskids, &testrow);\n\t(layoutPtr->map->MapParity) (raidPtr, asmap->raidAddress, &prow, &pcol, &poffset, 0);\t/* get pcol */\n\n\t/* this need not be true if we've redirected the access to a spare in\n\t * another row RF_ASSERT(row == testrow); */\n\tstripeOffset = 0;\n\tfor (i = 0; i < layoutPtr->numDataCol + layoutPtr->numParityCol; i++) {\n\t\tif (diskids[i] != pcol) {\n\t\t\tif (RF_DEAD_DISK(raidPtr->Disks[testrow][diskids[i]].status)) {\n\t\t\t\tif (raidPtr->status[testrow] != rf_rs_reconstructing)\n\t\t\t\t\treturn (1);\n\t\t\t\tRF_ASSERT(raidPtr->reconControl[testrow]->fcol == diskids[i]);\n\t\t\t\tlayoutPtr->map->MapSector(raidPtr,\n\t\t\t\t    sosAddr + stripeOffset * layoutPtr->sectorsPerStripeUnit,\n\t\t\t\t    &trow, &tcol, &diskOffset, 0);\n\t\t\t\tRF_ASSERT((trow == testrow) && (tcol == diskids[i]));\n\t\t\t\tif (!rf_CheckRUReconstructed(raidPtr->reconControl[testrow]->reconMap, diskOffset))\n\t\t\t\t\treturn (1);\n\t\t\t\tasmap->flags |= RF_ASM_REDIR_LARGE_WRITE;\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tstripeOffset++;\n\t\t}\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"raid%d: Redirected type '%c' r %d c %d o %ld -> r %d c %d o %ld\\n\"",
            "raidPtr->raidid",
            "type",
            "or",
            "oc",
            "(long) oo",
            "failedPDA->row",
            "failedPDA->col",
            "(long) failedPDA->startSector"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "failedPDA->col != -1"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "raidPtr",
            "failedPDA->raidAddress",
            "&failedPDA->row",
            "&failedPDA->col",
            "&failedPDA->startSector",
            "RF_REMAP"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "0"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressOfPrevStripeUnitBoundary",
          "args": [
            "layoutPtr",
            "failedPDA->startSector"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "raidPtr",
            "failedPDA->raidAddress",
            "&failedPDA->row",
            "&failedPDA->col",
            "&failedPDA->startSector",
            "RF_REMAP"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_CheckRUReconstructed",
          "args": [
            "raidPtr->reconControl[frow]->reconMap",
            "failedPDA->startSector"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "rf_CheckRUReconstructed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_reconmap.c",
          "lines": "308-319",
          "snippet": "int \nrf_CheckRUReconstructed(mapPtr, startSector)\n\tRF_ReconMap_t *mapPtr;\n\tRF_SectorNum_t startSector;\n{\n\tRF_ReconMapListElem_t *l;\t/* used for searching */\n\tRF_ReconUnitNum_t i;\n\n\ti = startSector / mapPtr->sectorsPerReconUnit;\n\tl = mapPtr->status[i];\n\treturn ((l == RU_ALL) ? 1 : 0);\n}",
          "includes": [
            "#include \"rf_utils.h\"",
            "#include \"rf_general.h\"",
            "#include <sys/time.h>",
            "#include \"rf_raid.h\""
          ],
          "macros_used": [
            "#define RU_ALL      ((RF_ReconMapListElem_t *) -1)"
          ],
          "globals_used": [
            "static void \ncompact_stat_entry(RF_Raid_t * raidPtr, RF_ReconMap_t * mapPtr,\n    int i);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_utils.h\"\n#include \"rf_general.h\"\n#include <sys/time.h>\n#include \"rf_raid.h\"\n\n#define RU_ALL      ((RF_ReconMapListElem_t *) -1)\n\nstatic void \ncompact_stat_entry(RF_Raid_t * raidPtr, RF_ReconMap_t * mapPtr,\n    int i);\n\nint \nrf_CheckRUReconstructed(mapPtr, startSector)\n\tRF_ReconMap_t *mapPtr;\n\tRF_SectorNum_t startSector;\n{\n\tRF_ReconMapListElem_t *l;\t/* used for searching */\n\tRF_ReconUnitNum_t i;\n\n\ti = startSector / mapPtr->sectorsPerReconUnit;\n\tl = mapPtr->status[i];\n\treturn ((l == RU_ALL) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG",
          "args": [
            "\"Multiple disks failed in a single group!  Aborting I/O operation.\\n\""
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "RF_IO_IS_R_OR_W(type)"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_IO_IS_R_OR_W",
          "args": [
            "type"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_parityloggingdags.h\"\n#include \"rf_paritylogging.h\"\n#include \"rf_paritylogDiskMgr.h\"\n#include \"rf_paritylog.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nvoid \nrf_ParityLoggingDagSelect(\n    RF_Raid_t * raidPtr,\n    RF_IoType_t type,\n    RF_AccessStripeMap_t * asmp,\n    RF_VoidFuncPtr * createFunc)\n{\n\tRF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);\n\tRF_PhysDiskAddr_t *failedPDA = NULL;\n\tRF_RowCol_t frow, fcol;\n\tRF_RowStatus_t rstat;\n\tint     prior_recon;\n\n\tRF_ASSERT(RF_IO_IS_R_OR_W(type));\n\n\tif (asmp->numDataFailed + asmp->numParityFailed > 1) {\n\t\tRF_ERRORMSG(\"Multiple disks failed in a single group!  Aborting I/O operation.\\n\");\n\t\t /* *infoFunc = */ *createFunc = NULL;\n\t\treturn;\n\t} else\n\t\tif (asmp->numDataFailed + asmp->numParityFailed == 1) {\n\n\t\t\t/* if under recon & already reconstructed, redirect\n\t\t\t * the access to the spare drive and eliminate the\n\t\t\t * failure indication */\n\t\t\tfailedPDA = asmp->failedPDAs[0];\n\t\t\tfrow = failedPDA->row;\n\t\t\tfcol = failedPDA->col;\n\t\t\trstat = raidPtr->status[failedPDA->row];\n\t\t\tprior_recon = (rstat == rf_rs_reconfigured) || (\n\t\t\t    (rstat == rf_rs_reconstructing) ?\n\t\t\t    rf_CheckRUReconstructed(raidPtr->reconControl[frow]->reconMap, failedPDA->startSector) : 0\n\t\t\t    );\n\t\t\tif (prior_recon) {\n\t\t\t\tRF_RowCol_t or = failedPDA->row, oc = failedPDA->col;\n\t\t\t\tRF_SectorNum_t oo = failedPDA->startSector;\n\t\t\t\tif (layoutPtr->map->flags & \n\t\t\t\t    RF_DISTRIBUTE_SPARE) {\t\n\t\t\t\t\t/* redirect to dist spare space */\n\n\t\t\t\t\tif (failedPDA == asmp->parityInfo) {\n\n\t\t\t\t\t\t/* parity has failed */\n\t\t\t\t\t\t(layoutPtr->map->MapParity) (raidPtr, failedPDA->raidAddress, &failedPDA->row,\n\t\t\t\t\t\t    &failedPDA->col, &failedPDA->startSector, RF_REMAP);\n\n\t\t\t\t\t\tif (asmp->parityInfo->next) {\t/* redir 2nd component,\n\t\t\t\t\t\t\t\t\t\t * if any */\n\t\t\t\t\t\t\tRF_PhysDiskAddr_t *p = asmp->parityInfo->next;\n\t\t\t\t\t\t\tRF_SectorNum_t SUoffs = p->startSector % layoutPtr->sectorsPerStripeUnit;\n\t\t\t\t\t\t\tp->row = failedPDA->row;\n\t\t\t\t\t\t\tp->col = failedPDA->col;\n\t\t\t\t\t\t\tp->startSector = rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr, failedPDA->startSector) +\n\t\t\t\t\t\t\t    SUoffs;\t/* cheating:\n\t\t\t\t\t\t\t\t\t * startSector is not\n\t\t\t\t\t\t\t\t\t * really a RAID address */\n\t\t\t\t\t\t}\n\t\t\t\t\t} else\n\t\t\t\t\t\tif (asmp->parityInfo->next && failedPDA == asmp->parityInfo->next) {\n\t\t\t\t\t\t\tRF_ASSERT(0);\t/* should not ever\n\t\t\t\t\t\t\t\t\t * happen */\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t/* data has failed */\n\t\t\t\t\t\t\t(layoutPtr->map->MapSector) (raidPtr, failedPDA->raidAddress, &failedPDA->row,\n\t\t\t\t\t\t\t    &failedPDA->col, &failedPDA->startSector, RF_REMAP);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t} else {\t\n\t\t\t\t\t/* redirect to dedicated spare space */\n\n\t\t\t\t\tfailedPDA->row = raidPtr->Disks[frow][fcol].spareRow;\n\t\t\t\t\tfailedPDA->col = raidPtr->Disks[frow][fcol].spareCol;\n\n\t\t\t\t\t/* the parity may have two distinct\n\t\t\t\t\t * components, both of which may need\n\t\t\t\t\t * to be redirected */\n\t\t\t\t\tif (asmp->parityInfo->next) {\n\t\t\t\t\t\tif (failedPDA == asmp->parityInfo) {\n\t\t\t\t\t\t\tfailedPDA->next->row = failedPDA->row;\n\t\t\t\t\t\t\tfailedPDA->next->col = failedPDA->col;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tif (failedPDA == asmp->parityInfo->next) {\t/* paranoid:  should never occur */\n\t\t\t\t\t\t\t\tasmp->parityInfo->row = failedPDA->row;\n\t\t\t\t\t\t\t\tasmp->parityInfo->col = failedPDA->col;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tRF_ASSERT(failedPDA->col != -1);\n\n\t\t\t\tif (rf_dagDebug || rf_mapDebug) {\n\t\t\t\t\tprintf(\"raid%d: Redirected type '%c' r %d c %d o %ld -> r %d c %d o %ld\\n\",\n\t\t\t\t\t    raidPtr->raidid, type, or, oc, (long) oo, failedPDA->row, failedPDA->col, (long) failedPDA->startSector);\n\t\t\t\t}\n\t\t\t\tasmp->numDataFailed = asmp->numParityFailed = 0;\n\t\t\t}\n\t\t}\n\tif (type == RF_IO_TYPE_READ) {\n\n\t\tif (asmp->numDataFailed == 0)\n\t\t\t*createFunc = (RF_VoidFuncPtr) rf_CreateFaultFreeReadDAG;\n\t\telse\n\t\t\t*createFunc = (RF_VoidFuncPtr) rf_CreateRaidFiveDegradedReadDAG;\n\n\t} else {\n\n\n\t\t/* if mirroring, always use large writes.  If the access\n\t\t * requires two distinct parity updates, always do a small\n\t\t * write.  If the stripe contains a failure but the access\n\t\t * does not, do a small write. The first conditional\n\t\t * (numStripeUnitsAccessed <= numDataCol/2) uses a\n\t\t * less-than-or-equal rather than just a less-than because\n\t\t * when G is 3 or 4, numDataCol/2 is 1, and I want\n\t\t * single-stripe-unit updates to use just one disk. */\n\t\tif ((asmp->numDataFailed + asmp->numParityFailed) == 0) {\n\t\t\tif (((asmp->numStripeUnitsAccessed <= \n\t\t\t      (layoutPtr->numDataCol / 2)) && \n\t\t\t     (layoutPtr->numDataCol != 1)) ||\n\t\t\t    (asmp->parityInfo->next != NULL) || \n\t\t\t    rf_CheckStripeForFailures(raidPtr, asmp)) {\n\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_CreateParityLoggingSmallWriteDAG;\n\t\t\t} else\n\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_CreateParityLoggingLargeWriteDAG;\n\t\t} else\n\t\t\tif (asmp->numParityFailed == 1)\n\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_CreateNonRedundantWriteDAG;\n\t\t\telse\n\t\t\t\tif (asmp->numStripeUnitsAccessed != 1 && failedPDA->numSector != layoutPtr->sectorsPerStripeUnit)\n\t\t\t\t\t*createFunc = NULL;\n\t\t\t\telse\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_CreateDegradedWriteDAG;\n\t}\n}"
  },
  {
    "function_name": "rf_MapSIDToPSIDParityLogging",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_paritylogging.c",
    "lines": "899-908",
    "snippet": "void \nrf_MapSIDToPSIDParityLogging(\n    RF_RaidLayout_t * layoutPtr,\n    RF_StripeNum_t stripeID,\n    RF_StripeNum_t * psID,\n    RF_ReconUnitNum_t * which_ru)\n{\n\t*which_ru = 0;\n\t*psID = stripeID;\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_parityloggingdags.h\"",
      "#include \"rf_paritylogging.h\"",
      "#include \"rf_paritylogDiskMgr.h\"",
      "#include \"rf_paritylog.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_parityloggingdags.h\"\n#include \"rf_paritylogging.h\"\n#include \"rf_paritylogDiskMgr.h\"\n#include \"rf_paritylog.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nvoid \nrf_MapSIDToPSIDParityLogging(\n    RF_RaidLayout_t * layoutPtr,\n    RF_StripeNum_t stripeID,\n    RF_StripeNum_t * psID,\n    RF_ReconUnitNum_t * which_ru)\n{\n\t*which_ru = 0;\n\t*psID = stripeID;\n}"
  },
  {
    "function_name": "rf_IdentifyStripeParityLogging",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_paritylogging.c",
    "lines": "883-896",
    "snippet": "void \nrf_IdentifyStripeParityLogging(\n    RF_Raid_t * raidPtr,\n    RF_RaidAddr_t addr,\n    RF_RowCol_t ** diskids,\n    RF_RowCol_t * outRow)\n{\n\tRF_StripeNum_t stripeID = rf_RaidAddressToStripeID(&raidPtr->Layout, \n\t\t\t\t\t\t\t   addr);\n\tRF_ParityLoggingConfigInfo_t *info = (RF_ParityLoggingConfigInfo_t *) \n\t\traidPtr->Layout.layoutSpecificInfo;\n\t*outRow = 0;\n\t*diskids = info->stripeIdentifier[stripeID % raidPtr->numCol];\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_parityloggingdags.h\"",
      "#include \"rf_paritylogging.h\"",
      "#include \"rf_paritylogDiskMgr.h\"",
      "#include \"rf_paritylog.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_RaidAddressToStripeID",
          "args": [
            "&raidPtr->Layout",
            "addr"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_parityloggingdags.h\"\n#include \"rf_paritylogging.h\"\n#include \"rf_paritylogDiskMgr.h\"\n#include \"rf_paritylog.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nvoid \nrf_IdentifyStripeParityLogging(\n    RF_Raid_t * raidPtr,\n    RF_RaidAddr_t addr,\n    RF_RowCol_t ** diskids,\n    RF_RowCol_t * outRow)\n{\n\tRF_StripeNum_t stripeID = rf_RaidAddressToStripeID(&raidPtr->Layout, \n\t\t\t\t\t\t\t   addr);\n\tRF_ParityLoggingConfigInfo_t *info = (RF_ParityLoggingConfigInfo_t *) \n\t\traidPtr->Layout.layoutSpecificInfo;\n\t*outRow = 0;\n\t*diskids = info->stripeIdentifier[stripeID % raidPtr->numCol];\n}"
  },
  {
    "function_name": "rf_MapRegionParity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_paritylogging.c",
    "lines": "865-878",
    "snippet": "void \nrf_MapRegionParity(\n    RF_Raid_t * raidPtr,\n    RF_RegionId_t regionID,\n    RF_RowCol_t * row,\n    RF_RowCol_t * col,\n    RF_SectorNum_t * startSector,\n    RF_SectorCount_t * numSector)\n{\n\t*row = 0;\n\t*col = raidPtr->numCol - 2;\n\t*startSector = raidPtr->regionInfo[regionID].parityStartAddr;\n\t*numSector = raidPtr->regionInfo[regionID].numSectorsParity;\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_parityloggingdags.h\"",
      "#include \"rf_paritylogging.h\"",
      "#include \"rf_paritylogDiskMgr.h\"",
      "#include \"rf_paritylog.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_parityloggingdags.h\"\n#include \"rf_paritylogging.h\"\n#include \"rf_paritylogDiskMgr.h\"\n#include \"rf_paritylog.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nvoid \nrf_MapRegionParity(\n    RF_Raid_t * raidPtr,\n    RF_RegionId_t regionID,\n    RF_RowCol_t * row,\n    RF_RowCol_t * col,\n    RF_SectorNum_t * startSector,\n    RF_SectorCount_t * numSector)\n{\n\t*row = 0;\n\t*col = raidPtr->numCol - 2;\n\t*startSector = raidPtr->regionInfo[regionID].parityStartAddr;\n\t*numSector = raidPtr->regionInfo[regionID].numSectorsParity;\n}"
  },
  {
    "function_name": "rf_MapLogParityLogging",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_paritylogging.c",
    "lines": "848-860",
    "snippet": "void \nrf_MapLogParityLogging(\n    RF_Raid_t * raidPtr,\n    RF_RegionId_t regionID,\n    RF_SectorNum_t regionOffset,\n    RF_RowCol_t * row,\n    RF_RowCol_t * col,\n    RF_SectorNum_t * startSector)\n{\n\t*row = 0;\n\t*col = raidPtr->numCol - 1;\n\t*startSector = raidPtr->regionInfo[regionID].regionStartAddr + regionOffset;\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_parityloggingdags.h\"",
      "#include \"rf_paritylogging.h\"",
      "#include \"rf_paritylogDiskMgr.h\"",
      "#include \"rf_paritylog.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_parityloggingdags.h\"\n#include \"rf_paritylogging.h\"\n#include \"rf_paritylogDiskMgr.h\"\n#include \"rf_paritylog.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nvoid \nrf_MapLogParityLogging(\n    RF_Raid_t * raidPtr,\n    RF_RegionId_t regionID,\n    RF_SectorNum_t regionOffset,\n    RF_RowCol_t * row,\n    RF_RowCol_t * col,\n    RF_SectorNum_t * startSector)\n{\n\t*row = 0;\n\t*col = raidPtr->numCol - 1;\n\t*startSector = raidPtr->regionInfo[regionID].regionStartAddr + regionOffset;\n}"
  },
  {
    "function_name": "rf_MapParityParityLogging",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_paritylogging.c",
    "lines": "824-844",
    "snippet": "void \nrf_MapParityParityLogging(\n    RF_Raid_t * raidPtr,\n    RF_RaidAddr_t raidSector,\n    RF_RowCol_t * row,\n    RF_RowCol_t * col,\n    RF_SectorNum_t * diskSector,\n    int remap)\n{\n\tRF_StripeNum_t SUID = raidSector / \n\t\traidPtr->Layout.sectorsPerStripeUnit;\n\n\t*row = 0;\n\t/* *col =\n\t * raidPtr->Layout.numDataCol-(SUID/raidPtr->Layout.numDataCol)%(raidPt\n\t * r->numCol - raidPtr->Layout.numParityLogCol); */\n\t*col = raidPtr->Layout.numDataCol;\n\t*diskSector = (SUID / (raidPtr->Layout.numDataCol)) * \n\t\traidPtr->Layout.sectorsPerStripeUnit +\n\t    (raidSector % raidPtr->Layout.sectorsPerStripeUnit);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_parityloggingdags.h\"",
      "#include \"rf_paritylogging.h\"",
      "#include \"rf_paritylogDiskMgr.h\"",
      "#include \"rf_paritylog.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_parityloggingdags.h\"\n#include \"rf_paritylogging.h\"\n#include \"rf_paritylogDiskMgr.h\"\n#include \"rf_paritylog.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nvoid \nrf_MapParityParityLogging(\n    RF_Raid_t * raidPtr,\n    RF_RaidAddr_t raidSector,\n    RF_RowCol_t * row,\n    RF_RowCol_t * col,\n    RF_SectorNum_t * diskSector,\n    int remap)\n{\n\tRF_StripeNum_t SUID = raidSector / \n\t\traidPtr->Layout.sectorsPerStripeUnit;\n\n\t*row = 0;\n\t/* *col =\n\t * raidPtr->Layout.numDataCol-(SUID/raidPtr->Layout.numDataCol)%(raidPt\n\t * r->numCol - raidPtr->Layout.numParityLogCol); */\n\t*col = raidPtr->Layout.numDataCol;\n\t*diskSector = (SUID / (raidPtr->Layout.numDataCol)) * \n\t\traidPtr->Layout.sectorsPerStripeUnit +\n\t    (raidSector % raidPtr->Layout.sectorsPerStripeUnit);\n}"
  },
  {
    "function_name": "rf_MapSectorParityLogging",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_paritylogging.c",
    "lines": "802-820",
    "snippet": "void \nrf_MapSectorParityLogging(\n    RF_Raid_t * raidPtr,\n    RF_RaidAddr_t raidSector,\n    RF_RowCol_t * row,\n    RF_RowCol_t * col,\n    RF_SectorNum_t * diskSector,\n    int remap)\n{\n\tRF_StripeNum_t SUID = raidSector / \n\t\traidPtr->Layout.sectorsPerStripeUnit;\n\t*row = 0;\n\t/* *col = (SUID % (raidPtr->numCol -\n\t * raidPtr->Layout.numParityLogCol)); */\n\t*col = SUID % raidPtr->Layout.numDataCol;\n\t*diskSector = (SUID / (raidPtr->Layout.numDataCol)) * \n\t\traidPtr->Layout.sectorsPerStripeUnit +\n\t    (raidSector % raidPtr->Layout.sectorsPerStripeUnit);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_parityloggingdags.h\"",
      "#include \"rf_paritylogging.h\"",
      "#include \"rf_paritylogDiskMgr.h\"",
      "#include \"rf_paritylog.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_parityloggingdags.h\"\n#include \"rf_paritylogging.h\"\n#include \"rf_paritylogDiskMgr.h\"\n#include \"rf_paritylog.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nvoid \nrf_MapSectorParityLogging(\n    RF_Raid_t * raidPtr,\n    RF_RaidAddr_t raidSector,\n    RF_RowCol_t * row,\n    RF_RowCol_t * col,\n    RF_SectorNum_t * diskSector,\n    int remap)\n{\n\tRF_StripeNum_t SUID = raidSector / \n\t\traidPtr->Layout.sectorsPerStripeUnit;\n\t*row = 0;\n\t/* *col = (SUID % (raidPtr->numCol -\n\t * raidPtr->Layout.numParityLogCol)); */\n\t*col = SUID % raidPtr->Layout.numDataCol;\n\t*diskSector = (SUID / (raidPtr->Layout.numDataCol)) * \n\t\traidPtr->Layout.sectorsPerStripeUnit +\n\t    (raidSector % raidPtr->Layout.sectorsPerStripeUnit);\n}"
  },
  {
    "function_name": "rf_MapRegionIDParityLogging",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_paritylogging.c",
    "lines": "780-798",
    "snippet": "RF_RegionId_t \nrf_MapRegionIDParityLogging(\n    RF_Raid_t * raidPtr,\n    RF_SectorNum_t address)\n{\n\tRF_RegionId_t regionID;\n\n/*  regionID = address / (raidPtr->regionParityRange * raidPtr->Layout.numDataCol); */\n\tregionID = address / raidPtr->regionParityRange;\n\tif (regionID == rf_numParityRegions) {\n\t\t/* last region may be larger than other regions */\n\t\tregionID--;\n\t}\n\tRF_ASSERT(address >= raidPtr->regionInfo[regionID].parityStartAddr);\n\tRF_ASSERT(address < raidPtr->regionInfo[regionID].parityStartAddr + \n\t\t  raidPtr->regionInfo[regionID].numSectorsParity);\n\tRF_ASSERT(regionID < rf_numParityRegions);\n\treturn (regionID);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_parityloggingdags.h\"",
      "#include \"rf_paritylogging.h\"",
      "#include \"rf_paritylogDiskMgr.h\"",
      "#include \"rf_paritylog.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "regionID < rf_numParityRegions"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "address < raidPtr->regionInfo[regionID].parityStartAddr + \n\t\t  raidPtr->regionInfo[regionID].numSectorsParity"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "address >= raidPtr->regionInfo[regionID].parityStartAddr"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_parityloggingdags.h\"\n#include \"rf_paritylogging.h\"\n#include \"rf_paritylogDiskMgr.h\"\n#include \"rf_paritylog.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nRF_RegionId_t \nrf_MapRegionIDParityLogging(\n    RF_Raid_t * raidPtr,\n    RF_SectorNum_t address)\n{\n\tRF_RegionId_t regionID;\n\n/*  regionID = address / (raidPtr->regionParityRange * raidPtr->Layout.numDataCol); */\n\tregionID = address / raidPtr->regionParityRange;\n\tif (regionID == rf_numParityRegions) {\n\t\t/* last region may be larger than other regions */\n\t\tregionID--;\n\t}\n\tRF_ASSERT(address >= raidPtr->regionInfo[regionID].parityStartAddr);\n\tRF_ASSERT(address < raidPtr->regionInfo[regionID].parityStartAddr + \n\t\t  raidPtr->regionInfo[regionID].numSectorsParity);\n\tRF_ASSERT(regionID < rf_numParityRegions);\n\treturn (regionID);\n}"
  },
  {
    "function_name": "rf_GetDefaultHeadSepLimitParityLogging",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_paritylogging.c",
    "lines": "774-778",
    "snippet": "RF_HeadSepLimit_t \nrf_GetDefaultHeadSepLimitParityLogging(RF_Raid_t * raidPtr)\n{\n\treturn (10);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_parityloggingdags.h\"",
      "#include \"rf_paritylogging.h\"",
      "#include \"rf_paritylogDiskMgr.h\"",
      "#include \"rf_paritylog.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_parityloggingdags.h\"\n#include \"rf_paritylogging.h\"\n#include \"rf_paritylogDiskMgr.h\"\n#include \"rf_paritylog.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nRF_HeadSepLimit_t \nrf_GetDefaultHeadSepLimitParityLogging(RF_Raid_t * raidPtr)\n{\n\treturn (10);\n}"
  },
  {
    "function_name": "rf_GetDefaultNumFloatingReconBuffersParityLogging",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_paritylogging.c",
    "lines": "768-772",
    "snippet": "int \nrf_GetDefaultNumFloatingReconBuffersParityLogging(RF_Raid_t * raidPtr)\n{\n\treturn (20);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_parityloggingdags.h\"",
      "#include \"rf_paritylogging.h\"",
      "#include \"rf_paritylogDiskMgr.h\"",
      "#include \"rf_paritylog.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_parityloggingdags.h\"\n#include \"rf_paritylogging.h\"\n#include \"rf_paritylogDiskMgr.h\"\n#include \"rf_paritylog.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nint \nrf_GetDefaultNumFloatingReconBuffersParityLogging(RF_Raid_t * raidPtr)\n{\n\treturn (20);\n}"
  },
  {
    "function_name": "rf_ShutdownParityLogging",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_paritylogging.c",
    "lines": "735-766",
    "snippet": "static void \nrf_ShutdownParityLogging(RF_ThreadArg_t arg)\n{\n\tRF_Raid_t *raidPtr;\n\n\traidPtr = (RF_Raid_t *) arg;\n\tif (rf_parityLogDebug) {\n\t\tprintf(\"raid%d: ShutdownParityLogging\\n\", raidPtr->raidid);\n\t}\n\t/* shutdown disk thread */\n\t/* This has the desirable side-effect of forcing all regions to be\n\t * reintegrated.  This is necessary since all parity log maps are\n\t * currently held in volatile memory. */\n\n\tRF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);\n\traidPtr->parityLogDiskQueue.threadState |= RF_PLOG_TERMINATE;\n\tRF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);\n\tRF_SIGNAL_COND(raidPtr->parityLogDiskQueue.cond);\n\t/*\n         * pLogDiskThread will now terminate when queues are cleared\n         * now wait for it to be done\n         */\n\tRF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);\n\twhile (!(raidPtr->parityLogDiskQueue.threadState & RF_PLOG_SHUTDOWN)) {\n\t\tRF_WAIT_COND(raidPtr->parityLogDiskQueue.cond, \n\t\t\t     raidPtr->parityLogDiskQueue.mutex);\n\t}\n\tRF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);\n\tif (rf_parityLogDebug) {\n\t\tprintf(\"raid%d: ShutdownParityLogging done (thread completed)\\n\", raidPtr->raidid);\n\t}\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_parityloggingdags.h\"",
      "#include \"rf_paritylogging.h\"",
      "#include \"rf_paritylogDiskMgr.h\"",
      "#include \"rf_paritylog.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"raid%d: ShutdownParityLogging done (thread completed)\\n\"",
            "raidPtr->raidid"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "raidPtr->parityLogDiskQueue.mutex"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_WAIT_COND",
          "args": [
            "raidPtr->parityLogDiskQueue.cond",
            "raidPtr->parityLogDiskQueue.mutex"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "raidPtr->parityLogDiskQueue.mutex"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_SIGNAL_COND",
          "args": [
            "raidPtr->parityLogDiskQueue.cond"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "raidPtr->parityLogDiskQueue.mutex"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "raidPtr->parityLogDiskQueue.mutex"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_parityloggingdags.h\"\n#include \"rf_paritylogging.h\"\n#include \"rf_paritylogDiskMgr.h\"\n#include \"rf_paritylog.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void \nrf_ShutdownParityLogging(RF_ThreadArg_t arg)\n{\n\tRF_Raid_t *raidPtr;\n\n\traidPtr = (RF_Raid_t *) arg;\n\tif (rf_parityLogDebug) {\n\t\tprintf(\"raid%d: ShutdownParityLogging\\n\", raidPtr->raidid);\n\t}\n\t/* shutdown disk thread */\n\t/* This has the desirable side-effect of forcing all regions to be\n\t * reintegrated.  This is necessary since all parity log maps are\n\t * currently held in volatile memory. */\n\n\tRF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);\n\traidPtr->parityLogDiskQueue.threadState |= RF_PLOG_TERMINATE;\n\tRF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);\n\tRF_SIGNAL_COND(raidPtr->parityLogDiskQueue.cond);\n\t/*\n         * pLogDiskThread will now terminate when queues are cleared\n         * now wait for it to be done\n         */\n\tRF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);\n\twhile (!(raidPtr->parityLogDiskQueue.threadState & RF_PLOG_SHUTDOWN)) {\n\t\tRF_WAIT_COND(raidPtr->parityLogDiskQueue.cond, \n\t\t\t     raidPtr->parityLogDiskQueue.mutex);\n\t}\n\tRF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);\n\tif (rf_parityLogDebug) {\n\t\tprintf(\"raid%d: ShutdownParityLogging done (thread completed)\\n\", raidPtr->raidid);\n\t}\n}"
  },
  {
    "function_name": "rf_ShutdownParityLoggingDiskQueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_paritylogging.c",
    "lines": "703-733",
    "snippet": "static void \nrf_ShutdownParityLoggingDiskQueue(RF_ThreadArg_t arg)\n{\n\tRF_ParityLogData_t *d;\n\tRF_CommonLogData_t *c;\n\tRF_Raid_t *raidPtr;\n\n\traidPtr = (RF_Raid_t *) arg;\n\tif (rf_parityLogDebug) {\n\t\tprintf(\"raid%d: ShutdownParityLoggingDiskQueue\\n\",\n\t\t       raidPtr->raidid);\n\t}\n\t/* free disk manager stuff */\n\tRF_ASSERT(raidPtr->parityLogDiskQueue.bufHead == NULL);\n\tRF_ASSERT(raidPtr->parityLogDiskQueue.bufTail == NULL);\n\tRF_ASSERT(raidPtr->parityLogDiskQueue.reintHead == NULL);\n\tRF_ASSERT(raidPtr->parityLogDiskQueue.reintTail == NULL);\n\twhile (raidPtr->parityLogDiskQueue.freeDataList) {\n\t\td = raidPtr->parityLogDiskQueue.freeDataList;\n\t\traidPtr->parityLogDiskQueue.freeDataList = \n\t\t\traidPtr->parityLogDiskQueue.freeDataList->next;\n\t\tRF_Free(d, sizeof(RF_ParityLogData_t));\n\t}\n\twhile (raidPtr->parityLogDiskQueue.freeCommonList) {\n\t\tc = raidPtr->parityLogDiskQueue.freeCommonList;\n\t\trf_mutex_destroy(&c->mutex);\n\t\traidPtr->parityLogDiskQueue.freeCommonList = \n\t\t\traidPtr->parityLogDiskQueue.freeCommonList->next;\n\t\tRF_Free(c, sizeof(RF_CommonLogData_t));\n\t}\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_parityloggingdags.h\"",
      "#include \"rf_paritylogging.h\"",
      "#include \"rf_paritylogDiskMgr.h\"",
      "#include \"rf_paritylog.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "c",
            "sizeof(RF_CommonLogData_t)"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_mutex_destroy",
          "args": [
            "&c->mutex"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "d",
            "sizeof(RF_ParityLogData_t)"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "raidPtr->parityLogDiskQueue.reintTail == NULL"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "raidPtr->parityLogDiskQueue.reintHead == NULL"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "raidPtr->parityLogDiskQueue.bufTail == NULL"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "raidPtr->parityLogDiskQueue.bufHead == NULL"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"raid%d: ShutdownParityLoggingDiskQueue\\n\"",
            "raidPtr->raidid"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_parityloggingdags.h\"\n#include \"rf_paritylogging.h\"\n#include \"rf_paritylogDiskMgr.h\"\n#include \"rf_paritylog.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void \nrf_ShutdownParityLoggingDiskQueue(RF_ThreadArg_t arg)\n{\n\tRF_ParityLogData_t *d;\n\tRF_CommonLogData_t *c;\n\tRF_Raid_t *raidPtr;\n\n\traidPtr = (RF_Raid_t *) arg;\n\tif (rf_parityLogDebug) {\n\t\tprintf(\"raid%d: ShutdownParityLoggingDiskQueue\\n\",\n\t\t       raidPtr->raidid);\n\t}\n\t/* free disk manager stuff */\n\tRF_ASSERT(raidPtr->parityLogDiskQueue.bufHead == NULL);\n\tRF_ASSERT(raidPtr->parityLogDiskQueue.bufTail == NULL);\n\tRF_ASSERT(raidPtr->parityLogDiskQueue.reintHead == NULL);\n\tRF_ASSERT(raidPtr->parityLogDiskQueue.reintTail == NULL);\n\twhile (raidPtr->parityLogDiskQueue.freeDataList) {\n\t\td = raidPtr->parityLogDiskQueue.freeDataList;\n\t\traidPtr->parityLogDiskQueue.freeDataList = \n\t\t\traidPtr->parityLogDiskQueue.freeDataList->next;\n\t\tRF_Free(d, sizeof(RF_ParityLogData_t));\n\t}\n\twhile (raidPtr->parityLogDiskQueue.freeCommonList) {\n\t\tc = raidPtr->parityLogDiskQueue.freeCommonList;\n\t\trf_mutex_destroy(&c->mutex);\n\t\traidPtr->parityLogDiskQueue.freeCommonList = \n\t\t\traidPtr->parityLogDiskQueue.freeCommonList->next;\n\t\tRF_Free(c, sizeof(RF_CommonLogData_t));\n\t}\n}"
  },
  {
    "function_name": "rf_ShutdownParityLoggingParityBufferPool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_paritylogging.c",
    "lines": "690-701",
    "snippet": "static void \nrf_ShutdownParityLoggingParityBufferPool(RF_ThreadArg_t arg)\n{\n\tRF_Raid_t *raidPtr;\n\n\traidPtr = (RF_Raid_t *) arg;\n\tif (rf_parityLogDebug) {\n\t\tprintf(\"raid%d: ShutdownParityLoggingParityBufferPool\\n\",\n\t\t       raidPtr->raidid);\n\t}\n\tFreeRegionBufferQueue(&raidPtr->parityBufferPool);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_parityloggingdags.h\"",
      "#include \"rf_paritylogging.h\"",
      "#include \"rf_paritylogDiskMgr.h\"",
      "#include \"rf_paritylog.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FreeRegionBufferQueue",
          "args": [
            "&raidPtr->parityBufferPool"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "FreeRegionBufferQueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_paritylogging.c",
          "lines": "626-641",
          "snippet": "static void \nFreeRegionBufferQueue(RF_RegionBufferQueue_t * queue)\n{\n\tint     i;\n\n\tRF_LOCK_MUTEX(queue->mutex);\n\tif (queue->availableBuffers != queue->totalBuffers) {\n\t\tprintf(\"Attempt to free region queue which is still in use!\\n\");\n\t\tRF_ASSERT(0);\n\t}\n\tfor (i = 0; i < queue->totalBuffers; i++)\n\t\tRF_Free(queue->buffers[i], queue->bufferSize);\n\tRF_Free(queue->buffers, queue->totalBuffers * sizeof(caddr_t));\n\tRF_UNLOCK_MUTEX(queue->mutex);\n\trf_mutex_destroy(&queue->mutex);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_parityloggingdags.h\"",
            "#include \"rf_paritylogging.h\"",
            "#include \"rf_paritylogDiskMgr.h\"",
            "#include \"rf_paritylog.h\"",
            "#include \"rf_dagdegwr.h\"",
            "#include \"rf_dagdegrd.h\"",
            "#include \"rf_dagffwr.h\"",
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_parityloggingdags.h\"\n#include \"rf_paritylogging.h\"\n#include \"rf_paritylogDiskMgr.h\"\n#include \"rf_paritylog.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void \nFreeRegionBufferQueue(RF_RegionBufferQueue_t * queue)\n{\n\tint     i;\n\n\tRF_LOCK_MUTEX(queue->mutex);\n\tif (queue->availableBuffers != queue->totalBuffers) {\n\t\tprintf(\"Attempt to free region queue which is still in use!\\n\");\n\t\tRF_ASSERT(0);\n\t}\n\tfor (i = 0; i < queue->totalBuffers; i++)\n\t\tRF_Free(queue->buffers[i], queue->bufferSize);\n\tRF_Free(queue->buffers, queue->totalBuffers * sizeof(caddr_t));\n\tRF_UNLOCK_MUTEX(queue->mutex);\n\trf_mutex_destroy(&queue->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"raid%d: ShutdownParityLoggingParityBufferPool\\n\"",
            "raidPtr->raidid"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_parityloggingdags.h\"\n#include \"rf_paritylogging.h\"\n#include \"rf_paritylogDiskMgr.h\"\n#include \"rf_paritylog.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void \nrf_ShutdownParityLoggingParityBufferPool(RF_ThreadArg_t arg)\n{\n\tRF_Raid_t *raidPtr;\n\n\traidPtr = (RF_Raid_t *) arg;\n\tif (rf_parityLogDebug) {\n\t\tprintf(\"raid%d: ShutdownParityLoggingParityBufferPool\\n\",\n\t\t       raidPtr->raidid);\n\t}\n\tFreeRegionBufferQueue(&raidPtr->parityBufferPool);\n}"
  },
  {
    "function_name": "rf_ShutdownParityLoggingRegionBufferPool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_paritylogging.c",
    "lines": "677-688",
    "snippet": "static void \nrf_ShutdownParityLoggingRegionBufferPool(RF_ThreadArg_t arg)\n{\n\tRF_Raid_t *raidPtr;\n\n\traidPtr = (RF_Raid_t *) arg;\n\tif (rf_parityLogDebug) {\n\t\tprintf(\"raid%d: ShutdownParityLoggingRegionBufferPool\\n\", \n\t\t       raidPtr->raidid);\n\t}\n\tFreeRegionBufferQueue(&raidPtr->regionBufferPool);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_parityloggingdags.h\"",
      "#include \"rf_paritylogging.h\"",
      "#include \"rf_paritylogDiskMgr.h\"",
      "#include \"rf_paritylog.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FreeRegionBufferQueue",
          "args": [
            "&raidPtr->regionBufferPool"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "FreeRegionBufferQueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_paritylogging.c",
          "lines": "626-641",
          "snippet": "static void \nFreeRegionBufferQueue(RF_RegionBufferQueue_t * queue)\n{\n\tint     i;\n\n\tRF_LOCK_MUTEX(queue->mutex);\n\tif (queue->availableBuffers != queue->totalBuffers) {\n\t\tprintf(\"Attempt to free region queue which is still in use!\\n\");\n\t\tRF_ASSERT(0);\n\t}\n\tfor (i = 0; i < queue->totalBuffers; i++)\n\t\tRF_Free(queue->buffers[i], queue->bufferSize);\n\tRF_Free(queue->buffers, queue->totalBuffers * sizeof(caddr_t));\n\tRF_UNLOCK_MUTEX(queue->mutex);\n\trf_mutex_destroy(&queue->mutex);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_parityloggingdags.h\"",
            "#include \"rf_paritylogging.h\"",
            "#include \"rf_paritylogDiskMgr.h\"",
            "#include \"rf_paritylog.h\"",
            "#include \"rf_dagdegwr.h\"",
            "#include \"rf_dagdegrd.h\"",
            "#include \"rf_dagffwr.h\"",
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_parityloggingdags.h\"\n#include \"rf_paritylogging.h\"\n#include \"rf_paritylogDiskMgr.h\"\n#include \"rf_paritylog.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void \nFreeRegionBufferQueue(RF_RegionBufferQueue_t * queue)\n{\n\tint     i;\n\n\tRF_LOCK_MUTEX(queue->mutex);\n\tif (queue->availableBuffers != queue->totalBuffers) {\n\t\tprintf(\"Attempt to free region queue which is still in use!\\n\");\n\t\tRF_ASSERT(0);\n\t}\n\tfor (i = 0; i < queue->totalBuffers; i++)\n\t\tRF_Free(queue->buffers[i], queue->bufferSize);\n\tRF_Free(queue->buffers, queue->totalBuffers * sizeof(caddr_t));\n\tRF_UNLOCK_MUTEX(queue->mutex);\n\trf_mutex_destroy(&queue->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"raid%d: ShutdownParityLoggingRegionBufferPool\\n\"",
            "raidPtr->raidid"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_parityloggingdags.h\"\n#include \"rf_paritylogging.h\"\n#include \"rf_paritylogDiskMgr.h\"\n#include \"rf_paritylog.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void \nrf_ShutdownParityLoggingRegionBufferPool(RF_ThreadArg_t arg)\n{\n\tRF_Raid_t *raidPtr;\n\n\traidPtr = (RF_Raid_t *) arg;\n\tif (rf_parityLogDebug) {\n\t\tprintf(\"raid%d: ShutdownParityLoggingRegionBufferPool\\n\", \n\t\t       raidPtr->raidid);\n\t}\n\tFreeRegionBufferQueue(&raidPtr->regionBufferPool);\n}"
  },
  {
    "function_name": "rf_ShutdownParityLoggingPool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_paritylogging.c",
    "lines": "662-675",
    "snippet": "static void \nrf_ShutdownParityLoggingPool(RF_ThreadArg_t arg)\n{\n\tRF_Raid_t *raidPtr;\n\n\traidPtr = (RF_Raid_t *) arg;\n\tif (rf_parityLogDebug) {\n\t\tprintf(\"raid%d: ShutdownParityLoggingPool\\n\", raidPtr->raidid);\n\t}\n\t/* free contents of parityLogPool */\n\tFreeParityLogQueue(raidPtr, &raidPtr->parityLogPool);\n\tRF_Free(raidPtr->parityLogBufferHeap, raidPtr->numParityLogs * \n\t\traidPtr->numSectorsPerLog * raidPtr->bytesPerSector);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_parityloggingdags.h\"",
      "#include \"rf_paritylogging.h\"",
      "#include \"rf_paritylogDiskMgr.h\"",
      "#include \"rf_paritylog.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "raidPtr->parityLogBufferHeap",
            "raidPtr->numParityLogs * \n\t\traidPtr->numSectorsPerLog * raidPtr->bytesPerSector"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreeParityLogQueue",
          "args": [
            "raidPtr",
            "&raidPtr->parityLogPool"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "FreeParityLogQueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_paritylogging.c",
          "lines": "605-623",
          "snippet": "static void \nFreeParityLogQueue(\n    RF_Raid_t * raidPtr,\n    RF_ParityLogQueue_t * queue)\n{\n\tRF_ParityLog_t *l1, *l2;\n\n\tRF_LOCK_MUTEX(queue->mutex);\n\tl1 = queue->parityLogs;\n\twhile (l1) {\n\t\tl2 = l1;\n\t\tl1 = l2->next;\n\t\tRF_Free(l2->records, (raidPtr->numSectorsPerLog * \n\t\t\t\t      sizeof(RF_ParityLogRecord_t)));\n\t\tRF_Free(l2, sizeof(RF_ParityLog_t));\n\t}\n\tRF_UNLOCK_MUTEX(queue->mutex);\n\trf_mutex_destroy(&queue->mutex);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_parityloggingdags.h\"",
            "#include \"rf_paritylogging.h\"",
            "#include \"rf_paritylogDiskMgr.h\"",
            "#include \"rf_paritylog.h\"",
            "#include \"rf_dagdegwr.h\"",
            "#include \"rf_dagdegrd.h\"",
            "#include \"rf_dagffwr.h\"",
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_parityloggingdags.h\"\n#include \"rf_paritylogging.h\"\n#include \"rf_paritylogDiskMgr.h\"\n#include \"rf_paritylog.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void \nFreeParityLogQueue(\n    RF_Raid_t * raidPtr,\n    RF_ParityLogQueue_t * queue)\n{\n\tRF_ParityLog_t *l1, *l2;\n\n\tRF_LOCK_MUTEX(queue->mutex);\n\tl1 = queue->parityLogs;\n\twhile (l1) {\n\t\tl2 = l1;\n\t\tl1 = l2->next;\n\t\tRF_Free(l2->records, (raidPtr->numSectorsPerLog * \n\t\t\t\t      sizeof(RF_ParityLogRecord_t)));\n\t\tRF_Free(l2, sizeof(RF_ParityLog_t));\n\t}\n\tRF_UNLOCK_MUTEX(queue->mutex);\n\trf_mutex_destroy(&queue->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"raid%d: ShutdownParityLoggingPool\\n\"",
            "raidPtr->raidid"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_parityloggingdags.h\"\n#include \"rf_paritylogging.h\"\n#include \"rf_paritylogDiskMgr.h\"\n#include \"rf_paritylog.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void \nrf_ShutdownParityLoggingPool(RF_ThreadArg_t arg)\n{\n\tRF_Raid_t *raidPtr;\n\n\traidPtr = (RF_Raid_t *) arg;\n\tif (rf_parityLogDebug) {\n\t\tprintf(\"raid%d: ShutdownParityLoggingPool\\n\", raidPtr->raidid);\n\t}\n\t/* free contents of parityLogPool */\n\tFreeParityLogQueue(raidPtr, &raidPtr->parityLogPool);\n\tRF_Free(raidPtr->parityLogBufferHeap, raidPtr->numParityLogs * \n\t\traidPtr->numSectorsPerLog * raidPtr->bytesPerSector);\n}"
  },
  {
    "function_name": "rf_ShutdownParityLoggingRegionInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_paritylogging.c",
    "lines": "643-660",
    "snippet": "static void \nrf_ShutdownParityLoggingRegionInfo(RF_ThreadArg_t arg)\n{\n\tRF_Raid_t *raidPtr;\n\tRF_RegionId_t i;\n\n\traidPtr = (RF_Raid_t *) arg;\n\tif (rf_parityLogDebug) {\n\t\tprintf(\"raid%d: ShutdownParityLoggingRegionInfo\\n\", \n\t\t       raidPtr->raidid);\n\t}\n\t/* free region information structs */\n\tfor (i = 0; i < rf_numParityRegions; i++)\n\t\tFreeRegionInfo(raidPtr, i);\n\tRF_Free(raidPtr->regionInfo, (rf_numParityRegions * \n\t\t\t\t      sizeof(raidPtr->regionInfo)));\n\traidPtr->regionInfo = NULL;\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_parityloggingdags.h\"",
      "#include \"rf_paritylogging.h\"",
      "#include \"rf_paritylogDiskMgr.h\"",
      "#include \"rf_paritylog.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "raidPtr->regionInfo",
            "(rf_numParityRegions * \n\t\t\t\t      sizeof(raidPtr->regionInfo))"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreeRegionInfo",
          "args": [
            "raidPtr",
            "i"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "FreeRegionInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_paritylogging.c",
          "lines": "582-602",
          "snippet": "static void \nFreeRegionInfo(\n    RF_Raid_t * raidPtr,\n    RF_RegionId_t regionID)\n{\n\tRF_LOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);\n\tRF_Free(raidPtr->regionInfo[regionID].diskMap, \n\t\t(raidPtr->regionInfo[regionID].capacity * \n\t\t sizeof(RF_DiskMap_t)));\n\tif (!rf_forceParityLogReint && raidPtr->regionInfo[regionID].coreLog) {\n\t\trf_ReleaseParityLogs(raidPtr, \n\t\t\t\t     raidPtr->regionInfo[regionID].coreLog);\n\t\traidPtr->regionInfo[regionID].coreLog = NULL;\n\t} else {\n\t\tRF_ASSERT(raidPtr->regionInfo[regionID].coreLog == NULL);\n\t\tRF_ASSERT(raidPtr->regionInfo[regionID].diskCount == 0);\n\t}\n\tRF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);\n\trf_mutex_destroy(&raidPtr->regionInfo[regionID].mutex);\n\trf_mutex_destroy(&raidPtr->regionInfo[regionID].reintMutex);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_parityloggingdags.h\"",
            "#include \"rf_paritylogging.h\"",
            "#include \"rf_paritylogDiskMgr.h\"",
            "#include \"rf_paritylog.h\"",
            "#include \"rf_dagdegwr.h\"",
            "#include \"rf_dagdegrd.h\"",
            "#include \"rf_dagffwr.h\"",
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_parityloggingdags.h\"\n#include \"rf_paritylogging.h\"\n#include \"rf_paritylogDiskMgr.h\"\n#include \"rf_paritylog.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void \nFreeRegionInfo(\n    RF_Raid_t * raidPtr,\n    RF_RegionId_t regionID)\n{\n\tRF_LOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);\n\tRF_Free(raidPtr->regionInfo[regionID].diskMap, \n\t\t(raidPtr->regionInfo[regionID].capacity * \n\t\t sizeof(RF_DiskMap_t)));\n\tif (!rf_forceParityLogReint && raidPtr->regionInfo[regionID].coreLog) {\n\t\trf_ReleaseParityLogs(raidPtr, \n\t\t\t\t     raidPtr->regionInfo[regionID].coreLog);\n\t\traidPtr->regionInfo[regionID].coreLog = NULL;\n\t} else {\n\t\tRF_ASSERT(raidPtr->regionInfo[regionID].coreLog == NULL);\n\t\tRF_ASSERT(raidPtr->regionInfo[regionID].diskCount == 0);\n\t}\n\tRF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);\n\trf_mutex_destroy(&raidPtr->regionInfo[regionID].mutex);\n\trf_mutex_destroy(&raidPtr->regionInfo[regionID].reintMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"raid%d: ShutdownParityLoggingRegionInfo\\n\"",
            "raidPtr->raidid"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_parityloggingdags.h\"\n#include \"rf_paritylogging.h\"\n#include \"rf_paritylogDiskMgr.h\"\n#include \"rf_paritylog.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void \nrf_ShutdownParityLoggingRegionInfo(RF_ThreadArg_t arg)\n{\n\tRF_Raid_t *raidPtr;\n\tRF_RegionId_t i;\n\n\traidPtr = (RF_Raid_t *) arg;\n\tif (rf_parityLogDebug) {\n\t\tprintf(\"raid%d: ShutdownParityLoggingRegionInfo\\n\", \n\t\t       raidPtr->raidid);\n\t}\n\t/* free region information structs */\n\tfor (i = 0; i < rf_numParityRegions; i++)\n\t\tFreeRegionInfo(raidPtr, i);\n\tRF_Free(raidPtr->regionInfo, (rf_numParityRegions * \n\t\t\t\t      sizeof(raidPtr->regionInfo)));\n\traidPtr->regionInfo = NULL;\n}"
  },
  {
    "function_name": "FreeRegionBufferQueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_paritylogging.c",
    "lines": "626-641",
    "snippet": "static void \nFreeRegionBufferQueue(RF_RegionBufferQueue_t * queue)\n{\n\tint     i;\n\n\tRF_LOCK_MUTEX(queue->mutex);\n\tif (queue->availableBuffers != queue->totalBuffers) {\n\t\tprintf(\"Attempt to free region queue which is still in use!\\n\");\n\t\tRF_ASSERT(0);\n\t}\n\tfor (i = 0; i < queue->totalBuffers; i++)\n\t\tRF_Free(queue->buffers[i], queue->bufferSize);\n\tRF_Free(queue->buffers, queue->totalBuffers * sizeof(caddr_t));\n\tRF_UNLOCK_MUTEX(queue->mutex);\n\trf_mutex_destroy(&queue->mutex);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_parityloggingdags.h\"",
      "#include \"rf_paritylogging.h\"",
      "#include \"rf_paritylogDiskMgr.h\"",
      "#include \"rf_paritylog.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_mutex_destroy",
          "args": [
            "&queue->mutex"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "queue->mutex"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "queue->buffers",
            "queue->totalBuffers * sizeof(caddr_t)"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "queue->buffers[i]",
            "queue->bufferSize"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "0"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Attempt to free region queue which is still in use!\\n\""
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "queue->mutex"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_parityloggingdags.h\"\n#include \"rf_paritylogging.h\"\n#include \"rf_paritylogDiskMgr.h\"\n#include \"rf_paritylog.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void \nFreeRegionBufferQueue(RF_RegionBufferQueue_t * queue)\n{\n\tint     i;\n\n\tRF_LOCK_MUTEX(queue->mutex);\n\tif (queue->availableBuffers != queue->totalBuffers) {\n\t\tprintf(\"Attempt to free region queue which is still in use!\\n\");\n\t\tRF_ASSERT(0);\n\t}\n\tfor (i = 0; i < queue->totalBuffers; i++)\n\t\tRF_Free(queue->buffers[i], queue->bufferSize);\n\tRF_Free(queue->buffers, queue->totalBuffers * sizeof(caddr_t));\n\tRF_UNLOCK_MUTEX(queue->mutex);\n\trf_mutex_destroy(&queue->mutex);\n}"
  },
  {
    "function_name": "FreeParityLogQueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_paritylogging.c",
    "lines": "605-623",
    "snippet": "static void \nFreeParityLogQueue(\n    RF_Raid_t * raidPtr,\n    RF_ParityLogQueue_t * queue)\n{\n\tRF_ParityLog_t *l1, *l2;\n\n\tRF_LOCK_MUTEX(queue->mutex);\n\tl1 = queue->parityLogs;\n\twhile (l1) {\n\t\tl2 = l1;\n\t\tl1 = l2->next;\n\t\tRF_Free(l2->records, (raidPtr->numSectorsPerLog * \n\t\t\t\t      sizeof(RF_ParityLogRecord_t)));\n\t\tRF_Free(l2, sizeof(RF_ParityLog_t));\n\t}\n\tRF_UNLOCK_MUTEX(queue->mutex);\n\trf_mutex_destroy(&queue->mutex);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_parityloggingdags.h\"",
      "#include \"rf_paritylogging.h\"",
      "#include \"rf_paritylogDiskMgr.h\"",
      "#include \"rf_paritylog.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_mutex_destroy",
          "args": [
            "&queue->mutex"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "queue->mutex"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "l2",
            "sizeof(RF_ParityLog_t)"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "l2->records",
            "(raidPtr->numSectorsPerLog * \n\t\t\t\t      sizeof(RF_ParityLogRecord_t))"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "queue->mutex"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_parityloggingdags.h\"\n#include \"rf_paritylogging.h\"\n#include \"rf_paritylogDiskMgr.h\"\n#include \"rf_paritylog.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void \nFreeParityLogQueue(\n    RF_Raid_t * raidPtr,\n    RF_ParityLogQueue_t * queue)\n{\n\tRF_ParityLog_t *l1, *l2;\n\n\tRF_LOCK_MUTEX(queue->mutex);\n\tl1 = queue->parityLogs;\n\twhile (l1) {\n\t\tl2 = l1;\n\t\tl1 = l2->next;\n\t\tRF_Free(l2->records, (raidPtr->numSectorsPerLog * \n\t\t\t\t      sizeof(RF_ParityLogRecord_t)));\n\t\tRF_Free(l2, sizeof(RF_ParityLog_t));\n\t}\n\tRF_UNLOCK_MUTEX(queue->mutex);\n\trf_mutex_destroy(&queue->mutex);\n}"
  },
  {
    "function_name": "FreeRegionInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_paritylogging.c",
    "lines": "582-602",
    "snippet": "static void \nFreeRegionInfo(\n    RF_Raid_t * raidPtr,\n    RF_RegionId_t regionID)\n{\n\tRF_LOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);\n\tRF_Free(raidPtr->regionInfo[regionID].diskMap, \n\t\t(raidPtr->regionInfo[regionID].capacity * \n\t\t sizeof(RF_DiskMap_t)));\n\tif (!rf_forceParityLogReint && raidPtr->regionInfo[regionID].coreLog) {\n\t\trf_ReleaseParityLogs(raidPtr, \n\t\t\t\t     raidPtr->regionInfo[regionID].coreLog);\n\t\traidPtr->regionInfo[regionID].coreLog = NULL;\n\t} else {\n\t\tRF_ASSERT(raidPtr->regionInfo[regionID].coreLog == NULL);\n\t\tRF_ASSERT(raidPtr->regionInfo[regionID].diskCount == 0);\n\t}\n\tRF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);\n\trf_mutex_destroy(&raidPtr->regionInfo[regionID].mutex);\n\trf_mutex_destroy(&raidPtr->regionInfo[regionID].reintMutex);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_parityloggingdags.h\"",
      "#include \"rf_paritylogging.h\"",
      "#include \"rf_paritylogDiskMgr.h\"",
      "#include \"rf_paritylog.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_mutex_destroy",
          "args": [
            "&raidPtr->regionInfo[regionID].reintMutex"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_mutex_destroy",
          "args": [
            "&raidPtr->regionInfo[regionID].mutex"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "raidPtr->regionInfo[regionID].mutex"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "raidPtr->regionInfo[regionID].diskCount == 0"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "raidPtr->regionInfo[regionID].coreLog == NULL"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_ReleaseParityLogs",
          "args": [
            "raidPtr",
            "raidPtr->regionInfo[regionID].coreLog"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ReleaseParityLogs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_paritylog.c",
          "lines": "467-539",
          "snippet": "void \nrf_ReleaseParityLogs(\n    RF_Raid_t * raidPtr,\n    RF_ParityLog_t * firstLog)\n{\n\tRF_ParityLogData_t *logDataList;\n\tRF_ParityLog_t *log, *lastLog;\n\tint     cnt;\n\n\t/* Insert a linked list of parity logs (firstLog) to the free list\n\t * (parityLogPool.parityLogPool)\n\t * \n\t * NON-BLOCKING. */\n\n\tRF_ASSERT(firstLog);\n\n\t/* Before returning logs to global free list, service all requests\n\t * which are blocked on logs.  Holding mutexes for parityLogPool and\n\t * parityLogDiskQueue forces synchronization with AcquireParityLog(). */\n\tRF_LOCK_MUTEX(raidPtr->parityLogPool.mutex);\n\tRF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);\n\tlogDataList = DequeueMatchingLogData(raidPtr, &raidPtr->parityLogDiskQueue.logBlockHead, &raidPtr->parityLogDiskQueue.logBlockTail);\n\tlog = firstLog;\n\tif (firstLog)\n\t\tfirstLog = firstLog->next;\n\tlog->numRecords = 0;\n\tlog->next = NULL;\n\twhile (logDataList && log) {\n\t\tRF_UNLOCK_MUTEX(raidPtr->parityLogPool.mutex);\n\t\tRF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);\n\t\trf_ParityLogAppend(logDataList, RF_TRUE, &log, RF_FALSE);\n\t\tif (rf_parityLogDebug)\n\t\t\tprintf(\"[finishing up buf-blocked log data, region %d]\\n\", logDataList->regionID);\n\t\tif (log == NULL) {\n\t\t\tlog = firstLog;\n\t\t\tif (firstLog) {\n\t\t\t\tfirstLog = firstLog->next;\n\t\t\t\tlog->numRecords = 0;\n\t\t\t\tlog->next = NULL;\n\t\t\t}\n\t\t}\n\t\tRF_LOCK_MUTEX(raidPtr->parityLogPool.mutex);\n\t\tRF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);\n\t\tif (log)\n\t\t\tlogDataList = DequeueMatchingLogData(raidPtr, &raidPtr->parityLogDiskQueue.logBlockHead, &raidPtr->parityLogDiskQueue.logBlockTail);\n\t}\n\t/* return remaining logs to pool */\n\tif (log) {\n\t\tlog->next = firstLog;\n\t\tfirstLog = log;\n\t}\n\tif (firstLog) {\n\t\tlastLog = firstLog;\n\t\traidPtr->logsInUse--;\n\t\tRF_ASSERT(raidPtr->logsInUse >= 0 && raidPtr->logsInUse <= raidPtr->numParityLogs);\n\t\twhile (lastLog->next) {\n\t\t\tlastLog = lastLog->next;\n\t\t\traidPtr->logsInUse--;\n\t\t\tRF_ASSERT(raidPtr->logsInUse >= 0 && raidPtr->logsInUse <= raidPtr->numParityLogs);\n\t\t}\n\t\tlastLog->next = raidPtr->parityLogPool.parityLogs;\n\t\traidPtr->parityLogPool.parityLogs = firstLog;\n\t\tcnt = 0;\n\t\tlog = raidPtr->parityLogPool.parityLogs;\n\t\twhile (log) {\n\t\t\tcnt++;\n\t\t\tlog = log->next;\n\t\t}\n\t\tRF_ASSERT(cnt + raidPtr->logsInUse == raidPtr->numParityLogs);\n\t}\n\tRF_UNLOCK_MUTEX(raidPtr->parityLogPool.mutex);\n\tRF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);\n}",
          "includes": [
            "#include \"rf_paritylogDiskMgr.h\"",
            "#include \"rf_paritylogging.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_paritylog.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_mcpair.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylogDiskMgr.h\"\n#include \"rf_paritylogging.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_paritylog.h\"\n#include \"rf_etimer.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_layout.h\"\n#include \"rf_desc.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nvoid \nrf_ReleaseParityLogs(\n    RF_Raid_t * raidPtr,\n    RF_ParityLog_t * firstLog)\n{\n\tRF_ParityLogData_t *logDataList;\n\tRF_ParityLog_t *log, *lastLog;\n\tint     cnt;\n\n\t/* Insert a linked list of parity logs (firstLog) to the free list\n\t * (parityLogPool.parityLogPool)\n\t * \n\t * NON-BLOCKING. */\n\n\tRF_ASSERT(firstLog);\n\n\t/* Before returning logs to global free list, service all requests\n\t * which are blocked on logs.  Holding mutexes for parityLogPool and\n\t * parityLogDiskQueue forces synchronization with AcquireParityLog(). */\n\tRF_LOCK_MUTEX(raidPtr->parityLogPool.mutex);\n\tRF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);\n\tlogDataList = DequeueMatchingLogData(raidPtr, &raidPtr->parityLogDiskQueue.logBlockHead, &raidPtr->parityLogDiskQueue.logBlockTail);\n\tlog = firstLog;\n\tif (firstLog)\n\t\tfirstLog = firstLog->next;\n\tlog->numRecords = 0;\n\tlog->next = NULL;\n\twhile (logDataList && log) {\n\t\tRF_UNLOCK_MUTEX(raidPtr->parityLogPool.mutex);\n\t\tRF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);\n\t\trf_ParityLogAppend(logDataList, RF_TRUE, &log, RF_FALSE);\n\t\tif (rf_parityLogDebug)\n\t\t\tprintf(\"[finishing up buf-blocked log data, region %d]\\n\", logDataList->regionID);\n\t\tif (log == NULL) {\n\t\t\tlog = firstLog;\n\t\t\tif (firstLog) {\n\t\t\t\tfirstLog = firstLog->next;\n\t\t\t\tlog->numRecords = 0;\n\t\t\t\tlog->next = NULL;\n\t\t\t}\n\t\t}\n\t\tRF_LOCK_MUTEX(raidPtr->parityLogPool.mutex);\n\t\tRF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);\n\t\tif (log)\n\t\t\tlogDataList = DequeueMatchingLogData(raidPtr, &raidPtr->parityLogDiskQueue.logBlockHead, &raidPtr->parityLogDiskQueue.logBlockTail);\n\t}\n\t/* return remaining logs to pool */\n\tif (log) {\n\t\tlog->next = firstLog;\n\t\tfirstLog = log;\n\t}\n\tif (firstLog) {\n\t\tlastLog = firstLog;\n\t\traidPtr->logsInUse--;\n\t\tRF_ASSERT(raidPtr->logsInUse >= 0 && raidPtr->logsInUse <= raidPtr->numParityLogs);\n\t\twhile (lastLog->next) {\n\t\t\tlastLog = lastLog->next;\n\t\t\traidPtr->logsInUse--;\n\t\t\tRF_ASSERT(raidPtr->logsInUse >= 0 && raidPtr->logsInUse <= raidPtr->numParityLogs);\n\t\t}\n\t\tlastLog->next = raidPtr->parityLogPool.parityLogs;\n\t\traidPtr->parityLogPool.parityLogs = firstLog;\n\t\tcnt = 0;\n\t\tlog = raidPtr->parityLogPool.parityLogs;\n\t\twhile (log) {\n\t\t\tcnt++;\n\t\t\tlog = log->next;\n\t\t}\n\t\tRF_ASSERT(cnt + raidPtr->logsInUse == raidPtr->numParityLogs);\n\t}\n\tRF_UNLOCK_MUTEX(raidPtr->parityLogPool.mutex);\n\tRF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "raidPtr->regionInfo[regionID].diskMap",
            "(raidPtr->regionInfo[regionID].capacity * \n\t\t sizeof(RF_DiskMap_t))"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "raidPtr->regionInfo[regionID].mutex"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_parityloggingdags.h\"\n#include \"rf_paritylogging.h\"\n#include \"rf_paritylogDiskMgr.h\"\n#include \"rf_paritylog.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void \nFreeRegionInfo(\n    RF_Raid_t * raidPtr,\n    RF_RegionId_t regionID)\n{\n\tRF_LOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);\n\tRF_Free(raidPtr->regionInfo[regionID].diskMap, \n\t\t(raidPtr->regionInfo[regionID].capacity * \n\t\t sizeof(RF_DiskMap_t)));\n\tif (!rf_forceParityLogReint && raidPtr->regionInfo[regionID].coreLog) {\n\t\trf_ReleaseParityLogs(raidPtr, \n\t\t\t\t     raidPtr->regionInfo[regionID].coreLog);\n\t\traidPtr->regionInfo[regionID].coreLog = NULL;\n\t} else {\n\t\tRF_ASSERT(raidPtr->regionInfo[regionID].coreLog == NULL);\n\t\tRF_ASSERT(raidPtr->regionInfo[regionID].diskCount == 0);\n\t}\n\tRF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);\n\trf_mutex_destroy(&raidPtr->regionInfo[regionID].mutex);\n\trf_mutex_destroy(&raidPtr->regionInfo[regionID].reintMutex);\n}"
  },
  {
    "function_name": "rf_ConfigureParityLogging",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_paritylogging.c",
    "lines": "70-580",
    "snippet": "int \nrf_ConfigureParityLogging(\n    RF_ShutdownList_t ** listp,\n    RF_Raid_t * raidPtr,\n    RF_Config_t * cfgPtr)\n{\n\tint     i, j, startdisk, rc;\n\tRF_SectorCount_t totalLogCapacity, fragmentation, lastRegionCapacity;\n\tRF_SectorCount_t parityBufferCapacity, maxRegionParityRange;\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_ParityLoggingConfigInfo_t *info;\n\tRF_ParityLog_t *l = NULL, *next;\n\tcaddr_t lHeapPtr;\n\n\tif (rf_numParityRegions <= 0)\n\t\treturn(EINVAL);\n\n\t/*\n         * We create multiple entries on the shutdown list here, since\n         * this configuration routine is fairly complicated in and of\n         * itself, and this makes backing out of a failed configuration\n         * much simpler.\n         */\n\n\traidPtr->numSectorsPerLog = RF_DEFAULT_NUM_SECTORS_PER_LOG;\n\n\t/* create a parity logging configuration structure */\n\tRF_MallocAndAdd(info, sizeof(RF_ParityLoggingConfigInfo_t), \n\t\t\t(RF_ParityLoggingConfigInfo_t *), \n\t\t\traidPtr->cleanupList);\n\tif (info == NULL)\n\t\treturn (ENOMEM);\n\tlayoutPtr->layoutSpecificInfo = (void *) info;\n\n\tRF_ASSERT(raidPtr->numRow == 1);\n\n\t/* the stripe identifier must identify the disks in each stripe, IN\n\t * THE ORDER THAT THEY APPEAR IN THE STRIPE. */\n\tinfo->stripeIdentifier = rf_make_2d_array((raidPtr->numCol), \n\t\t\t\t\t\t  (raidPtr->numCol), \n\t\t\t\t\t\t  raidPtr->cleanupList);\n\tif (info->stripeIdentifier == NULL)\n\t\treturn (ENOMEM);\n\n\tstartdisk = 0;\n\tfor (i = 0; i < (raidPtr->numCol); i++) {\n\t\tfor (j = 0; j < (raidPtr->numCol); j++) {\n\t\t\tinfo->stripeIdentifier[i][j] = (startdisk + j) % \n\t\t\t\t(raidPtr->numCol - 1);\n\t\t}\n\t\tif ((--startdisk) < 0)\n\t\t\tstartdisk = raidPtr->numCol - 1 - 1;\n\t}\n\n\t/* fill in the remaining layout parameters */\n\tlayoutPtr->numStripe = layoutPtr->stripeUnitsPerDisk;\n\tlayoutPtr->bytesPerStripeUnit = layoutPtr->sectorsPerStripeUnit << \n\t\traidPtr->logBytesPerSector;\n\tlayoutPtr->numParityCol = 1;\n\tlayoutPtr->numParityLogCol = 1;\n\tlayoutPtr->numDataCol = raidPtr->numCol - layoutPtr->numParityCol - \n\t\tlayoutPtr->numParityLogCol;\n\tlayoutPtr->dataSectorsPerStripe = layoutPtr->numDataCol * \n\t\tlayoutPtr->sectorsPerStripeUnit;\n\tlayoutPtr->dataStripeUnitsPerDisk = layoutPtr->stripeUnitsPerDisk;\n\traidPtr->sectorsPerDisk = layoutPtr->stripeUnitsPerDisk * \n\t\tlayoutPtr->sectorsPerStripeUnit;\n\n\traidPtr->totalSectors = layoutPtr->stripeUnitsPerDisk * \n\t\tlayoutPtr->numDataCol * layoutPtr->sectorsPerStripeUnit;\n\n\t/* configure parity log parameters\n\t * \n\t * parameter               comment/constraints \n\t * ------------------------------------------- \n\t * numParityRegions*       all regions (except possibly last) \n\t *                         of equal size \n\t * totalInCoreLogCapacity* amount of memory in bytes available \n\t *                         for in-core logs (default 1 MB) \n\t * numSectorsPerLog#       capacity of an in-core log in sectors \n\t *                         (1 * disk track)\n\t * numParityLogs           total number of in-core logs,\n\t *                         should be at least numParityRegions \n\t * regionLogCapacity       size of a region log (except possibly \n\t *                         last one) in sectors \n\t * totalLogCapacity        total amount of log space in sectors\n\t * \n\t * where '*' denotes a user settable parameter. \n\t * Note that logs are fixed to be the size of a disk track, \n\t * value #defined in rf_paritylog.h\n\t * \n\t */\n\n\ttotalLogCapacity = layoutPtr->stripeUnitsPerDisk * layoutPtr->sectorsPerStripeUnit * layoutPtr->numParityLogCol;\n\traidPtr->regionLogCapacity = totalLogCapacity / rf_numParityRegions;\n\tif (rf_parityLogDebug)\n\t\tprintf(\"bytes per sector %d\\n\", raidPtr->bytesPerSector);\n\n\t/* reduce fragmentation within a disk region by adjusting the number\n\t * of regions in an attempt to allow an integral number of logs to fit\n\t * into a disk region */\n\tfragmentation = raidPtr->regionLogCapacity % raidPtr->numSectorsPerLog;\n\tif (fragmentation > 0)\n\t\tfor (i = 1; i < (raidPtr->numSectorsPerLog / 2); i++) {\n\t\t\tif (((totalLogCapacity / (rf_numParityRegions + i)) % \n\t\t\t     raidPtr->numSectorsPerLog) < fragmentation) {\n\t\t\t\trf_numParityRegions++;\n\t\t\t\traidPtr->regionLogCapacity = totalLogCapacity /\n\t\t\t\t\trf_numParityRegions;\n\t\t\t\tfragmentation = raidPtr->regionLogCapacity % \n\t\t\t\t\traidPtr->numSectorsPerLog;\n\t\t\t}\n\t\t\tif (((totalLogCapacity / (rf_numParityRegions - i)) % \n\t\t\t     raidPtr->numSectorsPerLog) < fragmentation) {\n\t\t\t\trf_numParityRegions--;\n\t\t\t\traidPtr->regionLogCapacity = totalLogCapacity /\n\t\t\t\t\trf_numParityRegions;\n\t\t\t\tfragmentation = raidPtr->regionLogCapacity % \n\t\t\t\t\traidPtr->numSectorsPerLog;\n\t\t\t}\n\t\t}\n\t/* ensure integral number of regions per log */\n\traidPtr->regionLogCapacity = (raidPtr->regionLogCapacity / \n\t\t\t\t      raidPtr->numSectorsPerLog) * \n\t\traidPtr->numSectorsPerLog;\n\n\traidPtr->numParityLogs = rf_totalInCoreLogCapacity / \n\t\t(raidPtr->bytesPerSector * raidPtr->numSectorsPerLog);\n\t/* to avoid deadlock, must ensure that enough logs exist for each\n\t * region to have one simultaneously */\n\tif (raidPtr->numParityLogs < rf_numParityRegions)\n\t\traidPtr->numParityLogs = rf_numParityRegions;\n\n\t/* create region information structs */\n\tRF_Malloc(raidPtr->regionInfo, \n\t\t  (rf_numParityRegions * sizeof(RF_RegionInfo_t)), \n\t\t  (RF_RegionInfo_t *));\n\tif (raidPtr->regionInfo == NULL)\n\t\treturn (ENOMEM);\n\n\t/* last region may not be full capacity */\n\tlastRegionCapacity = raidPtr->regionLogCapacity;\n\twhile ((rf_numParityRegions - 1) * raidPtr->regionLogCapacity + \n\t       lastRegionCapacity > totalLogCapacity)\n\t\tlastRegionCapacity = lastRegionCapacity - \n\t\t\traidPtr->numSectorsPerLog;\n\n\traidPtr->regionParityRange = raidPtr->sectorsPerDisk / \n\t\trf_numParityRegions;\n\tmaxRegionParityRange = raidPtr->regionParityRange;\n\n/* i can't remember why this line is in the code -wvcii 6/30/95 */\n/*  if (raidPtr->sectorsPerDisk % rf_numParityRegions > 0)\n    regionParityRange++; */\n\n\t/* build pool of unused parity logs */\n\tRF_Malloc(raidPtr->parityLogBufferHeap, raidPtr->numParityLogs * \n\t\t  raidPtr->numSectorsPerLog * raidPtr->bytesPerSector, \n\t\t  (caddr_t));\n\tif (raidPtr->parityLogBufferHeap == NULL)\n\t\treturn (ENOMEM);\n\tlHeapPtr = raidPtr->parityLogBufferHeap;\n\trc = rf_mutex_init(&raidPtr->parityLogPool.mutex);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to init mutex file %s line %d rc=%d\\n\", \n\t\t\t     __FILE__, __LINE__, rc);\n\t\tRF_Free(raidPtr->parityLogBufferHeap, raidPtr->numParityLogs * \n\t\t\traidPtr->numSectorsPerLog * raidPtr->bytesPerSector);\n\t\treturn (ENOMEM);\n\t}\n\tfor (i = 0; i < raidPtr->numParityLogs; i++) {\n\t\tif (i == 0) {\n\t\t\tRF_Calloc(raidPtr->parityLogPool.parityLogs, 1, \n\t\t\t\t  sizeof(RF_ParityLog_t), (RF_ParityLog_t *));\n\t\t\tif (raidPtr->parityLogPool.parityLogs == NULL) {\n\t\t\t\tRF_Free(raidPtr->parityLogBufferHeap, \n\t\t\t\t\traidPtr->numParityLogs * \n\t\t\t\t\traidPtr->numSectorsPerLog * \n\t\t\t\t\traidPtr->bytesPerSector);\n\t\t\t\treturn (ENOMEM);\n\t\t\t}\n\t\t\tl = raidPtr->parityLogPool.parityLogs;\n\t\t} else {\n\t\t\tRF_Calloc(l->next, 1, sizeof(RF_ParityLog_t), \n\t\t\t\t  (RF_ParityLog_t *));\n\t\t\tif (l->next == NULL) {\n\t\t\t\tRF_Free(raidPtr->parityLogBufferHeap, \n\t\t\t\t\traidPtr->numParityLogs * \n\t\t\t\t\traidPtr->numSectorsPerLog * \n\t\t\t\t\traidPtr->bytesPerSector);\n\t\t\t\tfor (l = raidPtr->parityLogPool.parityLogs; \n\t\t\t\t     l;\n\t\t\t\t     l = next) {\n\t\t\t\t\tnext = l->next;\n\t\t\t\t\tif (l->records)\n\t\t\t\t\t\tRF_Free(l->records, (raidPtr->numSectorsPerLog * sizeof(RF_ParityLogRecord_t)));\n\t\t\t\t\tRF_Free(l, sizeof(RF_ParityLog_t));\n\t\t\t\t}\n\t\t\t\treturn (ENOMEM);\n\t\t\t}\n\t\t\tl = l->next;\n\t\t}\n\t\tl->bufPtr = lHeapPtr;\n\t\tlHeapPtr += raidPtr->numSectorsPerLog * \n\t\t\traidPtr->bytesPerSector;\n\t\tRF_Malloc(l->records, (raidPtr->numSectorsPerLog * \n\t\t\t\t       sizeof(RF_ParityLogRecord_t)), \n\t\t\t  (RF_ParityLogRecord_t *));\n\t\tif (l->records == NULL) {\n\t\t\tRF_Free(raidPtr->parityLogBufferHeap, \n\t\t\t\traidPtr->numParityLogs * \n\t\t\t\traidPtr->numSectorsPerLog * \n\t\t\t\traidPtr->bytesPerSector);\n\t\t\tfor (l = raidPtr->parityLogPool.parityLogs; \n\t\t\t     l; \n\t\t\t     l = next) {\n\t\t\t\tnext = l->next;\n\t\t\t\tif (l->records)\n\t\t\t\t\tRF_Free(l->records, \n\t\t\t\t\t\t(raidPtr->numSectorsPerLog * \n\t\t\t\t\t\t sizeof(RF_ParityLogRecord_t)));\n\t\t\t\tRF_Free(l, sizeof(RF_ParityLog_t));\n\t\t\t}\n\t\t\treturn (ENOMEM);\n\t\t}\n\t}\n\trc = rf_ShutdownCreate(listp, rf_ShutdownParityLoggingPool, raidPtr);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to create shutdown entry file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\trf_ShutdownParityLoggingPool(raidPtr);\n\t\treturn (rc);\n\t}\n\t/* build pool of region buffers */\n\trc = rf_mutex_init(&raidPtr->regionBufferPool.mutex);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to init mutex file %s line %d rc=%d\\n\", \n\t\t\t     __FILE__, __LINE__, rc);\n\t\treturn (ENOMEM);\n\t}\n\trc = rf_cond_init(&raidPtr->regionBufferPool.cond);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to init cond file %s line %d rc=%d\\n\", \n\t\t\t     __FILE__, __LINE__, rc);\n\t\trf_mutex_destroy(&raidPtr->regionBufferPool.mutex);\n\t\treturn (ENOMEM);\n\t}\n\traidPtr->regionBufferPool.bufferSize = raidPtr->regionLogCapacity * \n\t\traidPtr->bytesPerSector;\n\tprintf(\"regionBufferPool.bufferSize %d\\n\", \n\t       raidPtr->regionBufferPool.bufferSize);\n\n\t/* for now, only one region at a time may be reintegrated */\n\traidPtr->regionBufferPool.totalBuffers = 1;\t\n\n\traidPtr->regionBufferPool.availableBuffers = \n\t\traidPtr->regionBufferPool.totalBuffers;\n\traidPtr->regionBufferPool.availBuffersIndex = 0;\n\traidPtr->regionBufferPool.emptyBuffersIndex = 0;\n\tRF_Malloc(raidPtr->regionBufferPool.buffers, \n\t\t  raidPtr->regionBufferPool.totalBuffers * sizeof(caddr_t), \n\t\t  (caddr_t *));\n\tif (raidPtr->regionBufferPool.buffers == NULL) {\n\t\trf_mutex_destroy(&raidPtr->regionBufferPool.mutex);\n\t\trf_cond_destroy(&raidPtr->regionBufferPool.cond);\n\t\treturn (ENOMEM);\n\t}\n\tfor (i = 0; i < raidPtr->regionBufferPool.totalBuffers; i++) {\n\t\tRF_Malloc(raidPtr->regionBufferPool.buffers[i], \n\t\t\t  raidPtr->regionBufferPool.bufferSize * sizeof(char),\n\t\t\t  (caddr_t));\n\t\tif (raidPtr->regionBufferPool.buffers[i] == NULL) {\n\t\t\trf_mutex_destroy(&raidPtr->regionBufferPool.mutex);\n\t\t\trf_cond_destroy(&raidPtr->regionBufferPool.cond);\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\tRF_Free(raidPtr->regionBufferPool.buffers[i], \n\t\t\t\t\traidPtr->regionBufferPool.bufferSize *\n\t\t\t\t\tsizeof(char));\n\t\t\t}\n\t\t\tRF_Free(raidPtr->regionBufferPool.buffers, \n\t\t\t\traidPtr->regionBufferPool.totalBuffers * \n\t\t\t\tsizeof(caddr_t));\n\t\t\treturn (ENOMEM);\n\t\t}\n\t\tprintf(\"raidPtr->regionBufferPool.buffers[%d] = %lx\\n\", i,\n\t\t    (long) raidPtr->regionBufferPool.buffers[i]);\n\t}\n\trc = rf_ShutdownCreate(listp, \n\t\t\t       rf_ShutdownParityLoggingRegionBufferPool,\n\t\t\t       raidPtr);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to create shutdown entry file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\trf_ShutdownParityLoggingRegionBufferPool(raidPtr);\n\t\treturn (rc);\n\t}\n\t/* build pool of parity buffers */\n\tparityBufferCapacity = maxRegionParityRange;\n\trc = rf_mutex_init(&raidPtr->parityBufferPool.mutex);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to init mutex file %s line %d rc=%d\\n\", \n\t\t\t     __FILE__, __LINE__, rc);\n\t\treturn (rc);\n\t}\n\trc = rf_cond_init(&raidPtr->parityBufferPool.cond);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to init cond file %s line %d rc=%d\\n\", \n\t\t\t     __FILE__, __LINE__, rc);\n\t\trf_mutex_destroy(&raidPtr->parityBufferPool.mutex);\n\t\treturn (ENOMEM);\n\t}\n\traidPtr->parityBufferPool.bufferSize = parityBufferCapacity * \n\t\traidPtr->bytesPerSector;\n\tprintf(\"parityBufferPool.bufferSize %d\\n\", \n\t       raidPtr->parityBufferPool.bufferSize);\n\n\t/* for now, only one region at a time may be reintegrated */\n\traidPtr->parityBufferPool.totalBuffers = 1;\t\n\n\traidPtr->parityBufferPool.availableBuffers = \n\t\traidPtr->parityBufferPool.totalBuffers;\n\traidPtr->parityBufferPool.availBuffersIndex = 0;\n\traidPtr->parityBufferPool.emptyBuffersIndex = 0;\n\tRF_Malloc(raidPtr->parityBufferPool.buffers, \n\t\t  raidPtr->parityBufferPool.totalBuffers * sizeof(caddr_t), \n\t\t  (caddr_t *));\n\tif (raidPtr->parityBufferPool.buffers == NULL) {\n\t\trf_mutex_destroy(&raidPtr->parityBufferPool.mutex);\n\t\trf_cond_destroy(&raidPtr->parityBufferPool.cond);\n\t\treturn (ENOMEM);\n\t}\n\tfor (i = 0; i < raidPtr->parityBufferPool.totalBuffers; i++) {\n\t\tRF_Malloc(raidPtr->parityBufferPool.buffers[i], \n\t\t\t  raidPtr->parityBufferPool.bufferSize * sizeof(char),\n\t\t\t  (caddr_t));\n\t\tif (raidPtr->parityBufferPool.buffers == NULL) {\n\t\t\trf_mutex_destroy(&raidPtr->parityBufferPool.mutex);\n\t\t\trf_cond_destroy(&raidPtr->parityBufferPool.cond);\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\tRF_Free(raidPtr->parityBufferPool.buffers[i], \n\t\t\t\t\traidPtr->regionBufferPool.bufferSize * \n\t\t\t\t\tsizeof(char));\n\t\t\t}\n\t\t\tRF_Free(raidPtr->parityBufferPool.buffers, \n\t\t\t\traidPtr->regionBufferPool.totalBuffers * \n\t\t\t\tsizeof(caddr_t));\n\t\t\treturn (ENOMEM);\n\t\t}\n\t\tprintf(\"parityBufferPool.buffers[%d] = %lx\\n\", i,\n\t\t    (long) raidPtr->parityBufferPool.buffers[i]);\n\t}\n\trc = rf_ShutdownCreate(listp, \n\t\t\t       rf_ShutdownParityLoggingParityBufferPool, \n\t\t\t       raidPtr);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to create shutdown entry file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\trf_ShutdownParityLoggingParityBufferPool(raidPtr);\n\t\treturn (rc);\n\t}\n\t/* initialize parityLogDiskQueue */\n\trc = rf_create_managed_mutex(listp, \n\t\t\t\t     &raidPtr->parityLogDiskQueue.mutex);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to init mutex file %s line %d rc=%d\\n\", \n\t\t\t     __FILE__, __LINE__, rc);\n\t\treturn (rc);\n\t}\n\trc = rf_create_managed_cond(listp, &raidPtr->parityLogDiskQueue.cond);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to init cond file %s line %d rc=%d\\n\", \n\t\t\t     __FILE__, __LINE__, rc);\n\t\treturn (rc);\n\t}\n\traidPtr->parityLogDiskQueue.flushQueue = NULL;\n\traidPtr->parityLogDiskQueue.reintQueue = NULL;\n\traidPtr->parityLogDiskQueue.bufHead = NULL;\n\traidPtr->parityLogDiskQueue.bufTail = NULL;\n\traidPtr->parityLogDiskQueue.reintHead = NULL;\n\traidPtr->parityLogDiskQueue.reintTail = NULL;\n\traidPtr->parityLogDiskQueue.logBlockHead = NULL;\n\traidPtr->parityLogDiskQueue.logBlockTail = NULL;\n\traidPtr->parityLogDiskQueue.reintBlockHead = NULL;\n\traidPtr->parityLogDiskQueue.reintBlockTail = NULL;\n\traidPtr->parityLogDiskQueue.freeDataList = NULL;\n\traidPtr->parityLogDiskQueue.freeCommonList = NULL;\n\n\trc = rf_ShutdownCreate(listp, \n\t\t\t       rf_ShutdownParityLoggingDiskQueue, \n\t\t\t       raidPtr);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to create shutdown entry file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\treturn (rc);\n\t}\n\tfor (i = 0; i < rf_numParityRegions; i++) {\n\t\trc = rf_mutex_init(&raidPtr->regionInfo[i].mutex);\n\t\tif (rc) {\n\t\t\tRF_ERRORMSG3(\"Unable to init mutex file %s line %d rc=%d\\n\", __FILE__,\n\t\t\t    __LINE__, rc);\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tFreeRegionInfo(raidPtr, j);\n\t\t\tRF_Free(raidPtr->regionInfo, \n\t\t\t\t(rf_numParityRegions * \n\t\t\t\t sizeof(RF_RegionInfo_t)));\n\t\t\treturn (ENOMEM);\n\t\t}\n\t\trc = rf_mutex_init(&raidPtr->regionInfo[i].reintMutex);\n\t\tif (rc) {\n\t\t\tRF_ERRORMSG3(\"Unable to init mutex file %s line %d rc=%d\\n\", __FILE__,\n\t\t\t    __LINE__, rc);\n\t\t\trf_mutex_destroy(&raidPtr->regionInfo[i].mutex);\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tFreeRegionInfo(raidPtr, j);\n\t\t\tRF_Free(raidPtr->regionInfo, \n\t\t\t\t(rf_numParityRegions * \n\t\t\t\t sizeof(RF_RegionInfo_t)));\n\t\t\treturn (ENOMEM);\n\t\t}\n\t\traidPtr->regionInfo[i].reintInProgress = RF_FALSE;\n\t\traidPtr->regionInfo[i].regionStartAddr = \n\t\t\traidPtr->regionLogCapacity * i;\n\t\traidPtr->regionInfo[i].parityStartAddr = \n\t\t\traidPtr->regionParityRange * i;\n\t\tif (i < rf_numParityRegions - 1) {\n\t\t\traidPtr->regionInfo[i].capacity = \n\t\t\t\traidPtr->regionLogCapacity;\n\t\t\traidPtr->regionInfo[i].numSectorsParity = \n\t\t\t\traidPtr->regionParityRange;\n\t\t} else {\n\t\t\traidPtr->regionInfo[i].capacity = \n\t\t\t\tlastRegionCapacity;\n\t\t\traidPtr->regionInfo[i].numSectorsParity = \n\t\t\t\traidPtr->sectorsPerDisk - \n\t\t\t\traidPtr->regionParityRange * i;\n\t\t\tif (raidPtr->regionInfo[i].numSectorsParity > \n\t\t\t    maxRegionParityRange)\n\t\t\t\tmaxRegionParityRange = \n\t\t\t\t\traidPtr->regionInfo[i].numSectorsParity;\n\t\t}\n\t\traidPtr->regionInfo[i].diskCount = 0;\n\t\tRF_ASSERT(raidPtr->regionInfo[i].capacity + \n\t\t\t  raidPtr->regionInfo[i].regionStartAddr <= \n\t\t\t  totalLogCapacity);\n\t\tRF_ASSERT(raidPtr->regionInfo[i].parityStartAddr + \n\t\t\t  raidPtr->regionInfo[i].numSectorsParity <= \n\t\t\t  raidPtr->sectorsPerDisk);\n\t\tRF_Malloc(raidPtr->regionInfo[i].diskMap, \n\t\t\t  (raidPtr->regionInfo[i].capacity *\n\t\t\t   sizeof(RF_DiskMap_t)), \n\t\t\t  (RF_DiskMap_t *));\n\t\tif (raidPtr->regionInfo[i].diskMap == NULL) {\n\t\t\trf_mutex_destroy(&raidPtr->regionInfo[i].mutex);\n\t\t\trf_mutex_destroy(&raidPtr->regionInfo[i].reintMutex);\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tFreeRegionInfo(raidPtr, j);\n\t\t\tRF_Free(raidPtr->regionInfo, \n\t\t\t\t(rf_numParityRegions * \n\t\t\t\t sizeof(RF_RegionInfo_t)));\n\t\t\treturn (ENOMEM);\n\t\t}\n\t\traidPtr->regionInfo[i].loggingEnabled = RF_FALSE;\n\t\traidPtr->regionInfo[i].coreLog = NULL;\n\t}\n\trc = rf_ShutdownCreate(listp,\n\t\t\t       rf_ShutdownParityLoggingRegionInfo, \n\t\t\t       raidPtr);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to create shutdown entry file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\trf_ShutdownParityLoggingRegionInfo(raidPtr);\n\t\treturn (rc);\n\t}\n\tRF_ASSERT(raidPtr->parityLogDiskQueue.threadState == 0);\n\traidPtr->parityLogDiskQueue.threadState = RF_PLOG_CREATED;\n\trc = RF_CREATE_THREAD(raidPtr->pLogDiskThreadHandle, \n\t\t\t      rf_ParityLoggingDiskManager, raidPtr,\"rf_log\");\n\tif (rc) {\n\t\traidPtr->parityLogDiskQueue.threadState = 0;\n\t\tRF_ERRORMSG3(\"Unable to create parity logging disk thread file %s line %d rc=%d\\n\",\n\t\t    __FILE__, __LINE__, rc);\n\t\treturn (ENOMEM);\n\t}\n\t/* wait for thread to start */\n\tRF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);\n\twhile (!(raidPtr->parityLogDiskQueue.threadState & RF_PLOG_RUNNING)) {\n\t\tRF_WAIT_COND(raidPtr->parityLogDiskQueue.cond, \n\t\t\t     raidPtr->parityLogDiskQueue.mutex);\n\t}\n\tRF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);\n\n\trc = rf_ShutdownCreate(listp, rf_ShutdownParityLogging, raidPtr);\n\tif (rc) {\n\t\tRF_ERRORMSG1(\"Got rc=%d adding parity logging shutdown event\\n\", rc);\n\t\trf_ShutdownParityLogging(raidPtr);\n\t\treturn (rc);\n\t}\n\tif (rf_parityLogDebug) {\n\t\tprintf(\"                            size of disk log in sectors: %d\\n\",\n\t\t    (int) totalLogCapacity);\n\t\tprintf(\"                            total number of parity regions is %d\\n\", (int) rf_numParityRegions);\n\t\tprintf(\"                            nominal sectors of log per parity region is %d\\n\", (int) raidPtr->regionLogCapacity);\n\t\tprintf(\"                            nominal region fragmentation is %d sectors\\n\", (int) fragmentation);\n\t\tprintf(\"                            total number of parity logs is %d\\n\", raidPtr->numParityLogs);\n\t\tprintf(\"                            parity log size is %d sectors\\n\", raidPtr->numSectorsPerLog);\n\t\tprintf(\"                            total in-core log space is %d bytes\\n\", (int) rf_totalInCoreLogCapacity);\n\t}\n\trf_EnableParityLogging(raidPtr);\n\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_parityloggingdags.h\"",
      "#include \"rf_paritylogging.h\"",
      "#include \"rf_paritylogDiskMgr.h\"",
      "#include \"rf_paritylog.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_EnableParityLogging",
          "args": [
            "raidPtr"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "rf_EnableParityLogging",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_paritylog.c",
          "lines": "856-868",
          "snippet": "void \nrf_EnableParityLogging(RF_Raid_t * raidPtr)\n{\n\tint     regionID;\n\n\tfor (regionID = 0; regionID < rf_numParityRegions; regionID++) {\n\t\tRF_LOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);\n\t\traidPtr->regionInfo[regionID].loggingEnabled = RF_TRUE;\n\t\tRF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);\n\t}\n\tif (rf_parityLogDebug)\n\t\tprintf(\"[parity logging enabled]\\n\");\n}",
          "includes": [
            "#include \"rf_paritylogDiskMgr.h\"",
            "#include \"rf_paritylogging.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_paritylog.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_desc.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_mcpair.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylogDiskMgr.h\"\n#include \"rf_paritylogging.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_paritylog.h\"\n#include \"rf_etimer.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_layout.h\"\n#include \"rf_desc.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nvoid \nrf_EnableParityLogging(RF_Raid_t * raidPtr)\n{\n\tint     regionID;\n\n\tfor (regionID = 0; regionID < rf_numParityRegions; regionID++) {\n\t\tRF_LOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);\n\t\traidPtr->regionInfo[regionID].loggingEnabled = RF_TRUE;\n\t\tRF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);\n\t}\n\tif (rf_parityLogDebug)\n\t\tprintf(\"[parity logging enabled]\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"                            total in-core log space is %d bytes\\n\"",
            "(int) rf_totalInCoreLogCapacity"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_ShutdownParityLogging",
          "args": [
            "raidPtr"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ShutdownParityLogging",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_paritylogging.c",
          "lines": "735-766",
          "snippet": "static void \nrf_ShutdownParityLogging(RF_ThreadArg_t arg)\n{\n\tRF_Raid_t *raidPtr;\n\n\traidPtr = (RF_Raid_t *) arg;\n\tif (rf_parityLogDebug) {\n\t\tprintf(\"raid%d: ShutdownParityLogging\\n\", raidPtr->raidid);\n\t}\n\t/* shutdown disk thread */\n\t/* This has the desirable side-effect of forcing all regions to be\n\t * reintegrated.  This is necessary since all parity log maps are\n\t * currently held in volatile memory. */\n\n\tRF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);\n\traidPtr->parityLogDiskQueue.threadState |= RF_PLOG_TERMINATE;\n\tRF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);\n\tRF_SIGNAL_COND(raidPtr->parityLogDiskQueue.cond);\n\t/*\n         * pLogDiskThread will now terminate when queues are cleared\n         * now wait for it to be done\n         */\n\tRF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);\n\twhile (!(raidPtr->parityLogDiskQueue.threadState & RF_PLOG_SHUTDOWN)) {\n\t\tRF_WAIT_COND(raidPtr->parityLogDiskQueue.cond, \n\t\t\t     raidPtr->parityLogDiskQueue.mutex);\n\t}\n\tRF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);\n\tif (rf_parityLogDebug) {\n\t\tprintf(\"raid%d: ShutdownParityLogging done (thread completed)\\n\", raidPtr->raidid);\n\t}\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_parityloggingdags.h\"",
            "#include \"rf_paritylogging.h\"",
            "#include \"rf_paritylogDiskMgr.h\"",
            "#include \"rf_paritylog.h\"",
            "#include \"rf_dagdegwr.h\"",
            "#include \"rf_dagdegrd.h\"",
            "#include \"rf_dagffwr.h\"",
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_parityloggingdags.h\"\n#include \"rf_paritylogging.h\"\n#include \"rf_paritylogDiskMgr.h\"\n#include \"rf_paritylog.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void \nrf_ShutdownParityLogging(RF_ThreadArg_t arg)\n{\n\tRF_Raid_t *raidPtr;\n\n\traidPtr = (RF_Raid_t *) arg;\n\tif (rf_parityLogDebug) {\n\t\tprintf(\"raid%d: ShutdownParityLogging\\n\", raidPtr->raidid);\n\t}\n\t/* shutdown disk thread */\n\t/* This has the desirable side-effect of forcing all regions to be\n\t * reintegrated.  This is necessary since all parity log maps are\n\t * currently held in volatile memory. */\n\n\tRF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);\n\traidPtr->parityLogDiskQueue.threadState |= RF_PLOG_TERMINATE;\n\tRF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);\n\tRF_SIGNAL_COND(raidPtr->parityLogDiskQueue.cond);\n\t/*\n         * pLogDiskThread will now terminate when queues are cleared\n         * now wait for it to be done\n         */\n\tRF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);\n\twhile (!(raidPtr->parityLogDiskQueue.threadState & RF_PLOG_SHUTDOWN)) {\n\t\tRF_WAIT_COND(raidPtr->parityLogDiskQueue.cond, \n\t\t\t     raidPtr->parityLogDiskQueue.mutex);\n\t}\n\tRF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);\n\tif (rf_parityLogDebug) {\n\t\tprintf(\"raid%d: ShutdownParityLogging done (thread completed)\\n\", raidPtr->raidid);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG1",
          "args": [
            "\"Got rc=%d adding parity logging shutdown event\\n\"",
            "rc"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_ShutdownCreate",
          "args": [
            "listp",
            "rf_ShutdownParityLogging",
            "raidPtr"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "raidPtr->parityLogDiskQueue.mutex"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_WAIT_COND",
          "args": [
            "raidPtr->parityLogDiskQueue.cond",
            "raidPtr->parityLogDiskQueue.mutex"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "raidPtr->parityLogDiskQueue.mutex"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"Unable to create parity logging disk thread file %s line %d rc=%d\\n\"",
            "__FILE__",
            "__LINE__",
            "rc"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_CREATE_THREAD",
          "args": [
            "raidPtr->pLogDiskThreadHandle",
            "rf_ParityLoggingDiskManager",
            "raidPtr",
            "\"rf_log\""
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "raidPtr->parityLogDiskQueue.threadState == 0"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_ShutdownParityLoggingRegionInfo",
          "args": [
            "raidPtr"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ShutdownParityLoggingRegionInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_paritylogging.c",
          "lines": "643-660",
          "snippet": "static void \nrf_ShutdownParityLoggingRegionInfo(RF_ThreadArg_t arg)\n{\n\tRF_Raid_t *raidPtr;\n\tRF_RegionId_t i;\n\n\traidPtr = (RF_Raid_t *) arg;\n\tif (rf_parityLogDebug) {\n\t\tprintf(\"raid%d: ShutdownParityLoggingRegionInfo\\n\", \n\t\t       raidPtr->raidid);\n\t}\n\t/* free region information structs */\n\tfor (i = 0; i < rf_numParityRegions; i++)\n\t\tFreeRegionInfo(raidPtr, i);\n\tRF_Free(raidPtr->regionInfo, (rf_numParityRegions * \n\t\t\t\t      sizeof(raidPtr->regionInfo)));\n\traidPtr->regionInfo = NULL;\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_parityloggingdags.h\"",
            "#include \"rf_paritylogging.h\"",
            "#include \"rf_paritylogDiskMgr.h\"",
            "#include \"rf_paritylog.h\"",
            "#include \"rf_dagdegwr.h\"",
            "#include \"rf_dagdegrd.h\"",
            "#include \"rf_dagffwr.h\"",
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_parityloggingdags.h\"\n#include \"rf_paritylogging.h\"\n#include \"rf_paritylogDiskMgr.h\"\n#include \"rf_paritylog.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void \nrf_ShutdownParityLoggingRegionInfo(RF_ThreadArg_t arg)\n{\n\tRF_Raid_t *raidPtr;\n\tRF_RegionId_t i;\n\n\traidPtr = (RF_Raid_t *) arg;\n\tif (rf_parityLogDebug) {\n\t\tprintf(\"raid%d: ShutdownParityLoggingRegionInfo\\n\", \n\t\t       raidPtr->raidid);\n\t}\n\t/* free region information structs */\n\tfor (i = 0; i < rf_numParityRegions; i++)\n\t\tFreeRegionInfo(raidPtr, i);\n\tRF_Free(raidPtr->regionInfo, (rf_numParityRegions * \n\t\t\t\t      sizeof(raidPtr->regionInfo)));\n\traidPtr->regionInfo = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"Unable to create shutdown entry file %s line %d rc=%d\\n\"",
            "__FILE__",
            "__LINE__",
            "rc"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_ShutdownCreate",
          "args": [
            "listp",
            "rf_ShutdownParityLoggingRegionInfo",
            "raidPtr"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "raidPtr->regionInfo",
            "(rf_numParityRegions * \n\t\t\t\t sizeof(RF_RegionInfo_t))"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreeRegionInfo",
          "args": [
            "raidPtr",
            "j"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "FreeRegionInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_paritylogging.c",
          "lines": "582-602",
          "snippet": "static void \nFreeRegionInfo(\n    RF_Raid_t * raidPtr,\n    RF_RegionId_t regionID)\n{\n\tRF_LOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);\n\tRF_Free(raidPtr->regionInfo[regionID].diskMap, \n\t\t(raidPtr->regionInfo[regionID].capacity * \n\t\t sizeof(RF_DiskMap_t)));\n\tif (!rf_forceParityLogReint && raidPtr->regionInfo[regionID].coreLog) {\n\t\trf_ReleaseParityLogs(raidPtr, \n\t\t\t\t     raidPtr->regionInfo[regionID].coreLog);\n\t\traidPtr->regionInfo[regionID].coreLog = NULL;\n\t} else {\n\t\tRF_ASSERT(raidPtr->regionInfo[regionID].coreLog == NULL);\n\t\tRF_ASSERT(raidPtr->regionInfo[regionID].diskCount == 0);\n\t}\n\tRF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);\n\trf_mutex_destroy(&raidPtr->regionInfo[regionID].mutex);\n\trf_mutex_destroy(&raidPtr->regionInfo[regionID].reintMutex);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_parityloggingdags.h\"",
            "#include \"rf_paritylogging.h\"",
            "#include \"rf_paritylogDiskMgr.h\"",
            "#include \"rf_paritylog.h\"",
            "#include \"rf_dagdegwr.h\"",
            "#include \"rf_dagdegrd.h\"",
            "#include \"rf_dagffwr.h\"",
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_parityloggingdags.h\"\n#include \"rf_paritylogging.h\"\n#include \"rf_paritylogDiskMgr.h\"\n#include \"rf_paritylog.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void \nFreeRegionInfo(\n    RF_Raid_t * raidPtr,\n    RF_RegionId_t regionID)\n{\n\tRF_LOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);\n\tRF_Free(raidPtr->regionInfo[regionID].diskMap, \n\t\t(raidPtr->regionInfo[regionID].capacity * \n\t\t sizeof(RF_DiskMap_t)));\n\tif (!rf_forceParityLogReint && raidPtr->regionInfo[regionID].coreLog) {\n\t\trf_ReleaseParityLogs(raidPtr, \n\t\t\t\t     raidPtr->regionInfo[regionID].coreLog);\n\t\traidPtr->regionInfo[regionID].coreLog = NULL;\n\t} else {\n\t\tRF_ASSERT(raidPtr->regionInfo[regionID].coreLog == NULL);\n\t\tRF_ASSERT(raidPtr->regionInfo[regionID].diskCount == 0);\n\t}\n\tRF_UNLOCK_MUTEX(raidPtr->regionInfo[regionID].mutex);\n\trf_mutex_destroy(&raidPtr->regionInfo[regionID].mutex);\n\trf_mutex_destroy(&raidPtr->regionInfo[regionID].reintMutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_mutex_destroy",
          "args": [
            "&raidPtr->regionInfo[i].reintMutex"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_mutex_destroy",
          "args": [
            "&raidPtr->regionInfo[i].mutex"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "raidPtr->regionInfo[i].diskMap",
            "(raidPtr->regionInfo[i].capacity *\n\t\t\t   sizeof(RF_DiskMap_t))",
            "(RF_DiskMap_t *)"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "raidPtr->regionInfo[i].parityStartAddr + \n\t\t\t  raidPtr->regionInfo[i].numSectorsParity <= \n\t\t\t  raidPtr->sectorsPerDisk"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "raidPtr->regionInfo[i].capacity + \n\t\t\t  raidPtr->regionInfo[i].regionStartAddr <= \n\t\t\t  totalLogCapacity"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "raidPtr->regionInfo",
            "(rf_numParityRegions * \n\t\t\t\t sizeof(RF_RegionInfo_t))"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_mutex_destroy",
          "args": [
            "&raidPtr->regionInfo[i].mutex"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"Unable to init mutex file %s line %d rc=%d\\n\"",
            "__FILE__",
            "__LINE__",
            "rc"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_mutex_init",
          "args": [
            "&raidPtr->regionInfo[i].reintMutex"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "rf_mutex_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_threadstuff.c",
          "lines": "173-186",
          "snippet": "int \nrf_mutex_init(m)\ndecl_simple_lock_data(, *m)\n{\n\tsimple_lock_init(m);\n\treturn (0);\n}\n\nint \nrf_mutex_destroy(m)\ndecl_simple_lock_data(, *m)\n{\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nint \nrf_mutex_init(m)\ndecl_simple_lock_data(, *m)\n{\n\tsimple_lock_init(m);\n\treturn (0);\n}\n\nint \nrf_mutex_destroy(m)\ndecl_simple_lock_data(, *m)\n{\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "raidPtr->regionInfo",
            "(rf_numParityRegions * \n\t\t\t\t sizeof(RF_RegionInfo_t))"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"Unable to init mutex file %s line %d rc=%d\\n\"",
            "__FILE__",
            "__LINE__",
            "rc"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"Unable to create shutdown entry file %s line %d rc=%d\\n\"",
            "__FILE__",
            "__LINE__",
            "rc"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_ShutdownCreate",
          "args": [
            "listp",
            "rf_ShutdownParityLoggingDiskQueue",
            "raidPtr"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"Unable to init cond file %s line %d rc=%d\\n\"",
            "__FILE__",
            "__LINE__",
            "rc"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_create_managed_cond",
          "args": [
            "listp",
            "&raidPtr->parityLogDiskQueue.cond"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "_rf_create_managed_cond",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_threadstuff.c",
          "lines": "92-113",
          "snippet": "int \n_rf_create_managed_cond(listp, c, file, line)\n\tRF_ShutdownList_t **listp;\nRF_DECLARE_COND(*c)\n\tchar   *file;\n\tint     line;\n{\n\tint     rc, rc1;\n\n\trc = rf_cond_init(c);\n\tif (rc)\n\t\treturn (rc);\n\trc = _rf_ShutdownCreate(listp, cond_destroyer, (void *) c, file, line);\n\tif (rc) {\n\t\tRF_ERRORMSG1(\"RAIDFRAME: Error %d adding shutdown entry\\n\", rc);\n\t\trc1 = rf_cond_destroy(c);\n\t\tif (rc1) {\n\t\t\tRF_ERRORMSG1(\"RAIDFRAME: Error %d destroying cond\\n\", rc1);\n\t\t}\n\t}\n\treturn (rc);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cond_destroyer(void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic void cond_destroyer(void *);\n\nint \n_rf_create_managed_cond(listp, c, file, line)\n\tRF_ShutdownList_t **listp;\nRF_DECLARE_COND(*c)\n\tchar   *file;\n\tint     line;\n{\n\tint     rc, rc1;\n\n\trc = rf_cond_init(c);\n\tif (rc)\n\t\treturn (rc);\n\trc = _rf_ShutdownCreate(listp, cond_destroyer, (void *) c, file, line);\n\tif (rc) {\n\t\tRF_ERRORMSG1(\"RAIDFRAME: Error %d adding shutdown entry\\n\", rc);\n\t\trc1 = rf_cond_destroy(c);\n\t\tif (rc1) {\n\t\t\tRF_ERRORMSG1(\"RAIDFRAME: Error %d destroying cond\\n\", rc1);\n\t\t}\n\t}\n\treturn (rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"Unable to init mutex file %s line %d rc=%d\\n\"",
            "__FILE__",
            "__LINE__",
            "rc"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_create_managed_mutex",
          "args": [
            "listp",
            "&raidPtr->parityLogDiskQueue.mutex"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "_rf_create_managed_mutex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_threadstuff.c",
          "lines": "69-90",
          "snippet": "int \n_rf_create_managed_mutex(listp, m, file, line)\n\tRF_ShutdownList_t **listp;\nRF_DECLARE_MUTEX(*m)\n\tchar   *file;\n\tint     line;\n{\n\tint     rc, rc1;\n\n\trc = rf_mutex_init(m);\n\tif (rc)\n\t\treturn (rc);\n\trc = _rf_ShutdownCreate(listp, mutex_destroyer, (void *) m, file, line);\n\tif (rc) {\n\t\tRF_ERRORMSG1(\"RAIDFRAME: Error %d adding shutdown entry\\n\", rc);\n\t\trc1 = rf_mutex_destroy(m);\n\t\tif (rc1) {\n\t\t\tRF_ERRORMSG1(\"RAIDFRAME: Error %d destroying mutex\\n\", rc1);\n\t\t}\n\t}\n\treturn (rc);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mutex_destroyer(void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic void mutex_destroyer(void *);\n\nint \n_rf_create_managed_mutex(listp, m, file, line)\n\tRF_ShutdownList_t **listp;\nRF_DECLARE_MUTEX(*m)\n\tchar   *file;\n\tint     line;\n{\n\tint     rc, rc1;\n\n\trc = rf_mutex_init(m);\n\tif (rc)\n\t\treturn (rc);\n\trc = _rf_ShutdownCreate(listp, mutex_destroyer, (void *) m, file, line);\n\tif (rc) {\n\t\tRF_ERRORMSG1(\"RAIDFRAME: Error %d adding shutdown entry\\n\", rc);\n\t\trc1 = rf_mutex_destroy(m);\n\t\tif (rc1) {\n\t\t\tRF_ERRORMSG1(\"RAIDFRAME: Error %d destroying mutex\\n\", rc1);\n\t\t}\n\t}\n\treturn (rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_ShutdownParityLoggingParityBufferPool",
          "args": [
            "raidPtr"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ShutdownParityLoggingParityBufferPool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_paritylogging.c",
          "lines": "690-701",
          "snippet": "static void \nrf_ShutdownParityLoggingParityBufferPool(RF_ThreadArg_t arg)\n{\n\tRF_Raid_t *raidPtr;\n\n\traidPtr = (RF_Raid_t *) arg;\n\tif (rf_parityLogDebug) {\n\t\tprintf(\"raid%d: ShutdownParityLoggingParityBufferPool\\n\",\n\t\t       raidPtr->raidid);\n\t}\n\tFreeRegionBufferQueue(&raidPtr->parityBufferPool);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_parityloggingdags.h\"",
            "#include \"rf_paritylogging.h\"",
            "#include \"rf_paritylogDiskMgr.h\"",
            "#include \"rf_paritylog.h\"",
            "#include \"rf_dagdegwr.h\"",
            "#include \"rf_dagdegrd.h\"",
            "#include \"rf_dagffwr.h\"",
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_parityloggingdags.h\"\n#include \"rf_paritylogging.h\"\n#include \"rf_paritylogDiskMgr.h\"\n#include \"rf_paritylog.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void \nrf_ShutdownParityLoggingParityBufferPool(RF_ThreadArg_t arg)\n{\n\tRF_Raid_t *raidPtr;\n\n\traidPtr = (RF_Raid_t *) arg;\n\tif (rf_parityLogDebug) {\n\t\tprintf(\"raid%d: ShutdownParityLoggingParityBufferPool\\n\",\n\t\t       raidPtr->raidid);\n\t}\n\tFreeRegionBufferQueue(&raidPtr->parityBufferPool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"Unable to create shutdown entry file %s line %d rc=%d\\n\"",
            "__FILE__",
            "__LINE__",
            "rc"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_ShutdownCreate",
          "args": [
            "listp",
            "rf_ShutdownParityLoggingParityBufferPool",
            "raidPtr"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "raidPtr->parityBufferPool.buffers",
            "raidPtr->regionBufferPool.totalBuffers * \n\t\t\t\tsizeof(caddr_t)"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "raidPtr->parityBufferPool.buffers[i]",
            "raidPtr->regionBufferPool.bufferSize * \n\t\t\t\t\tsizeof(char)"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_cond_destroy",
          "args": [
            "&raidPtr->parityBufferPool.cond"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_mutex_destroy",
          "args": [
            "&raidPtr->parityBufferPool.mutex"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "raidPtr->parityBufferPool.buffers[i]",
            "raidPtr->parityBufferPool.bufferSize * sizeof(char)",
            "(caddr_t)"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_cond_destroy",
          "args": [
            "&raidPtr->parityBufferPool.cond"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_mutex_destroy",
          "args": [
            "&raidPtr->parityBufferPool.mutex"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "raidPtr->parityBufferPool.buffers",
            "raidPtr->parityBufferPool.totalBuffers * sizeof(caddr_t)",
            "(caddr_t *)"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_mutex_destroy",
          "args": [
            "&raidPtr->parityBufferPool.mutex"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"Unable to init cond file %s line %d rc=%d\\n\"",
            "__FILE__",
            "__LINE__",
            "rc"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_cond_init",
          "args": [
            "&raidPtr->parityBufferPool.cond"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "rf_cond_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_threadstuff.c",
          "lines": "188-201",
          "snippet": "int \nrf_cond_init(c)\nRF_DECLARE_COND(*c)\n{\n\t*c = 0;\t\t\t/* no reason */\n\treturn (0);\n}\n\nint \nrf_cond_destroy(c)\nRF_DECLARE_COND(*c)\n{\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nint \nrf_cond_init(c)\nRF_DECLARE_COND(*c)\n{\n\t*c = 0;\t\t\t/* no reason */\n\treturn (0);\n}\n\nint \nrf_cond_destroy(c)\nRF_DECLARE_COND(*c)\n{\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"Unable to init mutex file %s line %d rc=%d\\n\"",
            "__FILE__",
            "__LINE__",
            "rc"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_ShutdownParityLoggingRegionBufferPool",
          "args": [
            "raidPtr"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ShutdownParityLoggingRegionBufferPool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_paritylogging.c",
          "lines": "677-688",
          "snippet": "static void \nrf_ShutdownParityLoggingRegionBufferPool(RF_ThreadArg_t arg)\n{\n\tRF_Raid_t *raidPtr;\n\n\traidPtr = (RF_Raid_t *) arg;\n\tif (rf_parityLogDebug) {\n\t\tprintf(\"raid%d: ShutdownParityLoggingRegionBufferPool\\n\", \n\t\t       raidPtr->raidid);\n\t}\n\tFreeRegionBufferQueue(&raidPtr->regionBufferPool);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_parityloggingdags.h\"",
            "#include \"rf_paritylogging.h\"",
            "#include \"rf_paritylogDiskMgr.h\"",
            "#include \"rf_paritylog.h\"",
            "#include \"rf_dagdegwr.h\"",
            "#include \"rf_dagdegrd.h\"",
            "#include \"rf_dagffwr.h\"",
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_parityloggingdags.h\"\n#include \"rf_paritylogging.h\"\n#include \"rf_paritylogDiskMgr.h\"\n#include \"rf_paritylog.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void \nrf_ShutdownParityLoggingRegionBufferPool(RF_ThreadArg_t arg)\n{\n\tRF_Raid_t *raidPtr;\n\n\traidPtr = (RF_Raid_t *) arg;\n\tif (rf_parityLogDebug) {\n\t\tprintf(\"raid%d: ShutdownParityLoggingRegionBufferPool\\n\", \n\t\t       raidPtr->raidid);\n\t}\n\tFreeRegionBufferQueue(&raidPtr->regionBufferPool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"Unable to create shutdown entry file %s line %d rc=%d\\n\"",
            "__FILE__",
            "__LINE__",
            "rc"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_ShutdownCreate",
          "args": [
            "listp",
            "rf_ShutdownParityLoggingRegionBufferPool",
            "raidPtr"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "raidPtr->regionBufferPool.buffers",
            "raidPtr->regionBufferPool.totalBuffers * \n\t\t\t\tsizeof(caddr_t)"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "raidPtr->regionBufferPool.buffers[i]",
            "raidPtr->regionBufferPool.bufferSize *\n\t\t\t\t\tsizeof(char)"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_cond_destroy",
          "args": [
            "&raidPtr->regionBufferPool.cond"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_mutex_destroy",
          "args": [
            "&raidPtr->regionBufferPool.mutex"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "raidPtr->regionBufferPool.buffers[i]",
            "raidPtr->regionBufferPool.bufferSize * sizeof(char)",
            "(caddr_t)"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_cond_destroy",
          "args": [
            "&raidPtr->regionBufferPool.cond"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_mutex_destroy",
          "args": [
            "&raidPtr->regionBufferPool.mutex"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "raidPtr->regionBufferPool.buffers",
            "raidPtr->regionBufferPool.totalBuffers * sizeof(caddr_t)",
            "(caddr_t *)"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_mutex_destroy",
          "args": [
            "&raidPtr->regionBufferPool.mutex"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"Unable to init cond file %s line %d rc=%d\\n\"",
            "__FILE__",
            "__LINE__",
            "rc"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"Unable to init mutex file %s line %d rc=%d\\n\"",
            "__FILE__",
            "__LINE__",
            "rc"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_ShutdownParityLoggingPool",
          "args": [
            "raidPtr"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ShutdownParityLoggingPool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_paritylogging.c",
          "lines": "662-675",
          "snippet": "static void \nrf_ShutdownParityLoggingPool(RF_ThreadArg_t arg)\n{\n\tRF_Raid_t *raidPtr;\n\n\traidPtr = (RF_Raid_t *) arg;\n\tif (rf_parityLogDebug) {\n\t\tprintf(\"raid%d: ShutdownParityLoggingPool\\n\", raidPtr->raidid);\n\t}\n\t/* free contents of parityLogPool */\n\tFreeParityLogQueue(raidPtr, &raidPtr->parityLogPool);\n\tRF_Free(raidPtr->parityLogBufferHeap, raidPtr->numParityLogs * \n\t\traidPtr->numSectorsPerLog * raidPtr->bytesPerSector);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_utils.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_parityloggingdags.h\"",
            "#include \"rf_paritylogging.h\"",
            "#include \"rf_paritylogDiskMgr.h\"",
            "#include \"rf_paritylog.h\"",
            "#include \"rf_dagdegwr.h\"",
            "#include \"rf_dagdegrd.h\"",
            "#include \"rf_dagffwr.h\"",
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_parityloggingdags.h\"\n#include \"rf_paritylogging.h\"\n#include \"rf_paritylogDiskMgr.h\"\n#include \"rf_paritylog.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void \nrf_ShutdownParityLoggingPool(RF_ThreadArg_t arg)\n{\n\tRF_Raid_t *raidPtr;\n\n\traidPtr = (RF_Raid_t *) arg;\n\tif (rf_parityLogDebug) {\n\t\tprintf(\"raid%d: ShutdownParityLoggingPool\\n\", raidPtr->raidid);\n\t}\n\t/* free contents of parityLogPool */\n\tFreeParityLogQueue(raidPtr, &raidPtr->parityLogPool);\n\tRF_Free(raidPtr->parityLogBufferHeap, raidPtr->numParityLogs * \n\t\traidPtr->numSectorsPerLog * raidPtr->bytesPerSector);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"Unable to create shutdown entry file %s line %d rc=%d\\n\"",
            "__FILE__",
            "__LINE__",
            "rc"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_ShutdownCreate",
          "args": [
            "listp",
            "rf_ShutdownParityLoggingPool",
            "raidPtr"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "l",
            "sizeof(RF_ParityLog_t)"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "l->records",
            "(raidPtr->numSectorsPerLog * \n\t\t\t\t\t\t sizeof(RF_ParityLogRecord_t))"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "raidPtr->parityLogBufferHeap",
            "raidPtr->numParityLogs * \n\t\t\t\traidPtr->numSectorsPerLog * \n\t\t\t\traidPtr->bytesPerSector"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "l->records",
            "(raidPtr->numSectorsPerLog * \n\t\t\t\t       sizeof(RF_ParityLogRecord_t))",
            "(RF_ParityLogRecord_t *)"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "l",
            "sizeof(RF_ParityLog_t)"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "l->records",
            "(raidPtr->numSectorsPerLog * sizeof(RF_ParityLogRecord_t))"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "raidPtr->parityLogBufferHeap",
            "raidPtr->numParityLogs * \n\t\t\t\t\traidPtr->numSectorsPerLog * \n\t\t\t\t\traidPtr->bytesPerSector"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Calloc",
          "args": [
            "l->next",
            "1",
            "sizeof(RF_ParityLog_t)",
            "(RF_ParityLog_t *)"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "raidPtr->parityLogBufferHeap",
            "raidPtr->numParityLogs * \n\t\t\t\t\traidPtr->numSectorsPerLog * \n\t\t\t\t\traidPtr->bytesPerSector"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Calloc",
          "args": [
            "raidPtr->parityLogPool.parityLogs",
            "1",
            "sizeof(RF_ParityLog_t)",
            "(RF_ParityLog_t *)"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "raidPtr->parityLogBufferHeap",
            "raidPtr->numParityLogs * \n\t\t\traidPtr->numSectorsPerLog * raidPtr->bytesPerSector"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"Unable to init mutex file %s line %d rc=%d\\n\"",
            "__FILE__",
            "__LINE__",
            "rc"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "raidPtr->parityLogBufferHeap",
            "raidPtr->numParityLogs * \n\t\t  raidPtr->numSectorsPerLog * raidPtr->bytesPerSector",
            "(caddr_t)"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_Malloc",
          "args": [
            "raidPtr->regionInfo",
            "(rf_numParityRegions * sizeof(RF_RegionInfo_t))",
            "(RF_RegionInfo_t *)"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_make_2d_array",
          "args": [
            "(raidPtr->numCol)",
            "(raidPtr->numCol)",
            "raidPtr->cleanupList"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "raidPtr->numRow == 1"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_MallocAndAdd",
          "args": [
            "info",
            "sizeof(RF_ParityLoggingConfigInfo_t)",
            "(RF_ParityLoggingConfigInfo_t *), \n\t\t\traidPtr->cleanupList"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_utils.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_parityloggingdags.h\"\n#include \"rf_paritylogging.h\"\n#include \"rf_paritylogDiskMgr.h\"\n#include \"rf_paritylog.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nint \nrf_ConfigureParityLogging(\n    RF_ShutdownList_t ** listp,\n    RF_Raid_t * raidPtr,\n    RF_Config_t * cfgPtr)\n{\n\tint     i, j, startdisk, rc;\n\tRF_SectorCount_t totalLogCapacity, fragmentation, lastRegionCapacity;\n\tRF_SectorCount_t parityBufferCapacity, maxRegionParityRange;\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_ParityLoggingConfigInfo_t *info;\n\tRF_ParityLog_t *l = NULL, *next;\n\tcaddr_t lHeapPtr;\n\n\tif (rf_numParityRegions <= 0)\n\t\treturn(EINVAL);\n\n\t/*\n         * We create multiple entries on the shutdown list here, since\n         * this configuration routine is fairly complicated in and of\n         * itself, and this makes backing out of a failed configuration\n         * much simpler.\n         */\n\n\traidPtr->numSectorsPerLog = RF_DEFAULT_NUM_SECTORS_PER_LOG;\n\n\t/* create a parity logging configuration structure */\n\tRF_MallocAndAdd(info, sizeof(RF_ParityLoggingConfigInfo_t), \n\t\t\t(RF_ParityLoggingConfigInfo_t *), \n\t\t\traidPtr->cleanupList);\n\tif (info == NULL)\n\t\treturn (ENOMEM);\n\tlayoutPtr->layoutSpecificInfo = (void *) info;\n\n\tRF_ASSERT(raidPtr->numRow == 1);\n\n\t/* the stripe identifier must identify the disks in each stripe, IN\n\t * THE ORDER THAT THEY APPEAR IN THE STRIPE. */\n\tinfo->stripeIdentifier = rf_make_2d_array((raidPtr->numCol), \n\t\t\t\t\t\t  (raidPtr->numCol), \n\t\t\t\t\t\t  raidPtr->cleanupList);\n\tif (info->stripeIdentifier == NULL)\n\t\treturn (ENOMEM);\n\n\tstartdisk = 0;\n\tfor (i = 0; i < (raidPtr->numCol); i++) {\n\t\tfor (j = 0; j < (raidPtr->numCol); j++) {\n\t\t\tinfo->stripeIdentifier[i][j] = (startdisk + j) % \n\t\t\t\t(raidPtr->numCol - 1);\n\t\t}\n\t\tif ((--startdisk) < 0)\n\t\t\tstartdisk = raidPtr->numCol - 1 - 1;\n\t}\n\n\t/* fill in the remaining layout parameters */\n\tlayoutPtr->numStripe = layoutPtr->stripeUnitsPerDisk;\n\tlayoutPtr->bytesPerStripeUnit = layoutPtr->sectorsPerStripeUnit << \n\t\traidPtr->logBytesPerSector;\n\tlayoutPtr->numParityCol = 1;\n\tlayoutPtr->numParityLogCol = 1;\n\tlayoutPtr->numDataCol = raidPtr->numCol - layoutPtr->numParityCol - \n\t\tlayoutPtr->numParityLogCol;\n\tlayoutPtr->dataSectorsPerStripe = layoutPtr->numDataCol * \n\t\tlayoutPtr->sectorsPerStripeUnit;\n\tlayoutPtr->dataStripeUnitsPerDisk = layoutPtr->stripeUnitsPerDisk;\n\traidPtr->sectorsPerDisk = layoutPtr->stripeUnitsPerDisk * \n\t\tlayoutPtr->sectorsPerStripeUnit;\n\n\traidPtr->totalSectors = layoutPtr->stripeUnitsPerDisk * \n\t\tlayoutPtr->numDataCol * layoutPtr->sectorsPerStripeUnit;\n\n\t/* configure parity log parameters\n\t * \n\t * parameter               comment/constraints \n\t * ------------------------------------------- \n\t * numParityRegions*       all regions (except possibly last) \n\t *                         of equal size \n\t * totalInCoreLogCapacity* amount of memory in bytes available \n\t *                         for in-core logs (default 1 MB) \n\t * numSectorsPerLog#       capacity of an in-core log in sectors \n\t *                         (1 * disk track)\n\t * numParityLogs           total number of in-core logs,\n\t *                         should be at least numParityRegions \n\t * regionLogCapacity       size of a region log (except possibly \n\t *                         last one) in sectors \n\t * totalLogCapacity        total amount of log space in sectors\n\t * \n\t * where '*' denotes a user settable parameter. \n\t * Note that logs are fixed to be the size of a disk track, \n\t * value #defined in rf_paritylog.h\n\t * \n\t */\n\n\ttotalLogCapacity = layoutPtr->stripeUnitsPerDisk * layoutPtr->sectorsPerStripeUnit * layoutPtr->numParityLogCol;\n\traidPtr->regionLogCapacity = totalLogCapacity / rf_numParityRegions;\n\tif (rf_parityLogDebug)\n\t\tprintf(\"bytes per sector %d\\n\", raidPtr->bytesPerSector);\n\n\t/* reduce fragmentation within a disk region by adjusting the number\n\t * of regions in an attempt to allow an integral number of logs to fit\n\t * into a disk region */\n\tfragmentation = raidPtr->regionLogCapacity % raidPtr->numSectorsPerLog;\n\tif (fragmentation > 0)\n\t\tfor (i = 1; i < (raidPtr->numSectorsPerLog / 2); i++) {\n\t\t\tif (((totalLogCapacity / (rf_numParityRegions + i)) % \n\t\t\t     raidPtr->numSectorsPerLog) < fragmentation) {\n\t\t\t\trf_numParityRegions++;\n\t\t\t\traidPtr->regionLogCapacity = totalLogCapacity /\n\t\t\t\t\trf_numParityRegions;\n\t\t\t\tfragmentation = raidPtr->regionLogCapacity % \n\t\t\t\t\traidPtr->numSectorsPerLog;\n\t\t\t}\n\t\t\tif (((totalLogCapacity / (rf_numParityRegions - i)) % \n\t\t\t     raidPtr->numSectorsPerLog) < fragmentation) {\n\t\t\t\trf_numParityRegions--;\n\t\t\t\traidPtr->regionLogCapacity = totalLogCapacity /\n\t\t\t\t\trf_numParityRegions;\n\t\t\t\tfragmentation = raidPtr->regionLogCapacity % \n\t\t\t\t\traidPtr->numSectorsPerLog;\n\t\t\t}\n\t\t}\n\t/* ensure integral number of regions per log */\n\traidPtr->regionLogCapacity = (raidPtr->regionLogCapacity / \n\t\t\t\t      raidPtr->numSectorsPerLog) * \n\t\traidPtr->numSectorsPerLog;\n\n\traidPtr->numParityLogs = rf_totalInCoreLogCapacity / \n\t\t(raidPtr->bytesPerSector * raidPtr->numSectorsPerLog);\n\t/* to avoid deadlock, must ensure that enough logs exist for each\n\t * region to have one simultaneously */\n\tif (raidPtr->numParityLogs < rf_numParityRegions)\n\t\traidPtr->numParityLogs = rf_numParityRegions;\n\n\t/* create region information structs */\n\tRF_Malloc(raidPtr->regionInfo, \n\t\t  (rf_numParityRegions * sizeof(RF_RegionInfo_t)), \n\t\t  (RF_RegionInfo_t *));\n\tif (raidPtr->regionInfo == NULL)\n\t\treturn (ENOMEM);\n\n\t/* last region may not be full capacity */\n\tlastRegionCapacity = raidPtr->regionLogCapacity;\n\twhile ((rf_numParityRegions - 1) * raidPtr->regionLogCapacity + \n\t       lastRegionCapacity > totalLogCapacity)\n\t\tlastRegionCapacity = lastRegionCapacity - \n\t\t\traidPtr->numSectorsPerLog;\n\n\traidPtr->regionParityRange = raidPtr->sectorsPerDisk / \n\t\trf_numParityRegions;\n\tmaxRegionParityRange = raidPtr->regionParityRange;\n\n/* i can't remember why this line is in the code -wvcii 6/30/95 */\n/*  if (raidPtr->sectorsPerDisk % rf_numParityRegions > 0)\n    regionParityRange++; */\n\n\t/* build pool of unused parity logs */\n\tRF_Malloc(raidPtr->parityLogBufferHeap, raidPtr->numParityLogs * \n\t\t  raidPtr->numSectorsPerLog * raidPtr->bytesPerSector, \n\t\t  (caddr_t));\n\tif (raidPtr->parityLogBufferHeap == NULL)\n\t\treturn (ENOMEM);\n\tlHeapPtr = raidPtr->parityLogBufferHeap;\n\trc = rf_mutex_init(&raidPtr->parityLogPool.mutex);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to init mutex file %s line %d rc=%d\\n\", \n\t\t\t     __FILE__, __LINE__, rc);\n\t\tRF_Free(raidPtr->parityLogBufferHeap, raidPtr->numParityLogs * \n\t\t\traidPtr->numSectorsPerLog * raidPtr->bytesPerSector);\n\t\treturn (ENOMEM);\n\t}\n\tfor (i = 0; i < raidPtr->numParityLogs; i++) {\n\t\tif (i == 0) {\n\t\t\tRF_Calloc(raidPtr->parityLogPool.parityLogs, 1, \n\t\t\t\t  sizeof(RF_ParityLog_t), (RF_ParityLog_t *));\n\t\t\tif (raidPtr->parityLogPool.parityLogs == NULL) {\n\t\t\t\tRF_Free(raidPtr->parityLogBufferHeap, \n\t\t\t\t\traidPtr->numParityLogs * \n\t\t\t\t\traidPtr->numSectorsPerLog * \n\t\t\t\t\traidPtr->bytesPerSector);\n\t\t\t\treturn (ENOMEM);\n\t\t\t}\n\t\t\tl = raidPtr->parityLogPool.parityLogs;\n\t\t} else {\n\t\t\tRF_Calloc(l->next, 1, sizeof(RF_ParityLog_t), \n\t\t\t\t  (RF_ParityLog_t *));\n\t\t\tif (l->next == NULL) {\n\t\t\t\tRF_Free(raidPtr->parityLogBufferHeap, \n\t\t\t\t\traidPtr->numParityLogs * \n\t\t\t\t\traidPtr->numSectorsPerLog * \n\t\t\t\t\traidPtr->bytesPerSector);\n\t\t\t\tfor (l = raidPtr->parityLogPool.parityLogs; \n\t\t\t\t     l;\n\t\t\t\t     l = next) {\n\t\t\t\t\tnext = l->next;\n\t\t\t\t\tif (l->records)\n\t\t\t\t\t\tRF_Free(l->records, (raidPtr->numSectorsPerLog * sizeof(RF_ParityLogRecord_t)));\n\t\t\t\t\tRF_Free(l, sizeof(RF_ParityLog_t));\n\t\t\t\t}\n\t\t\t\treturn (ENOMEM);\n\t\t\t}\n\t\t\tl = l->next;\n\t\t}\n\t\tl->bufPtr = lHeapPtr;\n\t\tlHeapPtr += raidPtr->numSectorsPerLog * \n\t\t\traidPtr->bytesPerSector;\n\t\tRF_Malloc(l->records, (raidPtr->numSectorsPerLog * \n\t\t\t\t       sizeof(RF_ParityLogRecord_t)), \n\t\t\t  (RF_ParityLogRecord_t *));\n\t\tif (l->records == NULL) {\n\t\t\tRF_Free(raidPtr->parityLogBufferHeap, \n\t\t\t\traidPtr->numParityLogs * \n\t\t\t\traidPtr->numSectorsPerLog * \n\t\t\t\traidPtr->bytesPerSector);\n\t\t\tfor (l = raidPtr->parityLogPool.parityLogs; \n\t\t\t     l; \n\t\t\t     l = next) {\n\t\t\t\tnext = l->next;\n\t\t\t\tif (l->records)\n\t\t\t\t\tRF_Free(l->records, \n\t\t\t\t\t\t(raidPtr->numSectorsPerLog * \n\t\t\t\t\t\t sizeof(RF_ParityLogRecord_t)));\n\t\t\t\tRF_Free(l, sizeof(RF_ParityLog_t));\n\t\t\t}\n\t\t\treturn (ENOMEM);\n\t\t}\n\t}\n\trc = rf_ShutdownCreate(listp, rf_ShutdownParityLoggingPool, raidPtr);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to create shutdown entry file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\trf_ShutdownParityLoggingPool(raidPtr);\n\t\treturn (rc);\n\t}\n\t/* build pool of region buffers */\n\trc = rf_mutex_init(&raidPtr->regionBufferPool.mutex);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to init mutex file %s line %d rc=%d\\n\", \n\t\t\t     __FILE__, __LINE__, rc);\n\t\treturn (ENOMEM);\n\t}\n\trc = rf_cond_init(&raidPtr->regionBufferPool.cond);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to init cond file %s line %d rc=%d\\n\", \n\t\t\t     __FILE__, __LINE__, rc);\n\t\trf_mutex_destroy(&raidPtr->regionBufferPool.mutex);\n\t\treturn (ENOMEM);\n\t}\n\traidPtr->regionBufferPool.bufferSize = raidPtr->regionLogCapacity * \n\t\traidPtr->bytesPerSector;\n\tprintf(\"regionBufferPool.bufferSize %d\\n\", \n\t       raidPtr->regionBufferPool.bufferSize);\n\n\t/* for now, only one region at a time may be reintegrated */\n\traidPtr->regionBufferPool.totalBuffers = 1;\t\n\n\traidPtr->regionBufferPool.availableBuffers = \n\t\traidPtr->regionBufferPool.totalBuffers;\n\traidPtr->regionBufferPool.availBuffersIndex = 0;\n\traidPtr->regionBufferPool.emptyBuffersIndex = 0;\n\tRF_Malloc(raidPtr->regionBufferPool.buffers, \n\t\t  raidPtr->regionBufferPool.totalBuffers * sizeof(caddr_t), \n\t\t  (caddr_t *));\n\tif (raidPtr->regionBufferPool.buffers == NULL) {\n\t\trf_mutex_destroy(&raidPtr->regionBufferPool.mutex);\n\t\trf_cond_destroy(&raidPtr->regionBufferPool.cond);\n\t\treturn (ENOMEM);\n\t}\n\tfor (i = 0; i < raidPtr->regionBufferPool.totalBuffers; i++) {\n\t\tRF_Malloc(raidPtr->regionBufferPool.buffers[i], \n\t\t\t  raidPtr->regionBufferPool.bufferSize * sizeof(char),\n\t\t\t  (caddr_t));\n\t\tif (raidPtr->regionBufferPool.buffers[i] == NULL) {\n\t\t\trf_mutex_destroy(&raidPtr->regionBufferPool.mutex);\n\t\t\trf_cond_destroy(&raidPtr->regionBufferPool.cond);\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\tRF_Free(raidPtr->regionBufferPool.buffers[i], \n\t\t\t\t\traidPtr->regionBufferPool.bufferSize *\n\t\t\t\t\tsizeof(char));\n\t\t\t}\n\t\t\tRF_Free(raidPtr->regionBufferPool.buffers, \n\t\t\t\traidPtr->regionBufferPool.totalBuffers * \n\t\t\t\tsizeof(caddr_t));\n\t\t\treturn (ENOMEM);\n\t\t}\n\t\tprintf(\"raidPtr->regionBufferPool.buffers[%d] = %lx\\n\", i,\n\t\t    (long) raidPtr->regionBufferPool.buffers[i]);\n\t}\n\trc = rf_ShutdownCreate(listp, \n\t\t\t       rf_ShutdownParityLoggingRegionBufferPool,\n\t\t\t       raidPtr);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to create shutdown entry file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\trf_ShutdownParityLoggingRegionBufferPool(raidPtr);\n\t\treturn (rc);\n\t}\n\t/* build pool of parity buffers */\n\tparityBufferCapacity = maxRegionParityRange;\n\trc = rf_mutex_init(&raidPtr->parityBufferPool.mutex);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to init mutex file %s line %d rc=%d\\n\", \n\t\t\t     __FILE__, __LINE__, rc);\n\t\treturn (rc);\n\t}\n\trc = rf_cond_init(&raidPtr->parityBufferPool.cond);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to init cond file %s line %d rc=%d\\n\", \n\t\t\t     __FILE__, __LINE__, rc);\n\t\trf_mutex_destroy(&raidPtr->parityBufferPool.mutex);\n\t\treturn (ENOMEM);\n\t}\n\traidPtr->parityBufferPool.bufferSize = parityBufferCapacity * \n\t\traidPtr->bytesPerSector;\n\tprintf(\"parityBufferPool.bufferSize %d\\n\", \n\t       raidPtr->parityBufferPool.bufferSize);\n\n\t/* for now, only one region at a time may be reintegrated */\n\traidPtr->parityBufferPool.totalBuffers = 1;\t\n\n\traidPtr->parityBufferPool.availableBuffers = \n\t\traidPtr->parityBufferPool.totalBuffers;\n\traidPtr->parityBufferPool.availBuffersIndex = 0;\n\traidPtr->parityBufferPool.emptyBuffersIndex = 0;\n\tRF_Malloc(raidPtr->parityBufferPool.buffers, \n\t\t  raidPtr->parityBufferPool.totalBuffers * sizeof(caddr_t), \n\t\t  (caddr_t *));\n\tif (raidPtr->parityBufferPool.buffers == NULL) {\n\t\trf_mutex_destroy(&raidPtr->parityBufferPool.mutex);\n\t\trf_cond_destroy(&raidPtr->parityBufferPool.cond);\n\t\treturn (ENOMEM);\n\t}\n\tfor (i = 0; i < raidPtr->parityBufferPool.totalBuffers; i++) {\n\t\tRF_Malloc(raidPtr->parityBufferPool.buffers[i], \n\t\t\t  raidPtr->parityBufferPool.bufferSize * sizeof(char),\n\t\t\t  (caddr_t));\n\t\tif (raidPtr->parityBufferPool.buffers == NULL) {\n\t\t\trf_mutex_destroy(&raidPtr->parityBufferPool.mutex);\n\t\t\trf_cond_destroy(&raidPtr->parityBufferPool.cond);\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\tRF_Free(raidPtr->parityBufferPool.buffers[i], \n\t\t\t\t\traidPtr->regionBufferPool.bufferSize * \n\t\t\t\t\tsizeof(char));\n\t\t\t}\n\t\t\tRF_Free(raidPtr->parityBufferPool.buffers, \n\t\t\t\traidPtr->regionBufferPool.totalBuffers * \n\t\t\t\tsizeof(caddr_t));\n\t\t\treturn (ENOMEM);\n\t\t}\n\t\tprintf(\"parityBufferPool.buffers[%d] = %lx\\n\", i,\n\t\t    (long) raidPtr->parityBufferPool.buffers[i]);\n\t}\n\trc = rf_ShutdownCreate(listp, \n\t\t\t       rf_ShutdownParityLoggingParityBufferPool, \n\t\t\t       raidPtr);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to create shutdown entry file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\trf_ShutdownParityLoggingParityBufferPool(raidPtr);\n\t\treturn (rc);\n\t}\n\t/* initialize parityLogDiskQueue */\n\trc = rf_create_managed_mutex(listp, \n\t\t\t\t     &raidPtr->parityLogDiskQueue.mutex);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to init mutex file %s line %d rc=%d\\n\", \n\t\t\t     __FILE__, __LINE__, rc);\n\t\treturn (rc);\n\t}\n\trc = rf_create_managed_cond(listp, &raidPtr->parityLogDiskQueue.cond);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to init cond file %s line %d rc=%d\\n\", \n\t\t\t     __FILE__, __LINE__, rc);\n\t\treturn (rc);\n\t}\n\traidPtr->parityLogDiskQueue.flushQueue = NULL;\n\traidPtr->parityLogDiskQueue.reintQueue = NULL;\n\traidPtr->parityLogDiskQueue.bufHead = NULL;\n\traidPtr->parityLogDiskQueue.bufTail = NULL;\n\traidPtr->parityLogDiskQueue.reintHead = NULL;\n\traidPtr->parityLogDiskQueue.reintTail = NULL;\n\traidPtr->parityLogDiskQueue.logBlockHead = NULL;\n\traidPtr->parityLogDiskQueue.logBlockTail = NULL;\n\traidPtr->parityLogDiskQueue.reintBlockHead = NULL;\n\traidPtr->parityLogDiskQueue.reintBlockTail = NULL;\n\traidPtr->parityLogDiskQueue.freeDataList = NULL;\n\traidPtr->parityLogDiskQueue.freeCommonList = NULL;\n\n\trc = rf_ShutdownCreate(listp, \n\t\t\t       rf_ShutdownParityLoggingDiskQueue, \n\t\t\t       raidPtr);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to create shutdown entry file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\treturn (rc);\n\t}\n\tfor (i = 0; i < rf_numParityRegions; i++) {\n\t\trc = rf_mutex_init(&raidPtr->regionInfo[i].mutex);\n\t\tif (rc) {\n\t\t\tRF_ERRORMSG3(\"Unable to init mutex file %s line %d rc=%d\\n\", __FILE__,\n\t\t\t    __LINE__, rc);\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tFreeRegionInfo(raidPtr, j);\n\t\t\tRF_Free(raidPtr->regionInfo, \n\t\t\t\t(rf_numParityRegions * \n\t\t\t\t sizeof(RF_RegionInfo_t)));\n\t\t\treturn (ENOMEM);\n\t\t}\n\t\trc = rf_mutex_init(&raidPtr->regionInfo[i].reintMutex);\n\t\tif (rc) {\n\t\t\tRF_ERRORMSG3(\"Unable to init mutex file %s line %d rc=%d\\n\", __FILE__,\n\t\t\t    __LINE__, rc);\n\t\t\trf_mutex_destroy(&raidPtr->regionInfo[i].mutex);\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tFreeRegionInfo(raidPtr, j);\n\t\t\tRF_Free(raidPtr->regionInfo, \n\t\t\t\t(rf_numParityRegions * \n\t\t\t\t sizeof(RF_RegionInfo_t)));\n\t\t\treturn (ENOMEM);\n\t\t}\n\t\traidPtr->regionInfo[i].reintInProgress = RF_FALSE;\n\t\traidPtr->regionInfo[i].regionStartAddr = \n\t\t\traidPtr->regionLogCapacity * i;\n\t\traidPtr->regionInfo[i].parityStartAddr = \n\t\t\traidPtr->regionParityRange * i;\n\t\tif (i < rf_numParityRegions - 1) {\n\t\t\traidPtr->regionInfo[i].capacity = \n\t\t\t\traidPtr->regionLogCapacity;\n\t\t\traidPtr->regionInfo[i].numSectorsParity = \n\t\t\t\traidPtr->regionParityRange;\n\t\t} else {\n\t\t\traidPtr->regionInfo[i].capacity = \n\t\t\t\tlastRegionCapacity;\n\t\t\traidPtr->regionInfo[i].numSectorsParity = \n\t\t\t\traidPtr->sectorsPerDisk - \n\t\t\t\traidPtr->regionParityRange * i;\n\t\t\tif (raidPtr->regionInfo[i].numSectorsParity > \n\t\t\t    maxRegionParityRange)\n\t\t\t\tmaxRegionParityRange = \n\t\t\t\t\traidPtr->regionInfo[i].numSectorsParity;\n\t\t}\n\t\traidPtr->regionInfo[i].diskCount = 0;\n\t\tRF_ASSERT(raidPtr->regionInfo[i].capacity + \n\t\t\t  raidPtr->regionInfo[i].regionStartAddr <= \n\t\t\t  totalLogCapacity);\n\t\tRF_ASSERT(raidPtr->regionInfo[i].parityStartAddr + \n\t\t\t  raidPtr->regionInfo[i].numSectorsParity <= \n\t\t\t  raidPtr->sectorsPerDisk);\n\t\tRF_Malloc(raidPtr->regionInfo[i].diskMap, \n\t\t\t  (raidPtr->regionInfo[i].capacity *\n\t\t\t   sizeof(RF_DiskMap_t)), \n\t\t\t  (RF_DiskMap_t *));\n\t\tif (raidPtr->regionInfo[i].diskMap == NULL) {\n\t\t\trf_mutex_destroy(&raidPtr->regionInfo[i].mutex);\n\t\t\trf_mutex_destroy(&raidPtr->regionInfo[i].reintMutex);\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tFreeRegionInfo(raidPtr, j);\n\t\t\tRF_Free(raidPtr->regionInfo, \n\t\t\t\t(rf_numParityRegions * \n\t\t\t\t sizeof(RF_RegionInfo_t)));\n\t\t\treturn (ENOMEM);\n\t\t}\n\t\traidPtr->regionInfo[i].loggingEnabled = RF_FALSE;\n\t\traidPtr->regionInfo[i].coreLog = NULL;\n\t}\n\trc = rf_ShutdownCreate(listp,\n\t\t\t       rf_ShutdownParityLoggingRegionInfo, \n\t\t\t       raidPtr);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to create shutdown entry file %s line %d rc=%d\\n\", __FILE__,\n\t\t    __LINE__, rc);\n\t\trf_ShutdownParityLoggingRegionInfo(raidPtr);\n\t\treturn (rc);\n\t}\n\tRF_ASSERT(raidPtr->parityLogDiskQueue.threadState == 0);\n\traidPtr->parityLogDiskQueue.threadState = RF_PLOG_CREATED;\n\trc = RF_CREATE_THREAD(raidPtr->pLogDiskThreadHandle, \n\t\t\t      rf_ParityLoggingDiskManager, raidPtr,\"rf_log\");\n\tif (rc) {\n\t\traidPtr->parityLogDiskQueue.threadState = 0;\n\t\tRF_ERRORMSG3(\"Unable to create parity logging disk thread file %s line %d rc=%d\\n\",\n\t\t    __FILE__, __LINE__, rc);\n\t\treturn (ENOMEM);\n\t}\n\t/* wait for thread to start */\n\tRF_LOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);\n\twhile (!(raidPtr->parityLogDiskQueue.threadState & RF_PLOG_RUNNING)) {\n\t\tRF_WAIT_COND(raidPtr->parityLogDiskQueue.cond, \n\t\t\t     raidPtr->parityLogDiskQueue.mutex);\n\t}\n\tRF_UNLOCK_MUTEX(raidPtr->parityLogDiskQueue.mutex);\n\n\trc = rf_ShutdownCreate(listp, rf_ShutdownParityLogging, raidPtr);\n\tif (rc) {\n\t\tRF_ERRORMSG1(\"Got rc=%d adding parity logging shutdown event\\n\", rc);\n\t\trf_ShutdownParityLogging(raidPtr);\n\t\treturn (rc);\n\t}\n\tif (rf_parityLogDebug) {\n\t\tprintf(\"                            size of disk log in sectors: %d\\n\",\n\t\t    (int) totalLogCapacity);\n\t\tprintf(\"                            total number of parity regions is %d\\n\", (int) rf_numParityRegions);\n\t\tprintf(\"                            nominal sectors of log per parity region is %d\\n\", (int) raidPtr->regionLogCapacity);\n\t\tprintf(\"                            nominal region fragmentation is %d sectors\\n\", (int) fragmentation);\n\t\tprintf(\"                            total number of parity logs is %d\\n\", raidPtr->numParityLogs);\n\t\tprintf(\"                            parity log size is %d sectors\\n\", raidPtr->numSectorsPerLog);\n\t\tprintf(\"                            total in-core log space is %d bytes\\n\", (int) rf_totalInCoreLogCapacity);\n\t}\n\trf_EnableParityLogging(raidPtr);\n\n\treturn (0);\n}"
  }
]