[
  {
    "function_name": "sm_isa_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_sm_isa.c",
    "lines": "169-203",
    "snippet": "void\nsm_isa_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct sm_isa_softc *isc = (struct sm_isa_softc *)self;\n\tstruct smc91cxx_softc *sc = &isc->sc_smc;\n\tstruct isa_attach_args *ia = aux;\n\tbus_space_tag_t iot = ia->ia_iot;\n\tbus_space_handle_t ioh;\n\n\tprintf(\"\\n\");\n\n\t/* Map i/o space. */\n\tif (bus_space_map(iot, ia->ia_iobase, ia->ia_iosize, 0, &ioh))\n\t\tpanic(\"sm_isa_attach: can't map i/o space\");\n\n\tsc->sc_bst = iot;\n\tsc->sc_bsh = ioh;\n\n\t/* should always be enabled */\n\tsc->sc_enabled = 1;\n\n\t/* XXX Should get Ethernet address from EEPROM!! */\n\n\t/* Perform generic intialization. */\n\tsmc91cxx_attach(sc, NULL);\n\n\t/* Establish the interrupt handler. */\n\tisc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,\n\t    IPL_NET, smc91cxx_intr, sc, sc->sc_dev.dv_xname);\n\tif (isc->sc_ih == NULL)\n\t\tprintf(\"%s: couldn't establish interrupt handler\\n\",\n\t\t    sc->sc_dev.dv_xname);\n}",
    "includes": [
      "#include <dev/isa/isavar.h>",
      "#include <dev/ic/smc91cxxvar.h>",
      "#include <dev/ic/smc91cxxreg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void\tsm_isa_attach"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: couldn't establish interrupt handler\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "isa_intr_establish",
          "args": [
            "ia->ia_ic",
            "ia->ia_irq",
            "IST_EDGE",
            "IPL_NET",
            "smc91cxx_intr",
            "sc",
            "sc->sc_dev.dv_xname"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smc91cxx_attach",
          "args": [
            "sc",
            "NULL"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "smc91cxx_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/smc91cxx.c",
          "lines": "201-279",
          "snippet": "void\nsmc91cxx_attach(sc, myea)\n\tstruct smc91cxx_softc *sc;\n\tu_int8_t *myea;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tu_int16_t tmp;\n\tint i, aui;\n#ifdef SMC_DEBUG\n\tconst char *idstr;\n#endif\n\n\t/* Make sure the chip is stopped. */\n\tsmc91cxx_stop(sc);\n\n#ifdef SMC_DEBUG\n\tSMC_SELECT_BANK(sc, 3);\n\ttmp = bus_space_read_2(bst, bsh, REVISION_REG_W);\n\tidstr = smc91cxx_idstrs[RR_ID(tmp)];\n\tprintf(\"%s: \", sc->sc_dev.dv_xname);\n\tif (idstr != NULL)\n\t\tprintf(\"%s, \", idstr);\n\telse\n\t\tprintf(\"unknown chip id %d, \", RR_ID(tmp));\n\tprintf(\"revision %d\\n\", RR_REV(tmp));\n#endif\n\n\t/* Read the station address from the chip. */\n\tSMC_SELECT_BANK(sc, 1);\n\tif (myea == NULL) {\n\t\tfor (i = 0; i < ETHER_ADDR_LEN; i += 2) {\n\t\t\ttmp = bus_space_read_2(bst, bsh, IAR_ADDR0_REG_W + i);\n\t\t\tsc->sc_arpcom.ac_enaddr[i + 1] = (tmp >>8) & 0xff;\n\t\t\tsc->sc_arpcom.ac_enaddr[i] = tmp & 0xff;\n\t\t}\n\t} else {\n\t\tbcopy(myea, sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);\n\t}\n\n\tprintf(\": address %s, \",\n\t    ether_sprintf(sc->sc_arpcom.ac_enaddr));\n\n\t/* ..and default media. */\n\ttmp = bus_space_read_2(bst, bsh, CONFIG_REG_W);\n\tprintf(\"utp/aui (default %s)\\n\", (aui = (tmp & CR_AUI_SELECT)) ?\n\t    \"aui\" : \"utp\");\n\n\t/* Initialize the ifnet structure. */\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_start = smc91cxx_start;\n\tifp->if_ioctl = smc91cxx_ioctl;\n\tifp->if_watchdog = smc91cxx_watchdog;\n\tifp->if_flags =\n\t    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;\n\tifp->if_snd.ifq_maxlen = IFQ_MAXLEN;\n\n\t/* Attach the interface. */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n\t/* Initialize the media structures. */\n\tifmedia_init(&sc->sc_media, 0, smc91cxx_mediachange,\n\t    smc91cxx_mediastatus);\n\tfor (i = 0; i < NSMC91CxxMEDIA; i++)\n\t\tifmedia_add(&sc->sc_media, smc91cxx_media[i], 0, NULL);\n\tifmedia_set(&sc->sc_media, IFM_ETHER | (aui ? IFM_10_5 : IFM_10_T));\n\n#if NBPFILTER > 0\n\tbpfattach(&sc->sc_arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,\n\t\tsizeof(struct ether_header));\n#endif\n\n#if NRND > 0\n\trnd_attach_source(&sc->rnd_source, sc->sc_dev.dv_xname, RND_TYPE_NET);\n#endif\n}",
          "includes": [
            "#include <dev/ic/smc91cxxvar.h>",
            "#include <dev/ic/smc91cxxreg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netccitt/pk_extern.h>",
            "#include <netccitt/pk_var.h>",
            "#include <netccitt/pk.h>",
            "#include <netccitt/x25.h>",
            "#include <sys/socketvar.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/rnd.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tNSMC91CxxMEDIA\t(sizeof(smc91cxx_media) / sizeof(smc91cxx_media[0]))",
            "#define ETHER_ADDR_LEN\t\t6"
          ],
          "globals_used": [
            "const int smc91cxx_media[] = {\n\tIFM_ETHER|IFM_10_T,\n\tIFM_ETHER|IFM_10_5,\n};",
            "int\tsmc91cxx_mediachange",
            "void\tsmc91cxx_mediastatus",
            "void\tsmc91cxx_start",
            "void\tsmc91cxx_watchdog",
            "int\tsmc91cxx_ioctl"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/smc91cxxvar.h>\n#include <dev/ic/smc91cxxreg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netccitt/pk_extern.h>\n#include <netccitt/pk_var.h>\n#include <netccitt/pk.h>\n#include <netccitt/x25.h>\n#include <sys/socketvar.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/rnd.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tNSMC91CxxMEDIA\t(sizeof(smc91cxx_media) / sizeof(smc91cxx_media[0]))\n#define ETHER_ADDR_LEN\t\t6\n\nconst int smc91cxx_media[] = {\n\tIFM_ETHER|IFM_10_T,\n\tIFM_ETHER|IFM_10_5,\n};\nint\tsmc91cxx_mediachange;\nvoid\tsmc91cxx_mediastatus;\nvoid\tsmc91cxx_start;\nvoid\tsmc91cxx_watchdog;\nint\tsmc91cxx_ioctl;\n\nvoid\nsmc91cxx_attach(sc, myea)\n\tstruct smc91cxx_softc *sc;\n\tu_int8_t *myea;\n{\n\tstruct ifnet *ifp = &sc->sc_arpcom.ac_if;\n\tbus_space_tag_t bst = sc->sc_bst;\n\tbus_space_handle_t bsh = sc->sc_bsh;\n\tu_int16_t tmp;\n\tint i, aui;\n#ifdef SMC_DEBUG\n\tconst char *idstr;\n#endif\n\n\t/* Make sure the chip is stopped. */\n\tsmc91cxx_stop(sc);\n\n#ifdef SMC_DEBUG\n\tSMC_SELECT_BANK(sc, 3);\n\ttmp = bus_space_read_2(bst, bsh, REVISION_REG_W);\n\tidstr = smc91cxx_idstrs[RR_ID(tmp)];\n\tprintf(\"%s: \", sc->sc_dev.dv_xname);\n\tif (idstr != NULL)\n\t\tprintf(\"%s, \", idstr);\n\telse\n\t\tprintf(\"unknown chip id %d, \", RR_ID(tmp));\n\tprintf(\"revision %d\\n\", RR_REV(tmp));\n#endif\n\n\t/* Read the station address from the chip. */\n\tSMC_SELECT_BANK(sc, 1);\n\tif (myea == NULL) {\n\t\tfor (i = 0; i < ETHER_ADDR_LEN; i += 2) {\n\t\t\ttmp = bus_space_read_2(bst, bsh, IAR_ADDR0_REG_W + i);\n\t\t\tsc->sc_arpcom.ac_enaddr[i + 1] = (tmp >>8) & 0xff;\n\t\t\tsc->sc_arpcom.ac_enaddr[i] = tmp & 0xff;\n\t\t}\n\t} else {\n\t\tbcopy(myea, sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);\n\t}\n\n\tprintf(\": address %s, \",\n\t    ether_sprintf(sc->sc_arpcom.ac_enaddr));\n\n\t/* ..and default media. */\n\ttmp = bus_space_read_2(bst, bsh, CONFIG_REG_W);\n\tprintf(\"utp/aui (default %s)\\n\", (aui = (tmp & CR_AUI_SELECT)) ?\n\t    \"aui\" : \"utp\");\n\n\t/* Initialize the ifnet structure. */\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_start = smc91cxx_start;\n\tifp->if_ioctl = smc91cxx_ioctl;\n\tifp->if_watchdog = smc91cxx_watchdog;\n\tifp->if_flags =\n\t    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;\n\tifp->if_snd.ifq_maxlen = IFQ_MAXLEN;\n\n\t/* Attach the interface. */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n\t/* Initialize the media structures. */\n\tifmedia_init(&sc->sc_media, 0, smc91cxx_mediachange,\n\t    smc91cxx_mediastatus);\n\tfor (i = 0; i < NSMC91CxxMEDIA; i++)\n\t\tifmedia_add(&sc->sc_media, smc91cxx_media[i], 0, NULL);\n\tifmedia_set(&sc->sc_media, IFM_ETHER | (aui ? IFM_10_5 : IFM_10_T));\n\n#if NBPFILTER > 0\n\tbpfattach(&sc->sc_arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,\n\t\tsizeof(struct ether_header));\n#endif\n\n#if NRND > 0\n\trnd_attach_source(&sc->rnd_source, sc->sc_dev.dv_xname, RND_TYPE_NET);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"sm_isa_attach: can't map i/o space\""
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "iot",
            "ia->ia_iobase",
            "ia->ia_iosize",
            "0",
            "&ioh"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/isavar.h>\n#include <dev/ic/smc91cxxvar.h>\n#include <dev/ic/smc91cxxreg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\tsm_isa_attach;\n\nvoid\nsm_isa_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct sm_isa_softc *isc = (struct sm_isa_softc *)self;\n\tstruct smc91cxx_softc *sc = &isc->sc_smc;\n\tstruct isa_attach_args *ia = aux;\n\tbus_space_tag_t iot = ia->ia_iot;\n\tbus_space_handle_t ioh;\n\n\tprintf(\"\\n\");\n\n\t/* Map i/o space. */\n\tif (bus_space_map(iot, ia->ia_iobase, ia->ia_iosize, 0, &ioh))\n\t\tpanic(\"sm_isa_attach: can't map i/o space\");\n\n\tsc->sc_bst = iot;\n\tsc->sc_bsh = ioh;\n\n\t/* should always be enabled */\n\tsc->sc_enabled = 1;\n\n\t/* XXX Should get Ethernet address from EEPROM!! */\n\n\t/* Perform generic intialization. */\n\tsmc91cxx_attach(sc, NULL);\n\n\t/* Establish the interrupt handler. */\n\tisc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,\n\t    IPL_NET, smc91cxx_intr, sc, sc->sc_dev.dv_xname);\n\tif (isc->sc_ih == NULL)\n\t\tprintf(\"%s: couldn't establish interrupt handler\\n\",\n\t\t    sc->sc_dev.dv_xname);\n}"
  },
  {
    "function_name": "sm_isa_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/if_sm_isa.c",
    "lines": "104-167",
    "snippet": "int\nsm_isa_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct isa_attach_args *ia = aux;\n\tbus_space_tag_t iot = ia->ia_iot;\n\tbus_space_handle_t ioh;\n\tu_int16_t tmp;\n\tint rv = 0;\n\textern const char *smc91cxx_idstrs[];\n\n\t/* Disallow wildcarded values. */\n\tif (ia->ia_irq == -1)\n\t\treturn (0);\n\tif (ia->ia_iobase == -1)\n\t\treturn (0);\n\n\t/* Map i/o space. */\n\tif (bus_space_map(iot, ia->ia_iobase, SMC_IOSIZE, 0, &ioh))\n\t\treturn (0);\n\n\t/* Check that high byte of BANK_SELECT is what we expect. */\n\ttmp = bus_space_read_2(iot, ioh, BANK_SELECT_REG_W);\n\tif ((tmp & BSR_DETECT_MASK) != BSR_DETECT_VALUE)\n\t\tgoto out;\n\n\t/*\n\t * Switch to bank 0 and perform the test again.\n\t * XXX INVASIVE!\n\t */\n\tbus_space_write_2(iot, ioh, BANK_SELECT_REG_W, 0);\n\ttmp = bus_space_read_2(iot, ioh, BANK_SELECT_REG_W);\n\tif ((tmp & BSR_DETECT_MASK) != BSR_DETECT_VALUE)\n\t\tgoto out;\n\n\t/*\n\t * Switch to bank 1 and check the base address register.\n\t * XXX INVASIVE!\n\t */\n\tbus_space_write_2(iot, ioh, BANK_SELECT_REG_W, 1);\n\ttmp = bus_space_read_2(iot, ioh, BASE_ADDR_REG_W);\n\tif (ia->ia_iobase != ((tmp >> 3) & 0x3e0))\n\t\tgoto out;\n\n\t/*\n\t * Check for a recognized chip id.\n\t * XXX INVASIVE!\n\t */\n\tbus_space_write_2(iot, ioh, BANK_SELECT_REG_W, 3);\n\ttmp = bus_space_read_2(iot, ioh, REVISION_REG_W);\n\tif (smc91cxx_idstrs[RR_ID(tmp)] == NULL)\n\t\tgoto out;\n\n\t/*\n\t * Assume we have an SMC91Cxx.\n\t */\n\tia->ia_iosize = SMC_IOSIZE;\n\trv = 1;\n\n out:\n\tbus_space_unmap(iot, ioh, SMC_IOSIZE);\n\treturn (rv);\n}",
    "includes": [
      "#include <dev/isa/isavar.h>",
      "#include <dev/ic/smc91cxxvar.h>",
      "#include <dev/ic/smc91cxxreg.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_media.h>",
      "#include <net/if_ether.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\tsm_isa_match"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "iot",
            "ioh",
            "SMC_IOSIZE"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RR_ID",
          "args": [
            "tmp"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "iot",
            "ioh",
            "REVISION_REG_W"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "BANK_SELECT_REG_W",
            "3"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "iot",
            "ioh",
            "BASE_ADDR_REG_W"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "BANK_SELECT_REG_W",
            "1"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "iot",
            "ioh",
            "BANK_SELECT_REG_W"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh",
            "BANK_SELECT_REG_W",
            "0"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "iot",
            "ioh",
            "BANK_SELECT_REG_W"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "iot",
            "ia->ia_iobase",
            "SMC_IOSIZE",
            "0",
            "&ioh"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/isa/isavar.h>\n#include <dev/ic/smc91cxxvar.h>\n#include <dev/ic/smc91cxxreg.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_ether.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint\tsm_isa_match;\n\nint\nsm_isa_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match, *aux;\n{\n\tstruct isa_attach_args *ia = aux;\n\tbus_space_tag_t iot = ia->ia_iot;\n\tbus_space_handle_t ioh;\n\tu_int16_t tmp;\n\tint rv = 0;\n\textern const char *smc91cxx_idstrs[];\n\n\t/* Disallow wildcarded values. */\n\tif (ia->ia_irq == -1)\n\t\treturn (0);\n\tif (ia->ia_iobase == -1)\n\t\treturn (0);\n\n\t/* Map i/o space. */\n\tif (bus_space_map(iot, ia->ia_iobase, SMC_IOSIZE, 0, &ioh))\n\t\treturn (0);\n\n\t/* Check that high byte of BANK_SELECT is what we expect. */\n\ttmp = bus_space_read_2(iot, ioh, BANK_SELECT_REG_W);\n\tif ((tmp & BSR_DETECT_MASK) != BSR_DETECT_VALUE)\n\t\tgoto out;\n\n\t/*\n\t * Switch to bank 0 and perform the test again.\n\t * XXX INVASIVE!\n\t */\n\tbus_space_write_2(iot, ioh, BANK_SELECT_REG_W, 0);\n\ttmp = bus_space_read_2(iot, ioh, BANK_SELECT_REG_W);\n\tif ((tmp & BSR_DETECT_MASK) != BSR_DETECT_VALUE)\n\t\tgoto out;\n\n\t/*\n\t * Switch to bank 1 and check the base address register.\n\t * XXX INVASIVE!\n\t */\n\tbus_space_write_2(iot, ioh, BANK_SELECT_REG_W, 1);\n\ttmp = bus_space_read_2(iot, ioh, BASE_ADDR_REG_W);\n\tif (ia->ia_iobase != ((tmp >> 3) & 0x3e0))\n\t\tgoto out;\n\n\t/*\n\t * Check for a recognized chip id.\n\t * XXX INVASIVE!\n\t */\n\tbus_space_write_2(iot, ioh, BANK_SELECT_REG_W, 3);\n\ttmp = bus_space_read_2(iot, ioh, REVISION_REG_W);\n\tif (smc91cxx_idstrs[RR_ID(tmp)] == NULL)\n\t\tgoto out;\n\n\t/*\n\t * Assume we have an SMC91Cxx.\n\t */\n\tia->ia_iosize = SMC_IOSIZE;\n\trv = 1;\n\n out:\n\tbus_space_unmap(iot, ioh, SMC_IOSIZE);\n\treturn (rv);\n}"
  }
]