[
  {
    "function_name": "eap_get_props",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
    "lines": "1906-1912",
    "snippet": "int\neap_get_props(addr)\n\tvoid *addr;\n{\n\treturn (AUDIO_PROP_MMAP | AUDIO_PROP_INDEPENDENT | \n                AUDIO_PROP_FULLDUPLEX);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/ac97.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\teap_get_props",
      "void *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\teap_get_props;\nvoid *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\neap_get_props(addr)\n\tvoid *addr;\n{\n\treturn (AUDIO_PROP_MMAP | AUDIO_PROP_INDEPENDENT | \n                AUDIO_PROP_FULLDUPLEX);\n}"
  },
  {
    "function_name": "eap_mappage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
    "lines": "1886-1904",
    "snippet": "int\neap_mappage(addr, mem, off, prot)\n\tvoid *addr;\n\tvoid *mem;\n\tint off;\n\tint prot;\n{\n\tstruct eap_softc *sc = addr;\n\tstruct eap_dma *p;\n\n\tif (off < 0)\n\t\treturn (-1);\n\tfor (p = sc->sc_dmas; p && KERNADDR(p) != mem; p = p->next)\n\t\t;\n\tif (!p)\n\t\treturn (-1);\n\treturn (bus_dmamem_mmap(sc->sc_dmatag, p->segs, p->nsegs, \n\t\t\t\toff, prot, BUS_DMA_WAITOK));\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/ac97.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\teap_mappage",
      "void *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_dmamem_mmap",
          "args": [
            "sc->sc_dmatag",
            "p->segs",
            "p->nsegs",
            "off",
            "prot",
            "BUS_DMA_WAITOK"
          ],
          "line": 1902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KERNADDR",
          "args": [
            "p"
          ],
          "line": 1898
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\teap_mappage;\nvoid *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\neap_mappage(addr, mem, off, prot)\n\tvoid *addr;\n\tvoid *mem;\n\tint off;\n\tint prot;\n{\n\tstruct eap_softc *sc = addr;\n\tstruct eap_dma *p;\n\n\tif (off < 0)\n\t\treturn (-1);\n\tfor (p = sc->sc_dmas; p && KERNADDR(p) != mem; p = p->next)\n\t\t;\n\tif (!p)\n\t\treturn (-1);\n\treturn (bus_dmamem_mmap(sc->sc_dmatag, p->segs, p->nsegs, \n\t\t\t\toff, prot, BUS_DMA_WAITOK));\n}"
  },
  {
    "function_name": "eap_round_buffersize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
    "lines": "1878-1884",
    "snippet": "u_long\neap_round_buffersize(addr, size)\n\tvoid *addr;\n\tu_long size;\n{\n\treturn (size);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/ac97.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "u_long\teap_round_buffersize",
      "void *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;",
      "u_long size;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_long\teap_round_buffersize;\nvoid *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;\nu_long size;\n\nu_long\neap_round_buffersize(addr, size)\n\tvoid *addr;\n\tu_long size;\n{\n\treturn (size);\n}"
  },
  {
    "function_name": "eap_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
    "lines": "1859-1876",
    "snippet": "void\neap_free(addr, ptr, pool)\n\tvoid *addr;\n\tvoid *ptr;\n\tint pool;\n{\n\tstruct eap_softc *sc = addr;\n\tstruct eap_dma **p;\n\n\tfor (p = &sc->sc_dmas; *p; p = &(*p)->next) {\n\t\tif (KERNADDR(*p) == ptr) {\n\t\t\teap_freemem(sc, *p);\n\t\t\t*p = (*p)->next;\n\t\t\tfree(*p, pool);\n\t\t\treturn;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/ac97.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\teap_freemem",
      "void\teap_free",
      "void *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "*p",
            "pool"
          ],
          "line": 1872
        },
        "resolved": true,
        "details": {
          "function_name": "eap_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
          "lines": "1859-1876",
          "snippet": "void\neap_free(addr, ptr, pool)\n\tvoid *addr;\n\tvoid *ptr;\n\tint pool;\n{\n\tstruct eap_softc *sc = addr;\n\tstruct eap_dma **p;\n\n\tfor (p = &sc->sc_dmas; *p; p = &(*p)->next) {\n\t\tif (KERNADDR(*p) == ptr) {\n\t\t\teap_freemem(sc, *p);\n\t\t\t*p = (*p)->next;\n\t\t\tfree(*p, pool);\n\t\t\treturn;\n\t\t}\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "eap_freemem",
          "args": [
            "sc",
            "*p"
          ],
          "line": 1870
        },
        "resolved": true,
        "details": {
          "function_name": "eap_freemem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
          "lines": "1050-1060",
          "snippet": "int\neap_freemem(sc, p)\n\tstruct eap_softc *sc;\n\tstruct eap_dma *p;\n{\n\tbus_dmamap_unload(sc->sc_dmatag, p->map);\n\tbus_dmamap_destroy(sc->sc_dmatag, p->map);\n\tbus_dmamem_unmap(sc->sc_dmatag, p->addr, p->size);\n\tbus_dmamem_free(sc->sc_dmatag, p->segs, p->nsegs);\n\treturn (0);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/ac97.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\teap_freemem",
            "void *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;",
            "u_long size;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\teap_freemem;\nvoid *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;\nu_long size;\n\nint\neap_freemem(sc, p)\n\tstruct eap_softc *sc;\n\tstruct eap_dma *p;\n{\n\tbus_dmamap_unload(sc->sc_dmatag, p->map);\n\tbus_dmamap_destroy(sc->sc_dmatag, p->map);\n\tbus_dmamem_unmap(sc->sc_dmatag, p->addr, p->size);\n\tbus_dmamem_free(sc->sc_dmatag, p->segs, p->nsegs);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KERNADDR",
          "args": [
            "*p"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\teap_freemem;\nvoid\teap_free;\nvoid *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nvoid\neap_free(addr, ptr, pool)\n\tvoid *addr;\n\tvoid *ptr;\n\tint pool;\n{\n\tstruct eap_softc *sc = addr;\n\tstruct eap_dma **p;\n\n\tfor (p = &sc->sc_dmas; *p; p = &(*p)->next) {\n\t\tif (KERNADDR(*p) == ptr) {\n\t\t\teap_freemem(sc, *p);\n\t\t\t*p = (*p)->next;\n\t\t\tfree(*p, pool);\n\t\t\treturn;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "eap_query_devinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
    "lines": "1696-1834",
    "snippet": "int\neap_query_devinfo(addr, dip)\n\tvoid *addr;\n\tmixer_devinfo_t *dip;\n{\n\tswitch (dip->index) {\n\tcase EAP_MASTER_VOL:\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->mixer_class = EAP_OUTPUT_CLASS;\n\t\tdip->prev = dip->next = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNmaster);\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\tcase EAP_VOICE_VOL:\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->mixer_class = EAP_INPUT_CLASS;\n\t\tdip->prev = AUDIO_MIXER_LAST;\n\t\tdip->next = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNdac);\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\tcase EAP_FM_VOL:\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->mixer_class = EAP_INPUT_CLASS;\n\t\tdip->prev = AUDIO_MIXER_LAST;\n\t\tdip->next = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNfmsynth);\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\tcase EAP_CD_VOL:\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->mixer_class = EAP_INPUT_CLASS;\n\t\tdip->prev = AUDIO_MIXER_LAST;\n\t\tdip->next = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNcd);\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\tcase EAP_LINE_VOL:\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->mixer_class = EAP_INPUT_CLASS;\n\t\tdip->prev = AUDIO_MIXER_LAST;\n\t\tdip->next = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNline);\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\tcase EAP_AUX_VOL:\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->mixer_class = EAP_INPUT_CLASS;\n\t\tdip->prev = AUDIO_MIXER_LAST;\n\t\tdip->next = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNaux);\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\tcase EAP_MIC_VOL:\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->mixer_class = EAP_INPUT_CLASS;\n\t\tdip->prev = AUDIO_MIXER_LAST;\n\t\tdip->next = EAP_MIC_PREAMP;\n\t\tstrcpy(dip->label.name, AudioNmicrophone);\n\t\tdip->un.v.num_channels = 1;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\tcase EAP_RECORD_SOURCE:\n\t\tdip->mixer_class = EAP_RECORD_CLASS;\n\t\tdip->prev = dip->next = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNsource);\n\t\tdip->type = AUDIO_MIXER_SET;\n\t\tdip->un.s.num_mem = 6;\n\t\tstrcpy(dip->un.s.member[0].label.name, AudioNmicrophone);\n\t\tdip->un.s.member[0].mask = 1 << EAP_MIC_VOL;\n\t\tstrcpy(dip->un.s.member[1].label.name, AudioNcd);\n\t\tdip->un.s.member[1].mask = 1 << EAP_CD_VOL;\n\t\tstrcpy(dip->un.s.member[2].label.name, AudioNline);\n\t\tdip->un.s.member[2].mask = 1 << EAP_LINE_VOL;\n\t\tstrcpy(dip->un.s.member[3].label.name, AudioNfmsynth);\n\t\tdip->un.s.member[3].mask = 1 << EAP_FM_VOL;\n\t\tstrcpy(dip->un.s.member[4].label.name, AudioNaux);\n\t\tdip->un.s.member[4].mask = 1 << EAP_AUX_VOL;\n\t\tstrcpy(dip->un.s.member[5].label.name, AudioNdac);\n\t\tdip->un.s.member[5].mask = 1 << EAP_VOICE_VOL;\n\t\treturn (0);\n\tcase EAP_OUTPUT_SELECT:\n\t\tdip->mixer_class = EAP_OUTPUT_CLASS;\n\t\tdip->prev = dip->next = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNselect);\n\t\tdip->type = AUDIO_MIXER_SET;\n\t\tdip->un.s.num_mem = 6;\n\t\tstrcpy(dip->un.s.member[0].label.name, AudioNmicrophone);\n\t\tdip->un.s.member[0].mask = 1 << EAP_MIC_VOL;\n\t\tstrcpy(dip->un.s.member[1].label.name, AudioNcd);\n\t\tdip->un.s.member[1].mask = 1 << EAP_CD_VOL;\n\t\tstrcpy(dip->un.s.member[2].label.name, AudioNline);\n\t\tdip->un.s.member[2].mask = 1 << EAP_LINE_VOL;\n\t\tstrcpy(dip->un.s.member[3].label.name, AudioNfmsynth);\n\t\tdip->un.s.member[3].mask = 1 << EAP_FM_VOL;\n\t\tstrcpy(dip->un.s.member[4].label.name, AudioNaux);\n\t\tdip->un.s.member[4].mask = 1 << EAP_AUX_VOL;\n\t\tstrcpy(dip->un.s.member[5].label.name, AudioNdac);\n\t\tdip->un.s.member[5].mask = 1 << EAP_VOICE_VOL;\n\t\treturn (0);\n\tcase EAP_MIC_PREAMP:\n\t\tdip->type = AUDIO_MIXER_ENUM;\n\t\tdip->mixer_class = EAP_INPUT_CLASS;\n\t\tdip->prev = EAP_MIC_VOL;\n\t\tdip->next = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNpreamp);\n\t\tdip->un.e.num_mem = 2;\n\t\tstrcpy(dip->un.e.member[0].label.name, AudioNoff);\n\t\tdip->un.e.member[0].ord = 0;\n\t\tstrcpy(dip->un.e.member[1].label.name, AudioNon);\n\t\tdip->un.e.member[1].ord = 1;\n\t\treturn (0);\n\tcase EAP_OUTPUT_CLASS:\n\t\tdip->type = AUDIO_MIXER_CLASS;\n\t\tdip->mixer_class = EAP_OUTPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioCoutputs);\n\t\treturn (0);\n\tcase EAP_RECORD_CLASS:\n\t\tdip->type = AUDIO_MIXER_CLASS;\n\t\tdip->mixer_class = EAP_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioCrecord);\n\t\treturn (0);\n\tcase EAP_INPUT_CLASS:\n\t\tdip->type = AUDIO_MIXER_CLASS;\n\t\tdip->mixer_class = EAP_INPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioCinputs);\n\t\treturn (0);\n\t}\n\treturn (ENXIO);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/ac97.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define EAP_INPUT_CLASS\t\t12",
      "#define EAP_RECORD_CLASS\t11",
      "#define EAP_OUTPUT_CLASS\t10",
      "#define\tEAP_MIC_PREAMP\t\t9",
      "#define EAP_OUTPUT_SELECT\t8",
      "#define\tEAP_RECORD_SOURCE \t7",
      "#define EAP_MIC_VOL\t\t6",
      "#define EAP_AUX_VOL\t\t5",
      "#define EAP_LINE_VOL\t\t4",
      "#define EAP_CD_VOL\t\t3",
      "#define EAP_FM_VOL\t\t2",
      "#define EAP_VOICE_VOL\t\t1",
      "#define EAP_MASTER_VOL\t\t0"
    ],
    "globals_used": [
      "int\teap_query_devinfo",
      "void *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioCinputs"
          ],
          "line": 1830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioCrecord"
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioCoutputs"
          ],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[1].label.name",
            "AudioNon"
          ],
          "line": 1811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[0].label.name",
            "AudioNoff"
          ],
          "line": 1809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNpreamp"
          ],
          "line": 1807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.s.member[5].label.name",
            "AudioNdac"
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.s.member[4].label.name",
            "AudioNaux"
          ],
          "line": 1797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.s.member[3].label.name",
            "AudioNfmsynth"
          ],
          "line": 1795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.s.member[2].label.name",
            "AudioNline"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.s.member[1].label.name",
            "AudioNcd"
          ],
          "line": 1791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.s.member[0].label.name",
            "AudioNmicrophone"
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNselect"
          ],
          "line": 1786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.s.member[5].label.name",
            "AudioNdac"
          ],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.s.member[4].label.name",
            "AudioNaux"
          ],
          "line": 1778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.s.member[3].label.name",
            "AudioNfmsynth"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.s.member[2].label.name",
            "AudioNline"
          ],
          "line": 1774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.s.member[1].label.name",
            "AudioNcd"
          ],
          "line": 1772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.s.member[0].label.name",
            "AudioNmicrophone"
          ],
          "line": 1770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNsource"
          ],
          "line": 1767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNmicrophone"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNaux"
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNline"
          ],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 1735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNcd"
          ],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNfmsynth"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNdac"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNmaster"
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define EAP_INPUT_CLASS\t\t12\n#define EAP_RECORD_CLASS\t11\n#define EAP_OUTPUT_CLASS\t10\n#define\tEAP_MIC_PREAMP\t\t9\n#define EAP_OUTPUT_SELECT\t8\n#define\tEAP_RECORD_SOURCE \t7\n#define EAP_MIC_VOL\t\t6\n#define EAP_AUX_VOL\t\t5\n#define EAP_LINE_VOL\t\t4\n#define EAP_CD_VOL\t\t3\n#define EAP_FM_VOL\t\t2\n#define EAP_VOICE_VOL\t\t1\n#define EAP_MASTER_VOL\t\t0\n\nint\teap_query_devinfo;\nvoid *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\neap_query_devinfo(addr, dip)\n\tvoid *addr;\n\tmixer_devinfo_t *dip;\n{\n\tswitch (dip->index) {\n\tcase EAP_MASTER_VOL:\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->mixer_class = EAP_OUTPUT_CLASS;\n\t\tdip->prev = dip->next = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNmaster);\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\tcase EAP_VOICE_VOL:\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->mixer_class = EAP_INPUT_CLASS;\n\t\tdip->prev = AUDIO_MIXER_LAST;\n\t\tdip->next = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNdac);\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\tcase EAP_FM_VOL:\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->mixer_class = EAP_INPUT_CLASS;\n\t\tdip->prev = AUDIO_MIXER_LAST;\n\t\tdip->next = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNfmsynth);\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\tcase EAP_CD_VOL:\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->mixer_class = EAP_INPUT_CLASS;\n\t\tdip->prev = AUDIO_MIXER_LAST;\n\t\tdip->next = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNcd);\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\tcase EAP_LINE_VOL:\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->mixer_class = EAP_INPUT_CLASS;\n\t\tdip->prev = AUDIO_MIXER_LAST;\n\t\tdip->next = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNline);\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\tcase EAP_AUX_VOL:\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->mixer_class = EAP_INPUT_CLASS;\n\t\tdip->prev = AUDIO_MIXER_LAST;\n\t\tdip->next = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNaux);\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\tcase EAP_MIC_VOL:\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->mixer_class = EAP_INPUT_CLASS;\n\t\tdip->prev = AUDIO_MIXER_LAST;\n\t\tdip->next = EAP_MIC_PREAMP;\n\t\tstrcpy(dip->label.name, AudioNmicrophone);\n\t\tdip->un.v.num_channels = 1;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\treturn (0);\n\tcase EAP_RECORD_SOURCE:\n\t\tdip->mixer_class = EAP_RECORD_CLASS;\n\t\tdip->prev = dip->next = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNsource);\n\t\tdip->type = AUDIO_MIXER_SET;\n\t\tdip->un.s.num_mem = 6;\n\t\tstrcpy(dip->un.s.member[0].label.name, AudioNmicrophone);\n\t\tdip->un.s.member[0].mask = 1 << EAP_MIC_VOL;\n\t\tstrcpy(dip->un.s.member[1].label.name, AudioNcd);\n\t\tdip->un.s.member[1].mask = 1 << EAP_CD_VOL;\n\t\tstrcpy(dip->un.s.member[2].label.name, AudioNline);\n\t\tdip->un.s.member[2].mask = 1 << EAP_LINE_VOL;\n\t\tstrcpy(dip->un.s.member[3].label.name, AudioNfmsynth);\n\t\tdip->un.s.member[3].mask = 1 << EAP_FM_VOL;\n\t\tstrcpy(dip->un.s.member[4].label.name, AudioNaux);\n\t\tdip->un.s.member[4].mask = 1 << EAP_AUX_VOL;\n\t\tstrcpy(dip->un.s.member[5].label.name, AudioNdac);\n\t\tdip->un.s.member[5].mask = 1 << EAP_VOICE_VOL;\n\t\treturn (0);\n\tcase EAP_OUTPUT_SELECT:\n\t\tdip->mixer_class = EAP_OUTPUT_CLASS;\n\t\tdip->prev = dip->next = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNselect);\n\t\tdip->type = AUDIO_MIXER_SET;\n\t\tdip->un.s.num_mem = 6;\n\t\tstrcpy(dip->un.s.member[0].label.name, AudioNmicrophone);\n\t\tdip->un.s.member[0].mask = 1 << EAP_MIC_VOL;\n\t\tstrcpy(dip->un.s.member[1].label.name, AudioNcd);\n\t\tdip->un.s.member[1].mask = 1 << EAP_CD_VOL;\n\t\tstrcpy(dip->un.s.member[2].label.name, AudioNline);\n\t\tdip->un.s.member[2].mask = 1 << EAP_LINE_VOL;\n\t\tstrcpy(dip->un.s.member[3].label.name, AudioNfmsynth);\n\t\tdip->un.s.member[3].mask = 1 << EAP_FM_VOL;\n\t\tstrcpy(dip->un.s.member[4].label.name, AudioNaux);\n\t\tdip->un.s.member[4].mask = 1 << EAP_AUX_VOL;\n\t\tstrcpy(dip->un.s.member[5].label.name, AudioNdac);\n\t\tdip->un.s.member[5].mask = 1 << EAP_VOICE_VOL;\n\t\treturn (0);\n\tcase EAP_MIC_PREAMP:\n\t\tdip->type = AUDIO_MIXER_ENUM;\n\t\tdip->mixer_class = EAP_INPUT_CLASS;\n\t\tdip->prev = EAP_MIC_VOL;\n\t\tdip->next = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNpreamp);\n\t\tdip->un.e.num_mem = 2;\n\t\tstrcpy(dip->un.e.member[0].label.name, AudioNoff);\n\t\tdip->un.e.member[0].ord = 0;\n\t\tstrcpy(dip->un.e.member[1].label.name, AudioNon);\n\t\tdip->un.e.member[1].ord = 1;\n\t\treturn (0);\n\tcase EAP_OUTPUT_CLASS:\n\t\tdip->type = AUDIO_MIXER_CLASS;\n\t\tdip->mixer_class = EAP_OUTPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioCoutputs);\n\t\treturn (0);\n\tcase EAP_RECORD_CLASS:\n\t\tdip->type = AUDIO_MIXER_CLASS;\n\t\tdip->mixer_class = EAP_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioCrecord);\n\t\treturn (0);\n\tcase EAP_INPUT_CLASS:\n\t\tdip->type = AUDIO_MIXER_CLASS;\n\t\tdip->mixer_class = EAP_INPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioCinputs);\n\t\treturn (0);\n\t}\n\treturn (ENXIO);\n}"
  },
  {
    "function_name": "eap_mixer_get_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
    "lines": "1627-1694",
    "snippet": "int\neap_mixer_get_port(addr, cp)\n\tvoid *addr;\n\tmixer_ctrl_t *cp;\n{\n\tstruct eap_softc *sc = addr;\n\tint la, ra, l, r;\n\n\tswitch (cp->dev) {\n\tcase EAP_RECORD_SOURCE:\n\t\tif (cp->type != AUDIO_MIXER_SET)\n\t\t\treturn (EINVAL);\n\t\tcp->un.mask = sc->sc_record_source;\n\t\treturn (0);\n\tcase EAP_OUTPUT_SELECT:\n\t\tif (cp->type != AUDIO_MIXER_SET)\n\t\t\treturn (EINVAL);\n\t\tcp->un.mask = sc->sc_output_source;\n\t\treturn (0);\n\tcase EAP_MIC_PREAMP:\n\t\tif (cp->type != AUDIO_MIXER_ENUM)\n\t\t\treturn (EINVAL);\n\t\tcp->un.ord = sc->sc_mic_preamp;\n\t\treturn (0);\n\tcase EAP_MASTER_VOL:\n\t\tl = ATT5_TO_VOL(sc->sc_port[AK_MASTER_L]);\n\t\tr = ATT5_TO_VOL(sc->sc_port[AK_MASTER_R]);\n\t\tbreak;\n\tcase EAP_MIC_VOL:\n\t\tif (cp->un.value.num_channels != 1)\n\t\t\treturn (EINVAL);\n\t\tla = ra = AK_MIC;\n\t\tgoto lr;\n\tcase EAP_VOICE_VOL:\n\t\tla = AK_VOICE_L;\n\t\tra = AK_VOICE_R;\n\t\tgoto lr;\n\tcase EAP_FM_VOL:\n\t\tla = AK_FM_L;\n\t\tra = AK_FM_R;\n\t\tgoto lr;\n\tcase EAP_CD_VOL:\n\t\tla = AK_CD_L;\n\t\tra = AK_CD_R;\n\t\tgoto lr;\n\tcase EAP_LINE_VOL:\n\t\tla = AK_LINE_L;\n\t\tra = AK_LINE_R;\n\t\tgoto lr;\n\tcase EAP_AUX_VOL:\n\t\tla = AK_AUX_L;\n\t\tra = AK_AUX_R;\n\tlr:\n\t\tl = GAIN5_TO_VOL(sc->sc_port[la]);\n\t\tr = GAIN5_TO_VOL(sc->sc_port[ra]);\n\t\tbreak;\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\tif (cp->un.value.num_channels == 1)\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = (l+r) / 2;\n\telse if (cp->un.value.num_channels == 2) {\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_LEFT]  = l;\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = r;\n\t} else\n\t\treturn (EINVAL);\n\treturn (0);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/ac97.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tEAP_MIC_PREAMP\t\t9",
      "#define EAP_OUTPUT_SELECT\t8",
      "#define\tEAP_RECORD_SOURCE \t7",
      "#define EAP_MIC_VOL\t\t6",
      "#define EAP_AUX_VOL\t\t5",
      "#define EAP_LINE_VOL\t\t4",
      "#define EAP_CD_VOL\t\t3",
      "#define EAP_FM_VOL\t\t2",
      "#define EAP_VOICE_VOL\t\t1",
      "#define EAP_MASTER_VOL\t\t0",
      "#define AK_MIC\t\t\t0x0e",
      "#define AK_AUX_R\t\t0x0b",
      "#define AK_AUX_L\t\t0x0a",
      "#define AK_LINE_R\t\t0x09",
      "#define AK_LINE_L\t\t0x08",
      "#define AK_CD_R\t\t\t0x07",
      "#define AK_CD_L\t\t\t0x06",
      "#define AK_FM_R\t\t\t0x05",
      "#define AK_FM_L\t\t\t0x04",
      "#define AK_VOICE_R\t\t0x03",
      "#define AK_VOICE_L\t\t0x02",
      "#define AK_MASTER_R\t\t0x01",
      "#define AK_MASTER_L\t\t0x00"
    ],
    "globals_used": [
      "int\teap_mixer_get_port",
      "void *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GAIN5_TO_VOL",
          "args": [
            "sc->sc_port[ra]"
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GAIN5_TO_VOL",
          "args": [
            "sc->sc_port[la]"
          ],
          "line": 1680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ATT5_TO_VOL",
          "args": [
            "sc->sc_port[AK_MASTER_R]"
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ATT5_TO_VOL",
          "args": [
            "sc->sc_port[AK_MASTER_L]"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tEAP_MIC_PREAMP\t\t9\n#define EAP_OUTPUT_SELECT\t8\n#define\tEAP_RECORD_SOURCE \t7\n#define EAP_MIC_VOL\t\t6\n#define EAP_AUX_VOL\t\t5\n#define EAP_LINE_VOL\t\t4\n#define EAP_CD_VOL\t\t3\n#define EAP_FM_VOL\t\t2\n#define EAP_VOICE_VOL\t\t1\n#define EAP_MASTER_VOL\t\t0\n#define AK_MIC\t\t\t0x0e\n#define AK_AUX_R\t\t0x0b\n#define AK_AUX_L\t\t0x0a\n#define AK_LINE_R\t\t0x09\n#define AK_LINE_L\t\t0x08\n#define AK_CD_R\t\t\t0x07\n#define AK_CD_L\t\t\t0x06\n#define AK_FM_R\t\t\t0x05\n#define AK_FM_L\t\t\t0x04\n#define AK_VOICE_R\t\t0x03\n#define AK_VOICE_L\t\t0x02\n#define AK_MASTER_R\t\t0x01\n#define AK_MASTER_L\t\t0x00\n\nint\teap_mixer_get_port;\nvoid *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\neap_mixer_get_port(addr, cp)\n\tvoid *addr;\n\tmixer_ctrl_t *cp;\n{\n\tstruct eap_softc *sc = addr;\n\tint la, ra, l, r;\n\n\tswitch (cp->dev) {\n\tcase EAP_RECORD_SOURCE:\n\t\tif (cp->type != AUDIO_MIXER_SET)\n\t\t\treturn (EINVAL);\n\t\tcp->un.mask = sc->sc_record_source;\n\t\treturn (0);\n\tcase EAP_OUTPUT_SELECT:\n\t\tif (cp->type != AUDIO_MIXER_SET)\n\t\t\treturn (EINVAL);\n\t\tcp->un.mask = sc->sc_output_source;\n\t\treturn (0);\n\tcase EAP_MIC_PREAMP:\n\t\tif (cp->type != AUDIO_MIXER_ENUM)\n\t\t\treturn (EINVAL);\n\t\tcp->un.ord = sc->sc_mic_preamp;\n\t\treturn (0);\n\tcase EAP_MASTER_VOL:\n\t\tl = ATT5_TO_VOL(sc->sc_port[AK_MASTER_L]);\n\t\tr = ATT5_TO_VOL(sc->sc_port[AK_MASTER_R]);\n\t\tbreak;\n\tcase EAP_MIC_VOL:\n\t\tif (cp->un.value.num_channels != 1)\n\t\t\treturn (EINVAL);\n\t\tla = ra = AK_MIC;\n\t\tgoto lr;\n\tcase EAP_VOICE_VOL:\n\t\tla = AK_VOICE_L;\n\t\tra = AK_VOICE_R;\n\t\tgoto lr;\n\tcase EAP_FM_VOL:\n\t\tla = AK_FM_L;\n\t\tra = AK_FM_R;\n\t\tgoto lr;\n\tcase EAP_CD_VOL:\n\t\tla = AK_CD_L;\n\t\tra = AK_CD_R;\n\t\tgoto lr;\n\tcase EAP_LINE_VOL:\n\t\tla = AK_LINE_L;\n\t\tra = AK_LINE_R;\n\t\tgoto lr;\n\tcase EAP_AUX_VOL:\n\t\tla = AK_AUX_L;\n\t\tra = AK_AUX_R;\n\tlr:\n\t\tl = GAIN5_TO_VOL(sc->sc_port[la]);\n\t\tr = GAIN5_TO_VOL(sc->sc_port[ra]);\n\t\tbreak;\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\tif (cp->un.value.num_channels == 1)\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = (l+r) / 2;\n\telse if (cp->un.value.num_channels == 2) {\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_LEFT]  = l;\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = r;\n\t} else\n\t\treturn (EINVAL);\n\treturn (0);\n}"
  },
  {
    "function_name": "eap_mixer_set_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
    "lines": "1510-1625",
    "snippet": "int\neap_mixer_set_port(addr, cp)\n\tvoid *addr;\n\tmixer_ctrl_t *cp;\n{\n\tstruct eap_softc *sc = addr;\n\tint lval, rval, l, r, la, ra;\n\tint l1, r1, l2, r2, m, o1, o2;\n\n\tif (cp->dev == EAP_RECORD_SOURCE) {\n\t\tif (cp->type != AUDIO_MIXER_SET)\n\t\t\treturn (EINVAL);\n\t\tm = sc->sc_record_source = cp->un.mask;\n\t\tl1 = l2 = r1 = r2 = 0;\n\t\tif (m & (1 << EAP_VOICE_VOL)) \n\t\t\tl2 |= AK_M_VOICE, r2 |= AK_M_VOICE;\n\t\tif (m & (1 << EAP_FM_VOL)) \n\t\t\tl1 |= AK_M_FM_L, r1 |= AK_M_FM_R;\n\t\tif (m & (1 << EAP_CD_VOL)) \n\t\t\tl1 |= AK_M_CD_L, r1 |= AK_M_CD_R;\n\t\tif (m & (1 << EAP_LINE_VOL)) \n\t\t\tl1 |= AK_M_LINE_L, r1 |= AK_M_LINE_R;\n\t\tif (m & (1 << EAP_AUX_VOL)) \n\t\t\tl2 |= AK_M2_AUX_L, r2 |= AK_M2_AUX_R;\n\t\tif (m & (1 << EAP_MIC_VOL)) \n\t\t\tl2 |= AK_M_TMIC, r2 |= AK_M_TMIC;\n\t\teap_set_mixer(sc, AK_IN_MIXER1_L, l1);\t\t\n\t\teap_set_mixer(sc, AK_IN_MIXER1_R, r1);\n\t\teap_set_mixer(sc, AK_IN_MIXER2_L, l2);\n\t\teap_set_mixer(sc, AK_IN_MIXER2_R, r2);\n\t\treturn (0);\n\t}\n\tif (cp->dev == EAP_OUTPUT_SELECT) {\n\t\tif (cp->type != AUDIO_MIXER_SET)\n\t\t\treturn (EINVAL);\n\t\tm = sc->sc_output_source = cp->un.mask;\n\t\to1 = o2 = 0;\n\t\tif (m & (1 << EAP_VOICE_VOL)) \n\t\t\to2 |= AK_M_VOICE_L | AK_M_VOICE_R;\n\t\tif (m & (1 << EAP_FM_VOL)) \n\t\t\to1 |= AK_M_FM_L | AK_M_FM_R;\n\t\tif (m & (1 << EAP_CD_VOL)) \n\t\t\to1 |= AK_M_CD_L | AK_M_CD_R;\n\t\tif (m & (1 << EAP_LINE_VOL)) \n\t\t\to1 |= AK_M_LINE_L | AK_M_LINE_R;\n\t\tif (m & (1 << EAP_AUX_VOL)) \n\t\t\to2 |= AK_M_AUX_L | AK_M_AUX_R;\n\t\tif (m & (1 << EAP_MIC_VOL)) \n\t\t\to1 |= AK_M_MIC;\n\t\teap_set_mixer(sc, AK_OUT_MIXER1, o1);\n\t\teap_set_mixer(sc, AK_OUT_MIXER2, o2);\n\t\treturn (0);\n\t}\n\tif (cp->dev == EAP_MIC_PREAMP) {\n\t\tif (cp->type != AUDIO_MIXER_ENUM)\n\t\t\treturn (EINVAL);\n\t\tif (cp->un.ord != 0 && cp->un.ord != 1)\n\t\t\treturn (EINVAL);\n\t\tsc->sc_mic_preamp = cp->un.ord;\n\t\teap_set_mixer(sc, AK_MGAIN, cp->un.ord);\n\t\treturn (0);\n\t}\n\tif (cp->type != AUDIO_MIXER_VALUE)\n\t\treturn (EINVAL);\n\tif (cp->un.value.num_channels == 1)\n\t\tlval = rval = cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];\n\telse if (cp->un.value.num_channels == 2) {\n\t\tlval = cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];\n\t\trval = cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];\n\t} else\n\t\treturn (EINVAL);\n\tra = -1;\n\tswitch (cp->dev) {\n\tcase EAP_MASTER_VOL:\n\t\tl = VOL_TO_ATT5(lval);\n\t\tr = VOL_TO_ATT5(rval);\n\t\tla = AK_MASTER_L;\n\t\tra = AK_MASTER_R;\n\t\tbreak;\n\tcase EAP_MIC_VOL:\n\t\tif (cp->un.value.num_channels != 1)\n\t\t\treturn (EINVAL);\n\t\tla = AK_MIC;\n\t\tgoto lr;\n\tcase EAP_VOICE_VOL:\n\t\tla = AK_VOICE_L;\n\t\tra = AK_VOICE_R;\n\t\tgoto lr;\n\tcase EAP_FM_VOL:\n\t\tla = AK_FM_L;\n\t\tra = AK_FM_R;\n\t\tgoto lr;\n\tcase EAP_CD_VOL:\n\t\tla = AK_CD_L;\n\t\tra = AK_CD_R;\n\t\tgoto lr;\n\tcase EAP_LINE_VOL:\n\t\tla = AK_LINE_L;\n\t\tra = AK_LINE_R;\n\t\tgoto lr;\n\tcase EAP_AUX_VOL:\n\t\tla = AK_AUX_L;\n\t\tra = AK_AUX_R;\n\tlr:\n\t\tl = VOL_TO_GAIN5(lval);\n\t\tr = VOL_TO_GAIN5(rval);\n\t\tbreak;\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\teap_set_mixer(sc, la, l);\n\tif (ra >= 0) {\n\t\teap_set_mixer(sc, ra, r);\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/ac97.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tEAP_MIC_PREAMP\t\t9",
      "#define EAP_OUTPUT_SELECT\t8",
      "#define\tEAP_RECORD_SOURCE \t7",
      "#define EAP_MIC_VOL\t\t6",
      "#define EAP_AUX_VOL\t\t5",
      "#define EAP_LINE_VOL\t\t4",
      "#define EAP_CD_VOL\t\t3",
      "#define EAP_FM_VOL\t\t2",
      "#define EAP_VOICE_VOL\t\t1",
      "#define EAP_MASTER_VOL\t\t0",
      "#define AK_MGAIN\t\t0x19",
      "#define  AK_M_VOICE\t\t0x04",
      "#define  AK_M2_AUX_R\t\t0x08",
      "#define  AK_M2_AUX_L\t\t0x10",
      "#define  AK_M_TMIC\t\t0x80",
      "#define AK_IN_MIXER2_R\t\t0x15",
      "#define AK_IN_MIXER2_L\t\t0x14",
      "#define AK_IN_MIXER1_R\t\t0x13",
      "#define AK_IN_MIXER1_L\t\t0x12",
      "#define  AK_M_VOICE_R\t\t0x04",
      "#define  AK_M_VOICE_L\t\t0x08",
      "#define  AK_M_AUX_R\t\t0x10",
      "#define  AK_M_AUX_L\t\t0x20",
      "#define AK_OUT_MIXER2\t\t0x11",
      "#define  AK_M_MIC\t\t0x01",
      "#define  AK_M_CD_R\t\t0x02",
      "#define  AK_M_CD_L\t\t0x04",
      "#define  AK_M_LINE_R\t\t0x08",
      "#define  AK_M_LINE_L\t\t0x10",
      "#define  AK_M_FM_R\t\t0x20",
      "#define  AK_M_FM_L\t\t0x40",
      "#define AK_OUT_MIXER1\t\t0x10",
      "#define AK_MIC\t\t\t0x0e",
      "#define AK_AUX_R\t\t0x0b",
      "#define AK_AUX_L\t\t0x0a",
      "#define AK_LINE_R\t\t0x09",
      "#define AK_LINE_L\t\t0x08",
      "#define AK_CD_R\t\t\t0x07",
      "#define AK_CD_L\t\t\t0x06",
      "#define AK_FM_R\t\t\t0x05",
      "#define AK_FM_L\t\t\t0x04",
      "#define AK_VOICE_R\t\t0x03",
      "#define AK_VOICE_L\t\t0x02",
      "#define AK_MASTER_R\t\t0x01",
      "#define AK_MASTER_L\t\t0x00"
    ],
    "globals_used": [
      "int\teap_mixer_set_port",
      "void\teap_set_mixer",
      "void *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eap_set_mixer",
          "args": [
            "sc",
            "ra",
            "r"
          ],
          "line": 1622
        },
        "resolved": true,
        "details": {
          "function_name": "eap_set_mixer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
          "lines": "1499-1508",
          "snippet": "void\neap_set_mixer(sc, a, d)\n\tstruct eap_softc *sc;\n\tint a, d;\n{\n\teap_write_codec(sc, a, d);\n\n        sc->sc_port[a] = d;\n        DPRINTFN(1, (\"eap_mixer_set_port port 0x%02x = 0x%02x\\n\", a, d));\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/ac97.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void    eap_write_codec",
            "int\teap_mixer_set_port",
            "void\teap_set_mixer"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid    eap_write_codec;\nint\teap_mixer_set_port;\nvoid\teap_set_mixer;\n\nvoid\neap_set_mixer(sc, a, d)\n\tstruct eap_softc *sc;\n\tint a, d;\n{\n\teap_write_codec(sc, a, d);\n\n        sc->sc_port[a] = d;\n        DPRINTFN(1, (\"eap_mixer_set_port port 0x%02x = 0x%02x\\n\", a, d));\n}"
        }
      },
      {
        "call_info": {
          "callee": "VOL_TO_GAIN5",
          "args": [
            "rval"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VOL_TO_GAIN5",
          "args": [
            "lval"
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VOL_TO_ATT5",
          "args": [
            "rval"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VOL_TO_ATT5",
          "args": [
            "lval"
          ],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tEAP_MIC_PREAMP\t\t9\n#define EAP_OUTPUT_SELECT\t8\n#define\tEAP_RECORD_SOURCE \t7\n#define EAP_MIC_VOL\t\t6\n#define EAP_AUX_VOL\t\t5\n#define EAP_LINE_VOL\t\t4\n#define EAP_CD_VOL\t\t3\n#define EAP_FM_VOL\t\t2\n#define EAP_VOICE_VOL\t\t1\n#define EAP_MASTER_VOL\t\t0\n#define AK_MGAIN\t\t0x19\n#define  AK_M_VOICE\t\t0x04\n#define  AK_M2_AUX_R\t\t0x08\n#define  AK_M2_AUX_L\t\t0x10\n#define  AK_M_TMIC\t\t0x80\n#define AK_IN_MIXER2_R\t\t0x15\n#define AK_IN_MIXER2_L\t\t0x14\n#define AK_IN_MIXER1_R\t\t0x13\n#define AK_IN_MIXER1_L\t\t0x12\n#define  AK_M_VOICE_R\t\t0x04\n#define  AK_M_VOICE_L\t\t0x08\n#define  AK_M_AUX_R\t\t0x10\n#define  AK_M_AUX_L\t\t0x20\n#define AK_OUT_MIXER2\t\t0x11\n#define  AK_M_MIC\t\t0x01\n#define  AK_M_CD_R\t\t0x02\n#define  AK_M_CD_L\t\t0x04\n#define  AK_M_LINE_R\t\t0x08\n#define  AK_M_LINE_L\t\t0x10\n#define  AK_M_FM_R\t\t0x20\n#define  AK_M_FM_L\t\t0x40\n#define AK_OUT_MIXER1\t\t0x10\n#define AK_MIC\t\t\t0x0e\n#define AK_AUX_R\t\t0x0b\n#define AK_AUX_L\t\t0x0a\n#define AK_LINE_R\t\t0x09\n#define AK_LINE_L\t\t0x08\n#define AK_CD_R\t\t\t0x07\n#define AK_CD_L\t\t\t0x06\n#define AK_FM_R\t\t\t0x05\n#define AK_FM_L\t\t\t0x04\n#define AK_VOICE_R\t\t0x03\n#define AK_VOICE_L\t\t0x02\n#define AK_MASTER_R\t\t0x01\n#define AK_MASTER_L\t\t0x00\n\nint\teap_mixer_set_port;\nvoid\teap_set_mixer;\nvoid *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\neap_mixer_set_port(addr, cp)\n\tvoid *addr;\n\tmixer_ctrl_t *cp;\n{\n\tstruct eap_softc *sc = addr;\n\tint lval, rval, l, r, la, ra;\n\tint l1, r1, l2, r2, m, o1, o2;\n\n\tif (cp->dev == EAP_RECORD_SOURCE) {\n\t\tif (cp->type != AUDIO_MIXER_SET)\n\t\t\treturn (EINVAL);\n\t\tm = sc->sc_record_source = cp->un.mask;\n\t\tl1 = l2 = r1 = r2 = 0;\n\t\tif (m & (1 << EAP_VOICE_VOL)) \n\t\t\tl2 |= AK_M_VOICE, r2 |= AK_M_VOICE;\n\t\tif (m & (1 << EAP_FM_VOL)) \n\t\t\tl1 |= AK_M_FM_L, r1 |= AK_M_FM_R;\n\t\tif (m & (1 << EAP_CD_VOL)) \n\t\t\tl1 |= AK_M_CD_L, r1 |= AK_M_CD_R;\n\t\tif (m & (1 << EAP_LINE_VOL)) \n\t\t\tl1 |= AK_M_LINE_L, r1 |= AK_M_LINE_R;\n\t\tif (m & (1 << EAP_AUX_VOL)) \n\t\t\tl2 |= AK_M2_AUX_L, r2 |= AK_M2_AUX_R;\n\t\tif (m & (1 << EAP_MIC_VOL)) \n\t\t\tl2 |= AK_M_TMIC, r2 |= AK_M_TMIC;\n\t\teap_set_mixer(sc, AK_IN_MIXER1_L, l1);\t\t\n\t\teap_set_mixer(sc, AK_IN_MIXER1_R, r1);\n\t\teap_set_mixer(sc, AK_IN_MIXER2_L, l2);\n\t\teap_set_mixer(sc, AK_IN_MIXER2_R, r2);\n\t\treturn (0);\n\t}\n\tif (cp->dev == EAP_OUTPUT_SELECT) {\n\t\tif (cp->type != AUDIO_MIXER_SET)\n\t\t\treturn (EINVAL);\n\t\tm = sc->sc_output_source = cp->un.mask;\n\t\to1 = o2 = 0;\n\t\tif (m & (1 << EAP_VOICE_VOL)) \n\t\t\to2 |= AK_M_VOICE_L | AK_M_VOICE_R;\n\t\tif (m & (1 << EAP_FM_VOL)) \n\t\t\to1 |= AK_M_FM_L | AK_M_FM_R;\n\t\tif (m & (1 << EAP_CD_VOL)) \n\t\t\to1 |= AK_M_CD_L | AK_M_CD_R;\n\t\tif (m & (1 << EAP_LINE_VOL)) \n\t\t\to1 |= AK_M_LINE_L | AK_M_LINE_R;\n\t\tif (m & (1 << EAP_AUX_VOL)) \n\t\t\to2 |= AK_M_AUX_L | AK_M_AUX_R;\n\t\tif (m & (1 << EAP_MIC_VOL)) \n\t\t\to1 |= AK_M_MIC;\n\t\teap_set_mixer(sc, AK_OUT_MIXER1, o1);\n\t\teap_set_mixer(sc, AK_OUT_MIXER2, o2);\n\t\treturn (0);\n\t}\n\tif (cp->dev == EAP_MIC_PREAMP) {\n\t\tif (cp->type != AUDIO_MIXER_ENUM)\n\t\t\treturn (EINVAL);\n\t\tif (cp->un.ord != 0 && cp->un.ord != 1)\n\t\t\treturn (EINVAL);\n\t\tsc->sc_mic_preamp = cp->un.ord;\n\t\teap_set_mixer(sc, AK_MGAIN, cp->un.ord);\n\t\treturn (0);\n\t}\n\tif (cp->type != AUDIO_MIXER_VALUE)\n\t\treturn (EINVAL);\n\tif (cp->un.value.num_channels == 1)\n\t\tlval = rval = cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];\n\telse if (cp->un.value.num_channels == 2) {\n\t\tlval = cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];\n\t\trval = cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];\n\t} else\n\t\treturn (EINVAL);\n\tra = -1;\n\tswitch (cp->dev) {\n\tcase EAP_MASTER_VOL:\n\t\tl = VOL_TO_ATT5(lval);\n\t\tr = VOL_TO_ATT5(rval);\n\t\tla = AK_MASTER_L;\n\t\tra = AK_MASTER_R;\n\t\tbreak;\n\tcase EAP_MIC_VOL:\n\t\tif (cp->un.value.num_channels != 1)\n\t\t\treturn (EINVAL);\n\t\tla = AK_MIC;\n\t\tgoto lr;\n\tcase EAP_VOICE_VOL:\n\t\tla = AK_VOICE_L;\n\t\tra = AK_VOICE_R;\n\t\tgoto lr;\n\tcase EAP_FM_VOL:\n\t\tla = AK_FM_L;\n\t\tra = AK_FM_R;\n\t\tgoto lr;\n\tcase EAP_CD_VOL:\n\t\tla = AK_CD_L;\n\t\tra = AK_CD_R;\n\t\tgoto lr;\n\tcase EAP_LINE_VOL:\n\t\tla = AK_LINE_L;\n\t\tra = AK_LINE_R;\n\t\tgoto lr;\n\tcase EAP_AUX_VOL:\n\t\tla = AK_AUX_L;\n\t\tra = AK_AUX_R;\n\tlr:\n\t\tl = VOL_TO_GAIN5(lval);\n\t\tr = VOL_TO_GAIN5(rval);\n\t\tbreak;\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\teap_set_mixer(sc, la, l);\n\tif (ra >= 0) {\n\t\teap_set_mixer(sc, ra, r);\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "eap_set_mixer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
    "lines": "1499-1508",
    "snippet": "void\neap_set_mixer(sc, a, d)\n\tstruct eap_softc *sc;\n\tint a, d;\n{\n\teap_write_codec(sc, a, d);\n\n        sc->sc_port[a] = d;\n        DPRINTFN(1, (\"eap_mixer_set_port port 0x%02x = 0x%02x\\n\", a, d));\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/ac97.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void    eap_write_codec",
      "int\teap_mixer_set_port",
      "void\teap_set_mixer"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"eap_mixer_set_port port 0x%02x = 0x%02x\\n\", a, d)"
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eap_write_codec",
          "args": [
            "sc",
            "a",
            "d"
          ],
          "line": 1504
        },
        "resolved": true,
        "details": {
          "function_name": "eap_write_codec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
          "lines": "488-506",
          "snippet": "void\neap_write_codec(sc, a, d)\n\tstruct eap_softc *sc;\n\tint a, d;\n{\n\n\tint icss, to;\n\t\n\tto = EAP_WRITE_TIMEOUT;\n\tdo {\n\t\ticss = EREAD4(sc, EAP_ICSS);\n\t\tDPRINTFN(5,(\"eap: codec %d prog: icss=0x%08x\\n\", a, icss));\n                if (!to--) {\n                        printf(\"eap: timeout writing to codec\\n\");\n                        return;\n                }\n\t} while (icss & EAP_CWRIP);  /* XXX could use CSTAT here */\n        EWRITE4(sc, EAP_CODEC, EAP_SET_CODEC(a, d));\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/ac97.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define EAP_WRITE_TIMEOUT\t0x1000",
            "#define EAP_CODEC\t\t0x10",
            "#define  EAP_CWRIP\t\t0x00000100",
            "#define EAP_ICSS\t\t0x04\t/* interrupt / chip select status */"
          ],
          "globals_used": [
            "void    eap_write_codec"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define EAP_WRITE_TIMEOUT\t0x1000\n#define EAP_CODEC\t\t0x10\n#define  EAP_CWRIP\t\t0x00000100\n#define EAP_ICSS\t\t0x04\t/* interrupt / chip select status */\n\nvoid    eap_write_codec;\n\nvoid\neap_write_codec(sc, a, d)\n\tstruct eap_softc *sc;\n\tint a, d;\n{\n\n\tint icss, to;\n\t\n\tto = EAP_WRITE_TIMEOUT;\n\tdo {\n\t\ticss = EREAD4(sc, EAP_ICSS);\n\t\tDPRINTFN(5,(\"eap: codec %d prog: icss=0x%08x\\n\", a, icss));\n                if (!to--) {\n                        printf(\"eap: timeout writing to codec\\n\");\n                        return;\n                }\n\t} while (icss & EAP_CWRIP);  /* XXX could use CSTAT here */\n        EWRITE4(sc, EAP_CODEC, EAP_SET_CODEC(a, d));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid    eap_write_codec;\nint\teap_mixer_set_port;\nvoid\teap_set_mixer;\n\nvoid\neap_set_mixer(sc, a, d)\n\tstruct eap_softc *sc;\n\tint a, d;\n{\n\teap_write_codec(sc, a, d);\n\n        sc->sc_port[a] = d;\n        DPRINTFN(1, (\"eap_mixer_set_port port 0x%02x = 0x%02x\\n\", a, d));\n}"
  },
  {
    "function_name": "eap1371_get_portnum_by_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
    "lines": "1490-1497",
    "snippet": "int\neap1371_get_portnum_by_name(sc, class, device, qualifier)\n\tstruct eap_softc *sc;\n\tchar *class, *device, *qualifier;\n{\n\treturn ((sc->codec_if->vtbl->get_portnum_by_name)(sc->codec_if, class,\n             device, qualifier));\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/ac97.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int     eap1371_get_portnum_by_name"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc->codec_if",
            "class",
            "device",
            "qualifier"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint     eap1371_get_portnum_by_name;\n\nint\neap1371_get_portnum_by_name(sc, class, device, qualifier)\n\tstruct eap_softc *sc;\n\tchar *class, *device, *qualifier;\n{\n\treturn ((sc->codec_if->vtbl->get_portnum_by_name)(sc->codec_if, class,\n             device, qualifier));\n}"
  },
  {
    "function_name": "eap1371_query_devinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
    "lines": "1480-1488",
    "snippet": "int\neap1371_query_devinfo(addr, dip)\n\tvoid *addr;\n\tmixer_devinfo_t *dip;\n{\n\tstruct eap_softc *sc = addr;\n\n\treturn ((sc->codec_if->vtbl->query_devinfo)(sc->codec_if, dip));\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/ac97.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\teap1371_query_devinfo",
      "void *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc->codec_if",
            "dip"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\teap1371_query_devinfo;\nvoid *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\neap1371_query_devinfo(addr, dip)\n\tvoid *addr;\n\tmixer_devinfo_t *dip;\n{\n\tstruct eap_softc *sc = addr;\n\n\treturn ((sc->codec_if->vtbl->query_devinfo)(sc->codec_if, dip));\n}"
  },
  {
    "function_name": "eap1371_mixer_get_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
    "lines": "1469-1478",
    "snippet": "int\neap1371_mixer_get_port(addr, cp)\n\tvoid *addr;\n\tmixer_ctrl_t *cp;\n{\n\tstruct eap_softc *sc = addr;\n\n\treturn ((sc->codec_if->vtbl->mixer_get_port)(sc->codec_if,\n\t\t\t\t\t\t     cp));\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/ac97.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\teap1371_mixer_get_port",
      "void *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc->codec_if",
            "cp"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\teap1371_mixer_get_port;\nvoid *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\neap1371_mixer_get_port(addr, cp)\n\tvoid *addr;\n\tmixer_ctrl_t *cp;\n{\n\tstruct eap_softc *sc = addr;\n\n\treturn ((sc->codec_if->vtbl->mixer_get_port)(sc->codec_if,\n\t\t\t\t\t\t     cp));\n}"
  },
  {
    "function_name": "eap1371_mixer_set_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
    "lines": "1458-1467",
    "snippet": "int\neap1371_mixer_set_port(addr, cp)\n\tvoid *addr;\n\tmixer_ctrl_t *cp;\n{\n\tstruct eap_softc *sc = addr;\n\n\treturn ((sc->codec_if->vtbl->mixer_set_port)(sc->codec_if,\n\t\t\t\t\t\t     cp));\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/ac97.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\teap1371_mixer_set_port",
      "void *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc->codec_if",
            "cp"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\teap1371_mixer_set_port;\nvoid *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\neap1371_mixer_set_port(addr, cp)\n\tvoid *addr;\n\tmixer_ctrl_t *cp;\n{\n\tstruct eap_softc *sc = addr;\n\n\treturn ((sc->codec_if->vtbl->mixer_set_port)(sc->codec_if,\n\t\t\t\t\t\t     cp));\n}"
  },
  {
    "function_name": "eap_getdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
    "lines": "1449-1456",
    "snippet": "int\neap_getdev(addr, retp)\n\tvoid *addr;\n\tstruct audio_device *retp;\n{\n\t*retp = eap_device;\n\treturn (0);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/ac97.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\teap_getdev",
      "struct audio_device eap_device = {\n\t\"Ensoniq AudioPCI\",\n\t\"\",\n\t\"eap\"\n};",
      "void *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\teap_getdev;\nstruct audio_device eap_device = {\n\t\"Ensoniq AudioPCI\",\n\t\"\",\n\t\"eap\"\n};\nvoid *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\neap_getdev(addr, retp)\n\tvoid *addr;\n\tstruct audio_device *retp;\n{\n\t*retp = eap_device;\n\treturn (0);\n}"
  },
  {
    "function_name": "eap_halt_input",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
    "lines": "1433-1447",
    "snippet": "int\neap_halt_input(addr)\n\tvoid *addr;\n{\n\tstruct eap_softc *sc = addr;\n\tu_int32_t icsc;\n    \n\tDPRINTF((\"eap: eap_halt_input\\n\"));\n\ticsc = EREAD4(sc, EAP_ICSC);\n\tEWRITE4(sc, EAP_ICSC, icsc & ~EAP_ADC_EN);\n#ifdef DIAGNOSTIC\n\tsc->sc_rrun = 0;\n#endif\n\treturn (0);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/ac97.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define  EAP_ADC_EN\t\t0x00000010",
      "#define EAP_ICSC\t\t0x00    /* interrupt / chip select control */"
    ],
    "globals_used": [
      "int\teap_halt_input",
      "void *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "EAP_ICSC",
            "icsc & ~EAP_ADC_EN"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EREAD4",
          "args": [
            "sc",
            "EAP_ICSC"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"eap: eap_halt_input\\n\")"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define  EAP_ADC_EN\t\t0x00000010\n#define EAP_ICSC\t\t0x00    /* interrupt / chip select control */\n\nint\teap_halt_input;\nvoid *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\neap_halt_input(addr)\n\tvoid *addr;\n{\n\tstruct eap_softc *sc = addr;\n\tu_int32_t icsc;\n    \n\tDPRINTF((\"eap: eap_halt_input\\n\"));\n\ticsc = EREAD4(sc, EAP_ICSC);\n\tEWRITE4(sc, EAP_ICSC, icsc & ~EAP_ADC_EN);\n#ifdef DIAGNOSTIC\n\tsc->sc_rrun = 0;\n#endif\n\treturn (0);\n}"
  },
  {
    "function_name": "eap_halt_output",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
    "lines": "1417-1431",
    "snippet": "int\neap_halt_output(addr)\n\tvoid *addr;\n{\n\tstruct eap_softc *sc = addr;\n\tu_int32_t icsc;\n\t\n\tDPRINTF((\"eap: eap_halt_output\\n\"));\n\ticsc = EREAD4(sc, EAP_ICSC);\n\tEWRITE4(sc, EAP_ICSC, icsc & ~EAP_DAC2_EN);\n#ifdef DIAGNOSTIC\n\tsc->sc_prun = 0;\n#endif\n\treturn (0);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/ac97.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define  EAP_DAC2_EN\t\t0x00000020",
      "#define EAP_ICSC\t\t0x00    /* interrupt / chip select control */"
    ],
    "globals_used": [
      "int\teap_halt_output",
      "void *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "EAP_ICSC",
            "icsc & ~EAP_DAC2_EN"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EREAD4",
          "args": [
            "sc",
            "EAP_ICSC"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"eap: eap_halt_output\\n\")"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define  EAP_DAC2_EN\t\t0x00000020\n#define EAP_ICSC\t\t0x00    /* interrupt / chip select control */\n\nint\teap_halt_output;\nvoid *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\neap_halt_output(addr)\n\tvoid *addr;\n{\n\tstruct eap_softc *sc = addr;\n\tu_int32_t icsc;\n\t\n\tDPRINTF((\"eap: eap_halt_output\\n\"));\n\ticsc = EREAD4(sc, EAP_ICSC);\n\tEWRITE4(sc, EAP_ICSC, icsc & ~EAP_DAC2_EN);\n#ifdef DIAGNOSTIC\n\tsc->sc_prun = 0;\n#endif\n\treturn (0);\n}"
  },
  {
    "function_name": "eap_trigger_input",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
    "lines": "1349-1415",
    "snippet": "int\neap_trigger_input(addr, start, end, blksize, intr, arg, param)\n\tvoid *addr;\n\tvoid *start, *end;\n\tint blksize;\n\tvoid (*intr) __P((void *));\n\tvoid *arg;\n\tstruct audio_params *param;\n{\n\tstruct eap_softc *sc = addr;\n\tstruct eap_dma *p;\n\tu_int32_t icsc, sic;\n\tint sampshift;\n\n#ifdef DIAGNOSTIC\n\tif (sc->sc_rrun)\n\t\tpanic(\"eap_trigger_input: already running\");\n\tsc->sc_rrun = 1;\n#endif\n\n\tDPRINTFN(1, (\"eap_trigger_input: sc=%p start=%p end=%p blksize=%d intr=%p(%p)\\n\", \n\t    addr, start, end, blksize, intr, arg));\n\tsc->sc_rintr = intr;\n\tsc->sc_rarg = arg;\n\n\tsic = EREAD4(sc, EAP_SIC);\n\tsic &= ~(EAP_R1_S_EB | EAP_R1_S_MB);\n\tsampshift = 0;\n\tif (param->precision * param->factor == 16) {\n\t\tsic |= EAP_R1_S_EB;\n\t\tsampshift++;\n\t}\n\tif (param->channels == 2) {\n\t\tsic |= EAP_R1_S_MB;\n\t\tsampshift++;\n\t}\n\tDPRINTFN(1, (\"set SIC=0x%08x\\n\", sic));\n\n\tEWRITE4(sc, EAP_SIC, sic);\n\n\tfor (p = sc->sc_dmas; p && KERNADDR(p) != start; p = p->next)\n\t\t;\n\tif (!p) {\n\t\tprintf(\"eap_trigger_input: bad addr %p\\n\", start);\n\t\treturn (EINVAL);\n\t}\n\n\tDPRINTF((\"eap_trigger_input: ADC_ADDR=0x%x, ADC_SIZE=0x%x\\n\",\n\t\t (int)DMAADDR(p), \n\t\t EAP_SET_SIZE(0, (((char *)end - (char *)start) >> 2) - 1)));\n\tEWRITE4(sc, EAP_MEMPAGE, EAP_ADC_PAGE);\n\tEWRITE4(sc, EAP_ADC_ADDR, DMAADDR(p));\n\tEWRITE4(sc, EAP_ADC_SIZE, \n\t\tEAP_SET_SIZE(0, (((char *)end - (char *)start) >> 2) - 1));\n\n\tEWRITE4(sc, EAP_ADC_CSR, (blksize >> sampshift) - 1);\n\n\tif (sc->sc_1371)\n\t\tEWRITE4(sc, E1371_SRC, 0);\n\n\ticsc = EREAD4(sc, EAP_ICSC);\n\tEWRITE4(sc, EAP_ICSC, icsc | EAP_ADC_EN);\n\n\tDPRINTFN(1, (\"eap_trigger_input: set ICSC = 0x%08x\\n\", icsc));\n\n\treturn (0);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/ac97.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define EAP_ADC_SIZE\t\t0x34",
      "#define EAP_ADC_ADDR\t\t0x30",
      "#define EAP_ADC_PAGE\t\t0xd",
      "#define EAP_ADC_CSR\t\t0x2c",
      "#define  EAP_R1_S_EB\t\t0x00000020",
      "#define  EAP_R1_S_MB\t\t0x00000010",
      "#define EAP_SIC\t\t\t0x20",
      "#define E1371_SRC\t\t0x10",
      "#define EAP_MEMPAGE\t\t0x0c",
      "#define  EAP_ADC_EN\t\t0x00000010",
      "#define EAP_ICSC\t\t0x00    /* interrupt / chip select control */"
    ],
    "globals_used": [
      "int\teap_trigger_input",
      "void *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"eap_trigger_input: set ICSC = 0x%08x\\n\", icsc)"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "EAP_ICSC",
            "icsc | EAP_ADC_EN"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EREAD4",
          "args": [
            "sc",
            "EAP_ICSC"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "E1371_SRC",
            "0"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "EAP_ADC_CSR",
            "(blksize >> sampshift) - 1"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "EAP_ADC_SIZE",
            "EAP_SET_SIZE(0, (((char *)end - (char *)start) >> 2) - 1)"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EAP_SET_SIZE",
          "args": [
            "0",
            "(((char *)end - (char *)start) >> 2) - 1"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "EAP_ADC_ADDR",
            "DMAADDR(p)"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMAADDR",
          "args": [
            "p"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "EAP_MEMPAGE",
            "EAP_ADC_PAGE"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"eap_trigger_input: ADC_ADDR=0x%x, ADC_SIZE=0x%x\\n\",\n\t\t (int)DMAADDR(p), \n\t\t EAP_SET_SIZE(0, (((char *)end - (char *)start) >> 2) - 1))"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EAP_SET_SIZE",
          "args": [
            "0",
            "(((char *)end - (char *)start) >> 2) - 1"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMAADDR",
          "args": [
            "p"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"eap_trigger_input: bad addr %p\\n\"",
            "start"
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "KERNADDR",
          "args": [
            "p"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "EAP_SIC",
            "sic"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"set SIC=0x%08x\\n\", sic)"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EREAD4",
          "args": [
            "sc",
            "EAP_SIC"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"eap_trigger_input: sc=%p start=%p end=%p blksize=%d intr=%p(%p)\\n\", \n\t    addr, start, end, blksize, intr, arg)"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"eap_trigger_input: already running\""
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define EAP_ADC_SIZE\t\t0x34\n#define EAP_ADC_ADDR\t\t0x30\n#define EAP_ADC_PAGE\t\t0xd\n#define EAP_ADC_CSR\t\t0x2c\n#define  EAP_R1_S_EB\t\t0x00000020\n#define  EAP_R1_S_MB\t\t0x00000010\n#define EAP_SIC\t\t\t0x20\n#define E1371_SRC\t\t0x10\n#define EAP_MEMPAGE\t\t0x0c\n#define  EAP_ADC_EN\t\t0x00000010\n#define EAP_ICSC\t\t0x00    /* interrupt / chip select control */\n\nint\teap_trigger_input;\nvoid *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\neap_trigger_input(addr, start, end, blksize, intr, arg, param)\n\tvoid *addr;\n\tvoid *start, *end;\n\tint blksize;\n\tvoid (*intr) __P((void *));\n\tvoid *arg;\n\tstruct audio_params *param;\n{\n\tstruct eap_softc *sc = addr;\n\tstruct eap_dma *p;\n\tu_int32_t icsc, sic;\n\tint sampshift;\n\n#ifdef DIAGNOSTIC\n\tif (sc->sc_rrun)\n\t\tpanic(\"eap_trigger_input: already running\");\n\tsc->sc_rrun = 1;\n#endif\n\n\tDPRINTFN(1, (\"eap_trigger_input: sc=%p start=%p end=%p blksize=%d intr=%p(%p)\\n\", \n\t    addr, start, end, blksize, intr, arg));\n\tsc->sc_rintr = intr;\n\tsc->sc_rarg = arg;\n\n\tsic = EREAD4(sc, EAP_SIC);\n\tsic &= ~(EAP_R1_S_EB | EAP_R1_S_MB);\n\tsampshift = 0;\n\tif (param->precision * param->factor == 16) {\n\t\tsic |= EAP_R1_S_EB;\n\t\tsampshift++;\n\t}\n\tif (param->channels == 2) {\n\t\tsic |= EAP_R1_S_MB;\n\t\tsampshift++;\n\t}\n\tDPRINTFN(1, (\"set SIC=0x%08x\\n\", sic));\n\n\tEWRITE4(sc, EAP_SIC, sic);\n\n\tfor (p = sc->sc_dmas; p && KERNADDR(p) != start; p = p->next)\n\t\t;\n\tif (!p) {\n\t\tprintf(\"eap_trigger_input: bad addr %p\\n\", start);\n\t\treturn (EINVAL);\n\t}\n\n\tDPRINTF((\"eap_trigger_input: ADC_ADDR=0x%x, ADC_SIZE=0x%x\\n\",\n\t\t (int)DMAADDR(p), \n\t\t EAP_SET_SIZE(0, (((char *)end - (char *)start) >> 2) - 1)));\n\tEWRITE4(sc, EAP_MEMPAGE, EAP_ADC_PAGE);\n\tEWRITE4(sc, EAP_ADC_ADDR, DMAADDR(p));\n\tEWRITE4(sc, EAP_ADC_SIZE, \n\t\tEAP_SET_SIZE(0, (((char *)end - (char *)start) >> 2) - 1));\n\n\tEWRITE4(sc, EAP_ADC_CSR, (blksize >> sampshift) - 1);\n\n\tif (sc->sc_1371)\n\t\tEWRITE4(sc, E1371_SRC, 0);\n\n\ticsc = EREAD4(sc, EAP_ICSC);\n\tEWRITE4(sc, EAP_ICSC, icsc | EAP_ADC_EN);\n\n\tDPRINTFN(1, (\"eap_trigger_input: set ICSC = 0x%08x\\n\", icsc));\n\n\treturn (0);\n}"
  },
  {
    "function_name": "eap_trigger_output",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
    "lines": "1266-1345",
    "snippet": "int\neap_trigger_output(addr, start, end, blksize, intr, arg, param)\n\tvoid *addr;\n\tvoid *start, *end;\n\tint blksize;\n\tvoid (*intr) __P((void *));\n\tvoid *arg;\n\tstruct audio_params *param;\n{\n\tstruct eap_softc *sc = addr;\n\tstruct eap_dma *p;\n\tu_int32_t icsc, sic;\n\tint sampshift;\n\tint idx;\n\n#ifdef DIAGNOSTIC\n\tif (sc->sc_prun)\n\t\tpanic(\"eap_trigger_output: already running\");\n\tsc->sc_prun = 1;\n#endif\n\n\tDPRINTFN(1, (\"eap_trigger_output: sc=%p start=%p end=%p \"\n            \"blksize=%d intr=%p(%p)\\n\", addr, start, end, blksize, intr, arg));\n\tsc->sc_pintr = intr;\n\tsc->sc_parg = arg;\n\n\tsic = EREAD4(sc, EAP_SIC);\n\tsic &= ~(EAP_P2_S_EB | EAP_P2_S_MB | EAP_INC_BITS | EAP_P2_INTR_EN);\n\tsic |= EAP_SET_P2_ST_INC(0) | EAP_SET_P2_END_INC(param->precision * param->factor / 8);\n\tsampshift = 0;\n\tif (param->precision * param->factor == 16) {\n\t\tsic |= EAP_P2_S_EB;\n\t\tsampshift++;\n\t}\n\tif (param->channels == 2) {\n\t\tsic |= EAP_P2_S_MB;\n\t\tsampshift++;\n\t}\n\n\tDPRINTFN(1, (\"set SIC=0x%08x\\n\", sic));\n\tEWRITE4(sc, EAP_SIC, sic);\n\tEWRITE4(sc, EAP_SIC, sic | EAP_P2_INTR_EN);\n\n\tfor (p = sc->sc_dmas; p && KERNADDR(p) != start; p = p->next)\n\t\t;\n\tif (!p) {\n\t\tprintf(\"eap_trigger_output: bad addr %p\\n\", start);\n\t\treturn (EINVAL);\n\t}\n\n\tDPRINTF((\"eap_trigger_output: DAC2_ADDR=0x%x, DAC2_SIZE=0x%x\\n\",\n\t\t (int)DMAADDR(p), \n\t\t EAP_SET_SIZE(0, (((char *)end - (char *)start) >> 2) - 1)));\n\tEWRITE4(sc, EAP_MEMPAGE, EAP_DAC_PAGE);\n\tEWRITE4(sc, EAP_DAC2_ADDR, DMAADDR(p));\n\tEWRITE4(sc, EAP_DAC2_SIZE, \n\t\tEAP_SET_SIZE(0, (((char *)end - (char *)start) >> 2) - 1));\n\n\tEWRITE4(sc, EAP_DAC2_CSR, (blksize >> sampshift) - 1);\n\ticsc = EREAD4(sc, EAP_ICSC);\n\n\tif (sc->sc_1371)\n\t\tEWRITE4(sc, E1371_SRC, 0);\n\n      \tEWRITE4(sc, EAP_ICSC, icsc | EAP_DAC2_EN);\n\n\n\tfor (idx = 0; idx < 3; idx++) {\n\t\tDPRINTFN (1, (\"icsc=%08x sic=%08x dac2csr=%08x icss=%08x src=%08x\\n\",\n\t\t    EREAD4(sc, EAP_ICSC), \n\t\t    EREAD4(sc, EAP_SIC),\n\t\t    EREAD4(sc, EAP_DAC2_CSR),\n\t\t    EREAD4(sc, EAP_ICSS),\n\t\t    EREAD4(sc, E1371_SRC)));\n\n\t\tdelay(1000);\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/ac97.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define EAP_DAC2_SIZE\t\t0x3c",
      "#define EAP_DAC2_ADDR\t\t0x38",
      "#define EAP_DAC_PAGE\t\t0xc",
      "#define EAP_DAC2_CSR\t\t0x28",
      "#define  EAP_INC_BITS\t\t0x003f0000",
      "#define  EAP_P2_INTR_EN\t\t0x00000200",
      "#define  EAP_P2_S_EB\t\t0x00000008",
      "#define  EAP_P2_S_MB\t\t0x00000004",
      "#define EAP_SIC\t\t\t0x20",
      "#define E1371_SRC\t\t0x10",
      "#define EAP_MEMPAGE\t\t0x0c",
      "#define EAP_ICSS\t\t0x04\t/* interrupt / chip select status */",
      "#define  EAP_DAC2_EN\t\t0x00000020",
      "#define EAP_ICSC\t\t0x00    /* interrupt / chip select control */"
    ],
    "globals_used": [
      "int\teap_trigger_output",
      "void *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1000"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"icsc=%08x sic=%08x dac2csr=%08x icss=%08x src=%08x\\n\",\n\t\t    EREAD4(sc, EAP_ICSC), \n\t\t    EREAD4(sc, EAP_SIC),\n\t\t    EREAD4(sc, EAP_DAC2_CSR),\n\t\t    EREAD4(sc, EAP_ICSS),\n\t\t    EREAD4(sc, E1371_SRC))"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EREAD4",
          "args": [
            "sc",
            "E1371_SRC"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EREAD4",
          "args": [
            "sc",
            "EAP_ICSS"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EREAD4",
          "args": [
            "sc",
            "EAP_DAC2_CSR"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EREAD4",
          "args": [
            "sc",
            "EAP_SIC"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EREAD4",
          "args": [
            "sc",
            "EAP_ICSC"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "EAP_ICSC",
            "icsc | EAP_DAC2_EN"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "E1371_SRC",
            "0"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EREAD4",
          "args": [
            "sc",
            "EAP_ICSC"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "EAP_DAC2_CSR",
            "(blksize >> sampshift) - 1"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "EAP_DAC2_SIZE",
            "EAP_SET_SIZE(0, (((char *)end - (char *)start) >> 2) - 1)"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EAP_SET_SIZE",
          "args": [
            "0",
            "(((char *)end - (char *)start) >> 2) - 1"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "EAP_DAC2_ADDR",
            "DMAADDR(p)"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMAADDR",
          "args": [
            "p"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "EAP_MEMPAGE",
            "EAP_DAC_PAGE"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"eap_trigger_output: DAC2_ADDR=0x%x, DAC2_SIZE=0x%x\\n\",\n\t\t (int)DMAADDR(p), \n\t\t EAP_SET_SIZE(0, (((char *)end - (char *)start) >> 2) - 1))"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EAP_SET_SIZE",
          "args": [
            "0",
            "(((char *)end - (char *)start) >> 2) - 1"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMAADDR",
          "args": [
            "p"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"eap_trigger_output: bad addr %p\\n\"",
            "start"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "KERNADDR",
          "args": [
            "p"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "EAP_SIC",
            "sic | EAP_P2_INTR_EN"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "EAP_SIC",
            "sic"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"set SIC=0x%08x\\n\", sic)"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EAP_SET_P2_END_INC",
          "args": [
            "param->precision * param->factor / 8"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EAP_SET_P2_ST_INC",
          "args": [
            "0"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EREAD4",
          "args": [
            "sc",
            "EAP_SIC"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"eap_trigger_output: sc=%p start=%p end=%p \"\n            \"blksize=%d intr=%p(%p)\\n\", addr, start, end, blksize, intr, arg)"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"eap_trigger_output: already running\""
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define EAP_DAC2_SIZE\t\t0x3c\n#define EAP_DAC2_ADDR\t\t0x38\n#define EAP_DAC_PAGE\t\t0xc\n#define EAP_DAC2_CSR\t\t0x28\n#define  EAP_INC_BITS\t\t0x003f0000\n#define  EAP_P2_INTR_EN\t\t0x00000200\n#define  EAP_P2_S_EB\t\t0x00000008\n#define  EAP_P2_S_MB\t\t0x00000004\n#define EAP_SIC\t\t\t0x20\n#define E1371_SRC\t\t0x10\n#define EAP_MEMPAGE\t\t0x0c\n#define EAP_ICSS\t\t0x04\t/* interrupt / chip select status */\n#define  EAP_DAC2_EN\t\t0x00000020\n#define EAP_ICSC\t\t0x00    /* interrupt / chip select control */\n\nint\teap_trigger_output;\nvoid *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\neap_trigger_output(addr, start, end, blksize, intr, arg, param)\n\tvoid *addr;\n\tvoid *start, *end;\n\tint blksize;\n\tvoid (*intr) __P((void *));\n\tvoid *arg;\n\tstruct audio_params *param;\n{\n\tstruct eap_softc *sc = addr;\n\tstruct eap_dma *p;\n\tu_int32_t icsc, sic;\n\tint sampshift;\n\tint idx;\n\n#ifdef DIAGNOSTIC\n\tif (sc->sc_prun)\n\t\tpanic(\"eap_trigger_output: already running\");\n\tsc->sc_prun = 1;\n#endif\n\n\tDPRINTFN(1, (\"eap_trigger_output: sc=%p start=%p end=%p \"\n            \"blksize=%d intr=%p(%p)\\n\", addr, start, end, blksize, intr, arg));\n\tsc->sc_pintr = intr;\n\tsc->sc_parg = arg;\n\n\tsic = EREAD4(sc, EAP_SIC);\n\tsic &= ~(EAP_P2_S_EB | EAP_P2_S_MB | EAP_INC_BITS | EAP_P2_INTR_EN);\n\tsic |= EAP_SET_P2_ST_INC(0) | EAP_SET_P2_END_INC(param->precision * param->factor / 8);\n\tsampshift = 0;\n\tif (param->precision * param->factor == 16) {\n\t\tsic |= EAP_P2_S_EB;\n\t\tsampshift++;\n\t}\n\tif (param->channels == 2) {\n\t\tsic |= EAP_P2_S_MB;\n\t\tsampshift++;\n\t}\n\n\tDPRINTFN(1, (\"set SIC=0x%08x\\n\", sic));\n\tEWRITE4(sc, EAP_SIC, sic);\n\tEWRITE4(sc, EAP_SIC, sic | EAP_P2_INTR_EN);\n\n\tfor (p = sc->sc_dmas; p && KERNADDR(p) != start; p = p->next)\n\t\t;\n\tif (!p) {\n\t\tprintf(\"eap_trigger_output: bad addr %p\\n\", start);\n\t\treturn (EINVAL);\n\t}\n\n\tDPRINTF((\"eap_trigger_output: DAC2_ADDR=0x%x, DAC2_SIZE=0x%x\\n\",\n\t\t (int)DMAADDR(p), \n\t\t EAP_SET_SIZE(0, (((char *)end - (char *)start) >> 2) - 1)));\n\tEWRITE4(sc, EAP_MEMPAGE, EAP_DAC_PAGE);\n\tEWRITE4(sc, EAP_DAC2_ADDR, DMAADDR(p));\n\tEWRITE4(sc, EAP_DAC2_SIZE, \n\t\tEAP_SET_SIZE(0, (((char *)end - (char *)start) >> 2) - 1));\n\n\tEWRITE4(sc, EAP_DAC2_CSR, (blksize >> sampshift) - 1);\n\ticsc = EREAD4(sc, EAP_ICSC);\n\n\tif (sc->sc_1371)\n\t\tEWRITE4(sc, E1371_SRC, 0);\n\n      \tEWRITE4(sc, EAP_ICSC, icsc | EAP_DAC2_EN);\n\n\n\tfor (idx = 0; idx < 3; idx++) {\n\t\tDPRINTFN (1, (\"icsc=%08x sic=%08x dac2csr=%08x icss=%08x src=%08x\\n\",\n\t\t    EREAD4(sc, EAP_ICSC), \n\t\t    EREAD4(sc, EAP_SIC),\n\t\t    EREAD4(sc, EAP_DAC2_CSR),\n\t\t    EREAD4(sc, EAP_ICSS),\n\t\t    EREAD4(sc, E1371_SRC)));\n\n\t\tdelay(1000);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "eap_round_blocksize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
    "lines": "1258-1264",
    "snippet": "int\neap_round_blocksize(addr, blk)\n\tvoid *addr;\n\tint blk;\n{\n\treturn (blk & -32);\t/* keep good alignment */\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/ac97.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\teap_round_blocksize",
      "void *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\teap_round_blocksize;\nvoid *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\neap_round_blocksize(addr, blk)\n\tvoid *addr;\n\tint blk;\n{\n\treturn (blk & -32);\t/* keep good alignment */\n}"
  },
  {
    "function_name": "eap_set_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
    "lines": "1145-1256",
    "snippet": "int\neap_set_params(addr, setmode, usemode, play, rec)\n\tvoid *addr;\n\tint setmode, usemode;\n\tstruct audio_params *play, *rec;\n{\n\tstruct eap_softc *sc = addr;\n\tstruct audio_params *p;\n\tint mode;\n\tu_int32_t div;\n\n\t/*\n\t * The es1370 only has one clock, so make the sample rates match.\n\t */\n\tif (!sc->sc_1371) {\n\t    if (play->sample_rate != rec->sample_rate &&\n\t\tusemode == (AUMODE_PLAY | AUMODE_RECORD)) {\n\t    \tif (setmode == AUMODE_PLAY) {\n\t\t    rec->sample_rate = play->sample_rate;\n\t\t    setmode |= AUMODE_RECORD;\n\t\t} else if (setmode == AUMODE_RECORD) {\n\t\t    play->sample_rate = rec->sample_rate;\n\t\t    setmode |= AUMODE_PLAY;\n\t\t} else\n\t\t    return (EINVAL);\n\t    }\n\t}\n\n\tfor (mode = AUMODE_RECORD; mode != -1; \n\t     mode = mode == AUMODE_RECORD ? AUMODE_PLAY : -1) {\n\t\tif ((setmode & mode) == 0)\n\t\t\tcontinue;\n\n\t\tp = mode == AUMODE_PLAY ? play : rec;\n\n\t\tif (p->sample_rate < 4000 || p->sample_rate > 48000 ||\n\t\t    (p->precision != 8 && p->precision != 16) ||\n\t\t    (p->channels != 1 && p->channels != 2))\n\t\t\treturn (EINVAL);\n\n\t\tp->factor = 1;\n\t\tp->sw_code = 0;\n\t\tswitch (p->encoding) {\n\t\tcase AUDIO_ENCODING_SLINEAR_BE:\n\t\t\tif (p->precision == 16)\n\t\t\t\tp->sw_code = swap_bytes;\n\t\t\telse\n\t\t\t\tp->sw_code = change_sign8;\n\t\t\tbreak;\n\t\tcase AUDIO_ENCODING_SLINEAR_LE:\n\t\t\tif (p->precision != 16)\n\t\t\t\tp->sw_code = change_sign8;\n\t\t\tbreak;\n\t\tcase AUDIO_ENCODING_ULINEAR_BE:\n\t\t\tif (p->precision == 16) {\n\t\t\t\tif (mode == AUMODE_PLAY)\n\t\t\t\t\tp->sw_code = swap_bytes_change_sign16;\n\t\t\t\telse\n\t\t\t\t\tp->sw_code = change_sign16_swap_bytes;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIO_ENCODING_ULINEAR_LE:\n\t\t\tif (p->precision == 16)\n\t\t\t\tp->sw_code = change_sign16;\n\t\t\tbreak;\n\t\tcase AUDIO_ENCODING_ULAW:\n\t\t\tif (mode == AUMODE_PLAY) {\n\t\t\t\tp->factor = 2;\n\t\t\t\tp->sw_code = mulaw_to_slinear16;\n\t\t\t} else\n\t\t\t\tp->sw_code = ulinear8_to_mulaw;\n\t\t\tbreak;\n\t\tcase AUDIO_ENCODING_ALAW:\n\t\t\tif (mode == AUMODE_PLAY) {\n\t\t\t\tp->factor = 2;\n\t\t\t\tp->sw_code = alaw_to_slinear16;\n\t\t\t} else\n\t\t\t\tp->sw_code = ulinear8_to_alaw;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (EINVAL);\n\t\t}\n\t}\n\n        if (sc->sc_1371) {\n\t\teap1371_set_dac_rate(sc, play->sample_rate, 1);\n\t\teap1371_set_dac_rate(sc, play->sample_rate, 2);\n\t\teap1371_set_adc_rate(sc, rec->sample_rate);\n\t} else {\n                /* Set the speed */\n                DPRINTFN(2, (\"eap_set_params: old ICSC = 0x%08x\\n\", \n                             EREAD4(sc, EAP_ICSC)));\n                div = EREAD4(sc, EAP_ICSC) & ~EAP_PCLKBITS;\n                /*\n                 * XXX\n                 * The -2 isn't documented, but seemed to make the wall \n                 * time match\n                 * what I expect.  - mycroft\n                 */\n                if (usemode == AUMODE_RECORD)\n                        div |= EAP_SET_PCLKDIV(EAP_XTAL_FREQ / \n                                rec->sample_rate - 2);\n                else\n                        div |= EAP_SET_PCLKDIV(EAP_XTAL_FREQ / \n                                play->sample_rate - 2);\n                div |= EAP_CCB_INTRM;\n                EWRITE4(sc, EAP_ICSC, div);\n                DPRINTFN(2, (\"eap_set_params: set ICSC = 0x%08x\\n\", div));\n        }\n\n\treturn (0);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/ac97.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define EAP_XTAL_FREQ 1411200 /* 22.5792 / 16 MHz */",
      "#define  EAP_PCLKBITS\t\t0x1fff0000",
      "#define  EAP_CCB_INTRM\t\t0x00000400",
      "#define EAP_ICSC\t\t0x00    /* interrupt / chip select control */"
    ],
    "globals_used": [
      "int\teap_set_params",
      "void \teap1371_set_adc_rate",
      "void \teap1371_set_dac_rate",
      "void *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"eap_set_params: set ICSC = 0x%08x\\n\", div)"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "EAP_ICSC",
            "div"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EAP_SET_PCLKDIV",
          "args": [
            "EAP_XTAL_FREQ / \n                                play->sample_rate - 2"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EAP_SET_PCLKDIV",
          "args": [
            "EAP_XTAL_FREQ / \n                                rec->sample_rate - 2"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EREAD4",
          "args": [
            "sc",
            "EAP_ICSC"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"eap_set_params: old ICSC = 0x%08x\\n\", \n                             EREAD4(sc, EAP_ICSC))"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EREAD4",
          "args": [
            "sc",
            "EAP_ICSC"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eap1371_set_adc_rate",
          "args": [
            "sc",
            "rec->sample_rate"
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "eap1371_set_adc_rate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
          "lines": "688-726",
          "snippet": "void\neap1371_set_adc_rate(sc, rate)\n\tstruct eap_softc *sc;\n\tint rate;\n{\n\tint freq, n, truncm;\n\tint out;\n\n        /* Whatever, it works, so I'll leave it :) */\n\n        if (rate > 48000)\n            rate = 48000;\n        if (rate < 4000)\n            rate = 4000;\n        n = rate / 3000;\n        if ((1 << n) & SRC_MAGIC)\n                n--;\n        truncm = ((21 * n) - 1) | 1;\n        freq = ((48000 << 15) / rate) * n;\n        if (rate >= 24000) {\n                if (truncm > 239)\n                        truncm = 239;\n\t\tout = ESRC_SET_TRUNC((239 - truncm) / 2);\n        } else {\n                if (truncm > 119)\n                        truncm = 119;\n\t\tout = ESRC_SMF | ESRC_SET_TRUNC((119 - truncm) / 2);\n        }\n \tout |= ESRC_SET_N(n);\n        eap1371_src_write(sc, ESRC_ADC+ESRC_TRUNC_N, out);\n\n      \n        out = eap1371_src_read(sc, ESRC_ADC+ESRC_IREGS) & 0xff;\n        eap1371_src_write(sc, ESRC_ADC+ESRC_IREGS, out | \n\t\t\t  ESRC_SET_VFI(freq >> 15));\n        eap1371_src_write(sc, ESRC_ADC+ESRC_VFF, freq & 0x7fff);\n        eap1371_src_write(sc, ESRC_ADC_VOLL, ESRC_SET_ADC_VOL(n));\n        eap1371_src_write(sc, ESRC_ADC_VOLR, ESRC_SET_ADC_VOL(n));\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/ac97.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define  SRC_MAGIC ((1<15)|(1<<13)|(1<<11)|(1<<9))",
            "#define ESRC_SMF\t\t0x8000",
            "#define  ESRC_VFF\t\t0x03",
            "#define  ESRC_IREGS\t\t0x01",
            "#define  ESRC_TRUNC_N\t\t0x00",
            "#define ESRC_ADC_VOLR\t\t0x6d",
            "#define ESRC_ADC_VOLL\t\t0x6c",
            "#define ESRC_ADC\t\t0x78"
          ],
          "globals_used": [
            "void \teap1371_set_adc_rate",
            "int\teap1371_src_read",
            "void\teap1371_src_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define  SRC_MAGIC ((1<15)|(1<<13)|(1<<11)|(1<<9))\n#define ESRC_SMF\t\t0x8000\n#define  ESRC_VFF\t\t0x03\n#define  ESRC_IREGS\t\t0x01\n#define  ESRC_TRUNC_N\t\t0x00\n#define ESRC_ADC_VOLR\t\t0x6d\n#define ESRC_ADC_VOLL\t\t0x6c\n#define ESRC_ADC\t\t0x78\n\nvoid \teap1371_set_adc_rate;\nint\teap1371_src_read;\nvoid\teap1371_src_write;\n\nvoid\neap1371_set_adc_rate(sc, rate)\n\tstruct eap_softc *sc;\n\tint rate;\n{\n\tint freq, n, truncm;\n\tint out;\n\n        /* Whatever, it works, so I'll leave it :) */\n\n        if (rate > 48000)\n            rate = 48000;\n        if (rate < 4000)\n            rate = 4000;\n        n = rate / 3000;\n        if ((1 << n) & SRC_MAGIC)\n                n--;\n        truncm = ((21 * n) - 1) | 1;\n        freq = ((48000 << 15) / rate) * n;\n        if (rate >= 24000) {\n                if (truncm > 239)\n                        truncm = 239;\n\t\tout = ESRC_SET_TRUNC((239 - truncm) / 2);\n        } else {\n                if (truncm > 119)\n                        truncm = 119;\n\t\tout = ESRC_SMF | ESRC_SET_TRUNC((119 - truncm) / 2);\n        }\n \tout |= ESRC_SET_N(n);\n        eap1371_src_write(sc, ESRC_ADC+ESRC_TRUNC_N, out);\n\n      \n        out = eap1371_src_read(sc, ESRC_ADC+ESRC_IREGS) & 0xff;\n        eap1371_src_write(sc, ESRC_ADC+ESRC_IREGS, out | \n\t\t\t  ESRC_SET_VFI(freq >> 15));\n        eap1371_src_write(sc, ESRC_ADC+ESRC_VFF, freq & 0x7fff);\n        eap1371_src_write(sc, ESRC_ADC_VOLL, ESRC_SET_ADC_VOL(n));\n        eap1371_src_write(sc, ESRC_ADC_VOLR, ESRC_SET_ADC_VOL(n));\n}"
        }
      },
      {
        "call_info": {
          "callee": "eap1371_set_dac_rate",
          "args": [
            "sc",
            "play->sample_rate",
            "2"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "eap1371_set_dac_rate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
          "lines": "728-757",
          "snippet": "void\neap1371_set_dac_rate(sc, rate, which)\n\tstruct eap_softc *sc;\n\tint rate;\n\tint which;\n{\n        int dac = (which == 1) ? ESRC_DAC1 : ESRC_DAC2;\n\tint freq, r;\n \n        /* Whatever, it works, so I'll leave it :) */\n\n        if (rate > 48000)\n            rate = 48000;\n        if (rate < 4000)\n            rate = 4000;\n        freq = ((rate << 15) + 1500) / 3000;\n        \n        eap1371_src_wait(sc);\n        r = EREAD4(sc, E1371_SRC) & (E1371_SRC_DISABLE | \n            E1371_SRC_DISP2 | E1371_SRC_DISP1 | E1371_SRC_DISREC);\n        r |= (which == 1) ? E1371_SRC_DISP1 : E1371_SRC_DISP2;\n        EWRITE4(sc, E1371_SRC, r);\n        r = eap1371_src_read(sc, dac + ESRC_IREGS) & 0x00ff;\n        eap1371_src_write(sc, dac + ESRC_IREGS, r | ((freq >> 5) & 0xfc00));\n        eap1371_src_write(sc, dac + ESRC_VFF, freq & 0x7fff);\n        r = EREAD4(sc, E1371_SRC) & (E1371_SRC_DISABLE | \n            E1371_SRC_DISP2 | E1371_SRC_DISP1 | E1371_SRC_DISREC);\n        r &= ~((which == 1) ? E1371_SRC_DISP1 : E1371_SRC_DISP2);\n        EWRITE4(sc, E1371_SRC, r);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/ac97.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define  ESRC_VFF\t\t0x03",
            "#define  ESRC_IREGS\t\t0x01",
            "#define ESRC_DAC2\t\t0x70",
            "#define ESRC_DAC1\t\t0x74",
            "#define  E1371_SRC_DISREC       (1<<19)",
            "#define  E1371_SRC_DISP2        (1<<20)",
            "#define  E1371_SRC_DISP1\t(1<<21)",
            "#define  E1371_SRC_DISABLE\t(1<<22)",
            "#define E1371_SRC\t\t0x10"
          ],
          "globals_used": [
            "int\teap1371_src_wait",
            "void \teap1371_set_dac_rate",
            "int\teap1371_src_read",
            "void\teap1371_src_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define  ESRC_VFF\t\t0x03\n#define  ESRC_IREGS\t\t0x01\n#define ESRC_DAC2\t\t0x70\n#define ESRC_DAC1\t\t0x74\n#define  E1371_SRC_DISREC       (1<<19)\n#define  E1371_SRC_DISP2        (1<<20)\n#define  E1371_SRC_DISP1\t(1<<21)\n#define  E1371_SRC_DISABLE\t(1<<22)\n#define E1371_SRC\t\t0x10\n\nint\teap1371_src_wait;\nvoid \teap1371_set_dac_rate;\nint\teap1371_src_read;\nvoid\teap1371_src_write;\n\nvoid\neap1371_set_dac_rate(sc, rate, which)\n\tstruct eap_softc *sc;\n\tint rate;\n\tint which;\n{\n        int dac = (which == 1) ? ESRC_DAC1 : ESRC_DAC2;\n\tint freq, r;\n \n        /* Whatever, it works, so I'll leave it :) */\n\n        if (rate > 48000)\n            rate = 48000;\n        if (rate < 4000)\n            rate = 4000;\n        freq = ((rate << 15) + 1500) / 3000;\n        \n        eap1371_src_wait(sc);\n        r = EREAD4(sc, E1371_SRC) & (E1371_SRC_DISABLE | \n            E1371_SRC_DISP2 | E1371_SRC_DISP1 | E1371_SRC_DISREC);\n        r |= (which == 1) ? E1371_SRC_DISP1 : E1371_SRC_DISP2;\n        EWRITE4(sc, E1371_SRC, r);\n        r = eap1371_src_read(sc, dac + ESRC_IREGS) & 0x00ff;\n        eap1371_src_write(sc, dac + ESRC_IREGS, r | ((freq >> 5) & 0xfc00));\n        eap1371_src_write(sc, dac + ESRC_VFF, freq & 0x7fff);\n        r = EREAD4(sc, E1371_SRC) & (E1371_SRC_DISABLE | \n            E1371_SRC_DISP2 | E1371_SRC_DISP1 | E1371_SRC_DISREC);\n        r &= ~((which == 1) ? E1371_SRC_DISP1 : E1371_SRC_DISP2);\n        EWRITE4(sc, E1371_SRC, r);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define EAP_XTAL_FREQ 1411200 /* 22.5792 / 16 MHz */\n#define  EAP_PCLKBITS\t\t0x1fff0000\n#define  EAP_CCB_INTRM\t\t0x00000400\n#define EAP_ICSC\t\t0x00    /* interrupt / chip select control */\n\nint\teap_set_params;\nvoid \teap1371_set_adc_rate;\nvoid \teap1371_set_dac_rate;\nvoid *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\neap_set_params(addr, setmode, usemode, play, rec)\n\tvoid *addr;\n\tint setmode, usemode;\n\tstruct audio_params *play, *rec;\n{\n\tstruct eap_softc *sc = addr;\n\tstruct audio_params *p;\n\tint mode;\n\tu_int32_t div;\n\n\t/*\n\t * The es1370 only has one clock, so make the sample rates match.\n\t */\n\tif (!sc->sc_1371) {\n\t    if (play->sample_rate != rec->sample_rate &&\n\t\tusemode == (AUMODE_PLAY | AUMODE_RECORD)) {\n\t    \tif (setmode == AUMODE_PLAY) {\n\t\t    rec->sample_rate = play->sample_rate;\n\t\t    setmode |= AUMODE_RECORD;\n\t\t} else if (setmode == AUMODE_RECORD) {\n\t\t    play->sample_rate = rec->sample_rate;\n\t\t    setmode |= AUMODE_PLAY;\n\t\t} else\n\t\t    return (EINVAL);\n\t    }\n\t}\n\n\tfor (mode = AUMODE_RECORD; mode != -1; \n\t     mode = mode == AUMODE_RECORD ? AUMODE_PLAY : -1) {\n\t\tif ((setmode & mode) == 0)\n\t\t\tcontinue;\n\n\t\tp = mode == AUMODE_PLAY ? play : rec;\n\n\t\tif (p->sample_rate < 4000 || p->sample_rate > 48000 ||\n\t\t    (p->precision != 8 && p->precision != 16) ||\n\t\t    (p->channels != 1 && p->channels != 2))\n\t\t\treturn (EINVAL);\n\n\t\tp->factor = 1;\n\t\tp->sw_code = 0;\n\t\tswitch (p->encoding) {\n\t\tcase AUDIO_ENCODING_SLINEAR_BE:\n\t\t\tif (p->precision == 16)\n\t\t\t\tp->sw_code = swap_bytes;\n\t\t\telse\n\t\t\t\tp->sw_code = change_sign8;\n\t\t\tbreak;\n\t\tcase AUDIO_ENCODING_SLINEAR_LE:\n\t\t\tif (p->precision != 16)\n\t\t\t\tp->sw_code = change_sign8;\n\t\t\tbreak;\n\t\tcase AUDIO_ENCODING_ULINEAR_BE:\n\t\t\tif (p->precision == 16) {\n\t\t\t\tif (mode == AUMODE_PLAY)\n\t\t\t\t\tp->sw_code = swap_bytes_change_sign16;\n\t\t\t\telse\n\t\t\t\t\tp->sw_code = change_sign16_swap_bytes;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIO_ENCODING_ULINEAR_LE:\n\t\t\tif (p->precision == 16)\n\t\t\t\tp->sw_code = change_sign16;\n\t\t\tbreak;\n\t\tcase AUDIO_ENCODING_ULAW:\n\t\t\tif (mode == AUMODE_PLAY) {\n\t\t\t\tp->factor = 2;\n\t\t\t\tp->sw_code = mulaw_to_slinear16;\n\t\t\t} else\n\t\t\t\tp->sw_code = ulinear8_to_mulaw;\n\t\t\tbreak;\n\t\tcase AUDIO_ENCODING_ALAW:\n\t\t\tif (mode == AUMODE_PLAY) {\n\t\t\t\tp->factor = 2;\n\t\t\t\tp->sw_code = alaw_to_slinear16;\n\t\t\t} else\n\t\t\t\tp->sw_code = ulinear8_to_alaw;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (EINVAL);\n\t\t}\n\t}\n\n        if (sc->sc_1371) {\n\t\teap1371_set_dac_rate(sc, play->sample_rate, 1);\n\t\teap1371_set_dac_rate(sc, play->sample_rate, 2);\n\t\teap1371_set_adc_rate(sc, rec->sample_rate);\n\t} else {\n                /* Set the speed */\n                DPRINTFN(2, (\"eap_set_params: old ICSC = 0x%08x\\n\", \n                             EREAD4(sc, EAP_ICSC)));\n                div = EREAD4(sc, EAP_ICSC) & ~EAP_PCLKBITS;\n                /*\n                 * XXX\n                 * The -2 isn't documented, but seemed to make the wall \n                 * time match\n                 * what I expect.  - mycroft\n                 */\n                if (usemode == AUMODE_RECORD)\n                        div |= EAP_SET_PCLKDIV(EAP_XTAL_FREQ / \n                                rec->sample_rate - 2);\n                else\n                        div |= EAP_SET_PCLKDIV(EAP_XTAL_FREQ / \n                                play->sample_rate - 2);\n                div |= EAP_CCB_INTRM;\n                EWRITE4(sc, EAP_ICSC, div);\n                DPRINTFN(2, (\"eap_set_params: set ICSC = 0x%08x\\n\", div));\n        }\n\n\treturn (0);\n}"
  },
  {
    "function_name": "eap_query_encoding",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
    "lines": "1086-1143",
    "snippet": "int\neap_query_encoding(addr, fp)\n\tvoid *addr;\n\tstruct audio_encoding *fp;\n{\n\tswitch (fp->index) {\n\tcase 0:\n\t\tstrcpy(fp->name, AudioEulinear);\n\t\tfp->encoding = AUDIO_ENCODING_ULINEAR;\n\t\tfp->precision = 8;\n\t\tfp->flags = 0;\n\t\treturn (0);\n\tcase 1:\n\t\tstrcpy(fp->name, AudioEmulaw);\n\t\tfp->encoding = AUDIO_ENCODING_ULAW;\n\t\tfp->precision = 8;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n\tcase 2:\n\t\tstrcpy(fp->name, AudioEalaw);\n\t\tfp->encoding = AUDIO_ENCODING_ALAW;\n\t\tfp->precision = 8;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n\tcase 3:\n\t\tstrcpy(fp->name, AudioEslinear);\n\t\tfp->encoding = AUDIO_ENCODING_SLINEAR;\n\t\tfp->precision = 8;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n\tcase 4:\n\t\tstrcpy(fp->name, AudioEslinear_le);\n\t\tfp->encoding = AUDIO_ENCODING_SLINEAR_LE;\n\t\tfp->precision = 16;\n\t\tfp->flags = 0;\n\t\treturn (0);\n\tcase 5:\n\t\tstrcpy(fp->name, AudioEulinear_le);\n\t\tfp->encoding = AUDIO_ENCODING_ULINEAR_LE;\n\t\tfp->precision = 16;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n\tcase 6:\n\t\tstrcpy(fp->name, AudioEslinear_be);\n\t\tfp->encoding = AUDIO_ENCODING_SLINEAR_BE;\n\t\tfp->precision = 16;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n\tcase 7:\n\t\tstrcpy(fp->name, AudioEulinear_be);\n\t\tfp->encoding = AUDIO_ENCODING_ULINEAR_BE;\n\t\tfp->precision = 16;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/ac97.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\teap_query_encoding",
      "void *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;",
      "int pool, flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEulinear_be"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEslinear_be"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEulinear_le"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEslinear_le"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEslinear"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEalaw"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEmulaw"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEulinear"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\teap_query_encoding;\nvoid *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;\nint pool, flags;\n\nint\neap_query_encoding(addr, fp)\n\tvoid *addr;\n\tstruct audio_encoding *fp;\n{\n\tswitch (fp->index) {\n\tcase 0:\n\t\tstrcpy(fp->name, AudioEulinear);\n\t\tfp->encoding = AUDIO_ENCODING_ULINEAR;\n\t\tfp->precision = 8;\n\t\tfp->flags = 0;\n\t\treturn (0);\n\tcase 1:\n\t\tstrcpy(fp->name, AudioEmulaw);\n\t\tfp->encoding = AUDIO_ENCODING_ULAW;\n\t\tfp->precision = 8;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n\tcase 2:\n\t\tstrcpy(fp->name, AudioEalaw);\n\t\tfp->encoding = AUDIO_ENCODING_ALAW;\n\t\tfp->precision = 8;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n\tcase 3:\n\t\tstrcpy(fp->name, AudioEslinear);\n\t\tfp->encoding = AUDIO_ENCODING_SLINEAR;\n\t\tfp->precision = 8;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n\tcase 4:\n\t\tstrcpy(fp->name, AudioEslinear_le);\n\t\tfp->encoding = AUDIO_ENCODING_SLINEAR_LE;\n\t\tfp->precision = 16;\n\t\tfp->flags = 0;\n\t\treturn (0);\n\tcase 5:\n\t\tstrcpy(fp->name, AudioEulinear_le);\n\t\tfp->encoding = AUDIO_ENCODING_ULINEAR_LE;\n\t\tfp->precision = 16;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n\tcase 6:\n\t\tstrcpy(fp->name, AudioEslinear_be);\n\t\tfp->encoding = AUDIO_ENCODING_SLINEAR_BE;\n\t\tfp->precision = 16;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n\tcase 7:\n\t\tstrcpy(fp->name, AudioEulinear_be);\n\t\tfp->encoding = AUDIO_ENCODING_ULINEAR_BE;\n\t\tfp->precision = 16;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\treturn (0);\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n}"
  },
  {
    "function_name": "eap_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
    "lines": "1073-1084",
    "snippet": "void\neap_close(addr)\n\tvoid *addr;\n{\n\tstruct eap_softc *sc = addr;\n    \n\teap_halt_output(sc);\n\teap_halt_input(sc);\n\n\tsc->sc_pintr = 0;\n\tsc->sc_rintr = 0;\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/ac97.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\teap_close",
      "int\teap_halt_output",
      "int\teap_halt_input",
      "void *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eap_halt_input",
          "args": [
            "sc"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "eap_halt_input",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
          "lines": "1433-1447",
          "snippet": "int\neap_halt_input(addr)\n\tvoid *addr;\n{\n\tstruct eap_softc *sc = addr;\n\tu_int32_t icsc;\n    \n\tDPRINTF((\"eap: eap_halt_input\\n\"));\n\ticsc = EREAD4(sc, EAP_ICSC);\n\tEWRITE4(sc, EAP_ICSC, icsc & ~EAP_ADC_EN);\n#ifdef DIAGNOSTIC\n\tsc->sc_rrun = 0;\n#endif\n\treturn (0);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/ac97.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define  EAP_ADC_EN\t\t0x00000010",
            "#define EAP_ICSC\t\t0x00    /* interrupt / chip select control */"
          ],
          "globals_used": [
            "int\teap_halt_input",
            "void *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define  EAP_ADC_EN\t\t0x00000010\n#define EAP_ICSC\t\t0x00    /* interrupt / chip select control */\n\nint\teap_halt_input;\nvoid *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\neap_halt_input(addr)\n\tvoid *addr;\n{\n\tstruct eap_softc *sc = addr;\n\tu_int32_t icsc;\n    \n\tDPRINTF((\"eap: eap_halt_input\\n\"));\n\ticsc = EREAD4(sc, EAP_ICSC);\n\tEWRITE4(sc, EAP_ICSC, icsc & ~EAP_ADC_EN);\n#ifdef DIAGNOSTIC\n\tsc->sc_rrun = 0;\n#endif\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eap_halt_output",
          "args": [
            "sc"
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "eap_halt_output",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
          "lines": "1417-1431",
          "snippet": "int\neap_halt_output(addr)\n\tvoid *addr;\n{\n\tstruct eap_softc *sc = addr;\n\tu_int32_t icsc;\n\t\n\tDPRINTF((\"eap: eap_halt_output\\n\"));\n\ticsc = EREAD4(sc, EAP_ICSC);\n\tEWRITE4(sc, EAP_ICSC, icsc & ~EAP_DAC2_EN);\n#ifdef DIAGNOSTIC\n\tsc->sc_prun = 0;\n#endif\n\treturn (0);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/ac97.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define  EAP_DAC2_EN\t\t0x00000020",
            "#define EAP_ICSC\t\t0x00    /* interrupt / chip select control */"
          ],
          "globals_used": [
            "int\teap_halt_output",
            "void *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define  EAP_DAC2_EN\t\t0x00000020\n#define EAP_ICSC\t\t0x00    /* interrupt / chip select control */\n\nint\teap_halt_output;\nvoid *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\neap_halt_output(addr)\n\tvoid *addr;\n{\n\tstruct eap_softc *sc = addr;\n\tu_int32_t icsc;\n\t\n\tDPRINTF((\"eap: eap_halt_output\\n\"));\n\ticsc = EREAD4(sc, EAP_ICSC);\n\tEWRITE4(sc, EAP_ICSC, icsc & ~EAP_DAC2_EN);\n#ifdef DIAGNOSTIC\n\tsc->sc_prun = 0;\n#endif\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\teap_close;\nint\teap_halt_output;\nint\teap_halt_input;\nvoid *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nvoid\neap_close(addr)\n\tvoid *addr;\n{\n\tstruct eap_softc *sc = addr;\n    \n\teap_halt_output(sc);\n\teap_halt_input(sc);\n\n\tsc->sc_pintr = 0;\n\tsc->sc_rintr = 0;\n}"
  },
  {
    "function_name": "eap_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
    "lines": "1062-1068",
    "snippet": "int\neap_open(addr, flags)\n\tvoid *addr;\n\tint flags;\n{\n\treturn (0);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/ac97.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\teap_open",
      "void *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;",
      "int pool, flags;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\teap_open;\nvoid *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;\nint pool, flags;\n\nint\neap_open(addr, flags)\n\tvoid *addr;\n\tint flags;\n{\n\treturn (0);\n}"
  },
  {
    "function_name": "eap_freemem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
    "lines": "1050-1060",
    "snippet": "int\neap_freemem(sc, p)\n\tstruct eap_softc *sc;\n\tstruct eap_dma *p;\n{\n\tbus_dmamap_unload(sc->sc_dmatag, p->map);\n\tbus_dmamap_destroy(sc->sc_dmatag, p->map);\n\tbus_dmamem_unmap(sc->sc_dmatag, p->addr, p->size);\n\tbus_dmamem_free(sc->sc_dmatag, p->segs, p->nsegs);\n\treturn (0);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/ac97.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\teap_freemem",
      "void *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;",
      "u_long size;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_dmamem_free",
          "args": [
            "sc->sc_dmatag",
            "p->segs",
            "p->nsegs"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_unmap",
          "args": [
            "sc->sc_dmatag",
            "p->addr",
            "p->size"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_destroy",
          "args": [
            "sc->sc_dmatag",
            "p->map"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_unload",
          "args": [
            "sc->sc_dmatag",
            "p->map"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\teap_freemem;\nvoid *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;\nu_long size;\n\nint\neap_freemem(sc, p)\n\tstruct eap_softc *sc;\n\tstruct eap_dma *p;\n{\n\tbus_dmamap_unload(sc->sc_dmatag, p->map);\n\tbus_dmamap_destroy(sc->sc_dmatag, p->map);\n\tbus_dmamem_unmap(sc->sc_dmatag, p->addr, p->size);\n\tbus_dmamem_free(sc->sc_dmatag, p->segs, p->nsegs);\n\treturn (0);\n}"
  },
  {
    "function_name": "eap_allocmem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
    "lines": "1009-1048",
    "snippet": "int\neap_allocmem(sc, size, align, p)\n\tstruct eap_softc *sc;\n\tsize_t size;\n\tsize_t align;\n\tstruct eap_dma *p;\n{\n\tint error;\n\n\tp->size = size;\n\terror = bus_dmamem_alloc(sc->sc_dmatag, p->size, align, 0,\n\t\t\t\t p->segs, sizeof(p->segs)/sizeof(p->segs[0]),\n\t\t\t\t &p->nsegs, BUS_DMA_NOWAIT);\n\tif (error)\n\t\treturn (error);\n\n\terror = bus_dmamem_map(sc->sc_dmatag, p->segs, p->nsegs, p->size, \n\t\t\t       &p->addr, BUS_DMA_NOWAIT|BUS_DMA_COHERENT);\n\tif (error)\n\t\tgoto free;\n\n\terror = bus_dmamap_create(sc->sc_dmatag, p->size, 1, p->size,\n\t\t\t\t  0, BUS_DMA_NOWAIT, &p->map);\n\tif (error)\n\t\tgoto unmap;\n\n\terror = bus_dmamap_load(sc->sc_dmatag, p->map, p->addr, p->size, NULL, \n\t\t\t\tBUS_DMA_NOWAIT);\n\tif (error)\n\t\tgoto destroy;\n\treturn (0);\n\ndestroy:\n\tbus_dmamap_destroy(sc->sc_dmatag, p->map);\nunmap:\n\tbus_dmamem_unmap(sc->sc_dmatag, p->addr, p->size);\nfree:\n\tbus_dmamem_free(sc->sc_dmatag, p->segs, p->nsegs);\n\treturn (error);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/ac97.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\teap_allocmem",
      "void *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;",
      "u_long size;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_dmamem_free",
          "args": [
            "sc->sc_dmatag",
            "p->segs",
            "p->nsegs"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_unmap",
          "args": [
            "sc->sc_dmatag",
            "p->addr",
            "p->size"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_destroy",
          "args": [
            "sc->sc_dmatag",
            "p->map"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_load",
          "args": [
            "sc->sc_dmatag",
            "p->map",
            "p->addr",
            "p->size",
            "NULL",
            "BUS_DMA_NOWAIT"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamap_create",
          "args": [
            "sc->sc_dmatag",
            "p->size",
            "1",
            "p->size",
            "0",
            "BUS_DMA_NOWAIT",
            "&p->map"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_map",
          "args": [
            "sc->sc_dmatag",
            "p->segs",
            "p->nsegs",
            "p->size",
            "&p->addr",
            "BUS_DMA_NOWAIT|BUS_DMA_COHERENT"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_dmamem_alloc",
          "args": [
            "sc->sc_dmatag",
            "p->size",
            "align",
            "0",
            "p->segs",
            "sizeof(p->segs)/sizeof(p->segs[0])",
            "&p->nsegs",
            "BUS_DMA_NOWAIT"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\teap_allocmem;\nvoid *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;\nu_long size;\n\nint\neap_allocmem(sc, size, align, p)\n\tstruct eap_softc *sc;\n\tsize_t size;\n\tsize_t align;\n\tstruct eap_dma *p;\n{\n\tint error;\n\n\tp->size = size;\n\terror = bus_dmamem_alloc(sc->sc_dmatag, p->size, align, 0,\n\t\t\t\t p->segs, sizeof(p->segs)/sizeof(p->segs[0]),\n\t\t\t\t &p->nsegs, BUS_DMA_NOWAIT);\n\tif (error)\n\t\treturn (error);\n\n\terror = bus_dmamem_map(sc->sc_dmatag, p->segs, p->nsegs, p->size, \n\t\t\t       &p->addr, BUS_DMA_NOWAIT|BUS_DMA_COHERENT);\n\tif (error)\n\t\tgoto free;\n\n\terror = bus_dmamap_create(sc->sc_dmatag, p->size, 1, p->size,\n\t\t\t\t  0, BUS_DMA_NOWAIT, &p->map);\n\tif (error)\n\t\tgoto unmap;\n\n\terror = bus_dmamap_load(sc->sc_dmatag, p->map, p->addr, p->size, NULL, \n\t\t\t\tBUS_DMA_NOWAIT);\n\tif (error)\n\t\tgoto destroy;\n\treturn (0);\n\ndestroy:\n\tbus_dmamap_destroy(sc->sc_dmatag, p->map);\nunmap:\n\tbus_dmamem_unmap(sc->sc_dmatag, p->addr, p->size);\nfree:\n\tbus_dmamem_free(sc->sc_dmatag, p->segs, p->nsegs);\n\treturn (error);\n}"
  },
  {
    "function_name": "eap_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
    "lines": "961-1007",
    "snippet": "int\neap_intr(p)\n\tvoid *p;\n{\n\tstruct eap_softc *sc = p;\n\tu_int32_t intr, sic;\n\n\tintr = EREAD4(sc, EAP_ICSS);\n\tif (!(intr & EAP_INTR))\n\t\treturn (0);\n\tsic = EREAD4(sc, EAP_SIC);\n\tDPRINTFN(5, (\"eap_intr: ICSS=0x%08x, SIC=0x%08x\\n\", intr, sic));\n\tif (intr & EAP_I_ADC) {\n\t\t/*\n\t\t * XXX This is a hack!\n\t\t * The EAP chip sometimes generates the recording interrupt\n\t\t * while it is still transferring the data.  To make sure\n\t\t * it has all arrived we busy wait until the count is right.\n\t\t * The transfer we are waiting for is 8 longwords.\n\t\t */\n\t\tint s, nw, n;\n\n\t\tEWRITE4(sc, EAP_MEMPAGE, EAP_ADC_PAGE);\n\t\ts = EREAD4(sc, EAP_ADC_CSR);\n\t\tnw = ((s & 0xffff) + 1) >> 2; /* # of words in DMA */\n\t\tn = 0;\n\t\twhile (((EREAD4(sc, EAP_ADC_SIZE) >> 16) + 8) % nw == 0) {\n\t\t\tdelay(10);\n\t\t\tif (++n > 100) {\n\t\t\t\tprintf(\"eapintr: dma fix timeout\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* Continue with normal interrupt handling. */\n\t\tEWRITE4(sc, EAP_SIC, sic & ~EAP_R1_INTR_EN);\n\t\tEWRITE4(sc, EAP_SIC, sic | EAP_R1_INTR_EN);\n\t\tif (sc->sc_rintr)\n\t\t\tsc->sc_rintr(sc->sc_rarg);\n\t}\n\tif (intr & EAP_I_DAC2) {\n\t\tEWRITE4(sc, EAP_SIC, sic & ~EAP_P2_INTR_EN);\n\t\tEWRITE4(sc, EAP_SIC, sic | EAP_P2_INTR_EN);\n\t\tif (sc->sc_pintr)\n\t\t\tsc->sc_pintr(sc->sc_parg);\n\t}\n\treturn (1);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/ac97.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define EAP_ADC_SIZE\t\t0x34",
      "#define EAP_ADC_PAGE\t\t0xd",
      "#define EAP_ADC_CSR\t\t0x2c",
      "#define  EAP_R1_INTR_EN\t\t0x00000400",
      "#define  EAP_P2_INTR_EN\t\t0x00000200",
      "#define EAP_SIC\t\t\t0x20",
      "#define EAP_MEMPAGE\t\t0x0c",
      "#define  EAP_INTR\t\t0x80000000",
      "#define  EAP_I_DAC2\t\t0x00000002",
      "#define  EAP_I_ADC\t\t0x00000001",
      "#define EAP_ICSS\t\t0x04\t/* interrupt / chip select status */"
    ],
    "globals_used": [
      "int\teap_intr"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sc->sc_pintr",
          "args": [
            "sc->sc_parg"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "EAP_SIC",
            "sic | EAP_P2_INTR_EN"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "EAP_SIC",
            "sic & ~EAP_P2_INTR_EN"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->sc_rintr",
          "args": [
            "sc->sc_rarg"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "EAP_SIC",
            "sic | EAP_R1_INTR_EN"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "EAP_SIC",
            "sic & ~EAP_R1_INTR_EN"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"eapintr: dma fix timeout\""
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "10"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EREAD4",
          "args": [
            "sc",
            "EAP_ADC_SIZE"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EREAD4",
          "args": [
            "sc",
            "EAP_ADC_CSR"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "EAP_MEMPAGE",
            "EAP_ADC_PAGE"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"eap_intr: ICSS=0x%08x, SIC=0x%08x\\n\", intr, sic)"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EREAD4",
          "args": [
            "sc",
            "EAP_SIC"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EREAD4",
          "args": [
            "sc",
            "EAP_ICSS"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define EAP_ADC_SIZE\t\t0x34\n#define EAP_ADC_PAGE\t\t0xd\n#define EAP_ADC_CSR\t\t0x2c\n#define  EAP_R1_INTR_EN\t\t0x00000400\n#define  EAP_P2_INTR_EN\t\t0x00000200\n#define EAP_SIC\t\t\t0x20\n#define EAP_MEMPAGE\t\t0x0c\n#define  EAP_INTR\t\t0x80000000\n#define  EAP_I_DAC2\t\t0x00000002\n#define  EAP_I_ADC\t\t0x00000001\n#define EAP_ICSS\t\t0x04\t/* interrupt / chip select status */\n\nint\teap_intr;\n\nint\neap_intr(p)\n\tvoid *p;\n{\n\tstruct eap_softc *sc = p;\n\tu_int32_t intr, sic;\n\n\tintr = EREAD4(sc, EAP_ICSS);\n\tif (!(intr & EAP_INTR))\n\t\treturn (0);\n\tsic = EREAD4(sc, EAP_SIC);\n\tDPRINTFN(5, (\"eap_intr: ICSS=0x%08x, SIC=0x%08x\\n\", intr, sic));\n\tif (intr & EAP_I_ADC) {\n\t\t/*\n\t\t * XXX This is a hack!\n\t\t * The EAP chip sometimes generates the recording interrupt\n\t\t * while it is still transferring the data.  To make sure\n\t\t * it has all arrived we busy wait until the count is right.\n\t\t * The transfer we are waiting for is 8 longwords.\n\t\t */\n\t\tint s, nw, n;\n\n\t\tEWRITE4(sc, EAP_MEMPAGE, EAP_ADC_PAGE);\n\t\ts = EREAD4(sc, EAP_ADC_CSR);\n\t\tnw = ((s & 0xffff) + 1) >> 2; /* # of words in DMA */\n\t\tn = 0;\n\t\twhile (((EREAD4(sc, EAP_ADC_SIZE) >> 16) + 8) % nw == 0) {\n\t\t\tdelay(10);\n\t\t\tif (++n > 100) {\n\t\t\t\tprintf(\"eapintr: dma fix timeout\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* Continue with normal interrupt handling. */\n\t\tEWRITE4(sc, EAP_SIC, sic & ~EAP_R1_INTR_EN);\n\t\tEWRITE4(sc, EAP_SIC, sic | EAP_R1_INTR_EN);\n\t\tif (sc->sc_rintr)\n\t\t\tsc->sc_rintr(sc->sc_rarg);\n\t}\n\tif (intr & EAP_I_DAC2) {\n\t\tEWRITE4(sc, EAP_SIC, sic & ~EAP_P2_INTR_EN);\n\t\tEWRITE4(sc, EAP_SIC, sic | EAP_P2_INTR_EN);\n\t\tif (sc->sc_pintr)\n\t\t\tsc->sc_pintr(sc->sc_parg);\n\t}\n\treturn (1);\n}"
  },
  {
    "function_name": "eap1371_reset_codec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
    "lines": "947-959",
    "snippet": "void\neap1371_reset_codec(sc_)\n\tvoid *sc_;\n{\n\tstruct eap_softc *sc = sc_;\n\tu_int32_t icsc = EREAD4(sc, EAP_ICSC);\n\t\n\tEWRITE4(sc, EAP_ICSC, icsc | E1371_SYNC_RES);\n\tdelay(100);\n\tEWRITE4(sc, EAP_ICSC, icsc & ~E1371_SYNC_RES);\n\n\treturn;\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/ac97.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define  E1371_SYNC_RES\t\t(1<<14)",
      "#define EAP_ICSC\t\t0x00    /* interrupt / chip select control */"
    ],
    "globals_used": [
      "void    eap1371_reset_codec"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "EAP_ICSC",
            "icsc & ~E1371_SYNC_RES"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "100"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "EAP_ICSC",
            "icsc | E1371_SYNC_RES"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EREAD4",
          "args": [
            "sc",
            "EAP_ICSC"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define  E1371_SYNC_RES\t\t(1<<14)\n#define EAP_ICSC\t\t0x00    /* interrupt / chip select control */\n\nvoid    eap1371_reset_codec;\n\nvoid\neap1371_reset_codec(sc_)\n\tvoid *sc_;\n{\n\tstruct eap_softc *sc = sc_;\n\tu_int32_t icsc = EREAD4(sc, EAP_ICSC);\n\t\n\tEWRITE4(sc, EAP_ICSC, icsc | E1371_SYNC_RES);\n\tdelay(100);\n\tEWRITE4(sc, EAP_ICSC, icsc & ~E1371_SYNC_RES);\n\n\treturn;\n}"
  },
  {
    "function_name": "eap1371_attach_codec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
    "lines": "936-945",
    "snippet": "int\neap1371_attach_codec(sc_, codec_if)\n\tvoid *sc_;\n\tstruct ac97_codec_if  *codec_if;\n{\n\tstruct eap_softc *sc = sc_;\n\t\n\tsc->codec_if = codec_if;\n\treturn (0);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/ac97.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int     eap1371_attach_codec"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint     eap1371_attach_codec;\n\nint\neap1371_attach_codec(sc_, codec_if)\n\tvoid *sc_;\n\tstruct ac97_codec_if  *codec_if;\n{\n\tstruct eap_softc *sc = sc_;\n\t\n\tsc->codec_if = codec_if;\n\treturn (0);\n}"
  },
  {
    "function_name": "eap_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
    "lines": "759-934",
    "snippet": "void\neap_attach(parent, self, aux)\n\tstruct device *parent;\n\tstruct device *self;\n\tvoid *aux;\n{\n\tstruct eap_softc *sc = (struct eap_softc *)self;\n\tstruct pci_attach_args *pa = (struct pci_attach_args *)aux;\n\tpci_chipset_tag_t pc = pa->pa_pc;\n\tstruct audio_hw_if *eap_hw_if;\n\tchar const *intrstr;\n\tpci_intr_handle_t ih;\n\tpcireg_t csr;\n\tmixer_ctrl_t ctl;\n\tint i;\n\n\tsc->sc_1371 = \n\t    !(PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ENSONIQ_AUDIOPCI);\n\n\t/* Map I/O register */\n\tif (pci_mapreg_map(pa, PCI_CBIO, PCI_MAPREG_TYPE_IO, 0,\n\t\t\t   &sc->iot, &sc->ioh, NULL, NULL)) {\n\t\tprintf(\"\\n%s: can't map i/o space\\n\", sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\tsc->sc_dmatag = pa->pa_dmat;\n\n\t/* Enable the device. */\n\tcsr = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);\n\tpci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,\n\t\t       csr | PCI_COMMAND_MASTER_ENABLE);\n\n\t/* Map and establish the interrupt. */\n\tif (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,\n\t\t\t pa->pa_intrline, &ih)) {\n\t\tprintf(\"\\n%s: couldn't map interrupt\\n\", sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\tintrstr = pci_intr_string(pc, ih);\n\tsc->sc_ih = pci_intr_establish(pc, ih, IPL_AUDIO, eap_intr, sc, \n\t\t\t\t       sc->sc_dev.dv_xname);\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\"\\n%s: couldn't establish interrupt\",\n\t\t       sc->sc_dev.dv_xname);\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\tprintf(\": %s\\n\", intrstr);\n\n\tif (!sc->sc_1371) {\n\t\t/* Enable interrupts and looping mode. */\n\t\t/* enable the parts we need */\n\t\tEWRITE4(sc, EAP_SIC, EAP_P2_INTR_EN | EAP_R1_INTR_EN);\n\t\tEWRITE4(sc, EAP_ICSC, EAP_CDC_EN); \n\n\t\t/* reset codec */\t\n\t\t/* normal operation */ \n\t\t/* select codec clocks */\n\t\teap_write_codec(sc, AK_RESET, AK_PD); \n\t\teap_write_codec(sc, AK_RESET, AK_PD | AK_NRST);\n\t\teap_write_codec(sc, AK_CS, 0x0);\n\n\t\teap_hw_if = &eap1370_hw_if;\n\n\t\t/* Enable all relevant mixer switches. */\n\t\tctl.dev = EAP_OUTPUT_SELECT;\n\t\tctl.type = AUDIO_MIXER_SET;\n\t\tctl.un.mask = 1 << EAP_VOICE_VOL | 1 << EAP_FM_VOL | \n\t\t\t1 << EAP_CD_VOL | 1 << EAP_LINE_VOL | 1 << EAP_AUX_VOL |\n\t\t\t1 << EAP_MIC_VOL;\n\t\teap_hw_if->set_port(sc, &ctl);\n\n\t\tctl.type = AUDIO_MIXER_VALUE;\n\t\tctl.un.value.num_channels = 1;\n\t\tfor (ctl.dev = EAP_MASTER_VOL; ctl.dev < EAP_MIC_VOL; \n\t\t     ctl.dev++) {\n\t\t\tctl.un.value.level[AUDIO_MIXER_LEVEL_MONO] = VOL_0DB;\n\t\t\teap_hw_if->set_port(sc, &ctl);\n\t\t}\n\t\tctl.un.value.level[AUDIO_MIXER_LEVEL_MONO] = 0;\n\t\teap_hw_if->set_port(sc, &ctl);\n\t\tctl.dev = EAP_MIC_PREAMP;\n\t\tctl.type = AUDIO_MIXER_ENUM;\n\t\tctl.un.ord = 0;\n\t\teap_hw_if->set_port(sc, &ctl);\n\t\tctl.dev = EAP_RECORD_SOURCE;\n\t\tctl.type = AUDIO_MIXER_SET;\n\t\tctl.un.mask = 1 << EAP_MIC_VOL;\n\t\teap_hw_if->set_port(sc, &ctl);\n\t} else {\n\t\tint error;\n\n                /* clean slate */\n                EWRITE4(sc, EAP_SIC, 0);\n                EWRITE4(sc, EAP_ICSC, 0);\n                EWRITE4(sc, E1371_LEGACY, 0);\n\n\t\tif (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ENSONIQ_CT5880) {\n\t\t\tEWRITE4(sc, EAP_ICSS, CT5880_AC97_RESET);\n\n\t\t\tdelay(20000);\n\t\t}\n\n                /* Reset from es1371's perspective */\n                EWRITE4(sc, EAP_ICSC, E1371_SYNC_RES);\n                delay(20);\n                EWRITE4(sc, EAP_ICSC, 0);\n\n                /* must properly reprogram sample rate converter,\n                 * or it locks up.  Set some defaults for the life of the\n                 * machine, and set up a sb default sample rate.\n                 */\n                EWRITE4(sc, E1371_SRC, E1371_SRC_DISABLE);\n                for (i=0; i<0x80; i++)\n                        eap1371_src_write(sc, i, 0);\n\t\teap1371_src_write(sc, ESRC_DAC1+ESRC_TRUNC_N, ESRC_SET_N(16));\n\t\teap1371_src_write(sc, ESRC_DAC2+ESRC_TRUNC_N, ESRC_SET_N(16));\n                eap1371_src_write(sc, ESRC_DAC1+ESRC_IREGS, ESRC_SET_VFI(16));\n                eap1371_src_write(sc, ESRC_DAC2+ESRC_IREGS, ESRC_SET_VFI(16));\n                eap1371_src_write(sc, ESRC_ADC_VOLL, ESRC_SET_ADC_VOL(16));\n                eap1371_src_write(sc, ESRC_ADC_VOLR, ESRC_SET_ADC_VOL(16));\n\t\teap1371_src_write(sc, ESRC_DAC1_VOLL, ESRC_SET_DAC_VOLI(1));\n\t\teap1371_src_write(sc, ESRC_DAC1_VOLR, ESRC_SET_DAC_VOLI(1));\n\t\teap1371_src_write(sc, ESRC_DAC2_VOLL, ESRC_SET_DAC_VOLI(1));\n\t\teap1371_src_write(sc, ESRC_DAC2_VOLR, ESRC_SET_DAC_VOLI(1));\n                eap1371_set_adc_rate(sc, 22050);\n                eap1371_set_dac_rate(sc, 22050, 1);\n                eap1371_set_dac_rate(sc, 22050, 2);\n             \n                EWRITE4(sc, E1371_SRC, 0);\n\n                /* Reset codec */\n\n\t\t/* Interrupt enable */\n\t\tsc->host_if.arg = sc;\n\t\tsc->host_if.attach = eap1371_attach_codec;\n\t\tsc->host_if.read = eap1371_read_codec;\n\n\t\tsc->host_if.write = eap1371_write_codec;\n\t\tsc->host_if.reset = eap1371_reset_codec;\n\t\t\n\t\tif ((error = ac97_attach(&sc->host_if)) == 0) {\n\t\t\t/* Interrupt enable */\n\t\t\tEWRITE4(sc, EAP_SIC, EAP_P2_INTR_EN | EAP_R1_INTR_EN);\n\t\t} else\n\t\t\treturn;\n\n\t\teap_hw_if = &eap1371_hw_if;\n\n\t\t/* Just enable the DAC and master volumes by default */\n\t\tctl.type = AUDIO_MIXER_ENUM;\n\t\tctl.un.ord = 0;  /* off */\n\t\tctl.dev = eap1371_get_portnum_by_name(sc, AudioCoutputs,\n\t\t       AudioNmaster, AudioNmute);\n\t\teap1371_mixer_set_port(sc, &ctl);\n\t\tctl.dev = eap1371_get_portnum_by_name(sc, AudioCinputs,\n\t\t       AudioNdac, AudioNmute);\n\t\teap1371_mixer_set_port(sc, &ctl);\n\t\tctl.dev = eap1371_get_portnum_by_name(sc, AudioCrecord,\n\t\t       AudioNvolume, AudioNmute);\n\t\teap1371_mixer_set_port(sc, &ctl);\n\t\t\n\t\t\n\t\tctl.dev = eap1371_get_portnum_by_name(sc, AudioCrecord,\n\t\t       AudioNsource, NULL);\n\t\tctl.type = AUDIO_MIXER_ENUM;\n\t\tctl.un.ord = 0;\n\t\teap1371_mixer_set_port(sc, &ctl);\n\n        }\n\n\taudio_attach_mi(eap_hw_if, sc, &sc->sc_dev);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/ac97.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tEAP_MIC_PREAMP\t\t9",
      "#define EAP_OUTPUT_SELECT\t8",
      "#define\tEAP_RECORD_SOURCE \t7",
      "#define EAP_MIC_VOL\t\t6",
      "#define EAP_AUX_VOL\t\t5",
      "#define EAP_LINE_VOL\t\t4",
      "#define EAP_CD_VOL\t\t3",
      "#define EAP_FM_VOL\t\t2",
      "#define EAP_VOICE_VOL\t\t1",
      "#define EAP_MASTER_VOL\t\t0",
      "#define VOL_0DB 200",
      "#define AK_CS\t\t\t0x17",
      "#define  AK_NRST\t\t0x01",
      "#define  AK_PD\t\t\t0x02",
      "#define AK_RESET\t\t0x16",
      "#define  EAP_R1_INTR_EN\t\t0x00000400",
      "#define  EAP_P2_INTR_EN\t\t0x00000200",
      "#define EAP_SIC\t\t\t0x20",
      "#define  ESRC_IREGS\t\t0x01",
      "#define  ESRC_TRUNC_N\t\t0x00",
      "#define ESRC_DAC2_VOLR\t\t0x7f",
      "#define ESRC_DAC2_VOLL\t\t0x7e",
      "#define ESRC_DAC1_VOLR\t\t0x7d",
      "#define ESRC_DAC1_VOLL\t\t0x7c",
      "#define ESRC_ADC_VOLR\t\t0x6d",
      "#define ESRC_ADC_VOLL\t\t0x6c",
      "#define ESRC_DAC2\t\t0x70",
      "#define ESRC_DAC1\t\t0x74",
      "#define E1371_LEGACY\t\t0x18",
      "#define  E1371_SRC_DISABLE\t(1<<22)",
      "#define E1371_SRC\t\t0x10",
      "#define  CT5880_AC97_RESET      0x20000000",
      "#define EAP_ICSS\t\t0x04\t/* interrupt / chip select status */",
      "#define  E1371_SYNC_RES\t\t(1<<14)",
      "#define  EAP_CDC_EN\t\t0x00000002",
      "#define EAP_ICSC\t\t0x00    /* interrupt / chip select control */",
      "#define\tPCI_CBIO\t\t0x10"
    ],
    "globals_used": [
      "void\teap_attach",
      "int\teap_intr",
      "void    eap_write_codec",
      "int\teap1371_mixer_set_port",
      "void \teap1371_set_adc_rate",
      "void \teap1371_set_dac_rate",
      "void\teap1371_src_write",
      "int     eap1371_attach_codec",
      "int\teap1371_read_codec",
      "int\teap1371_write_codec",
      "void    eap1371_reset_codec",
      "int     eap1371_get_portnum_by_name",
      "struct audio_hw_if eap1370_hw_if = {\n\teap_open,\n\teap_close,\n\tNULL,\n\teap_query_encoding,\n\teap_set_params,\n\teap_round_blocksize,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\teap_halt_output,\n\teap_halt_input,\n\tNULL,\n\teap_getdev,\n\tNULL,\n\teap_mixer_set_port,\n\teap_mixer_get_port,\n\teap_query_devinfo,\n\teap_malloc,\n\teap_free,\n\teap_round_buffersize,\n\teap_mappage,\n\teap_get_props,\n\teap_trigger_output,\n\teap_trigger_input,\n};",
      "struct audio_hw_if eap1371_hw_if = {\n\teap_open,\n\teap_close,\n\tNULL,\n\teap_query_encoding,\n\teap_set_params,\n\teap_round_blocksize,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\teap_halt_output,\n\teap_halt_input,\n\tNULL,\n\teap_getdev,\n\tNULL,\n\teap1371_mixer_set_port,\n\teap1371_mixer_get_port,\n\teap1371_query_devinfo,\n\teap_malloc,\n\teap_free,\n\teap_round_buffersize,\n\teap_mappage,\n\teap_get_props,\n\teap_trigger_output,\n\teap_trigger_input,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audio_attach_mi",
          "args": [
            "eap_hw_if",
            "sc",
            "&sc->sc_dev"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "audio_attach_mi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "394-408",
          "snippet": "void\naudio_attach_mi(ahwp, hdlp, dev)\n\tstruct audio_hw_if *ahwp;\n\tvoid *hdlp;\n\tstruct device *dev;\n{\n\tstruct audio_attach_args arg;\n\n\tif (ahwp != NULL) {\n\t\targ.type = AUDIODEV_TYPE_AUDIO;\n\t\targ.hwif = ahwp;\n\t\targ.hdl = hdlp;\n\t\t(void)config_found(dev, &arg, audioprint);\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_attach_mi(ahwp, hdlp, dev)\n\tstruct audio_hw_if *ahwp;\n\tvoid *hdlp;\n\tstruct device *dev;\n{\n\tstruct audio_attach_args arg;\n\n\tif (ahwp != NULL) {\n\t\targ.type = AUDIODEV_TYPE_AUDIO;\n\t\targ.hwif = ahwp;\n\t\targ.hdl = hdlp;\n\t\t(void)config_found(dev, &arg, audioprint);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "eap1371_mixer_set_port",
          "args": [
            "sc",
            "&ctl"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "eap1371_mixer_set_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
          "lines": "1458-1467",
          "snippet": "int\neap1371_mixer_set_port(addr, cp)\n\tvoid *addr;\n\tmixer_ctrl_t *cp;\n{\n\tstruct eap_softc *sc = addr;\n\n\treturn ((sc->codec_if->vtbl->mixer_set_port)(sc->codec_if,\n\t\t\t\t\t\t     cp));\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/ac97.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\teap1371_mixer_set_port",
            "void *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\teap1371_mixer_set_port;\nvoid *\neap_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\neap1371_mixer_set_port(addr, cp)\n\tvoid *addr;\n\tmixer_ctrl_t *cp;\n{\n\tstruct eap_softc *sc = addr;\n\n\treturn ((sc->codec_if->vtbl->mixer_set_port)(sc->codec_if,\n\t\t\t\t\t\t     cp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "eap1371_get_portnum_by_name",
          "args": [
            "sc",
            "AudioCrecord",
            "AudioNsource",
            "NULL"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "eap1371_get_portnum_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
          "lines": "1490-1497",
          "snippet": "int\neap1371_get_portnum_by_name(sc, class, device, qualifier)\n\tstruct eap_softc *sc;\n\tchar *class, *device, *qualifier;\n{\n\treturn ((sc->codec_if->vtbl->get_portnum_by_name)(sc->codec_if, class,\n             device, qualifier));\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/ac97.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int     eap1371_get_portnum_by_name"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint     eap1371_get_portnum_by_name;\n\nint\neap1371_get_portnum_by_name(sc, class, device, qualifier)\n\tstruct eap_softc *sc;\n\tchar *class, *device, *qualifier;\n{\n\treturn ((sc->codec_if->vtbl->get_portnum_by_name)(sc->codec_if, class,\n             device, qualifier));\n}"
        }
      },
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "EAP_SIC",
            "EAP_P2_INTR_EN | EAP_R1_INTR_EN"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ac97_attach",
          "args": [
            "&sc->host_if"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "ac97_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ac97.c",
          "lines": "476-557",
          "snippet": "int \nac97_attach(hostIf)\n\tstruct ac97_host_if *hostIf;\n{\n\tstruct ac97_softc *as;\n\tint error, i, j;\n\tu_int16_t id1, id2, caps;\n\tu_int32_t id;\n\tmixer_ctrl_t ctl;\n\n\tas = malloc(sizeof(struct ac97_softc), M_DEVBUF, M_WAITOK);\n\n\tif (!as) return (ENOMEM);\n\n\tas->codecIf.vtbl = &ac97civ;\n\tas->hostIf = hostIf;\n\n\tif ((error = hostIf->attach(hostIf->arg, &as->codecIf))) {\n\t\tfree (as, M_DEVBUF);\n\t\treturn (error);\n\t}\n\n\thostIf->reset(hostIf->arg);\n\tDELAY(1000);\n\n\thostIf->write(hostIf->arg, AC97_REG_POWER, 0);\n\thostIf->write(hostIf->arg, AC97_REG_RESET, 0);\n\tDELAY(10000);\n\n\tif ((error = hostIf->read(hostIf->arg, AC97_REG_VENDOR_ID1, &id1)))\n\t\treturn (error);\n\n\tif ((error = hostIf->read(hostIf->arg, AC97_REG_VENDOR_ID2, &id2)))\n\t\treturn (error);\n\n\tif ((error = hostIf->read(hostIf->arg, AC97_REG_RESET, &caps)))\n\t\treturn (error);\n\n\tid = (id1 << 16) | id2;\n\n\tprintf(\"ac97: codec id 0x%8x\", id);\n\tfor (i = 0; ac97codecid[i].id; i++) {\n\t\tif (ac97codecid[i].id == id) \n\t\t\tprintf(\" (%s)\", ac97codecid[i].name);\n\t}\n\tprintf(\"\\nac97: codec features \");\n\tfor (i = j = 0; i < 10; i++) {\n\t\tif (caps & (1 << i)) {\n\t\t\tprintf(\"%s%s\", j? \", \" : \"\", ac97feature[i]);\n\t\t\tj++;\n\t\t}\n\t}\n\n\tprintf(\"%s%s\\n\", j? \", \" : \"\", ac97enhancement[(caps >> 10) & 0x1f]);\n\n\tac97_setup_source_info(as);\n\n\t/* Just enable the DAC and master volumes by default */\n\tbzero(&ctl, sizeof(ctl));\n\n\tctl.type = AUDIO_MIXER_ENUM;\n\tctl.un.ord = 0;  /* off */\n\tctl.dev = ac97_get_portnum_by_name(&as->codecIf, AudioCoutputs,\n\t\t\t\t\t   AudioNmaster, AudioNmute);\n\tac97_mixer_set_port(&as->codecIf, &ctl);\n\tctl.dev = ac97_get_portnum_by_name(&as->codecIf, AudioCinputs,\n\t\t\t\t\t   AudioNdac, AudioNmute);\n\t\n\tac97_mixer_set_port(&as->codecIf, &ctl);\n\tctl.dev = ac97_get_portnum_by_name(&as->codecIf, AudioCrecord,\n\t\t\t\t\t   AudioNvolume, AudioNmute);\n\tac97_mixer_set_port(&as->codecIf, &ctl);\n\t\t\n\t\t\n\tctl.dev = ac97_get_portnum_by_name(&as->codecIf, AudioCrecord,\n\t\t\t\t\t   AudioNsource, NULL);\n\tctl.type = AUDIO_MIXER_ENUM;\n\tctl.un.ord = 0;\n\tac97_mixer_set_port(&as->codecIf, &ctl);\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/ic/ac97.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define AC97_REG_VENDOR_ID2           0x7e",
            "#define AC97_REG_VENDOR_ID1           0x7c",
            "#define AC97_REG_POWER                0x26",
            "#define AC97_REG_RESET                0x00"
          ],
          "globals_used": [
            "int ac97_mixer_set_port",
            "int ac97_get_portnum_by_name",
            "struct ac97_codec_if_vtbl ac97civ = {\n\tac97_mixer_get_port, \n\tac97_mixer_set_port,\n\tac97_query_devinfo,\n\tac97_get_portnum_by_name\n};",
            "static struct ac97_codecid {\n\tu_int32_t id;\n\tchar *name;\n} ac97codecid[] = {\n\t{ 0x414B4D00, \"Asahi Kasei AK4540\" \t},\n\t{ 0x43525900, \"Cirrus Logic CS4297\" \t},\n\t{ 0x83847600, \"SigmaTel STAC????\" \t},\n\t{ 0x83847604, \"SigmaTel STAC9701/3/4/5\" },\n\t{ 0x83847605, \"SigmaTel STAC9704\" \t},\n\t{ 0x83847608, \"SigmaTel STAC9708\" \t},\n\t{ 0x83847609, \"SigmaTel STAC9721\" \t},\n\t{ 0, \t      NULL\t\t\t}\n};",
            "static char *ac97enhancement[] = {\n\t\"No 3D Stereo\",\n\t\"Analog Devices Phat Stereo\",\n\t\"Creative\"\n\t\"National Semi 3D\",\n\t\"Yamaha Ymersion\",\n\t\"BBE 3D\",\n\t\"Crystal Semi 3D\"\n\t\"Qsound QXpander\",\n\t\"Spatializer 3D\",\n\t\"SRS 3D\",\n\t\"Platform Tech 3D\",\n\t\"AKM 3D\",\n\t\"Aureal\",\n\t\"AZTECH 3D\",\n\t\"Binaura 3D\",\n\t\"ESS Technology\",\n\t\"Harman International VMAx\",\n\t\"Nvidea 3D\",\n\t\"Philips Incredible Sound\",\n\t\"Texas Instruments' 3D\",\n\t\"VLSI Technology 3D\",\n\t\"TriTech 3D\",\n\t\"Realtek 3D\",\n\t\"Samsung 3D\",\n\t\"Wolfson Microelectronics 3D\",\n\t\"Delta Integration 3D\",\n\t\"SigmaTel 3D\",\n\t\"Unknown 3D\",\n\t\"Rockwell 3D\",\n\t\"Unknown 3D\",\n\t\"Unknown 3D\",\n\t\"Unknown 3D\",\n};",
            "static char *ac97feature[] = {\n\t\"mic channel\",\n\t\"reserved\",\n\t\"tone\",\n\t\"simulated stereo\",\n\t\"headphone\",\n\t\"bass boost\",\n\t\"18 bit DAC\",\n\t\"20 bit DAC\",\n\t\"18 bit ADC\",\n\t\"20 bit ADC\"\n};",
            "void ac97_setup_source_info"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ac97.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define AC97_REG_VENDOR_ID2           0x7e\n#define AC97_REG_VENDOR_ID1           0x7c\n#define AC97_REG_POWER                0x26\n#define AC97_REG_RESET                0x00\n\nint ac97_mixer_set_port;\nint ac97_get_portnum_by_name;\nstruct ac97_codec_if_vtbl ac97civ = {\n\tac97_mixer_get_port, \n\tac97_mixer_set_port,\n\tac97_query_devinfo,\n\tac97_get_portnum_by_name\n};\nstatic struct ac97_codecid {\n\tu_int32_t id;\n\tchar *name;\n} ac97codecid[] = {\n\t{ 0x414B4D00, \"Asahi Kasei AK4540\" \t},\n\t{ 0x43525900, \"Cirrus Logic CS4297\" \t},\n\t{ 0x83847600, \"SigmaTel STAC????\" \t},\n\t{ 0x83847604, \"SigmaTel STAC9701/3/4/5\" },\n\t{ 0x83847605, \"SigmaTel STAC9704\" \t},\n\t{ 0x83847608, \"SigmaTel STAC9708\" \t},\n\t{ 0x83847609, \"SigmaTel STAC9721\" \t},\n\t{ 0, \t      NULL\t\t\t}\n};\nstatic char *ac97enhancement[] = {\n\t\"No 3D Stereo\",\n\t\"Analog Devices Phat Stereo\",\n\t\"Creative\"\n\t\"National Semi 3D\",\n\t\"Yamaha Ymersion\",\n\t\"BBE 3D\",\n\t\"Crystal Semi 3D\"\n\t\"Qsound QXpander\",\n\t\"Spatializer 3D\",\n\t\"SRS 3D\",\n\t\"Platform Tech 3D\",\n\t\"AKM 3D\",\n\t\"Aureal\",\n\t\"AZTECH 3D\",\n\t\"Binaura 3D\",\n\t\"ESS Technology\",\n\t\"Harman International VMAx\",\n\t\"Nvidea 3D\",\n\t\"Philips Incredible Sound\",\n\t\"Texas Instruments' 3D\",\n\t\"VLSI Technology 3D\",\n\t\"TriTech 3D\",\n\t\"Realtek 3D\",\n\t\"Samsung 3D\",\n\t\"Wolfson Microelectronics 3D\",\n\t\"Delta Integration 3D\",\n\t\"SigmaTel 3D\",\n\t\"Unknown 3D\",\n\t\"Rockwell 3D\",\n\t\"Unknown 3D\",\n\t\"Unknown 3D\",\n\t\"Unknown 3D\",\n};\nstatic char *ac97feature[] = {\n\t\"mic channel\",\n\t\"reserved\",\n\t\"tone\",\n\t\"simulated stereo\",\n\t\"headphone\",\n\t\"bass boost\",\n\t\"18 bit DAC\",\n\t\"20 bit DAC\",\n\t\"18 bit ADC\",\n\t\"20 bit ADC\"\n};\nvoid ac97_setup_source_info;\n\nint \nac97_attach(hostIf)\n\tstruct ac97_host_if *hostIf;\n{\n\tstruct ac97_softc *as;\n\tint error, i, j;\n\tu_int16_t id1, id2, caps;\n\tu_int32_t id;\n\tmixer_ctrl_t ctl;\n\n\tas = malloc(sizeof(struct ac97_softc), M_DEVBUF, M_WAITOK);\n\n\tif (!as) return (ENOMEM);\n\n\tas->codecIf.vtbl = &ac97civ;\n\tas->hostIf = hostIf;\n\n\tif ((error = hostIf->attach(hostIf->arg, &as->codecIf))) {\n\t\tfree (as, M_DEVBUF);\n\t\treturn (error);\n\t}\n\n\thostIf->reset(hostIf->arg);\n\tDELAY(1000);\n\n\thostIf->write(hostIf->arg, AC97_REG_POWER, 0);\n\thostIf->write(hostIf->arg, AC97_REG_RESET, 0);\n\tDELAY(10000);\n\n\tif ((error = hostIf->read(hostIf->arg, AC97_REG_VENDOR_ID1, &id1)))\n\t\treturn (error);\n\n\tif ((error = hostIf->read(hostIf->arg, AC97_REG_VENDOR_ID2, &id2)))\n\t\treturn (error);\n\n\tif ((error = hostIf->read(hostIf->arg, AC97_REG_RESET, &caps)))\n\t\treturn (error);\n\n\tid = (id1 << 16) | id2;\n\n\tprintf(\"ac97: codec id 0x%8x\", id);\n\tfor (i = 0; ac97codecid[i].id; i++) {\n\t\tif (ac97codecid[i].id == id) \n\t\t\tprintf(\" (%s)\", ac97codecid[i].name);\n\t}\n\tprintf(\"\\nac97: codec features \");\n\tfor (i = j = 0; i < 10; i++) {\n\t\tif (caps & (1 << i)) {\n\t\t\tprintf(\"%s%s\", j? \", \" : \"\", ac97feature[i]);\n\t\t\tj++;\n\t\t}\n\t}\n\n\tprintf(\"%s%s\\n\", j? \", \" : \"\", ac97enhancement[(caps >> 10) & 0x1f]);\n\n\tac97_setup_source_info(as);\n\n\t/* Just enable the DAC and master volumes by default */\n\tbzero(&ctl, sizeof(ctl));\n\n\tctl.type = AUDIO_MIXER_ENUM;\n\tctl.un.ord = 0;  /* off */\n\tctl.dev = ac97_get_portnum_by_name(&as->codecIf, AudioCoutputs,\n\t\t\t\t\t   AudioNmaster, AudioNmute);\n\tac97_mixer_set_port(&as->codecIf, &ctl);\n\tctl.dev = ac97_get_portnum_by_name(&as->codecIf, AudioCinputs,\n\t\t\t\t\t   AudioNdac, AudioNmute);\n\t\n\tac97_mixer_set_port(&as->codecIf, &ctl);\n\tctl.dev = ac97_get_portnum_by_name(&as->codecIf, AudioCrecord,\n\t\t\t\t\t   AudioNvolume, AudioNmute);\n\tac97_mixer_set_port(&as->codecIf, &ctl);\n\t\t\n\t\t\n\tctl.dev = ac97_get_portnum_by_name(&as->codecIf, AudioCrecord,\n\t\t\t\t\t   AudioNsource, NULL);\n\tctl.type = AUDIO_MIXER_ENUM;\n\tctl.un.ord = 0;\n\tac97_mixer_set_port(&as->codecIf, &ctl);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "E1371_SRC",
            "0"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eap1371_set_dac_rate",
          "args": [
            "sc",
            "22050",
            "2"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "eap1371_set_dac_rate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
          "lines": "728-757",
          "snippet": "void\neap1371_set_dac_rate(sc, rate, which)\n\tstruct eap_softc *sc;\n\tint rate;\n\tint which;\n{\n        int dac = (which == 1) ? ESRC_DAC1 : ESRC_DAC2;\n\tint freq, r;\n \n        /* Whatever, it works, so I'll leave it :) */\n\n        if (rate > 48000)\n            rate = 48000;\n        if (rate < 4000)\n            rate = 4000;\n        freq = ((rate << 15) + 1500) / 3000;\n        \n        eap1371_src_wait(sc);\n        r = EREAD4(sc, E1371_SRC) & (E1371_SRC_DISABLE | \n            E1371_SRC_DISP2 | E1371_SRC_DISP1 | E1371_SRC_DISREC);\n        r |= (which == 1) ? E1371_SRC_DISP1 : E1371_SRC_DISP2;\n        EWRITE4(sc, E1371_SRC, r);\n        r = eap1371_src_read(sc, dac + ESRC_IREGS) & 0x00ff;\n        eap1371_src_write(sc, dac + ESRC_IREGS, r | ((freq >> 5) & 0xfc00));\n        eap1371_src_write(sc, dac + ESRC_VFF, freq & 0x7fff);\n        r = EREAD4(sc, E1371_SRC) & (E1371_SRC_DISABLE | \n            E1371_SRC_DISP2 | E1371_SRC_DISP1 | E1371_SRC_DISREC);\n        r &= ~((which == 1) ? E1371_SRC_DISP1 : E1371_SRC_DISP2);\n        EWRITE4(sc, E1371_SRC, r);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/ac97.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define  ESRC_VFF\t\t0x03",
            "#define  ESRC_IREGS\t\t0x01",
            "#define ESRC_DAC2\t\t0x70",
            "#define ESRC_DAC1\t\t0x74",
            "#define  E1371_SRC_DISREC       (1<<19)",
            "#define  E1371_SRC_DISP2        (1<<20)",
            "#define  E1371_SRC_DISP1\t(1<<21)",
            "#define  E1371_SRC_DISABLE\t(1<<22)",
            "#define E1371_SRC\t\t0x10"
          ],
          "globals_used": [
            "int\teap1371_src_wait",
            "void \teap1371_set_dac_rate",
            "int\teap1371_src_read",
            "void\teap1371_src_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define  ESRC_VFF\t\t0x03\n#define  ESRC_IREGS\t\t0x01\n#define ESRC_DAC2\t\t0x70\n#define ESRC_DAC1\t\t0x74\n#define  E1371_SRC_DISREC       (1<<19)\n#define  E1371_SRC_DISP2        (1<<20)\n#define  E1371_SRC_DISP1\t(1<<21)\n#define  E1371_SRC_DISABLE\t(1<<22)\n#define E1371_SRC\t\t0x10\n\nint\teap1371_src_wait;\nvoid \teap1371_set_dac_rate;\nint\teap1371_src_read;\nvoid\teap1371_src_write;\n\nvoid\neap1371_set_dac_rate(sc, rate, which)\n\tstruct eap_softc *sc;\n\tint rate;\n\tint which;\n{\n        int dac = (which == 1) ? ESRC_DAC1 : ESRC_DAC2;\n\tint freq, r;\n \n        /* Whatever, it works, so I'll leave it :) */\n\n        if (rate > 48000)\n            rate = 48000;\n        if (rate < 4000)\n            rate = 4000;\n        freq = ((rate << 15) + 1500) / 3000;\n        \n        eap1371_src_wait(sc);\n        r = EREAD4(sc, E1371_SRC) & (E1371_SRC_DISABLE | \n            E1371_SRC_DISP2 | E1371_SRC_DISP1 | E1371_SRC_DISREC);\n        r |= (which == 1) ? E1371_SRC_DISP1 : E1371_SRC_DISP2;\n        EWRITE4(sc, E1371_SRC, r);\n        r = eap1371_src_read(sc, dac + ESRC_IREGS) & 0x00ff;\n        eap1371_src_write(sc, dac + ESRC_IREGS, r | ((freq >> 5) & 0xfc00));\n        eap1371_src_write(sc, dac + ESRC_VFF, freq & 0x7fff);\n        r = EREAD4(sc, E1371_SRC) & (E1371_SRC_DISABLE | \n            E1371_SRC_DISP2 | E1371_SRC_DISP1 | E1371_SRC_DISREC);\n        r &= ~((which == 1) ? E1371_SRC_DISP1 : E1371_SRC_DISP2);\n        EWRITE4(sc, E1371_SRC, r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eap1371_set_adc_rate",
          "args": [
            "sc",
            "22050"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "eap1371_set_adc_rate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
          "lines": "688-726",
          "snippet": "void\neap1371_set_adc_rate(sc, rate)\n\tstruct eap_softc *sc;\n\tint rate;\n{\n\tint freq, n, truncm;\n\tint out;\n\n        /* Whatever, it works, so I'll leave it :) */\n\n        if (rate > 48000)\n            rate = 48000;\n        if (rate < 4000)\n            rate = 4000;\n        n = rate / 3000;\n        if ((1 << n) & SRC_MAGIC)\n                n--;\n        truncm = ((21 * n) - 1) | 1;\n        freq = ((48000 << 15) / rate) * n;\n        if (rate >= 24000) {\n                if (truncm > 239)\n                        truncm = 239;\n\t\tout = ESRC_SET_TRUNC((239 - truncm) / 2);\n        } else {\n                if (truncm > 119)\n                        truncm = 119;\n\t\tout = ESRC_SMF | ESRC_SET_TRUNC((119 - truncm) / 2);\n        }\n \tout |= ESRC_SET_N(n);\n        eap1371_src_write(sc, ESRC_ADC+ESRC_TRUNC_N, out);\n\n      \n        out = eap1371_src_read(sc, ESRC_ADC+ESRC_IREGS) & 0xff;\n        eap1371_src_write(sc, ESRC_ADC+ESRC_IREGS, out | \n\t\t\t  ESRC_SET_VFI(freq >> 15));\n        eap1371_src_write(sc, ESRC_ADC+ESRC_VFF, freq & 0x7fff);\n        eap1371_src_write(sc, ESRC_ADC_VOLL, ESRC_SET_ADC_VOL(n));\n        eap1371_src_write(sc, ESRC_ADC_VOLR, ESRC_SET_ADC_VOL(n));\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/ac97.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define  SRC_MAGIC ((1<15)|(1<<13)|(1<<11)|(1<<9))",
            "#define ESRC_SMF\t\t0x8000",
            "#define  ESRC_VFF\t\t0x03",
            "#define  ESRC_IREGS\t\t0x01",
            "#define  ESRC_TRUNC_N\t\t0x00",
            "#define ESRC_ADC_VOLR\t\t0x6d",
            "#define ESRC_ADC_VOLL\t\t0x6c",
            "#define ESRC_ADC\t\t0x78"
          ],
          "globals_used": [
            "void \teap1371_set_adc_rate",
            "int\teap1371_src_read",
            "void\teap1371_src_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define  SRC_MAGIC ((1<15)|(1<<13)|(1<<11)|(1<<9))\n#define ESRC_SMF\t\t0x8000\n#define  ESRC_VFF\t\t0x03\n#define  ESRC_IREGS\t\t0x01\n#define  ESRC_TRUNC_N\t\t0x00\n#define ESRC_ADC_VOLR\t\t0x6d\n#define ESRC_ADC_VOLL\t\t0x6c\n#define ESRC_ADC\t\t0x78\n\nvoid \teap1371_set_adc_rate;\nint\teap1371_src_read;\nvoid\teap1371_src_write;\n\nvoid\neap1371_set_adc_rate(sc, rate)\n\tstruct eap_softc *sc;\n\tint rate;\n{\n\tint freq, n, truncm;\n\tint out;\n\n        /* Whatever, it works, so I'll leave it :) */\n\n        if (rate > 48000)\n            rate = 48000;\n        if (rate < 4000)\n            rate = 4000;\n        n = rate / 3000;\n        if ((1 << n) & SRC_MAGIC)\n                n--;\n        truncm = ((21 * n) - 1) | 1;\n        freq = ((48000 << 15) / rate) * n;\n        if (rate >= 24000) {\n                if (truncm > 239)\n                        truncm = 239;\n\t\tout = ESRC_SET_TRUNC((239 - truncm) / 2);\n        } else {\n                if (truncm > 119)\n                        truncm = 119;\n\t\tout = ESRC_SMF | ESRC_SET_TRUNC((119 - truncm) / 2);\n        }\n \tout |= ESRC_SET_N(n);\n        eap1371_src_write(sc, ESRC_ADC+ESRC_TRUNC_N, out);\n\n      \n        out = eap1371_src_read(sc, ESRC_ADC+ESRC_IREGS) & 0xff;\n        eap1371_src_write(sc, ESRC_ADC+ESRC_IREGS, out | \n\t\t\t  ESRC_SET_VFI(freq >> 15));\n        eap1371_src_write(sc, ESRC_ADC+ESRC_VFF, freq & 0x7fff);\n        eap1371_src_write(sc, ESRC_ADC_VOLL, ESRC_SET_ADC_VOL(n));\n        eap1371_src_write(sc, ESRC_ADC_VOLR, ESRC_SET_ADC_VOL(n));\n}"
        }
      },
      {
        "call_info": {
          "callee": "eap1371_src_write",
          "args": [
            "sc",
            "ESRC_DAC2_VOLR",
            "ESRC_SET_DAC_VOLI(1)"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "eap1371_src_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
          "lines": "674-686",
          "snippet": "void\neap1371_src_write(sc, a, d)\n\tstruct eap_softc *sc;\n\tint a,d;\n{\n\tint r;\n\n\tr = eap1371_src_wait(sc);\n\tr &= (E1371_SRC_DISABLE | E1371_SRC_DISP1 |\n\t    E1371_SRC_DISP2 | E1371_SRC_DISREC);\n\tr |= E1371_SRC_RAMWE | E1371_SRC_ADDR(a) | E1371_SRC_DATA(d);\n\tEWRITE4(sc, E1371_SRC, r);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/ac97.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define  E1371_SRC_DISREC       (1<<19)",
            "#define  E1371_SRC_DISP2        (1<<20)",
            "#define  E1371_SRC_DISP1\t(1<<21)",
            "#define  E1371_SRC_DISABLE\t(1<<22)",
            "#define  E1371_SRC_RAMWE\t(1<<24)",
            "#define E1371_SRC\t\t0x10"
          ],
          "globals_used": [
            "int\teap1371_src_wait",
            "void\teap1371_src_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define  E1371_SRC_DISREC       (1<<19)\n#define  E1371_SRC_DISP2        (1<<20)\n#define  E1371_SRC_DISP1\t(1<<21)\n#define  E1371_SRC_DISABLE\t(1<<22)\n#define  E1371_SRC_RAMWE\t(1<<24)\n#define E1371_SRC\t\t0x10\n\nint\teap1371_src_wait;\nvoid\teap1371_src_write;\n\nvoid\neap1371_src_write(sc, a, d)\n\tstruct eap_softc *sc;\n\tint a,d;\n{\n\tint r;\n\n\tr = eap1371_src_wait(sc);\n\tr &= (E1371_SRC_DISABLE | E1371_SRC_DISP1 |\n\t    E1371_SRC_DISP2 | E1371_SRC_DISREC);\n\tr |= E1371_SRC_RAMWE | E1371_SRC_ADDR(a) | E1371_SRC_DATA(d);\n\tEWRITE4(sc, E1371_SRC, r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ESRC_SET_DAC_VOLI",
          "args": [
            "1"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESRC_SET_DAC_VOLI",
          "args": [
            "1"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESRC_SET_DAC_VOLI",
          "args": [
            "1"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESRC_SET_DAC_VOLI",
          "args": [
            "1"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESRC_SET_ADC_VOL",
          "args": [
            "16"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESRC_SET_ADC_VOL",
          "args": [
            "16"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESRC_SET_VFI",
          "args": [
            "16"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESRC_SET_VFI",
          "args": [
            "16"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESRC_SET_N",
          "args": [
            "16"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESRC_SET_N",
          "args": [
            "16"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "E1371_SRC",
            "E1371_SRC_DISABLE"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "EAP_ICSC",
            "0"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "20"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "EAP_ICSC",
            "E1371_SYNC_RES"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "EAP_ICSS",
            "CT5880_AC97_RESET"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_PRODUCT",
          "args": [
            "pa->pa_id"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "E1371_LEGACY",
            "0"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "EAP_ICSC",
            "0"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "EAP_SIC",
            "0"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eap_hw_if->set_port",
          "args": [
            "sc",
            "&ctl"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eap_hw_if->set_port",
          "args": [
            "sc",
            "&ctl"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eap_hw_if->set_port",
          "args": [
            "sc",
            "&ctl"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eap_hw_if->set_port",
          "args": [
            "sc",
            "&ctl"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eap_hw_if->set_port",
          "args": [
            "sc",
            "&ctl"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eap_write_codec",
          "args": [
            "sc",
            "AK_CS",
            "0x0"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "eap_write_codec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
          "lines": "488-506",
          "snippet": "void\neap_write_codec(sc, a, d)\n\tstruct eap_softc *sc;\n\tint a, d;\n{\n\n\tint icss, to;\n\t\n\tto = EAP_WRITE_TIMEOUT;\n\tdo {\n\t\ticss = EREAD4(sc, EAP_ICSS);\n\t\tDPRINTFN(5,(\"eap: codec %d prog: icss=0x%08x\\n\", a, icss));\n                if (!to--) {\n                        printf(\"eap: timeout writing to codec\\n\");\n                        return;\n                }\n\t} while (icss & EAP_CWRIP);  /* XXX could use CSTAT here */\n        EWRITE4(sc, EAP_CODEC, EAP_SET_CODEC(a, d));\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/ac97.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define EAP_WRITE_TIMEOUT\t0x1000",
            "#define EAP_CODEC\t\t0x10",
            "#define  EAP_CWRIP\t\t0x00000100",
            "#define EAP_ICSS\t\t0x04\t/* interrupt / chip select status */"
          ],
          "globals_used": [
            "void    eap_write_codec"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define EAP_WRITE_TIMEOUT\t0x1000\n#define EAP_CODEC\t\t0x10\n#define  EAP_CWRIP\t\t0x00000100\n#define EAP_ICSS\t\t0x04\t/* interrupt / chip select status */\n\nvoid    eap_write_codec;\n\nvoid\neap_write_codec(sc, a, d)\n\tstruct eap_softc *sc;\n\tint a, d;\n{\n\n\tint icss, to;\n\t\n\tto = EAP_WRITE_TIMEOUT;\n\tdo {\n\t\ticss = EREAD4(sc, EAP_ICSS);\n\t\tDPRINTFN(5,(\"eap: codec %d prog: icss=0x%08x\\n\", a, icss));\n                if (!to--) {\n                        printf(\"eap: timeout writing to codec\\n\");\n                        return;\n                }\n\t} while (icss & EAP_CWRIP);  /* XXX could use CSTAT here */\n        EWRITE4(sc, EAP_CODEC, EAP_SET_CODEC(a, d));\n}"
        }
      },
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "EAP_ICSC",
            "EAP_CDC_EN"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "EAP_SIC",
            "EAP_P2_INTR_EN | EAP_R1_INTR_EN"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\": %s\\n\"",
            "intrstr"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_intr_establish",
          "args": [
            "pc",
            "ih",
            "IPL_AUDIO",
            "eap_intr",
            "sc",
            "sc->sc_dev.dv_xname"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_string",
          "args": [
            "pc",
            "ih"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_map",
          "args": [
            "pc",
            "pa->pa_intrtag",
            "pa->pa_intrpin",
            "pa->pa_intrline",
            "&ih"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_write",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "PCI_COMMAND_STATUS_REG",
            "csr | PCI_COMMAND_MASTER_ENABLE"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "pa->pa_pc",
            "pa->pa_tag",
            "PCI_COMMAND_STATUS_REG"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_mapreg_map",
          "args": [
            "pa",
            "PCI_CBIO",
            "PCI_MAPREG_TYPE_IO",
            "0",
            "&sc->iot",
            "&sc->ioh",
            "NULL",
            "NULL"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "pci_mapreg_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci_map.c",
          "lines": "230-275",
          "snippet": "int\npci_mapreg_map(pa, reg, type, busflags, tagp, handlep, basep, sizep)\n\tstruct pci_attach_args *pa;\n\tint reg, busflags;\n\tpcireg_t type;\n\tbus_space_tag_t *tagp;\n\tbus_space_handle_t *handlep;\n\tbus_addr_t *basep;\n\tbus_size_t *sizep;\n{\n\tbus_space_tag_t tag;\n\tbus_space_handle_t handle;\n\tbus_addr_t base;\n\tbus_size_t size;\n\tint flags;\n\n\tif (PCI_MAPREG_TYPE(type) == PCI_MAPREG_TYPE_IO) {\n\t\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_io_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t     &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_iot;\n\t} else {\n\t\tif ((pa->pa_flags & PCI_FLAGS_MEM_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_mem_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t      &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_memt;\n\t}\n\n\tif (bus_space_map(tag, base, size, busflags | flags, &handle))\n\t\treturn (1);\n\n\tif (tagp != 0)\n\t\t*tagp = tag;\n\tif (handlep != 0)\n\t\t*handlep = handle;\n\tif (basep != 0)\n\t\t*basep = base;\n\tif (sizep != 0)\n\t\t*sizep = size;\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nbsd_pci_io_find",
            "static int nbsd_pci_mem_find"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int nbsd_pci_io_find;\nstatic int nbsd_pci_mem_find;\n\nint\npci_mapreg_map(pa, reg, type, busflags, tagp, handlep, basep, sizep)\n\tstruct pci_attach_args *pa;\n\tint reg, busflags;\n\tpcireg_t type;\n\tbus_space_tag_t *tagp;\n\tbus_space_handle_t *handlep;\n\tbus_addr_t *basep;\n\tbus_size_t *sizep;\n{\n\tbus_space_tag_t tag;\n\tbus_space_handle_t handle;\n\tbus_addr_t base;\n\tbus_size_t size;\n\tint flags;\n\n\tif (PCI_MAPREG_TYPE(type) == PCI_MAPREG_TYPE_IO) {\n\t\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_io_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t     &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_iot;\n\t} else {\n\t\tif ((pa->pa_flags & PCI_FLAGS_MEM_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_mem_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t      &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_memt;\n\t}\n\n\tif (bus_space_map(tag, base, size, busflags | flags, &handle))\n\t\treturn (1);\n\n\tif (tagp != 0)\n\t\t*tagp = tag;\n\tif (handlep != 0)\n\t\t*handlep = handle;\n\tif (basep != 0)\n\t\t*basep = base;\n\tif (sizep != 0)\n\t\t*sizep = size;\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PCI_PRODUCT",
          "args": [
            "pa->pa_id"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tEAP_MIC_PREAMP\t\t9\n#define EAP_OUTPUT_SELECT\t8\n#define\tEAP_RECORD_SOURCE \t7\n#define EAP_MIC_VOL\t\t6\n#define EAP_AUX_VOL\t\t5\n#define EAP_LINE_VOL\t\t4\n#define EAP_CD_VOL\t\t3\n#define EAP_FM_VOL\t\t2\n#define EAP_VOICE_VOL\t\t1\n#define EAP_MASTER_VOL\t\t0\n#define VOL_0DB 200\n#define AK_CS\t\t\t0x17\n#define  AK_NRST\t\t0x01\n#define  AK_PD\t\t\t0x02\n#define AK_RESET\t\t0x16\n#define  EAP_R1_INTR_EN\t\t0x00000400\n#define  EAP_P2_INTR_EN\t\t0x00000200\n#define EAP_SIC\t\t\t0x20\n#define  ESRC_IREGS\t\t0x01\n#define  ESRC_TRUNC_N\t\t0x00\n#define ESRC_DAC2_VOLR\t\t0x7f\n#define ESRC_DAC2_VOLL\t\t0x7e\n#define ESRC_DAC1_VOLR\t\t0x7d\n#define ESRC_DAC1_VOLL\t\t0x7c\n#define ESRC_ADC_VOLR\t\t0x6d\n#define ESRC_ADC_VOLL\t\t0x6c\n#define ESRC_DAC2\t\t0x70\n#define ESRC_DAC1\t\t0x74\n#define E1371_LEGACY\t\t0x18\n#define  E1371_SRC_DISABLE\t(1<<22)\n#define E1371_SRC\t\t0x10\n#define  CT5880_AC97_RESET      0x20000000\n#define EAP_ICSS\t\t0x04\t/* interrupt / chip select status */\n#define  E1371_SYNC_RES\t\t(1<<14)\n#define  EAP_CDC_EN\t\t0x00000002\n#define EAP_ICSC\t\t0x00    /* interrupt / chip select control */\n#define\tPCI_CBIO\t\t0x10\n\nvoid\teap_attach;\nint\teap_intr;\nvoid    eap_write_codec;\nint\teap1371_mixer_set_port;\nvoid \teap1371_set_adc_rate;\nvoid \teap1371_set_dac_rate;\nvoid\teap1371_src_write;\nint     eap1371_attach_codec;\nint\teap1371_read_codec;\nint\teap1371_write_codec;\nvoid    eap1371_reset_codec;\nint     eap1371_get_portnum_by_name;\nstruct audio_hw_if eap1370_hw_if = {\n\teap_open,\n\teap_close,\n\tNULL,\n\teap_query_encoding,\n\teap_set_params,\n\teap_round_blocksize,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\teap_halt_output,\n\teap_halt_input,\n\tNULL,\n\teap_getdev,\n\tNULL,\n\teap_mixer_set_port,\n\teap_mixer_get_port,\n\teap_query_devinfo,\n\teap_malloc,\n\teap_free,\n\teap_round_buffersize,\n\teap_mappage,\n\teap_get_props,\n\teap_trigger_output,\n\teap_trigger_input,\n};\nstruct audio_hw_if eap1371_hw_if = {\n\teap_open,\n\teap_close,\n\tNULL,\n\teap_query_encoding,\n\teap_set_params,\n\teap_round_blocksize,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n\teap_halt_output,\n\teap_halt_input,\n\tNULL,\n\teap_getdev,\n\tNULL,\n\teap1371_mixer_set_port,\n\teap1371_mixer_get_port,\n\teap1371_query_devinfo,\n\teap_malloc,\n\teap_free,\n\teap_round_buffersize,\n\teap_mappage,\n\teap_get_props,\n\teap_trigger_output,\n\teap_trigger_input,\n};\n\nvoid\neap_attach(parent, self, aux)\n\tstruct device *parent;\n\tstruct device *self;\n\tvoid *aux;\n{\n\tstruct eap_softc *sc = (struct eap_softc *)self;\n\tstruct pci_attach_args *pa = (struct pci_attach_args *)aux;\n\tpci_chipset_tag_t pc = pa->pa_pc;\n\tstruct audio_hw_if *eap_hw_if;\n\tchar const *intrstr;\n\tpci_intr_handle_t ih;\n\tpcireg_t csr;\n\tmixer_ctrl_t ctl;\n\tint i;\n\n\tsc->sc_1371 = \n\t    !(PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ENSONIQ_AUDIOPCI);\n\n\t/* Map I/O register */\n\tif (pci_mapreg_map(pa, PCI_CBIO, PCI_MAPREG_TYPE_IO, 0,\n\t\t\t   &sc->iot, &sc->ioh, NULL, NULL)) {\n\t\tprintf(\"\\n%s: can't map i/o space\\n\", sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\n\tsc->sc_dmatag = pa->pa_dmat;\n\n\t/* Enable the device. */\n\tcsr = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);\n\tpci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,\n\t\t       csr | PCI_COMMAND_MASTER_ENABLE);\n\n\t/* Map and establish the interrupt. */\n\tif (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,\n\t\t\t pa->pa_intrline, &ih)) {\n\t\tprintf(\"\\n%s: couldn't map interrupt\\n\", sc->sc_dev.dv_xname);\n\t\treturn;\n\t}\n\tintrstr = pci_intr_string(pc, ih);\n\tsc->sc_ih = pci_intr_establish(pc, ih, IPL_AUDIO, eap_intr, sc, \n\t\t\t\t       sc->sc_dev.dv_xname);\n\tif (sc->sc_ih == NULL) {\n\t\tprintf(\"\\n%s: couldn't establish interrupt\",\n\t\t       sc->sc_dev.dv_xname);\n\t\tif (intrstr != NULL)\n\t\t\tprintf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t}\n\tprintf(\": %s\\n\", intrstr);\n\n\tif (!sc->sc_1371) {\n\t\t/* Enable interrupts and looping mode. */\n\t\t/* enable the parts we need */\n\t\tEWRITE4(sc, EAP_SIC, EAP_P2_INTR_EN | EAP_R1_INTR_EN);\n\t\tEWRITE4(sc, EAP_ICSC, EAP_CDC_EN); \n\n\t\t/* reset codec */\t\n\t\t/* normal operation */ \n\t\t/* select codec clocks */\n\t\teap_write_codec(sc, AK_RESET, AK_PD); \n\t\teap_write_codec(sc, AK_RESET, AK_PD | AK_NRST);\n\t\teap_write_codec(sc, AK_CS, 0x0);\n\n\t\teap_hw_if = &eap1370_hw_if;\n\n\t\t/* Enable all relevant mixer switches. */\n\t\tctl.dev = EAP_OUTPUT_SELECT;\n\t\tctl.type = AUDIO_MIXER_SET;\n\t\tctl.un.mask = 1 << EAP_VOICE_VOL | 1 << EAP_FM_VOL | \n\t\t\t1 << EAP_CD_VOL | 1 << EAP_LINE_VOL | 1 << EAP_AUX_VOL |\n\t\t\t1 << EAP_MIC_VOL;\n\t\teap_hw_if->set_port(sc, &ctl);\n\n\t\tctl.type = AUDIO_MIXER_VALUE;\n\t\tctl.un.value.num_channels = 1;\n\t\tfor (ctl.dev = EAP_MASTER_VOL; ctl.dev < EAP_MIC_VOL; \n\t\t     ctl.dev++) {\n\t\t\tctl.un.value.level[AUDIO_MIXER_LEVEL_MONO] = VOL_0DB;\n\t\t\teap_hw_if->set_port(sc, &ctl);\n\t\t}\n\t\tctl.un.value.level[AUDIO_MIXER_LEVEL_MONO] = 0;\n\t\teap_hw_if->set_port(sc, &ctl);\n\t\tctl.dev = EAP_MIC_PREAMP;\n\t\tctl.type = AUDIO_MIXER_ENUM;\n\t\tctl.un.ord = 0;\n\t\teap_hw_if->set_port(sc, &ctl);\n\t\tctl.dev = EAP_RECORD_SOURCE;\n\t\tctl.type = AUDIO_MIXER_SET;\n\t\tctl.un.mask = 1 << EAP_MIC_VOL;\n\t\teap_hw_if->set_port(sc, &ctl);\n\t} else {\n\t\tint error;\n\n                /* clean slate */\n                EWRITE4(sc, EAP_SIC, 0);\n                EWRITE4(sc, EAP_ICSC, 0);\n                EWRITE4(sc, E1371_LEGACY, 0);\n\n\t\tif (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ENSONIQ_CT5880) {\n\t\t\tEWRITE4(sc, EAP_ICSS, CT5880_AC97_RESET);\n\n\t\t\tdelay(20000);\n\t\t}\n\n                /* Reset from es1371's perspective */\n                EWRITE4(sc, EAP_ICSC, E1371_SYNC_RES);\n                delay(20);\n                EWRITE4(sc, EAP_ICSC, 0);\n\n                /* must properly reprogram sample rate converter,\n                 * or it locks up.  Set some defaults for the life of the\n                 * machine, and set up a sb default sample rate.\n                 */\n                EWRITE4(sc, E1371_SRC, E1371_SRC_DISABLE);\n                for (i=0; i<0x80; i++)\n                        eap1371_src_write(sc, i, 0);\n\t\teap1371_src_write(sc, ESRC_DAC1+ESRC_TRUNC_N, ESRC_SET_N(16));\n\t\teap1371_src_write(sc, ESRC_DAC2+ESRC_TRUNC_N, ESRC_SET_N(16));\n                eap1371_src_write(sc, ESRC_DAC1+ESRC_IREGS, ESRC_SET_VFI(16));\n                eap1371_src_write(sc, ESRC_DAC2+ESRC_IREGS, ESRC_SET_VFI(16));\n                eap1371_src_write(sc, ESRC_ADC_VOLL, ESRC_SET_ADC_VOL(16));\n                eap1371_src_write(sc, ESRC_ADC_VOLR, ESRC_SET_ADC_VOL(16));\n\t\teap1371_src_write(sc, ESRC_DAC1_VOLL, ESRC_SET_DAC_VOLI(1));\n\t\teap1371_src_write(sc, ESRC_DAC1_VOLR, ESRC_SET_DAC_VOLI(1));\n\t\teap1371_src_write(sc, ESRC_DAC2_VOLL, ESRC_SET_DAC_VOLI(1));\n\t\teap1371_src_write(sc, ESRC_DAC2_VOLR, ESRC_SET_DAC_VOLI(1));\n                eap1371_set_adc_rate(sc, 22050);\n                eap1371_set_dac_rate(sc, 22050, 1);\n                eap1371_set_dac_rate(sc, 22050, 2);\n             \n                EWRITE4(sc, E1371_SRC, 0);\n\n                /* Reset codec */\n\n\t\t/* Interrupt enable */\n\t\tsc->host_if.arg = sc;\n\t\tsc->host_if.attach = eap1371_attach_codec;\n\t\tsc->host_if.read = eap1371_read_codec;\n\n\t\tsc->host_if.write = eap1371_write_codec;\n\t\tsc->host_if.reset = eap1371_reset_codec;\n\t\t\n\t\tif ((error = ac97_attach(&sc->host_if)) == 0) {\n\t\t\t/* Interrupt enable */\n\t\t\tEWRITE4(sc, EAP_SIC, EAP_P2_INTR_EN | EAP_R1_INTR_EN);\n\t\t} else\n\t\t\treturn;\n\n\t\teap_hw_if = &eap1371_hw_if;\n\n\t\t/* Just enable the DAC and master volumes by default */\n\t\tctl.type = AUDIO_MIXER_ENUM;\n\t\tctl.un.ord = 0;  /* off */\n\t\tctl.dev = eap1371_get_portnum_by_name(sc, AudioCoutputs,\n\t\t       AudioNmaster, AudioNmute);\n\t\teap1371_mixer_set_port(sc, &ctl);\n\t\tctl.dev = eap1371_get_portnum_by_name(sc, AudioCinputs,\n\t\t       AudioNdac, AudioNmute);\n\t\teap1371_mixer_set_port(sc, &ctl);\n\t\tctl.dev = eap1371_get_portnum_by_name(sc, AudioCrecord,\n\t\t       AudioNvolume, AudioNmute);\n\t\teap1371_mixer_set_port(sc, &ctl);\n\t\t\n\t\t\n\t\tctl.dev = eap1371_get_portnum_by_name(sc, AudioCrecord,\n\t\t       AudioNsource, NULL);\n\t\tctl.type = AUDIO_MIXER_ENUM;\n\t\tctl.un.ord = 0;\n\t\teap1371_mixer_set_port(sc, &ctl);\n\n        }\n\n\taudio_attach_mi(eap_hw_if, sc, &sc->sc_dev);\n}"
  },
  {
    "function_name": "eap1371_set_dac_rate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
    "lines": "728-757",
    "snippet": "void\neap1371_set_dac_rate(sc, rate, which)\n\tstruct eap_softc *sc;\n\tint rate;\n\tint which;\n{\n        int dac = (which == 1) ? ESRC_DAC1 : ESRC_DAC2;\n\tint freq, r;\n \n        /* Whatever, it works, so I'll leave it :) */\n\n        if (rate > 48000)\n            rate = 48000;\n        if (rate < 4000)\n            rate = 4000;\n        freq = ((rate << 15) + 1500) / 3000;\n        \n        eap1371_src_wait(sc);\n        r = EREAD4(sc, E1371_SRC) & (E1371_SRC_DISABLE | \n            E1371_SRC_DISP2 | E1371_SRC_DISP1 | E1371_SRC_DISREC);\n        r |= (which == 1) ? E1371_SRC_DISP1 : E1371_SRC_DISP2;\n        EWRITE4(sc, E1371_SRC, r);\n        r = eap1371_src_read(sc, dac + ESRC_IREGS) & 0x00ff;\n        eap1371_src_write(sc, dac + ESRC_IREGS, r | ((freq >> 5) & 0xfc00));\n        eap1371_src_write(sc, dac + ESRC_VFF, freq & 0x7fff);\n        r = EREAD4(sc, E1371_SRC) & (E1371_SRC_DISABLE | \n            E1371_SRC_DISP2 | E1371_SRC_DISP1 | E1371_SRC_DISREC);\n        r &= ~((which == 1) ? E1371_SRC_DISP1 : E1371_SRC_DISP2);\n        EWRITE4(sc, E1371_SRC, r);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/ac97.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define  ESRC_VFF\t\t0x03",
      "#define  ESRC_IREGS\t\t0x01",
      "#define ESRC_DAC2\t\t0x70",
      "#define ESRC_DAC1\t\t0x74",
      "#define  E1371_SRC_DISREC       (1<<19)",
      "#define  E1371_SRC_DISP2        (1<<20)",
      "#define  E1371_SRC_DISP1\t(1<<21)",
      "#define  E1371_SRC_DISABLE\t(1<<22)",
      "#define E1371_SRC\t\t0x10"
    ],
    "globals_used": [
      "int\teap1371_src_wait",
      "void \teap1371_set_dac_rate",
      "int\teap1371_src_read",
      "void\teap1371_src_write"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "E1371_SRC",
            "r"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EREAD4",
          "args": [
            "sc",
            "E1371_SRC"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eap1371_src_write",
          "args": [
            "sc",
            "dac + ESRC_VFF",
            "freq & 0x7fff"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "eap1371_src_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
          "lines": "674-686",
          "snippet": "void\neap1371_src_write(sc, a, d)\n\tstruct eap_softc *sc;\n\tint a,d;\n{\n\tint r;\n\n\tr = eap1371_src_wait(sc);\n\tr &= (E1371_SRC_DISABLE | E1371_SRC_DISP1 |\n\t    E1371_SRC_DISP2 | E1371_SRC_DISREC);\n\tr |= E1371_SRC_RAMWE | E1371_SRC_ADDR(a) | E1371_SRC_DATA(d);\n\tEWRITE4(sc, E1371_SRC, r);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/ac97.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define  E1371_SRC_DISREC       (1<<19)",
            "#define  E1371_SRC_DISP2        (1<<20)",
            "#define  E1371_SRC_DISP1\t(1<<21)",
            "#define  E1371_SRC_DISABLE\t(1<<22)",
            "#define  E1371_SRC_RAMWE\t(1<<24)",
            "#define E1371_SRC\t\t0x10"
          ],
          "globals_used": [
            "int\teap1371_src_wait",
            "void\teap1371_src_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define  E1371_SRC_DISREC       (1<<19)\n#define  E1371_SRC_DISP2        (1<<20)\n#define  E1371_SRC_DISP1\t(1<<21)\n#define  E1371_SRC_DISABLE\t(1<<22)\n#define  E1371_SRC_RAMWE\t(1<<24)\n#define E1371_SRC\t\t0x10\n\nint\teap1371_src_wait;\nvoid\teap1371_src_write;\n\nvoid\neap1371_src_write(sc, a, d)\n\tstruct eap_softc *sc;\n\tint a,d;\n{\n\tint r;\n\n\tr = eap1371_src_wait(sc);\n\tr &= (E1371_SRC_DISABLE | E1371_SRC_DISP1 |\n\t    E1371_SRC_DISP2 | E1371_SRC_DISREC);\n\tr |= E1371_SRC_RAMWE | E1371_SRC_ADDR(a) | E1371_SRC_DATA(d);\n\tEWRITE4(sc, E1371_SRC, r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eap1371_src_read",
          "args": [
            "sc",
            "dac + ESRC_IREGS"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "eap1371_src_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
          "lines": "641-672",
          "snippet": "int\neap1371_src_read(sc, a)\n\tstruct eap_softc *sc;\n\tint a;\n{\n\tint r, to;\n\tint src;\n\n\tsrc = eap1371_src_wait(sc);\n\n\tEWRITE4(sc, E1371_SRC, \n\t    (src & (E1371_SRC_DISABLE | E1371_SRC_DISP1 |\n\t\tE1371_SRC_DISP2 | E1371_SRC_DISREC)) |\n\t    E1371_SRC_ADDR(a) | 0x10000UL);\n\n\tr = eap1371_src_wait(sc);\n\n\tif ((r & E1371_SRC_STATE_MASK) != E1371_SRC_STATE_OK) {\n\t\tfor (to = 0; to < EAP_READ_TIMEOUT; to++) {\n\t\t\tr = EREAD4(sc, E1371_SRC);\n\t\t\tif ((r & E1371_SRC_STATE_MASK) == \n\t\t\t    E1371_SRC_STATE_OK) break;\n\t\t}\n\t}\n\n\tEWRITE4 (sc, E1371_SRC,\n\t    (src & (E1371_SRC_DISABLE | E1371_SRC_DISP1 |\n\t    E1371_SRC_DISP2 | E1371_SRC_DISREC)) |\n\t    E1371_SRC_ADDR(a));\n\n\treturn r;\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/ac97.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define EAP_READ_TIMEOUT        0x1000",
            "#define  E1371_SRC_STATE_OK     0x010000",
            "#define  E1371_SRC_STATE_MASK   0x870000",
            "#define  E1371_SRC_DISREC       (1<<19)",
            "#define  E1371_SRC_DISP2        (1<<20)",
            "#define  E1371_SRC_DISP1\t(1<<21)",
            "#define  E1371_SRC_DISABLE\t(1<<22)",
            "#define E1371_SRC\t\t0x10"
          ],
          "globals_used": [
            "int\teap1371_src_wait",
            "int\teap1371_src_read"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define EAP_READ_TIMEOUT        0x1000\n#define  E1371_SRC_STATE_OK     0x010000\n#define  E1371_SRC_STATE_MASK   0x870000\n#define  E1371_SRC_DISREC       (1<<19)\n#define  E1371_SRC_DISP2        (1<<20)\n#define  E1371_SRC_DISP1\t(1<<21)\n#define  E1371_SRC_DISABLE\t(1<<22)\n#define E1371_SRC\t\t0x10\n\nint\teap1371_src_wait;\nint\teap1371_src_read;\n\nint\neap1371_src_read(sc, a)\n\tstruct eap_softc *sc;\n\tint a;\n{\n\tint r, to;\n\tint src;\n\n\tsrc = eap1371_src_wait(sc);\n\n\tEWRITE4(sc, E1371_SRC, \n\t    (src & (E1371_SRC_DISABLE | E1371_SRC_DISP1 |\n\t\tE1371_SRC_DISP2 | E1371_SRC_DISREC)) |\n\t    E1371_SRC_ADDR(a) | 0x10000UL);\n\n\tr = eap1371_src_wait(sc);\n\n\tif ((r & E1371_SRC_STATE_MASK) != E1371_SRC_STATE_OK) {\n\t\tfor (to = 0; to < EAP_READ_TIMEOUT; to++) {\n\t\t\tr = EREAD4(sc, E1371_SRC);\n\t\t\tif ((r & E1371_SRC_STATE_MASK) == \n\t\t\t    E1371_SRC_STATE_OK) break;\n\t\t}\n\t}\n\n\tEWRITE4 (sc, E1371_SRC,\n\t    (src & (E1371_SRC_DISABLE | E1371_SRC_DISP1 |\n\t    E1371_SRC_DISP2 | E1371_SRC_DISREC)) |\n\t    E1371_SRC_ADDR(a));\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "E1371_SRC",
            "r"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EREAD4",
          "args": [
            "sc",
            "E1371_SRC"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eap1371_src_wait",
          "args": [
            "sc"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "eap1371_src_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
          "lines": "620-639",
          "snippet": "int\neap1371_src_wait(sc)\n\tstruct eap_softc *sc;\n{\n        int to;\n        int src;\n\n\tfor (to = 0; to < EAP_READ_TIMEOUT; to++) {\n\t\tsrc = EREAD4(sc, E1371_SRC);\n\t\tif (!(src & E1371_SRC_RBUSY))\n\t\t\treturn src;\n\t\tdelay(1);\n\t}\n\n\t\n\tprintf(\"eap: timeout waiting for sample rate\"\n\t    \"converter\\n\");\n\n\treturn src;\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/ac97.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define EAP_READ_TIMEOUT        0x1000",
            "#define  E1371_SRC_RBUSY\t(1<<23)",
            "#define E1371_SRC\t\t0x10"
          ],
          "globals_used": [
            "int\teap1371_src_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define EAP_READ_TIMEOUT        0x1000\n#define  E1371_SRC_RBUSY\t(1<<23)\n#define E1371_SRC\t\t0x10\n\nint\teap1371_src_wait;\n\nint\neap1371_src_wait(sc)\n\tstruct eap_softc *sc;\n{\n        int to;\n        int src;\n\n\tfor (to = 0; to < EAP_READ_TIMEOUT; to++) {\n\t\tsrc = EREAD4(sc, E1371_SRC);\n\t\tif (!(src & E1371_SRC_RBUSY))\n\t\t\treturn src;\n\t\tdelay(1);\n\t}\n\n\t\n\tprintf(\"eap: timeout waiting for sample rate\"\n\t    \"converter\\n\");\n\n\treturn src;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define  ESRC_VFF\t\t0x03\n#define  ESRC_IREGS\t\t0x01\n#define ESRC_DAC2\t\t0x70\n#define ESRC_DAC1\t\t0x74\n#define  E1371_SRC_DISREC       (1<<19)\n#define  E1371_SRC_DISP2        (1<<20)\n#define  E1371_SRC_DISP1\t(1<<21)\n#define  E1371_SRC_DISABLE\t(1<<22)\n#define E1371_SRC\t\t0x10\n\nint\teap1371_src_wait;\nvoid \teap1371_set_dac_rate;\nint\teap1371_src_read;\nvoid\teap1371_src_write;\n\nvoid\neap1371_set_dac_rate(sc, rate, which)\n\tstruct eap_softc *sc;\n\tint rate;\n\tint which;\n{\n        int dac = (which == 1) ? ESRC_DAC1 : ESRC_DAC2;\n\tint freq, r;\n \n        /* Whatever, it works, so I'll leave it :) */\n\n        if (rate > 48000)\n            rate = 48000;\n        if (rate < 4000)\n            rate = 4000;\n        freq = ((rate << 15) + 1500) / 3000;\n        \n        eap1371_src_wait(sc);\n        r = EREAD4(sc, E1371_SRC) & (E1371_SRC_DISABLE | \n            E1371_SRC_DISP2 | E1371_SRC_DISP1 | E1371_SRC_DISREC);\n        r |= (which == 1) ? E1371_SRC_DISP1 : E1371_SRC_DISP2;\n        EWRITE4(sc, E1371_SRC, r);\n        r = eap1371_src_read(sc, dac + ESRC_IREGS) & 0x00ff;\n        eap1371_src_write(sc, dac + ESRC_IREGS, r | ((freq >> 5) & 0xfc00));\n        eap1371_src_write(sc, dac + ESRC_VFF, freq & 0x7fff);\n        r = EREAD4(sc, E1371_SRC) & (E1371_SRC_DISABLE | \n            E1371_SRC_DISP2 | E1371_SRC_DISP1 | E1371_SRC_DISREC);\n        r &= ~((which == 1) ? E1371_SRC_DISP1 : E1371_SRC_DISP2);\n        EWRITE4(sc, E1371_SRC, r);\n}"
  },
  {
    "function_name": "eap1371_set_adc_rate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
    "lines": "688-726",
    "snippet": "void\neap1371_set_adc_rate(sc, rate)\n\tstruct eap_softc *sc;\n\tint rate;\n{\n\tint freq, n, truncm;\n\tint out;\n\n        /* Whatever, it works, so I'll leave it :) */\n\n        if (rate > 48000)\n            rate = 48000;\n        if (rate < 4000)\n            rate = 4000;\n        n = rate / 3000;\n        if ((1 << n) & SRC_MAGIC)\n                n--;\n        truncm = ((21 * n) - 1) | 1;\n        freq = ((48000 << 15) / rate) * n;\n        if (rate >= 24000) {\n                if (truncm > 239)\n                        truncm = 239;\n\t\tout = ESRC_SET_TRUNC((239 - truncm) / 2);\n        } else {\n                if (truncm > 119)\n                        truncm = 119;\n\t\tout = ESRC_SMF | ESRC_SET_TRUNC((119 - truncm) / 2);\n        }\n \tout |= ESRC_SET_N(n);\n        eap1371_src_write(sc, ESRC_ADC+ESRC_TRUNC_N, out);\n\n      \n        out = eap1371_src_read(sc, ESRC_ADC+ESRC_IREGS) & 0xff;\n        eap1371_src_write(sc, ESRC_ADC+ESRC_IREGS, out | \n\t\t\t  ESRC_SET_VFI(freq >> 15));\n        eap1371_src_write(sc, ESRC_ADC+ESRC_VFF, freq & 0x7fff);\n        eap1371_src_write(sc, ESRC_ADC_VOLL, ESRC_SET_ADC_VOL(n));\n        eap1371_src_write(sc, ESRC_ADC_VOLR, ESRC_SET_ADC_VOL(n));\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/ac97.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define  SRC_MAGIC ((1<15)|(1<<13)|(1<<11)|(1<<9))",
      "#define ESRC_SMF\t\t0x8000",
      "#define  ESRC_VFF\t\t0x03",
      "#define  ESRC_IREGS\t\t0x01",
      "#define  ESRC_TRUNC_N\t\t0x00",
      "#define ESRC_ADC_VOLR\t\t0x6d",
      "#define ESRC_ADC_VOLL\t\t0x6c",
      "#define ESRC_ADC\t\t0x78"
    ],
    "globals_used": [
      "void \teap1371_set_adc_rate",
      "int\teap1371_src_read",
      "void\teap1371_src_write"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eap1371_src_write",
          "args": [
            "sc",
            "ESRC_ADC_VOLR",
            "ESRC_SET_ADC_VOL(n)"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "eap1371_src_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
          "lines": "674-686",
          "snippet": "void\neap1371_src_write(sc, a, d)\n\tstruct eap_softc *sc;\n\tint a,d;\n{\n\tint r;\n\n\tr = eap1371_src_wait(sc);\n\tr &= (E1371_SRC_DISABLE | E1371_SRC_DISP1 |\n\t    E1371_SRC_DISP2 | E1371_SRC_DISREC);\n\tr |= E1371_SRC_RAMWE | E1371_SRC_ADDR(a) | E1371_SRC_DATA(d);\n\tEWRITE4(sc, E1371_SRC, r);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/ac97.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define  E1371_SRC_DISREC       (1<<19)",
            "#define  E1371_SRC_DISP2        (1<<20)",
            "#define  E1371_SRC_DISP1\t(1<<21)",
            "#define  E1371_SRC_DISABLE\t(1<<22)",
            "#define  E1371_SRC_RAMWE\t(1<<24)",
            "#define E1371_SRC\t\t0x10"
          ],
          "globals_used": [
            "int\teap1371_src_wait",
            "void\teap1371_src_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define  E1371_SRC_DISREC       (1<<19)\n#define  E1371_SRC_DISP2        (1<<20)\n#define  E1371_SRC_DISP1\t(1<<21)\n#define  E1371_SRC_DISABLE\t(1<<22)\n#define  E1371_SRC_RAMWE\t(1<<24)\n#define E1371_SRC\t\t0x10\n\nint\teap1371_src_wait;\nvoid\teap1371_src_write;\n\nvoid\neap1371_src_write(sc, a, d)\n\tstruct eap_softc *sc;\n\tint a,d;\n{\n\tint r;\n\n\tr = eap1371_src_wait(sc);\n\tr &= (E1371_SRC_DISABLE | E1371_SRC_DISP1 |\n\t    E1371_SRC_DISP2 | E1371_SRC_DISREC);\n\tr |= E1371_SRC_RAMWE | E1371_SRC_ADDR(a) | E1371_SRC_DATA(d);\n\tEWRITE4(sc, E1371_SRC, r);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ESRC_SET_ADC_VOL",
          "args": [
            "n"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESRC_SET_ADC_VOL",
          "args": [
            "n"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESRC_SET_VFI",
          "args": [
            "freq >> 15"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eap1371_src_read",
          "args": [
            "sc",
            "ESRC_ADC+ESRC_IREGS"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "eap1371_src_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
          "lines": "641-672",
          "snippet": "int\neap1371_src_read(sc, a)\n\tstruct eap_softc *sc;\n\tint a;\n{\n\tint r, to;\n\tint src;\n\n\tsrc = eap1371_src_wait(sc);\n\n\tEWRITE4(sc, E1371_SRC, \n\t    (src & (E1371_SRC_DISABLE | E1371_SRC_DISP1 |\n\t\tE1371_SRC_DISP2 | E1371_SRC_DISREC)) |\n\t    E1371_SRC_ADDR(a) | 0x10000UL);\n\n\tr = eap1371_src_wait(sc);\n\n\tif ((r & E1371_SRC_STATE_MASK) != E1371_SRC_STATE_OK) {\n\t\tfor (to = 0; to < EAP_READ_TIMEOUT; to++) {\n\t\t\tr = EREAD4(sc, E1371_SRC);\n\t\t\tif ((r & E1371_SRC_STATE_MASK) == \n\t\t\t    E1371_SRC_STATE_OK) break;\n\t\t}\n\t}\n\n\tEWRITE4 (sc, E1371_SRC,\n\t    (src & (E1371_SRC_DISABLE | E1371_SRC_DISP1 |\n\t    E1371_SRC_DISP2 | E1371_SRC_DISREC)) |\n\t    E1371_SRC_ADDR(a));\n\n\treturn r;\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/ac97.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define EAP_READ_TIMEOUT        0x1000",
            "#define  E1371_SRC_STATE_OK     0x010000",
            "#define  E1371_SRC_STATE_MASK   0x870000",
            "#define  E1371_SRC_DISREC       (1<<19)",
            "#define  E1371_SRC_DISP2        (1<<20)",
            "#define  E1371_SRC_DISP1\t(1<<21)",
            "#define  E1371_SRC_DISABLE\t(1<<22)",
            "#define E1371_SRC\t\t0x10"
          ],
          "globals_used": [
            "int\teap1371_src_wait",
            "int\teap1371_src_read"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define EAP_READ_TIMEOUT        0x1000\n#define  E1371_SRC_STATE_OK     0x010000\n#define  E1371_SRC_STATE_MASK   0x870000\n#define  E1371_SRC_DISREC       (1<<19)\n#define  E1371_SRC_DISP2        (1<<20)\n#define  E1371_SRC_DISP1\t(1<<21)\n#define  E1371_SRC_DISABLE\t(1<<22)\n#define E1371_SRC\t\t0x10\n\nint\teap1371_src_wait;\nint\teap1371_src_read;\n\nint\neap1371_src_read(sc, a)\n\tstruct eap_softc *sc;\n\tint a;\n{\n\tint r, to;\n\tint src;\n\n\tsrc = eap1371_src_wait(sc);\n\n\tEWRITE4(sc, E1371_SRC, \n\t    (src & (E1371_SRC_DISABLE | E1371_SRC_DISP1 |\n\t\tE1371_SRC_DISP2 | E1371_SRC_DISREC)) |\n\t    E1371_SRC_ADDR(a) | 0x10000UL);\n\n\tr = eap1371_src_wait(sc);\n\n\tif ((r & E1371_SRC_STATE_MASK) != E1371_SRC_STATE_OK) {\n\t\tfor (to = 0; to < EAP_READ_TIMEOUT; to++) {\n\t\t\tr = EREAD4(sc, E1371_SRC);\n\t\t\tif ((r & E1371_SRC_STATE_MASK) == \n\t\t\t    E1371_SRC_STATE_OK) break;\n\t\t}\n\t}\n\n\tEWRITE4 (sc, E1371_SRC,\n\t    (src & (E1371_SRC_DISABLE | E1371_SRC_DISP1 |\n\t    E1371_SRC_DISP2 | E1371_SRC_DISREC)) |\n\t    E1371_SRC_ADDR(a));\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ESRC_SET_N",
          "args": [
            "n"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESRC_SET_TRUNC",
          "args": [
            "(119 - truncm) / 2"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESRC_SET_TRUNC",
          "args": [
            "(239 - truncm) / 2"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define  SRC_MAGIC ((1<15)|(1<<13)|(1<<11)|(1<<9))\n#define ESRC_SMF\t\t0x8000\n#define  ESRC_VFF\t\t0x03\n#define  ESRC_IREGS\t\t0x01\n#define  ESRC_TRUNC_N\t\t0x00\n#define ESRC_ADC_VOLR\t\t0x6d\n#define ESRC_ADC_VOLL\t\t0x6c\n#define ESRC_ADC\t\t0x78\n\nvoid \teap1371_set_adc_rate;\nint\teap1371_src_read;\nvoid\teap1371_src_write;\n\nvoid\neap1371_set_adc_rate(sc, rate)\n\tstruct eap_softc *sc;\n\tint rate;\n{\n\tint freq, n, truncm;\n\tint out;\n\n        /* Whatever, it works, so I'll leave it :) */\n\n        if (rate > 48000)\n            rate = 48000;\n        if (rate < 4000)\n            rate = 4000;\n        n = rate / 3000;\n        if ((1 << n) & SRC_MAGIC)\n                n--;\n        truncm = ((21 * n) - 1) | 1;\n        freq = ((48000 << 15) / rate) * n;\n        if (rate >= 24000) {\n                if (truncm > 239)\n                        truncm = 239;\n\t\tout = ESRC_SET_TRUNC((239 - truncm) / 2);\n        } else {\n                if (truncm > 119)\n                        truncm = 119;\n\t\tout = ESRC_SMF | ESRC_SET_TRUNC((119 - truncm) / 2);\n        }\n \tout |= ESRC_SET_N(n);\n        eap1371_src_write(sc, ESRC_ADC+ESRC_TRUNC_N, out);\n\n      \n        out = eap1371_src_read(sc, ESRC_ADC+ESRC_IREGS) & 0xff;\n        eap1371_src_write(sc, ESRC_ADC+ESRC_IREGS, out | \n\t\t\t  ESRC_SET_VFI(freq >> 15));\n        eap1371_src_write(sc, ESRC_ADC+ESRC_VFF, freq & 0x7fff);\n        eap1371_src_write(sc, ESRC_ADC_VOLL, ESRC_SET_ADC_VOL(n));\n        eap1371_src_write(sc, ESRC_ADC_VOLR, ESRC_SET_ADC_VOL(n));\n}"
  },
  {
    "function_name": "eap1371_src_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
    "lines": "674-686",
    "snippet": "void\neap1371_src_write(sc, a, d)\n\tstruct eap_softc *sc;\n\tint a,d;\n{\n\tint r;\n\n\tr = eap1371_src_wait(sc);\n\tr &= (E1371_SRC_DISABLE | E1371_SRC_DISP1 |\n\t    E1371_SRC_DISP2 | E1371_SRC_DISREC);\n\tr |= E1371_SRC_RAMWE | E1371_SRC_ADDR(a) | E1371_SRC_DATA(d);\n\tEWRITE4(sc, E1371_SRC, r);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/ac97.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define  E1371_SRC_DISREC       (1<<19)",
      "#define  E1371_SRC_DISP2        (1<<20)",
      "#define  E1371_SRC_DISP1\t(1<<21)",
      "#define  E1371_SRC_DISABLE\t(1<<22)",
      "#define  E1371_SRC_RAMWE\t(1<<24)",
      "#define E1371_SRC\t\t0x10"
    ],
    "globals_used": [
      "int\teap1371_src_wait",
      "void\teap1371_src_write"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "E1371_SRC",
            "r"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "E1371_SRC_DATA",
          "args": [
            "d"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "E1371_SRC_ADDR",
          "args": [
            "a"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eap1371_src_wait",
          "args": [
            "sc"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "eap1371_src_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
          "lines": "620-639",
          "snippet": "int\neap1371_src_wait(sc)\n\tstruct eap_softc *sc;\n{\n        int to;\n        int src;\n\n\tfor (to = 0; to < EAP_READ_TIMEOUT; to++) {\n\t\tsrc = EREAD4(sc, E1371_SRC);\n\t\tif (!(src & E1371_SRC_RBUSY))\n\t\t\treturn src;\n\t\tdelay(1);\n\t}\n\n\t\n\tprintf(\"eap: timeout waiting for sample rate\"\n\t    \"converter\\n\");\n\n\treturn src;\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/ac97.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define EAP_READ_TIMEOUT        0x1000",
            "#define  E1371_SRC_RBUSY\t(1<<23)",
            "#define E1371_SRC\t\t0x10"
          ],
          "globals_used": [
            "int\teap1371_src_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define EAP_READ_TIMEOUT        0x1000\n#define  E1371_SRC_RBUSY\t(1<<23)\n#define E1371_SRC\t\t0x10\n\nint\teap1371_src_wait;\n\nint\neap1371_src_wait(sc)\n\tstruct eap_softc *sc;\n{\n        int to;\n        int src;\n\n\tfor (to = 0; to < EAP_READ_TIMEOUT; to++) {\n\t\tsrc = EREAD4(sc, E1371_SRC);\n\t\tif (!(src & E1371_SRC_RBUSY))\n\t\t\treturn src;\n\t\tdelay(1);\n\t}\n\n\t\n\tprintf(\"eap: timeout waiting for sample rate\"\n\t    \"converter\\n\");\n\n\treturn src;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define  E1371_SRC_DISREC       (1<<19)\n#define  E1371_SRC_DISP2        (1<<20)\n#define  E1371_SRC_DISP1\t(1<<21)\n#define  E1371_SRC_DISABLE\t(1<<22)\n#define  E1371_SRC_RAMWE\t(1<<24)\n#define E1371_SRC\t\t0x10\n\nint\teap1371_src_wait;\nvoid\teap1371_src_write;\n\nvoid\neap1371_src_write(sc, a, d)\n\tstruct eap_softc *sc;\n\tint a,d;\n{\n\tint r;\n\n\tr = eap1371_src_wait(sc);\n\tr &= (E1371_SRC_DISABLE | E1371_SRC_DISP1 |\n\t    E1371_SRC_DISP2 | E1371_SRC_DISREC);\n\tr |= E1371_SRC_RAMWE | E1371_SRC_ADDR(a) | E1371_SRC_DATA(d);\n\tEWRITE4(sc, E1371_SRC, r);\n}"
  },
  {
    "function_name": "eap1371_src_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
    "lines": "641-672",
    "snippet": "int\neap1371_src_read(sc, a)\n\tstruct eap_softc *sc;\n\tint a;\n{\n\tint r, to;\n\tint src;\n\n\tsrc = eap1371_src_wait(sc);\n\n\tEWRITE4(sc, E1371_SRC, \n\t    (src & (E1371_SRC_DISABLE | E1371_SRC_DISP1 |\n\t\tE1371_SRC_DISP2 | E1371_SRC_DISREC)) |\n\t    E1371_SRC_ADDR(a) | 0x10000UL);\n\n\tr = eap1371_src_wait(sc);\n\n\tif ((r & E1371_SRC_STATE_MASK) != E1371_SRC_STATE_OK) {\n\t\tfor (to = 0; to < EAP_READ_TIMEOUT; to++) {\n\t\t\tr = EREAD4(sc, E1371_SRC);\n\t\t\tif ((r & E1371_SRC_STATE_MASK) == \n\t\t\t    E1371_SRC_STATE_OK) break;\n\t\t}\n\t}\n\n\tEWRITE4 (sc, E1371_SRC,\n\t    (src & (E1371_SRC_DISABLE | E1371_SRC_DISP1 |\n\t    E1371_SRC_DISP2 | E1371_SRC_DISREC)) |\n\t    E1371_SRC_ADDR(a));\n\n\treturn r;\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/ac97.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define EAP_READ_TIMEOUT        0x1000",
      "#define  E1371_SRC_STATE_OK     0x010000",
      "#define  E1371_SRC_STATE_MASK   0x870000",
      "#define  E1371_SRC_DISREC       (1<<19)",
      "#define  E1371_SRC_DISP2        (1<<20)",
      "#define  E1371_SRC_DISP1\t(1<<21)",
      "#define  E1371_SRC_DISABLE\t(1<<22)",
      "#define E1371_SRC\t\t0x10"
    ],
    "globals_used": [
      "int\teap1371_src_wait",
      "int\teap1371_src_read"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "E1371_SRC",
            "(src & (E1371_SRC_DISABLE | E1371_SRC_DISP1 |\n\t    E1371_SRC_DISP2 | E1371_SRC_DISREC)) |\n\t    E1371_SRC_ADDR(a)"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "E1371_SRC_ADDR",
          "args": [
            "a"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EREAD4",
          "args": [
            "sc",
            "E1371_SRC"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eap1371_src_wait",
          "args": [
            "sc"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "eap1371_src_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
          "lines": "620-639",
          "snippet": "int\neap1371_src_wait(sc)\n\tstruct eap_softc *sc;\n{\n        int to;\n        int src;\n\n\tfor (to = 0; to < EAP_READ_TIMEOUT; to++) {\n\t\tsrc = EREAD4(sc, E1371_SRC);\n\t\tif (!(src & E1371_SRC_RBUSY))\n\t\t\treturn src;\n\t\tdelay(1);\n\t}\n\n\t\n\tprintf(\"eap: timeout waiting for sample rate\"\n\t    \"converter\\n\");\n\n\treturn src;\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/ac97.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define EAP_READ_TIMEOUT        0x1000",
            "#define  E1371_SRC_RBUSY\t(1<<23)",
            "#define E1371_SRC\t\t0x10"
          ],
          "globals_used": [
            "int\teap1371_src_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define EAP_READ_TIMEOUT        0x1000\n#define  E1371_SRC_RBUSY\t(1<<23)\n#define E1371_SRC\t\t0x10\n\nint\teap1371_src_wait;\n\nint\neap1371_src_wait(sc)\n\tstruct eap_softc *sc;\n{\n        int to;\n        int src;\n\n\tfor (to = 0; to < EAP_READ_TIMEOUT; to++) {\n\t\tsrc = EREAD4(sc, E1371_SRC);\n\t\tif (!(src & E1371_SRC_RBUSY))\n\t\t\treturn src;\n\t\tdelay(1);\n\t}\n\n\t\n\tprintf(\"eap: timeout waiting for sample rate\"\n\t    \"converter\\n\");\n\n\treturn src;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "E1371_SRC",
            "(src & (E1371_SRC_DISABLE | E1371_SRC_DISP1 |\n\t\tE1371_SRC_DISP2 | E1371_SRC_DISREC)) |\n\t    E1371_SRC_ADDR(a) | 0x10000UL"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "E1371_SRC_ADDR",
          "args": [
            "a"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define EAP_READ_TIMEOUT        0x1000\n#define  E1371_SRC_STATE_OK     0x010000\n#define  E1371_SRC_STATE_MASK   0x870000\n#define  E1371_SRC_DISREC       (1<<19)\n#define  E1371_SRC_DISP2        (1<<20)\n#define  E1371_SRC_DISP1\t(1<<21)\n#define  E1371_SRC_DISABLE\t(1<<22)\n#define E1371_SRC\t\t0x10\n\nint\teap1371_src_wait;\nint\teap1371_src_read;\n\nint\neap1371_src_read(sc, a)\n\tstruct eap_softc *sc;\n\tint a;\n{\n\tint r, to;\n\tint src;\n\n\tsrc = eap1371_src_wait(sc);\n\n\tEWRITE4(sc, E1371_SRC, \n\t    (src & (E1371_SRC_DISABLE | E1371_SRC_DISP1 |\n\t\tE1371_SRC_DISP2 | E1371_SRC_DISREC)) |\n\t    E1371_SRC_ADDR(a) | 0x10000UL);\n\n\tr = eap1371_src_wait(sc);\n\n\tif ((r & E1371_SRC_STATE_MASK) != E1371_SRC_STATE_OK) {\n\t\tfor (to = 0; to < EAP_READ_TIMEOUT; to++) {\n\t\t\tr = EREAD4(sc, E1371_SRC);\n\t\t\tif ((r & E1371_SRC_STATE_MASK) == \n\t\t\t    E1371_SRC_STATE_OK) break;\n\t\t}\n\t}\n\n\tEWRITE4 (sc, E1371_SRC,\n\t    (src & (E1371_SRC_DISABLE | E1371_SRC_DISP1 |\n\t    E1371_SRC_DISP2 | E1371_SRC_DISREC)) |\n\t    E1371_SRC_ADDR(a));\n\n\treturn r;\n}"
  },
  {
    "function_name": "eap1371_src_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
    "lines": "620-639",
    "snippet": "int\neap1371_src_wait(sc)\n\tstruct eap_softc *sc;\n{\n        int to;\n        int src;\n\n\tfor (to = 0; to < EAP_READ_TIMEOUT; to++) {\n\t\tsrc = EREAD4(sc, E1371_SRC);\n\t\tif (!(src & E1371_SRC_RBUSY))\n\t\t\treturn src;\n\t\tdelay(1);\n\t}\n\n\t\n\tprintf(\"eap: timeout waiting for sample rate\"\n\t    \"converter\\n\");\n\n\treturn src;\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/ac97.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define EAP_READ_TIMEOUT        0x1000",
      "#define  E1371_SRC_RBUSY\t(1<<23)",
      "#define E1371_SRC\t\t0x10"
    ],
    "globals_used": [
      "int\teap1371_src_wait"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"eap: timeout waiting for sample rate\"\n\t    \"converter\\n\""
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EREAD4",
          "args": [
            "sc",
            "E1371_SRC"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define EAP_READ_TIMEOUT        0x1000\n#define  E1371_SRC_RBUSY\t(1<<23)\n#define E1371_SRC\t\t0x10\n\nint\teap1371_src_wait;\n\nint\neap1371_src_wait(sc)\n\tstruct eap_softc *sc;\n{\n        int to;\n        int src;\n\n\tfor (to = 0; to < EAP_READ_TIMEOUT; to++) {\n\t\tsrc = EREAD4(sc, E1371_SRC);\n\t\tif (!(src & E1371_SRC_RBUSY))\n\t\t\treturn src;\n\t\tdelay(1);\n\t}\n\n\t\n\tprintf(\"eap: timeout waiting for sample rate\"\n\t    \"converter\\n\");\n\n\treturn src;\n}"
  },
  {
    "function_name": "eap1371_write_codec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
    "lines": "570-618",
    "snippet": "int\neap1371_write_codec(sc_, a, d)\n        void *sc_;\n\tu_int8_t a;\n\tu_int16_t d;\n{\n\tstruct eap_softc *sc = sc_;\n        int to;\n        int cdc, src;\n\n        to = EAP_WRITE_TIMEOUT;\n        do {\n                cdc = EREAD4(sc, E1371_CODEC);\n                if (!to--) {\n                        printf(\"eap: timeout writing to codec\\n\");\n                        return 1;\n                }\n        } while (cdc & E1371_CODEC_WIP);\n\n        /* just do it */\n\tsrc = (eap1371_src_wait(sc) & (E1371_SRC_DISABLE | E1371_SRC_DISP1 |\n\t\tE1371_SRC_DISP2 | E1371_SRC_DISREC)) ;\n\n\tEWRITE4(sc, E1371_SRC, src | 0x10000);\n\n\tfor (to = 0; to < EAP_WRITE_TIMEOUT; to++) {\n\t\tif (!(EREAD4(sc, E1371_SRC) & E1371_SRC_STATE_MASK))\n\t\t\tbreak;\n\n\t\tdelay(1);\n\t}\n\t\n\tfor (to = 0; to < EAP_WRITE_TIMEOUT; to++) {\n\t\tif ((EREAD4(sc, E1371_SRC) & E1371_SRC_STATE_MASK) ==\n\t\t\tE1371_SRC_STATE_OK)\n\t\t\tbreak;\n\n\t\tdelay(1);\n\t}\n\n        EWRITE4(sc, E1371_CODEC, E1371_SET_CODEC(a, d));\n\n\teap1371_src_wait(sc);\n\tEWRITE4(sc, E1371_SRC, src);\n\n        DPRINTFN(10, (\"eap1371: writing codec %x --> %x\\n\", d, a));\n\n        return (0);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/ac97.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define EAP_WRITE_TIMEOUT\t0x1000",
      "#define  E1371_SRC_STATE_OK     0x010000",
      "#define  E1371_SRC_STATE_MASK   0x870000",
      "#define  E1371_SRC_DISREC       (1<<19)",
      "#define  E1371_SRC_DISP2        (1<<20)",
      "#define  E1371_SRC_DISP1\t(1<<21)",
      "#define  E1371_SRC_DISABLE\t(1<<22)",
      "#define E1371_SRC\t\t0x10",
      "#define  E1371_CODEC_WIP\t(1<<30)",
      "#define E1371_CODEC\t\t0x14"
    ],
    "globals_used": [
      "int\teap1371_src_wait",
      "int\teap1371_write_codec"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"eap1371: writing codec %x --> %x\\n\", d, a)"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "E1371_SRC",
            "src"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eap1371_src_wait",
          "args": [
            "sc"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "eap1371_src_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
          "lines": "620-639",
          "snippet": "int\neap1371_src_wait(sc)\n\tstruct eap_softc *sc;\n{\n        int to;\n        int src;\n\n\tfor (to = 0; to < EAP_READ_TIMEOUT; to++) {\n\t\tsrc = EREAD4(sc, E1371_SRC);\n\t\tif (!(src & E1371_SRC_RBUSY))\n\t\t\treturn src;\n\t\tdelay(1);\n\t}\n\n\t\n\tprintf(\"eap: timeout waiting for sample rate\"\n\t    \"converter\\n\");\n\n\treturn src;\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/ac97.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define EAP_READ_TIMEOUT        0x1000",
            "#define  E1371_SRC_RBUSY\t(1<<23)",
            "#define E1371_SRC\t\t0x10"
          ],
          "globals_used": [
            "int\teap1371_src_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define EAP_READ_TIMEOUT        0x1000\n#define  E1371_SRC_RBUSY\t(1<<23)\n#define E1371_SRC\t\t0x10\n\nint\teap1371_src_wait;\n\nint\neap1371_src_wait(sc)\n\tstruct eap_softc *sc;\n{\n        int to;\n        int src;\n\n\tfor (to = 0; to < EAP_READ_TIMEOUT; to++) {\n\t\tsrc = EREAD4(sc, E1371_SRC);\n\t\tif (!(src & E1371_SRC_RBUSY))\n\t\t\treturn src;\n\t\tdelay(1);\n\t}\n\n\t\n\tprintf(\"eap: timeout waiting for sample rate\"\n\t    \"converter\\n\");\n\n\treturn src;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "E1371_CODEC",
            "E1371_SET_CODEC(a, d)"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "E1371_SET_CODEC",
          "args": [
            "a",
            "d"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EREAD4",
          "args": [
            "sc",
            "E1371_SRC"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EREAD4",
          "args": [
            "sc",
            "E1371_SRC"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "E1371_SRC",
            "src | 0x10000"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"eap: timeout writing to codec\\n\""
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EREAD4",
          "args": [
            "sc",
            "E1371_CODEC"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define EAP_WRITE_TIMEOUT\t0x1000\n#define  E1371_SRC_STATE_OK     0x010000\n#define  E1371_SRC_STATE_MASK   0x870000\n#define  E1371_SRC_DISREC       (1<<19)\n#define  E1371_SRC_DISP2        (1<<20)\n#define  E1371_SRC_DISP1\t(1<<21)\n#define  E1371_SRC_DISABLE\t(1<<22)\n#define E1371_SRC\t\t0x10\n#define  E1371_CODEC_WIP\t(1<<30)\n#define E1371_CODEC\t\t0x14\n\nint\teap1371_src_wait;\nint\teap1371_write_codec;\n\nint\neap1371_write_codec(sc_, a, d)\n        void *sc_;\n\tu_int8_t a;\n\tu_int16_t d;\n{\n\tstruct eap_softc *sc = sc_;\n        int to;\n        int cdc, src;\n\n        to = EAP_WRITE_TIMEOUT;\n        do {\n                cdc = EREAD4(sc, E1371_CODEC);\n                if (!to--) {\n                        printf(\"eap: timeout writing to codec\\n\");\n                        return 1;\n                }\n        } while (cdc & E1371_CODEC_WIP);\n\n        /* just do it */\n\tsrc = (eap1371_src_wait(sc) & (E1371_SRC_DISABLE | E1371_SRC_DISP1 |\n\t\tE1371_SRC_DISP2 | E1371_SRC_DISREC)) ;\n\n\tEWRITE4(sc, E1371_SRC, src | 0x10000);\n\n\tfor (to = 0; to < EAP_WRITE_TIMEOUT; to++) {\n\t\tif (!(EREAD4(sc, E1371_SRC) & E1371_SRC_STATE_MASK))\n\t\t\tbreak;\n\n\t\tdelay(1);\n\t}\n\t\n\tfor (to = 0; to < EAP_WRITE_TIMEOUT; to++) {\n\t\tif ((EREAD4(sc, E1371_SRC) & E1371_SRC_STATE_MASK) ==\n\t\t\tE1371_SRC_STATE_OK)\n\t\t\tbreak;\n\n\t\tdelay(1);\n\t}\n\n        EWRITE4(sc, E1371_CODEC, E1371_SET_CODEC(a, d));\n\n\teap1371_src_wait(sc);\n\tEWRITE4(sc, E1371_SRC, src);\n\n        DPRINTFN(10, (\"eap1371: writing codec %x --> %x\\n\", d, a));\n\n        return (0);\n}"
  },
  {
    "function_name": "eap1371_read_codec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
    "lines": "509-568",
    "snippet": "int\neap1371_read_codec(sc_, a, d)\n        void *sc_;\n\tu_int8_t a;\n\tu_int16_t *d;\n{\n\tstruct eap_softc *sc = sc_;\n        int to;\n        int cdc, src;\n\n        to = EAP_WRITE_TIMEOUT;\n        do {\n                cdc = EREAD4(sc, E1371_CODEC);\n                if (!to--) {\n                        printf(\"eap: timeout writing to codec\\n\");\n                        return 1;\n                }\n        } while (cdc & E1371_CODEC_WIP);\n\n        /* just do it */\n\tsrc = (eap1371_src_wait(sc) & (E1371_SRC_DISABLE | E1371_SRC_DISP1 |\n\t\tE1371_SRC_DISP2 | E1371_SRC_DISREC)) ;\n\n\tEWRITE4(sc, E1371_SRC, src | 0x10000);\n\n\tfor (to = 0; to < EAP_READ_TIMEOUT; to++) {\n\t\tif (!(EREAD4(sc, E1371_SRC) & E1371_SRC_STATE_MASK))\n\t\t\tbreak;\n\n\t\tdelay(1);\n\t}\n\n\tfor (to = 0; to < EAP_WRITE_TIMEOUT; to++) {\n\t\tif ((EREAD4(sc, E1371_SRC) & E1371_SRC_STATE_MASK) ==\n\t\t\tE1371_SRC_STATE_OK)\n\t\t\tbreak;\n\n\t\tdelay(1);\n\t}\n\t\n        EWRITE4(sc, E1371_CODEC, E1371_SET_CODEC(a, 0) | E1371_CODEC_READ);\n\n\teap1371_src_wait(sc);\n\tEWRITE4(sc, E1371_SRC, src);\n\n\tfor (to = 0; to < EAP_READ_TIMEOUT; to++) {\n\t\tif ((cdc = EREAD4(sc, E1371_CODEC)) & E1371_CODEC_VALID)\n\t\t\tbreak;\n\t}\n\n\tif (to == EAP_WRITE_TIMEOUT) {\n\t\tDPRINTF((\"eap1371: read codec timeout\\n\"));\n\t}\n\n\t*d = cdc & 0xffff;\n\n        DPRINTFN(10, (\"eap1371: reading codec (%x) = %x\\n\", a, *d));        \n\n\treturn (0);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/ac97.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define EAP_WRITE_TIMEOUT\t0x1000",
      "#define EAP_READ_TIMEOUT        0x1000",
      "#define  E1371_SRC_STATE_OK     0x010000",
      "#define  E1371_SRC_STATE_MASK   0x870000",
      "#define  E1371_SRC_DISREC       (1<<19)",
      "#define  E1371_SRC_DISP2        (1<<20)",
      "#define  E1371_SRC_DISP1\t(1<<21)",
      "#define  E1371_SRC_DISABLE\t(1<<22)",
      "#define E1371_SRC\t\t0x10",
      "#define  E1371_CODEC_READ       (1<<23)",
      "#define  E1371_CODEC_VALID      (1<<31)",
      "#define  E1371_CODEC_WIP\t(1<<30)",
      "#define E1371_CODEC\t\t0x14"
    ],
    "globals_used": [
      "int\teap1371_src_wait",
      "int\teap1371_read_codec"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "10",
            "(\"eap1371: reading codec (%x) = %x\\n\", a, *d)"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"eap1371: read codec timeout\\n\")"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EREAD4",
          "args": [
            "sc",
            "E1371_CODEC"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "E1371_SRC",
            "src"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eap1371_src_wait",
          "args": [
            "sc"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "eap1371_src_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
          "lines": "620-639",
          "snippet": "int\neap1371_src_wait(sc)\n\tstruct eap_softc *sc;\n{\n        int to;\n        int src;\n\n\tfor (to = 0; to < EAP_READ_TIMEOUT; to++) {\n\t\tsrc = EREAD4(sc, E1371_SRC);\n\t\tif (!(src & E1371_SRC_RBUSY))\n\t\t\treturn src;\n\t\tdelay(1);\n\t}\n\n\t\n\tprintf(\"eap: timeout waiting for sample rate\"\n\t    \"converter\\n\");\n\n\treturn src;\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <dev/ic/ac97.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define EAP_READ_TIMEOUT        0x1000",
            "#define  E1371_SRC_RBUSY\t(1<<23)",
            "#define E1371_SRC\t\t0x10"
          ],
          "globals_used": [
            "int\teap1371_src_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define EAP_READ_TIMEOUT        0x1000\n#define  E1371_SRC_RBUSY\t(1<<23)\n#define E1371_SRC\t\t0x10\n\nint\teap1371_src_wait;\n\nint\neap1371_src_wait(sc)\n\tstruct eap_softc *sc;\n{\n        int to;\n        int src;\n\n\tfor (to = 0; to < EAP_READ_TIMEOUT; to++) {\n\t\tsrc = EREAD4(sc, E1371_SRC);\n\t\tif (!(src & E1371_SRC_RBUSY))\n\t\t\treturn src;\n\t\tdelay(1);\n\t}\n\n\t\n\tprintf(\"eap: timeout waiting for sample rate\"\n\t    \"converter\\n\");\n\n\treturn src;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "E1371_CODEC",
            "E1371_SET_CODEC(a, 0) | E1371_CODEC_READ"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "E1371_SET_CODEC",
          "args": [
            "a",
            "0"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EREAD4",
          "args": [
            "sc",
            "E1371_SRC"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EREAD4",
          "args": [
            "sc",
            "E1371_SRC"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "E1371_SRC",
            "src | 0x10000"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"eap: timeout writing to codec\\n\""
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EREAD4",
          "args": [
            "sc",
            "E1371_CODEC"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define EAP_WRITE_TIMEOUT\t0x1000\n#define EAP_READ_TIMEOUT        0x1000\n#define  E1371_SRC_STATE_OK     0x010000\n#define  E1371_SRC_STATE_MASK   0x870000\n#define  E1371_SRC_DISREC       (1<<19)\n#define  E1371_SRC_DISP2        (1<<20)\n#define  E1371_SRC_DISP1\t(1<<21)\n#define  E1371_SRC_DISABLE\t(1<<22)\n#define E1371_SRC\t\t0x10\n#define  E1371_CODEC_READ       (1<<23)\n#define  E1371_CODEC_VALID      (1<<31)\n#define  E1371_CODEC_WIP\t(1<<30)\n#define E1371_CODEC\t\t0x14\n\nint\teap1371_src_wait;\nint\teap1371_read_codec;\n\nint\neap1371_read_codec(sc_, a, d)\n        void *sc_;\n\tu_int8_t a;\n\tu_int16_t *d;\n{\n\tstruct eap_softc *sc = sc_;\n        int to;\n        int cdc, src;\n\n        to = EAP_WRITE_TIMEOUT;\n        do {\n                cdc = EREAD4(sc, E1371_CODEC);\n                if (!to--) {\n                        printf(\"eap: timeout writing to codec\\n\");\n                        return 1;\n                }\n        } while (cdc & E1371_CODEC_WIP);\n\n        /* just do it */\n\tsrc = (eap1371_src_wait(sc) & (E1371_SRC_DISABLE | E1371_SRC_DISP1 |\n\t\tE1371_SRC_DISP2 | E1371_SRC_DISREC)) ;\n\n\tEWRITE4(sc, E1371_SRC, src | 0x10000);\n\n\tfor (to = 0; to < EAP_READ_TIMEOUT; to++) {\n\t\tif (!(EREAD4(sc, E1371_SRC) & E1371_SRC_STATE_MASK))\n\t\t\tbreak;\n\n\t\tdelay(1);\n\t}\n\n\tfor (to = 0; to < EAP_WRITE_TIMEOUT; to++) {\n\t\tif ((EREAD4(sc, E1371_SRC) & E1371_SRC_STATE_MASK) ==\n\t\t\tE1371_SRC_STATE_OK)\n\t\t\tbreak;\n\n\t\tdelay(1);\n\t}\n\t\n        EWRITE4(sc, E1371_CODEC, E1371_SET_CODEC(a, 0) | E1371_CODEC_READ);\n\n\teap1371_src_wait(sc);\n\tEWRITE4(sc, E1371_SRC, src);\n\n\tfor (to = 0; to < EAP_READ_TIMEOUT; to++) {\n\t\tif ((cdc = EREAD4(sc, E1371_CODEC)) & E1371_CODEC_VALID)\n\t\t\tbreak;\n\t}\n\n\tif (to == EAP_WRITE_TIMEOUT) {\n\t\tDPRINTF((\"eap1371: read codec timeout\\n\"));\n\t}\n\n\t*d = cdc & 0xffff;\n\n        DPRINTFN(10, (\"eap1371: reading codec (%x) = %x\\n\", a, *d));        \n\n\treturn (0);\n}"
  },
  {
    "function_name": "eap_write_codec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
    "lines": "488-506",
    "snippet": "void\neap_write_codec(sc, a, d)\n\tstruct eap_softc *sc;\n\tint a, d;\n{\n\n\tint icss, to;\n\t\n\tto = EAP_WRITE_TIMEOUT;\n\tdo {\n\t\ticss = EREAD4(sc, EAP_ICSS);\n\t\tDPRINTFN(5,(\"eap: codec %d prog: icss=0x%08x\\n\", a, icss));\n                if (!to--) {\n                        printf(\"eap: timeout writing to codec\\n\");\n                        return;\n                }\n\t} while (icss & EAP_CWRIP);  /* XXX could use CSTAT here */\n        EWRITE4(sc, EAP_CODEC, EAP_SET_CODEC(a, d));\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/ac97.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define EAP_WRITE_TIMEOUT\t0x1000",
      "#define EAP_CODEC\t\t0x10",
      "#define  EAP_CWRIP\t\t0x00000100",
      "#define EAP_ICSS\t\t0x04\t/* interrupt / chip select status */"
    ],
    "globals_used": [
      "void    eap_write_codec"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EWRITE4",
          "args": [
            "sc",
            "EAP_CODEC",
            "EAP_SET_CODEC(a, d)"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EAP_SET_CODEC",
          "args": [
            "a",
            "d"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"eap: timeout writing to codec\\n\""
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"eap: codec %d prog: icss=0x%08x\\n\", a, icss)"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EREAD4",
          "args": [
            "sc",
            "EAP_ICSS"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define EAP_WRITE_TIMEOUT\t0x1000\n#define EAP_CODEC\t\t0x10\n#define  EAP_CWRIP\t\t0x00000100\n#define EAP_ICSS\t\t0x04\t/* interrupt / chip select status */\n\nvoid    eap_write_codec;\n\nvoid\neap_write_codec(sc, a, d)\n\tstruct eap_softc *sc;\n\tint a, d;\n{\n\n\tint icss, to;\n\t\n\tto = EAP_WRITE_TIMEOUT;\n\tdo {\n\t\ticss = EREAD4(sc, EAP_ICSS);\n\t\tDPRINTFN(5,(\"eap: codec %d prog: icss=0x%08x\\n\", a, icss));\n                if (!to--) {\n                        printf(\"eap: timeout writing to codec\\n\");\n                        return;\n                }\n\t} while (icss & EAP_CWRIP);  /* XXX could use CSTAT here */\n        EWRITE4(sc, EAP_CODEC, EAP_SET_CODEC(a, d));\n}"
  },
  {
    "function_name": "eap_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/eap.c",
    "lines": "467-486",
    "snippet": "int\neap_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match;\n\tvoid *aux;\n{\n\tstruct pci_attach_args *pa = (struct pci_attach_args *) aux;\n\n\tif (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_ENSONIQ &&\n\t    PCI_VENDOR(pa->pa_id) != PCI_VENDOR_CREATIVELABS)\n\t\treturn (0);\n\n\tif (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ENSONIQ_AUDIOPCI ||\n\t    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ENSONIQ_AUDIOPCI97 ||\n\t    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ENSONIQ_CT5880 ||\n\t    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_CREATIVELABS_EV1938)\n\t\treturn (1);\n\n\treturn (0);\n}",
    "includes": [
      "#include <machine/bus.h>",
      "#include <dev/ic/ac97.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\teap_match"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PCI_PRODUCT",
          "args": [
            "pa->pa_id"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_PRODUCT",
          "args": [
            "pa->pa_id"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_PRODUCT",
          "args": [
            "pa->pa_id"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_PRODUCT",
          "args": [
            "pa->pa_id"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDOR",
          "args": [
            "pa->pa_id"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDOR",
          "args": [
            "pa->pa_id"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <machine/bus.h>\n#include <dev/ic/ac97.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\teap_match;\n\nint\neap_match(parent, match, aux)\n\tstruct device *parent;\n\tvoid *match;\n\tvoid *aux;\n{\n\tstruct pci_attach_args *pa = (struct pci_attach_args *) aux;\n\n\tif (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_ENSONIQ &&\n\t    PCI_VENDOR(pa->pa_id) != PCI_VENDOR_CREATIVELABS)\n\t\treturn (0);\n\n\tif (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ENSONIQ_AUDIOPCI ||\n\t    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ENSONIQ_AUDIOPCI97 ||\n\t    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ENSONIQ_CT5880 ||\n\t    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_CREATIVELABS_EV1938)\n\t\treturn (1);\n\n\treturn (0);\n}"
  }
]