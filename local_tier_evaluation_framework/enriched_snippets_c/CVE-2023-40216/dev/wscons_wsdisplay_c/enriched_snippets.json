[
  {
    "function_name": "wsdisplay_shutdownhook",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "1780-1785",
    "snippet": "static void\nwsdisplay_shutdownhook(arg)\n\tvoid *arg;\n{\n\twsdisplay_switchtoconsole();\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wsdisplay_shutdownhook"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wsdisplay_switchtoconsole",
          "args": [],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "wsdisplay_switchtoconsole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "1769-1775",
          "snippet": "void\nwsdisplay_switchtoconsole()\n{\n\tif (wsdisplay_console_device != NULL)\n\t\twsdisplay_switch((struct device *)wsdisplay_console_device, \n\t\t    0, 0);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct wsdisplay_softc *wsdisplay_console_device;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstatic struct wsdisplay_softc *wsdisplay_console_device;\n\nvoid\nwsdisplay_switchtoconsole()\n{\n\tif (wsdisplay_console_device != NULL)\n\t\twsdisplay_switch((struct device *)wsdisplay_console_device, \n\t\t    0, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstatic void wsdisplay_shutdownhook;\n\nstatic void\nwsdisplay_shutdownhook(arg)\n\tvoid *arg;\n{\n\twsdisplay_switchtoconsole();\n}"
  },
  {
    "function_name": "wsdisplay_switchtoconsole",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "1769-1775",
    "snippet": "void\nwsdisplay_switchtoconsole()\n{\n\tif (wsdisplay_console_device != NULL)\n\t\twsdisplay_switch((struct device *)wsdisplay_console_device, \n\t\t    0, 0);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct wsdisplay_softc *wsdisplay_console_device;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wsdisplay_switch",
          "args": [
            "(struct device *)wsdisplay_console_device",
            "0",
            "0"
          ],
          "line": 1773
        },
        "resolved": true,
        "details": {
          "function_name": "wsdisplay_switchtoconsole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "1769-1775",
          "snippet": "void\nwsdisplay_switchtoconsole()\n{\n\tif (wsdisplay_console_device != NULL)\n\t\twsdisplay_switch((struct device *)wsdisplay_console_device, \n\t\t    0, 0);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstatic struct wsdisplay_softc *wsdisplay_console_device;\n\nvoid\nwsdisplay_switchtoconsole()\n{\n\tif (wsdisplay_console_device != NULL)\n\t\twsdisplay_switch((struct device *)wsdisplay_console_device, \n\t\t    0, 0);\n}"
  },
  {
    "function_name": "wsdisplay_unset_cons_kbd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "1758-1764",
    "snippet": "void\nwsdisplay_unset_cons_kbd()\n{\n\twsdisplay_cons.cn_getc = wsdisplay_getc_dummy;\n\t/* wsdisplay_cons.cn_bell = NULL; XXX */\n\twsdisplay_cons_kbd_pollc = NULL;\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int wsdisplay_getc_dummy",
      "static void (*wsdisplay_cons_kbd_pollc)",
      "static struct consdev wsdisplay_cons = {\n\tNULL, NULL, wsdisplay_getc_dummy, wsdisplay_cnputc,\n\twsdisplay_pollc, NODEV, CN_NORMAL\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstatic int wsdisplay_getc_dummy;\nstatic void (*wsdisplay_cons_kbd_pollc);\nstatic struct consdev wsdisplay_cons = {\n\tNULL, NULL, wsdisplay_getc_dummy, wsdisplay_cnputc,\n\twsdisplay_pollc, NODEV, CN_NORMAL\n};\n\nvoid\nwsdisplay_unset_cons_kbd()\n{\n\twsdisplay_cons.cn_getc = wsdisplay_getc_dummy;\n\t/* wsdisplay_cons.cn_bell = NULL; XXX */\n\twsdisplay_cons_kbd_pollc = NULL;\n}"
  },
  {
    "function_name": "wsdisplay_set_cons_kbd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "1747-1756",
    "snippet": "void\nwsdisplay_set_cons_kbd(get, poll, bell)\n\tint (*get) __P((dev_t));\n\tvoid (*poll) __P((dev_t, int));\n\tvoid (*bell) __P((dev_t, u_int, u_int, u_int));\n{\n\twsdisplay_cons.cn_getc = get;\n\t/* wsdisplay_cons.cn_bell = bell; XXX */\n\twsdisplay_cons_kbd_pollc = poll;\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void (*wsdisplay_cons_kbd_pollc)",
      "static struct consdev wsdisplay_cons = {\n\tNULL, NULL, wsdisplay_getc_dummy, wsdisplay_cnputc,\n\twsdisplay_pollc, NODEV, CN_NORMAL\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstatic void (*wsdisplay_cons_kbd_pollc);\nstatic struct consdev wsdisplay_cons = {\n\tNULL, NULL, wsdisplay_getc_dummy, wsdisplay_cnputc,\n\twsdisplay_pollc, NODEV, CN_NORMAL\n};\n\nvoid\nwsdisplay_set_cons_kbd(get, poll, bell)\n\tint (*get) __P((dev_t));\n\tvoid (*poll) __P((dev_t, int));\n\tvoid (*bell) __P((dev_t, u_int, u_int, u_int));\n{\n\twsdisplay_cons.cn_getc = get;\n\t/* wsdisplay_cons.cn_bell = bell; XXX */\n\twsdisplay_cons_kbd_pollc = poll;\n}"
  },
  {
    "function_name": "wsdisplay_pollc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "1735-1745",
    "snippet": "static void\nwsdisplay_pollc(dev, on)\n\tdev_t dev;\n\tint on;\n{\n\n\twsdisplay_cons_pollmode = on;\n\n\tif (wsdisplay_cons_kbd_pollc)\n\t\t(*wsdisplay_cons_kbd_pollc)(dev, on);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wsdisplay_pollc",
      "static int wsdisplay_cons_pollmode;",
      "static void (*wsdisplay_cons_kbd_pollc)",
      "struct tty *\nwsdisplaytty(dev)\n\tdev_t dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "dev",
            "on"
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstatic void wsdisplay_pollc;\nstatic int wsdisplay_cons_pollmode;\nstatic void (*wsdisplay_cons_kbd_pollc);\nstruct tty *\nwsdisplaytty(dev)\n\tdev_t dev;\n\nstatic void\nwsdisplay_pollc(dev, on)\n\tdev_t dev;\n\tint on;\n{\n\n\twsdisplay_cons_pollmode = on;\n\n\tif (wsdisplay_cons_kbd_pollc)\n\t\t(*wsdisplay_cons_kbd_pollc)(dev, on);\n}"
  },
  {
    "function_name": "wsdisplay_getc_dummy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "1727-1733",
    "snippet": "static int\nwsdisplay_getc_dummy(dev)\n\tdev_t dev;\n{\n\t/* panic? */\n\treturn (0);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int wsdisplay_getc_dummy",
      "struct tty *\nwsdisplaytty(dev)\n\tdev_t dev;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstatic int wsdisplay_getc_dummy;\nstruct tty *\nwsdisplaytty(dev)\n\tdev_t dev;\n\nstatic int\nwsdisplay_getc_dummy(dev)\n\tdev_t dev;\n{\n\t/* panic? */\n\treturn (0);\n}"
  },
  {
    "function_name": "wsdisplay_cnputc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "1708-1725",
    "snippet": "void\nwsdisplay_cnputc(dev, i)\n\tdev_t dev;\n\tint i;\n{\n\tstruct wsscreen_internal *dc;\n\tchar c = i;\n\n\tif (!wsdisplay_console_initted)\n\t\treturn;\n\n\tif (wsdisplay_console_device != NULL &&\n\t    (wsdisplay_console_device->sc_scr[0]->scr_flags & SCR_GRAPHICS))\n\t\treturn;\n\n\tdc = &wsdisplay_console_conf;\n\t(*dc->wsemul->output)(dc->wsemulcookie, &c, 1, 1);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [
      "#define SCR_GRAPHICS 4\t\t/* graphics mode, no text (emulation) output */"
    ],
    "globals_used": [
      "static int wsdisplay_console_initted;",
      "static struct wsdisplay_softc *wsdisplay_console_device;",
      "static struct wsscreen_internal wsdisplay_console_conf;",
      "struct tty *\nwsdisplaytty(dev)\n\tdev_t dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "dc->wsemulcookie",
            "&c",
            "1",
            "1"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define SCR_GRAPHICS 4\t\t/* graphics mode, no text (emulation) output */\n\nstatic int wsdisplay_console_initted;\nstatic struct wsdisplay_softc *wsdisplay_console_device;\nstatic struct wsscreen_internal wsdisplay_console_conf;\nstruct tty *\nwsdisplaytty(dev)\n\tdev_t dev;\n\nvoid\nwsdisplay_cnputc(dev, i)\n\tdev_t dev;\n\tint i;\n{\n\tstruct wsscreen_internal *dc;\n\tchar c = i;\n\n\tif (!wsdisplay_console_initted)\n\t\treturn;\n\n\tif (wsdisplay_console_device != NULL &&\n\t    (wsdisplay_console_device->sc_scr[0]->scr_flags & SCR_GRAPHICS))\n\t\treturn;\n\n\tdc = &wsdisplay_console_conf;\n\t(*dc->wsemul->output)(dc->wsemulcookie, &c, 1, 1);\n}"
  },
  {
    "function_name": "wsdisplay_kbdholdscreen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "1674-1690",
    "snippet": "void\nwsdisplay_kbdholdscreen(dev, hold)\n\tstruct device *dev;\n\tint hold;\n{\n\tstruct wsdisplay_softc *sc = (struct wsdisplay_softc *)dev;\n\tstruct wsscreen *scr;\n\n\tscr = sc->sc_focus;\n\n\tif (hold)\n\t\tscr->scr_hold_screen = 1;\n\telse {\n\t\tscr->scr_hold_screen = 0;\n\t\ttimeout(ttrstrt, scr->scr_tty, 0);\t/* \"immediate\" */\n\t}\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;",
      "struct tty *\nwsdisplaytty(dev)\n\tdev_t dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "ttrstrt",
            "scr->scr_tty",
            "0"
          ],
          "line": 1688
        },
        "resolved": true,
        "details": {
          "function_name": "usl_attachtimeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay_compat_usl.c",
          "lines": "278-297",
          "snippet": "static void\nusl_attachtimeout(arg)\n\tvoid *arg;\n{\n\tstruct usl_syncdata *sd = arg;\n\n\tprintf(\"usl_attachtimeout\\n\");\n\n\tif (!(sd->s_flags & SF_ATTACHPENDING)) {\n\t\tprintf(\"usl_attachtimeout: not attaching\\n\");\n\t\treturn;\n\t}\n\n\tsd->s_flags &= ~SF_ATTACHPENDING;\n\n\tif (sd->s_callback)\n\t\t(*sd->s_callback)(sd->s_cbarg, EIO, 0);\n\n\t(void) usl_sync_check(sd);\n}",
          "includes": [
            "#include <dev/wscons/wsdisplay_usl_io.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/errno.h>",
            "#include <sys/malloc.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/timeout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define SF_ATTACHPENDING 2"
          ],
          "globals_used": [
            "static int usl_sync_check",
            "static void usl_attachtimeout"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsdisplay_usl_io.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/errno.h>\n#include <sys/malloc.h>\n#include <sys/signalvar.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define SF_ATTACHPENDING 2\n\nstatic int usl_sync_check;\nstatic void usl_attachtimeout;\n\nstatic void\nusl_attachtimeout(arg)\n\tvoid *arg;\n{\n\tstruct usl_syncdata *sd = arg;\n\n\tprintf(\"usl_attachtimeout\\n\");\n\n\tif (!(sd->s_flags & SF_ATTACHPENDING)) {\n\t\tprintf(\"usl_attachtimeout: not attaching\\n\");\n\t\treturn;\n\t}\n\n\tsd->s_flags &= ~SF_ATTACHPENDING;\n\n\tif (sd->s_callback)\n\t\t(*sd->s_callback)(sd->s_cbarg, EIO, 0);\n\n\t(void) usl_sync_check(sd);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\nstruct tty *\nwsdisplaytty(dev)\n\tdev_t dev;\n\nvoid\nwsdisplay_kbdholdscreen(dev, hold)\n\tstruct device *dev;\n\tint hold;\n{\n\tstruct wsdisplay_softc *sc = (struct wsdisplay_softc *)dev;\n\tstruct wsscreen *scr;\n\n\tscr = sc->sc_focus;\n\n\tif (hold)\n\t\tscr->scr_hold_screen = 1;\n\telse {\n\t\tscr->scr_hold_screen = 0;\n\t\ttimeout(ttrstrt, scr->scr_tty, 0);\t/* \"immediate\" */\n\t}\n}"
  },
  {
    "function_name": "wsscreen_switchwait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "1647-1672",
    "snippet": "int\nwsscreen_switchwait(sc, no)\n\tstruct wsdisplay_softc *sc;\n\tint no;\n{\n\tstruct wsscreen *scr;\n\tint s, res = 0;\n\n\tif (no < 0 || no >= WSDISPLAY_MAXSCREEN)\n\t\treturn (ENXIO);\n\tscr = sc->sc_scr[no];\n\tif (!scr)\n\t\treturn (ENXIO);\n\n\ts = spltty();\n\tif (scr != sc->sc_focus) {\n\t\tscr->scr_flags |= SCR_WAITACTIVE;\n\t\tres = tsleep(scr, PCATCH, \"wswait\", 0);\n\t\tif (scr != sc->sc_scr[no])\n\t\t\tres = ENXIO; /* disappeared in the meantime */\n\t\telse\n\t\t\tscr->scr_flags &= ~SCR_WAITACTIVE;\n\t}\n\tsplx(s);\n\treturn (res);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [
      "#define WSDISPLAY_MAXSCREEN 8",
      "#define SCR_WAITACTIVE 2\t/* someone waiting on activation */"
    ],
    "globals_used": [
      "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "scr",
            "PCATCH",
            "\"wswait\"",
            "0"
          ],
          "line": 1664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define WSDISPLAY_MAXSCREEN 8\n#define SCR_WAITACTIVE 2\t/* someone waiting on activation */\n\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\n\nint\nwsscreen_switchwait(sc, no)\n\tstruct wsdisplay_softc *sc;\n\tint no;\n{\n\tstruct wsscreen *scr;\n\tint s, res = 0;\n\n\tif (no < 0 || no >= WSDISPLAY_MAXSCREEN)\n\t\treturn (ENXIO);\n\tscr = sc->sc_scr[no];\n\tif (!scr)\n\t\treturn (ENXIO);\n\n\ts = spltty();\n\tif (scr != sc->sc_focus) {\n\t\tscr->scr_flags |= SCR_WAITACTIVE;\n\t\tres = tsleep(scr, PCATCH, \"wswait\", 0);\n\t\tif (scr != sc->sc_scr[no])\n\t\t\tres = ENXIO; /* disappeared in the meantime */\n\t\telse\n\t\t\tscr->scr_flags &= ~SCR_WAITACTIVE;\n\t}\n\tsplx(s);\n\treturn (res);\n}"
  },
  {
    "function_name": "wsdisplay_getactivescreen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "1640-1645",
    "snippet": "int\nwsdisplay_getactivescreen(sc)\n\tstruct wsdisplay_softc *sc;\n{\n\treturn (sc->sc_focusidx);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\n\nint\nwsdisplay_getactivescreen(sc)\n\tstruct wsdisplay_softc *sc;\n{\n\treturn (sc->sc_focusidx);\n}"
  },
  {
    "function_name": "wsdisplay_screenstate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "1628-1638",
    "snippet": "int\nwsdisplay_screenstate(sc, idx)\n\tstruct wsdisplay_softc *sc;\n\tint idx;\n{\n\tif (idx >= WSDISPLAY_MAXSCREEN)\n\t\treturn (EINVAL);\n\tif (!sc->sc_scr[idx])\n\t\treturn (ENXIO);\n\treturn ((sc->sc_scr[idx]->scr_flags & SCR_OPEN) ? EBUSY : 0);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [
      "#define WSDISPLAY_MAXSCREEN 8",
      "#define SCR_OPEN 1\t\t/* is it open? */"
    ],
    "globals_used": [
      "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define WSDISPLAY_MAXSCREEN 8\n#define SCR_OPEN 1\t\t/* is it open? */\n\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\n\nint\nwsdisplay_screenstate(sc, idx)\n\tstruct wsdisplay_softc *sc;\n\tint idx;\n{\n\tif (idx >= WSDISPLAY_MAXSCREEN)\n\t\treturn (EINVAL);\n\tif (!sc->sc_scr[idx])\n\t\treturn (ENXIO);\n\treturn ((sc->sc_scr[idx]->scr_flags & SCR_OPEN) ? EBUSY : 0);\n}"
  },
  {
    "function_name": "wsdisplay_maxscreenidx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "1621-1626",
    "snippet": "int\nwsdisplay_maxscreenidx(sc)\n\tstruct wsdisplay_softc *sc;\n{\n\treturn (WSDISPLAY_MAXSCREEN - 1);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [
      "#define WSDISPLAY_MAXSCREEN 8"
    ],
    "globals_used": [
      "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define WSDISPLAY_MAXSCREEN 8\n\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\n\nint\nwsdisplay_maxscreenidx(sc)\n\tstruct wsdisplay_softc *sc;\n{\n\treturn (WSDISPLAY_MAXSCREEN - 1);\n}"
  },
  {
    "function_name": "wsscreen_lookup_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "1606-1616",
    "snippet": "int\nwsscreen_lookup_sync(scr, ops, cookiep)\n\tstruct wsscreen *scr;\n\tconst struct wscons_syncops *ops; /* used as ID */\n\tvoid **cookiep;\n{\n\tif (!scr->scr_syncops || ops != scr->scr_syncops)\n\t\treturn (EINVAL);\n\t*cookiep = scr->scr_synccookie;\n\treturn (0);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nint\nwsscreen_lookup_sync(scr, ops, cookiep)\n\tstruct wsscreen *scr;\n\tconst struct wscons_syncops *ops; /* used as ID */\n\tvoid **cookiep;\n{\n\tif (!scr->scr_syncops || ops != scr->scr_syncops)\n\t\treturn (EINVAL);\n\t*cookiep = scr->scr_synccookie;\n\treturn (0);\n}"
  },
  {
    "function_name": "wsscreen_detach_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "1596-1604",
    "snippet": "int\nwsscreen_detach_sync(scr)\n\tstruct wsscreen *scr;\n{\n\tif (!scr->scr_syncops)\n\t\treturn (EINVAL);\n\tscr->scr_syncops = 0;\n\treturn (0);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nint\nwsscreen_detach_sync(scr)\n\tstruct wsscreen *scr;\n{\n\tif (!scr->scr_syncops)\n\t\treturn (EINVAL);\n\tscr->scr_syncops = 0;\n\treturn (0);\n}"
  },
  {
    "function_name": "wsscreen_attach_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "1577-1594",
    "snippet": "int\nwsscreen_attach_sync(scr, ops, cookie)\n\tstruct wsscreen *scr;\n\tconst struct wscons_syncops *ops;\n\tvoid *cookie;\n{\n\tif (scr->scr_syncops) {\n\t\t/*\n\t\t * The screen is already claimed.\n\t\t * Check if the owner is still alive.\n\t\t */\n\t\tif ((*scr->scr_syncops->check)(scr->scr_synccookie))\n\t\t\treturn (EBUSY);\n\t}\n\tscr->scr_syncops = ops;\n\tscr->scr_synccookie = cookie;\n\treturn (0);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void *cookie;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "scr->scr_synccookie"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nvoid *cookie;\n\nint\nwsscreen_attach_sync(scr, ops, cookie)\n\tstruct wsscreen *scr;\n\tconst struct wscons_syncops *ops;\n\tvoid *cookie;\n{\n\tif (scr->scr_syncops) {\n\t\t/*\n\t\t * The screen is already claimed.\n\t\t * Check if the owner is still alive.\n\t\t */\n\t\tif ((*scr->scr_syncops->check)(scr->scr_synccookie))\n\t\t\treturn (EBUSY);\n\t}\n\tscr->scr_syncops = ops;\n\tscr->scr_synccookie = cookie;\n\treturn (0);\n}"
  },
  {
    "function_name": "wsdisplay_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "1547-1572",
    "snippet": "void\nwsdisplay_reset(dev, op)\n\tstruct device *dev;\n\tenum wsdisplay_resetops op;\n{\n\tstruct wsdisplay_softc *sc = (struct wsdisplay_softc *)dev;\n\tstruct wsscreen *scr;\n\n\tKASSERT(sc != NULL);\n\tscr = sc->sc_focus;\n\n\tif (!scr)\n\t\treturn;\n\n\tswitch (op) {\n\tcase WSDISPLAY_RESETEMUL:\n\t\tif (!WSSCREEN_HAS_EMULATOR(scr))\n\t\t\tbreak;\n\t\t(*scr->scr_dconf->wsemul->reset)(scr->scr_dconf->wsemulcookie,\n\t\t\t\t\t\t WSEMUL_RESET);\n\t\tbreak;\n\tcase WSDISPLAY_RESETCLOSE:\n\t\twsdisplay_closescreen(sc, scr);\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wsdisplay_closescreen",
      "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;",
      "struct tty *\nwsdisplaytty(dev)\n\tdev_t dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wsdisplay_closescreen",
          "args": [
            "sc",
            "scr"
          ],
          "line": 1569
        },
        "resolved": true,
        "details": {
          "function_name": "wsdisplay_closescreen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "394-423",
          "snippet": "static void\nwsdisplay_closescreen(sc, scr)\n\tstruct wsdisplay_softc *sc;\n\tstruct wsscreen *scr;\n{\n\tint maj, mn, idx;\n\n\t/* hangup */\n\tif (WSSCREEN_HAS_TTY(scr)) {\n\t\tstruct tty *tp = scr->scr_tty;\n\t\t(*linesw[tp->t_line].l_modem)(tp, 0);\n\t}\n\n\t/* locate the major number */\n\tfor (maj = 0; maj < nchrdev; maj++)\n\t\tif (cdevsw[maj].d_open == wsdisplayopen)\n\t\t\tbreak;\n\t/* locate the screen index */\n\tfor (idx = 0; idx < WSDISPLAY_MAXSCREEN; idx++)\n\t\tif (scr == sc->sc_scr[idx])\n\t\t\tbreak;\n#ifdef DIAGNOSTIC\n\tif (idx == WSDISPLAY_MAXSCREEN)\n\t\tpanic(\"wsdisplay_forceclose: bad screen\");\n#endif\n\n\t/* nuke the vnodes */\n\tmn = WSDISPLAYMINOR(sc->sc_dv.dv_unit, idx);\n\tvdevgone(maj, mn, mn, VCHR);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [
            "#define WSDISPLAY_MAXSCREEN 8"
          ],
          "globals_used": [
            "static void wsdisplay_closescreen",
            "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define WSDISPLAY_MAXSCREEN 8\n\nstatic void wsdisplay_closescreen;\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\n\nstatic void\nwsdisplay_closescreen(sc, scr)\n\tstruct wsdisplay_softc *sc;\n\tstruct wsscreen *scr;\n{\n\tint maj, mn, idx;\n\n\t/* hangup */\n\tif (WSSCREEN_HAS_TTY(scr)) {\n\t\tstruct tty *tp = scr->scr_tty;\n\t\t(*linesw[tp->t_line].l_modem)(tp, 0);\n\t}\n\n\t/* locate the major number */\n\tfor (maj = 0; maj < nchrdev; maj++)\n\t\tif (cdevsw[maj].d_open == wsdisplayopen)\n\t\t\tbreak;\n\t/* locate the screen index */\n\tfor (idx = 0; idx < WSDISPLAY_MAXSCREEN; idx++)\n\t\tif (scr == sc->sc_scr[idx])\n\t\t\tbreak;\n#ifdef DIAGNOSTIC\n\tif (idx == WSDISPLAY_MAXSCREEN)\n\t\tpanic(\"wsdisplay_forceclose: bad screen\");\n#endif\n\n\t/* nuke the vnodes */\n\tmn = WSDISPLAYMINOR(sc->sc_dv.dv_unit, idx);\n\tvdevgone(maj, mn, mn, VCHR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "scr->scr_dconf->wsemulcookie",
            "WSEMUL_RESET"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSSCREEN_HAS_EMULATOR",
          "args": [
            "scr"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KASSERT",
          "args": [
            "sc != NULL"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstatic void wsdisplay_closescreen;\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\nstruct tty *\nwsdisplaytty(dev)\n\tdev_t dev;\n\nvoid\nwsdisplay_reset(dev, op)\n\tstruct device *dev;\n\tenum wsdisplay_resetops op;\n{\n\tstruct wsdisplay_softc *sc = (struct wsdisplay_softc *)dev;\n\tstruct wsscreen *scr;\n\n\tKASSERT(sc != NULL);\n\tscr = sc->sc_focus;\n\n\tif (!scr)\n\t\treturn;\n\n\tswitch (op) {\n\tcase WSDISPLAY_RESETEMUL:\n\t\tif (!WSSCREEN_HAS_EMULATOR(scr))\n\t\t\tbreak;\n\t\t(*scr->scr_dconf->wsemul->reset)(scr->scr_dconf->wsemulcookie,\n\t\t\t\t\t\t WSEMUL_RESET);\n\t\tbreak;\n\tcase WSDISPLAY_RESETCLOSE:\n\t\twsdisplay_closescreen(sc, scr);\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "wsdisplay_switch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "1495-1545",
    "snippet": "int\nwsdisplay_switch(dev, no, waitok)\n\tstruct device *dev;\n\tint no, waitok;\n{\n\tstruct wsdisplay_softc *sc = (struct wsdisplay_softc *)dev;\n\tint s, res = 0;\n\tstruct wsscreen *scr;\n\n\tif (no < 0 || no >= WSDISPLAY_MAXSCREEN || !sc->sc_scr[no])\n\t\treturn (ENXIO);\n\n\ts = spltty();\n\n\tif (sc->sc_focus && no == sc->sc_focusidx) {\n\t\tsplx(s);\n\t\treturn (0);\n\t}\n\n\tif (sc->sc_flags & SC_SWITCHPENDING) {\n\t\tsplx(s);\n\t\treturn (EBUSY);\n\t}\n\n\tsc->sc_flags |= SC_SWITCHPENDING;\n\tsc->sc_screenwanted = no;\n\n\tsplx(s);\n\n\tscr = sc->sc_focus;\n\tif (!scr) {\n\t\tsc->sc_oldscreen = -1;\n\t\treturn (wsdisplay_switch1(sc, 0, waitok));\n\t} else\n\t\tsc->sc_oldscreen = sc->sc_focusidx;\n\n#define wsswitch_cb1 ((void (*) __P((void *, int, int)))wsdisplay_switch1)\n\tif (scr->scr_syncops) {\n\t\tres = (*scr->scr_syncops->detach)(scr->scr_synccookie, waitok,\n\t  sc->sc_isconsole && wsdisplay_cons_pollmode ? 0 : wsswitch_cb1, sc);\n\t\tif (res == EAGAIN) {\n\t\t\t/* switch will be done asynchronously */\n\t\t\treturn (0);\n\t\t}\n\t} else if (scr->scr_flags & SCR_GRAPHICS) {\n\t\t/* no way to save state */\n\t\tres = EBUSY;\n\t}\n\n\treturn (wsdisplay_switch1(sc, res, waitok));\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [
      "#define wsswitch_cb1 ((void (*) __P((void *, int, int)))wsdisplay_switch1)",
      "#define SC_SWITCHPENDING 1",
      "#define WSDISPLAY_MAXSCREEN 8",
      "#define SCR_GRAPHICS 4\t\t/* graphics mode, no text (emulation) output */"
    ],
    "globals_used": [
      "static int wsdisplay_cons_pollmode;",
      "int wsdisplay_switch1",
      "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;",
      "struct tty *\nwsdisplaytty(dev)\n\tdev_t dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wsdisplay_switch1",
          "args": [
            "sc",
            "res",
            "waitok"
          ],
          "line": 1544
        },
        "resolved": true,
        "details": {
          "function_name": "wsdisplay_switch1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "1454-1493",
          "snippet": "int\nwsdisplay_switch1(arg, error, waitok)\n\tvoid *arg;\n\tint error, waitok;\n{\n\tstruct wsdisplay_softc *sc = arg;\n\tint no;\n\tstruct wsscreen *scr;\n\n\tif (!(sc->sc_flags & SC_SWITCHPENDING)) {\n\t\tprintf(\"wsdisplay_switch1: not switching\\n\");\n\t\treturn (EINVAL);\n\t}\n\n\tno = sc->sc_screenwanted;\n\tif (no < 0 || no >= WSDISPLAY_MAXSCREEN)\n\t\tpanic(\"wsdisplay_switch1: invalid screen %d\", no);\n\tscr = sc->sc_scr[no];\n\tif (!scr) {\n\t\tprintf(\"wsdisplay_switch1: screen %d disappeared\\n\", no);\n\t\terror = ENXIO;\n\t}\n\n\tif (error) {\n\tsc->sc_flags &= ~SC_SWITCHPENDING;\n\t\treturn (error);\n\t}\n\n#define wsswitch_cb2 ((void (*) __P((void *, int, int)))wsdisplay_switch2)\n\terror = (*sc->sc_accessops->show_screen)(sc->sc_accesscookie,\n\t\t\t\t\t\t scr->scr_dconf->emulcookie,\n\t\t\t\t\t\t waitok,\n\t  sc->sc_isconsole && wsdisplay_cons_pollmode ? 0 : wsswitch_cb2, sc);\n\tif (error == EAGAIN) {\n\t\t/* switch will be done asynchronously */\n\treturn (0);\n}\n\n\treturn (wsdisplay_switch2(sc, error, waitok));\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [
            "#define wsswitch_cb2 ((void (*) __P((void *, int, int)))wsdisplay_switch2)",
            "#define d ((struct wsmux_device *)data)",
            "#define d ((struct wsdisplay_kbddata *)data)",
            "#define d ((struct wsdisplay_font *)data)",
            "#define d ((struct wsdisplay_delscreendata *)data)",
            "#define d ((struct wsdisplay_addscreendata *)data)",
            "#define d ((struct wsdisplay_usefontdata *)data)",
            "#define d (*(int *)data)",
            "#define SC_SWITCHPENDING 1",
            "#define WSDISPLAY_MAXSCREEN 8"
          ],
          "globals_used": [
            "static int wsdisplay_cons_pollmode;",
            "int wsdisplay_switch1",
            "int wsdisplay_switch2",
            "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define wsswitch_cb2 ((void (*) __P((void *, int, int)))wsdisplay_switch2)\n#define d ((struct wsmux_device *)data)\n#define d ((struct wsdisplay_kbddata *)data)\n#define d ((struct wsdisplay_font *)data)\n#define d ((struct wsdisplay_delscreendata *)data)\n#define d ((struct wsdisplay_addscreendata *)data)\n#define d ((struct wsdisplay_usefontdata *)data)\n#define d (*(int *)data)\n#define SC_SWITCHPENDING 1\n#define WSDISPLAY_MAXSCREEN 8\n\nstatic int wsdisplay_cons_pollmode;\nint wsdisplay_switch1;\nint wsdisplay_switch2;\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\n\nint\nwsdisplay_switch1(arg, error, waitok)\n\tvoid *arg;\n\tint error, waitok;\n{\n\tstruct wsdisplay_softc *sc = arg;\n\tint no;\n\tstruct wsscreen *scr;\n\n\tif (!(sc->sc_flags & SC_SWITCHPENDING)) {\n\t\tprintf(\"wsdisplay_switch1: not switching\\n\");\n\t\treturn (EINVAL);\n\t}\n\n\tno = sc->sc_screenwanted;\n\tif (no < 0 || no >= WSDISPLAY_MAXSCREEN)\n\t\tpanic(\"wsdisplay_switch1: invalid screen %d\", no);\n\tscr = sc->sc_scr[no];\n\tif (!scr) {\n\t\tprintf(\"wsdisplay_switch1: screen %d disappeared\\n\", no);\n\t\terror = ENXIO;\n\t}\n\n\tif (error) {\n\tsc->sc_flags &= ~SC_SWITCHPENDING;\n\t\treturn (error);\n\t}\n\n#define wsswitch_cb2 ((void (*) __P((void *, int, int)))wsdisplay_switch2)\n\terror = (*sc->sc_accessops->show_screen)(sc->sc_accesscookie,\n\t\t\t\t\t\t scr->scr_dconf->emulcookie,\n\t\t\t\t\t\t waitok,\n\t  sc->sc_isconsole && wsdisplay_cons_pollmode ? 0 : wsswitch_cb2, sc);\n\tif (error == EAGAIN) {\n\t\t/* switch will be done asynchronously */\n\treturn (0);\n}\n\n\treturn (wsdisplay_switch2(sc, error, waitok));\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "scr->scr_synccookie",
            "waitok",
            "sc->sc_isconsole && wsdisplay_cons_pollmode ? 0 : wsswitch_cb1",
            "sc"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define wsswitch_cb1 ((void (*) __P((void *, int, int)))wsdisplay_switch1)\n#define SC_SWITCHPENDING 1\n#define WSDISPLAY_MAXSCREEN 8\n#define SCR_GRAPHICS 4\t\t/* graphics mode, no text (emulation) output */\n\nstatic int wsdisplay_cons_pollmode;\nint wsdisplay_switch1;\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\nstruct tty *\nwsdisplaytty(dev)\n\tdev_t dev;\n\nint\nwsdisplay_switch(dev, no, waitok)\n\tstruct device *dev;\n\tint no, waitok;\n{\n\tstruct wsdisplay_softc *sc = (struct wsdisplay_softc *)dev;\n\tint s, res = 0;\n\tstruct wsscreen *scr;\n\n\tif (no < 0 || no >= WSDISPLAY_MAXSCREEN || !sc->sc_scr[no])\n\t\treturn (ENXIO);\n\n\ts = spltty();\n\n\tif (sc->sc_focus && no == sc->sc_focusidx) {\n\t\tsplx(s);\n\t\treturn (0);\n\t}\n\n\tif (sc->sc_flags & SC_SWITCHPENDING) {\n\t\tsplx(s);\n\t\treturn (EBUSY);\n\t}\n\n\tsc->sc_flags |= SC_SWITCHPENDING;\n\tsc->sc_screenwanted = no;\n\n\tsplx(s);\n\n\tscr = sc->sc_focus;\n\tif (!scr) {\n\t\tsc->sc_oldscreen = -1;\n\t\treturn (wsdisplay_switch1(sc, 0, waitok));\n\t} else\n\t\tsc->sc_oldscreen = sc->sc_focusidx;\n\n#define wsswitch_cb1 ((void (*) __P((void *, int, int)))wsdisplay_switch1)\n\tif (scr->scr_syncops) {\n\t\tres = (*scr->scr_syncops->detach)(scr->scr_synccookie, waitok,\n\t  sc->sc_isconsole && wsdisplay_cons_pollmode ? 0 : wsswitch_cb1, sc);\n\t\tif (res == EAGAIN) {\n\t\t\t/* switch will be done asynchronously */\n\t\t\treturn (0);\n\t\t}\n\t} else if (scr->scr_flags & SCR_GRAPHICS) {\n\t\t/* no way to save state */\n\t\tres = EBUSY;\n\t}\n\n\treturn (wsdisplay_switch1(sc, res, waitok));\n}"
  },
  {
    "function_name": "wsdisplay_switch1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "1454-1493",
    "snippet": "int\nwsdisplay_switch1(arg, error, waitok)\n\tvoid *arg;\n\tint error, waitok;\n{\n\tstruct wsdisplay_softc *sc = arg;\n\tint no;\n\tstruct wsscreen *scr;\n\n\tif (!(sc->sc_flags & SC_SWITCHPENDING)) {\n\t\tprintf(\"wsdisplay_switch1: not switching\\n\");\n\t\treturn (EINVAL);\n\t}\n\n\tno = sc->sc_screenwanted;\n\tif (no < 0 || no >= WSDISPLAY_MAXSCREEN)\n\t\tpanic(\"wsdisplay_switch1: invalid screen %d\", no);\n\tscr = sc->sc_scr[no];\n\tif (!scr) {\n\t\tprintf(\"wsdisplay_switch1: screen %d disappeared\\n\", no);\n\t\terror = ENXIO;\n\t}\n\n\tif (error) {\n\tsc->sc_flags &= ~SC_SWITCHPENDING;\n\t\treturn (error);\n\t}\n\n#define wsswitch_cb2 ((void (*) __P((void *, int, int)))wsdisplay_switch2)\n\terror = (*sc->sc_accessops->show_screen)(sc->sc_accesscookie,\n\t\t\t\t\t\t scr->scr_dconf->emulcookie,\n\t\t\t\t\t\t waitok,\n\t  sc->sc_isconsole && wsdisplay_cons_pollmode ? 0 : wsswitch_cb2, sc);\n\tif (error == EAGAIN) {\n\t\t/* switch will be done asynchronously */\n\treturn (0);\n}\n\n\treturn (wsdisplay_switch2(sc, error, waitok));\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [
      "#define wsswitch_cb2 ((void (*) __P((void *, int, int)))wsdisplay_switch2)",
      "#define d ((struct wsmux_device *)data)",
      "#define d ((struct wsdisplay_kbddata *)data)",
      "#define d ((struct wsdisplay_font *)data)",
      "#define d ((struct wsdisplay_delscreendata *)data)",
      "#define d ((struct wsdisplay_addscreendata *)data)",
      "#define d ((struct wsdisplay_usefontdata *)data)",
      "#define d (*(int *)data)",
      "#define SC_SWITCHPENDING 1",
      "#define WSDISPLAY_MAXSCREEN 8"
    ],
    "globals_used": [
      "static int wsdisplay_cons_pollmode;",
      "int wsdisplay_switch1",
      "int wsdisplay_switch2",
      "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wsdisplay_switch2",
          "args": [
            "sc",
            "error",
            "waitok"
          ],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "wsdisplay_switch2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "1395-1452",
          "snippet": "int\nwsdisplay_switch2(arg, error, waitok)\n\tvoid *arg;\n\tint error, waitok;\n{\n\tstruct wsdisplay_softc *sc = arg;\n\tint no;\n\tstruct wsscreen *scr;\n\n\tif (!(sc->sc_flags & SC_SWITCHPENDING)) {\n\t\tprintf(\"wsdisplay_switch2: not switching\\n\");\n\t\treturn (EINVAL);\n\t}\n\n\tno = sc->sc_screenwanted;\n\tif (no < 0 || no >= WSDISPLAY_MAXSCREEN)\n\t\tpanic(\"wsdisplay_switch2: invalid screen %d\", no);\n\tscr = sc->sc_scr[no];\n\tif (!scr) {\n\t\tprintf(\"wsdisplay_switch2: screen %d disappeared\\n\", no);\n\t\terror = ENXIO;\n\t}\n\n\tif (error) {\n\t\t/* try to recover, avoid recursion */\n\n\t\tif (sc->sc_oldscreen == -1) {\n\t\t\tprintf(\"wsdisplay_switch2: giving up\\n\");\n\t\t\tsc->sc_focus = 0;\n\t\t\tsc->sc_flags &= ~SC_SWITCHPENDING;\n\t\t\treturn (error);\n\t\t}\n\n\t\tsc->sc_screenwanted = sc->sc_oldscreen;\n\t\tsc->sc_oldscreen = -1;\n\t\treturn (wsdisplay_switch1(arg, 0, waitok));\n\t}\n\n\tsc->sc_focusidx = no;\n\tsc->sc_focus = scr;\n\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t(void) wsdisplay_update_rawkbd(sc, scr);\n#endif\n\t/* keyboard map??? */\n\n#define wsswitch_cb3 ((void (*) __P((void *, int, int)))wsdisplay_switch3)\n\tif (scr->scr_syncops) {\n\t\terror = (*scr->scr_syncops->attach)(scr->scr_synccookie, waitok,\n\t  sc->sc_isconsole && wsdisplay_cons_pollmode ? 0 : wsswitch_cb3, sc);\n\t\tif (error == EAGAIN) {\n\t\t\t/* switch will be done asynchronously */\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (wsdisplay_switch3(sc, error, waitok));\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [
            "#define wsswitch_cb3 ((void (*) __P((void *, int, int)))wsdisplay_switch3)",
            "#define d ((struct wsmux_device *)data)",
            "#define d ((struct wsdisplay_kbddata *)data)",
            "#define d ((struct wsdisplay_font *)data)",
            "#define d ((struct wsdisplay_delscreendata *)data)",
            "#define d ((struct wsdisplay_addscreendata *)data)",
            "#define d ((struct wsdisplay_usefontdata *)data)",
            "#define d (*(int *)data)",
            "#define SC_SWITCHPENDING 1",
            "#define WSDISPLAY_MAXSCREEN 8"
          ],
          "globals_used": [
            "static int wsdisplay_cons_pollmode;",
            "int wsdisplay_switch1",
            "int wsdisplay_switch2",
            "int wsdisplay_switch3",
            "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define wsswitch_cb3 ((void (*) __P((void *, int, int)))wsdisplay_switch3)\n#define d ((struct wsmux_device *)data)\n#define d ((struct wsdisplay_kbddata *)data)\n#define d ((struct wsdisplay_font *)data)\n#define d ((struct wsdisplay_delscreendata *)data)\n#define d ((struct wsdisplay_addscreendata *)data)\n#define d ((struct wsdisplay_usefontdata *)data)\n#define d (*(int *)data)\n#define SC_SWITCHPENDING 1\n#define WSDISPLAY_MAXSCREEN 8\n\nstatic int wsdisplay_cons_pollmode;\nint wsdisplay_switch1;\nint wsdisplay_switch2;\nint wsdisplay_switch3;\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\n\nint\nwsdisplay_switch2(arg, error, waitok)\n\tvoid *arg;\n\tint error, waitok;\n{\n\tstruct wsdisplay_softc *sc = arg;\n\tint no;\n\tstruct wsscreen *scr;\n\n\tif (!(sc->sc_flags & SC_SWITCHPENDING)) {\n\t\tprintf(\"wsdisplay_switch2: not switching\\n\");\n\t\treturn (EINVAL);\n\t}\n\n\tno = sc->sc_screenwanted;\n\tif (no < 0 || no >= WSDISPLAY_MAXSCREEN)\n\t\tpanic(\"wsdisplay_switch2: invalid screen %d\", no);\n\tscr = sc->sc_scr[no];\n\tif (!scr) {\n\t\tprintf(\"wsdisplay_switch2: screen %d disappeared\\n\", no);\n\t\terror = ENXIO;\n\t}\n\n\tif (error) {\n\t\t/* try to recover, avoid recursion */\n\n\t\tif (sc->sc_oldscreen == -1) {\n\t\t\tprintf(\"wsdisplay_switch2: giving up\\n\");\n\t\t\tsc->sc_focus = 0;\n\t\t\tsc->sc_flags &= ~SC_SWITCHPENDING;\n\t\t\treturn (error);\n\t\t}\n\n\t\tsc->sc_screenwanted = sc->sc_oldscreen;\n\t\tsc->sc_oldscreen = -1;\n\t\treturn (wsdisplay_switch1(arg, 0, waitok));\n\t}\n\n\tsc->sc_focusidx = no;\n\tsc->sc_focus = scr;\n\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t(void) wsdisplay_update_rawkbd(sc, scr);\n#endif\n\t/* keyboard map??? */\n\n#define wsswitch_cb3 ((void (*) __P((void *, int, int)))wsdisplay_switch3)\n\tif (scr->scr_syncops) {\n\t\terror = (*scr->scr_syncops->attach)(scr->scr_synccookie, waitok,\n\t  sc->sc_isconsole && wsdisplay_cons_pollmode ? 0 : wsswitch_cb3, sc);\n\t\tif (error == EAGAIN) {\n\t\t\t/* switch will be done asynchronously */\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (wsdisplay_switch3(sc, error, waitok));\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc->sc_accesscookie",
            "scr->scr_dconf->emulcookie",
            "waitok",
            "sc->sc_isconsole && wsdisplay_cons_pollmode ? 0 : wsswitch_cb2",
            "sc"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"wsdisplay_switch1: screen %d disappeared\\n\"",
            "no"
          ],
          "line": 1473
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"wsdisplay_switch1: invalid screen %d\"",
            "no"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define wsswitch_cb2 ((void (*) __P((void *, int, int)))wsdisplay_switch2)\n#define d ((struct wsmux_device *)data)\n#define d ((struct wsdisplay_kbddata *)data)\n#define d ((struct wsdisplay_font *)data)\n#define d ((struct wsdisplay_delscreendata *)data)\n#define d ((struct wsdisplay_addscreendata *)data)\n#define d ((struct wsdisplay_usefontdata *)data)\n#define d (*(int *)data)\n#define SC_SWITCHPENDING 1\n#define WSDISPLAY_MAXSCREEN 8\n\nstatic int wsdisplay_cons_pollmode;\nint wsdisplay_switch1;\nint wsdisplay_switch2;\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\n\nint\nwsdisplay_switch1(arg, error, waitok)\n\tvoid *arg;\n\tint error, waitok;\n{\n\tstruct wsdisplay_softc *sc = arg;\n\tint no;\n\tstruct wsscreen *scr;\n\n\tif (!(sc->sc_flags & SC_SWITCHPENDING)) {\n\t\tprintf(\"wsdisplay_switch1: not switching\\n\");\n\t\treturn (EINVAL);\n\t}\n\n\tno = sc->sc_screenwanted;\n\tif (no < 0 || no >= WSDISPLAY_MAXSCREEN)\n\t\tpanic(\"wsdisplay_switch1: invalid screen %d\", no);\n\tscr = sc->sc_scr[no];\n\tif (!scr) {\n\t\tprintf(\"wsdisplay_switch1: screen %d disappeared\\n\", no);\n\t\terror = ENXIO;\n\t}\n\n\tif (error) {\n\tsc->sc_flags &= ~SC_SWITCHPENDING;\n\t\treturn (error);\n\t}\n\n#define wsswitch_cb2 ((void (*) __P((void *, int, int)))wsdisplay_switch2)\n\terror = (*sc->sc_accessops->show_screen)(sc->sc_accesscookie,\n\t\t\t\t\t\t scr->scr_dconf->emulcookie,\n\t\t\t\t\t\t waitok,\n\t  sc->sc_isconsole && wsdisplay_cons_pollmode ? 0 : wsswitch_cb2, sc);\n\tif (error == EAGAIN) {\n\t\t/* switch will be done asynchronously */\n\treturn (0);\n}\n\n\treturn (wsdisplay_switch2(sc, error, waitok));\n}"
  },
  {
    "function_name": "wsdisplay_switch2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "1395-1452",
    "snippet": "int\nwsdisplay_switch2(arg, error, waitok)\n\tvoid *arg;\n\tint error, waitok;\n{\n\tstruct wsdisplay_softc *sc = arg;\n\tint no;\n\tstruct wsscreen *scr;\n\n\tif (!(sc->sc_flags & SC_SWITCHPENDING)) {\n\t\tprintf(\"wsdisplay_switch2: not switching\\n\");\n\t\treturn (EINVAL);\n\t}\n\n\tno = sc->sc_screenwanted;\n\tif (no < 0 || no >= WSDISPLAY_MAXSCREEN)\n\t\tpanic(\"wsdisplay_switch2: invalid screen %d\", no);\n\tscr = sc->sc_scr[no];\n\tif (!scr) {\n\t\tprintf(\"wsdisplay_switch2: screen %d disappeared\\n\", no);\n\t\terror = ENXIO;\n\t}\n\n\tif (error) {\n\t\t/* try to recover, avoid recursion */\n\n\t\tif (sc->sc_oldscreen == -1) {\n\t\t\tprintf(\"wsdisplay_switch2: giving up\\n\");\n\t\t\tsc->sc_focus = 0;\n\t\t\tsc->sc_flags &= ~SC_SWITCHPENDING;\n\t\t\treturn (error);\n\t\t}\n\n\t\tsc->sc_screenwanted = sc->sc_oldscreen;\n\t\tsc->sc_oldscreen = -1;\n\t\treturn (wsdisplay_switch1(arg, 0, waitok));\n\t}\n\n\tsc->sc_focusidx = no;\n\tsc->sc_focus = scr;\n\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t(void) wsdisplay_update_rawkbd(sc, scr);\n#endif\n\t/* keyboard map??? */\n\n#define wsswitch_cb3 ((void (*) __P((void *, int, int)))wsdisplay_switch3)\n\tif (scr->scr_syncops) {\n\t\terror = (*scr->scr_syncops->attach)(scr->scr_synccookie, waitok,\n\t  sc->sc_isconsole && wsdisplay_cons_pollmode ? 0 : wsswitch_cb3, sc);\n\t\tif (error == EAGAIN) {\n\t\t\t/* switch will be done asynchronously */\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (wsdisplay_switch3(sc, error, waitok));\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [
      "#define wsswitch_cb3 ((void (*) __P((void *, int, int)))wsdisplay_switch3)",
      "#define d ((struct wsmux_device *)data)",
      "#define d ((struct wsdisplay_kbddata *)data)",
      "#define d ((struct wsdisplay_font *)data)",
      "#define d ((struct wsdisplay_delscreendata *)data)",
      "#define d ((struct wsdisplay_addscreendata *)data)",
      "#define d ((struct wsdisplay_usefontdata *)data)",
      "#define d (*(int *)data)",
      "#define SC_SWITCHPENDING 1",
      "#define WSDISPLAY_MAXSCREEN 8"
    ],
    "globals_used": [
      "static int wsdisplay_cons_pollmode;",
      "int wsdisplay_switch1",
      "int wsdisplay_switch2",
      "int wsdisplay_switch3",
      "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wsdisplay_switch3",
          "args": [
            "sc",
            "error",
            "waitok"
          ],
          "line": 1451
        },
        "resolved": true,
        "details": {
          "function_name": "wsdisplay_switch3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "1347-1393",
          "snippet": "int\nwsdisplay_switch3(arg, error, waitok)\n\tvoid *arg;\n\tint error, waitok;\n{\n\tstruct wsdisplay_softc *sc = arg;\n\tint no;\n\tstruct wsscreen *scr;\n\n\tif (!(sc->sc_flags & SC_SWITCHPENDING)) {\n\t\tprintf(\"wsdisplay_switch3: not switching\\n\");\n\t\treturn (EINVAL);\n\t}\n\n\tno = sc->sc_screenwanted;\n\tif (no < 0 || no >= WSDISPLAY_MAXSCREEN)\n\t\tpanic(\"wsdisplay_switch3: invalid screen %d\", no);\n\tscr = sc->sc_scr[no];\n\tif (!scr) {\n\t\tprintf(\"wsdisplay_switch3: screen %d disappeared\\n\", no);\n\t\terror = ENXIO;\n\t}\n\n\tif (error) {\n\t\t/* try to recover, avoid recursion */\n\n\t\tif (sc->sc_oldscreen == -1) {\n\t\t\tprintf(\"wsdisplay_switch3: giving up\\n\");\n\t\t\tsc->sc_focus = 0;\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t\t\twsdisplay_update_rawkbd(sc, 0);\n#endif\n\t\tsc->sc_flags &= ~SC_SWITCHPENDING;\n\t\t\treturn (error);\n\t\t}\n\n\t\tsc->sc_screenwanted = sc->sc_oldscreen;\n\t\tsc->sc_oldscreen = -1;\n\t\treturn (wsdisplay_switch1(arg, 0, waitok));\n\t}\n\n\tsc->sc_flags &= ~SC_SWITCHPENDING;\n\n\tif (!error && (scr->scr_flags & SCR_WAITACTIVE))\n\t\twakeup(scr);\n\treturn (error);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [
            "#define d ((struct wsmux_device *)data)",
            "#define d ((struct wsdisplay_kbddata *)data)",
            "#define d ((struct wsdisplay_font *)data)",
            "#define d ((struct wsdisplay_delscreendata *)data)",
            "#define d ((struct wsdisplay_addscreendata *)data)",
            "#define d ((struct wsdisplay_usefontdata *)data)",
            "#define d (*(int *)data)",
            "#define SC_SWITCHPENDING 1",
            "#define WSDISPLAY_MAXSCREEN 8",
            "#define SCR_WAITACTIVE 2\t/* someone waiting on activation */"
          ],
          "globals_used": [
            "int wsdisplay_switch1",
            "int wsdisplay_switch3",
            "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define d ((struct wsmux_device *)data)\n#define d ((struct wsdisplay_kbddata *)data)\n#define d ((struct wsdisplay_font *)data)\n#define d ((struct wsdisplay_delscreendata *)data)\n#define d ((struct wsdisplay_addscreendata *)data)\n#define d ((struct wsdisplay_usefontdata *)data)\n#define d (*(int *)data)\n#define SC_SWITCHPENDING 1\n#define WSDISPLAY_MAXSCREEN 8\n#define SCR_WAITACTIVE 2\t/* someone waiting on activation */\n\nint wsdisplay_switch1;\nint wsdisplay_switch3;\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\n\nint\nwsdisplay_switch3(arg, error, waitok)\n\tvoid *arg;\n\tint error, waitok;\n{\n\tstruct wsdisplay_softc *sc = arg;\n\tint no;\n\tstruct wsscreen *scr;\n\n\tif (!(sc->sc_flags & SC_SWITCHPENDING)) {\n\t\tprintf(\"wsdisplay_switch3: not switching\\n\");\n\t\treturn (EINVAL);\n\t}\n\n\tno = sc->sc_screenwanted;\n\tif (no < 0 || no >= WSDISPLAY_MAXSCREEN)\n\t\tpanic(\"wsdisplay_switch3: invalid screen %d\", no);\n\tscr = sc->sc_scr[no];\n\tif (!scr) {\n\t\tprintf(\"wsdisplay_switch3: screen %d disappeared\\n\", no);\n\t\terror = ENXIO;\n\t}\n\n\tif (error) {\n\t\t/* try to recover, avoid recursion */\n\n\t\tif (sc->sc_oldscreen == -1) {\n\t\t\tprintf(\"wsdisplay_switch3: giving up\\n\");\n\t\t\tsc->sc_focus = 0;\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t\t\twsdisplay_update_rawkbd(sc, 0);\n#endif\n\t\tsc->sc_flags &= ~SC_SWITCHPENDING;\n\t\t\treturn (error);\n\t\t}\n\n\t\tsc->sc_screenwanted = sc->sc_oldscreen;\n\t\tsc->sc_oldscreen = -1;\n\t\treturn (wsdisplay_switch1(arg, 0, waitok));\n\t}\n\n\tsc->sc_flags &= ~SC_SWITCHPENDING;\n\n\tif (!error && (scr->scr_flags & SCR_WAITACTIVE))\n\t\twakeup(scr);\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "scr->scr_synccookie",
            "waitok",
            "sc->sc_isconsole && wsdisplay_cons_pollmode ? 0 : wsswitch_cb3",
            "sc"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsdisplay_update_rawkbd",
          "args": [
            "sc",
            "scr"
          ],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "wsdisplay_update_rawkbd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "1321-1344",
          "snippet": "int\nwsdisplay_update_rawkbd(sc, scr)\n\tstruct wsdisplay_softc *sc;\n\tstruct wsscreen *scr;\n{\n\tint s, raw, data, error;\n\ts = spltty();\n\n\traw = (scr ? scr->scr_rawkbd : 0);\n\n\tif (scr != sc->sc_focus ||\n\t    sc->sc_rawkbd == raw) {\n\t\tsplx(s);\n\t\treturn (0);\n\t}\n\n\tdata = raw ? WSKBD_RAW : WSKBD_TRANSLATED;\n\terror = wsmux_displayioctl(&sc->sc_muxdv->sc_dv, WSKBDIO_SETMODE,\n\t\t\t\t   (caddr_t)&data, 0, 0);\n\tif (!error)\n\t\tsc->sc_rawkbd = raw;\n\tsplx(s);\n\treturn (error);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\n\nint\nwsdisplay_update_rawkbd(sc, scr)\n\tstruct wsdisplay_softc *sc;\n\tstruct wsscreen *scr;\n{\n\tint s, raw, data, error;\n\ts = spltty();\n\n\traw = (scr ? scr->scr_rawkbd : 0);\n\n\tif (scr != sc->sc_focus ||\n\t    sc->sc_rawkbd == raw) {\n\t\tsplx(s);\n\t\treturn (0);\n\t}\n\n\tdata = raw ? WSKBD_RAW : WSKBD_TRANSLATED;\n\terror = wsmux_displayioctl(&sc->sc_muxdv->sc_dv, WSKBDIO_SETMODE,\n\t\t\t\t   (caddr_t)&data, 0, 0);\n\tif (!error)\n\t\tsc->sc_rawkbd = raw;\n\tsplx(s);\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wsdisplay_switch1",
          "args": [
            "arg",
            "0",
            "waitok"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "wsdisplay_switch1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "1454-1493",
          "snippet": "int\nwsdisplay_switch1(arg, error, waitok)\n\tvoid *arg;\n\tint error, waitok;\n{\n\tstruct wsdisplay_softc *sc = arg;\n\tint no;\n\tstruct wsscreen *scr;\n\n\tif (!(sc->sc_flags & SC_SWITCHPENDING)) {\n\t\tprintf(\"wsdisplay_switch1: not switching\\n\");\n\t\treturn (EINVAL);\n\t}\n\n\tno = sc->sc_screenwanted;\n\tif (no < 0 || no >= WSDISPLAY_MAXSCREEN)\n\t\tpanic(\"wsdisplay_switch1: invalid screen %d\", no);\n\tscr = sc->sc_scr[no];\n\tif (!scr) {\n\t\tprintf(\"wsdisplay_switch1: screen %d disappeared\\n\", no);\n\t\terror = ENXIO;\n\t}\n\n\tif (error) {\n\tsc->sc_flags &= ~SC_SWITCHPENDING;\n\t\treturn (error);\n\t}\n\n#define wsswitch_cb2 ((void (*) __P((void *, int, int)))wsdisplay_switch2)\n\terror = (*sc->sc_accessops->show_screen)(sc->sc_accesscookie,\n\t\t\t\t\t\t scr->scr_dconf->emulcookie,\n\t\t\t\t\t\t waitok,\n\t  sc->sc_isconsole && wsdisplay_cons_pollmode ? 0 : wsswitch_cb2, sc);\n\tif (error == EAGAIN) {\n\t\t/* switch will be done asynchronously */\n\treturn (0);\n}\n\n\treturn (wsdisplay_switch2(sc, error, waitok));\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [
            "#define wsswitch_cb2 ((void (*) __P((void *, int, int)))wsdisplay_switch2)",
            "#define d ((struct wsmux_device *)data)",
            "#define d ((struct wsdisplay_kbddata *)data)",
            "#define d ((struct wsdisplay_font *)data)",
            "#define d ((struct wsdisplay_delscreendata *)data)",
            "#define d ((struct wsdisplay_addscreendata *)data)",
            "#define d ((struct wsdisplay_usefontdata *)data)",
            "#define d (*(int *)data)",
            "#define SC_SWITCHPENDING 1",
            "#define WSDISPLAY_MAXSCREEN 8"
          ],
          "globals_used": [
            "static int wsdisplay_cons_pollmode;",
            "int wsdisplay_switch1",
            "int wsdisplay_switch2",
            "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define wsswitch_cb2 ((void (*) __P((void *, int, int)))wsdisplay_switch2)\n#define d ((struct wsmux_device *)data)\n#define d ((struct wsdisplay_kbddata *)data)\n#define d ((struct wsdisplay_font *)data)\n#define d ((struct wsdisplay_delscreendata *)data)\n#define d ((struct wsdisplay_addscreendata *)data)\n#define d ((struct wsdisplay_usefontdata *)data)\n#define d (*(int *)data)\n#define SC_SWITCHPENDING 1\n#define WSDISPLAY_MAXSCREEN 8\n\nstatic int wsdisplay_cons_pollmode;\nint wsdisplay_switch1;\nint wsdisplay_switch2;\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\n\nint\nwsdisplay_switch1(arg, error, waitok)\n\tvoid *arg;\n\tint error, waitok;\n{\n\tstruct wsdisplay_softc *sc = arg;\n\tint no;\n\tstruct wsscreen *scr;\n\n\tif (!(sc->sc_flags & SC_SWITCHPENDING)) {\n\t\tprintf(\"wsdisplay_switch1: not switching\\n\");\n\t\treturn (EINVAL);\n\t}\n\n\tno = sc->sc_screenwanted;\n\tif (no < 0 || no >= WSDISPLAY_MAXSCREEN)\n\t\tpanic(\"wsdisplay_switch1: invalid screen %d\", no);\n\tscr = sc->sc_scr[no];\n\tif (!scr) {\n\t\tprintf(\"wsdisplay_switch1: screen %d disappeared\\n\", no);\n\t\terror = ENXIO;\n\t}\n\n\tif (error) {\n\tsc->sc_flags &= ~SC_SWITCHPENDING;\n\t\treturn (error);\n\t}\n\n#define wsswitch_cb2 ((void (*) __P((void *, int, int)))wsdisplay_switch2)\n\terror = (*sc->sc_accessops->show_screen)(sc->sc_accesscookie,\n\t\t\t\t\t\t scr->scr_dconf->emulcookie,\n\t\t\t\t\t\t waitok,\n\t  sc->sc_isconsole && wsdisplay_cons_pollmode ? 0 : wsswitch_cb2, sc);\n\tif (error == EAGAIN) {\n\t\t/* switch will be done asynchronously */\n\treturn (0);\n}\n\n\treturn (wsdisplay_switch2(sc, error, waitok));\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"wsdisplay_switch2: giving up\\n\""
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"wsdisplay_switch2: invalid screen %d\"",
            "no"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define wsswitch_cb3 ((void (*) __P((void *, int, int)))wsdisplay_switch3)\n#define d ((struct wsmux_device *)data)\n#define d ((struct wsdisplay_kbddata *)data)\n#define d ((struct wsdisplay_font *)data)\n#define d ((struct wsdisplay_delscreendata *)data)\n#define d ((struct wsdisplay_addscreendata *)data)\n#define d ((struct wsdisplay_usefontdata *)data)\n#define d (*(int *)data)\n#define SC_SWITCHPENDING 1\n#define WSDISPLAY_MAXSCREEN 8\n\nstatic int wsdisplay_cons_pollmode;\nint wsdisplay_switch1;\nint wsdisplay_switch2;\nint wsdisplay_switch3;\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\n\nint\nwsdisplay_switch2(arg, error, waitok)\n\tvoid *arg;\n\tint error, waitok;\n{\n\tstruct wsdisplay_softc *sc = arg;\n\tint no;\n\tstruct wsscreen *scr;\n\n\tif (!(sc->sc_flags & SC_SWITCHPENDING)) {\n\t\tprintf(\"wsdisplay_switch2: not switching\\n\");\n\t\treturn (EINVAL);\n\t}\n\n\tno = sc->sc_screenwanted;\n\tif (no < 0 || no >= WSDISPLAY_MAXSCREEN)\n\t\tpanic(\"wsdisplay_switch2: invalid screen %d\", no);\n\tscr = sc->sc_scr[no];\n\tif (!scr) {\n\t\tprintf(\"wsdisplay_switch2: screen %d disappeared\\n\", no);\n\t\terror = ENXIO;\n\t}\n\n\tif (error) {\n\t\t/* try to recover, avoid recursion */\n\n\t\tif (sc->sc_oldscreen == -1) {\n\t\t\tprintf(\"wsdisplay_switch2: giving up\\n\");\n\t\t\tsc->sc_focus = 0;\n\t\t\tsc->sc_flags &= ~SC_SWITCHPENDING;\n\t\t\treturn (error);\n\t\t}\n\n\t\tsc->sc_screenwanted = sc->sc_oldscreen;\n\t\tsc->sc_oldscreen = -1;\n\t\treturn (wsdisplay_switch1(arg, 0, waitok));\n\t}\n\n\tsc->sc_focusidx = no;\n\tsc->sc_focus = scr;\n\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t(void) wsdisplay_update_rawkbd(sc, scr);\n#endif\n\t/* keyboard map??? */\n\n#define wsswitch_cb3 ((void (*) __P((void *, int, int)))wsdisplay_switch3)\n\tif (scr->scr_syncops) {\n\t\terror = (*scr->scr_syncops->attach)(scr->scr_synccookie, waitok,\n\t  sc->sc_isconsole && wsdisplay_cons_pollmode ? 0 : wsswitch_cb3, sc);\n\t\tif (error == EAGAIN) {\n\t\t\t/* switch will be done asynchronously */\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (wsdisplay_switch3(sc, error, waitok));\n}"
  },
  {
    "function_name": "wsdisplay_switch3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "1347-1393",
    "snippet": "int\nwsdisplay_switch3(arg, error, waitok)\n\tvoid *arg;\n\tint error, waitok;\n{\n\tstruct wsdisplay_softc *sc = arg;\n\tint no;\n\tstruct wsscreen *scr;\n\n\tif (!(sc->sc_flags & SC_SWITCHPENDING)) {\n\t\tprintf(\"wsdisplay_switch3: not switching\\n\");\n\t\treturn (EINVAL);\n\t}\n\n\tno = sc->sc_screenwanted;\n\tif (no < 0 || no >= WSDISPLAY_MAXSCREEN)\n\t\tpanic(\"wsdisplay_switch3: invalid screen %d\", no);\n\tscr = sc->sc_scr[no];\n\tif (!scr) {\n\t\tprintf(\"wsdisplay_switch3: screen %d disappeared\\n\", no);\n\t\terror = ENXIO;\n\t}\n\n\tif (error) {\n\t\t/* try to recover, avoid recursion */\n\n\t\tif (sc->sc_oldscreen == -1) {\n\t\t\tprintf(\"wsdisplay_switch3: giving up\\n\");\n\t\t\tsc->sc_focus = 0;\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t\t\twsdisplay_update_rawkbd(sc, 0);\n#endif\n\t\tsc->sc_flags &= ~SC_SWITCHPENDING;\n\t\t\treturn (error);\n\t\t}\n\n\t\tsc->sc_screenwanted = sc->sc_oldscreen;\n\t\tsc->sc_oldscreen = -1;\n\t\treturn (wsdisplay_switch1(arg, 0, waitok));\n\t}\n\n\tsc->sc_flags &= ~SC_SWITCHPENDING;\n\n\tif (!error && (scr->scr_flags & SCR_WAITACTIVE))\n\t\twakeup(scr);\n\treturn (error);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [
      "#define d ((struct wsmux_device *)data)",
      "#define d ((struct wsdisplay_kbddata *)data)",
      "#define d ((struct wsdisplay_font *)data)",
      "#define d ((struct wsdisplay_delscreendata *)data)",
      "#define d ((struct wsdisplay_addscreendata *)data)",
      "#define d ((struct wsdisplay_usefontdata *)data)",
      "#define d (*(int *)data)",
      "#define SC_SWITCHPENDING 1",
      "#define WSDISPLAY_MAXSCREEN 8",
      "#define SCR_WAITACTIVE 2\t/* someone waiting on activation */"
    ],
    "globals_used": [
      "int wsdisplay_switch1",
      "int wsdisplay_switch3",
      "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "scr"
          ],
          "line": 1391
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wsdisplay_switch1",
          "args": [
            "arg",
            "0",
            "waitok"
          ],
          "line": 1385
        },
        "resolved": true,
        "details": {
          "function_name": "wsdisplay_switch1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "1454-1493",
          "snippet": "int\nwsdisplay_switch1(arg, error, waitok)\n\tvoid *arg;\n\tint error, waitok;\n{\n\tstruct wsdisplay_softc *sc = arg;\n\tint no;\n\tstruct wsscreen *scr;\n\n\tif (!(sc->sc_flags & SC_SWITCHPENDING)) {\n\t\tprintf(\"wsdisplay_switch1: not switching\\n\");\n\t\treturn (EINVAL);\n\t}\n\n\tno = sc->sc_screenwanted;\n\tif (no < 0 || no >= WSDISPLAY_MAXSCREEN)\n\t\tpanic(\"wsdisplay_switch1: invalid screen %d\", no);\n\tscr = sc->sc_scr[no];\n\tif (!scr) {\n\t\tprintf(\"wsdisplay_switch1: screen %d disappeared\\n\", no);\n\t\terror = ENXIO;\n\t}\n\n\tif (error) {\n\tsc->sc_flags &= ~SC_SWITCHPENDING;\n\t\treturn (error);\n\t}\n\n#define wsswitch_cb2 ((void (*) __P((void *, int, int)))wsdisplay_switch2)\n\terror = (*sc->sc_accessops->show_screen)(sc->sc_accesscookie,\n\t\t\t\t\t\t scr->scr_dconf->emulcookie,\n\t\t\t\t\t\t waitok,\n\t  sc->sc_isconsole && wsdisplay_cons_pollmode ? 0 : wsswitch_cb2, sc);\n\tif (error == EAGAIN) {\n\t\t/* switch will be done asynchronously */\n\treturn (0);\n}\n\n\treturn (wsdisplay_switch2(sc, error, waitok));\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [
            "#define wsswitch_cb2 ((void (*) __P((void *, int, int)))wsdisplay_switch2)",
            "#define d ((struct wsmux_device *)data)",
            "#define d ((struct wsdisplay_kbddata *)data)",
            "#define d ((struct wsdisplay_font *)data)",
            "#define d ((struct wsdisplay_delscreendata *)data)",
            "#define d ((struct wsdisplay_addscreendata *)data)",
            "#define d ((struct wsdisplay_usefontdata *)data)",
            "#define d (*(int *)data)",
            "#define SC_SWITCHPENDING 1",
            "#define WSDISPLAY_MAXSCREEN 8"
          ],
          "globals_used": [
            "static int wsdisplay_cons_pollmode;",
            "int wsdisplay_switch1",
            "int wsdisplay_switch2",
            "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define wsswitch_cb2 ((void (*) __P((void *, int, int)))wsdisplay_switch2)\n#define d ((struct wsmux_device *)data)\n#define d ((struct wsdisplay_kbddata *)data)\n#define d ((struct wsdisplay_font *)data)\n#define d ((struct wsdisplay_delscreendata *)data)\n#define d ((struct wsdisplay_addscreendata *)data)\n#define d ((struct wsdisplay_usefontdata *)data)\n#define d (*(int *)data)\n#define SC_SWITCHPENDING 1\n#define WSDISPLAY_MAXSCREEN 8\n\nstatic int wsdisplay_cons_pollmode;\nint wsdisplay_switch1;\nint wsdisplay_switch2;\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\n\nint\nwsdisplay_switch1(arg, error, waitok)\n\tvoid *arg;\n\tint error, waitok;\n{\n\tstruct wsdisplay_softc *sc = arg;\n\tint no;\n\tstruct wsscreen *scr;\n\n\tif (!(sc->sc_flags & SC_SWITCHPENDING)) {\n\t\tprintf(\"wsdisplay_switch1: not switching\\n\");\n\t\treturn (EINVAL);\n\t}\n\n\tno = sc->sc_screenwanted;\n\tif (no < 0 || no >= WSDISPLAY_MAXSCREEN)\n\t\tpanic(\"wsdisplay_switch1: invalid screen %d\", no);\n\tscr = sc->sc_scr[no];\n\tif (!scr) {\n\t\tprintf(\"wsdisplay_switch1: screen %d disappeared\\n\", no);\n\t\terror = ENXIO;\n\t}\n\n\tif (error) {\n\tsc->sc_flags &= ~SC_SWITCHPENDING;\n\t\treturn (error);\n\t}\n\n#define wsswitch_cb2 ((void (*) __P((void *, int, int)))wsdisplay_switch2)\n\terror = (*sc->sc_accessops->show_screen)(sc->sc_accesscookie,\n\t\t\t\t\t\t scr->scr_dconf->emulcookie,\n\t\t\t\t\t\t waitok,\n\t  sc->sc_isconsole && wsdisplay_cons_pollmode ? 0 : wsswitch_cb2, sc);\n\tif (error == EAGAIN) {\n\t\t/* switch will be done asynchronously */\n\treturn (0);\n}\n\n\treturn (wsdisplay_switch2(sc, error, waitok));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wsdisplay_update_rawkbd",
          "args": [
            "sc",
            "0"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "wsdisplay_update_rawkbd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "1321-1344",
          "snippet": "int\nwsdisplay_update_rawkbd(sc, scr)\n\tstruct wsdisplay_softc *sc;\n\tstruct wsscreen *scr;\n{\n\tint s, raw, data, error;\n\ts = spltty();\n\n\traw = (scr ? scr->scr_rawkbd : 0);\n\n\tif (scr != sc->sc_focus ||\n\t    sc->sc_rawkbd == raw) {\n\t\tsplx(s);\n\t\treturn (0);\n\t}\n\n\tdata = raw ? WSKBD_RAW : WSKBD_TRANSLATED;\n\terror = wsmux_displayioctl(&sc->sc_muxdv->sc_dv, WSKBDIO_SETMODE,\n\t\t\t\t   (caddr_t)&data, 0, 0);\n\tif (!error)\n\t\tsc->sc_rawkbd = raw;\n\tsplx(s);\n\treturn (error);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\n\nint\nwsdisplay_update_rawkbd(sc, scr)\n\tstruct wsdisplay_softc *sc;\n\tstruct wsscreen *scr;\n{\n\tint s, raw, data, error;\n\ts = spltty();\n\n\traw = (scr ? scr->scr_rawkbd : 0);\n\n\tif (scr != sc->sc_focus ||\n\t    sc->sc_rawkbd == raw) {\n\t\tsplx(s);\n\t\treturn (0);\n\t}\n\n\tdata = raw ? WSKBD_RAW : WSKBD_TRANSLATED;\n\terror = wsmux_displayioctl(&sc->sc_muxdv->sc_dv, WSKBDIO_SETMODE,\n\t\t\t\t   (caddr_t)&data, 0, 0);\n\tif (!error)\n\t\tsc->sc_rawkbd = raw;\n\tsplx(s);\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"wsdisplay_switch3: giving up\\n\""
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"wsdisplay_switch3: invalid screen %d\"",
            "no"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define d ((struct wsmux_device *)data)\n#define d ((struct wsdisplay_kbddata *)data)\n#define d ((struct wsdisplay_font *)data)\n#define d ((struct wsdisplay_delscreendata *)data)\n#define d ((struct wsdisplay_addscreendata *)data)\n#define d ((struct wsdisplay_usefontdata *)data)\n#define d (*(int *)data)\n#define SC_SWITCHPENDING 1\n#define WSDISPLAY_MAXSCREEN 8\n#define SCR_WAITACTIVE 2\t/* someone waiting on activation */\n\nint wsdisplay_switch1;\nint wsdisplay_switch3;\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\n\nint\nwsdisplay_switch3(arg, error, waitok)\n\tvoid *arg;\n\tint error, waitok;\n{\n\tstruct wsdisplay_softc *sc = arg;\n\tint no;\n\tstruct wsscreen *scr;\n\n\tif (!(sc->sc_flags & SC_SWITCHPENDING)) {\n\t\tprintf(\"wsdisplay_switch3: not switching\\n\");\n\t\treturn (EINVAL);\n\t}\n\n\tno = sc->sc_screenwanted;\n\tif (no < 0 || no >= WSDISPLAY_MAXSCREEN)\n\t\tpanic(\"wsdisplay_switch3: invalid screen %d\", no);\n\tscr = sc->sc_scr[no];\n\tif (!scr) {\n\t\tprintf(\"wsdisplay_switch3: screen %d disappeared\\n\", no);\n\t\terror = ENXIO;\n\t}\n\n\tif (error) {\n\t\t/* try to recover, avoid recursion */\n\n\t\tif (sc->sc_oldscreen == -1) {\n\t\t\tprintf(\"wsdisplay_switch3: giving up\\n\");\n\t\t\tsc->sc_focus = 0;\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t\t\twsdisplay_update_rawkbd(sc, 0);\n#endif\n\t\tsc->sc_flags &= ~SC_SWITCHPENDING;\n\t\t\treturn (error);\n\t\t}\n\n\t\tsc->sc_screenwanted = sc->sc_oldscreen;\n\t\tsc->sc_oldscreen = -1;\n\t\treturn (wsdisplay_switch1(arg, 0, waitok));\n\t}\n\n\tsc->sc_flags &= ~SC_SWITCHPENDING;\n\n\tif (!error && (scr->scr_flags & SCR_WAITACTIVE))\n\t\twakeup(scr);\n\treturn (error);\n}"
  },
  {
    "function_name": "wsdisplay_update_rawkbd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "1321-1344",
    "snippet": "int\nwsdisplay_update_rawkbd(sc, scr)\n\tstruct wsdisplay_softc *sc;\n\tstruct wsscreen *scr;\n{\n\tint s, raw, data, error;\n\ts = spltty();\n\n\traw = (scr ? scr->scr_rawkbd : 0);\n\n\tif (scr != sc->sc_focus ||\n\t    sc->sc_rawkbd == raw) {\n\t\tsplx(s);\n\t\treturn (0);\n\t}\n\n\tdata = raw ? WSKBD_RAW : WSKBD_TRANSLATED;\n\terror = wsmux_displayioctl(&sc->sc_muxdv->sc_dv, WSKBDIO_SETMODE,\n\t\t\t\t   (caddr_t)&data, 0, 0);\n\tif (!error)\n\t\tsc->sc_rawkbd = raw;\n\tsplx(s);\n\treturn (error);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsmux_displayioctl",
          "args": [
            "&sc->sc_muxdv->sc_dv",
            "WSKBDIO_SETMODE",
            "(caddr_t)&data",
            "0",
            "0"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "wsmux_displayioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmux.c",
          "lines": "631-675",
          "snippet": "int\nwsmux_displayioctl(dv, cmd, data, flag, p)\n\tstruct device *dv;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct wsmux_softc *sc = (struct wsmux_softc *)dv;\n\tstruct wsplink *m;\n\tint error, ok;\n\n\tDPRINTF((\"wsmux_displayioctl: %s: sc=%p, cmd=%08lx\\n\", \n\t\t sc->sc_dv.dv_xname, sc, cmd));\n\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\tif (cmd == WSKBDIO_SETMODE) {\n\t\tsc->sc_rawkbd = *(int *)data;\n\t\tDPRINTF((\"wsmux_displayioctl: rawkbd = %d\\n\", sc->sc_rawkbd));\n\t}\t\t\n#endif\n\n\t/* \n\t * Return 0 if any of the ioctl() succeeds, otherwise the last error.\n\t * Return -1 if no mux component accepts the ioctl.\n\t */\n\terror = -1;\n\tok = 0;\n\tfor (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {\n\t\tDPRINTF((\"wsmux_displayioctl: m=%p sc=%p sc_muxp=%p\\n\", \n\t\t\t m, sc, *m->sc_muxp));\n\t\tif (m->sc_ops->ddispioctl && *m->sc_muxp == sc) {\n\t\t\terror = m->sc_ops->ddispioctl(m->sc, cmd, data,\n\t\t\t\t\t\t      flag, p);\n\t\t\tDPRINTF((\"wsmux_displayioctl: m=%p dev=%s ==> %d\\n\", \n\t\t\t\t m, m->sc->dv_xname, error));\n\t\t\tif (!error)\n\t\t\t\tok = 1;\n\t\t}\n\t}\n\tif (ok)\n\t\terror = 0;\n\n\treturn (error);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/device.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include \"wskbd.h\"",
            "#include \"wsdisplay.h\"",
            "#include \"wsmux.h\""
          ],
          "macros_used": [
            "#define d ((struct wsmux_device *)data)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n\n#define d ((struct wsmux_device *)data)\n\nint\nwsmux_displayioctl(dv, cmd, data, flag, p)\n\tstruct device *dv;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct wsmux_softc *sc = (struct wsmux_softc *)dv;\n\tstruct wsplink *m;\n\tint error, ok;\n\n\tDPRINTF((\"wsmux_displayioctl: %s: sc=%p, cmd=%08lx\\n\", \n\t\t sc->sc_dv.dv_xname, sc, cmd));\n\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\tif (cmd == WSKBDIO_SETMODE) {\n\t\tsc->sc_rawkbd = *(int *)data;\n\t\tDPRINTF((\"wsmux_displayioctl: rawkbd = %d\\n\", sc->sc_rawkbd));\n\t}\t\t\n#endif\n\n\t/* \n\t * Return 0 if any of the ioctl() succeeds, otherwise the last error.\n\t * Return -1 if no mux component accepts the ioctl.\n\t */\n\terror = -1;\n\tok = 0;\n\tfor (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {\n\t\tDPRINTF((\"wsmux_displayioctl: m=%p sc=%p sc_muxp=%p\\n\", \n\t\t\t m, sc, *m->sc_muxp));\n\t\tif (m->sc_ops->ddispioctl && *m->sc_muxp == sc) {\n\t\t\terror = m->sc_ops->ddispioctl(m->sc, cmd, data,\n\t\t\t\t\t\t      flag, p);\n\t\t\tDPRINTF((\"wsmux_displayioctl: m=%p dev=%s ==> %d\\n\", \n\t\t\t\t m, m->sc->dv_xname, error));\n\t\t\tif (!error)\n\t\t\t\tok = 1;\n\t\t}\n\t}\n\tif (ok)\n\t\terror = 0;\n\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\n\nint\nwsdisplay_update_rawkbd(sc, scr)\n\tstruct wsdisplay_softc *sc;\n\tstruct wsscreen *scr;\n{\n\tint s, raw, data, error;\n\ts = spltty();\n\n\traw = (scr ? scr->scr_rawkbd : 0);\n\n\tif (scr != sc->sc_focus ||\n\t    sc->sc_rawkbd == raw) {\n\t\tsplx(s);\n\t\treturn (0);\n\t}\n\n\tdata = raw ? WSKBD_RAW : WSKBD_TRANSLATED;\n\terror = wsmux_displayioctl(&sc->sc_muxdv->sc_dv, WSKBDIO_SETMODE,\n\t\t\t\t   (caddr_t)&data, 0, 0);\n\tif (!error)\n\t\tsc->sc_rawkbd = raw;\n\tsplx(s);\n\treturn (error);\n}"
  },
  {
    "function_name": "wsdisplay_kbdinput",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "1290-1318",
    "snippet": "void\nwsdisplay_kbdinput(dev, ks)\n\tstruct device *dev;\n\tkeysym_t ks;\n{\n\tstruct wsdisplay_softc *sc = (struct wsdisplay_softc *)dev;\n\tstruct wsscreen *scr;\n\tchar *dp;\n\tint count;\n\tstruct tty *tp;\n\n\tKASSERT(sc != NULL);\n\n\tscr = sc->sc_focus;\n\n\tif (!scr || !WSSCREEN_HAS_TTY(scr))\n\t\treturn;\n\n\ttp = scr->scr_tty;\n\n\tif (KS_GROUP(ks) == KS_GROUP_Ascii)\n\t\t(*linesw[tp->t_line].l_rint)(KS_VALUE(ks), tp);\n\telse if (WSSCREEN_HAS_EMULATOR(scr)) {\n\t\tcount = (*scr->scr_dconf->wsemul->translate)\n\t\t    (scr->scr_dconf->wsemulcookie, ks, &dp);\n\t\twhile (count-- > 0)\n\t\t\t(*linesw[tp->t_line].l_rint)(*dp++, tp);\n\t}\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;",
      "struct tty *\nwsdisplaytty(dev)\n\tdev_t dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "*dp++",
            "tp"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "scr->scr_dconf->wsemulcookie",
            "ks",
            "&dp"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSSCREEN_HAS_EMULATOR",
          "args": [
            "scr"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "KS_VALUE(ks)",
            "tp"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KS_VALUE",
          "args": [
            "ks"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KS_GROUP",
          "args": [
            "ks"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSSCREEN_HAS_TTY",
          "args": [
            "scr"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KASSERT",
          "args": [
            "sc != NULL"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\nstruct tty *\nwsdisplaytty(dev)\n\tdev_t dev;\n\nvoid\nwsdisplay_kbdinput(dev, ks)\n\tstruct device *dev;\n\tkeysym_t ks;\n{\n\tstruct wsdisplay_softc *sc = (struct wsdisplay_softc *)dev;\n\tstruct wsscreen *scr;\n\tchar *dp;\n\tint count;\n\tstruct tty *tp;\n\n\tKASSERT(sc != NULL);\n\n\tscr = sc->sc_focus;\n\n\tif (!scr || !WSSCREEN_HAS_TTY(scr))\n\t\treturn;\n\n\ttp = scr->scr_tty;\n\n\tif (KS_GROUP(ks) == KS_GROUP_Ascii)\n\t\t(*linesw[tp->t_line].l_rint)(KS_VALUE(ks), tp);\n\telse if (WSSCREEN_HAS_EMULATOR(scr)) {\n\t\tcount = (*scr->scr_dconf->wsemul->translate)\n\t\t    (scr->scr_dconf->wsemulcookie, ks, &dp);\n\t\twhile (count-- > 0)\n\t\t\t(*linesw[tp->t_line].l_rint)(*dp++, tp);\n\t}\n}"
  },
  {
    "function_name": "wsdisplay_emulinput",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "1265-1285",
    "snippet": "void\nwsdisplay_emulinput(v, data, count)\n\tvoid *v;\n\tconst u_char *data;\n\tu_int count;\n{\n\tstruct wsscreen *scr = v;\n\tstruct tty *tp;\n\n\tif (v == NULL)\t\t\t/* console, before real attach */\n\t\treturn;\n\n\tif (scr->scr_flags & SCR_GRAPHICS) /* XXX can't happen */\n\t\treturn;\n\tif (!WSSCREEN_HAS_TTY(scr))\n\t\treturn;\n\n\ttp = scr->scr_tty;\n\twhile (count-- > 0)\n\t\t(*linesw[tp->t_line].l_rint)(*data++, tp);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [
      "#define SCR_GRAPHICS 4\t\t/* graphics mode, no text (emulation) output */"
    ],
    "globals_used": [
      "int console;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "*data++",
            "tp"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSSCREEN_HAS_TTY",
          "args": [
            "scr"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define SCR_GRAPHICS 4\t\t/* graphics mode, no text (emulation) output */\n\nint console;\n\nvoid\nwsdisplay_emulinput(v, data, count)\n\tvoid *v;\n\tconst u_char *data;\n\tu_int count;\n{\n\tstruct wsscreen *scr = v;\n\tstruct tty *tp;\n\n\tif (v == NULL)\t\t\t/* console, before real attach */\n\t\treturn;\n\n\tif (scr->scr_flags & SCR_GRAPHICS) /* XXX can't happen */\n\t\treturn;\n\tif (!WSSCREEN_HAS_TTY(scr))\n\t\treturn;\n\n\ttp = scr->scr_tty;\n\twhile (count-- > 0)\n\t\t(*linesw[tp->t_line].l_rint)(*data++, tp);\n}"
  },
  {
    "function_name": "wsdisplay_emulbell",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "1249-1263",
    "snippet": "void\nwsdisplay_emulbell(v)\n\tvoid *v;\n{\n\tstruct wsscreen *scr = v;\n\n\tif (scr == NULL)\t\t/* console, before real attach */\n\t\treturn;\n\n\tif (scr->scr_flags & SCR_GRAPHICS) /* can this happen? */\n\t\treturn;\n\n\t(void) wsdisplay_internal_ioctl(scr->sc, scr, WSKBDIO_BELL, NULL,\n\t\t\t\t\tFWRITE, NULL);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [
      "#define SCR_GRAPHICS 4\t\t/* graphics mode, no text (emulation) output */"
    ],
    "globals_used": [
      "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;",
      "int console;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wsdisplay_internal_ioctl",
          "args": [
            "scr->sc",
            "scr",
            "WSKBDIO_BELL",
            "NULL",
            "FWRITE",
            "NULL"
          ],
          "line": 1261
        },
        "resolved": true,
        "details": {
          "function_name": "wsdisplay_internal_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "936-1012",
          "snippet": "int\nwsdisplay_internal_ioctl(sc, scr, cmd, data, flag, p)\n\tstruct wsdisplay_softc *sc;\n\tstruct wsscreen *scr;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tint error;\n\tchar namebuf[16];\n\tstruct wsdisplay_font fd;\n\n#if NWSKBD > 0\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t\tswitch (cmd) {\n\t\t    case WSKBDIO_SETMODE:\n\t\t\tscr->scr_rawkbd = (*(int *)data == WSKBD_RAW);\n\t\t\treturn (wsdisplay_update_rawkbd(sc, scr));\n\t\t    case WSKBDIO_GETMODE:\n\t\t\t*(int *)data = (scr->scr_rawkbd ?\n\t\t\t\t\tWSKBD_RAW : WSKBD_TRANSLATED);\n\t\t\treturn (0);\n\t\t}\n#endif\n\terror = wsmux_displayioctl(&sc->sc_muxdv->sc_dv, cmd, data, flag, p);\n\t\tif (error >= 0)\n\t\treturn (error);\n#endif /* NWSKBD > 0 */\n\n\tswitch (cmd) {\n\tcase WSDISPLAYIO_GMODE:\n\t\t*(u_int *)data = (scr->scr_flags & SCR_GRAPHICS ?\n\t\t\t\t  WSDISPLAYIO_MODE_MAPPED :\n\t\t\t\t  WSDISPLAYIO_MODE_EMUL);\n\t\treturn (0);\n\n\tcase WSDISPLAYIO_SMODE:\n#define d (*(int *)data)\n\t\tif (d != WSDISPLAYIO_MODE_EMUL &&\n\t\t    d != WSDISPLAYIO_MODE_MAPPED)\n\t\t\treturn (EINVAL);\n\n\t    if (WSSCREEN_HAS_EMULATOR(scr)) {\n\t\t    scr->scr_flags &= ~SCR_GRAPHICS;\n\t\t    if (d == WSDISPLAYIO_MODE_MAPPED)\n\t\t\t    scr->scr_flags |= SCR_GRAPHICS;\n\t    } else if (d == WSDISPLAYIO_MODE_EMUL)\n\t\t    return (EINVAL);\n\t    return (0);\n#undef d\n\n\tcase WSDISPLAYIO_USEFONT:\n#define d ((struct wsdisplay_usefontdata *)data)\n\t\tif (!sc->sc_accessops->load_font)\n\t\t\treturn (EINVAL);\n\t\tif (d->name) {\n\t\t\terror = copyinstr(d->name, namebuf, sizeof(namebuf), 0);\n\t\t\tif (error)\n\t\t\t\treturn (error);\n\t\t\tfd.name = namebuf;\n\t\t} else\n\t\t\tfd.name = 0;\n\t\tfd.data = 0;\n\t\terror = (*sc->sc_accessops->load_font)(sc->sc_accesscookie,\n\t\t\t\t\tscr->scr_dconf->emulcookie, &fd);\n\t\tif (!error && WSSCREEN_HAS_EMULATOR(scr))\n\t\t\t(*scr->scr_dconf->wsemul->reset)\n\t\t\t\t(scr->scr_dconf->wsemulcookie, WSEMUL_SYNCFONT);\n\t\treturn (error);\n#undef d\n\t}\n\n\t/* check ioctls for display */\n\treturn ((*sc->sc_accessops->ioctl)(sc->sc_accesscookie, cmd, data,\n\t    flag, p));\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [
            "#define d ((struct wsmux_device *)data)",
            "#define d ((struct wsdisplay_kbddata *)data)",
            "#define d ((struct wsdisplay_font *)data)",
            "#define d ((struct wsdisplay_delscreendata *)data)",
            "#define d ((struct wsdisplay_addscreendata *)data)",
            "#define d ((struct wsdisplay_usefontdata *)data)",
            "#define d (*(int *)data)",
            "#define SCR_GRAPHICS 4\t\t/* graphics mode, no text (emulation) output */"
          ],
          "globals_used": [
            "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;",
            "const char *name;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define d ((struct wsmux_device *)data)\n#define d ((struct wsdisplay_kbddata *)data)\n#define d ((struct wsdisplay_font *)data)\n#define d ((struct wsdisplay_delscreendata *)data)\n#define d ((struct wsdisplay_addscreendata *)data)\n#define d ((struct wsdisplay_usefontdata *)data)\n#define d (*(int *)data)\n#define SCR_GRAPHICS 4\t\t/* graphics mode, no text (emulation) output */\n\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\nconst char *name;\n\nint\nwsdisplay_internal_ioctl(sc, scr, cmd, data, flag, p)\n\tstruct wsdisplay_softc *sc;\n\tstruct wsscreen *scr;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tint error;\n\tchar namebuf[16];\n\tstruct wsdisplay_font fd;\n\n#if NWSKBD > 0\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t\tswitch (cmd) {\n\t\t    case WSKBDIO_SETMODE:\n\t\t\tscr->scr_rawkbd = (*(int *)data == WSKBD_RAW);\n\t\t\treturn (wsdisplay_update_rawkbd(sc, scr));\n\t\t    case WSKBDIO_GETMODE:\n\t\t\t*(int *)data = (scr->scr_rawkbd ?\n\t\t\t\t\tWSKBD_RAW : WSKBD_TRANSLATED);\n\t\t\treturn (0);\n\t\t}\n#endif\n\terror = wsmux_displayioctl(&sc->sc_muxdv->sc_dv, cmd, data, flag, p);\n\t\tif (error >= 0)\n\t\treturn (error);\n#endif /* NWSKBD > 0 */\n\n\tswitch (cmd) {\n\tcase WSDISPLAYIO_GMODE:\n\t\t*(u_int *)data = (scr->scr_flags & SCR_GRAPHICS ?\n\t\t\t\t  WSDISPLAYIO_MODE_MAPPED :\n\t\t\t\t  WSDISPLAYIO_MODE_EMUL);\n\t\treturn (0);\n\n\tcase WSDISPLAYIO_SMODE:\n#define d (*(int *)data)\n\t\tif (d != WSDISPLAYIO_MODE_EMUL &&\n\t\t    d != WSDISPLAYIO_MODE_MAPPED)\n\t\t\treturn (EINVAL);\n\n\t    if (WSSCREEN_HAS_EMULATOR(scr)) {\n\t\t    scr->scr_flags &= ~SCR_GRAPHICS;\n\t\t    if (d == WSDISPLAYIO_MODE_MAPPED)\n\t\t\t    scr->scr_flags |= SCR_GRAPHICS;\n\t    } else if (d == WSDISPLAYIO_MODE_EMUL)\n\t\t    return (EINVAL);\n\t    return (0);\n#undef d\n\n\tcase WSDISPLAYIO_USEFONT:\n#define d ((struct wsdisplay_usefontdata *)data)\n\t\tif (!sc->sc_accessops->load_font)\n\t\t\treturn (EINVAL);\n\t\tif (d->name) {\n\t\t\terror = copyinstr(d->name, namebuf, sizeof(namebuf), 0);\n\t\t\tif (error)\n\t\t\t\treturn (error);\n\t\t\tfd.name = namebuf;\n\t\t} else\n\t\t\tfd.name = 0;\n\t\tfd.data = 0;\n\t\terror = (*sc->sc_accessops->load_font)(sc->sc_accesscookie,\n\t\t\t\t\tscr->scr_dconf->emulcookie, &fd);\n\t\tif (!error && WSSCREEN_HAS_EMULATOR(scr))\n\t\t\t(*scr->scr_dconf->wsemul->reset)\n\t\t\t\t(scr->scr_dconf->wsemulcookie, WSEMUL_SYNCFONT);\n\t\treturn (error);\n#undef d\n\t}\n\n\t/* check ioctls for display */\n\treturn ((*sc->sc_accessops->ioctl)(sc->sc_accesscookie, cmd, data,\n\t    flag, p));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define SCR_GRAPHICS 4\t\t/* graphics mode, no text (emulation) output */\n\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\nint console;\n\nvoid\nwsdisplay_emulbell(v)\n\tvoid *v;\n{\n\tstruct wsscreen *scr = v;\n\n\tif (scr == NULL)\t\t/* console, before real attach */\n\t\treturn;\n\n\tif (scr->scr_flags & SCR_GRAPHICS) /* can this happen? */\n\t\treturn;\n\n\t(void) wsdisplay_internal_ioctl(scr->sc, scr, WSKBDIO_BELL, NULL,\n\t\t\t\t\tFWRITE, NULL);\n}"
  },
  {
    "function_name": "wsdisplayparam",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "1234-1244",
    "snippet": "int\nwsdisplayparam(tp, t)\n\tstruct tty *tp;\n\tstruct termios *t;\n{\n\n\ttp->t_ispeed = t->c_ispeed;\n\ttp->t_ospeed = t->c_ospeed;\n\ttp->t_cflag = t->c_cflag;\n\treturn 0;\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int wsdisplayparam"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstatic int wsdisplayparam;\n\nint\nwsdisplayparam(tp, t)\n\tstruct tty *tp;\n\tstruct termios *t;\n{\n\n\ttp->t_ispeed = t->c_ispeed;\n\ttp->t_ospeed = t->c_ospeed;\n\ttp->t_cflag = t->c_cflag;\n\treturn 0;\n}"
  },
  {
    "function_name": "wsdisplaystop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "1218-1231",
    "snippet": "int\nwsdisplaystop(tp, flag)\n\tstruct tty *tp;\n\tint flag;\n{\n\tint s;\n\n\ts = spltty();\n\tif (ISSET(tp->t_state, TS_BUSY))\n\t\tif (!ISSET(tp->t_state, TS_TTSTOP))\n\t\t\tSET(tp->t_state, TS_FLUSH);\n\tsplx(s);\n\treturn 0;\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET",
          "args": [
            "tp->t_state",
            "TS_FLUSH"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "tp->t_state",
            "TS_TTSTOP"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISSET",
          "args": [
            "tp->t_state",
            "TS_BUSY"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nint\nwsdisplaystop(tp, flag)\n\tstruct tty *tp;\n\tint flag;\n{\n\tint s;\n\n\ts = spltty();\n\tif (ISSET(tp->t_state, TS_BUSY))\n\t\tif (!ISSET(tp->t_state, TS_TTSTOP))\n\t\t\tSET(tp->t_state, TS_FLUSH);\n\tsplx(s);\n\treturn 0;\n}"
  },
  {
    "function_name": "wsdisplaystart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "1147-1216",
    "snippet": "void\nwsdisplaystart(tp)\n\tstruct tty *tp;\n{\n\tstruct wsdisplay_softc *sc;\n\tstruct wsscreen *scr;\n\tint s, n;\n\tu_char *buf;\n\t\t\n\ts = spltty();\n\tif (tp->t_state & (TS_TIMEOUT | TS_BUSY | TS_TTSTOP)) {\n\t\tsplx(s);\n\t\treturn;\n\t}\n\tsc = wsdisplay_cd.cd_devs[WSDISPLAYUNIT(tp->t_dev)];\n\tscr = sc->sc_scr[WSDISPLAYSCREEN(tp->t_dev)];\n\tif (scr->scr_hold_screen) {\n\t\ttp->t_state |= TS_TIMEOUT;\n\t\tsplx(s);\n\t\treturn;\n\t}\n\ttp->t_state |= TS_BUSY; \n\tsplx(s);\n\t\n\t/*\n\t * Drain output from ring buffer.\n\t * The output will normally be in one contiguous chunk, but when the \n\t * ring wraps, it will be in two pieces.. one at the end of the ring, \n\t * the other at the start.  For performance, rather than loop here, \n\t * we output one chunk, see if there's another one, and if so, output \n\t * it too.\n\t */\n\n\tn = ndqb(&tp->t_outq, 0);\n\tbuf = tp->t_outq.c_cf;\n\n\tif (!(scr->scr_flags & SCR_GRAPHICS)) {\n\t\tKASSERT(WSSCREEN_HAS_EMULATOR(scr));\n\t\t(*scr->scr_dconf->wsemul->output)(scr->scr_dconf->wsemulcookie,\n\t\t\t\t\t\t  buf, n, 0);\n\t}\n\tndflush(&tp->t_outq, n);\n\n\tif ((n = ndqb(&tp->t_outq, 0)) > 0) {\n\t\tbuf = tp->t_outq.c_cf;\n\n\tif (!(scr->scr_flags & SCR_GRAPHICS)) {\n\t\tKASSERT(WSSCREEN_HAS_EMULATOR(scr));\n\t\t(*scr->scr_dconf->wsemul->output)(scr->scr_dconf->wsemulcookie,\n\t\t    buf, n, 0);\n\t}\n\t\tndflush(&tp->t_outq, n);\n\t}\n\n\ts = spltty();\n\ttp->t_state &= ~TS_BUSY;\n\t/* Come back if there's more to do */\n\tif (tp->t_outq.c_cc) {\n\t\ttp->t_state |= TS_TIMEOUT;\n\t\ttimeout(ttrstrt, tp, (hz > 128) ? (hz / 128) : 1);\n\t}\n\tif (tp->t_outq.c_cc <= tp->t_lowat) {\n\t\tif (tp->t_state&TS_ASLEEP) {\n\t\t\ttp->t_state &= ~TS_ASLEEP;\n\t\t\twakeup((caddr_t)&tp->t_outq);\n\t\t}\n\t\tselwakeup(&tp->t_wsel);\n\t}\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [
      "#define SCR_GRAPHICS 4\t\t/* graphics mode, no text (emulation) output */"
    ],
    "globals_used": [
      "extern struct cfdriver wsdisplay_cd;",
      "struct cfdriver wsdisplay_cd = {\n\tNULL, \"wsdisplay\", DV_TTY\n};",
      "static void wsdisplaystart",
      "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selwakeup",
          "args": [
            "&tp->t_wsel"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "(caddr_t)&tp->t_outq"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "ttrstrt",
            "tp",
            "(hz > 128) ? (hz / 128) : 1"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "usl_attachtimeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay_compat_usl.c",
          "lines": "278-297",
          "snippet": "static void\nusl_attachtimeout(arg)\n\tvoid *arg;\n{\n\tstruct usl_syncdata *sd = arg;\n\n\tprintf(\"usl_attachtimeout\\n\");\n\n\tif (!(sd->s_flags & SF_ATTACHPENDING)) {\n\t\tprintf(\"usl_attachtimeout: not attaching\\n\");\n\t\treturn;\n\t}\n\n\tsd->s_flags &= ~SF_ATTACHPENDING;\n\n\tif (sd->s_callback)\n\t\t(*sd->s_callback)(sd->s_cbarg, EIO, 0);\n\n\t(void) usl_sync_check(sd);\n}",
          "includes": [
            "#include <dev/wscons/wsdisplay_usl_io.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/errno.h>",
            "#include <sys/malloc.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/timeout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define SF_ATTACHPENDING 2"
          ],
          "globals_used": [
            "static int usl_sync_check",
            "static void usl_attachtimeout"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsdisplay_usl_io.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/errno.h>\n#include <sys/malloc.h>\n#include <sys/signalvar.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define SF_ATTACHPENDING 2\n\nstatic int usl_sync_check;\nstatic void usl_attachtimeout;\n\nstatic void\nusl_attachtimeout(arg)\n\tvoid *arg;\n{\n\tstruct usl_syncdata *sd = arg;\n\n\tprintf(\"usl_attachtimeout\\n\");\n\n\tif (!(sd->s_flags & SF_ATTACHPENDING)) {\n\t\tprintf(\"usl_attachtimeout: not attaching\\n\");\n\t\treturn;\n\t}\n\n\tsd->s_flags &= ~SF_ATTACHPENDING;\n\n\tif (sd->s_callback)\n\t\t(*sd->s_callback)(sd->s_cbarg, EIO, 0);\n\n\t(void) usl_sync_check(sd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndflush",
          "args": [
            "&tp->t_outq",
            "n"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "scr->scr_dconf->wsemulcookie",
            "buf",
            "n",
            "0"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KASSERT",
          "args": [
            "WSSCREEN_HAS_EMULATOR(scr)"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSSCREEN_HAS_EMULATOR",
          "args": [
            "scr"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndqb",
          "args": [
            "&tp->t_outq",
            "0"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndflush",
          "args": [
            "&tp->t_outq",
            "n"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "scr->scr_dconf->wsemulcookie",
            "buf",
            "n",
            "0"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KASSERT",
          "args": [
            "WSSCREEN_HAS_EMULATOR(scr)"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSSCREEN_HAS_EMULATOR",
          "args": [
            "scr"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ndqb",
          "args": [
            "&tp->t_outq",
            "0"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSDISPLAYSCREEN",
          "args": [
            "tp->t_dev"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSDISPLAYUNIT",
          "args": [
            "tp->t_dev"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define SCR_GRAPHICS 4\t\t/* graphics mode, no text (emulation) output */\n\nextern struct cfdriver wsdisplay_cd;\nstruct cfdriver wsdisplay_cd = {\n\tNULL, \"wsdisplay\", DV_TTY\n};\nstatic void wsdisplaystart;\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\n\nvoid\nwsdisplaystart(tp)\n\tstruct tty *tp;\n{\n\tstruct wsdisplay_softc *sc;\n\tstruct wsscreen *scr;\n\tint s, n;\n\tu_char *buf;\n\t\t\n\ts = spltty();\n\tif (tp->t_state & (TS_TIMEOUT | TS_BUSY | TS_TTSTOP)) {\n\t\tsplx(s);\n\t\treturn;\n\t}\n\tsc = wsdisplay_cd.cd_devs[WSDISPLAYUNIT(tp->t_dev)];\n\tscr = sc->sc_scr[WSDISPLAYSCREEN(tp->t_dev)];\n\tif (scr->scr_hold_screen) {\n\t\ttp->t_state |= TS_TIMEOUT;\n\t\tsplx(s);\n\t\treturn;\n\t}\n\ttp->t_state |= TS_BUSY; \n\tsplx(s);\n\t\n\t/*\n\t * Drain output from ring buffer.\n\t * The output will normally be in one contiguous chunk, but when the \n\t * ring wraps, it will be in two pieces.. one at the end of the ring, \n\t * the other at the start.  For performance, rather than loop here, \n\t * we output one chunk, see if there's another one, and if so, output \n\t * it too.\n\t */\n\n\tn = ndqb(&tp->t_outq, 0);\n\tbuf = tp->t_outq.c_cf;\n\n\tif (!(scr->scr_flags & SCR_GRAPHICS)) {\n\t\tKASSERT(WSSCREEN_HAS_EMULATOR(scr));\n\t\t(*scr->scr_dconf->wsemul->output)(scr->scr_dconf->wsemulcookie,\n\t\t\t\t\t\t  buf, n, 0);\n\t}\n\tndflush(&tp->t_outq, n);\n\n\tif ((n = ndqb(&tp->t_outq, 0)) > 0) {\n\t\tbuf = tp->t_outq.c_cf;\n\n\tif (!(scr->scr_flags & SCR_GRAPHICS)) {\n\t\tKASSERT(WSSCREEN_HAS_EMULATOR(scr));\n\t\t(*scr->scr_dconf->wsemul->output)(scr->scr_dconf->wsemulcookie,\n\t\t    buf, n, 0);\n\t}\n\t\tndflush(&tp->t_outq, n);\n\t}\n\n\ts = spltty();\n\ttp->t_state &= ~TS_BUSY;\n\t/* Come back if there's more to do */\n\tif (tp->t_outq.c_cc) {\n\t\ttp->t_state |= TS_TIMEOUT;\n\t\ttimeout(ttrstrt, tp, (hz > 128) ? (hz / 128) : 1);\n\t}\n\tif (tp->t_outq.c_cc <= tp->t_lowat) {\n\t\tif (tp->t_state&TS_ASLEEP) {\n\t\t\ttp->t_state &= ~TS_ASLEEP;\n\t\t\twakeup((caddr_t)&tp->t_outq);\n\t\t}\n\t\tselwakeup(&tp->t_wsel);\n\t}\n\tsplx(s);\n}"
  },
  {
    "function_name": "wsdisplaymmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "1126-1145",
    "snippet": "int\nwsdisplaymmap(dev, offset, prot)\n\tdev_t dev;\n\tint offset;\t\t/* XXX */\n\tint prot;\n{\n\tstruct wsdisplay_softc *sc = wsdisplay_cd.cd_devs[WSDISPLAYUNIT(dev)];\n\tstruct wsscreen *scr;\n\n\tif (ISWSDISPLAYCTL(dev))\n\t\treturn (-1);\n\n\tscr = sc->sc_scr[WSDISPLAYSCREEN(dev)];\n\n\tif (!(scr->scr_flags & SCR_GRAPHICS))\n\t\treturn (-1);\n\n\t/* pass mmap to display */\n\treturn ((*sc->sc_accessops->mmap)(sc->sc_accesscookie, offset, prot));\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [
      "#define SCR_GRAPHICS 4\t\t/* graphics mode, no text (emulation) output */"
    ],
    "globals_used": [
      "extern struct cfdriver wsdisplay_cd;",
      "struct cfdriver wsdisplay_cd = {\n\tNULL, \"wsdisplay\", DV_TTY\n};",
      "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;",
      "struct tty *\nwsdisplaytty(dev)\n\tdev_t dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc->sc_accesscookie",
            "offset",
            "prot"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSDISPLAYSCREEN",
          "args": [
            "dev"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISWSDISPLAYCTL",
          "args": [
            "dev"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSDISPLAYUNIT",
          "args": [
            "dev"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define SCR_GRAPHICS 4\t\t/* graphics mode, no text (emulation) output */\n\nextern struct cfdriver wsdisplay_cd;\nstruct cfdriver wsdisplay_cd = {\n\tNULL, \"wsdisplay\", DV_TTY\n};\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\nstruct tty *\nwsdisplaytty(dev)\n\tdev_t dev;\n\nint\nwsdisplaymmap(dev, offset, prot)\n\tdev_t dev;\n\tint offset;\t\t/* XXX */\n\tint prot;\n{\n\tstruct wsdisplay_softc *sc = wsdisplay_cd.cd_devs[WSDISPLAYUNIT(dev)];\n\tstruct wsscreen *scr;\n\n\tif (ISWSDISPLAYCTL(dev))\n\t\treturn (-1);\n\n\tscr = sc->sc_scr[WSDISPLAYSCREEN(dev)];\n\n\tif (!(scr->scr_flags & SCR_GRAPHICS))\n\t\treturn (-1);\n\n\t/* pass mmap to display */\n\treturn ((*sc->sc_accessops->mmap)(sc->sc_accesscookie, offset, prot));\n}"
  },
  {
    "function_name": "wsdisplay_cfg_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "1014-1124",
    "snippet": "int\nwsdisplay_cfg_ioctl(sc, cmd, data, flag, p)\n\tstruct wsdisplay_softc *sc;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tint error;\n\tchar *type, typebuf[16], *emul, emulbuf[16];\n\tvoid *buf;\n#if defined(COMPAT_14) && NWSKBD > 0\n\tstruct wsmux_device wsmuxdata;\n#endif\n\n\tswitch (cmd) {\n\tcase WSDISPLAYIO_ADDSCREEN:\n#define d ((struct wsdisplay_addscreendata *)data)\n\t\tif (d->screentype) {\n\t\t\terror = copyinstr(d->screentype, typebuf,\n\t\t\t\t\t  sizeof(typebuf), 0);\n\t\t\tif (error)\n\t\t\t\treturn (error);\n\t\t\ttype = typebuf;\n\t\t} else\n\t\t\ttype = 0;\n\t\tif (d->emul) {\n\t\t\terror = copyinstr(d->emul, emulbuf, sizeof(emulbuf), 0);\n\t\t\tif (error)\n\t\t\t\treturn (error);\n\t\t\temul = emulbuf;\n\t\t} else\n\t\t\temul = 0;\n\n\t\tif ((error = wsdisplay_addscreen(sc, d->idx, type, emul)) == 0)\n\t\t\twsdisplay_addscreen_print(sc, d->idx, 0);\n\t\treturn (error);\n#undef d\n\tcase WSDISPLAYIO_DELSCREEN:\n#define d ((struct wsdisplay_delscreendata *)data)\n\t\treturn (wsdisplay_delscreen(sc, d->idx, d->flags));\n#undef d\n\tcase WSDISPLAYIO_LDFONT:\n#define d ((struct wsdisplay_font *)data)\n\t\tif (!sc->sc_accessops->load_font)\n\t\t\treturn (EINVAL);\n\t\tif (d->name) {\n\t\t\terror = copyinstr(d->name, typebuf, sizeof(typebuf), 0);\n\t\t\tif (error)\n\t\t\t\treturn (error);\n\t\t\td->name = typebuf;\n\t\t} else\n\t\t\td->name = \"loaded\"; /* ??? */\n\t\tbuf = malloc(d->fontheight * d->stride * d->numchars,\n\t\t\t     M_DEVBUF, M_WAITOK);\n\t\terror = copyin(d->data, buf,\n\t\t\t       d->fontheight * d->stride * d->numchars);\n\t\tif (error) {\n\t\t\tfree(buf, M_DEVBUF);\n\t\t\treturn (error);\n\t\t}\n\t\td->data = buf;\n\t\terror =\n\t\t  (*sc->sc_accessops->load_font)(sc->sc_accesscookie, 0, d);\n\t\tfree(buf, M_DEVBUF);\n#undef d\n\t\treturn (error);\n\n#if NWSKBD > 0\n#ifdef COMPAT_14\n\tcase _O_WSDISPLAYIO_SETKEYBOARD:\n#define d ((struct wsdisplay_kbddata *)data)\n\t\tswitch (d->op) {\n\t\tcase _O_WSDISPLAY_KBD_ADD:\n\t\t\tif (d->idx == -1) {\n\t\t\t\td->idx = wskbd_pickfree();\n\t\t\t\tif (d->idx == -1)\n\t\t\t\t\treturn (ENXIO);\n\t\t\t}\n\t\t\twsmuxdata.type = WSMUX_KBD;\n\t\t\twsmuxdata.idx = d->idx;\n\t\t\treturn (wsmuxdoioctl(&sc->sc_muxdv->sc_dv,\n\t\t\t\t\t     WSMUX_ADD_DEVICE,\n\t\t\t\t\t     (caddr_t)&wsmuxdata, flag, p));\n\t\tcase _O_WSDISPLAY_KBD_DEL:\n\t\t\twsmuxdata.type = WSMUX_KBD;\n\t\t\twsmuxdata.idx = d->idx;\n\t\t\treturn (wsmuxdoioctl(&sc->sc_muxdv->sc_dv,\n\t\t\t\t\t     WSMUX_REMOVE_DEVICE,\n\t\t\t\t\t     (caddr_t)&wsmuxdata, flag, p));\n\t\tdefault:\n\t\t\treturn (EINVAL);\n\t\t}\n#undef d\n#endif\n\n\tcase WSMUX_ADD_DEVICE:\n#define d ((struct wsmux_device *)data)\n\t\tif (d->idx == -1 && d->type == WSMUX_KBD)\n\t\t\td->idx = wskbd_pickfree();\n#undef d\n\t\t/* fall into */\n\tcase WSMUX_INJECTEVENT:\n\tcase WSMUX_REMOVE_DEVICE:\n\tcase WSMUX_LIST_DEVICES:\n\t\treturn (wsmuxdoioctl(&sc->sc_muxdv->sc_dv, cmd, data, flag,p));\n#endif /* NWSKBD > 0 */\n\n\t}\n\treturn (EINVAL);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [
      "#define d ((struct wsmux_device *)data)",
      "#define d ((struct wsdisplay_kbddata *)data)",
      "#define d ((struct wsdisplay_font *)data)",
      "#define d ((struct wsdisplay_delscreendata *)data)",
      "#define d ((struct wsdisplay_addscreendata *)data)",
      "#define d ((struct wsdisplay_usefontdata *)data)",
      "#define d (*(int *)data)"
    ],
    "globals_used": [
      "int wsdisplay_addscreen",
      "static void wsdisplay_addscreen_print",
      "int wsdisplay_delscreen",
      "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;",
      "const char *emul;",
      "const struct wsscreen_descr *type;",
      "const char *name;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wsmuxdoioctl",
          "args": [
            "&sc->sc_muxdv->sc_dv",
            "cmd",
            "data",
            "flag",
            "p"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "wsmuxdoioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmux.c",
          "lines": "506-629",
          "snippet": "int\nwsmuxdoioctl(dv, cmd, data, flag, p)\n\tstruct device *dv;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct wsmux_softc *sc = (struct wsmux_softc *)dv;\n\tstruct wsplink *m;\n\tint error, ok;\n\tint s, put, get, n;\n\tstruct wseventvar *evar;\n\tstruct wscons_event *ev;\n\tstruct timeval xxxtime;\n\tstruct wsmux_device_list *l;\n\n\tDPRINTF((\"wsmuxdoioctl: %s: sc=%p, cmd=%08lx\\n\", \n\t\t sc->sc_dv.dv_xname, sc, cmd));\n\n\tswitch (cmd) {\n\tcase WSMUX_INJECTEVENT:\n\t\t/* Inject an event, e.g., from moused. */\n\t\tif (!sc->sc_events.io)\n\t\t\treturn (EACCES);\n\n\t\tevar = &sc->sc_events;\n\t\ts = spltty();\n\t\tget = evar->get;\n\t\tput = evar->put;\n\t\tif (++put % WSEVENT_QSIZE == get) {\n\t\t\tput--;\n\t\t\tsplx(s);\n\t\t\treturn (ENOSPC);\n\t\t}\n\t\tif (put >= WSEVENT_QSIZE)\n\t\t\tput = 0;\n\t\tev = &evar->q[put];\n\t\t*ev = *(struct wscons_event *)data;\n\t\tmicrotime(&xxxtime);\n\t\tTIMEVAL_TO_TIMESPEC(&xxxtime, &ev->time);\n\t\tevar->put = put;\n\t\tWSEVENT_WAKEUP(evar);\n\t\tsplx(s);\n\t\treturn (0);\n\tcase WSMUX_ADD_DEVICE:\n#define d ((struct wsmux_device *)data)\n\t\tswitch (d->type) {\n#if NWSMOUSE > 0\n\t\tcase WSMUX_MOUSE:\n\t\t\treturn (wsmouse_add_mux(d->idx, sc));\n#endif\n#if NWSKBD > 0\n\t\tcase WSMUX_KBD:\n\t\t\treturn (wskbd_add_mux(d->idx, sc));\n#endif\n#if NWSMUX > 0\n\t\tcase WSMUX_MUX:\n\t\t\treturn (wsmux_add_mux(d->idx, sc));\n#endif\n\t\tdefault:\n\t\t\treturn (EINVAL);\n\t\t}\n\tcase WSMUX_REMOVE_DEVICE:\n\t\tswitch (d->type) {\n#if NWSMOUSE > 0\n\t\tcase WSMUX_MOUSE:\n\t\t\treturn (wsmouse_rem_mux(d->idx, sc));\n#endif\n#if NWSKBD > 0\n\t\tcase WSMUX_KBD:\n\t\t\treturn (wskbd_rem_mux(d->idx, sc));\n#endif\n#if NWSMUX > 0\n\t\tcase WSMUX_MUX:\n\t\t\treturn (wsmux_rem_mux(d->idx, sc));\n#endif\n\t\tdefault:\n\t\t\treturn (EINVAL);\n\t\t}\n#undef d\n\tcase WSMUX_LIST_DEVICES:\n\t\tl = (struct wsmux_device_list *)data;\n\t\tfor (n = 0, m = LIST_FIRST(&sc->sc_reals);\n\t\t     n < WSMUX_MAXDEV && m != NULL;\n\t\t     m = LIST_NEXT(m, next)) {\n\t\t\tl->devices[n].type = m->type;\n\t\t\tl->devices[n].idx = m->sc->dv_unit;\n\t\t\tn++;\n\t\t}\n\t\tl->ndevices = n;\n\t\treturn (0);\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\tcase WSKBDIO_SETMODE:\n\t\tsc->sc_rawkbd = *(int *)data;\n\t\tDPRINTF((\"wsmuxdoioctl: save rawkbd = %d\\n\", sc->sc_rawkbd));\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (sc->sc_events.io == NULL && sc->sc_displaydv == NULL)\n\t\treturn (EACCES);\n\n\t/* Return 0 if any of the ioctl() succeeds, otherwise the last error */\n\terror = 0;\n\tok = 0;\n\tfor (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {\n\t\tDPRINTF((\"wsmuxdoioctl: m=%p *m->sc_muxp=%p sc=%p\\n\",\n\t\t\t m, *m->sc_muxp, sc));\n\t\tif (*m->sc_muxp == sc) {\n\t\t\tDPRINTF((\"wsmuxdoioctl: %s: m=%p dev=%s\\n\", \n\t\t\t\t sc->sc_dv.dv_xname, m, m->sc->dv_xname));\n\t\t\terror = m->sc_ops->dioctl(m->sc, cmd, data, flag, p);\n\t\t\tif (!error)\n\t\t\t\tok = 1;\n\t\t}\n\t}\n\tif (ok)\n\t\terror = 0;\n\n\treturn (error);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/device.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include \"wskbd.h\"",
            "#include \"wsdisplay.h\"",
            "#include \"wsmux.h\""
          ],
          "macros_used": [
            "#define d ((struct wsmux_device *)data)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n\n#define d ((struct wsmux_device *)data)\n\nint\nwsmuxdoioctl(dv, cmd, data, flag, p)\n\tstruct device *dv;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct wsmux_softc *sc = (struct wsmux_softc *)dv;\n\tstruct wsplink *m;\n\tint error, ok;\n\tint s, put, get, n;\n\tstruct wseventvar *evar;\n\tstruct wscons_event *ev;\n\tstruct timeval xxxtime;\n\tstruct wsmux_device_list *l;\n\n\tDPRINTF((\"wsmuxdoioctl: %s: sc=%p, cmd=%08lx\\n\", \n\t\t sc->sc_dv.dv_xname, sc, cmd));\n\n\tswitch (cmd) {\n\tcase WSMUX_INJECTEVENT:\n\t\t/* Inject an event, e.g., from moused. */\n\t\tif (!sc->sc_events.io)\n\t\t\treturn (EACCES);\n\n\t\tevar = &sc->sc_events;\n\t\ts = spltty();\n\t\tget = evar->get;\n\t\tput = evar->put;\n\t\tif (++put % WSEVENT_QSIZE == get) {\n\t\t\tput--;\n\t\t\tsplx(s);\n\t\t\treturn (ENOSPC);\n\t\t}\n\t\tif (put >= WSEVENT_QSIZE)\n\t\t\tput = 0;\n\t\tev = &evar->q[put];\n\t\t*ev = *(struct wscons_event *)data;\n\t\tmicrotime(&xxxtime);\n\t\tTIMEVAL_TO_TIMESPEC(&xxxtime, &ev->time);\n\t\tevar->put = put;\n\t\tWSEVENT_WAKEUP(evar);\n\t\tsplx(s);\n\t\treturn (0);\n\tcase WSMUX_ADD_DEVICE:\n#define d ((struct wsmux_device *)data)\n\t\tswitch (d->type) {\n#if NWSMOUSE > 0\n\t\tcase WSMUX_MOUSE:\n\t\t\treturn (wsmouse_add_mux(d->idx, sc));\n#endif\n#if NWSKBD > 0\n\t\tcase WSMUX_KBD:\n\t\t\treturn (wskbd_add_mux(d->idx, sc));\n#endif\n#if NWSMUX > 0\n\t\tcase WSMUX_MUX:\n\t\t\treturn (wsmux_add_mux(d->idx, sc));\n#endif\n\t\tdefault:\n\t\t\treturn (EINVAL);\n\t\t}\n\tcase WSMUX_REMOVE_DEVICE:\n\t\tswitch (d->type) {\n#if NWSMOUSE > 0\n\t\tcase WSMUX_MOUSE:\n\t\t\treturn (wsmouse_rem_mux(d->idx, sc));\n#endif\n#if NWSKBD > 0\n\t\tcase WSMUX_KBD:\n\t\t\treturn (wskbd_rem_mux(d->idx, sc));\n#endif\n#if NWSMUX > 0\n\t\tcase WSMUX_MUX:\n\t\t\treturn (wsmux_rem_mux(d->idx, sc));\n#endif\n\t\tdefault:\n\t\t\treturn (EINVAL);\n\t\t}\n#undef d\n\tcase WSMUX_LIST_DEVICES:\n\t\tl = (struct wsmux_device_list *)data;\n\t\tfor (n = 0, m = LIST_FIRST(&sc->sc_reals);\n\t\t     n < WSMUX_MAXDEV && m != NULL;\n\t\t     m = LIST_NEXT(m, next)) {\n\t\t\tl->devices[n].type = m->type;\n\t\t\tl->devices[n].idx = m->sc->dv_unit;\n\t\t\tn++;\n\t\t}\n\t\tl->ndevices = n;\n\t\treturn (0);\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\tcase WSKBDIO_SETMODE:\n\t\tsc->sc_rawkbd = *(int *)data;\n\t\tDPRINTF((\"wsmuxdoioctl: save rawkbd = %d\\n\", sc->sc_rawkbd));\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (sc->sc_events.io == NULL && sc->sc_displaydv == NULL)\n\t\treturn (EACCES);\n\n\t/* Return 0 if any of the ioctl() succeeds, otherwise the last error */\n\terror = 0;\n\tok = 0;\n\tfor (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {\n\t\tDPRINTF((\"wsmuxdoioctl: m=%p *m->sc_muxp=%p sc=%p\\n\",\n\t\t\t m, *m->sc_muxp, sc));\n\t\tif (*m->sc_muxp == sc) {\n\t\t\tDPRINTF((\"wsmuxdoioctl: %s: m=%p dev=%s\\n\", \n\t\t\t\t sc->sc_dv.dv_xname, m, m->sc->dv_xname));\n\t\t\terror = m->sc_ops->dioctl(m->sc, cmd, data, flag, p);\n\t\t\tif (!error)\n\t\t\t\tok = 1;\n\t\t}\n\t}\n\tif (ok)\n\t\terror = 0;\n\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wskbd_pickfree",
          "args": [],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "wskbd_pickfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
          "lines": "1057-1070",
          "snippet": "int\nwskbd_pickfree()\n{\n\tint i;\n\tstruct wskbd_softc *sc;\n\n\tfor (i = 0; i < wskbd_cd.cd_ndevs; i++) {\n\t\tif ((sc = wskbd_cd.cd_devs[i]) == NULL)\n\t\t\tcontinue;\n\t\tif (sc->sc_displaydv == NULL)\n\t\t\treturn (i);\n\t}\n\treturn (-1);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wsdisplay.h\"",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wskbdvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/malloc.h>",
            "#include <sys/timeout.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cfdriver wskbd_cd = {\n\tNULL, \"wskbd\", DV_TTY\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct cfdriver wskbd_cd = {\n\tNULL, \"wskbd\", DV_TTY\n};\n\nint\nwskbd_pickfree()\n{\n\tint i;\n\tstruct wskbd_softc *sc;\n\n\tfor (i = 0; i < wskbd_cd.cd_ndevs; i++) {\n\t\tif ((sc = wskbd_cd.cd_devs[i]) == NULL)\n\t\t\tcontinue;\n\t\tif (sc->sc_displaydv == NULL)\n\t\t\treturn (i);\n\t}\n\treturn (-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc->sc_accesscookie",
            "0",
            "d"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyin",
          "args": [
            "d->data",
            "buf",
            "d->fontheight * d->stride * d->numchars"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "d->fontheight * d->stride * d->numchars",
            "M_DEVBUF",
            "M_WAITOK"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "copyinstr",
          "args": [
            "d->name",
            "typebuf",
            "sizeof(typebuf)",
            "0"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsdisplay_delscreen",
          "args": [
            "sc",
            "d->idx",
            "d->flags"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "wsdisplay_delscreen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "425-479",
          "snippet": "int\nwsdisplay_delscreen(sc, idx, flags)\n\tstruct wsdisplay_softc *sc;\n\tint idx, flags;\n{\n\tstruct wsscreen *scr;\n\tint s;\n\tvoid *cookie;\n\n\tif (idx < 0 || idx >= WSDISPLAY_MAXSCREEN)\n\t\treturn (EINVAL);\n\tscr = sc->sc_scr[idx];\n\tif (!scr)\n\t\treturn (ENXIO);\n\n\tif (scr->scr_dconf == &wsdisplay_console_conf ||\n\t    scr->scr_syncops ||\n\t    ((scr->scr_flags & SCR_OPEN) && !(flags & WSDISPLAY_DELSCR_FORCE)))\n\t\treturn(EBUSY);\n\n\twsdisplay_closescreen(sc, scr);\n\n\t/*\n\t * delete pointers, so neither device entries\n\t * nor keyboard input can reference it anymore\n\t */\n\ts = spltty();\n\tif (sc->sc_focus == scr) {\n\t\tsc->sc_focus = 0;\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t\twsdisplay_update_rawkbd(sc, 0);\n#endif\n\t}\n\tsc->sc_scr[idx] = 0;\n\tsplx(s);\n\n\t/*\n\t * Wake up processes waiting for the screen to\n\t * be activated. Sleepers must check whether\n\t * the screen still exists.\n\t */\n\tif (scr->scr_flags & SCR_WAITACTIVE)\n\t\twakeup(scr);\n\n\t/* save a reference to the graphics screen */\n\tcookie = scr->scr_dconf->emulcookie;\n\n\twsscreen_detach(scr);\n\n\t(*sc->sc_accessops->free_screen)(sc->sc_accesscookie,\n\t\t\t\t\t cookie);\n\n\tprintf(\"%s: screen %d deleted\\n\", sc->sc_dv.dv_xname, idx);\n\treturn (0);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [
            "#define d ((struct wsmux_device *)data)",
            "#define d ((struct wsdisplay_kbddata *)data)",
            "#define d ((struct wsdisplay_font *)data)",
            "#define d ((struct wsdisplay_delscreendata *)data)",
            "#define d ((struct wsdisplay_addscreendata *)data)",
            "#define d ((struct wsdisplay_usefontdata *)data)",
            "#define d (*(int *)data)",
            "#define WSDISPLAY_MAXSCREEN 8",
            "#define SCR_WAITACTIVE 2\t/* someone waiting on activation */",
            "#define SCR_OPEN 1\t\t/* is it open? */"
          ],
          "globals_used": [
            "void wsscreen_detach",
            "static void wsdisplay_closescreen",
            "int wsdisplay_delscreen",
            "static struct wsscreen_internal wsdisplay_console_conf;",
            "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;",
            "void *cookie;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define d ((struct wsmux_device *)data)\n#define d ((struct wsdisplay_kbddata *)data)\n#define d ((struct wsdisplay_font *)data)\n#define d ((struct wsdisplay_delscreendata *)data)\n#define d ((struct wsdisplay_addscreendata *)data)\n#define d ((struct wsdisplay_usefontdata *)data)\n#define d (*(int *)data)\n#define WSDISPLAY_MAXSCREEN 8\n#define SCR_WAITACTIVE 2\t/* someone waiting on activation */\n#define SCR_OPEN 1\t\t/* is it open? */\n\nvoid wsscreen_detach;\nstatic void wsdisplay_closescreen;\nint wsdisplay_delscreen;\nstatic struct wsscreen_internal wsdisplay_console_conf;\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\nvoid *cookie;\n\nint\nwsdisplay_delscreen(sc, idx, flags)\n\tstruct wsdisplay_softc *sc;\n\tint idx, flags;\n{\n\tstruct wsscreen *scr;\n\tint s;\n\tvoid *cookie;\n\n\tif (idx < 0 || idx >= WSDISPLAY_MAXSCREEN)\n\t\treturn (EINVAL);\n\tscr = sc->sc_scr[idx];\n\tif (!scr)\n\t\treturn (ENXIO);\n\n\tif (scr->scr_dconf == &wsdisplay_console_conf ||\n\t    scr->scr_syncops ||\n\t    ((scr->scr_flags & SCR_OPEN) && !(flags & WSDISPLAY_DELSCR_FORCE)))\n\t\treturn(EBUSY);\n\n\twsdisplay_closescreen(sc, scr);\n\n\t/*\n\t * delete pointers, so neither device entries\n\t * nor keyboard input can reference it anymore\n\t */\n\ts = spltty();\n\tif (sc->sc_focus == scr) {\n\t\tsc->sc_focus = 0;\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t\twsdisplay_update_rawkbd(sc, 0);\n#endif\n\t}\n\tsc->sc_scr[idx] = 0;\n\tsplx(s);\n\n\t/*\n\t * Wake up processes waiting for the screen to\n\t * be activated. Sleepers must check whether\n\t * the screen still exists.\n\t */\n\tif (scr->scr_flags & SCR_WAITACTIVE)\n\t\twakeup(scr);\n\n\t/* save a reference to the graphics screen */\n\tcookie = scr->scr_dconf->emulcookie;\n\n\twsscreen_detach(scr);\n\n\t(*sc->sc_accessops->free_screen)(sc->sc_accesscookie,\n\t\t\t\t\t cookie);\n\n\tprintf(\"%s: screen %d deleted\\n\", sc->sc_dv.dv_xname, idx);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wsdisplay_addscreen_print",
          "args": [
            "sc",
            "d->idx",
            "0"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "wsdisplay_addscreen_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "328-342",
          "snippet": "static void\nwsdisplay_addscreen_print(sc, idx, count)\n\tstruct wsdisplay_softc *sc;\n\tint idx, count;\n{\n\tprintf(\"%s: screen %d\", sc->sc_dv.dv_xname, idx);\n\tif (count > 1)\n\t\tprintf(\"-%d\", idx + (count-1));\n\tprintf(\" added (%s\", sc->sc_scr[idx]->scr_dconf->scrdata->name);\n\tif (WSSCREEN_HAS_EMULATOR(sc->sc_scr[idx])) {\n\t\tprintf(\", %s emulation\",\n\t\t\tsc->sc_scr[idx]->scr_dconf->wsemul->name);\n\t}\n\tprintf(\")\\n\");\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [
            "#define d ((struct wsmux_device *)data)",
            "#define d ((struct wsdisplay_kbddata *)data)",
            "#define d ((struct wsdisplay_font *)data)",
            "#define d ((struct wsdisplay_delscreendata *)data)",
            "#define d ((struct wsdisplay_addscreendata *)data)",
            "#define d ((struct wsdisplay_usefontdata *)data)",
            "#define d (*(int *)data)"
          ],
          "globals_used": [
            "static void wsdisplay_addscreen_print",
            "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;",
            "static const struct wsscreen_descr *\nwsdisplay_screentype_pick(scrdata, name)\n\tconst struct wsscreen_list *scrdata;",
            "const char *name;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define d ((struct wsmux_device *)data)\n#define d ((struct wsdisplay_kbddata *)data)\n#define d ((struct wsdisplay_font *)data)\n#define d ((struct wsdisplay_delscreendata *)data)\n#define d ((struct wsdisplay_addscreendata *)data)\n#define d ((struct wsdisplay_usefontdata *)data)\n#define d (*(int *)data)\n\nstatic void wsdisplay_addscreen_print;\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\nstatic const struct wsscreen_descr *\nwsdisplay_screentype_pick(scrdata, name)\n\tconst struct wsscreen_list *scrdata;\nconst char *name;\n\nstatic void\nwsdisplay_addscreen_print(sc, idx, count)\n\tstruct wsdisplay_softc *sc;\n\tint idx, count;\n{\n\tprintf(\"%s: screen %d\", sc->sc_dv.dv_xname, idx);\n\tif (count > 1)\n\t\tprintf(\"-%d\", idx + (count-1));\n\tprintf(\" added (%s\", sc->sc_scr[idx]->scr_dconf->scrdata->name);\n\tif (WSSCREEN_HAS_EMULATOR(sc->sc_scr[idx])) {\n\t\tprintf(\", %s emulation\",\n\t\t\tsc->sc_scr[idx]->scr_dconf->wsemul->name);\n\t}\n\tprintf(\")\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "wsdisplay_addscreen",
          "args": [
            "sc",
            "d->idx",
            "type",
            "emul"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "wsdisplay_addscreen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "344-392",
          "snippet": "int\nwsdisplay_addscreen(sc, idx, screentype, emul)\n\tstruct wsdisplay_softc *sc;\n\tint idx;\n\tconst char *screentype, *emul;\n{\n\tconst struct wsscreen_descr *scrdesc;\n\tint error;\n\tvoid *cookie;\n\tint ccol, crow;\n\tlong defattr;\n\tstruct wsscreen *scr;\n\tint s;\n\n\tif (idx < 0 || idx >= WSDISPLAY_MAXSCREEN)\n\t\treturn (EINVAL);\n\tif (sc->sc_scr[idx] != NULL)\n\t\treturn (EBUSY);\n\n\tscrdesc = wsdisplay_screentype_pick(sc->sc_scrdata, screentype);\n\tif (!scrdesc)\n\t\treturn (ENXIO);\n\terror = (*sc->sc_accessops->alloc_screen)(sc->sc_accesscookie,\n\t\t\tscrdesc, &cookie, &ccol, &crow, &defattr);\n\tif (error)\n\t\treturn (error);\n\n\tscr = wsscreen_attach(sc, 0, emul, scrdesc,\n\t\t\t      cookie, ccol, crow, defattr);\n\tif (scr == NULL) {\n\t\t(*sc->sc_accessops->free_screen)(sc->sc_accesscookie,\n\t\t\t\t\t\t cookie);\n\t\treturn (ENXIO);\n\t}\n\n\tsc->sc_scr[idx] = scr;\n\n\t/* if no screen has focus yet, activate the first we get */\n\ts = spltty();\n\tif (!sc->sc_focus) {\n\t\t(*sc->sc_accessops->show_screen)(sc->sc_accesscookie,\n\t\t\t\t\t\t scr->scr_dconf->emulcookie,\n\t\t\t\t\t\t 0, 0, 0);\n\t\tsc->sc_focusidx = idx;\n\t\tsc->sc_focus = scr;\n\t}\n\tsplx(s);\n\treturn (0);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [
            "#define WSDISPLAY_MAXSCREEN 8"
          ],
          "globals_used": [
            "struct wsscreen *wsscreen_attach",
            "static const struct wsscreen_descr *\nwsdisplay_screentype_pick",
            "int wsdisplay_addscreen",
            "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;",
            "const char *emul;",
            "void *cookie;",
            "int ccol, crow;",
            "long defattr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define WSDISPLAY_MAXSCREEN 8\n\nstruct wsscreen *wsscreen_attach;\nstatic const struct wsscreen_descr *\nwsdisplay_screentype_pick;\nint wsdisplay_addscreen;\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\nconst char *emul;\nvoid *cookie;\nint ccol, crow;\nlong defattr;\n\nint\nwsdisplay_addscreen(sc, idx, screentype, emul)\n\tstruct wsdisplay_softc *sc;\n\tint idx;\n\tconst char *screentype, *emul;\n{\n\tconst struct wsscreen_descr *scrdesc;\n\tint error;\n\tvoid *cookie;\n\tint ccol, crow;\n\tlong defattr;\n\tstruct wsscreen *scr;\n\tint s;\n\n\tif (idx < 0 || idx >= WSDISPLAY_MAXSCREEN)\n\t\treturn (EINVAL);\n\tif (sc->sc_scr[idx] != NULL)\n\t\treturn (EBUSY);\n\n\tscrdesc = wsdisplay_screentype_pick(sc->sc_scrdata, screentype);\n\tif (!scrdesc)\n\t\treturn (ENXIO);\n\terror = (*sc->sc_accessops->alloc_screen)(sc->sc_accesscookie,\n\t\t\tscrdesc, &cookie, &ccol, &crow, &defattr);\n\tif (error)\n\t\treturn (error);\n\n\tscr = wsscreen_attach(sc, 0, emul, scrdesc,\n\t\t\t      cookie, ccol, crow, defattr);\n\tif (scr == NULL) {\n\t\t(*sc->sc_accessops->free_screen)(sc->sc_accesscookie,\n\t\t\t\t\t\t cookie);\n\t\treturn (ENXIO);\n\t}\n\n\tsc->sc_scr[idx] = scr;\n\n\t/* if no screen has focus yet, activate the first we get */\n\ts = spltty();\n\tif (!sc->sc_focus) {\n\t\t(*sc->sc_accessops->show_screen)(sc->sc_accesscookie,\n\t\t\t\t\t\t scr->scr_dconf->emulcookie,\n\t\t\t\t\t\t 0, 0, 0);\n\t\tsc->sc_focusidx = idx;\n\t\tsc->sc_focus = scr;\n\t}\n\tsplx(s);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copyinstr",
          "args": [
            "d->emul",
            "emulbuf",
            "sizeof(emulbuf)",
            "0"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyinstr",
          "args": [
            "d->screentype",
            "typebuf",
            "sizeof(typebuf)",
            "0"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define d ((struct wsmux_device *)data)\n#define d ((struct wsdisplay_kbddata *)data)\n#define d ((struct wsdisplay_font *)data)\n#define d ((struct wsdisplay_delscreendata *)data)\n#define d ((struct wsdisplay_addscreendata *)data)\n#define d ((struct wsdisplay_usefontdata *)data)\n#define d (*(int *)data)\n\nint wsdisplay_addscreen;\nstatic void wsdisplay_addscreen_print;\nint wsdisplay_delscreen;\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\nconst char *emul;\nconst struct wsscreen_descr *type;\nconst char *name;\n\nint\nwsdisplay_cfg_ioctl(sc, cmd, data, flag, p)\n\tstruct wsdisplay_softc *sc;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tint error;\n\tchar *type, typebuf[16], *emul, emulbuf[16];\n\tvoid *buf;\n#if defined(COMPAT_14) && NWSKBD > 0\n\tstruct wsmux_device wsmuxdata;\n#endif\n\n\tswitch (cmd) {\n\tcase WSDISPLAYIO_ADDSCREEN:\n#define d ((struct wsdisplay_addscreendata *)data)\n\t\tif (d->screentype) {\n\t\t\terror = copyinstr(d->screentype, typebuf,\n\t\t\t\t\t  sizeof(typebuf), 0);\n\t\t\tif (error)\n\t\t\t\treturn (error);\n\t\t\ttype = typebuf;\n\t\t} else\n\t\t\ttype = 0;\n\t\tif (d->emul) {\n\t\t\terror = copyinstr(d->emul, emulbuf, sizeof(emulbuf), 0);\n\t\t\tif (error)\n\t\t\t\treturn (error);\n\t\t\temul = emulbuf;\n\t\t} else\n\t\t\temul = 0;\n\n\t\tif ((error = wsdisplay_addscreen(sc, d->idx, type, emul)) == 0)\n\t\t\twsdisplay_addscreen_print(sc, d->idx, 0);\n\t\treturn (error);\n#undef d\n\tcase WSDISPLAYIO_DELSCREEN:\n#define d ((struct wsdisplay_delscreendata *)data)\n\t\treturn (wsdisplay_delscreen(sc, d->idx, d->flags));\n#undef d\n\tcase WSDISPLAYIO_LDFONT:\n#define d ((struct wsdisplay_font *)data)\n\t\tif (!sc->sc_accessops->load_font)\n\t\t\treturn (EINVAL);\n\t\tif (d->name) {\n\t\t\terror = copyinstr(d->name, typebuf, sizeof(typebuf), 0);\n\t\t\tif (error)\n\t\t\t\treturn (error);\n\t\t\td->name = typebuf;\n\t\t} else\n\t\t\td->name = \"loaded\"; /* ??? */\n\t\tbuf = malloc(d->fontheight * d->stride * d->numchars,\n\t\t\t     M_DEVBUF, M_WAITOK);\n\t\terror = copyin(d->data, buf,\n\t\t\t       d->fontheight * d->stride * d->numchars);\n\t\tif (error) {\n\t\t\tfree(buf, M_DEVBUF);\n\t\t\treturn (error);\n\t\t}\n\t\td->data = buf;\n\t\terror =\n\t\t  (*sc->sc_accessops->load_font)(sc->sc_accesscookie, 0, d);\n\t\tfree(buf, M_DEVBUF);\n#undef d\n\t\treturn (error);\n\n#if NWSKBD > 0\n#ifdef COMPAT_14\n\tcase _O_WSDISPLAYIO_SETKEYBOARD:\n#define d ((struct wsdisplay_kbddata *)data)\n\t\tswitch (d->op) {\n\t\tcase _O_WSDISPLAY_KBD_ADD:\n\t\t\tif (d->idx == -1) {\n\t\t\t\td->idx = wskbd_pickfree();\n\t\t\t\tif (d->idx == -1)\n\t\t\t\t\treturn (ENXIO);\n\t\t\t}\n\t\t\twsmuxdata.type = WSMUX_KBD;\n\t\t\twsmuxdata.idx = d->idx;\n\t\t\treturn (wsmuxdoioctl(&sc->sc_muxdv->sc_dv,\n\t\t\t\t\t     WSMUX_ADD_DEVICE,\n\t\t\t\t\t     (caddr_t)&wsmuxdata, flag, p));\n\t\tcase _O_WSDISPLAY_KBD_DEL:\n\t\t\twsmuxdata.type = WSMUX_KBD;\n\t\t\twsmuxdata.idx = d->idx;\n\t\t\treturn (wsmuxdoioctl(&sc->sc_muxdv->sc_dv,\n\t\t\t\t\t     WSMUX_REMOVE_DEVICE,\n\t\t\t\t\t     (caddr_t)&wsmuxdata, flag, p));\n\t\tdefault:\n\t\t\treturn (EINVAL);\n\t\t}\n#undef d\n#endif\n\n\tcase WSMUX_ADD_DEVICE:\n#define d ((struct wsmux_device *)data)\n\t\tif (d->idx == -1 && d->type == WSMUX_KBD)\n\t\t\td->idx = wskbd_pickfree();\n#undef d\n\t\t/* fall into */\n\tcase WSMUX_INJECTEVENT:\n\tcase WSMUX_REMOVE_DEVICE:\n\tcase WSMUX_LIST_DEVICES:\n\t\treturn (wsmuxdoioctl(&sc->sc_muxdv->sc_dv, cmd, data, flag,p));\n#endif /* NWSKBD > 0 */\n\n\t}\n\treturn (EINVAL);\n}"
  },
  {
    "function_name": "wsdisplay_internal_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "936-1012",
    "snippet": "int\nwsdisplay_internal_ioctl(sc, scr, cmd, data, flag, p)\n\tstruct wsdisplay_softc *sc;\n\tstruct wsscreen *scr;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tint error;\n\tchar namebuf[16];\n\tstruct wsdisplay_font fd;\n\n#if NWSKBD > 0\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t\tswitch (cmd) {\n\t\t    case WSKBDIO_SETMODE:\n\t\t\tscr->scr_rawkbd = (*(int *)data == WSKBD_RAW);\n\t\t\treturn (wsdisplay_update_rawkbd(sc, scr));\n\t\t    case WSKBDIO_GETMODE:\n\t\t\t*(int *)data = (scr->scr_rawkbd ?\n\t\t\t\t\tWSKBD_RAW : WSKBD_TRANSLATED);\n\t\t\treturn (0);\n\t\t}\n#endif\n\terror = wsmux_displayioctl(&sc->sc_muxdv->sc_dv, cmd, data, flag, p);\n\t\tif (error >= 0)\n\t\treturn (error);\n#endif /* NWSKBD > 0 */\n\n\tswitch (cmd) {\n\tcase WSDISPLAYIO_GMODE:\n\t\t*(u_int *)data = (scr->scr_flags & SCR_GRAPHICS ?\n\t\t\t\t  WSDISPLAYIO_MODE_MAPPED :\n\t\t\t\t  WSDISPLAYIO_MODE_EMUL);\n\t\treturn (0);\n\n\tcase WSDISPLAYIO_SMODE:\n#define d (*(int *)data)\n\t\tif (d != WSDISPLAYIO_MODE_EMUL &&\n\t\t    d != WSDISPLAYIO_MODE_MAPPED)\n\t\t\treturn (EINVAL);\n\n\t    if (WSSCREEN_HAS_EMULATOR(scr)) {\n\t\t    scr->scr_flags &= ~SCR_GRAPHICS;\n\t\t    if (d == WSDISPLAYIO_MODE_MAPPED)\n\t\t\t    scr->scr_flags |= SCR_GRAPHICS;\n\t    } else if (d == WSDISPLAYIO_MODE_EMUL)\n\t\t    return (EINVAL);\n\t    return (0);\n#undef d\n\n\tcase WSDISPLAYIO_USEFONT:\n#define d ((struct wsdisplay_usefontdata *)data)\n\t\tif (!sc->sc_accessops->load_font)\n\t\t\treturn (EINVAL);\n\t\tif (d->name) {\n\t\t\terror = copyinstr(d->name, namebuf, sizeof(namebuf), 0);\n\t\t\tif (error)\n\t\t\t\treturn (error);\n\t\t\tfd.name = namebuf;\n\t\t} else\n\t\t\tfd.name = 0;\n\t\tfd.data = 0;\n\t\terror = (*sc->sc_accessops->load_font)(sc->sc_accesscookie,\n\t\t\t\t\tscr->scr_dconf->emulcookie, &fd);\n\t\tif (!error && WSSCREEN_HAS_EMULATOR(scr))\n\t\t\t(*scr->scr_dconf->wsemul->reset)\n\t\t\t\t(scr->scr_dconf->wsemulcookie, WSEMUL_SYNCFONT);\n\t\treturn (error);\n#undef d\n\t}\n\n\t/* check ioctls for display */\n\treturn ((*sc->sc_accessops->ioctl)(sc->sc_accesscookie, cmd, data,\n\t    flag, p));\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [
      "#define d ((struct wsmux_device *)data)",
      "#define d ((struct wsdisplay_kbddata *)data)",
      "#define d ((struct wsdisplay_font *)data)",
      "#define d ((struct wsdisplay_delscreendata *)data)",
      "#define d ((struct wsdisplay_addscreendata *)data)",
      "#define d ((struct wsdisplay_usefontdata *)data)",
      "#define d (*(int *)data)",
      "#define SCR_GRAPHICS 4\t\t/* graphics mode, no text (emulation) output */"
    ],
    "globals_used": [
      "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;",
      "const char *name;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc->sc_accesscookie",
            "cmd",
            "data",
            "flag",
            "p"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "scr->scr_dconf->wsemulcookie",
            "WSEMUL_SYNCFONT"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSSCREEN_HAS_EMULATOR",
          "args": [
            "scr"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc->sc_accesscookie",
            "scr->scr_dconf->emulcookie",
            "&fd"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyinstr",
          "args": [
            "d->name",
            "namebuf",
            "sizeof(namebuf)",
            "0"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSSCREEN_HAS_EMULATOR",
          "args": [
            "scr"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsmux_displayioctl",
          "args": [
            "&sc->sc_muxdv->sc_dv",
            "cmd",
            "data",
            "flag",
            "p"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "wsmux_displayioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmux.c",
          "lines": "631-675",
          "snippet": "int\nwsmux_displayioctl(dv, cmd, data, flag, p)\n\tstruct device *dv;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct wsmux_softc *sc = (struct wsmux_softc *)dv;\n\tstruct wsplink *m;\n\tint error, ok;\n\n\tDPRINTF((\"wsmux_displayioctl: %s: sc=%p, cmd=%08lx\\n\", \n\t\t sc->sc_dv.dv_xname, sc, cmd));\n\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\tif (cmd == WSKBDIO_SETMODE) {\n\t\tsc->sc_rawkbd = *(int *)data;\n\t\tDPRINTF((\"wsmux_displayioctl: rawkbd = %d\\n\", sc->sc_rawkbd));\n\t}\t\t\n#endif\n\n\t/* \n\t * Return 0 if any of the ioctl() succeeds, otherwise the last error.\n\t * Return -1 if no mux component accepts the ioctl.\n\t */\n\terror = -1;\n\tok = 0;\n\tfor (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {\n\t\tDPRINTF((\"wsmux_displayioctl: m=%p sc=%p sc_muxp=%p\\n\", \n\t\t\t m, sc, *m->sc_muxp));\n\t\tif (m->sc_ops->ddispioctl && *m->sc_muxp == sc) {\n\t\t\terror = m->sc_ops->ddispioctl(m->sc, cmd, data,\n\t\t\t\t\t\t      flag, p);\n\t\t\tDPRINTF((\"wsmux_displayioctl: m=%p dev=%s ==> %d\\n\", \n\t\t\t\t m, m->sc->dv_xname, error));\n\t\t\tif (!error)\n\t\t\t\tok = 1;\n\t\t}\n\t}\n\tif (ok)\n\t\terror = 0;\n\n\treturn (error);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/device.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include \"wskbd.h\"",
            "#include \"wsdisplay.h\"",
            "#include \"wsmux.h\""
          ],
          "macros_used": [
            "#define d ((struct wsmux_device *)data)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n\n#define d ((struct wsmux_device *)data)\n\nint\nwsmux_displayioctl(dv, cmd, data, flag, p)\n\tstruct device *dv;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct wsmux_softc *sc = (struct wsmux_softc *)dv;\n\tstruct wsplink *m;\n\tint error, ok;\n\n\tDPRINTF((\"wsmux_displayioctl: %s: sc=%p, cmd=%08lx\\n\", \n\t\t sc->sc_dv.dv_xname, sc, cmd));\n\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\tif (cmd == WSKBDIO_SETMODE) {\n\t\tsc->sc_rawkbd = *(int *)data;\n\t\tDPRINTF((\"wsmux_displayioctl: rawkbd = %d\\n\", sc->sc_rawkbd));\n\t}\t\t\n#endif\n\n\t/* \n\t * Return 0 if any of the ioctl() succeeds, otherwise the last error.\n\t * Return -1 if no mux component accepts the ioctl.\n\t */\n\terror = -1;\n\tok = 0;\n\tfor (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {\n\t\tDPRINTF((\"wsmux_displayioctl: m=%p sc=%p sc_muxp=%p\\n\", \n\t\t\t m, sc, *m->sc_muxp));\n\t\tif (m->sc_ops->ddispioctl && *m->sc_muxp == sc) {\n\t\t\terror = m->sc_ops->ddispioctl(m->sc, cmd, data,\n\t\t\t\t\t\t      flag, p);\n\t\t\tDPRINTF((\"wsmux_displayioctl: m=%p dev=%s ==> %d\\n\", \n\t\t\t\t m, m->sc->dv_xname, error));\n\t\t\tif (!error)\n\t\t\t\tok = 1;\n\t\t}\n\t}\n\tif (ok)\n\t\terror = 0;\n\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wsdisplay_update_rawkbd",
          "args": [
            "sc",
            "scr"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "wsdisplay_update_rawkbd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "1321-1344",
          "snippet": "int\nwsdisplay_update_rawkbd(sc, scr)\n\tstruct wsdisplay_softc *sc;\n\tstruct wsscreen *scr;\n{\n\tint s, raw, data, error;\n\ts = spltty();\n\n\traw = (scr ? scr->scr_rawkbd : 0);\n\n\tif (scr != sc->sc_focus ||\n\t    sc->sc_rawkbd == raw) {\n\t\tsplx(s);\n\t\treturn (0);\n\t}\n\n\tdata = raw ? WSKBD_RAW : WSKBD_TRANSLATED;\n\terror = wsmux_displayioctl(&sc->sc_muxdv->sc_dv, WSKBDIO_SETMODE,\n\t\t\t\t   (caddr_t)&data, 0, 0);\n\tif (!error)\n\t\tsc->sc_rawkbd = raw;\n\tsplx(s);\n\treturn (error);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\n\nint\nwsdisplay_update_rawkbd(sc, scr)\n\tstruct wsdisplay_softc *sc;\n\tstruct wsscreen *scr;\n{\n\tint s, raw, data, error;\n\ts = spltty();\n\n\traw = (scr ? scr->scr_rawkbd : 0);\n\n\tif (scr != sc->sc_focus ||\n\t    sc->sc_rawkbd == raw) {\n\t\tsplx(s);\n\t\treturn (0);\n\t}\n\n\tdata = raw ? WSKBD_RAW : WSKBD_TRANSLATED;\n\terror = wsmux_displayioctl(&sc->sc_muxdv->sc_dv, WSKBDIO_SETMODE,\n\t\t\t\t   (caddr_t)&data, 0, 0);\n\tif (!error)\n\t\tsc->sc_rawkbd = raw;\n\tsplx(s);\n\treturn (error);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define d ((struct wsmux_device *)data)\n#define d ((struct wsdisplay_kbddata *)data)\n#define d ((struct wsdisplay_font *)data)\n#define d ((struct wsdisplay_delscreendata *)data)\n#define d ((struct wsdisplay_addscreendata *)data)\n#define d ((struct wsdisplay_usefontdata *)data)\n#define d (*(int *)data)\n#define SCR_GRAPHICS 4\t\t/* graphics mode, no text (emulation) output */\n\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\nconst char *name;\n\nint\nwsdisplay_internal_ioctl(sc, scr, cmd, data, flag, p)\n\tstruct wsdisplay_softc *sc;\n\tstruct wsscreen *scr;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tint error;\n\tchar namebuf[16];\n\tstruct wsdisplay_font fd;\n\n#if NWSKBD > 0\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t\tswitch (cmd) {\n\t\t    case WSKBDIO_SETMODE:\n\t\t\tscr->scr_rawkbd = (*(int *)data == WSKBD_RAW);\n\t\t\treturn (wsdisplay_update_rawkbd(sc, scr));\n\t\t    case WSKBDIO_GETMODE:\n\t\t\t*(int *)data = (scr->scr_rawkbd ?\n\t\t\t\t\tWSKBD_RAW : WSKBD_TRANSLATED);\n\t\t\treturn (0);\n\t\t}\n#endif\n\terror = wsmux_displayioctl(&sc->sc_muxdv->sc_dv, cmd, data, flag, p);\n\t\tif (error >= 0)\n\t\treturn (error);\n#endif /* NWSKBD > 0 */\n\n\tswitch (cmd) {\n\tcase WSDISPLAYIO_GMODE:\n\t\t*(u_int *)data = (scr->scr_flags & SCR_GRAPHICS ?\n\t\t\t\t  WSDISPLAYIO_MODE_MAPPED :\n\t\t\t\t  WSDISPLAYIO_MODE_EMUL);\n\t\treturn (0);\n\n\tcase WSDISPLAYIO_SMODE:\n#define d (*(int *)data)\n\t\tif (d != WSDISPLAYIO_MODE_EMUL &&\n\t\t    d != WSDISPLAYIO_MODE_MAPPED)\n\t\t\treturn (EINVAL);\n\n\t    if (WSSCREEN_HAS_EMULATOR(scr)) {\n\t\t    scr->scr_flags &= ~SCR_GRAPHICS;\n\t\t    if (d == WSDISPLAYIO_MODE_MAPPED)\n\t\t\t    scr->scr_flags |= SCR_GRAPHICS;\n\t    } else if (d == WSDISPLAYIO_MODE_EMUL)\n\t\t    return (EINVAL);\n\t    return (0);\n#undef d\n\n\tcase WSDISPLAYIO_USEFONT:\n#define d ((struct wsdisplay_usefontdata *)data)\n\t\tif (!sc->sc_accessops->load_font)\n\t\t\treturn (EINVAL);\n\t\tif (d->name) {\n\t\t\terror = copyinstr(d->name, namebuf, sizeof(namebuf), 0);\n\t\t\tif (error)\n\t\t\t\treturn (error);\n\t\t\tfd.name = namebuf;\n\t\t} else\n\t\t\tfd.name = 0;\n\t\tfd.data = 0;\n\t\terror = (*sc->sc_accessops->load_font)(sc->sc_accesscookie,\n\t\t\t\t\tscr->scr_dconf->emulcookie, &fd);\n\t\tif (!error && WSSCREEN_HAS_EMULATOR(scr))\n\t\t\t(*scr->scr_dconf->wsemul->reset)\n\t\t\t\t(scr->scr_dconf->wsemulcookie, WSEMUL_SYNCFONT);\n\t\treturn (error);\n#undef d\n\t}\n\n\t/* check ioctls for display */\n\treturn ((*sc->sc_accessops->ioctl)(sc->sc_accesscookie, cmd, data,\n\t    flag, p));\n}"
  },
  {
    "function_name": "wsdisplayioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "883-934",
    "snippet": "int\nwsdisplayioctl(dev, cmd, data, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct wsdisplay_softc *sc;\n\tstruct tty *tp;\n\tint unit, error;\n\tstruct wsscreen *scr;\n\n\tunit = WSDISPLAYUNIT(dev);\n\tsc = wsdisplay_cd.cd_devs[unit];\n\n#ifdef WSDISPLAY_COMPAT_USL\n\terror = wsdisplay_usl_ioctl1(sc, cmd, data, flag, p);\n\tif (error >= 0)\n\t\treturn (error);\n#endif\n\n\tif (ISWSDISPLAYCTL(dev))\n\t\treturn (wsdisplay_cfg_ioctl(sc, cmd, data, flag, p));\n\n\tscr = sc->sc_scr[WSDISPLAYSCREEN(dev)];\n\n\tif (WSSCREEN_HAS_TTY(scr)) {\n\t\ttp = scr->scr_tty;\n\n/* printf(\"disc\\n\"); */\n\t\t/* do the line discipline ioctls first */\n\t\terror = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);\n\t\tif (error >= 0)\n\t\t\treturn (error);\n\n/* printf(\"tty\\n\"); */\n\t\t/* then the tty ioctls */\n\t\terror = ttioctl(tp, cmd, data, flag, p);\n\t\tif (error >= 0)\n\t\t\treturn (error);\n\t}\n\n#ifdef WSDISPLAY_COMPAT_USL\n\terror = wsdisplay_usl_ioctl2(sc, scr, cmd, data, flag, p);\n\tif (error >= 0)\n\t\treturn (error);\n#endif\n\n\terror = wsdisplay_internal_ioctl(sc, scr, cmd, data, flag, p);\n\treturn (error != -1 ? error : ENOTTY);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern struct cfdriver wsdisplay_cd;",
      "struct cfdriver wsdisplay_cd = {\n\tNULL, \"wsdisplay\", DV_TTY\n};",
      "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;",
      "struct tty *\nwsdisplaytty(dev)\n\tdev_t dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wsdisplay_internal_ioctl",
          "args": [
            "sc",
            "scr",
            "cmd",
            "data",
            "flag",
            "p"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "wsdisplay_internal_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "936-1012",
          "snippet": "int\nwsdisplay_internal_ioctl(sc, scr, cmd, data, flag, p)\n\tstruct wsdisplay_softc *sc;\n\tstruct wsscreen *scr;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tint error;\n\tchar namebuf[16];\n\tstruct wsdisplay_font fd;\n\n#if NWSKBD > 0\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t\tswitch (cmd) {\n\t\t    case WSKBDIO_SETMODE:\n\t\t\tscr->scr_rawkbd = (*(int *)data == WSKBD_RAW);\n\t\t\treturn (wsdisplay_update_rawkbd(sc, scr));\n\t\t    case WSKBDIO_GETMODE:\n\t\t\t*(int *)data = (scr->scr_rawkbd ?\n\t\t\t\t\tWSKBD_RAW : WSKBD_TRANSLATED);\n\t\t\treturn (0);\n\t\t}\n#endif\n\terror = wsmux_displayioctl(&sc->sc_muxdv->sc_dv, cmd, data, flag, p);\n\t\tif (error >= 0)\n\t\treturn (error);\n#endif /* NWSKBD > 0 */\n\n\tswitch (cmd) {\n\tcase WSDISPLAYIO_GMODE:\n\t\t*(u_int *)data = (scr->scr_flags & SCR_GRAPHICS ?\n\t\t\t\t  WSDISPLAYIO_MODE_MAPPED :\n\t\t\t\t  WSDISPLAYIO_MODE_EMUL);\n\t\treturn (0);\n\n\tcase WSDISPLAYIO_SMODE:\n#define d (*(int *)data)\n\t\tif (d != WSDISPLAYIO_MODE_EMUL &&\n\t\t    d != WSDISPLAYIO_MODE_MAPPED)\n\t\t\treturn (EINVAL);\n\n\t    if (WSSCREEN_HAS_EMULATOR(scr)) {\n\t\t    scr->scr_flags &= ~SCR_GRAPHICS;\n\t\t    if (d == WSDISPLAYIO_MODE_MAPPED)\n\t\t\t    scr->scr_flags |= SCR_GRAPHICS;\n\t    } else if (d == WSDISPLAYIO_MODE_EMUL)\n\t\t    return (EINVAL);\n\t    return (0);\n#undef d\n\n\tcase WSDISPLAYIO_USEFONT:\n#define d ((struct wsdisplay_usefontdata *)data)\n\t\tif (!sc->sc_accessops->load_font)\n\t\t\treturn (EINVAL);\n\t\tif (d->name) {\n\t\t\terror = copyinstr(d->name, namebuf, sizeof(namebuf), 0);\n\t\t\tif (error)\n\t\t\t\treturn (error);\n\t\t\tfd.name = namebuf;\n\t\t} else\n\t\t\tfd.name = 0;\n\t\tfd.data = 0;\n\t\terror = (*sc->sc_accessops->load_font)(sc->sc_accesscookie,\n\t\t\t\t\tscr->scr_dconf->emulcookie, &fd);\n\t\tif (!error && WSSCREEN_HAS_EMULATOR(scr))\n\t\t\t(*scr->scr_dconf->wsemul->reset)\n\t\t\t\t(scr->scr_dconf->wsemulcookie, WSEMUL_SYNCFONT);\n\t\treturn (error);\n#undef d\n\t}\n\n\t/* check ioctls for display */\n\treturn ((*sc->sc_accessops->ioctl)(sc->sc_accesscookie, cmd, data,\n\t    flag, p));\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [
            "#define d ((struct wsmux_device *)data)",
            "#define d ((struct wsdisplay_kbddata *)data)",
            "#define d ((struct wsdisplay_font *)data)",
            "#define d ((struct wsdisplay_delscreendata *)data)",
            "#define d ((struct wsdisplay_addscreendata *)data)",
            "#define d ((struct wsdisplay_usefontdata *)data)",
            "#define d (*(int *)data)",
            "#define SCR_GRAPHICS 4\t\t/* graphics mode, no text (emulation) output */"
          ],
          "globals_used": [
            "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;",
            "const char *name;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define d ((struct wsmux_device *)data)\n#define d ((struct wsdisplay_kbddata *)data)\n#define d ((struct wsdisplay_font *)data)\n#define d ((struct wsdisplay_delscreendata *)data)\n#define d ((struct wsdisplay_addscreendata *)data)\n#define d ((struct wsdisplay_usefontdata *)data)\n#define d (*(int *)data)\n#define SCR_GRAPHICS 4\t\t/* graphics mode, no text (emulation) output */\n\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\nconst char *name;\n\nint\nwsdisplay_internal_ioctl(sc, scr, cmd, data, flag, p)\n\tstruct wsdisplay_softc *sc;\n\tstruct wsscreen *scr;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tint error;\n\tchar namebuf[16];\n\tstruct wsdisplay_font fd;\n\n#if NWSKBD > 0\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t\tswitch (cmd) {\n\t\t    case WSKBDIO_SETMODE:\n\t\t\tscr->scr_rawkbd = (*(int *)data == WSKBD_RAW);\n\t\t\treturn (wsdisplay_update_rawkbd(sc, scr));\n\t\t    case WSKBDIO_GETMODE:\n\t\t\t*(int *)data = (scr->scr_rawkbd ?\n\t\t\t\t\tWSKBD_RAW : WSKBD_TRANSLATED);\n\t\t\treturn (0);\n\t\t}\n#endif\n\terror = wsmux_displayioctl(&sc->sc_muxdv->sc_dv, cmd, data, flag, p);\n\t\tif (error >= 0)\n\t\treturn (error);\n#endif /* NWSKBD > 0 */\n\n\tswitch (cmd) {\n\tcase WSDISPLAYIO_GMODE:\n\t\t*(u_int *)data = (scr->scr_flags & SCR_GRAPHICS ?\n\t\t\t\t  WSDISPLAYIO_MODE_MAPPED :\n\t\t\t\t  WSDISPLAYIO_MODE_EMUL);\n\t\treturn (0);\n\n\tcase WSDISPLAYIO_SMODE:\n#define d (*(int *)data)\n\t\tif (d != WSDISPLAYIO_MODE_EMUL &&\n\t\t    d != WSDISPLAYIO_MODE_MAPPED)\n\t\t\treturn (EINVAL);\n\n\t    if (WSSCREEN_HAS_EMULATOR(scr)) {\n\t\t    scr->scr_flags &= ~SCR_GRAPHICS;\n\t\t    if (d == WSDISPLAYIO_MODE_MAPPED)\n\t\t\t    scr->scr_flags |= SCR_GRAPHICS;\n\t    } else if (d == WSDISPLAYIO_MODE_EMUL)\n\t\t    return (EINVAL);\n\t    return (0);\n#undef d\n\n\tcase WSDISPLAYIO_USEFONT:\n#define d ((struct wsdisplay_usefontdata *)data)\n\t\tif (!sc->sc_accessops->load_font)\n\t\t\treturn (EINVAL);\n\t\tif (d->name) {\n\t\t\terror = copyinstr(d->name, namebuf, sizeof(namebuf), 0);\n\t\t\tif (error)\n\t\t\t\treturn (error);\n\t\t\tfd.name = namebuf;\n\t\t} else\n\t\t\tfd.name = 0;\n\t\tfd.data = 0;\n\t\terror = (*sc->sc_accessops->load_font)(sc->sc_accesscookie,\n\t\t\t\t\tscr->scr_dconf->emulcookie, &fd);\n\t\tif (!error && WSSCREEN_HAS_EMULATOR(scr))\n\t\t\t(*scr->scr_dconf->wsemul->reset)\n\t\t\t\t(scr->scr_dconf->wsemulcookie, WSEMUL_SYNCFONT);\n\t\treturn (error);\n#undef d\n\t}\n\n\t/* check ioctls for display */\n\treturn ((*sc->sc_accessops->ioctl)(sc->sc_accesscookie, cmd, data,\n\t    flag, p));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wsdisplay_usl_ioctl2",
          "args": [
            "sc",
            "scr",
            "cmd",
            "data",
            "flag",
            "p"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "wsdisplay_usl_ioctl2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay_compat_usl.c",
          "lines": "363-548",
          "snippet": "int\nwsdisplay_usl_ioctl2(sc, scr, cmd, data, flag, p)\n\tstruct wsdisplay_softc *sc;\n\tstruct wsscreen *scr;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tint res;\n\tstruct usl_syncdata *sd;\n\tint req, intarg;\n\tstruct wskbd_bell_data bd;\n\tvoid *arg;\n\n\tswitch (cmd) {\n\t    case VT_SETMODE:\n#define newmode ((struct vt_mode *)data)\n\t\tif (newmode->mode == VT_PROCESS) {\n\t\t\tres = usl_sync_init(scr, &sd, p, newmode->acqsig,\n\t\t\t\t\t    newmode->relsig, newmode->frsig);\n\t\t\tif (res)\n\t\t\t\treturn (res);\n\t\t} else {\n\t\t\tsd = usl_sync_get(scr);\n\t\t\tif (sd)\n\t\t\t\tusl_sync_done(sd);\n\t\t}\n#undef newmode\n\t\treturn (0);\n\t    case VT_GETMODE:\n#define cmode ((struct vt_mode *)data)\n\t\tsd = usl_sync_get(scr);\n\t\tif (sd) {\n\t\t\tcmode->mode = VT_PROCESS;\n\t\t\tcmode->relsig = sd->s_relsig;\n\t\t\tcmode->acqsig = sd->s_acqsig;\n\t\t\tcmode->frsig = sd->s_frsig;\n\t\t} else\n\t\t\tcmode->mode = VT_AUTO;\n#undef cmode\n\t\treturn (0);\n\t    case VT_RELDISP:\n#define d (*(int *)data)\n\t\tsd = usl_sync_get(scr);\n\t\tif (!sd)\n\t\t\treturn (EINVAL);\n\t\tswitch (d) {\n\t\t    case VT_FALSE:\n\t\t    case VT_TRUE:\n\t\t\treturn (usl_detachack(sd, (d == VT_TRUE)));\n\t\t    case VT_ACKACQ:\n\t\t\treturn (usl_attachack(sd, 1));\n\t\t    default:\n\t\t\treturn (EINVAL);\n\t\t}\n#undef d\n\t\treturn (0);\n\n\t    case KDENABIO:\n\t\tif (suser(p->p_ucred, &p->p_acflag) || securelevel > 1)\n\t\t\treturn (EPERM);\n\t\t/* FALLTHRU */\n\t    case KDDISABIO:\n#if defined(__i386__)\n#if defined(COMPAT_10) || defined(COMPAT_11) || defined(COMPAT_FREEBSD)\n\t\t{\n\t\tstruct trapframe *fp = (struct trapframe *)p->p_md.md_regs;\n\t\tif (cmd == KDENABIO)\n\t\t\tfp->tf_eflags |= PSL_IOPL;\n\t\telse\n\t\t\tfp->tf_eflags &= ~PSL_IOPL;\n\t\t}\n#endif\n#endif\n\t\treturn (0);\n\t    case KDSETRAD:\n\t\t/* XXX ignore for now */\n\t\treturn (0);\n\n\t    default:\n\t\treturn (-1);\n\n\t    /*\n\t     * the following are converted to wsdisplay ioctls\n\t     */\n\t    case KDSETMODE:\n\t\treq = WSDISPLAYIO_SMODE;\n#define d (*(int *)data)\n\t\tswitch (d) {\n\t\t    case KD_GRAPHICS:\n\t\t\tintarg = WSDISPLAYIO_MODE_MAPPED;\n\t\t\tbreak;\n\t\t    case KD_TEXT:\n\t\t\tintarg = WSDISPLAYIO_MODE_EMUL;\n\t\t\tbreak;\n\t\t    default:\n\t\t\treturn (EINVAL);\n\t\t}\n#undef d\n\t\targ = &intarg;\n\t\tbreak;\n\t    case KDMKTONE:\n\t\treq = WSKBDIO_COMPLEXBELL;\n#define d (*(int *)data)\n\t\tif (d) {\n#define PCVT_SYSBEEPF\t1193182\n\t\t\tif (d >> 16) {\n\t\t\t\tbd.which = WSKBD_BELL_DOPERIOD;\n\t\t\tbd.period = d >> 16; /* ms */\n\t\t\t}\n\t\t\telse\n\t\t\t\tbd.which = 0;\n\t\t\tif (d & 0xffff) {\n\t\t\t\tbd.which |= WSKBD_BELL_DOPITCH;\n\t\t\t\tbd.pitch = PCVT_SYSBEEPF/(d & 0xffff); /* Hz */\n\t\t\t}\n\t\t} else\n\t\t\tbd.which = 0; /* default */\n#undef d\n\t\targ = &bd;\n\t\tbreak;\n\t    case KDSETLED:\n\t\treq = WSKBDIO_SETLEDS;\n\t\tintarg = 0;\n#define d (*(int *)data)\n\t\tif (d & LED_CAP)\n\t\t\tintarg |= WSKBD_LED_CAPS;\n\t\tif (d & LED_NUM)\n\t\t\tintarg |= WSKBD_LED_NUM;\n\t\tif (d & LED_SCR)\n\t\t\tintarg |= WSKBD_LED_SCROLL;\n#undef d\n\t\targ = &intarg;\n\t\tbreak;\n\t    case KDGETLED:\n\t\treq = WSKBDIO_GETLEDS;\n\t\targ = &intarg;\n\t\tbreak;\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t    case KDSKBMODE:\n\t\treq = WSKBDIO_SETMODE;\n\t\tswitch (*(int *)data) {\n\t\t    case K_RAW:\n\t\t\tintarg = WSKBD_RAW;\n\t\t\tbreak;\n\t\t    case K_XLATE:\n\t\t\tintarg = WSKBD_TRANSLATED;\n\t\t\tbreak;\n\t\t    default:\n\t\t\treturn (EINVAL);\n\t\t}\n\t\targ = &intarg;\n\t\tbreak;\n\t    case KDGKBMODE:\n\t\treq = WSKBDIO_GETMODE;\n\t\targ = &intarg;\n\t\tbreak;\n#endif\n\t}\n\n\tres = wsdisplay_internal_ioctl(sc, scr, req, arg, flag, p);\n\tif (res)\n\t\treturn (res);\n\n\tswitch (cmd) {\n\t    case KDGETLED:\n#define d (*(int *)data)\n\t\td = 0;\n\t\tif (intarg & WSKBD_LED_CAPS)\n\t\t\td |= LED_CAP;\n\t\tif (intarg & WSKBD_LED_NUM)\n\t\t\td |= LED_NUM;\n\t\tif (intarg & WSKBD_LED_SCROLL)\n\t\t\td |= LED_SCR;\n#undef d\n\t\tbreak;\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t    case KDGKBMODE:\n\t\t*(int *)data = (intarg == WSKBD_RAW ? K_RAW : K_XLATE);\n\t\tbreak;\n#endif\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/wscons/wsdisplay_usl_io.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/errno.h>",
            "#include <sys/malloc.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/timeout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define d (*(int *)data)",
            "#define d (*(int *)data)",
            "#define PCVT_SYSBEEPF\t1193182",
            "#define d (*(int *)data)",
            "#define d (*(int *)data)",
            "#define d (*(int *)data)",
            "#define cmode ((struct vt_mode *)data)",
            "#define newmode ((struct vt_mode *)data)"
          ],
          "globals_used": [
            "static int usl_sync_init",
            "static void usl_sync_done",
            "static struct usl_syncdata *usl_sync_get",
            "static int usl_detachack",
            "static int usl_attachack",
            "static struct usl_syncdata *\nusl_sync_get(scr)\n\tstruct wsscreen *scr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsdisplay_usl_io.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/errno.h>\n#include <sys/malloc.h>\n#include <sys/signalvar.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define d (*(int *)data)\n#define d (*(int *)data)\n#define PCVT_SYSBEEPF\t1193182\n#define d (*(int *)data)\n#define d (*(int *)data)\n#define d (*(int *)data)\n#define cmode ((struct vt_mode *)data)\n#define newmode ((struct vt_mode *)data)\n\nstatic int usl_sync_init;\nstatic void usl_sync_done;\nstatic struct usl_syncdata *usl_sync_get;\nstatic int usl_detachack;\nstatic int usl_attachack;\nstatic struct usl_syncdata *\nusl_sync_get(scr)\n\tstruct wsscreen *scr;\n\nint\nwsdisplay_usl_ioctl2(sc, scr, cmd, data, flag, p)\n\tstruct wsdisplay_softc *sc;\n\tstruct wsscreen *scr;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tint res;\n\tstruct usl_syncdata *sd;\n\tint req, intarg;\n\tstruct wskbd_bell_data bd;\n\tvoid *arg;\n\n\tswitch (cmd) {\n\t    case VT_SETMODE:\n#define newmode ((struct vt_mode *)data)\n\t\tif (newmode->mode == VT_PROCESS) {\n\t\t\tres = usl_sync_init(scr, &sd, p, newmode->acqsig,\n\t\t\t\t\t    newmode->relsig, newmode->frsig);\n\t\t\tif (res)\n\t\t\t\treturn (res);\n\t\t} else {\n\t\t\tsd = usl_sync_get(scr);\n\t\t\tif (sd)\n\t\t\t\tusl_sync_done(sd);\n\t\t}\n#undef newmode\n\t\treturn (0);\n\t    case VT_GETMODE:\n#define cmode ((struct vt_mode *)data)\n\t\tsd = usl_sync_get(scr);\n\t\tif (sd) {\n\t\t\tcmode->mode = VT_PROCESS;\n\t\t\tcmode->relsig = sd->s_relsig;\n\t\t\tcmode->acqsig = sd->s_acqsig;\n\t\t\tcmode->frsig = sd->s_frsig;\n\t\t} else\n\t\t\tcmode->mode = VT_AUTO;\n#undef cmode\n\t\treturn (0);\n\t    case VT_RELDISP:\n#define d (*(int *)data)\n\t\tsd = usl_sync_get(scr);\n\t\tif (!sd)\n\t\t\treturn (EINVAL);\n\t\tswitch (d) {\n\t\t    case VT_FALSE:\n\t\t    case VT_TRUE:\n\t\t\treturn (usl_detachack(sd, (d == VT_TRUE)));\n\t\t    case VT_ACKACQ:\n\t\t\treturn (usl_attachack(sd, 1));\n\t\t    default:\n\t\t\treturn (EINVAL);\n\t\t}\n#undef d\n\t\treturn (0);\n\n\t    case KDENABIO:\n\t\tif (suser(p->p_ucred, &p->p_acflag) || securelevel > 1)\n\t\t\treturn (EPERM);\n\t\t/* FALLTHRU */\n\t    case KDDISABIO:\n#if defined(__i386__)\n#if defined(COMPAT_10) || defined(COMPAT_11) || defined(COMPAT_FREEBSD)\n\t\t{\n\t\tstruct trapframe *fp = (struct trapframe *)p->p_md.md_regs;\n\t\tif (cmd == KDENABIO)\n\t\t\tfp->tf_eflags |= PSL_IOPL;\n\t\telse\n\t\t\tfp->tf_eflags &= ~PSL_IOPL;\n\t\t}\n#endif\n#endif\n\t\treturn (0);\n\t    case KDSETRAD:\n\t\t/* XXX ignore for now */\n\t\treturn (0);\n\n\t    default:\n\t\treturn (-1);\n\n\t    /*\n\t     * the following are converted to wsdisplay ioctls\n\t     */\n\t    case KDSETMODE:\n\t\treq = WSDISPLAYIO_SMODE;\n#define d (*(int *)data)\n\t\tswitch (d) {\n\t\t    case KD_GRAPHICS:\n\t\t\tintarg = WSDISPLAYIO_MODE_MAPPED;\n\t\t\tbreak;\n\t\t    case KD_TEXT:\n\t\t\tintarg = WSDISPLAYIO_MODE_EMUL;\n\t\t\tbreak;\n\t\t    default:\n\t\t\treturn (EINVAL);\n\t\t}\n#undef d\n\t\targ = &intarg;\n\t\tbreak;\n\t    case KDMKTONE:\n\t\treq = WSKBDIO_COMPLEXBELL;\n#define d (*(int *)data)\n\t\tif (d) {\n#define PCVT_SYSBEEPF\t1193182\n\t\t\tif (d >> 16) {\n\t\t\t\tbd.which = WSKBD_BELL_DOPERIOD;\n\t\t\tbd.period = d >> 16; /* ms */\n\t\t\t}\n\t\t\telse\n\t\t\t\tbd.which = 0;\n\t\t\tif (d & 0xffff) {\n\t\t\t\tbd.which |= WSKBD_BELL_DOPITCH;\n\t\t\t\tbd.pitch = PCVT_SYSBEEPF/(d & 0xffff); /* Hz */\n\t\t\t}\n\t\t} else\n\t\t\tbd.which = 0; /* default */\n#undef d\n\t\targ = &bd;\n\t\tbreak;\n\t    case KDSETLED:\n\t\treq = WSKBDIO_SETLEDS;\n\t\tintarg = 0;\n#define d (*(int *)data)\n\t\tif (d & LED_CAP)\n\t\t\tintarg |= WSKBD_LED_CAPS;\n\t\tif (d & LED_NUM)\n\t\t\tintarg |= WSKBD_LED_NUM;\n\t\tif (d & LED_SCR)\n\t\t\tintarg |= WSKBD_LED_SCROLL;\n#undef d\n\t\targ = &intarg;\n\t\tbreak;\n\t    case KDGETLED:\n\t\treq = WSKBDIO_GETLEDS;\n\t\targ = &intarg;\n\t\tbreak;\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t    case KDSKBMODE:\n\t\treq = WSKBDIO_SETMODE;\n\t\tswitch (*(int *)data) {\n\t\t    case K_RAW:\n\t\t\tintarg = WSKBD_RAW;\n\t\t\tbreak;\n\t\t    case K_XLATE:\n\t\t\tintarg = WSKBD_TRANSLATED;\n\t\t\tbreak;\n\t\t    default:\n\t\t\treturn (EINVAL);\n\t\t}\n\t\targ = &intarg;\n\t\tbreak;\n\t    case KDGKBMODE:\n\t\treq = WSKBDIO_GETMODE;\n\t\targ = &intarg;\n\t\tbreak;\n#endif\n\t}\n\n\tres = wsdisplay_internal_ioctl(sc, scr, req, arg, flag, p);\n\tif (res)\n\t\treturn (res);\n\n\tswitch (cmd) {\n\t    case KDGETLED:\n#define d (*(int *)data)\n\t\td = 0;\n\t\tif (intarg & WSKBD_LED_CAPS)\n\t\t\td |= LED_CAP;\n\t\tif (intarg & WSKBD_LED_NUM)\n\t\t\td |= LED_NUM;\n\t\tif (intarg & WSKBD_LED_SCROLL)\n\t\t\td |= LED_SCR;\n#undef d\n\t\tbreak;\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t    case KDGKBMODE:\n\t\t*(int *)data = (intarg == WSKBD_RAW ? K_RAW : K_XLATE);\n\t\tbreak;\n#endif\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ttioctl",
          "args": [
            "tp",
            "cmd",
            "data",
            "flag",
            "p"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "tp",
            "cmd",
            "data",
            "flag",
            "p"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSSCREEN_HAS_TTY",
          "args": [
            "scr"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSDISPLAYSCREEN",
          "args": [
            "dev"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsdisplay_cfg_ioctl",
          "args": [
            "sc",
            "cmd",
            "data",
            "flag",
            "p"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "wsdisplay_cfg_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "1014-1124",
          "snippet": "int\nwsdisplay_cfg_ioctl(sc, cmd, data, flag, p)\n\tstruct wsdisplay_softc *sc;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tint error;\n\tchar *type, typebuf[16], *emul, emulbuf[16];\n\tvoid *buf;\n#if defined(COMPAT_14) && NWSKBD > 0\n\tstruct wsmux_device wsmuxdata;\n#endif\n\n\tswitch (cmd) {\n\tcase WSDISPLAYIO_ADDSCREEN:\n#define d ((struct wsdisplay_addscreendata *)data)\n\t\tif (d->screentype) {\n\t\t\terror = copyinstr(d->screentype, typebuf,\n\t\t\t\t\t  sizeof(typebuf), 0);\n\t\t\tif (error)\n\t\t\t\treturn (error);\n\t\t\ttype = typebuf;\n\t\t} else\n\t\t\ttype = 0;\n\t\tif (d->emul) {\n\t\t\terror = copyinstr(d->emul, emulbuf, sizeof(emulbuf), 0);\n\t\t\tif (error)\n\t\t\t\treturn (error);\n\t\t\temul = emulbuf;\n\t\t} else\n\t\t\temul = 0;\n\n\t\tif ((error = wsdisplay_addscreen(sc, d->idx, type, emul)) == 0)\n\t\t\twsdisplay_addscreen_print(sc, d->idx, 0);\n\t\treturn (error);\n#undef d\n\tcase WSDISPLAYIO_DELSCREEN:\n#define d ((struct wsdisplay_delscreendata *)data)\n\t\treturn (wsdisplay_delscreen(sc, d->idx, d->flags));\n#undef d\n\tcase WSDISPLAYIO_LDFONT:\n#define d ((struct wsdisplay_font *)data)\n\t\tif (!sc->sc_accessops->load_font)\n\t\t\treturn (EINVAL);\n\t\tif (d->name) {\n\t\t\terror = copyinstr(d->name, typebuf, sizeof(typebuf), 0);\n\t\t\tif (error)\n\t\t\t\treturn (error);\n\t\t\td->name = typebuf;\n\t\t} else\n\t\t\td->name = \"loaded\"; /* ??? */\n\t\tbuf = malloc(d->fontheight * d->stride * d->numchars,\n\t\t\t     M_DEVBUF, M_WAITOK);\n\t\terror = copyin(d->data, buf,\n\t\t\t       d->fontheight * d->stride * d->numchars);\n\t\tif (error) {\n\t\t\tfree(buf, M_DEVBUF);\n\t\t\treturn (error);\n\t\t}\n\t\td->data = buf;\n\t\terror =\n\t\t  (*sc->sc_accessops->load_font)(sc->sc_accesscookie, 0, d);\n\t\tfree(buf, M_DEVBUF);\n#undef d\n\t\treturn (error);\n\n#if NWSKBD > 0\n#ifdef COMPAT_14\n\tcase _O_WSDISPLAYIO_SETKEYBOARD:\n#define d ((struct wsdisplay_kbddata *)data)\n\t\tswitch (d->op) {\n\t\tcase _O_WSDISPLAY_KBD_ADD:\n\t\t\tif (d->idx == -1) {\n\t\t\t\td->idx = wskbd_pickfree();\n\t\t\t\tif (d->idx == -1)\n\t\t\t\t\treturn (ENXIO);\n\t\t\t}\n\t\t\twsmuxdata.type = WSMUX_KBD;\n\t\t\twsmuxdata.idx = d->idx;\n\t\t\treturn (wsmuxdoioctl(&sc->sc_muxdv->sc_dv,\n\t\t\t\t\t     WSMUX_ADD_DEVICE,\n\t\t\t\t\t     (caddr_t)&wsmuxdata, flag, p));\n\t\tcase _O_WSDISPLAY_KBD_DEL:\n\t\t\twsmuxdata.type = WSMUX_KBD;\n\t\t\twsmuxdata.idx = d->idx;\n\t\t\treturn (wsmuxdoioctl(&sc->sc_muxdv->sc_dv,\n\t\t\t\t\t     WSMUX_REMOVE_DEVICE,\n\t\t\t\t\t     (caddr_t)&wsmuxdata, flag, p));\n\t\tdefault:\n\t\t\treturn (EINVAL);\n\t\t}\n#undef d\n#endif\n\n\tcase WSMUX_ADD_DEVICE:\n#define d ((struct wsmux_device *)data)\n\t\tif (d->idx == -1 && d->type == WSMUX_KBD)\n\t\t\td->idx = wskbd_pickfree();\n#undef d\n\t\t/* fall into */\n\tcase WSMUX_INJECTEVENT:\n\tcase WSMUX_REMOVE_DEVICE:\n\tcase WSMUX_LIST_DEVICES:\n\t\treturn (wsmuxdoioctl(&sc->sc_muxdv->sc_dv, cmd, data, flag,p));\n#endif /* NWSKBD > 0 */\n\n\t}\n\treturn (EINVAL);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [
            "#define d ((struct wsmux_device *)data)",
            "#define d ((struct wsdisplay_kbddata *)data)",
            "#define d ((struct wsdisplay_font *)data)",
            "#define d ((struct wsdisplay_delscreendata *)data)",
            "#define d ((struct wsdisplay_addscreendata *)data)",
            "#define d ((struct wsdisplay_usefontdata *)data)",
            "#define d (*(int *)data)"
          ],
          "globals_used": [
            "int wsdisplay_addscreen",
            "static void wsdisplay_addscreen_print",
            "int wsdisplay_delscreen",
            "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;",
            "const char *emul;",
            "const struct wsscreen_descr *type;",
            "const char *name;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define d ((struct wsmux_device *)data)\n#define d ((struct wsdisplay_kbddata *)data)\n#define d ((struct wsdisplay_font *)data)\n#define d ((struct wsdisplay_delscreendata *)data)\n#define d ((struct wsdisplay_addscreendata *)data)\n#define d ((struct wsdisplay_usefontdata *)data)\n#define d (*(int *)data)\n\nint wsdisplay_addscreen;\nstatic void wsdisplay_addscreen_print;\nint wsdisplay_delscreen;\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\nconst char *emul;\nconst struct wsscreen_descr *type;\nconst char *name;\n\nint\nwsdisplay_cfg_ioctl(sc, cmd, data, flag, p)\n\tstruct wsdisplay_softc *sc;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tint error;\n\tchar *type, typebuf[16], *emul, emulbuf[16];\n\tvoid *buf;\n#if defined(COMPAT_14) && NWSKBD > 0\n\tstruct wsmux_device wsmuxdata;\n#endif\n\n\tswitch (cmd) {\n\tcase WSDISPLAYIO_ADDSCREEN:\n#define d ((struct wsdisplay_addscreendata *)data)\n\t\tif (d->screentype) {\n\t\t\terror = copyinstr(d->screentype, typebuf,\n\t\t\t\t\t  sizeof(typebuf), 0);\n\t\t\tif (error)\n\t\t\t\treturn (error);\n\t\t\ttype = typebuf;\n\t\t} else\n\t\t\ttype = 0;\n\t\tif (d->emul) {\n\t\t\terror = copyinstr(d->emul, emulbuf, sizeof(emulbuf), 0);\n\t\t\tif (error)\n\t\t\t\treturn (error);\n\t\t\temul = emulbuf;\n\t\t} else\n\t\t\temul = 0;\n\n\t\tif ((error = wsdisplay_addscreen(sc, d->idx, type, emul)) == 0)\n\t\t\twsdisplay_addscreen_print(sc, d->idx, 0);\n\t\treturn (error);\n#undef d\n\tcase WSDISPLAYIO_DELSCREEN:\n#define d ((struct wsdisplay_delscreendata *)data)\n\t\treturn (wsdisplay_delscreen(sc, d->idx, d->flags));\n#undef d\n\tcase WSDISPLAYIO_LDFONT:\n#define d ((struct wsdisplay_font *)data)\n\t\tif (!sc->sc_accessops->load_font)\n\t\t\treturn (EINVAL);\n\t\tif (d->name) {\n\t\t\terror = copyinstr(d->name, typebuf, sizeof(typebuf), 0);\n\t\t\tif (error)\n\t\t\t\treturn (error);\n\t\t\td->name = typebuf;\n\t\t} else\n\t\t\td->name = \"loaded\"; /* ??? */\n\t\tbuf = malloc(d->fontheight * d->stride * d->numchars,\n\t\t\t     M_DEVBUF, M_WAITOK);\n\t\terror = copyin(d->data, buf,\n\t\t\t       d->fontheight * d->stride * d->numchars);\n\t\tif (error) {\n\t\t\tfree(buf, M_DEVBUF);\n\t\t\treturn (error);\n\t\t}\n\t\td->data = buf;\n\t\terror =\n\t\t  (*sc->sc_accessops->load_font)(sc->sc_accesscookie, 0, d);\n\t\tfree(buf, M_DEVBUF);\n#undef d\n\t\treturn (error);\n\n#if NWSKBD > 0\n#ifdef COMPAT_14\n\tcase _O_WSDISPLAYIO_SETKEYBOARD:\n#define d ((struct wsdisplay_kbddata *)data)\n\t\tswitch (d->op) {\n\t\tcase _O_WSDISPLAY_KBD_ADD:\n\t\t\tif (d->idx == -1) {\n\t\t\t\td->idx = wskbd_pickfree();\n\t\t\t\tif (d->idx == -1)\n\t\t\t\t\treturn (ENXIO);\n\t\t\t}\n\t\t\twsmuxdata.type = WSMUX_KBD;\n\t\t\twsmuxdata.idx = d->idx;\n\t\t\treturn (wsmuxdoioctl(&sc->sc_muxdv->sc_dv,\n\t\t\t\t\t     WSMUX_ADD_DEVICE,\n\t\t\t\t\t     (caddr_t)&wsmuxdata, flag, p));\n\t\tcase _O_WSDISPLAY_KBD_DEL:\n\t\t\twsmuxdata.type = WSMUX_KBD;\n\t\t\twsmuxdata.idx = d->idx;\n\t\t\treturn (wsmuxdoioctl(&sc->sc_muxdv->sc_dv,\n\t\t\t\t\t     WSMUX_REMOVE_DEVICE,\n\t\t\t\t\t     (caddr_t)&wsmuxdata, flag, p));\n\t\tdefault:\n\t\t\treturn (EINVAL);\n\t\t}\n#undef d\n#endif\n\n\tcase WSMUX_ADD_DEVICE:\n#define d ((struct wsmux_device *)data)\n\t\tif (d->idx == -1 && d->type == WSMUX_KBD)\n\t\t\td->idx = wskbd_pickfree();\n#undef d\n\t\t/* fall into */\n\tcase WSMUX_INJECTEVENT:\n\tcase WSMUX_REMOVE_DEVICE:\n\tcase WSMUX_LIST_DEVICES:\n\t\treturn (wsmuxdoioctl(&sc->sc_muxdv->sc_dv, cmd, data, flag,p));\n#endif /* NWSKBD > 0 */\n\n\t}\n\treturn (EINVAL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ISWSDISPLAYCTL",
          "args": [
            "dev"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsdisplay_usl_ioctl1",
          "args": [
            "sc",
            "cmd",
            "data",
            "flag",
            "p"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "wsdisplay_usl_ioctl1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay_compat_usl.c",
          "lines": "299-361",
          "snippet": "int\nwsdisplay_usl_ioctl1(sc, cmd, data, flag, p)\n\tstruct wsdisplay_softc *sc;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tint idx, maxidx;\n\n\tswitch (cmd) {\n\t    case VT_OPENQRY:\n\t\tmaxidx = wsdisplay_maxscreenidx(sc);\n\t\tfor (idx = 0; idx <= maxidx; idx++) {\n\t\t\tif (wsdisplay_screenstate(sc, idx) == 0) {\n\t\t\t\t*(int *)data = idx + 1;\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t}\n\t\treturn (ENXIO);\n\t    case VT_GETACTIVE:\n\t\tidx = wsdisplay_getactivescreen(sc);\n\t\t*(int *)data = idx + 1;\n\t\treturn (0);\n\t    case VT_ACTIVATE:\n\t\tidx = *(int *)data - 1;\n\t\treturn (wsdisplay_switch((struct device *)sc, idx, 1));\n\t    case VT_WAITACTIVE:\n\t\tidx = *(int *)data - 1;\n\t\treturn (wsscreen_switchwait(sc, idx));\n\t    case VT_GETSTATE:\n#define ss ((struct vt_stat *)data)\n\t\tidx = wsdisplay_getactivescreen(sc);\n\t\tss->v_active = idx + 1;\n\t\tss->v_state = 0;\n\t\tmaxidx = wsdisplay_maxscreenidx(sc);\n\t\tfor (idx = 0; idx <= maxidx; idx++)\n\t\t\tif (wsdisplay_screenstate(sc, idx) == EBUSY)\n\t\t\t\tss->v_state |= (1 << (idx + 1));\n#undef s\n\t\treturn (0);\n\n#ifdef WSDISPLAY_COMPAT_PCVT\n\t    case VGAPCVTID:\n#define id ((struct pcvtid *)data)\n\t\tstrcpy(id->name, \"pcvt\");\n\t\tid->rmajor = 3;\n\t\tid->rminor = 32;\n#undef id\n\t\treturn (0);\n#endif\n#ifdef WSDISPLAY_COMPAT_SYSCONS\n\t    case CONS_GETVERS:\n\t\t*(int *)data = 0x200;    /* version 2.0 */\n\t\treturn (0);\n#endif\n\n\t    default:\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/wscons/wsdisplay_usl_io.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/errno.h>",
            "#include <sys/malloc.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/timeout.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define id ((struct pcvtid *)data)",
            "#define ss ((struct vt_stat *)data)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsdisplay_usl_io.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/errno.h>\n#include <sys/malloc.h>\n#include <sys/signalvar.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define id ((struct pcvtid *)data)\n#define ss ((struct vt_stat *)data)\n\nint\nwsdisplay_usl_ioctl1(sc, cmd, data, flag, p)\n\tstruct wsdisplay_softc *sc;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tint idx, maxidx;\n\n\tswitch (cmd) {\n\t    case VT_OPENQRY:\n\t\tmaxidx = wsdisplay_maxscreenidx(sc);\n\t\tfor (idx = 0; idx <= maxidx; idx++) {\n\t\t\tif (wsdisplay_screenstate(sc, idx) == 0) {\n\t\t\t\t*(int *)data = idx + 1;\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t}\n\t\treturn (ENXIO);\n\t    case VT_GETACTIVE:\n\t\tidx = wsdisplay_getactivescreen(sc);\n\t\t*(int *)data = idx + 1;\n\t\treturn (0);\n\t    case VT_ACTIVATE:\n\t\tidx = *(int *)data - 1;\n\t\treturn (wsdisplay_switch((struct device *)sc, idx, 1));\n\t    case VT_WAITACTIVE:\n\t\tidx = *(int *)data - 1;\n\t\treturn (wsscreen_switchwait(sc, idx));\n\t    case VT_GETSTATE:\n#define ss ((struct vt_stat *)data)\n\t\tidx = wsdisplay_getactivescreen(sc);\n\t\tss->v_active = idx + 1;\n\t\tss->v_state = 0;\n\t\tmaxidx = wsdisplay_maxscreenidx(sc);\n\t\tfor (idx = 0; idx <= maxidx; idx++)\n\t\t\tif (wsdisplay_screenstate(sc, idx) == EBUSY)\n\t\t\t\tss->v_state |= (1 << (idx + 1));\n#undef s\n\t\treturn (0);\n\n#ifdef WSDISPLAY_COMPAT_PCVT\n\t    case VGAPCVTID:\n#define id ((struct pcvtid *)data)\n\t\tstrcpy(id->name, \"pcvt\");\n\t\tid->rmajor = 3;\n\t\tid->rminor = 32;\n#undef id\n\t\treturn (0);\n#endif\n#ifdef WSDISPLAY_COMPAT_SYSCONS\n\t    case CONS_GETVERS:\n\t\t*(int *)data = 0x200;    /* version 2.0 */\n\t\treturn (0);\n#endif\n\n\t    default:\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WSDISPLAYUNIT",
          "args": [
            "dev"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nextern struct cfdriver wsdisplay_cd;\nstruct cfdriver wsdisplay_cd = {\n\tNULL, \"wsdisplay\", DV_TTY\n};\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\nstruct tty *\nwsdisplaytty(dev)\n\tdev_t dev;\n\nint\nwsdisplayioctl(dev, cmd, data, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct wsdisplay_softc *sc;\n\tstruct tty *tp;\n\tint unit, error;\n\tstruct wsscreen *scr;\n\n\tunit = WSDISPLAYUNIT(dev);\n\tsc = wsdisplay_cd.cd_devs[unit];\n\n#ifdef WSDISPLAY_COMPAT_USL\n\terror = wsdisplay_usl_ioctl1(sc, cmd, data, flag, p);\n\tif (error >= 0)\n\t\treturn (error);\n#endif\n\n\tif (ISWSDISPLAYCTL(dev))\n\t\treturn (wsdisplay_cfg_ioctl(sc, cmd, data, flag, p));\n\n\tscr = sc->sc_scr[WSDISPLAYSCREEN(dev)];\n\n\tif (WSSCREEN_HAS_TTY(scr)) {\n\t\ttp = scr->scr_tty;\n\n/* printf(\"disc\\n\"); */\n\t\t/* do the line discipline ioctls first */\n\t\terror = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);\n\t\tif (error >= 0)\n\t\t\treturn (error);\n\n/* printf(\"tty\\n\"); */\n\t\t/* then the tty ioctls */\n\t\terror = ttioctl(tp, cmd, data, flag, p);\n\t\tif (error >= 0)\n\t\t\treturn (error);\n\t}\n\n#ifdef WSDISPLAY_COMPAT_USL\n\terror = wsdisplay_usl_ioctl2(sc, scr, cmd, data, flag, p);\n\tif (error >= 0)\n\t\treturn (error);\n#endif\n\n\terror = wsdisplay_internal_ioctl(sc, scr, cmd, data, flag, p);\n\treturn (error != -1 ? error : ENOTTY);\n}"
  },
  {
    "function_name": "wsdisplaywrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "838-862",
    "snippet": "int\nwsdisplaywrite(dev, uio, flag)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flag;\n{\n\tstruct wsdisplay_softc *sc;\n\tstruct tty *tp;\n\tint unit;\n\tstruct wsscreen *scr;\n\n\tunit = WSDISPLAYUNIT(dev);\n\tsc = wsdisplay_cd.cd_devs[unit];\n\n\tif (ISWSDISPLAYCTL(dev))\n\t\treturn (0);\n\n\tscr = sc->sc_scr[WSDISPLAYSCREEN(dev)];\n\n\tif (!WSSCREEN_HAS_TTY(scr))\n\t\treturn (ENODEV);\n\n\ttp = scr->scr_tty;\n\treturn ((*linesw[tp->t_line].l_write)(tp, uio, flag));\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern struct cfdriver wsdisplay_cd;",
      "struct cfdriver wsdisplay_cd = {\n\tNULL, \"wsdisplay\", DV_TTY\n};",
      "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;",
      "struct tty *\nwsdisplaytty(dev)\n\tdev_t dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "tp",
            "uio",
            "flag"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSSCREEN_HAS_TTY",
          "args": [
            "scr"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSDISPLAYSCREEN",
          "args": [
            "dev"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISWSDISPLAYCTL",
          "args": [
            "dev"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSDISPLAYUNIT",
          "args": [
            "dev"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nextern struct cfdriver wsdisplay_cd;\nstruct cfdriver wsdisplay_cd = {\n\tNULL, \"wsdisplay\", DV_TTY\n};\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\nstruct tty *\nwsdisplaytty(dev)\n\tdev_t dev;\n\nint\nwsdisplaywrite(dev, uio, flag)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flag;\n{\n\tstruct wsdisplay_softc *sc;\n\tstruct tty *tp;\n\tint unit;\n\tstruct wsscreen *scr;\n\n\tunit = WSDISPLAYUNIT(dev);\n\tsc = wsdisplay_cd.cd_devs[unit];\n\n\tif (ISWSDISPLAYCTL(dev))\n\t\treturn (0);\n\n\tscr = sc->sc_scr[WSDISPLAYSCREEN(dev)];\n\n\tif (!WSSCREEN_HAS_TTY(scr))\n\t\treturn (ENODEV);\n\n\ttp = scr->scr_tty;\n\treturn ((*linesw[tp->t_line].l_write)(tp, uio, flag));\n}"
  },
  {
    "function_name": "wsdisplayread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "812-836",
    "snippet": "int\nwsdisplayread(dev, uio, flag)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flag;\n{\n\tstruct wsdisplay_softc *sc;\n\tstruct tty *tp;\n\tint unit;\n\tstruct wsscreen *scr;\n\n\tunit = WSDISPLAYUNIT(dev);\n\tsc = wsdisplay_cd.cd_devs[unit];\n\n\tif (ISWSDISPLAYCTL(dev))\n\t\treturn (0);\n\n\tscr = sc->sc_scr[WSDISPLAYSCREEN(dev)];\n\n\tif (!WSSCREEN_HAS_TTY(scr))\n\t\treturn (ENODEV);\n\n\ttp = scr->scr_tty;\n\treturn ((*linesw[tp->t_line].l_read)(tp, uio, flag));\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern struct cfdriver wsdisplay_cd;",
      "struct cfdriver wsdisplay_cd = {\n\tNULL, \"wsdisplay\", DV_TTY\n};",
      "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;",
      "struct tty *\nwsdisplaytty(dev)\n\tdev_t dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "tp",
            "uio",
            "flag"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSSCREEN_HAS_TTY",
          "args": [
            "scr"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSDISPLAYSCREEN",
          "args": [
            "dev"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISWSDISPLAYCTL",
          "args": [
            "dev"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSDISPLAYUNIT",
          "args": [
            "dev"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nextern struct cfdriver wsdisplay_cd;\nstruct cfdriver wsdisplay_cd = {\n\tNULL, \"wsdisplay\", DV_TTY\n};\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\nstruct tty *\nwsdisplaytty(dev)\n\tdev_t dev;\n\nint\nwsdisplayread(dev, uio, flag)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flag;\n{\n\tstruct wsdisplay_softc *sc;\n\tstruct tty *tp;\n\tint unit;\n\tstruct wsscreen *scr;\n\n\tunit = WSDISPLAYUNIT(dev);\n\tsc = wsdisplay_cd.cd_devs[unit];\n\n\tif (ISWSDISPLAYCTL(dev))\n\t\treturn (0);\n\n\tscr = sc->sc_scr[WSDISPLAYSCREEN(dev)];\n\n\tif (!WSSCREEN_HAS_TTY(scr))\n\t\treturn (ENODEV);\n\n\ttp = scr->scr_tty;\n\treturn ((*linesw[tp->t_line].l_read)(tp, uio, flag));\n}"
  },
  {
    "function_name": "wsdisplayclose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "753-810",
    "snippet": "int\nwsdisplayclose(dev, flag, mode, p)\n\tdev_t dev;\n\tint flag, mode;\n\tstruct proc *p;\n{\n\tstruct wsdisplay_softc *sc;\n\tstruct tty *tp;\n\tint unit;\n\tstruct wsscreen *scr;\n\n\tunit = WSDISPLAYUNIT(dev);\n\tsc = wsdisplay_cd.cd_devs[unit];\n\n\tif (ISWSDISPLAYCTL(dev))\n\t\treturn (0);\n\n\tscr = sc->sc_scr[WSDISPLAYSCREEN(dev)];\n\n\tif (WSSCREEN_HAS_TTY(scr)) {\n\t\tif (scr->scr_hold_screen) {\n\t\t\tint s;\n\n\t\t\t/* XXX RESET KEYBOARD LEDS, etc. */\n\t\t\ts = spltty();\t/* avoid conflict with keyboard */\n\t\t\twsdisplay_kbdholdscreen((struct device *)sc, 0);\n\t\t\tsplx(s);\n\t\t}\n\t\ttp = scr->scr_tty;\n\t\t(*linesw[tp->t_line].l_close)(tp, flag);\n\t\tttyclose(tp);\n\t}\n\n\tif (scr->scr_syncops)\n\t\t(*scr->scr_syncops->destroy)(scr->scr_synccookie);\n\n\tif (WSSCREEN_HAS_EMULATOR(scr)) {\n\t\tscr->scr_flags &= ~SCR_GRAPHICS;\n\t\t(*scr->scr_dconf->wsemul->reset)(scr->scr_dconf->wsemulcookie,\n\t\t\t\t\t\t WSEMUL_RESET);\n\t\tif (wsdisplay_clearonclose)\n\t\t\t(*scr->scr_dconf->wsemul->reset)\n\t\t\t\t(scr->scr_dconf->wsemulcookie,\n\t\t\t\t WSEMUL_CLEARSCREEN);\n\t}\n\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\tif (scr->scr_rawkbd) {\n\t\tint kbmode = WSKBD_TRANSLATED;\n\t\t(void) wsdisplay_internal_ioctl(sc, scr, WSKBDIO_SETMODE,\n\t\t\t\t\t\t(caddr_t)&kbmode, 0, p);\n\t}\n#endif\n\n\tscr->scr_flags &= ~SCR_OPEN;\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [
      "#define SCR_GRAPHICS 4\t\t/* graphics mode, no text (emulation) output */",
      "#define SCR_OPEN 1\t\t/* is it open? */"
    ],
    "globals_used": [
      "extern struct cfdriver wsdisplay_cd;",
      "struct cfdriver wsdisplay_cd = {\n\tNULL, \"wsdisplay\", DV_TTY\n};",
      "int wsdisplay_clearonclose;",
      "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;",
      "struct tty *\nwsdisplaytty(dev)\n\tdev_t dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wsdisplay_internal_ioctl",
          "args": [
            "sc",
            "scr",
            "WSKBDIO_SETMODE",
            "(caddr_t)&kbmode",
            "0",
            "p"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "wsdisplay_internal_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "936-1012",
          "snippet": "int\nwsdisplay_internal_ioctl(sc, scr, cmd, data, flag, p)\n\tstruct wsdisplay_softc *sc;\n\tstruct wsscreen *scr;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tint error;\n\tchar namebuf[16];\n\tstruct wsdisplay_font fd;\n\n#if NWSKBD > 0\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t\tswitch (cmd) {\n\t\t    case WSKBDIO_SETMODE:\n\t\t\tscr->scr_rawkbd = (*(int *)data == WSKBD_RAW);\n\t\t\treturn (wsdisplay_update_rawkbd(sc, scr));\n\t\t    case WSKBDIO_GETMODE:\n\t\t\t*(int *)data = (scr->scr_rawkbd ?\n\t\t\t\t\tWSKBD_RAW : WSKBD_TRANSLATED);\n\t\t\treturn (0);\n\t\t}\n#endif\n\terror = wsmux_displayioctl(&sc->sc_muxdv->sc_dv, cmd, data, flag, p);\n\t\tif (error >= 0)\n\t\treturn (error);\n#endif /* NWSKBD > 0 */\n\n\tswitch (cmd) {\n\tcase WSDISPLAYIO_GMODE:\n\t\t*(u_int *)data = (scr->scr_flags & SCR_GRAPHICS ?\n\t\t\t\t  WSDISPLAYIO_MODE_MAPPED :\n\t\t\t\t  WSDISPLAYIO_MODE_EMUL);\n\t\treturn (0);\n\n\tcase WSDISPLAYIO_SMODE:\n#define d (*(int *)data)\n\t\tif (d != WSDISPLAYIO_MODE_EMUL &&\n\t\t    d != WSDISPLAYIO_MODE_MAPPED)\n\t\t\treturn (EINVAL);\n\n\t    if (WSSCREEN_HAS_EMULATOR(scr)) {\n\t\t    scr->scr_flags &= ~SCR_GRAPHICS;\n\t\t    if (d == WSDISPLAYIO_MODE_MAPPED)\n\t\t\t    scr->scr_flags |= SCR_GRAPHICS;\n\t    } else if (d == WSDISPLAYIO_MODE_EMUL)\n\t\t    return (EINVAL);\n\t    return (0);\n#undef d\n\n\tcase WSDISPLAYIO_USEFONT:\n#define d ((struct wsdisplay_usefontdata *)data)\n\t\tif (!sc->sc_accessops->load_font)\n\t\t\treturn (EINVAL);\n\t\tif (d->name) {\n\t\t\terror = copyinstr(d->name, namebuf, sizeof(namebuf), 0);\n\t\t\tif (error)\n\t\t\t\treturn (error);\n\t\t\tfd.name = namebuf;\n\t\t} else\n\t\t\tfd.name = 0;\n\t\tfd.data = 0;\n\t\terror = (*sc->sc_accessops->load_font)(sc->sc_accesscookie,\n\t\t\t\t\tscr->scr_dconf->emulcookie, &fd);\n\t\tif (!error && WSSCREEN_HAS_EMULATOR(scr))\n\t\t\t(*scr->scr_dconf->wsemul->reset)\n\t\t\t\t(scr->scr_dconf->wsemulcookie, WSEMUL_SYNCFONT);\n\t\treturn (error);\n#undef d\n\t}\n\n\t/* check ioctls for display */\n\treturn ((*sc->sc_accessops->ioctl)(sc->sc_accesscookie, cmd, data,\n\t    flag, p));\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [
            "#define d ((struct wsmux_device *)data)",
            "#define d ((struct wsdisplay_kbddata *)data)",
            "#define d ((struct wsdisplay_font *)data)",
            "#define d ((struct wsdisplay_delscreendata *)data)",
            "#define d ((struct wsdisplay_addscreendata *)data)",
            "#define d ((struct wsdisplay_usefontdata *)data)",
            "#define d (*(int *)data)",
            "#define SCR_GRAPHICS 4\t\t/* graphics mode, no text (emulation) output */"
          ],
          "globals_used": [
            "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;",
            "const char *name;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define d ((struct wsmux_device *)data)\n#define d ((struct wsdisplay_kbddata *)data)\n#define d ((struct wsdisplay_font *)data)\n#define d ((struct wsdisplay_delscreendata *)data)\n#define d ((struct wsdisplay_addscreendata *)data)\n#define d ((struct wsdisplay_usefontdata *)data)\n#define d (*(int *)data)\n#define SCR_GRAPHICS 4\t\t/* graphics mode, no text (emulation) output */\n\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\nconst char *name;\n\nint\nwsdisplay_internal_ioctl(sc, scr, cmd, data, flag, p)\n\tstruct wsdisplay_softc *sc;\n\tstruct wsscreen *scr;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tint error;\n\tchar namebuf[16];\n\tstruct wsdisplay_font fd;\n\n#if NWSKBD > 0\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t\tswitch (cmd) {\n\t\t    case WSKBDIO_SETMODE:\n\t\t\tscr->scr_rawkbd = (*(int *)data == WSKBD_RAW);\n\t\t\treturn (wsdisplay_update_rawkbd(sc, scr));\n\t\t    case WSKBDIO_GETMODE:\n\t\t\t*(int *)data = (scr->scr_rawkbd ?\n\t\t\t\t\tWSKBD_RAW : WSKBD_TRANSLATED);\n\t\t\treturn (0);\n\t\t}\n#endif\n\terror = wsmux_displayioctl(&sc->sc_muxdv->sc_dv, cmd, data, flag, p);\n\t\tif (error >= 0)\n\t\treturn (error);\n#endif /* NWSKBD > 0 */\n\n\tswitch (cmd) {\n\tcase WSDISPLAYIO_GMODE:\n\t\t*(u_int *)data = (scr->scr_flags & SCR_GRAPHICS ?\n\t\t\t\t  WSDISPLAYIO_MODE_MAPPED :\n\t\t\t\t  WSDISPLAYIO_MODE_EMUL);\n\t\treturn (0);\n\n\tcase WSDISPLAYIO_SMODE:\n#define d (*(int *)data)\n\t\tif (d != WSDISPLAYIO_MODE_EMUL &&\n\t\t    d != WSDISPLAYIO_MODE_MAPPED)\n\t\t\treturn (EINVAL);\n\n\t    if (WSSCREEN_HAS_EMULATOR(scr)) {\n\t\t    scr->scr_flags &= ~SCR_GRAPHICS;\n\t\t    if (d == WSDISPLAYIO_MODE_MAPPED)\n\t\t\t    scr->scr_flags |= SCR_GRAPHICS;\n\t    } else if (d == WSDISPLAYIO_MODE_EMUL)\n\t\t    return (EINVAL);\n\t    return (0);\n#undef d\n\n\tcase WSDISPLAYIO_USEFONT:\n#define d ((struct wsdisplay_usefontdata *)data)\n\t\tif (!sc->sc_accessops->load_font)\n\t\t\treturn (EINVAL);\n\t\tif (d->name) {\n\t\t\terror = copyinstr(d->name, namebuf, sizeof(namebuf), 0);\n\t\t\tif (error)\n\t\t\t\treturn (error);\n\t\t\tfd.name = namebuf;\n\t\t} else\n\t\t\tfd.name = 0;\n\t\tfd.data = 0;\n\t\terror = (*sc->sc_accessops->load_font)(sc->sc_accesscookie,\n\t\t\t\t\tscr->scr_dconf->emulcookie, &fd);\n\t\tif (!error && WSSCREEN_HAS_EMULATOR(scr))\n\t\t\t(*scr->scr_dconf->wsemul->reset)\n\t\t\t\t(scr->scr_dconf->wsemulcookie, WSEMUL_SYNCFONT);\n\t\treturn (error);\n#undef d\n\t}\n\n\t/* check ioctls for display */\n\treturn ((*sc->sc_accessops->ioctl)(sc->sc_accesscookie, cmd, data,\n\t    flag, p));\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "scr->scr_dconf->wsemulcookie",
            "WSEMUL_CLEARSCREEN"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "scr->scr_dconf->wsemulcookie",
            "WSEMUL_RESET"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSSCREEN_HAS_EMULATOR",
          "args": [
            "scr"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "scr->scr_synccookie"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttyclose",
          "args": [
            "tp"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "tp",
            "flag"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsdisplay_kbdholdscreen",
          "args": [
            "(struct device *)sc",
            "0"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "wsdisplay_kbdholdscreen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "1674-1690",
          "snippet": "void\nwsdisplay_kbdholdscreen(dev, hold)\n\tstruct device *dev;\n\tint hold;\n{\n\tstruct wsdisplay_softc *sc = (struct wsdisplay_softc *)dev;\n\tstruct wsscreen *scr;\n\n\tscr = sc->sc_focus;\n\n\tif (hold)\n\t\tscr->scr_hold_screen = 1;\n\telse {\n\t\tscr->scr_hold_screen = 0;\n\t\ttimeout(ttrstrt, scr->scr_tty, 0);\t/* \"immediate\" */\n\t}\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;",
            "struct tty *\nwsdisplaytty(dev)\n\tdev_t dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\nstruct tty *\nwsdisplaytty(dev)\n\tdev_t dev;\n\nvoid\nwsdisplay_kbdholdscreen(dev, hold)\n\tstruct device *dev;\n\tint hold;\n{\n\tstruct wsdisplay_softc *sc = (struct wsdisplay_softc *)dev;\n\tstruct wsscreen *scr;\n\n\tscr = sc->sc_focus;\n\n\tif (hold)\n\t\tscr->scr_hold_screen = 1;\n\telse {\n\t\tscr->scr_hold_screen = 0;\n\t\ttimeout(ttrstrt, scr->scr_tty, 0);\t/* \"immediate\" */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSSCREEN_HAS_TTY",
          "args": [
            "scr"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSDISPLAYSCREEN",
          "args": [
            "dev"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISWSDISPLAYCTL",
          "args": [
            "dev"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSDISPLAYUNIT",
          "args": [
            "dev"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define SCR_GRAPHICS 4\t\t/* graphics mode, no text (emulation) output */\n#define SCR_OPEN 1\t\t/* is it open? */\n\nextern struct cfdriver wsdisplay_cd;\nstruct cfdriver wsdisplay_cd = {\n\tNULL, \"wsdisplay\", DV_TTY\n};\nint wsdisplay_clearonclose;\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\nstruct tty *\nwsdisplaytty(dev)\n\tdev_t dev;\n\nint\nwsdisplayclose(dev, flag, mode, p)\n\tdev_t dev;\n\tint flag, mode;\n\tstruct proc *p;\n{\n\tstruct wsdisplay_softc *sc;\n\tstruct tty *tp;\n\tint unit;\n\tstruct wsscreen *scr;\n\n\tunit = WSDISPLAYUNIT(dev);\n\tsc = wsdisplay_cd.cd_devs[unit];\n\n\tif (ISWSDISPLAYCTL(dev))\n\t\treturn (0);\n\n\tscr = sc->sc_scr[WSDISPLAYSCREEN(dev)];\n\n\tif (WSSCREEN_HAS_TTY(scr)) {\n\t\tif (scr->scr_hold_screen) {\n\t\t\tint s;\n\n\t\t\t/* XXX RESET KEYBOARD LEDS, etc. */\n\t\t\ts = spltty();\t/* avoid conflict with keyboard */\n\t\t\twsdisplay_kbdholdscreen((struct device *)sc, 0);\n\t\t\tsplx(s);\n\t\t}\n\t\ttp = scr->scr_tty;\n\t\t(*linesw[tp->t_line].l_close)(tp, flag);\n\t\tttyclose(tp);\n\t}\n\n\tif (scr->scr_syncops)\n\t\t(*scr->scr_syncops->destroy)(scr->scr_synccookie);\n\n\tif (WSSCREEN_HAS_EMULATOR(scr)) {\n\t\tscr->scr_flags &= ~SCR_GRAPHICS;\n\t\t(*scr->scr_dconf->wsemul->reset)(scr->scr_dconf->wsemulcookie,\n\t\t\t\t\t\t WSEMUL_RESET);\n\t\tif (wsdisplay_clearonclose)\n\t\t\t(*scr->scr_dconf->wsemul->reset)\n\t\t\t\t(scr->scr_dconf->wsemulcookie,\n\t\t\t\t WSEMUL_CLEARSCREEN);\n\t}\n\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\tif (scr->scr_rawkbd) {\n\t\tint kbmode = WSKBD_TRANSLATED;\n\t\t(void) wsdisplay_internal_ioctl(sc, scr, WSKBDIO_SETMODE,\n\t\t\t\t\t\t(caddr_t)&kbmode, 0, p);\n\t}\n#endif\n\n\tscr->scr_flags &= ~SCR_OPEN;\n\n\treturn (0);\n}"
  },
  {
    "function_name": "wsdisplayopen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "690-751",
    "snippet": "int\nwsdisplayopen(dev, flag, mode, p)\n\tdev_t dev;\n\tint flag, mode;\n\tstruct proc *p;\n{\n\tstruct wsdisplay_softc *sc;\n\tstruct tty *tp;\n\tint unit, newopen, error;\n\tstruct wsscreen *scr;\n\n\tunit = WSDISPLAYUNIT(dev);\n\tif (unit >= wsdisplay_cd.cd_ndevs ||\t/* make sure it was attached */\n\t    (sc = wsdisplay_cd.cd_devs[unit]) == NULL)\n\t\treturn (ENXIO);\n\n\tif (ISWSDISPLAYCTL(dev))\n\t\treturn (0);\n\n\tif (WSDISPLAYSCREEN(dev) >= WSDISPLAY_MAXSCREEN)\n\t\treturn (ENXIO);\n\tscr = sc->sc_scr[WSDISPLAYSCREEN(dev)];\n\tif (!scr)\n\t\treturn (ENXIO);\n\n\tif (WSSCREEN_HAS_TTY(scr)) {\n\t\ttp = scr->scr_tty;\n\t\ttp->t_oproc = wsdisplaystart;\n\t\ttp->t_param = wsdisplayparam;\n\t\ttp->t_dev = dev;\n\t\tnewopen = (tp->t_state & TS_ISOPEN) == 0;\n\t\tif (newopen) {\n\t\t\tttychars(tp);\n\t\t\ttp->t_iflag = TTYDEF_IFLAG;\n\t\t\ttp->t_oflag = TTYDEF_OFLAG;\n\t\t\ttp->t_cflag = TTYDEF_CFLAG;\n\t\t\ttp->t_lflag = TTYDEF_LFLAG;\n\t\t\ttp->t_ispeed = tp->t_ospeed = TTYDEF_SPEED;\n\t\t\twsdisplayparam(tp, &tp->t_termios);\n\t\t\tttsetwater(tp);\n\t\t} else if ((tp->t_state & TS_XCLUDE) != 0 &&\n\t\t\t   p->p_ucred->cr_uid != 0)\n\t\t\treturn EBUSY;\n\t\ttp->t_state |= TS_CARR_ON;\n\n\t\terror = ((*linesw[tp->t_line].l_open)(dev, tp));\n\t\tif (error)\n\t\t\treturn (error);\n\n\t\tif (newopen && WSSCREEN_HAS_EMULATOR(scr)) {\n\t\t\t/* set window sizes as appropriate, and reset\n\t\t\t the emulation */\n\t\t\ttp->t_winsize.ws_row = scr->scr_dconf->scrdata->nrows;\n\t\t\ttp->t_winsize.ws_col = scr->scr_dconf->scrdata->ncols;\n\n\t\t\t/* wsdisplay_set_emulation() */\n\t\t}\n\t}\n\n\tscr->scr_flags |= SCR_OPEN;\n\treturn (0);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [
      "#define WSDISPLAY_MAXSCREEN 8",
      "#define SCR_OPEN 1\t\t/* is it open? */"
    ],
    "globals_used": [
      "extern struct cfdriver wsdisplay_cd;",
      "struct cfdriver wsdisplay_cd = {\n\tNULL, \"wsdisplay\", DV_TTY\n};",
      "static void wsdisplaystart",
      "static int wsdisplayparam",
      "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;",
      "static const struct wsscreen_descr *\nwsdisplay_screentype_pick(scrdata, name)\n\tconst struct wsscreen_list *scrdata;",
      "struct tty *\nwsdisplaytty(dev)\n\tdev_t dev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WSSCREEN_HAS_EMULATOR",
          "args": [
            "scr"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "dev",
            "tp"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttsetwater",
          "args": [
            "tp"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsdisplayparam",
          "args": [
            "tp",
            "&tp->t_termios"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "wsdisplayparam",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "1234-1244",
          "snippet": "int\nwsdisplayparam(tp, t)\n\tstruct tty *tp;\n\tstruct termios *t;\n{\n\n\ttp->t_ispeed = t->c_ispeed;\n\ttp->t_ospeed = t->c_ospeed;\n\ttp->t_cflag = t->c_cflag;\n\treturn 0;\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int wsdisplayparam"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstatic int wsdisplayparam;\n\nint\nwsdisplayparam(tp, t)\n\tstruct tty *tp;\n\tstruct termios *t;\n{\n\n\ttp->t_ispeed = t->c_ispeed;\n\ttp->t_ospeed = t->c_ospeed;\n\ttp->t_cflag = t->c_cflag;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ttychars",
          "args": [
            "tp"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSSCREEN_HAS_TTY",
          "args": [
            "scr"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSDISPLAYSCREEN",
          "args": [
            "dev"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSDISPLAYSCREEN",
          "args": [
            "dev"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISWSDISPLAYCTL",
          "args": [
            "dev"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSDISPLAYUNIT",
          "args": [
            "dev"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define WSDISPLAY_MAXSCREEN 8\n#define SCR_OPEN 1\t\t/* is it open? */\n\nextern struct cfdriver wsdisplay_cd;\nstruct cfdriver wsdisplay_cd = {\n\tNULL, \"wsdisplay\", DV_TTY\n};\nstatic void wsdisplaystart;\nstatic int wsdisplayparam;\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\nstatic const struct wsscreen_descr *\nwsdisplay_screentype_pick(scrdata, name)\n\tconst struct wsscreen_list *scrdata;\nstruct tty *\nwsdisplaytty(dev)\n\tdev_t dev;\n\nint\nwsdisplayopen(dev, flag, mode, p)\n\tdev_t dev;\n\tint flag, mode;\n\tstruct proc *p;\n{\n\tstruct wsdisplay_softc *sc;\n\tstruct tty *tp;\n\tint unit, newopen, error;\n\tstruct wsscreen *scr;\n\n\tunit = WSDISPLAYUNIT(dev);\n\tif (unit >= wsdisplay_cd.cd_ndevs ||\t/* make sure it was attached */\n\t    (sc = wsdisplay_cd.cd_devs[unit]) == NULL)\n\t\treturn (ENXIO);\n\n\tif (ISWSDISPLAYCTL(dev))\n\t\treturn (0);\n\n\tif (WSDISPLAYSCREEN(dev) >= WSDISPLAY_MAXSCREEN)\n\t\treturn (ENXIO);\n\tscr = sc->sc_scr[WSDISPLAYSCREEN(dev)];\n\tif (!scr)\n\t\treturn (ENXIO);\n\n\tif (WSSCREEN_HAS_TTY(scr)) {\n\t\ttp = scr->scr_tty;\n\t\ttp->t_oproc = wsdisplaystart;\n\t\ttp->t_param = wsdisplayparam;\n\t\ttp->t_dev = dev;\n\t\tnewopen = (tp->t_state & TS_ISOPEN) == 0;\n\t\tif (newopen) {\n\t\t\tttychars(tp);\n\t\t\ttp->t_iflag = TTYDEF_IFLAG;\n\t\t\ttp->t_oflag = TTYDEF_OFLAG;\n\t\t\ttp->t_cflag = TTYDEF_CFLAG;\n\t\t\ttp->t_lflag = TTYDEF_LFLAG;\n\t\t\ttp->t_ispeed = tp->t_ospeed = TTYDEF_SPEED;\n\t\t\twsdisplayparam(tp, &tp->t_termios);\n\t\t\tttsetwater(tp);\n\t\t} else if ((tp->t_state & TS_XCLUDE) != 0 &&\n\t\t\t   p->p_ucred->cr_uid != 0)\n\t\t\treturn EBUSY;\n\t\ttp->t_state |= TS_CARR_ON;\n\n\t\terror = ((*linesw[tp->t_line].l_open)(dev, tp));\n\t\tif (error)\n\t\t\treturn (error);\n\n\t\tif (newopen && WSSCREEN_HAS_EMULATOR(scr)) {\n\t\t\t/* set window sizes as appropriate, and reset\n\t\t\t the emulation */\n\t\t\ttp->t_winsize.ws_row = scr->scr_dconf->scrdata->nrows;\n\t\t\ttp->t_winsize.ws_col = scr->scr_dconf->scrdata->ncols;\n\n\t\t\t/* wsdisplay_set_emulation() */\n\t\t}\n\t}\n\n\tscr->scr_flags |= SCR_OPEN;\n\treturn (0);\n}"
  },
  {
    "function_name": "wsdisplay_cnattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "657-685",
    "snippet": "void\nwsdisplay_cnattach(type, cookie, ccol, crow, defattr)\n\tconst struct wsscreen_descr *type;\n\tvoid *cookie;\n\tint ccol, crow;\n\tlong defattr;\n{\n\tconst struct wsemul_ops *wsemul;\n\n\tKASSERT(!wsdisplay_console_initted);\n\tKASSERT(type->nrows > 0);\n\tKASSERT(type->ncols > 0);\n\tKASSERT(crow < type->nrows);\n\tKASSERT(ccol < type->ncols);\n\n\twsdisplay_console_conf.emulops = type->textops;\n\twsdisplay_console_conf.emulcookie = cookie;\n\twsdisplay_console_conf.scrdata = type;\n\n\twsemul = wsemul_pick(0); /* default */\n\twsdisplay_console_conf.wsemul = wsemul;\n\twsdisplay_console_conf.wsemulcookie = (*wsemul->cnattach)(type, cookie,\n\t\t\t\t\t\t\t\t  ccol, crow,\n\t\t\t\t\t\t\t\t  defattr);\n\n\tcn_tab = &wsdisplay_cons;\n\n\twsdisplay_console_initted = 1;\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int wsdisplay_console_initted;",
      "static struct wsscreen_internal wsdisplay_console_conf;",
      "static struct consdev wsdisplay_cons = {\n\tNULL, NULL, wsdisplay_getc_dummy, wsdisplay_cnputc,\n\twsdisplay_pollc, NODEV, CN_NORMAL\n};",
      "const struct wsscreen_descr *type;",
      "void *cookie;",
      "int ccol, crow;",
      "long defattr;",
      "static const struct wsscreen_descr *\nwsdisplay_screentype_pick(scrdata, name)\n\tconst struct wsscreen_list *scrdata;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "type",
            "cookie",
            "ccol",
            "crow",
            "defattr"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsemul_pick",
          "args": [
            "0"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KASSERT",
          "args": [
            "ccol < type->ncols"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KASSERT",
          "args": [
            "crow < type->nrows"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KASSERT",
          "args": [
            "type->ncols > 0"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KASSERT",
          "args": [
            "type->nrows > 0"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KASSERT",
          "args": [
            "!wsdisplay_console_initted"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstatic int wsdisplay_console_initted;\nstatic struct wsscreen_internal wsdisplay_console_conf;\nstatic struct consdev wsdisplay_cons = {\n\tNULL, NULL, wsdisplay_getc_dummy, wsdisplay_cnputc,\n\twsdisplay_pollc, NODEV, CN_NORMAL\n};\nconst struct wsscreen_descr *type;\nvoid *cookie;\nint ccol, crow;\nlong defattr;\nstatic const struct wsscreen_descr *\nwsdisplay_screentype_pick(scrdata, name)\n\tconst struct wsscreen_list *scrdata;\n\nvoid\nwsdisplay_cnattach(type, cookie, ccol, crow, defattr)\n\tconst struct wsscreen_descr *type;\n\tvoid *cookie;\n\tint ccol, crow;\n\tlong defattr;\n{\n\tconst struct wsemul_ops *wsemul;\n\n\tKASSERT(!wsdisplay_console_initted);\n\tKASSERT(type->nrows > 0);\n\tKASSERT(type->ncols > 0);\n\tKASSERT(crow < type->nrows);\n\tKASSERT(ccol < type->ncols);\n\n\twsdisplay_console_conf.emulops = type->textops;\n\twsdisplay_console_conf.emulcookie = cookie;\n\twsdisplay_console_conf.scrdata = type;\n\n\twsemul = wsemul_pick(0); /* default */\n\twsdisplay_console_conf.wsemul = wsemul;\n\twsdisplay_console_conf.wsemulcookie = (*wsemul->cnattach)(type, cookie,\n\t\t\t\t\t\t\t\t  ccol, crow,\n\t\t\t\t\t\t\t\t  defattr);\n\n\tcn_tab = &wsdisplay_cons;\n\n\twsdisplay_console_initted = 1;\n}"
  },
  {
    "function_name": "wsdisplay_common_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "592-655",
    "snippet": "static void\nwsdisplay_common_attach(sc, console, scrdata, accessops, accesscookie)\n\tstruct wsdisplay_softc *sc;\n\tint console;\n\tconst struct wsscreen_list *scrdata;\n\tconst struct wsdisplay_accessops *accessops;\n\tvoid *accesscookie;\n{\n\tstatic int hookset;\n\tint i, start=0;\n#if NWSKBD > 0\n\tstruct device *dv;\n\n\tsc->sc_muxdv = wsmux_create(\"dmux\", sc->sc_dv.dv_unit);\n\tif (!sc->sc_muxdv)\n\t\tpanic(\"wsdisplay_common_attach: no memory\\n\");\n\tsc->sc_muxdv->sc_displaydv = &sc->sc_dv;\n#endif\n\n\tsc->sc_isconsole = console;\n\n\tif (console) {\n\t\tKASSERT(wsdisplay_console_initted);\n\t\tKASSERT(wsdisplay_console_device == NULL);\n\n\t\tsc->sc_scr[0] = wsscreen_attach(sc, 1, 0, 0, 0, 0, 0, 0);\n\t\twsdisplay_console_device = sc;\n\n\t\tprintf(\": console (%s, %s emulation)\",\n\t\t       wsdisplay_console_conf.scrdata->name,\n\t\t       wsdisplay_console_conf.wsemul->name);\n\n#if NWSKBD > 0\n\t\tif ((dv = wskbd_set_console_display(&sc->sc_dv, sc->sc_muxdv)))\n\t\t\tprintf(\", using %s\", dv->dv_xname);\n#endif\n\n\t\tsc->sc_focusidx = 0;\n\t\tsc->sc_focus = sc->sc_scr[0];\n\t\tstart = 1;\n\t}\n\tprintf(\"\\n\");\n\n\tsc->sc_accessops = accessops;\n\tsc->sc_accesscookie = accesscookie;\n\tsc->sc_scrdata = scrdata;\n\n\t/*\n\t * Set up a number of virtual screens if wanted. The\n\t * WSDISPLAYIO_ADDSCREEN ioctl is more flexible, so this code\n\t * is for special cases like installation kernels.\n\t */\n\tfor (i = start; i < wsdisplay_defaultscreens; i++) {\n\t\tif (wsdisplay_addscreen(sc, i, 0, 0))\n\t\t\tbreak;\n}\n\n\tif (i > start) \n\t\twsdisplay_addscreen_print(sc, start, i-start);\n\t\n\tif (hookset == 0)\n\t\tshutdownhook_establish(wsdisplay_shutdownhook, NULL);\n\thookset = 1;\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct wsscreen *wsscreen_attach",
      "int wsdisplay_addscreen",
      "static void wsdisplay_shutdownhook",
      "static void wsdisplay_addscreen_print",
      "static void wsdisplay_common_attach",
      "static int wsdisplay_console_initted;",
      "static struct wsdisplay_softc *wsdisplay_console_device;",
      "static struct wsscreen_internal wsdisplay_console_conf;",
      "int wsdisplay_defaultscreens = WSDISPLAY_DEFAULTSCREENS;",
      "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;",
      "int console;",
      "static const struct wsscreen_descr *\nwsdisplay_screentype_pick(scrdata, name)\n\tconst struct wsscreen_list *scrdata;",
      "const char *name;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "shutdownhook_establish",
          "args": [
            "wsdisplay_shutdownhook",
            "NULL"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsdisplay_addscreen_print",
          "args": [
            "sc",
            "start",
            "i-start"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "wsdisplay_addscreen_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "328-342",
          "snippet": "static void\nwsdisplay_addscreen_print(sc, idx, count)\n\tstruct wsdisplay_softc *sc;\n\tint idx, count;\n{\n\tprintf(\"%s: screen %d\", sc->sc_dv.dv_xname, idx);\n\tif (count > 1)\n\t\tprintf(\"-%d\", idx + (count-1));\n\tprintf(\" added (%s\", sc->sc_scr[idx]->scr_dconf->scrdata->name);\n\tif (WSSCREEN_HAS_EMULATOR(sc->sc_scr[idx])) {\n\t\tprintf(\", %s emulation\",\n\t\t\tsc->sc_scr[idx]->scr_dconf->wsemul->name);\n\t}\n\tprintf(\")\\n\");\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [
            "#define d ((struct wsmux_device *)data)",
            "#define d ((struct wsdisplay_kbddata *)data)",
            "#define d ((struct wsdisplay_font *)data)",
            "#define d ((struct wsdisplay_delscreendata *)data)",
            "#define d ((struct wsdisplay_addscreendata *)data)",
            "#define d ((struct wsdisplay_usefontdata *)data)",
            "#define d (*(int *)data)"
          ],
          "globals_used": [
            "static void wsdisplay_addscreen_print",
            "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;",
            "static const struct wsscreen_descr *\nwsdisplay_screentype_pick(scrdata, name)\n\tconst struct wsscreen_list *scrdata;",
            "const char *name;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define d ((struct wsmux_device *)data)\n#define d ((struct wsdisplay_kbddata *)data)\n#define d ((struct wsdisplay_font *)data)\n#define d ((struct wsdisplay_delscreendata *)data)\n#define d ((struct wsdisplay_addscreendata *)data)\n#define d ((struct wsdisplay_usefontdata *)data)\n#define d (*(int *)data)\n\nstatic void wsdisplay_addscreen_print;\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\nstatic const struct wsscreen_descr *\nwsdisplay_screentype_pick(scrdata, name)\n\tconst struct wsscreen_list *scrdata;\nconst char *name;\n\nstatic void\nwsdisplay_addscreen_print(sc, idx, count)\n\tstruct wsdisplay_softc *sc;\n\tint idx, count;\n{\n\tprintf(\"%s: screen %d\", sc->sc_dv.dv_xname, idx);\n\tif (count > 1)\n\t\tprintf(\"-%d\", idx + (count-1));\n\tprintf(\" added (%s\", sc->sc_scr[idx]->scr_dconf->scrdata->name);\n\tif (WSSCREEN_HAS_EMULATOR(sc->sc_scr[idx])) {\n\t\tprintf(\", %s emulation\",\n\t\t\tsc->sc_scr[idx]->scr_dconf->wsemul->name);\n\t}\n\tprintf(\")\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "wsdisplay_addscreen",
          "args": [
            "sc",
            "i",
            "0",
            "0"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "wsdisplay_addscreen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "344-392",
          "snippet": "int\nwsdisplay_addscreen(sc, idx, screentype, emul)\n\tstruct wsdisplay_softc *sc;\n\tint idx;\n\tconst char *screentype, *emul;\n{\n\tconst struct wsscreen_descr *scrdesc;\n\tint error;\n\tvoid *cookie;\n\tint ccol, crow;\n\tlong defattr;\n\tstruct wsscreen *scr;\n\tint s;\n\n\tif (idx < 0 || idx >= WSDISPLAY_MAXSCREEN)\n\t\treturn (EINVAL);\n\tif (sc->sc_scr[idx] != NULL)\n\t\treturn (EBUSY);\n\n\tscrdesc = wsdisplay_screentype_pick(sc->sc_scrdata, screentype);\n\tif (!scrdesc)\n\t\treturn (ENXIO);\n\terror = (*sc->sc_accessops->alloc_screen)(sc->sc_accesscookie,\n\t\t\tscrdesc, &cookie, &ccol, &crow, &defattr);\n\tif (error)\n\t\treturn (error);\n\n\tscr = wsscreen_attach(sc, 0, emul, scrdesc,\n\t\t\t      cookie, ccol, crow, defattr);\n\tif (scr == NULL) {\n\t\t(*sc->sc_accessops->free_screen)(sc->sc_accesscookie,\n\t\t\t\t\t\t cookie);\n\t\treturn (ENXIO);\n\t}\n\n\tsc->sc_scr[idx] = scr;\n\n\t/* if no screen has focus yet, activate the first we get */\n\ts = spltty();\n\tif (!sc->sc_focus) {\n\t\t(*sc->sc_accessops->show_screen)(sc->sc_accesscookie,\n\t\t\t\t\t\t scr->scr_dconf->emulcookie,\n\t\t\t\t\t\t 0, 0, 0);\n\t\tsc->sc_focusidx = idx;\n\t\tsc->sc_focus = scr;\n\t}\n\tsplx(s);\n\treturn (0);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [
            "#define WSDISPLAY_MAXSCREEN 8"
          ],
          "globals_used": [
            "struct wsscreen *wsscreen_attach",
            "static const struct wsscreen_descr *\nwsdisplay_screentype_pick",
            "int wsdisplay_addscreen",
            "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;",
            "const char *emul;",
            "void *cookie;",
            "int ccol, crow;",
            "long defattr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define WSDISPLAY_MAXSCREEN 8\n\nstruct wsscreen *wsscreen_attach;\nstatic const struct wsscreen_descr *\nwsdisplay_screentype_pick;\nint wsdisplay_addscreen;\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\nconst char *emul;\nvoid *cookie;\nint ccol, crow;\nlong defattr;\n\nint\nwsdisplay_addscreen(sc, idx, screentype, emul)\n\tstruct wsdisplay_softc *sc;\n\tint idx;\n\tconst char *screentype, *emul;\n{\n\tconst struct wsscreen_descr *scrdesc;\n\tint error;\n\tvoid *cookie;\n\tint ccol, crow;\n\tlong defattr;\n\tstruct wsscreen *scr;\n\tint s;\n\n\tif (idx < 0 || idx >= WSDISPLAY_MAXSCREEN)\n\t\treturn (EINVAL);\n\tif (sc->sc_scr[idx] != NULL)\n\t\treturn (EBUSY);\n\n\tscrdesc = wsdisplay_screentype_pick(sc->sc_scrdata, screentype);\n\tif (!scrdesc)\n\t\treturn (ENXIO);\n\terror = (*sc->sc_accessops->alloc_screen)(sc->sc_accesscookie,\n\t\t\tscrdesc, &cookie, &ccol, &crow, &defattr);\n\tif (error)\n\t\treturn (error);\n\n\tscr = wsscreen_attach(sc, 0, emul, scrdesc,\n\t\t\t      cookie, ccol, crow, defattr);\n\tif (scr == NULL) {\n\t\t(*sc->sc_accessops->free_screen)(sc->sc_accesscookie,\n\t\t\t\t\t\t cookie);\n\t\treturn (ENXIO);\n\t}\n\n\tsc->sc_scr[idx] = scr;\n\n\t/* if no screen has focus yet, activate the first we get */\n\ts = spltty();\n\tif (!sc->sc_focus) {\n\t\t(*sc->sc_accessops->show_screen)(sc->sc_accesscookie,\n\t\t\t\t\t\t scr->scr_dconf->emulcookie,\n\t\t\t\t\t\t 0, 0, 0);\n\t\tsc->sc_focusidx = idx;\n\t\tsc->sc_focus = scr;\n\t}\n\tsplx(s);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wskbd_set_console_display",
          "args": [
            "&sc->sc_dv",
            "sc->sc_muxdv"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsscreen_attach",
          "args": [
            "sc",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "wsscreen_attach_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "1577-1594",
          "snippet": "int\nwsscreen_attach_sync(scr, ops, cookie)\n\tstruct wsscreen *scr;\n\tconst struct wscons_syncops *ops;\n\tvoid *cookie;\n{\n\tif (scr->scr_syncops) {\n\t\t/*\n\t\t * The screen is already claimed.\n\t\t * Check if the owner is still alive.\n\t\t */\n\t\tif ((*scr->scr_syncops->check)(scr->scr_synccookie))\n\t\t\treturn (EBUSY);\n\t}\n\tscr->scr_syncops = ops;\n\tscr->scr_synccookie = cookie;\n\treturn (0);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *cookie;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nvoid *cookie;\n\nint\nwsscreen_attach_sync(scr, ops, cookie)\n\tstruct wsscreen *scr;\n\tconst struct wscons_syncops *ops;\n\tvoid *cookie;\n{\n\tif (scr->scr_syncops) {\n\t\t/*\n\t\t * The screen is already claimed.\n\t\t * Check if the owner is still alive.\n\t\t */\n\t\tif ((*scr->scr_syncops->check)(scr->scr_synccookie))\n\t\t\treturn (EBUSY);\n\t}\n\tscr->scr_syncops = ops;\n\tscr->scr_synccookie = cookie;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KASSERT",
          "args": [
            "wsdisplay_console_device == NULL"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KASSERT",
          "args": [
            "wsdisplay_console_initted"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"wsdisplay_common_attach: no memory\\n\""
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsmux_create",
          "args": [
            "\"dmux\"",
            "sc->sc_dv.dv_unit"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct wsscreen *wsscreen_attach;\nint wsdisplay_addscreen;\nstatic void wsdisplay_shutdownhook;\nstatic void wsdisplay_addscreen_print;\nstatic void wsdisplay_common_attach;\nstatic int wsdisplay_console_initted;\nstatic struct wsdisplay_softc *wsdisplay_console_device;\nstatic struct wsscreen_internal wsdisplay_console_conf;\nint wsdisplay_defaultscreens = WSDISPLAY_DEFAULTSCREENS;\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\nint console;\nstatic const struct wsscreen_descr *\nwsdisplay_screentype_pick(scrdata, name)\n\tconst struct wsscreen_list *scrdata;\nconst char *name;\n\nstatic void\nwsdisplay_common_attach(sc, console, scrdata, accessops, accesscookie)\n\tstruct wsdisplay_softc *sc;\n\tint console;\n\tconst struct wsscreen_list *scrdata;\n\tconst struct wsdisplay_accessops *accessops;\n\tvoid *accesscookie;\n{\n\tstatic int hookset;\n\tint i, start=0;\n#if NWSKBD > 0\n\tstruct device *dv;\n\n\tsc->sc_muxdv = wsmux_create(\"dmux\", sc->sc_dv.dv_unit);\n\tif (!sc->sc_muxdv)\n\t\tpanic(\"wsdisplay_common_attach: no memory\\n\");\n\tsc->sc_muxdv->sc_displaydv = &sc->sc_dv;\n#endif\n\n\tsc->sc_isconsole = console;\n\n\tif (console) {\n\t\tKASSERT(wsdisplay_console_initted);\n\t\tKASSERT(wsdisplay_console_device == NULL);\n\n\t\tsc->sc_scr[0] = wsscreen_attach(sc, 1, 0, 0, 0, 0, 0, 0);\n\t\twsdisplay_console_device = sc;\n\n\t\tprintf(\": console (%s, %s emulation)\",\n\t\t       wsdisplay_console_conf.scrdata->name,\n\t\t       wsdisplay_console_conf.wsemul->name);\n\n#if NWSKBD > 0\n\t\tif ((dv = wskbd_set_console_display(&sc->sc_dv, sc->sc_muxdv)))\n\t\t\tprintf(\", using %s\", dv->dv_xname);\n#endif\n\n\t\tsc->sc_focusidx = 0;\n\t\tsc->sc_focus = sc->sc_scr[0];\n\t\tstart = 1;\n\t}\n\tprintf(\"\\n\");\n\n\tsc->sc_accessops = accessops;\n\tsc->sc_accesscookie = accesscookie;\n\tsc->sc_scrdata = scrdata;\n\n\t/*\n\t * Set up a number of virtual screens if wanted. The\n\t * WSDISPLAYIO_ADDSCREEN ioctl is more flexible, so this code\n\t * is for special cases like installation kernels.\n\t */\n\tfor (i = start; i < wsdisplay_defaultscreens; i++) {\n\t\tif (wsdisplay_addscreen(sc, i, 0, 0))\n\t\t\tbreak;\n}\n\n\tif (i > start) \n\t\twsdisplay_addscreen_print(sc, start, i-start);\n\t\n\tif (hookset == 0)\n\t\tshutdownhook_establish(wsdisplay_shutdownhook, NULL);\n\thookset = 1;\n}"
  },
  {
    "function_name": "wsdisplaydevprint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "577-590",
    "snippet": "int\nwsdisplaydevprint(aux, pnp)\n\tvoid *aux;\n\tconst char *pnp;\n{\n#if 0 /* -Wunused */\n\tstruct wsdisplaydev_attach_args *ap = aux;\n#endif\n\n\tif (pnp)\n\t\tprintf(\"wsdisplay at %s\", pnp);\n\n\treturn (UNCONF);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"wsdisplay at %s\"",
            "pnp"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nint\nwsdisplaydevprint(aux, pnp)\n\tvoid *aux;\n\tconst char *pnp;\n{\n#if 0 /* -Wunused */\n\tstruct wsdisplaydev_attach_args *ap = aux;\n#endif\n\n\tif (pnp)\n\t\tprintf(\"wsdisplay at %s\", pnp);\n\n\treturn (UNCONF);\n}"
  },
  {
    "function_name": "wsdisplay_noemul_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "565-574",
    "snippet": "void\nwsdisplay_noemul_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct wsdisplay_softc *sc = (struct wsdisplay_softc *)self;\n\tstruct wsdisplaydev_attach_args *ap = aux;\n\n\twsdisplay_common_attach(sc, 0, NULL, ap->accessops, ap->accesscookie);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wsdisplay_noemul_attach",
      "static void wsdisplay_common_attach",
      "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wsdisplay_common_attach",
          "args": [
            "sc",
            "0",
            "NULL",
            "ap->accessops",
            "ap->accesscookie"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "wsdisplay_common_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "592-655",
          "snippet": "static void\nwsdisplay_common_attach(sc, console, scrdata, accessops, accesscookie)\n\tstruct wsdisplay_softc *sc;\n\tint console;\n\tconst struct wsscreen_list *scrdata;\n\tconst struct wsdisplay_accessops *accessops;\n\tvoid *accesscookie;\n{\n\tstatic int hookset;\n\tint i, start=0;\n#if NWSKBD > 0\n\tstruct device *dv;\n\n\tsc->sc_muxdv = wsmux_create(\"dmux\", sc->sc_dv.dv_unit);\n\tif (!sc->sc_muxdv)\n\t\tpanic(\"wsdisplay_common_attach: no memory\\n\");\n\tsc->sc_muxdv->sc_displaydv = &sc->sc_dv;\n#endif\n\n\tsc->sc_isconsole = console;\n\n\tif (console) {\n\t\tKASSERT(wsdisplay_console_initted);\n\t\tKASSERT(wsdisplay_console_device == NULL);\n\n\t\tsc->sc_scr[0] = wsscreen_attach(sc, 1, 0, 0, 0, 0, 0, 0);\n\t\twsdisplay_console_device = sc;\n\n\t\tprintf(\": console (%s, %s emulation)\",\n\t\t       wsdisplay_console_conf.scrdata->name,\n\t\t       wsdisplay_console_conf.wsemul->name);\n\n#if NWSKBD > 0\n\t\tif ((dv = wskbd_set_console_display(&sc->sc_dv, sc->sc_muxdv)))\n\t\t\tprintf(\", using %s\", dv->dv_xname);\n#endif\n\n\t\tsc->sc_focusidx = 0;\n\t\tsc->sc_focus = sc->sc_scr[0];\n\t\tstart = 1;\n\t}\n\tprintf(\"\\n\");\n\n\tsc->sc_accessops = accessops;\n\tsc->sc_accesscookie = accesscookie;\n\tsc->sc_scrdata = scrdata;\n\n\t/*\n\t * Set up a number of virtual screens if wanted. The\n\t * WSDISPLAYIO_ADDSCREEN ioctl is more flexible, so this code\n\t * is for special cases like installation kernels.\n\t */\n\tfor (i = start; i < wsdisplay_defaultscreens; i++) {\n\t\tif (wsdisplay_addscreen(sc, i, 0, 0))\n\t\t\tbreak;\n}\n\n\tif (i > start) \n\t\twsdisplay_addscreen_print(sc, start, i-start);\n\t\n\tif (hookset == 0)\n\t\tshutdownhook_establish(wsdisplay_shutdownhook, NULL);\n\thookset = 1;\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct wsscreen *wsscreen_attach",
            "int wsdisplay_addscreen",
            "static void wsdisplay_shutdownhook",
            "static void wsdisplay_addscreen_print",
            "static void wsdisplay_common_attach",
            "static int wsdisplay_console_initted;",
            "static struct wsdisplay_softc *wsdisplay_console_device;",
            "static struct wsscreen_internal wsdisplay_console_conf;",
            "int wsdisplay_defaultscreens = WSDISPLAY_DEFAULTSCREENS;",
            "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;",
            "int console;",
            "static const struct wsscreen_descr *\nwsdisplay_screentype_pick(scrdata, name)\n\tconst struct wsscreen_list *scrdata;",
            "const char *name;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct wsscreen *wsscreen_attach;\nint wsdisplay_addscreen;\nstatic void wsdisplay_shutdownhook;\nstatic void wsdisplay_addscreen_print;\nstatic void wsdisplay_common_attach;\nstatic int wsdisplay_console_initted;\nstatic struct wsdisplay_softc *wsdisplay_console_device;\nstatic struct wsscreen_internal wsdisplay_console_conf;\nint wsdisplay_defaultscreens = WSDISPLAY_DEFAULTSCREENS;\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\nint console;\nstatic const struct wsscreen_descr *\nwsdisplay_screentype_pick(scrdata, name)\n\tconst struct wsscreen_list *scrdata;\nconst char *name;\n\nstatic void\nwsdisplay_common_attach(sc, console, scrdata, accessops, accesscookie)\n\tstruct wsdisplay_softc *sc;\n\tint console;\n\tconst struct wsscreen_list *scrdata;\n\tconst struct wsdisplay_accessops *accessops;\n\tvoid *accesscookie;\n{\n\tstatic int hookset;\n\tint i, start=0;\n#if NWSKBD > 0\n\tstruct device *dv;\n\n\tsc->sc_muxdv = wsmux_create(\"dmux\", sc->sc_dv.dv_unit);\n\tif (!sc->sc_muxdv)\n\t\tpanic(\"wsdisplay_common_attach: no memory\\n\");\n\tsc->sc_muxdv->sc_displaydv = &sc->sc_dv;\n#endif\n\n\tsc->sc_isconsole = console;\n\n\tif (console) {\n\t\tKASSERT(wsdisplay_console_initted);\n\t\tKASSERT(wsdisplay_console_device == NULL);\n\n\t\tsc->sc_scr[0] = wsscreen_attach(sc, 1, 0, 0, 0, 0, 0, 0);\n\t\twsdisplay_console_device = sc;\n\n\t\tprintf(\": console (%s, %s emulation)\",\n\t\t       wsdisplay_console_conf.scrdata->name,\n\t\t       wsdisplay_console_conf.wsemul->name);\n\n#if NWSKBD > 0\n\t\tif ((dv = wskbd_set_console_display(&sc->sc_dv, sc->sc_muxdv)))\n\t\t\tprintf(\", using %s\", dv->dv_xname);\n#endif\n\n\t\tsc->sc_focusidx = 0;\n\t\tsc->sc_focus = sc->sc_scr[0];\n\t\tstart = 1;\n\t}\n\tprintf(\"\\n\");\n\n\tsc->sc_accessops = accessops;\n\tsc->sc_accesscookie = accesscookie;\n\tsc->sc_scrdata = scrdata;\n\n\t/*\n\t * Set up a number of virtual screens if wanted. The\n\t * WSDISPLAYIO_ADDSCREEN ioctl is more flexible, so this code\n\t * is for special cases like installation kernels.\n\t */\n\tfor (i = start; i < wsdisplay_defaultscreens; i++) {\n\t\tif (wsdisplay_addscreen(sc, i, 0, 0))\n\t\t\tbreak;\n}\n\n\tif (i > start) \n\t\twsdisplay_addscreen_print(sc, start, i-start);\n\t\n\tif (hookset == 0)\n\t\tshutdownhook_establish(wsdisplay_shutdownhook, NULL);\n\thookset = 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstatic void wsdisplay_noemul_attach;\nstatic void wsdisplay_common_attach;\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\n\nvoid\nwsdisplay_noemul_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct wsdisplay_softc *sc = (struct wsdisplay_softc *)self;\n\tstruct wsdisplaydev_attach_args *ap = aux;\n\n\twsdisplay_common_attach(sc, 0, NULL, ap->accessops, ap->accesscookie);\n}"
  },
  {
    "function_name": "wsdisplay_noemul_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "551-563",
    "snippet": "int\nwsdisplay_noemul_match(parent, match, aux)\n\tstruct device *parent;\n\tstruct cfdata *match;\n\tvoid *aux;\n{\n#if 0 /* -Wunused */\n\tstruct wsdisplaydev_attach_args *ap = aux;\n#endif\n\n\t/* Always match. */\n\treturn (1);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int wsdisplay_noemul_match"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstatic int wsdisplay_noemul_match;\n\nint\nwsdisplay_noemul_match(parent, match, aux)\n\tstruct device *parent;\n\tstruct cfdata *match;\n\tvoid *aux;\n{\n#if 0 /* -Wunused */\n\tstruct wsdisplaydev_attach_args *ap = aux;\n#endif\n\n\t/* Always match. */\n\treturn (1);\n}"
  },
  {
    "function_name": "wsemuldisplaydevprint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "533-549",
    "snippet": "int\nwsemuldisplaydevprint(aux, pnp)\n\tvoid *aux;\n\tconst char *pnp;\n{\n#if 0 /* -Wunused */\n\tstruct wsemuldisplaydev_attach_args *ap = aux;\n#endif\n\n\tif (pnp)\n\t\tprintf(\"wsdisplay at %s\", pnp);\n#if 0 /* don't bother; it's ugly */\n\tprintf(\" console %d\", ap->console);\n#endif\n\n\treturn (UNCONF);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [
      "#define d ((struct wsmux_device *)data)",
      "#define d ((struct wsdisplay_kbddata *)data)",
      "#define d ((struct wsdisplay_font *)data)",
      "#define d ((struct wsdisplay_delscreendata *)data)",
      "#define d ((struct wsdisplay_addscreendata *)data)",
      "#define d ((struct wsdisplay_usefontdata *)data)",
      "#define d (*(int *)data)"
    ],
    "globals_used": [
      "int console;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" console %d\"",
            "ap->console"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define d ((struct wsmux_device *)data)\n#define d ((struct wsdisplay_kbddata *)data)\n#define d ((struct wsdisplay_font *)data)\n#define d ((struct wsdisplay_delscreendata *)data)\n#define d ((struct wsdisplay_addscreendata *)data)\n#define d ((struct wsdisplay_usefontdata *)data)\n#define d (*(int *)data)\n\nint console;\n\nint\nwsemuldisplaydevprint(aux, pnp)\n\tvoid *aux;\n\tconst char *pnp;\n{\n#if 0 /* -Wunused */\n\tstruct wsemuldisplaydev_attach_args *ap = aux;\n#endif\n\n\tif (pnp)\n\t\tprintf(\"wsdisplay at %s\", pnp);\n#if 0 /* don't bother; it's ugly */\n\tprintf(\" console %d\", ap->console);\n#endif\n\n\treturn (UNCONF);\n}"
  },
  {
    "function_name": "wsdisplay_emul_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "509-530",
    "snippet": "void\nwsdisplay_emul_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct wsdisplay_softc *sc = (struct wsdisplay_softc *)self;\n\tstruct wsemuldisplaydev_attach_args *ap = aux;\n\n\twsdisplay_common_attach(sc, ap->console, ap->scrdata,\n\t\t\t\tap->accessops, ap->accesscookie);\n\n\tif (ap->console) {\n\t\tint maj;\n\n\t\t/* locate the major number */\n\t\tfor (maj = 0; maj < nchrdev; maj++)\n\t\t\tif (cdevsw[maj].d_open == wsdisplayopen)\n\t\t\t\tbreak;\n\n\t\tcn_tab->cn_dev = makedev(maj, WSDISPLAYMINOR(self->dv_unit, 0));\n\t}\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wsdisplay_emul_attach",
      "static void wsdisplay_common_attach",
      "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;",
      "int console;",
      "static const struct wsscreen_descr *\nwsdisplay_screentype_pick(scrdata, name)\n\tconst struct wsscreen_list *scrdata;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "makedev",
          "args": [
            "maj",
            "WSDISPLAYMINOR(self->dv_unit, 0)"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSDISPLAYMINOR",
          "args": [
            "self->dv_unit",
            "0"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsdisplay_common_attach",
          "args": [
            "sc",
            "ap->console",
            "ap->scrdata",
            "ap->accessops",
            "ap->accesscookie"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "wsdisplay_common_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "592-655",
          "snippet": "static void\nwsdisplay_common_attach(sc, console, scrdata, accessops, accesscookie)\n\tstruct wsdisplay_softc *sc;\n\tint console;\n\tconst struct wsscreen_list *scrdata;\n\tconst struct wsdisplay_accessops *accessops;\n\tvoid *accesscookie;\n{\n\tstatic int hookset;\n\tint i, start=0;\n#if NWSKBD > 0\n\tstruct device *dv;\n\n\tsc->sc_muxdv = wsmux_create(\"dmux\", sc->sc_dv.dv_unit);\n\tif (!sc->sc_muxdv)\n\t\tpanic(\"wsdisplay_common_attach: no memory\\n\");\n\tsc->sc_muxdv->sc_displaydv = &sc->sc_dv;\n#endif\n\n\tsc->sc_isconsole = console;\n\n\tif (console) {\n\t\tKASSERT(wsdisplay_console_initted);\n\t\tKASSERT(wsdisplay_console_device == NULL);\n\n\t\tsc->sc_scr[0] = wsscreen_attach(sc, 1, 0, 0, 0, 0, 0, 0);\n\t\twsdisplay_console_device = sc;\n\n\t\tprintf(\": console (%s, %s emulation)\",\n\t\t       wsdisplay_console_conf.scrdata->name,\n\t\t       wsdisplay_console_conf.wsemul->name);\n\n#if NWSKBD > 0\n\t\tif ((dv = wskbd_set_console_display(&sc->sc_dv, sc->sc_muxdv)))\n\t\t\tprintf(\", using %s\", dv->dv_xname);\n#endif\n\n\t\tsc->sc_focusidx = 0;\n\t\tsc->sc_focus = sc->sc_scr[0];\n\t\tstart = 1;\n\t}\n\tprintf(\"\\n\");\n\n\tsc->sc_accessops = accessops;\n\tsc->sc_accesscookie = accesscookie;\n\tsc->sc_scrdata = scrdata;\n\n\t/*\n\t * Set up a number of virtual screens if wanted. The\n\t * WSDISPLAYIO_ADDSCREEN ioctl is more flexible, so this code\n\t * is for special cases like installation kernels.\n\t */\n\tfor (i = start; i < wsdisplay_defaultscreens; i++) {\n\t\tif (wsdisplay_addscreen(sc, i, 0, 0))\n\t\t\tbreak;\n}\n\n\tif (i > start) \n\t\twsdisplay_addscreen_print(sc, start, i-start);\n\t\n\tif (hookset == 0)\n\t\tshutdownhook_establish(wsdisplay_shutdownhook, NULL);\n\thookset = 1;\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct wsscreen *wsscreen_attach",
            "int wsdisplay_addscreen",
            "static void wsdisplay_shutdownhook",
            "static void wsdisplay_addscreen_print",
            "static void wsdisplay_common_attach",
            "static int wsdisplay_console_initted;",
            "static struct wsdisplay_softc *wsdisplay_console_device;",
            "static struct wsscreen_internal wsdisplay_console_conf;",
            "int wsdisplay_defaultscreens = WSDISPLAY_DEFAULTSCREENS;",
            "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;",
            "int console;",
            "static const struct wsscreen_descr *\nwsdisplay_screentype_pick(scrdata, name)\n\tconst struct wsscreen_list *scrdata;",
            "const char *name;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct wsscreen *wsscreen_attach;\nint wsdisplay_addscreen;\nstatic void wsdisplay_shutdownhook;\nstatic void wsdisplay_addscreen_print;\nstatic void wsdisplay_common_attach;\nstatic int wsdisplay_console_initted;\nstatic struct wsdisplay_softc *wsdisplay_console_device;\nstatic struct wsscreen_internal wsdisplay_console_conf;\nint wsdisplay_defaultscreens = WSDISPLAY_DEFAULTSCREENS;\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\nint console;\nstatic const struct wsscreen_descr *\nwsdisplay_screentype_pick(scrdata, name)\n\tconst struct wsscreen_list *scrdata;\nconst char *name;\n\nstatic void\nwsdisplay_common_attach(sc, console, scrdata, accessops, accesscookie)\n\tstruct wsdisplay_softc *sc;\n\tint console;\n\tconst struct wsscreen_list *scrdata;\n\tconst struct wsdisplay_accessops *accessops;\n\tvoid *accesscookie;\n{\n\tstatic int hookset;\n\tint i, start=0;\n#if NWSKBD > 0\n\tstruct device *dv;\n\n\tsc->sc_muxdv = wsmux_create(\"dmux\", sc->sc_dv.dv_unit);\n\tif (!sc->sc_muxdv)\n\t\tpanic(\"wsdisplay_common_attach: no memory\\n\");\n\tsc->sc_muxdv->sc_displaydv = &sc->sc_dv;\n#endif\n\n\tsc->sc_isconsole = console;\n\n\tif (console) {\n\t\tKASSERT(wsdisplay_console_initted);\n\t\tKASSERT(wsdisplay_console_device == NULL);\n\n\t\tsc->sc_scr[0] = wsscreen_attach(sc, 1, 0, 0, 0, 0, 0, 0);\n\t\twsdisplay_console_device = sc;\n\n\t\tprintf(\": console (%s, %s emulation)\",\n\t\t       wsdisplay_console_conf.scrdata->name,\n\t\t       wsdisplay_console_conf.wsemul->name);\n\n#if NWSKBD > 0\n\t\tif ((dv = wskbd_set_console_display(&sc->sc_dv, sc->sc_muxdv)))\n\t\t\tprintf(\", using %s\", dv->dv_xname);\n#endif\n\n\t\tsc->sc_focusidx = 0;\n\t\tsc->sc_focus = sc->sc_scr[0];\n\t\tstart = 1;\n\t}\n\tprintf(\"\\n\");\n\n\tsc->sc_accessops = accessops;\n\tsc->sc_accesscookie = accesscookie;\n\tsc->sc_scrdata = scrdata;\n\n\t/*\n\t * Set up a number of virtual screens if wanted. The\n\t * WSDISPLAYIO_ADDSCREEN ioctl is more flexible, so this code\n\t * is for special cases like installation kernels.\n\t */\n\tfor (i = start; i < wsdisplay_defaultscreens; i++) {\n\t\tif (wsdisplay_addscreen(sc, i, 0, 0))\n\t\t\tbreak;\n}\n\n\tif (i > start) \n\t\twsdisplay_addscreen_print(sc, start, i-start);\n\t\n\tif (hookset == 0)\n\t\tshutdownhook_establish(wsdisplay_shutdownhook, NULL);\n\thookset = 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstatic void wsdisplay_emul_attach;\nstatic void wsdisplay_common_attach;\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\nint console;\nstatic const struct wsscreen_descr *\nwsdisplay_screentype_pick(scrdata, name)\n\tconst struct wsscreen_list *scrdata;\n\nvoid\nwsdisplay_emul_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct wsdisplay_softc *sc = (struct wsdisplay_softc *)self;\n\tstruct wsemuldisplaydev_attach_args *ap = aux;\n\n\twsdisplay_common_attach(sc, ap->console, ap->scrdata,\n\t\t\t\tap->accessops, ap->accesscookie);\n\n\tif (ap->console) {\n\t\tint maj;\n\n\t\t/* locate the major number */\n\t\tfor (maj = 0; maj < nchrdev; maj++)\n\t\t\tif (cdevsw[maj].d_open == wsdisplayopen)\n\t\t\t\tbreak;\n\n\t\tcn_tab->cn_dev = makedev(maj, WSDISPLAYMINOR(self->dv_unit, 0));\n\t}\n}"
  },
  {
    "function_name": "wsdisplay_emul_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "484-507",
    "snippet": "int\nwsdisplay_emul_match(parent, match, aux)\n\tstruct device *parent;\n\tstruct cfdata *match;\n\tvoid *aux;\n{\n\tstruct wsemuldisplaydev_attach_args *ap = aux;\n\n\tif (match->wsemuldisplaydevcf_console !=\n\t    WSEMULDISPLAYDEVCF_CONSOLE_UNK) {\n\t\t/*\n\t\t * If console-ness of device specified, either match\n\t\t * exactly (at high priority), or fail.\n\t\t */\n\t\tif (match->wsemuldisplaydevcf_console != 0 &&\n\t\t    ap->console != 0)\n\t\t\treturn (10);\n\t\telse\n\t\t\treturn (0);\n\t}\n\n\t/* If console-ness unspecified, it wins. */\n\treturn (1);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int wsdisplay_emul_match",
      "int console;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstatic int wsdisplay_emul_match;\nint console;\n\nint\nwsdisplay_emul_match(parent, match, aux)\n\tstruct device *parent;\n\tstruct cfdata *match;\n\tvoid *aux;\n{\n\tstruct wsemuldisplaydev_attach_args *ap = aux;\n\n\tif (match->wsemuldisplaydevcf_console !=\n\t    WSEMULDISPLAYDEVCF_CONSOLE_UNK) {\n\t\t/*\n\t\t * If console-ness of device specified, either match\n\t\t * exactly (at high priority), or fail.\n\t\t */\n\t\tif (match->wsemuldisplaydevcf_console != 0 &&\n\t\t    ap->console != 0)\n\t\t\treturn (10);\n\t\telse\n\t\t\treturn (0);\n\t}\n\n\t/* If console-ness unspecified, it wins. */\n\treturn (1);\n}"
  },
  {
    "function_name": "wsdisplay_delscreen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "425-479",
    "snippet": "int\nwsdisplay_delscreen(sc, idx, flags)\n\tstruct wsdisplay_softc *sc;\n\tint idx, flags;\n{\n\tstruct wsscreen *scr;\n\tint s;\n\tvoid *cookie;\n\n\tif (idx < 0 || idx >= WSDISPLAY_MAXSCREEN)\n\t\treturn (EINVAL);\n\tscr = sc->sc_scr[idx];\n\tif (!scr)\n\t\treturn (ENXIO);\n\n\tif (scr->scr_dconf == &wsdisplay_console_conf ||\n\t    scr->scr_syncops ||\n\t    ((scr->scr_flags & SCR_OPEN) && !(flags & WSDISPLAY_DELSCR_FORCE)))\n\t\treturn(EBUSY);\n\n\twsdisplay_closescreen(sc, scr);\n\n\t/*\n\t * delete pointers, so neither device entries\n\t * nor keyboard input can reference it anymore\n\t */\n\ts = spltty();\n\tif (sc->sc_focus == scr) {\n\t\tsc->sc_focus = 0;\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t\twsdisplay_update_rawkbd(sc, 0);\n#endif\n\t}\n\tsc->sc_scr[idx] = 0;\n\tsplx(s);\n\n\t/*\n\t * Wake up processes waiting for the screen to\n\t * be activated. Sleepers must check whether\n\t * the screen still exists.\n\t */\n\tif (scr->scr_flags & SCR_WAITACTIVE)\n\t\twakeup(scr);\n\n\t/* save a reference to the graphics screen */\n\tcookie = scr->scr_dconf->emulcookie;\n\n\twsscreen_detach(scr);\n\n\t(*sc->sc_accessops->free_screen)(sc->sc_accesscookie,\n\t\t\t\t\t cookie);\n\n\tprintf(\"%s: screen %d deleted\\n\", sc->sc_dv.dv_xname, idx);\n\treturn (0);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [
      "#define d ((struct wsmux_device *)data)",
      "#define d ((struct wsdisplay_kbddata *)data)",
      "#define d ((struct wsdisplay_font *)data)",
      "#define d ((struct wsdisplay_delscreendata *)data)",
      "#define d ((struct wsdisplay_addscreendata *)data)",
      "#define d ((struct wsdisplay_usefontdata *)data)",
      "#define d (*(int *)data)",
      "#define WSDISPLAY_MAXSCREEN 8",
      "#define SCR_WAITACTIVE 2\t/* someone waiting on activation */",
      "#define SCR_OPEN 1\t\t/* is it open? */"
    ],
    "globals_used": [
      "void wsscreen_detach",
      "static void wsdisplay_closescreen",
      "int wsdisplay_delscreen",
      "static struct wsscreen_internal wsdisplay_console_conf;",
      "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;",
      "void *cookie;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: screen %d deleted\\n\"",
            "sc->sc_dv.dv_xname",
            "idx"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc->sc_accesscookie",
            "cookie"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsscreen_detach",
          "args": [
            "scr"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "wsscreen_detach_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "1596-1604",
          "snippet": "int\nwsscreen_detach_sync(scr)\n\tstruct wsscreen *scr;\n{\n\tif (!scr->scr_syncops)\n\t\treturn (EINVAL);\n\tscr->scr_syncops = 0;\n\treturn (0);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nint\nwsscreen_detach_sync(scr)\n\tstruct wsscreen *scr;\n{\n\tif (!scr->scr_syncops)\n\t\treturn (EINVAL);\n\tscr->scr_syncops = 0;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "scr"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsdisplay_update_rawkbd",
          "args": [
            "sc",
            "0"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "wsdisplay_update_rawkbd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "1321-1344",
          "snippet": "int\nwsdisplay_update_rawkbd(sc, scr)\n\tstruct wsdisplay_softc *sc;\n\tstruct wsscreen *scr;\n{\n\tint s, raw, data, error;\n\ts = spltty();\n\n\traw = (scr ? scr->scr_rawkbd : 0);\n\n\tif (scr != sc->sc_focus ||\n\t    sc->sc_rawkbd == raw) {\n\t\tsplx(s);\n\t\treturn (0);\n\t}\n\n\tdata = raw ? WSKBD_RAW : WSKBD_TRANSLATED;\n\terror = wsmux_displayioctl(&sc->sc_muxdv->sc_dv, WSKBDIO_SETMODE,\n\t\t\t\t   (caddr_t)&data, 0, 0);\n\tif (!error)\n\t\tsc->sc_rawkbd = raw;\n\tsplx(s);\n\treturn (error);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\n\nint\nwsdisplay_update_rawkbd(sc, scr)\n\tstruct wsdisplay_softc *sc;\n\tstruct wsscreen *scr;\n{\n\tint s, raw, data, error;\n\ts = spltty();\n\n\traw = (scr ? scr->scr_rawkbd : 0);\n\n\tif (scr != sc->sc_focus ||\n\t    sc->sc_rawkbd == raw) {\n\t\tsplx(s);\n\t\treturn (0);\n\t}\n\n\tdata = raw ? WSKBD_RAW : WSKBD_TRANSLATED;\n\terror = wsmux_displayioctl(&sc->sc_muxdv->sc_dv, WSKBDIO_SETMODE,\n\t\t\t\t   (caddr_t)&data, 0, 0);\n\tif (!error)\n\t\tsc->sc_rawkbd = raw;\n\tsplx(s);\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsdisplay_closescreen",
          "args": [
            "sc",
            "scr"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "wsdisplay_closescreen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "394-423",
          "snippet": "static void\nwsdisplay_closescreen(sc, scr)\n\tstruct wsdisplay_softc *sc;\n\tstruct wsscreen *scr;\n{\n\tint maj, mn, idx;\n\n\t/* hangup */\n\tif (WSSCREEN_HAS_TTY(scr)) {\n\t\tstruct tty *tp = scr->scr_tty;\n\t\t(*linesw[tp->t_line].l_modem)(tp, 0);\n\t}\n\n\t/* locate the major number */\n\tfor (maj = 0; maj < nchrdev; maj++)\n\t\tif (cdevsw[maj].d_open == wsdisplayopen)\n\t\t\tbreak;\n\t/* locate the screen index */\n\tfor (idx = 0; idx < WSDISPLAY_MAXSCREEN; idx++)\n\t\tif (scr == sc->sc_scr[idx])\n\t\t\tbreak;\n#ifdef DIAGNOSTIC\n\tif (idx == WSDISPLAY_MAXSCREEN)\n\t\tpanic(\"wsdisplay_forceclose: bad screen\");\n#endif\n\n\t/* nuke the vnodes */\n\tmn = WSDISPLAYMINOR(sc->sc_dv.dv_unit, idx);\n\tvdevgone(maj, mn, mn, VCHR);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [
            "#define WSDISPLAY_MAXSCREEN 8"
          ],
          "globals_used": [
            "static void wsdisplay_closescreen",
            "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define WSDISPLAY_MAXSCREEN 8\n\nstatic void wsdisplay_closescreen;\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\n\nstatic void\nwsdisplay_closescreen(sc, scr)\n\tstruct wsdisplay_softc *sc;\n\tstruct wsscreen *scr;\n{\n\tint maj, mn, idx;\n\n\t/* hangup */\n\tif (WSSCREEN_HAS_TTY(scr)) {\n\t\tstruct tty *tp = scr->scr_tty;\n\t\t(*linesw[tp->t_line].l_modem)(tp, 0);\n\t}\n\n\t/* locate the major number */\n\tfor (maj = 0; maj < nchrdev; maj++)\n\t\tif (cdevsw[maj].d_open == wsdisplayopen)\n\t\t\tbreak;\n\t/* locate the screen index */\n\tfor (idx = 0; idx < WSDISPLAY_MAXSCREEN; idx++)\n\t\tif (scr == sc->sc_scr[idx])\n\t\t\tbreak;\n#ifdef DIAGNOSTIC\n\tif (idx == WSDISPLAY_MAXSCREEN)\n\t\tpanic(\"wsdisplay_forceclose: bad screen\");\n#endif\n\n\t/* nuke the vnodes */\n\tmn = WSDISPLAYMINOR(sc->sc_dv.dv_unit, idx);\n\tvdevgone(maj, mn, mn, VCHR);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define d ((struct wsmux_device *)data)\n#define d ((struct wsdisplay_kbddata *)data)\n#define d ((struct wsdisplay_font *)data)\n#define d ((struct wsdisplay_delscreendata *)data)\n#define d ((struct wsdisplay_addscreendata *)data)\n#define d ((struct wsdisplay_usefontdata *)data)\n#define d (*(int *)data)\n#define WSDISPLAY_MAXSCREEN 8\n#define SCR_WAITACTIVE 2\t/* someone waiting on activation */\n#define SCR_OPEN 1\t\t/* is it open? */\n\nvoid wsscreen_detach;\nstatic void wsdisplay_closescreen;\nint wsdisplay_delscreen;\nstatic struct wsscreen_internal wsdisplay_console_conf;\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\nvoid *cookie;\n\nint\nwsdisplay_delscreen(sc, idx, flags)\n\tstruct wsdisplay_softc *sc;\n\tint idx, flags;\n{\n\tstruct wsscreen *scr;\n\tint s;\n\tvoid *cookie;\n\n\tif (idx < 0 || idx >= WSDISPLAY_MAXSCREEN)\n\t\treturn (EINVAL);\n\tscr = sc->sc_scr[idx];\n\tif (!scr)\n\t\treturn (ENXIO);\n\n\tif (scr->scr_dconf == &wsdisplay_console_conf ||\n\t    scr->scr_syncops ||\n\t    ((scr->scr_flags & SCR_OPEN) && !(flags & WSDISPLAY_DELSCR_FORCE)))\n\t\treturn(EBUSY);\n\n\twsdisplay_closescreen(sc, scr);\n\n\t/*\n\t * delete pointers, so neither device entries\n\t * nor keyboard input can reference it anymore\n\t */\n\ts = spltty();\n\tif (sc->sc_focus == scr) {\n\t\tsc->sc_focus = 0;\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t\twsdisplay_update_rawkbd(sc, 0);\n#endif\n\t}\n\tsc->sc_scr[idx] = 0;\n\tsplx(s);\n\n\t/*\n\t * Wake up processes waiting for the screen to\n\t * be activated. Sleepers must check whether\n\t * the screen still exists.\n\t */\n\tif (scr->scr_flags & SCR_WAITACTIVE)\n\t\twakeup(scr);\n\n\t/* save a reference to the graphics screen */\n\tcookie = scr->scr_dconf->emulcookie;\n\n\twsscreen_detach(scr);\n\n\t(*sc->sc_accessops->free_screen)(sc->sc_accesscookie,\n\t\t\t\t\t cookie);\n\n\tprintf(\"%s: screen %d deleted\\n\", sc->sc_dv.dv_xname, idx);\n\treturn (0);\n}"
  },
  {
    "function_name": "wsdisplay_closescreen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "394-423",
    "snippet": "static void\nwsdisplay_closescreen(sc, scr)\n\tstruct wsdisplay_softc *sc;\n\tstruct wsscreen *scr;\n{\n\tint maj, mn, idx;\n\n\t/* hangup */\n\tif (WSSCREEN_HAS_TTY(scr)) {\n\t\tstruct tty *tp = scr->scr_tty;\n\t\t(*linesw[tp->t_line].l_modem)(tp, 0);\n\t}\n\n\t/* locate the major number */\n\tfor (maj = 0; maj < nchrdev; maj++)\n\t\tif (cdevsw[maj].d_open == wsdisplayopen)\n\t\t\tbreak;\n\t/* locate the screen index */\n\tfor (idx = 0; idx < WSDISPLAY_MAXSCREEN; idx++)\n\t\tif (scr == sc->sc_scr[idx])\n\t\t\tbreak;\n#ifdef DIAGNOSTIC\n\tif (idx == WSDISPLAY_MAXSCREEN)\n\t\tpanic(\"wsdisplay_forceclose: bad screen\");\n#endif\n\n\t/* nuke the vnodes */\n\tmn = WSDISPLAYMINOR(sc->sc_dv.dv_unit, idx);\n\tvdevgone(maj, mn, mn, VCHR);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [
      "#define WSDISPLAY_MAXSCREEN 8"
    ],
    "globals_used": [
      "static void wsdisplay_closescreen",
      "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vdevgone",
          "args": [
            "maj",
            "mn",
            "mn",
            "VCHR"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSDISPLAYMINOR",
          "args": [
            "sc->sc_dv.dv_unit",
            "idx"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"wsdisplay_forceclose: bad screen\""
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "tp",
            "0"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSSCREEN_HAS_TTY",
          "args": [
            "scr"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define WSDISPLAY_MAXSCREEN 8\n\nstatic void wsdisplay_closescreen;\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\n\nstatic void\nwsdisplay_closescreen(sc, scr)\n\tstruct wsdisplay_softc *sc;\n\tstruct wsscreen *scr;\n{\n\tint maj, mn, idx;\n\n\t/* hangup */\n\tif (WSSCREEN_HAS_TTY(scr)) {\n\t\tstruct tty *tp = scr->scr_tty;\n\t\t(*linesw[tp->t_line].l_modem)(tp, 0);\n\t}\n\n\t/* locate the major number */\n\tfor (maj = 0; maj < nchrdev; maj++)\n\t\tif (cdevsw[maj].d_open == wsdisplayopen)\n\t\t\tbreak;\n\t/* locate the screen index */\n\tfor (idx = 0; idx < WSDISPLAY_MAXSCREEN; idx++)\n\t\tif (scr == sc->sc_scr[idx])\n\t\t\tbreak;\n#ifdef DIAGNOSTIC\n\tif (idx == WSDISPLAY_MAXSCREEN)\n\t\tpanic(\"wsdisplay_forceclose: bad screen\");\n#endif\n\n\t/* nuke the vnodes */\n\tmn = WSDISPLAYMINOR(sc->sc_dv.dv_unit, idx);\n\tvdevgone(maj, mn, mn, VCHR);\n}"
  },
  {
    "function_name": "wsdisplay_addscreen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "344-392",
    "snippet": "int\nwsdisplay_addscreen(sc, idx, screentype, emul)\n\tstruct wsdisplay_softc *sc;\n\tint idx;\n\tconst char *screentype, *emul;\n{\n\tconst struct wsscreen_descr *scrdesc;\n\tint error;\n\tvoid *cookie;\n\tint ccol, crow;\n\tlong defattr;\n\tstruct wsscreen *scr;\n\tint s;\n\n\tif (idx < 0 || idx >= WSDISPLAY_MAXSCREEN)\n\t\treturn (EINVAL);\n\tif (sc->sc_scr[idx] != NULL)\n\t\treturn (EBUSY);\n\n\tscrdesc = wsdisplay_screentype_pick(sc->sc_scrdata, screentype);\n\tif (!scrdesc)\n\t\treturn (ENXIO);\n\terror = (*sc->sc_accessops->alloc_screen)(sc->sc_accesscookie,\n\t\t\tscrdesc, &cookie, &ccol, &crow, &defattr);\n\tif (error)\n\t\treturn (error);\n\n\tscr = wsscreen_attach(sc, 0, emul, scrdesc,\n\t\t\t      cookie, ccol, crow, defattr);\n\tif (scr == NULL) {\n\t\t(*sc->sc_accessops->free_screen)(sc->sc_accesscookie,\n\t\t\t\t\t\t cookie);\n\t\treturn (ENXIO);\n\t}\n\n\tsc->sc_scr[idx] = scr;\n\n\t/* if no screen has focus yet, activate the first we get */\n\ts = spltty();\n\tif (!sc->sc_focus) {\n\t\t(*sc->sc_accessops->show_screen)(sc->sc_accesscookie,\n\t\t\t\t\t\t scr->scr_dconf->emulcookie,\n\t\t\t\t\t\t 0, 0, 0);\n\t\tsc->sc_focusidx = idx;\n\t\tsc->sc_focus = scr;\n\t}\n\tsplx(s);\n\treturn (0);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [
      "#define WSDISPLAY_MAXSCREEN 8"
    ],
    "globals_used": [
      "struct wsscreen *wsscreen_attach",
      "static const struct wsscreen_descr *\nwsdisplay_screentype_pick",
      "int wsdisplay_addscreen",
      "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;",
      "const char *emul;",
      "void *cookie;",
      "int ccol, crow;",
      "long defattr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc->sc_accesscookie",
            "scr->scr_dconf->emulcookie",
            "0",
            "0",
            "0"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc->sc_accesscookie",
            "cookie"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsscreen_attach",
          "args": [
            "sc",
            "0",
            "emul",
            "scrdesc",
            "cookie",
            "ccol",
            "crow",
            "defattr"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "wsscreen_attach_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "1577-1594",
          "snippet": "int\nwsscreen_attach_sync(scr, ops, cookie)\n\tstruct wsscreen *scr;\n\tconst struct wscons_syncops *ops;\n\tvoid *cookie;\n{\n\tif (scr->scr_syncops) {\n\t\t/*\n\t\t * The screen is already claimed.\n\t\t * Check if the owner is still alive.\n\t\t */\n\t\tif ((*scr->scr_syncops->check)(scr->scr_synccookie))\n\t\t\treturn (EBUSY);\n\t}\n\tscr->scr_syncops = ops;\n\tscr->scr_synccookie = cookie;\n\treturn (0);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *cookie;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nvoid *cookie;\n\nint\nwsscreen_attach_sync(scr, ops, cookie)\n\tstruct wsscreen *scr;\n\tconst struct wscons_syncops *ops;\n\tvoid *cookie;\n{\n\tif (scr->scr_syncops) {\n\t\t/*\n\t\t * The screen is already claimed.\n\t\t * Check if the owner is still alive.\n\t\t */\n\t\tif ((*scr->scr_syncops->check)(scr->scr_synccookie))\n\t\t\treturn (EBUSY);\n\t}\n\tscr->scr_syncops = ops;\n\tscr->scr_synccookie = cookie;\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc->sc_accesscookie",
            "scrdesc",
            "&cookie",
            "&ccol",
            "&crow",
            "&defattr"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsdisplay_screentype_pick",
          "args": [
            "sc->sc_scrdata",
            "screentype"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define WSDISPLAY_MAXSCREEN 8\n\nstruct wsscreen *wsscreen_attach;\nstatic const struct wsscreen_descr *\nwsdisplay_screentype_pick;\nint wsdisplay_addscreen;\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\nconst char *emul;\nvoid *cookie;\nint ccol, crow;\nlong defattr;\n\nint\nwsdisplay_addscreen(sc, idx, screentype, emul)\n\tstruct wsdisplay_softc *sc;\n\tint idx;\n\tconst char *screentype, *emul;\n{\n\tconst struct wsscreen_descr *scrdesc;\n\tint error;\n\tvoid *cookie;\n\tint ccol, crow;\n\tlong defattr;\n\tstruct wsscreen *scr;\n\tint s;\n\n\tif (idx < 0 || idx >= WSDISPLAY_MAXSCREEN)\n\t\treturn (EINVAL);\n\tif (sc->sc_scr[idx] != NULL)\n\t\treturn (EBUSY);\n\n\tscrdesc = wsdisplay_screentype_pick(sc->sc_scrdata, screentype);\n\tif (!scrdesc)\n\t\treturn (ENXIO);\n\terror = (*sc->sc_accessops->alloc_screen)(sc->sc_accesscookie,\n\t\t\tscrdesc, &cookie, &ccol, &crow, &defattr);\n\tif (error)\n\t\treturn (error);\n\n\tscr = wsscreen_attach(sc, 0, emul, scrdesc,\n\t\t\t      cookie, ccol, crow, defattr);\n\tif (scr == NULL) {\n\t\t(*sc->sc_accessops->free_screen)(sc->sc_accesscookie,\n\t\t\t\t\t\t cookie);\n\t\treturn (ENXIO);\n\t}\n\n\tsc->sc_scr[idx] = scr;\n\n\t/* if no screen has focus yet, activate the first we get */\n\ts = spltty();\n\tif (!sc->sc_focus) {\n\t\t(*sc->sc_accessops->show_screen)(sc->sc_accesscookie,\n\t\t\t\t\t\t scr->scr_dconf->emulcookie,\n\t\t\t\t\t\t 0, 0, 0);\n\t\tsc->sc_focusidx = idx;\n\t\tsc->sc_focus = scr;\n\t}\n\tsplx(s);\n\treturn (0);\n}"
  },
  {
    "function_name": "wsdisplay_addscreen_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "328-342",
    "snippet": "static void\nwsdisplay_addscreen_print(sc, idx, count)\n\tstruct wsdisplay_softc *sc;\n\tint idx, count;\n{\n\tprintf(\"%s: screen %d\", sc->sc_dv.dv_xname, idx);\n\tif (count > 1)\n\t\tprintf(\"-%d\", idx + (count-1));\n\tprintf(\" added (%s\", sc->sc_scr[idx]->scr_dconf->scrdata->name);\n\tif (WSSCREEN_HAS_EMULATOR(sc->sc_scr[idx])) {\n\t\tprintf(\", %s emulation\",\n\t\t\tsc->sc_scr[idx]->scr_dconf->wsemul->name);\n\t}\n\tprintf(\")\\n\");\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [
      "#define d ((struct wsmux_device *)data)",
      "#define d ((struct wsdisplay_kbddata *)data)",
      "#define d ((struct wsdisplay_font *)data)",
      "#define d ((struct wsdisplay_delscreendata *)data)",
      "#define d ((struct wsdisplay_addscreendata *)data)",
      "#define d ((struct wsdisplay_usefontdata *)data)",
      "#define d (*(int *)data)"
    ],
    "globals_used": [
      "static void wsdisplay_addscreen_print",
      "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;",
      "static const struct wsscreen_descr *\nwsdisplay_screentype_pick(scrdata, name)\n\tconst struct wsscreen_list *scrdata;",
      "const char *name;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\")\\n\""
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WSSCREEN_HAS_EMULATOR",
          "args": [
            "sc->sc_scr[idx]"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define d ((struct wsmux_device *)data)\n#define d ((struct wsdisplay_kbddata *)data)\n#define d ((struct wsdisplay_font *)data)\n#define d ((struct wsdisplay_delscreendata *)data)\n#define d ((struct wsdisplay_addscreendata *)data)\n#define d ((struct wsdisplay_usefontdata *)data)\n#define d (*(int *)data)\n\nstatic void wsdisplay_addscreen_print;\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\nstatic const struct wsscreen_descr *\nwsdisplay_screentype_pick(scrdata, name)\n\tconst struct wsscreen_list *scrdata;\nconst char *name;\n\nstatic void\nwsdisplay_addscreen_print(sc, idx, count)\n\tstruct wsdisplay_softc *sc;\n\tint idx, count;\n{\n\tprintf(\"%s: screen %d\", sc->sc_dv.dv_xname, idx);\n\tif (count > 1)\n\t\tprintf(\"-%d\", idx + (count-1));\n\tprintf(\" added (%s\", sc->sc_scr[idx]->scr_dconf->scrdata->name);\n\tif (WSSCREEN_HAS_EMULATOR(sc->sc_scr[idx])) {\n\t\tprintf(\", %s emulation\",\n\t\t\tsc->sc_scr[idx]->scr_dconf->wsemul->name);\n\t}\n\tprintf(\")\\n\");\n}"
  },
  {
    "function_name": "wsscreen_detach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
    "lines": "286-301",
    "snippet": "void\nwsscreen_detach(scr)\n\tstruct wsscreen *scr;\n{\n\tint ccol, crow; /* XXX */\n\n\tif (WSSCREEN_HAS_TTY(scr)) {\n\t\ttty_detach(scr->scr_tty);\n\t\tttyfree(scr->scr_tty);\n\t}\n\tif (WSSCREEN_HAS_EMULATOR(scr))\n\t\t(*scr->scr_dconf->wsemul->detach)(scr->scr_dconf->wsemulcookie,\n\t\t\t\t\t\t  &ccol, &crow);\n\tfree(scr->scr_dconf, M_DEVBUF);\n\tfree(scr, M_DEVBUF);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wskbd.h\"",
      "#include <dev/cons.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wsemulvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsdisplayvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/malloc.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void wsscreen_detach",
      "int ccol, crow;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "scr",
            "M_DEVBUF"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "wskbd_pickfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
          "lines": "1057-1070",
          "snippet": "int\nwskbd_pickfree()\n{\n\tint i;\n\tstruct wskbd_softc *sc;\n\n\tfor (i = 0; i < wskbd_cd.cd_ndevs; i++) {\n\t\tif ((sc = wskbd_cd.cd_devs[i]) == NULL)\n\t\t\tcontinue;\n\t\tif (sc->sc_displaydv == NULL)\n\t\t\treturn (i);\n\t}\n\treturn (-1);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wsdisplay.h\"",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wskbdvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/malloc.h>",
            "#include <sys/timeout.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cfdriver wskbd_cd = {\n\tNULL, \"wskbd\", DV_TTY\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct cfdriver wskbd_cd = {\n\tNULL, \"wskbd\", DV_TTY\n};\n\nint\nwskbd_pickfree()\n{\n\tint i;\n\tstruct wskbd_softc *sc;\n\n\tfor (i = 0; i < wskbd_cd.cd_ndevs; i++) {\n\t\tif ((sc = wskbd_cd.cd_devs[i]) == NULL)\n\t\t\tcontinue;\n\t\tif (sc->sc_displaydv == NULL)\n\t\t\treturn (i);\n\t}\n\treturn (-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "scr->scr_dconf->wsemulcookie",
            "&ccol",
            "&crow"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSSCREEN_HAS_EMULATOR",
          "args": [
            "scr"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ttyfree",
          "args": [
            "scr->scr_tty"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tty_detach",
          "args": [
            "scr->scr_tty"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSSCREEN_HAS_TTY",
          "args": [
            "scr"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nvoid wsscreen_detach;\nint ccol, crow;\n\nvoid\nwsscreen_detach(scr)\n\tstruct wsscreen *scr;\n{\n\tint ccol, crow; /* XXX */\n\n\tif (WSSCREEN_HAS_TTY(scr)) {\n\t\ttty_detach(scr->scr_tty);\n\t\tttyfree(scr->scr_tty);\n\t}\n\tif (WSSCREEN_HAS_EMULATOR(scr))\n\t\t(*scr->scr_dconf->wsemul->detach)(scr->scr_dconf->wsemulcookie,\n\t\t\t\t\t\t  &ccol, &crow);\n\tfree(scr->scr_dconf, M_DEVBUF);\n\tfree(scr, M_DEVBUF);\n}"
  }
]