[
  {
    "function_name": "lptioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/lpt.c",
    "lines": "422-438",
    "snippet": "int\nlptioctl(dev, cmd, data, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tint error = 0;\n\n\tswitch (cmd) {\n\tdefault:\n\t\terror = ENODEV;\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"lpt.h\"",
      "#include <dev/ic/lptvar.h>",
      "#include <dev/ic/lptreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/syslog.h>",
      "#include <sys/conf.h>",
      "#include <sys/device.h>",
      "#include <sys/uio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"lpt.h\"\n#include <dev/ic/lptvar.h>\n#include <dev/ic/lptreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/syslog.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/uio.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nlptioctl(dev, cmd, data, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tint error = 0;\n\n\tswitch (cmd) {\n\tdefault:\n\t\terror = ENODEV;\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "lptintr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/lpt.c",
    "lines": "386-420",
    "snippet": "int\nlptintr(arg)\n\tvoid *arg;\n{\n\tstruct lpt_softc *sc = arg;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tif (((sc->sc_state & LPT_OPEN) == 0 && sc->sc_count == 0) ||\n\t    (sc->sc_flags & LPT_NOINTR))\n\t\treturn 0;\n\n\t/* is printer online and ready for output */\n\tif (NOT_READY() && NOT_READY_ERR())\n\t\treturn -1;\n\n\tif (sc->sc_count) {\n\t\tu_int8_t control = sc->sc_control;\n\t\t/* send char */\n\t\tbus_space_write_1(iot, ioh, lpt_data, *sc->sc_cp++);\n\t\tdelay (50);\n\t\tbus_space_write_1(iot, ioh, lpt_control, control | LPC_STROBE);\n\t\tsc->sc_count--;\n\t\tbus_space_write_1(iot, ioh, lpt_control, control);\n\t\tsc->sc_state |= LPT_OBUSY;\n\t} else\n\t\tsc->sc_state &= ~LPT_OBUSY;\n\n\tif (sc->sc_count == 0) {\n\t\t/* none, wake up the top half to get more */\n\t\twakeup((caddr_t)sc);\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"lpt.h\"",
      "#include <dev/ic/lptvar.h>",
      "#include <dev/ic/lptreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/syslog.h>",
      "#include <sys/conf.h>",
      "#include <sys/device.h>",
      "#include <sys/uio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "(caddr_t)sc"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "lptwakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/lpt.c",
          "lines": "243-255",
          "snippet": "void\nlptwakeup(arg)\n\tvoid *arg;\n{\n\tstruct lpt_softc *sc = arg;\n\tint s;\n\n\ts = spltty();\n\tlptintr(sc);\n\tsplx(s);\n\n\ttimeout(lptwakeup, sc, STEP);\n}",
          "includes": [
            "#include \"lpt.h\"",
            "#include <dev/ic/lptvar.h>",
            "#include <dev/ic/lptreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/syslog.h>",
            "#include <sys/conf.h>",
            "#include <sys/device.h>",
            "#include <sys/uio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tSTEP\t\thz/4"
          ],
          "globals_used": [
            "void\tlptwakeup"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lpt.h\"\n#include <dev/ic/lptvar.h>\n#include <dev/ic/lptreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/syslog.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/uio.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tSTEP\t\thz/4\n\nvoid\tlptwakeup;\n\nvoid\nlptwakeup(arg)\n\tvoid *arg;\n{\n\tstruct lpt_softc *sc = arg;\n\tint s;\n\n\ts = spltty();\n\tlptintr(sc);\n\tsplx(s);\n\n\ttimeout(lptwakeup, sc, STEP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "lpt_control",
            "control"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "lpt_control",
            "control | LPC_STROBE"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "50"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "lpt_data",
            "*sc->sc_cp++"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NOT_READY_ERR",
          "args": [],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NOT_READY",
          "args": [],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lpt.h\"\n#include <dev/ic/lptvar.h>\n#include <dev/ic/lptreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/syslog.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/uio.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nlptintr(arg)\n\tvoid *arg;\n{\n\tstruct lpt_softc *sc = arg;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tif (((sc->sc_state & LPT_OPEN) == 0 && sc->sc_count == 0) ||\n\t    (sc->sc_flags & LPT_NOINTR))\n\t\treturn 0;\n\n\t/* is printer online and ready for output */\n\tif (NOT_READY() && NOT_READY_ERR())\n\t\treturn -1;\n\n\tif (sc->sc_count) {\n\t\tu_int8_t control = sc->sc_control;\n\t\t/* send char */\n\t\tbus_space_write_1(iot, ioh, lpt_data, *sc->sc_cp++);\n\t\tdelay (50);\n\t\tbus_space_write_1(iot, ioh, lpt_control, control | LPC_STROBE);\n\t\tsc->sc_count--;\n\t\tbus_space_write_1(iot, ioh, lpt_control, control);\n\t\tsc->sc_state |= LPT_OBUSY;\n\t} else\n\t\tsc->sc_state &= ~LPT_OBUSY;\n\n\tif (sc->sc_count == 0) {\n\t\t/* none, wake up the top half to get more */\n\t\twakeup((caddr_t)sc);\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "lptwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/lpt.c",
    "lines": "355-380",
    "snippet": "int\nlptwrite(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\tstruct lpt_softc *sc = lpt_cd.cd_devs[LPTUNIT(dev)];\n\tsize_t n;\n\tint error = 0;\n\n\twhile ((n = min(LPT_BSIZE, uio->uio_resid)) != 0) {\n\t\tuiomove(sc->sc_cp = sc->sc_inbuf->b_data, n, uio);\n\t\tsc->sc_count = n;\n\t\terror = lptpushbytes(sc);\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * Return accurate residual if interrupted or timed\n\t\t\t * out.\n\t\t\t */\n\t\t\tuio->uio_resid += sc->sc_count;\n\t\t\tsc->sc_count = 0;\n\t\t\treturn error;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"lpt.h\"",
      "#include <dev/ic/lptvar.h>",
      "#include <dev/ic/lptreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/syslog.h>",
      "#include <sys/conf.h>",
      "#include <sys/device.h>",
      "#include <sys/uio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tLPT_BSIZE\t1024"
    ],
    "globals_used": [
      "struct cfdriver lpt_cd = {\n\tNULL, \"lpt\", DV_TTY\n};",
      "int\tlptpushbytes"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lptpushbytes",
          "args": [
            "sc"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "lptpushbytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/lpt.c",
          "lines": "287-349",
          "snippet": "int\nlptpushbytes(sc)\n\tstruct lpt_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint error;\n\n\tif (sc->sc_flags & LPT_NOINTR) {\n\t\tint spin, tic;\n\t\tu_int8_t control = sc->sc_control;\n\n\t\twhile (sc->sc_count > 0) {\n\t\t\tspin = 0;\n\t\t\twhile (NOT_READY()) {\n\t\t\t\tif (++spin < sc->sc_spinmax)\n\t\t\t\t\tcontinue;\n\t\t\t\ttic = 0;\n\t\t\t\t/* adapt busy-wait algorithm */\n\t\t\t\tsc->sc_spinmax++;\n\t\t\t\twhile (NOT_READY_ERR()) {\n\t\t\t\t\t/* exponential backoff */\n\t\t\t\t\ttic = tic + tic + 1;\n\t\t\t\t\tif (tic > TIMEOUT)\n\t\t\t\t\t\ttic = TIMEOUT;\n\t\t\t\t\terror = tsleep((caddr_t)sc,\n\t\t\t\t\t    LPTPRI | PCATCH, \"lptpsh\", tic);\n\t\t\t\t\tif (error != EWOULDBLOCK)\n\t\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbus_space_write_1(iot, ioh, lpt_data, *sc->sc_cp++);\n\t\t\tbus_space_write_1(iot, ioh, lpt_control,\n\t\t\t    control | LPC_STROBE);\n\t\t\tsc->sc_count--;\n\t\t\tbus_space_write_1(iot, ioh, lpt_control, control);\n\n\t\t\t/* adapt busy-wait algorithm */\n\t\t\tif (spin*2 + 16 < sc->sc_spinmax)\n\t\t\t\tsc->sc_spinmax--;\n\t\t}\n\t} else {\n\t\tint s;\n\n\t\twhile (sc->sc_count > 0) {\n\t\t\t/* if the printer is ready for a char, give it one */\n\t\t\tif ((sc->sc_state & LPT_OBUSY) == 0) {\n\t\t\t\tLPRINTF((\"%s: write %d\\n\", sc->sc_dev.dv_xname,\n\t\t\t\t    sc->sc_count));\n\t\t\t\ts = spltty();\n\t\t\t\t(void) lptintr(sc);\n\t\t\t\tsplx(s);\n\t\t\t}\n\t\t\terror = tsleep((caddr_t)sc, LPTPRI | PCATCH,\n\t\t\t    \"lptwrite2\", 0);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"lpt.h\"",
            "#include <dev/ic/lptvar.h>",
            "#include <dev/ic/lptreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/syslog.h>",
            "#include <sys/conf.h>",
            "#include <sys/device.h>",
            "#include <sys/uio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tLPTPRI\t\t(PZERO+8)",
            "#define\tTIMEOUT\t\thz*16\t/* wait up to 16 seconds for a ready */"
          ],
          "globals_used": [
            "int\tlptpushbytes"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lpt.h\"\n#include <dev/ic/lptvar.h>\n#include <dev/ic/lptreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/syslog.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/uio.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tLPTPRI\t\t(PZERO+8)\n#define\tTIMEOUT\t\thz*16\t/* wait up to 16 seconds for a ready */\n\nint\tlptpushbytes;\n\nint\nlptpushbytes(sc)\n\tstruct lpt_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint error;\n\n\tif (sc->sc_flags & LPT_NOINTR) {\n\t\tint spin, tic;\n\t\tu_int8_t control = sc->sc_control;\n\n\t\twhile (sc->sc_count > 0) {\n\t\t\tspin = 0;\n\t\t\twhile (NOT_READY()) {\n\t\t\t\tif (++spin < sc->sc_spinmax)\n\t\t\t\t\tcontinue;\n\t\t\t\ttic = 0;\n\t\t\t\t/* adapt busy-wait algorithm */\n\t\t\t\tsc->sc_spinmax++;\n\t\t\t\twhile (NOT_READY_ERR()) {\n\t\t\t\t\t/* exponential backoff */\n\t\t\t\t\ttic = tic + tic + 1;\n\t\t\t\t\tif (tic > TIMEOUT)\n\t\t\t\t\t\ttic = TIMEOUT;\n\t\t\t\t\terror = tsleep((caddr_t)sc,\n\t\t\t\t\t    LPTPRI | PCATCH, \"lptpsh\", tic);\n\t\t\t\t\tif (error != EWOULDBLOCK)\n\t\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbus_space_write_1(iot, ioh, lpt_data, *sc->sc_cp++);\n\t\t\tbus_space_write_1(iot, ioh, lpt_control,\n\t\t\t    control | LPC_STROBE);\n\t\t\tsc->sc_count--;\n\t\t\tbus_space_write_1(iot, ioh, lpt_control, control);\n\n\t\t\t/* adapt busy-wait algorithm */\n\t\t\tif (spin*2 + 16 < sc->sc_spinmax)\n\t\t\t\tsc->sc_spinmax--;\n\t\t}\n\t} else {\n\t\tint s;\n\n\t\twhile (sc->sc_count > 0) {\n\t\t\t/* if the printer is ready for a char, give it one */\n\t\t\tif ((sc->sc_state & LPT_OBUSY) == 0) {\n\t\t\t\tLPRINTF((\"%s: write %d\\n\", sc->sc_dev.dv_xname,\n\t\t\t\t    sc->sc_count));\n\t\t\t\ts = spltty();\n\t\t\t\t(void) lptintr(sc);\n\t\t\t\tsplx(s);\n\t\t\t}\n\t\t\terror = tsleep((caddr_t)sc, LPTPRI | PCATCH,\n\t\t\t    \"lptwrite2\", 0);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uiomove",
          "args": [
            "sc->sc_cp = sc->sc_inbuf->b_data",
            "n",
            "uio"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "LPT_BSIZE",
            "uio->uio_resid"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "am7990_meminit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/am7990.c",
          "lines": "231-295",
          "snippet": "void\nam7990_meminit(sc)\n\tregister struct am7990_softc *sc;\n{\n\tu_long a;\n\tint bix;\n\tstruct leinit init;\n\tstruct lermd rmd;\n\tstruct letmd tmd;\n\n#if NBPFILTER > 0\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tinit.init_mode = LE_MODE_NORMAL | LE_MODE_PROM;\n\telse\n#endif\n\t\tinit.init_mode = LE_MODE_NORMAL;\n\tinit.init_padr[0] =\n\t    (sc->sc_arpcom.ac_enaddr[1] << 8) | sc->sc_arpcom.ac_enaddr[0];\n\tinit.init_padr[1] =\n\t    (sc->sc_arpcom.ac_enaddr[3] << 8) | sc->sc_arpcom.ac_enaddr[2];\n\tinit.init_padr[2] =\n\t    (sc->sc_arpcom.ac_enaddr[5] << 8) | sc->sc_arpcom.ac_enaddr[4];\n\tam7990_setladrf(&sc->sc_arpcom, init.init_ladrf);\n\n\tsc->sc_last_rd = 0;\n\tsc->sc_first_td = sc->sc_last_td = sc->sc_no_td = 0;\n\n\ta = sc->sc_addr + LE_RMDADDR(sc, 0);\n\tinit.init_rdra = a;\n\tinit.init_rlen = (a >> 16) | ((ffs(sc->sc_nrbuf) - 1) << 13);\n\n\ta = sc->sc_addr + LE_TMDADDR(sc, 0);\n\tinit.init_tdra = a;\n\tinit.init_tlen = (a >> 16) | ((ffs(sc->sc_ntbuf) - 1) << 13);\n\n\t(*sc->sc_copytodesc)(sc, &init, LE_INITADDR(sc), sizeof(init));\n\n\t/*\n\t * Set up receive ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_nrbuf; bix++) {\n\t\ta = sc->sc_addr + LE_RBUFADDR(sc, bix);\n\t\trmd.rmd0 = a;\n\t\trmd.rmd1_hadr = a >> 16;\n\t\trmd.rmd1_bits = LE_R1_OWN;\n\t\trmd.rmd2 = -LEBLEN | LE_XMD2_ONES;\n\t\trmd.rmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &rmd, LE_RMDADDR(sc, bix),\n\t\t    sizeof(rmd));\n\t}\n\n\t/*\n\t * Set up transmit ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_ntbuf; bix++) {\n\t\ta = sc->sc_addr + LE_TBUFADDR(sc, bix);\n\t\ttmd.tmd0 = a;\n\t\ttmd.tmd1_hadr = a >> 16;\n\t\ttmd.tmd1_bits = 0;\n\t\ttmd.tmd2 = 0 | LE_XMD2_ONES;\n\t\ttmd.tmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &tmd, LE_TMDADDR(sc, bix),\n\t\t    sizeof(tmd));\n\t}\n}",
          "includes": [
            "#include <dev/ic/am7990var.h>",
            "#include <dev/ic/am7990reg.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/syslog.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tifp\t(&sc->sc_arpcom.ac_if)"
          ],
          "globals_used": [
            "am7990_rint __P((struct am7990_softc *));",
            "am7990_tint __P((struct am7990_softc *));",
            "integrate struct",
            "integrate struct",
            "mbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/am7990var.h>\n#include <dev/ic/am7990reg.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/syslog.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tifp\t(&sc->sc_arpcom.ac_if)\n\nam7990_rint __P((struct am7990_softc *));\nam7990_tint __P((struct am7990_softc *));\nintegrate struct;\nintegrate struct;\nmbuf *\nam7990_get(sc, boff, totlen)\n\tstruct am7990_softc *sc;\n\nvoid\nam7990_meminit(sc)\n\tregister struct am7990_softc *sc;\n{\n\tu_long a;\n\tint bix;\n\tstruct leinit init;\n\tstruct lermd rmd;\n\tstruct letmd tmd;\n\n#if NBPFILTER > 0\n\tif (ifp->if_flags & IFF_PROMISC)\n\t\tinit.init_mode = LE_MODE_NORMAL | LE_MODE_PROM;\n\telse\n#endif\n\t\tinit.init_mode = LE_MODE_NORMAL;\n\tinit.init_padr[0] =\n\t    (sc->sc_arpcom.ac_enaddr[1] << 8) | sc->sc_arpcom.ac_enaddr[0];\n\tinit.init_padr[1] =\n\t    (sc->sc_arpcom.ac_enaddr[3] << 8) | sc->sc_arpcom.ac_enaddr[2];\n\tinit.init_padr[2] =\n\t    (sc->sc_arpcom.ac_enaddr[5] << 8) | sc->sc_arpcom.ac_enaddr[4];\n\tam7990_setladrf(&sc->sc_arpcom, init.init_ladrf);\n\n\tsc->sc_last_rd = 0;\n\tsc->sc_first_td = sc->sc_last_td = sc->sc_no_td = 0;\n\n\ta = sc->sc_addr + LE_RMDADDR(sc, 0);\n\tinit.init_rdra = a;\n\tinit.init_rlen = (a >> 16) | ((ffs(sc->sc_nrbuf) - 1) << 13);\n\n\ta = sc->sc_addr + LE_TMDADDR(sc, 0);\n\tinit.init_tdra = a;\n\tinit.init_tlen = (a >> 16) | ((ffs(sc->sc_ntbuf) - 1) << 13);\n\n\t(*sc->sc_copytodesc)(sc, &init, LE_INITADDR(sc), sizeof(init));\n\n\t/*\n\t * Set up receive ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_nrbuf; bix++) {\n\t\ta = sc->sc_addr + LE_RBUFADDR(sc, bix);\n\t\trmd.rmd0 = a;\n\t\trmd.rmd1_hadr = a >> 16;\n\t\trmd.rmd1_bits = LE_R1_OWN;\n\t\trmd.rmd2 = -LEBLEN | LE_XMD2_ONES;\n\t\trmd.rmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &rmd, LE_RMDADDR(sc, bix),\n\t\t    sizeof(rmd));\n\t}\n\n\t/*\n\t * Set up transmit ring descriptors.\n\t */\n\tfor (bix = 0; bix < sc->sc_ntbuf; bix++) {\n\t\ta = sc->sc_addr + LE_TBUFADDR(sc, bix);\n\t\ttmd.tmd0 = a;\n\t\ttmd.tmd1_hadr = a >> 16;\n\t\ttmd.tmd1_bits = 0;\n\t\ttmd.tmd2 = 0 | LE_XMD2_ONES;\n\t\ttmd.tmd3 = 0;\n\t\t(*sc->sc_copytodesc)(sc, &tmd, LE_TMDADDR(sc, bix),\n\t\t    sizeof(tmd));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "LPTUNIT",
          "args": [
            "dev"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lpt.h\"\n#include <dev/ic/lptvar.h>\n#include <dev/ic/lptreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/syslog.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/uio.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tLPT_BSIZE\t1024\n\nstruct cfdriver lpt_cd = {\n\tNULL, \"lpt\", DV_TTY\n};\nint\tlptpushbytes;\n\nint\nlptwrite(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\tstruct lpt_softc *sc = lpt_cd.cd_devs[LPTUNIT(dev)];\n\tsize_t n;\n\tint error = 0;\n\n\twhile ((n = min(LPT_BSIZE, uio->uio_resid)) != 0) {\n\t\tuiomove(sc->sc_cp = sc->sc_inbuf->b_data, n, uio);\n\t\tsc->sc_count = n;\n\t\terror = lptpushbytes(sc);\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * Return accurate residual if interrupted or timed\n\t\t\t * out.\n\t\t\t */\n\t\t\tuio->uio_resid += sc->sc_count;\n\t\t\tsc->sc_count = 0;\n\t\t\treturn error;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "lptpushbytes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/lpt.c",
    "lines": "287-349",
    "snippet": "int\nlptpushbytes(sc)\n\tstruct lpt_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint error;\n\n\tif (sc->sc_flags & LPT_NOINTR) {\n\t\tint spin, tic;\n\t\tu_int8_t control = sc->sc_control;\n\n\t\twhile (sc->sc_count > 0) {\n\t\t\tspin = 0;\n\t\t\twhile (NOT_READY()) {\n\t\t\t\tif (++spin < sc->sc_spinmax)\n\t\t\t\t\tcontinue;\n\t\t\t\ttic = 0;\n\t\t\t\t/* adapt busy-wait algorithm */\n\t\t\t\tsc->sc_spinmax++;\n\t\t\t\twhile (NOT_READY_ERR()) {\n\t\t\t\t\t/* exponential backoff */\n\t\t\t\t\ttic = tic + tic + 1;\n\t\t\t\t\tif (tic > TIMEOUT)\n\t\t\t\t\t\ttic = TIMEOUT;\n\t\t\t\t\terror = tsleep((caddr_t)sc,\n\t\t\t\t\t    LPTPRI | PCATCH, \"lptpsh\", tic);\n\t\t\t\t\tif (error != EWOULDBLOCK)\n\t\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbus_space_write_1(iot, ioh, lpt_data, *sc->sc_cp++);\n\t\t\tbus_space_write_1(iot, ioh, lpt_control,\n\t\t\t    control | LPC_STROBE);\n\t\t\tsc->sc_count--;\n\t\t\tbus_space_write_1(iot, ioh, lpt_control, control);\n\n\t\t\t/* adapt busy-wait algorithm */\n\t\t\tif (spin*2 + 16 < sc->sc_spinmax)\n\t\t\t\tsc->sc_spinmax--;\n\t\t}\n\t} else {\n\t\tint s;\n\n\t\twhile (sc->sc_count > 0) {\n\t\t\t/* if the printer is ready for a char, give it one */\n\t\t\tif ((sc->sc_state & LPT_OBUSY) == 0) {\n\t\t\t\tLPRINTF((\"%s: write %d\\n\", sc->sc_dev.dv_xname,\n\t\t\t\t    sc->sc_count));\n\t\t\t\ts = spltty();\n\t\t\t\t(void) lptintr(sc);\n\t\t\t\tsplx(s);\n\t\t\t}\n\t\t\terror = tsleep((caddr_t)sc, LPTPRI | PCATCH,\n\t\t\t    \"lptwrite2\", 0);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"lpt.h\"",
      "#include <dev/ic/lptvar.h>",
      "#include <dev/ic/lptreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/syslog.h>",
      "#include <sys/conf.h>",
      "#include <sys/device.h>",
      "#include <sys/uio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tLPTPRI\t\t(PZERO+8)",
      "#define\tTIMEOUT\t\thz*16\t/* wait up to 16 seconds for a ready */"
    ],
    "globals_used": [
      "int\tlptpushbytes"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "(caddr_t)sc",
            "LPTPRI | PCATCH",
            "\"lptwrite2\"",
            "0"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lptintr",
          "args": [
            "sc"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "lptintr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/lpt.c",
          "lines": "386-420",
          "snippet": "int\nlptintr(arg)\n\tvoid *arg;\n{\n\tstruct lpt_softc *sc = arg;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tif (((sc->sc_state & LPT_OPEN) == 0 && sc->sc_count == 0) ||\n\t    (sc->sc_flags & LPT_NOINTR))\n\t\treturn 0;\n\n\t/* is printer online and ready for output */\n\tif (NOT_READY() && NOT_READY_ERR())\n\t\treturn -1;\n\n\tif (sc->sc_count) {\n\t\tu_int8_t control = sc->sc_control;\n\t\t/* send char */\n\t\tbus_space_write_1(iot, ioh, lpt_data, *sc->sc_cp++);\n\t\tdelay (50);\n\t\tbus_space_write_1(iot, ioh, lpt_control, control | LPC_STROBE);\n\t\tsc->sc_count--;\n\t\tbus_space_write_1(iot, ioh, lpt_control, control);\n\t\tsc->sc_state |= LPT_OBUSY;\n\t} else\n\t\tsc->sc_state &= ~LPT_OBUSY;\n\n\tif (sc->sc_count == 0) {\n\t\t/* none, wake up the top half to get more */\n\t\twakeup((caddr_t)sc);\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"lpt.h\"",
            "#include <dev/ic/lptvar.h>",
            "#include <dev/ic/lptreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/syslog.h>",
            "#include <sys/conf.h>",
            "#include <sys/device.h>",
            "#include <sys/uio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lpt.h\"\n#include <dev/ic/lptvar.h>\n#include <dev/ic/lptreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/syslog.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/uio.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nlptintr(arg)\n\tvoid *arg;\n{\n\tstruct lpt_softc *sc = arg;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tif (((sc->sc_state & LPT_OPEN) == 0 && sc->sc_count == 0) ||\n\t    (sc->sc_flags & LPT_NOINTR))\n\t\treturn 0;\n\n\t/* is printer online and ready for output */\n\tif (NOT_READY() && NOT_READY_ERR())\n\t\treturn -1;\n\n\tif (sc->sc_count) {\n\t\tu_int8_t control = sc->sc_control;\n\t\t/* send char */\n\t\tbus_space_write_1(iot, ioh, lpt_data, *sc->sc_cp++);\n\t\tdelay (50);\n\t\tbus_space_write_1(iot, ioh, lpt_control, control | LPC_STROBE);\n\t\tsc->sc_count--;\n\t\tbus_space_write_1(iot, ioh, lpt_control, control);\n\t\tsc->sc_state |= LPT_OBUSY;\n\t} else\n\t\tsc->sc_state &= ~LPT_OBUSY;\n\n\tif (sc->sc_count == 0) {\n\t\t/* none, wake up the top half to get more */\n\t\twakeup((caddr_t)sc);\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LPRINTF",
          "args": [
            "(\"%s: write %d\\n\", sc->sc_dev.dv_xname,\n\t\t\t\t    sc->sc_count)"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "lpt_control",
            "control"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "lpt_control",
            "control | LPC_STROBE"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "lpt_data",
            "*sc->sc_cp++"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "(caddr_t)sc",
            "LPTPRI | PCATCH",
            "\"lptpsh\"",
            "tic"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NOT_READY_ERR",
          "args": [],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NOT_READY",
          "args": [],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lpt.h\"\n#include <dev/ic/lptvar.h>\n#include <dev/ic/lptreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/syslog.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/uio.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tLPTPRI\t\t(PZERO+8)\n#define\tTIMEOUT\t\thz*16\t/* wait up to 16 seconds for a ready */\n\nint\tlptpushbytes;\n\nint\nlptpushbytes(sc)\n\tstruct lpt_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint error;\n\n\tif (sc->sc_flags & LPT_NOINTR) {\n\t\tint spin, tic;\n\t\tu_int8_t control = sc->sc_control;\n\n\t\twhile (sc->sc_count > 0) {\n\t\t\tspin = 0;\n\t\t\twhile (NOT_READY()) {\n\t\t\t\tif (++spin < sc->sc_spinmax)\n\t\t\t\t\tcontinue;\n\t\t\t\ttic = 0;\n\t\t\t\t/* adapt busy-wait algorithm */\n\t\t\t\tsc->sc_spinmax++;\n\t\t\t\twhile (NOT_READY_ERR()) {\n\t\t\t\t\t/* exponential backoff */\n\t\t\t\t\ttic = tic + tic + 1;\n\t\t\t\t\tif (tic > TIMEOUT)\n\t\t\t\t\t\ttic = TIMEOUT;\n\t\t\t\t\terror = tsleep((caddr_t)sc,\n\t\t\t\t\t    LPTPRI | PCATCH, \"lptpsh\", tic);\n\t\t\t\t\tif (error != EWOULDBLOCK)\n\t\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbus_space_write_1(iot, ioh, lpt_data, *sc->sc_cp++);\n\t\t\tbus_space_write_1(iot, ioh, lpt_control,\n\t\t\t    control | LPC_STROBE);\n\t\t\tsc->sc_count--;\n\t\t\tbus_space_write_1(iot, ioh, lpt_control, control);\n\n\t\t\t/* adapt busy-wait algorithm */\n\t\t\tif (spin*2 + 16 < sc->sc_spinmax)\n\t\t\t\tsc->sc_spinmax--;\n\t\t}\n\t} else {\n\t\tint s;\n\n\t\twhile (sc->sc_count > 0) {\n\t\t\t/* if the printer is ready for a char, give it one */\n\t\t\tif ((sc->sc_state & LPT_OBUSY) == 0) {\n\t\t\t\tLPRINTF((\"%s: write %d\\n\", sc->sc_dev.dv_xname,\n\t\t\t\t    sc->sc_count));\n\t\t\t\ts = spltty();\n\t\t\t\t(void) lptintr(sc);\n\t\t\t\tsplx(s);\n\t\t\t}\n\t\t\terror = tsleep((caddr_t)sc, LPTPRI | PCATCH,\n\t\t\t    \"lptwrite2\", 0);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "lptclose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/lpt.c",
    "lines": "260-285",
    "snippet": "int\nlptclose(dev, flag, mode, p)\n\tdev_t dev;\n\tint flag;\n\tint mode;\n\tstruct proc *p;\n{\n\tint unit = LPTUNIT(dev);\n\tstruct lpt_softc *sc = lpt_cd.cd_devs[unit];\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tif (sc->sc_count)\n\t\t(void) lptpushbytes(sc);\n\n\tif ((sc->sc_flags & LPT_NOINTR) == 0)\n\t\tuntimeout(lptwakeup, sc);\n\n\tbus_space_write_1(iot, ioh, lpt_control, LPC_NINIT);\n\tsc->sc_state = 0;\n\tbus_space_write_1(iot, ioh, lpt_control, LPC_NINIT);\n\tbrelse(sc->sc_inbuf);\n\n\tLPRINTF((\"%s: closed\\n\", sc->sc_dev.dv_xname));\n\treturn 0;\n}",
    "includes": [
      "#include \"lpt.h\"",
      "#include <dev/ic/lptvar.h>",
      "#include <dev/ic/lptreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/syslog.h>",
      "#include <sys/conf.h>",
      "#include <sys/device.h>",
      "#include <sys/uio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cfdriver lpt_cd = {\n\tNULL, \"lpt\", DV_TTY\n};",
      "void\tlptwakeup",
      "int\tlptpushbytes"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LPRINTF",
          "args": [
            "(\"%s: closed\\n\", sc->sc_dev.dv_xname)"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "sc->sc_inbuf"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "lpt_control",
            "LPC_NINIT"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "lpt_control",
            "LPC_NINIT"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "lptwakeup",
            "sc"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lptpushbytes",
          "args": [
            "sc"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "lptpushbytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/lpt.c",
          "lines": "287-349",
          "snippet": "int\nlptpushbytes(sc)\n\tstruct lpt_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint error;\n\n\tif (sc->sc_flags & LPT_NOINTR) {\n\t\tint spin, tic;\n\t\tu_int8_t control = sc->sc_control;\n\n\t\twhile (sc->sc_count > 0) {\n\t\t\tspin = 0;\n\t\t\twhile (NOT_READY()) {\n\t\t\t\tif (++spin < sc->sc_spinmax)\n\t\t\t\t\tcontinue;\n\t\t\t\ttic = 0;\n\t\t\t\t/* adapt busy-wait algorithm */\n\t\t\t\tsc->sc_spinmax++;\n\t\t\t\twhile (NOT_READY_ERR()) {\n\t\t\t\t\t/* exponential backoff */\n\t\t\t\t\ttic = tic + tic + 1;\n\t\t\t\t\tif (tic > TIMEOUT)\n\t\t\t\t\t\ttic = TIMEOUT;\n\t\t\t\t\terror = tsleep((caddr_t)sc,\n\t\t\t\t\t    LPTPRI | PCATCH, \"lptpsh\", tic);\n\t\t\t\t\tif (error != EWOULDBLOCK)\n\t\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbus_space_write_1(iot, ioh, lpt_data, *sc->sc_cp++);\n\t\t\tbus_space_write_1(iot, ioh, lpt_control,\n\t\t\t    control | LPC_STROBE);\n\t\t\tsc->sc_count--;\n\t\t\tbus_space_write_1(iot, ioh, lpt_control, control);\n\n\t\t\t/* adapt busy-wait algorithm */\n\t\t\tif (spin*2 + 16 < sc->sc_spinmax)\n\t\t\t\tsc->sc_spinmax--;\n\t\t}\n\t} else {\n\t\tint s;\n\n\t\twhile (sc->sc_count > 0) {\n\t\t\t/* if the printer is ready for a char, give it one */\n\t\t\tif ((sc->sc_state & LPT_OBUSY) == 0) {\n\t\t\t\tLPRINTF((\"%s: write %d\\n\", sc->sc_dev.dv_xname,\n\t\t\t\t    sc->sc_count));\n\t\t\t\ts = spltty();\n\t\t\t\t(void) lptintr(sc);\n\t\t\t\tsplx(s);\n\t\t\t}\n\t\t\terror = tsleep((caddr_t)sc, LPTPRI | PCATCH,\n\t\t\t    \"lptwrite2\", 0);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"lpt.h\"",
            "#include <dev/ic/lptvar.h>",
            "#include <dev/ic/lptreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/syslog.h>",
            "#include <sys/conf.h>",
            "#include <sys/device.h>",
            "#include <sys/uio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tLPTPRI\t\t(PZERO+8)",
            "#define\tTIMEOUT\t\thz*16\t/* wait up to 16 seconds for a ready */"
          ],
          "globals_used": [
            "int\tlptpushbytes"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lpt.h\"\n#include <dev/ic/lptvar.h>\n#include <dev/ic/lptreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/syslog.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/uio.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tLPTPRI\t\t(PZERO+8)\n#define\tTIMEOUT\t\thz*16\t/* wait up to 16 seconds for a ready */\n\nint\tlptpushbytes;\n\nint\nlptpushbytes(sc)\n\tstruct lpt_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\tint error;\n\n\tif (sc->sc_flags & LPT_NOINTR) {\n\t\tint spin, tic;\n\t\tu_int8_t control = sc->sc_control;\n\n\t\twhile (sc->sc_count > 0) {\n\t\t\tspin = 0;\n\t\t\twhile (NOT_READY()) {\n\t\t\t\tif (++spin < sc->sc_spinmax)\n\t\t\t\t\tcontinue;\n\t\t\t\ttic = 0;\n\t\t\t\t/* adapt busy-wait algorithm */\n\t\t\t\tsc->sc_spinmax++;\n\t\t\t\twhile (NOT_READY_ERR()) {\n\t\t\t\t\t/* exponential backoff */\n\t\t\t\t\ttic = tic + tic + 1;\n\t\t\t\t\tif (tic > TIMEOUT)\n\t\t\t\t\t\ttic = TIMEOUT;\n\t\t\t\t\terror = tsleep((caddr_t)sc,\n\t\t\t\t\t    LPTPRI | PCATCH, \"lptpsh\", tic);\n\t\t\t\t\tif (error != EWOULDBLOCK)\n\t\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbus_space_write_1(iot, ioh, lpt_data, *sc->sc_cp++);\n\t\t\tbus_space_write_1(iot, ioh, lpt_control,\n\t\t\t    control | LPC_STROBE);\n\t\t\tsc->sc_count--;\n\t\t\tbus_space_write_1(iot, ioh, lpt_control, control);\n\n\t\t\t/* adapt busy-wait algorithm */\n\t\t\tif (spin*2 + 16 < sc->sc_spinmax)\n\t\t\t\tsc->sc_spinmax--;\n\t\t}\n\t} else {\n\t\tint s;\n\n\t\twhile (sc->sc_count > 0) {\n\t\t\t/* if the printer is ready for a char, give it one */\n\t\t\tif ((sc->sc_state & LPT_OBUSY) == 0) {\n\t\t\t\tLPRINTF((\"%s: write %d\\n\", sc->sc_dev.dv_xname,\n\t\t\t\t    sc->sc_count));\n\t\t\t\ts = spltty();\n\t\t\t\t(void) lptintr(sc);\n\t\t\t\tsplx(s);\n\t\t\t}\n\t\t\terror = tsleep((caddr_t)sc, LPTPRI | PCATCH,\n\t\t\t    \"lptwrite2\", 0);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LPTUNIT",
          "args": [
            "dev"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lpt.h\"\n#include <dev/ic/lptvar.h>\n#include <dev/ic/lptreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/syslog.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/uio.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct cfdriver lpt_cd = {\n\tNULL, \"lpt\", DV_TTY\n};\nvoid\tlptwakeup;\nint\tlptpushbytes;\n\nint\nlptclose(dev, flag, mode, p)\n\tdev_t dev;\n\tint flag;\n\tint mode;\n\tstruct proc *p;\n{\n\tint unit = LPTUNIT(dev);\n\tstruct lpt_softc *sc = lpt_cd.cd_devs[unit];\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tif (sc->sc_count)\n\t\t(void) lptpushbytes(sc);\n\n\tif ((sc->sc_flags & LPT_NOINTR) == 0)\n\t\tuntimeout(lptwakeup, sc);\n\n\tbus_space_write_1(iot, ioh, lpt_control, LPC_NINIT);\n\tsc->sc_state = 0;\n\tbus_space_write_1(iot, ioh, lpt_control, LPC_NINIT);\n\tbrelse(sc->sc_inbuf);\n\n\tLPRINTF((\"%s: closed\\n\", sc->sc_dev.dv_xname));\n\treturn 0;\n}"
  },
  {
    "function_name": "lptwakeup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/lpt.c",
    "lines": "243-255",
    "snippet": "void\nlptwakeup(arg)\n\tvoid *arg;\n{\n\tstruct lpt_softc *sc = arg;\n\tint s;\n\n\ts = spltty();\n\tlptintr(sc);\n\tsplx(s);\n\n\ttimeout(lptwakeup, sc, STEP);\n}",
    "includes": [
      "#include \"lpt.h\"",
      "#include <dev/ic/lptvar.h>",
      "#include <dev/ic/lptreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/syslog.h>",
      "#include <sys/conf.h>",
      "#include <sys/device.h>",
      "#include <sys/uio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tSTEP\t\thz/4"
    ],
    "globals_used": [
      "void\tlptwakeup"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "lptwakeup",
            "sc",
            "STEP"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "wdctimeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "952-980",
          "snippet": "void\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [
            "static void  __wdcerror"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nstatic void  __wdcerror;\n\nvoid\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lptintr",
          "args": [
            "sc"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "lptintr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/lpt.c",
          "lines": "386-420",
          "snippet": "int\nlptintr(arg)\n\tvoid *arg;\n{\n\tstruct lpt_softc *sc = arg;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tif (((sc->sc_state & LPT_OPEN) == 0 && sc->sc_count == 0) ||\n\t    (sc->sc_flags & LPT_NOINTR))\n\t\treturn 0;\n\n\t/* is printer online and ready for output */\n\tif (NOT_READY() && NOT_READY_ERR())\n\t\treturn -1;\n\n\tif (sc->sc_count) {\n\t\tu_int8_t control = sc->sc_control;\n\t\t/* send char */\n\t\tbus_space_write_1(iot, ioh, lpt_data, *sc->sc_cp++);\n\t\tdelay (50);\n\t\tbus_space_write_1(iot, ioh, lpt_control, control | LPC_STROBE);\n\t\tsc->sc_count--;\n\t\tbus_space_write_1(iot, ioh, lpt_control, control);\n\t\tsc->sc_state |= LPT_OBUSY;\n\t} else\n\t\tsc->sc_state &= ~LPT_OBUSY;\n\n\tif (sc->sc_count == 0) {\n\t\t/* none, wake up the top half to get more */\n\t\twakeup((caddr_t)sc);\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"lpt.h\"",
            "#include <dev/ic/lptvar.h>",
            "#include <dev/ic/lptreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/syslog.h>",
            "#include <sys/conf.h>",
            "#include <sys/device.h>",
            "#include <sys/uio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lpt.h\"\n#include <dev/ic/lptvar.h>\n#include <dev/ic/lptreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/syslog.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/uio.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nlptintr(arg)\n\tvoid *arg;\n{\n\tstruct lpt_softc *sc = arg;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh = sc->sc_ioh;\n\n\tif (((sc->sc_state & LPT_OPEN) == 0 && sc->sc_count == 0) ||\n\t    (sc->sc_flags & LPT_NOINTR))\n\t\treturn 0;\n\n\t/* is printer online and ready for output */\n\tif (NOT_READY() && NOT_READY_ERR())\n\t\treturn -1;\n\n\tif (sc->sc_count) {\n\t\tu_int8_t control = sc->sc_control;\n\t\t/* send char */\n\t\tbus_space_write_1(iot, ioh, lpt_data, *sc->sc_cp++);\n\t\tdelay (50);\n\t\tbus_space_write_1(iot, ioh, lpt_control, control | LPC_STROBE);\n\t\tsc->sc_count--;\n\t\tbus_space_write_1(iot, ioh, lpt_control, control);\n\t\tsc->sc_state |= LPT_OBUSY;\n\t} else\n\t\tsc->sc_state &= ~LPT_OBUSY;\n\n\tif (sc->sc_count == 0) {\n\t\t/* none, wake up the top half to get more */\n\t\twakeup((caddr_t)sc);\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lpt.h\"\n#include <dev/ic/lptvar.h>\n#include <dev/ic/lptreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/syslog.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/uio.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tSTEP\t\thz/4\n\nvoid\tlptwakeup;\n\nvoid\nlptwakeup(arg)\n\tvoid *arg;\n{\n\tstruct lpt_softc *sc = arg;\n\tint s;\n\n\ts = spltty();\n\tlptintr(sc);\n\tsplx(s);\n\n\ttimeout(lptwakeup, sc, STEP);\n}"
  },
  {
    "function_name": "lpt_not_ready",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/lpt.c",
    "lines": "222-241",
    "snippet": "int\nlpt_not_ready(status, sc)\n\tu_int8_t status;\n\tstruct lpt_softc *sc;\n{\n\tu_int8_t new;\n\n\tstatus = (status ^ LPS_INVERT) & LPS_MASK;\n\tnew = status & ~sc->sc_laststatus;\n\tsc->sc_laststatus = status;\n\n\tif (new & LPS_SELECT)\n\t\tlog(LOG_NOTICE, \"%s: offline\\n\", sc->sc_dev.dv_xname);\n\telse if (new & LPS_NOPAPER)\n\t\tlog(LOG_NOTICE, \"%s: out of paper\\n\", sc->sc_dev.dv_xname);\n\telse if (new & LPS_NERR)\n\t\tlog(LOG_NOTICE, \"%s: output error\\n\", sc->sc_dev.dv_xname);\n\n\treturn status;\n}",
    "includes": [
      "#include \"lpt.h\"",
      "#include <dev/ic/lptvar.h>",
      "#include <dev/ic/lptreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/syslog.h>",
      "#include <sys/conf.h>",
      "#include <sys/device.h>",
      "#include <sys/uio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tLPS_MASK\t(LPS_SELECT|LPS_NERR|LPS_NBSY|LPS_NACK|LPS_NOPAPER)",
      "#define\tLPS_INVERT\t(LPS_SELECT|LPS_NERR|LPS_NBSY|LPS_NACK)"
    ],
    "globals_used": [
      "int\tlpt_not_ready"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_NOTICE",
            "\"%s: output error\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1387-1401",
          "snippet": "int\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"lpt.h\"\n#include <dev/ic/lptvar.h>\n#include <dev/ic/lptreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/syslog.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/uio.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tLPS_MASK\t(LPS_SELECT|LPS_NERR|LPS_NBSY|LPS_NACK|LPS_NOPAPER)\n#define\tLPS_INVERT\t(LPS_SELECT|LPS_NERR|LPS_NBSY|LPS_NACK)\n\nint\tlpt_not_ready;\n\nint\nlpt_not_ready(status, sc)\n\tu_int8_t status;\n\tstruct lpt_softc *sc;\n{\n\tu_int8_t new;\n\n\tstatus = (status ^ LPS_INVERT) & LPS_MASK;\n\tnew = status & ~sc->sc_laststatus;\n\tsc->sc_laststatus = status;\n\n\tif (new & LPS_SELECT)\n\t\tlog(LOG_NOTICE, \"%s: offline\\n\", sc->sc_dev.dv_xname);\n\telse if (new & LPS_NOPAPER)\n\t\tlog(LOG_NOTICE, \"%s: out of paper\\n\", sc->sc_dev.dv_xname);\n\telse if (new & LPS_NERR)\n\t\tlog(LOG_NOTICE, \"%s: output error\\n\", sc->sc_dev.dv_xname);\n\n\treturn status;\n}"
  },
  {
    "function_name": "lptopen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/lpt.c",
    "lines": "140-220",
    "snippet": "int\nlptopen(dev, flag, mode, p)\n\tdev_t dev;\n\tint flag;\n\tint mode;\n\tstruct proc *p;\n{\n\tint unit = LPTUNIT(dev);\n\tu_int8_t flags = LPTFLAGS(dev);\n\tstruct lpt_softc *sc;\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tu_int8_t control;\n\tint error;\n\tint spin;\n\n\tif (unit >= lpt_cd.cd_ndevs)\n\t\treturn ENXIO;\n\tsc = lpt_cd.cd_devs[unit];\n\tif (!sc)\n\t\treturn ENXIO;\n\n\tsc->sc_flags = (sc->sc_flags & LPT_POLLED) | flags;\n\tif ((sc->sc_flags & (LPT_POLLED|LPT_NOINTR)) == LPT_POLLED)\n\t\treturn ENXIO;\n\n#ifdef DIAGNOSTIC\n\tif (sc->sc_state)\n\t\tprintf(\"%s: stat=0x%x not zero\\n\", sc->sc_dev.dv_xname,\n\t\t    sc->sc_state);\n#endif\n\n\tif (sc->sc_state)\n\t\treturn EBUSY;\n\n\tsc->sc_state = LPT_INIT;\n\tLPRINTF((\"%s: open: flags=0x%x\\n\", sc->sc_dev.dv_xname, flags));\n\tiot = sc->sc_iot;\n\tioh = sc->sc_ioh;\n\n\tif ((flags & LPT_NOPRIME) == 0) {\n\t\t/* assert INIT for 100 usec to start up printer */\n\t\tbus_space_write_1(iot, ioh, lpt_control, LPC_SELECT);\n\t\tdelay(100);\n\t}\n\n\tcontrol = LPC_SELECT | LPC_NINIT;\n\tbus_space_write_1(iot, ioh, lpt_control, control);\n\n\t/* wait till ready (printer running diagnostics) */\n\tfor (spin = 0; NOT_READY_ERR(); spin += STEP) {\n\t\tif (spin >= TIMEOUT) {\n\t\t\tsc->sc_state = 0;\n\t\t\treturn EBUSY;\n\t\t}\n\n\t\t/* wait 1/4 second, give up if we get a signal */\n\t\terror = tsleep((caddr_t)sc, LPTPRI | PCATCH, \"lptopen\", STEP);\n\t\tif (error != EWOULDBLOCK) {\n\t\t\tsc->sc_state = 0;\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tif ((flags & LPT_NOINTR) == 0)\n\t\tcontrol |= LPC_IENABLE;\n\tif (flags & LPT_AUTOLF)\n\t\tcontrol |= LPC_AUTOLF;\n\tsc->sc_control = control;\n\tbus_space_write_1(iot, ioh, lpt_control, control);\n\n\tsc->sc_inbuf = geteblk(LPT_BSIZE);\n\tsc->sc_count = 0;\n\tsc->sc_state = LPT_OPEN;\n\n\tif ((sc->sc_flags & LPT_NOINTR) == 0)\n\t\tlptwakeup(sc);\n\n\tLPRINTF((\"%s: opened\\n\", sc->sc_dev.dv_xname));\n\treturn 0;\n}",
    "includes": [
      "#include \"lpt.h\"",
      "#include <dev/ic/lptvar.h>",
      "#include <dev/ic/lptreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/syslog.h>",
      "#include <sys/conf.h>",
      "#include <sys/device.h>",
      "#include <sys/uio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tLPT_BSIZE\t1024",
      "#define\tLPTPRI\t\t(PZERO+8)",
      "#define\tSTEP\t\thz/4",
      "#define\tTIMEOUT\t\thz*16\t/* wait up to 16 seconds for a ready */"
    ],
    "globals_used": [
      "struct cfdriver lpt_cd = {\n\tNULL, \"lpt\", DV_TTY\n};",
      "void\tlptwakeup"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LPRINTF",
          "args": [
            "(\"%s: opened\\n\", sc->sc_dev.dv_xname)"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lptwakeup",
          "args": [
            "sc"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "lptwakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/lpt.c",
          "lines": "243-255",
          "snippet": "void\nlptwakeup(arg)\n\tvoid *arg;\n{\n\tstruct lpt_softc *sc = arg;\n\tint s;\n\n\ts = spltty();\n\tlptintr(sc);\n\tsplx(s);\n\n\ttimeout(lptwakeup, sc, STEP);\n}",
          "includes": [
            "#include \"lpt.h\"",
            "#include <dev/ic/lptvar.h>",
            "#include <dev/ic/lptreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/syslog.h>",
            "#include <sys/conf.h>",
            "#include <sys/device.h>",
            "#include <sys/uio.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tSTEP\t\thz/4"
          ],
          "globals_used": [
            "void\tlptwakeup"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lpt.h\"\n#include <dev/ic/lptvar.h>\n#include <dev/ic/lptreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/syslog.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/uio.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tSTEP\t\thz/4\n\nvoid\tlptwakeup;\n\nvoid\nlptwakeup(arg)\n\tvoid *arg;\n{\n\tstruct lpt_softc *sc = arg;\n\tint s;\n\n\ts = spltty();\n\tlptintr(sc);\n\tsplx(s);\n\n\ttimeout(lptwakeup, sc, STEP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "geteblk",
          "args": [
            "LPT_BSIZE"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "lpt_control",
            "control"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "(caddr_t)sc",
            "LPTPRI | PCATCH",
            "\"lptopen\"",
            "STEP"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NOT_READY_ERR",
          "args": [],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "lpt_control",
            "control"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "100"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "lpt_control",
            "LPC_SELECT"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LPRINTF",
          "args": [
            "(\"%s: open: flags=0x%x\\n\", sc->sc_dev.dv_xname, flags)"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: stat=0x%x not zero\\n\"",
            "sc->sc_dev.dv_xname",
            "sc->sc_state"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "LPTFLAGS",
          "args": [
            "dev"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LPTUNIT",
          "args": [
            "dev"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lpt.h\"\n#include <dev/ic/lptvar.h>\n#include <dev/ic/lptreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/syslog.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/uio.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tLPT_BSIZE\t1024\n#define\tLPTPRI\t\t(PZERO+8)\n#define\tSTEP\t\thz/4\n#define\tTIMEOUT\t\thz*16\t/* wait up to 16 seconds for a ready */\n\nstruct cfdriver lpt_cd = {\n\tNULL, \"lpt\", DV_TTY\n};\nvoid\tlptwakeup;\n\nint\nlptopen(dev, flag, mode, p)\n\tdev_t dev;\n\tint flag;\n\tint mode;\n\tstruct proc *p;\n{\n\tint unit = LPTUNIT(dev);\n\tu_int8_t flags = LPTFLAGS(dev);\n\tstruct lpt_softc *sc;\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tu_int8_t control;\n\tint error;\n\tint spin;\n\n\tif (unit >= lpt_cd.cd_ndevs)\n\t\treturn ENXIO;\n\tsc = lpt_cd.cd_devs[unit];\n\tif (!sc)\n\t\treturn ENXIO;\n\n\tsc->sc_flags = (sc->sc_flags & LPT_POLLED) | flags;\n\tif ((sc->sc_flags & (LPT_POLLED|LPT_NOINTR)) == LPT_POLLED)\n\t\treturn ENXIO;\n\n#ifdef DIAGNOSTIC\n\tif (sc->sc_state)\n\t\tprintf(\"%s: stat=0x%x not zero\\n\", sc->sc_dev.dv_xname,\n\t\t    sc->sc_state);\n#endif\n\n\tif (sc->sc_state)\n\t\treturn EBUSY;\n\n\tsc->sc_state = LPT_INIT;\n\tLPRINTF((\"%s: open: flags=0x%x\\n\", sc->sc_dev.dv_xname, flags));\n\tiot = sc->sc_iot;\n\tioh = sc->sc_ioh;\n\n\tif ((flags & LPT_NOPRIME) == 0) {\n\t\t/* assert INIT for 100 usec to start up printer */\n\t\tbus_space_write_1(iot, ioh, lpt_control, LPC_SELECT);\n\t\tdelay(100);\n\t}\n\n\tcontrol = LPC_SELECT | LPC_NINIT;\n\tbus_space_write_1(iot, ioh, lpt_control, control);\n\n\t/* wait till ready (printer running diagnostics) */\n\tfor (spin = 0; NOT_READY_ERR(); spin += STEP) {\n\t\tif (spin >= TIMEOUT) {\n\t\t\tsc->sc_state = 0;\n\t\t\treturn EBUSY;\n\t\t}\n\n\t\t/* wait 1/4 second, give up if we get a signal */\n\t\terror = tsleep((caddr_t)sc, LPTPRI | PCATCH, \"lptopen\", STEP);\n\t\tif (error != EWOULDBLOCK) {\n\t\t\tsc->sc_state = 0;\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tif ((flags & LPT_NOINTR) == 0)\n\t\tcontrol |= LPC_IENABLE;\n\tif (flags & LPT_AUTOLF)\n\t\tcontrol |= LPC_AUTOLF;\n\tsc->sc_control = control;\n\tbus_space_write_1(iot, ioh, lpt_control, control);\n\n\tsc->sc_inbuf = geteblk(LPT_BSIZE);\n\tsc->sc_count = 0;\n\tsc->sc_state = LPT_OPEN;\n\n\tif ((sc->sc_flags & LPT_NOINTR) == 0)\n\t\tlptwakeup(sc);\n\n\tLPRINTF((\"%s: opened\\n\", sc->sc_dev.dv_xname));\n\treturn 0;\n}"
  },
  {
    "function_name": "lpt_port_test",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/lpt.c",
    "lines": "114-135",
    "snippet": "int\nlpt_port_test(iot, ioh, base, off, data, mask)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tbus_addr_t base;\n\tbus_size_t off;\n\tu_int8_t data, mask;\n{\n\tint timeout;\n\tu_int8_t temp;\n\n\tdata &= mask;\n\tbus_space_write_1(iot, ioh, off, data);\n\ttimeout = 1000;\n\tdo {\n\t\tdelay(10);\n\t\ttemp = bus_space_read_1(iot, ioh, off) & mask;\n\t} while (temp != data && --timeout);\n\tLPRINTF((\"lpt: port=0x%x out=0x%x in=0x%x timeout=%d\\n\", base + off,\n\t    data, temp, timeout));\n\treturn (temp == data);\n}",
    "includes": [
      "#include \"lpt.h\"",
      "#include <dev/ic/lptvar.h>",
      "#include <dev/ic/lptreg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <sys/syslog.h>",
      "#include <sys/conf.h>",
      "#include <sys/device.h>",
      "#include <sys/uio.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/kernel.h>",
      "#include <sys/buf.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "LPRINTF",
          "args": [
            "(\"lpt: port=0x%x out=0x%x in=0x%x timeout=%d\\n\", base + off,\n\t    data, temp, timeout)"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh",
            "off"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "10"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh",
            "off",
            "data"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"lpt.h\"\n#include <dev/ic/lptvar.h>\n#include <dev/ic/lptreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/syslog.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/uio.h>\n#include <sys/ioctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nlpt_port_test(iot, ioh, base, off, data, mask)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh;\n\tbus_addr_t base;\n\tbus_size_t off;\n\tu_int8_t data, mask;\n{\n\tint timeout;\n\tu_int8_t temp;\n\n\tdata &= mask;\n\tbus_space_write_1(iot, ioh, off, data);\n\ttimeout = 1000;\n\tdo {\n\t\tdelay(10);\n\t\ttemp = bus_space_read_1(iot, ioh, off) & mask;\n\t} while (temp != data && --timeout);\n\tLPRINTF((\"lpt: port=0x%x out=0x%x in=0x%x timeout=%d\\n\", base + off,\n\t    data, temp, timeout));\n\treturn (temp == data);\n}"
  }
]