[
  {
    "function_name": "wskbd_translate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
    "lines": "1335-1530",
    "snippet": "static int\nwskbd_translate(id, type, value)\n\tstruct wskbd_internal *id;\n\tu_int type;\n\tint value;\n{\n\tstruct wskbd_softc *sc = id->t_sc;\n\tkeysym_t ksym, res, *group;\n\tstruct wscons_keymap kpbuf, *kp;\n\tint iscommand = 0;\n\n\tif (type == WSCONS_EVENT_ALL_KEYS_UP) {\n\t\tid->t_modifiers &= ~(MOD_SHIFT_L | MOD_SHIFT_R\n\t\t\t\t| MOD_CONTROL_L | MOD_CONTROL_R\n\t\t\t\t| MOD_META_L | MOD_META_R\n\t\t\t\t| MOD_MODESHIFT\n\t\t\t\t| MOD_COMMAND | MOD_COMMAND1 | MOD_COMMAND2);\n\t\tupdate_leds(id);\n\t\treturn (0);\n\t}\n\n\tif (sc != NULL) {\n\t\tif (value < 0 || value >= sc->sc_maplen) {\n#ifdef DEBUG\n\t\t\tprintf(\"wskbd_translate: keycode %d out of range\\n\",\n\t\t\t       value);\n#endif\n\t\t\treturn (0);\n\t\t}\n\t\tkp = sc->sc_map + value;\n\t} else {\n\t\tkp = &kpbuf;\n\t\twskbd_get_mapentry(id->t_keymap, value, kp);\n\t}\n\n\t/* if this key has a command, process it first */\n\tif (sc != NULL && kp->command != KS_voidSymbol)\n\t\tiscommand = internal_command(sc, &type, kp->command);\n\n\t/* Now update modifiers */\n\tswitch (kp->group1[0]) {\n\tcase KS_Shift_L:\n\t\tupdate_modifier(id, type, 0, MOD_SHIFT_L);\n\t\tbreak;\n\n\tcase KS_Shift_R:\n\t\tupdate_modifier(id, type, 0, MOD_SHIFT_R);\n\t\tbreak;\n\n\tcase KS_Shift_Lock:\n\t\tupdate_modifier(id, type, 1, MOD_SHIFTLOCK);\n\t\tbreak;\n\n\tcase KS_Caps_Lock:\n\t\tupdate_modifier(id, type, 1, MOD_CAPSLOCK);\n\t\tbreak;\n\n\tcase KS_Control_L:\n\t\tupdate_modifier(id, type, 0, MOD_CONTROL_L);\n\t\tbreak;\n\n\tcase KS_Control_R:\n\t\tupdate_modifier(id, type, 0, MOD_CONTROL_R);\n\t\tbreak;\n\n\tcase KS_Alt_L:\n\t\tupdate_modifier(id, type, 0, MOD_META_L);\n\t\tbreak;\n\n\tcase KS_Alt_R:\n\t\tupdate_modifier(id, type, 0, MOD_META_R);\n\t\tbreak;\n\n\tcase KS_Mode_switch:\n\t\tupdate_modifier(id, type, 0, MOD_MODESHIFT);\n\t\tbreak;\n\n\tcase KS_Num_Lock:\n\t\tupdate_modifier(id, type, 1, MOD_NUMLOCK);\n\t\tbreak;\n\n#if NWSDISPLAY > 0\n\tcase KS_Hold_Screen:\n\t\tif (sc != NULL) {\n\t\t\tupdate_modifier(id, type, 1, MOD_HOLDSCREEN);\n\t\t\twskbd_holdscreen(sc, id->t_modifiers & MOD_HOLDSCREEN);\n\t\t}\n\t\tbreak;\n#endif\n\t}\n\n\t/* If this is a key release or we are in command mode, we are done */\n\tif (type != WSCONS_EVENT_KEY_DOWN || iscommand) {\n\t\tupdate_leds(id);\n\t\treturn (0);\n\t}\n\n\t/* Get the keysym */\n\tif (id->t_modifiers & MOD_MODESHIFT)\n\t\tgroup = & kp->group2[0];\n\telse\n\t\tgroup = & kp->group1[0];\n\n\tif ((id->t_modifiers & MOD_NUMLOCK) != 0 &&\n\t    KS_GROUP(group[1]) == KS_GROUP_Keypad) {\n\t\tif (MOD_ONESET(id, MOD_ANYSHIFT))\n\t\t\tksym = group[0];\n\t\telse\n\t\t\tksym = group[1];\n\t} else if (! MOD_ONESET(id, MOD_ANYSHIFT | MOD_CAPSLOCK)) {\n\t\tksym = group[0];\n\t} else if (MOD_ONESET(id, MOD_CAPSLOCK)) {\n\t\tif (! MOD_ONESET(id, MOD_SHIFT_L | MOD_SHIFT_R))\n\t\t\tksym = group[0];\n\t\telse\n\t\t\tksym = group[1];\n\t\tif (ksym >= KS_a && ksym <= KS_z)\n\t\t\tksym += KS_A - KS_a;\n\t\telse if (ksym >= KS_agrave && ksym <= KS_thorn &&\n\t\t\t ksym != KS_division)\n\t\t\tksym += KS_Agrave - KS_agrave;\n\t} else if (MOD_ONESET(id, MOD_ANYSHIFT)) {\n\t\tksym = group[1];\n\t} else {\n\t\tksym = group[0];\n\t}\n\n\t/* Process compose sequence and dead accents */\n\tres = KS_voidSymbol;\n\n\tswitch (KS_GROUP(ksym)) {\n\tcase KS_GROUP_Ascii:\n\tcase KS_GROUP_Keypad:\n\tcase KS_GROUP_Function:\n\t\tres = ksym;\n\t\tbreak;\n\n\tcase KS_GROUP_Mod:\n\t\tif (ksym == KS_Multi_key) {\n\t\t\tupdate_modifier(id, 1, 0, MOD_COMPOSE);\n\t\t\tid->t_composelen = 2;\n\t\t}\n\t\tbreak;\n\n\tcase KS_GROUP_Dead:\n\t\tif (id->t_composelen == 0) {\n\t\t\tupdate_modifier(id, 1, 0, MOD_COMPOSE);\n\t\t\tid->t_composelen = 1;\n\t\t\tid->t_composebuf[0] = ksym;\n\t\t} else\n\t\t\tres = ksym;\n\t\tbreak;\n\t}\n\n\tif (res == KS_voidSymbol) {\n\t\tupdate_leds(id);\n\t\treturn (0);\n\t}\n\n\tif (id->t_composelen > 0) {\n\t\tid->t_composebuf[2 - id->t_composelen] = res;\n\t\tif (--id->t_composelen == 0) {\n\t\t\tres = wskbd_compose_value(id->t_composebuf);\n\t\t\tupdate_modifier(id, 0, 0, MOD_COMPOSE);\n\t\t} else {\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\tupdate_leds(id);\n\n\t/* We are done, return the symbol */\n\tif (KS_GROUP(res) == KS_GROUP_Ascii) {\n\t\tif (MOD_ONESET(id, MOD_ANYCONTROL)) {\n\t\t\tif ((res >= KS_at && res <= KS_z) || res == KS_space)\n\t\t\t\tres = res & 0x1f;\n\t\t\telse if (res == KS_2)\n\t\t\t\tres = 0x00;\n\t\t\telse if (res >= KS_3 && res <= KS_7)\n\t\t\t\tres = KS_Escape + (res - KS_3);\n\t\t\telse if (res == KS_8)\n\t\t\t\tres = KS_Delete;\n\t\t}\n\t\tif (MOD_ONESET(id, MOD_ANYMETA)) {\n\t\t\tif (id->t_flags & WSKFL_METAESC) {\n\t\t\t\tid->t_symbols[0] = KS_Escape;\n\t\t\t\tid->t_symbols[1] = res;\n\t\t\t\treturn (2);\n\t\t\t} else\n\t\t\tres |= 0x80;\n\t}\n\t}\n\n\tid->t_symbols[0] = res;\n\treturn (1);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wsdisplay.h\"",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wskbdvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [
      "#define MOD_ANYMETA\t\t(MOD_META_L | MOD_META_R)",
      "#define MOD_ANYCONTROL\t\t(MOD_CONTROL_L | MOD_CONTROL_R)",
      "#define MOD_ANYSHIFT\t\t(MOD_SHIFT_L | MOD_SHIFT_R | MOD_SHIFTLOCK)",
      "#define MOD_COMMAND2\t\t(1 << 14)",
      "#define MOD_COMMAND1\t\t(1 << 13)",
      "#define MOD_COMMAND\t\t(1 << 12)",
      "#define MOD_HOLDSCREEN\t\t(1 << 11)",
      "#define MOD_COMPOSE\t\t(1 << 10)",
      "#define MOD_NUMLOCK\t\t(1 << 9)",
      "#define MOD_MODESHIFT\t\t(1 << 8)",
      "#define MOD_META_R\t\t(1 << 7)",
      "#define MOD_META_L\t\t(1 << 6)",
      "#define MOD_CONTROL_R\t\t(1 << 5)",
      "#define MOD_CONTROL_L\t\t(1 << 4)",
      "#define MOD_CAPSLOCK\t\t(1 << 3)",
      "#define MOD_SHIFTLOCK\t\t(1 << 2)",
      "#define MOD_SHIFT_R\t\t(1 << 1)",
      "#define MOD_SHIFT_L\t\t(1 << 0)",
      "#define WSKFL_METAESC 1"
    ],
    "globals_used": [
      "static inline void update_leds",
      "static inline void update_modifier",
      "static int internal_command",
      "static int wskbd_translate"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MOD_ONESET",
          "args": [
            "id",
            "MOD_ANYMETA"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MOD_ONESET",
          "args": [
            "id",
            "MOD_ANYCONTROL"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KS_GROUP",
          "args": [
            "res"
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_leds",
          "args": [
            "id"
          ],
          "line": 1504
        },
        "resolved": true,
        "details": {
          "function_name": "update_leds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
          "lines": "1235-1256",
          "snippet": "static inline void\nupdate_leds(id)\n\tstruct wskbd_internal *id;\n{\n\tint new_state;\n\n\tnew_state = 0;\n\tif (id->t_modifiers & (MOD_SHIFTLOCK | MOD_CAPSLOCK))\n\t\tnew_state |= WSKBD_LED_CAPS;\n\tif (id->t_modifiers & MOD_NUMLOCK)\n\t\tnew_state |= WSKBD_LED_NUM;\n\tif (id->t_modifiers & MOD_COMPOSE)\n\t\tnew_state |= WSKBD_LED_COMPOSE;\n\tif (id->t_modifiers & MOD_HOLDSCREEN)\n\t\tnew_state |= WSKBD_LED_SCROLL;\n\n\tif (id->t_sc && new_state != id->t_sc->sc_ledstate) {\n\t\t(*id->t_sc->sc_accessops->set_leds)\n\t\t    (id->t_sc->sc_accesscookie, new_state);\n\t\tid->t_sc->sc_ledstate = new_state;\n\t}\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wsdisplay.h\"",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wskbdvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/malloc.h>",
            "#include <sys/timeout.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [
            "#define MOD_HOLDSCREEN\t\t(1 << 11)",
            "#define MOD_COMPOSE\t\t(1 << 10)",
            "#define MOD_NUMLOCK\t\t(1 << 9)",
            "#define MOD_CAPSLOCK\t\t(1 << 3)",
            "#define MOD_SHIFTLOCK\t\t(1 << 2)"
          ],
          "globals_used": [
            "static inline void update_leds"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define MOD_HOLDSCREEN\t\t(1 << 11)\n#define MOD_COMPOSE\t\t(1 << 10)\n#define MOD_NUMLOCK\t\t(1 << 9)\n#define MOD_CAPSLOCK\t\t(1 << 3)\n#define MOD_SHIFTLOCK\t\t(1 << 2)\n\nstatic inline void update_leds;\n\nstatic inline void\nupdate_leds(id)\n\tstruct wskbd_internal *id;\n{\n\tint new_state;\n\n\tnew_state = 0;\n\tif (id->t_modifiers & (MOD_SHIFTLOCK | MOD_CAPSLOCK))\n\t\tnew_state |= WSKBD_LED_CAPS;\n\tif (id->t_modifiers & MOD_NUMLOCK)\n\t\tnew_state |= WSKBD_LED_NUM;\n\tif (id->t_modifiers & MOD_COMPOSE)\n\t\tnew_state |= WSKBD_LED_COMPOSE;\n\tif (id->t_modifiers & MOD_HOLDSCREEN)\n\t\tnew_state |= WSKBD_LED_SCROLL;\n\n\tif (id->t_sc && new_state != id->t_sc->sc_ledstate) {\n\t\t(*id->t_sc->sc_accessops->set_leds)\n\t\t    (id->t_sc->sc_accesscookie, new_state);\n\t\tid->t_sc->sc_ledstate = new_state;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_modifier",
          "args": [
            "id",
            "0",
            "0",
            "MOD_COMPOSE"
          ],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "update_modifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
          "lines": "1258-1274",
          "snippet": "static inline void\nupdate_modifier(id, type, toggle, mask)\n\tstruct wskbd_internal *id;\n\tu_int type;\n\tint toggle;\n\tint mask;\n{\n\tif (toggle) {\n\t\tif (type == WSCONS_EVENT_KEY_DOWN)\n\t\t\tid->t_modifiers ^= mask;\n\t} else {\n\t\tif (type == WSCONS_EVENT_KEY_DOWN)\n\t\t\tid->t_modifiers |= mask;\n\t\telse\n\t\t\tid->t_modifiers &= ~mask;\n\t}\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wsdisplay.h\"",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wskbdvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/malloc.h>",
            "#include <sys/timeout.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void update_modifier"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstatic inline void update_modifier;\n\nstatic inline void\nupdate_modifier(id, type, toggle, mask)\n\tstruct wskbd_internal *id;\n\tu_int type;\n\tint toggle;\n\tint mask;\n{\n\tif (toggle) {\n\t\tif (type == WSCONS_EVENT_KEY_DOWN)\n\t\t\tid->t_modifiers ^= mask;\n\t} else {\n\t\tif (type == WSCONS_EVENT_KEY_DOWN)\n\t\t\tid->t_modifiers |= mask;\n\t\telse\n\t\t\tid->t_modifiers &= ~mask;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wskbd_compose_value",
          "args": [
            "id->t_composebuf"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "wskbd_compose_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbdutil.c",
          "lines": "200-233",
          "snippet": "keysym_t\nwskbd_compose_value(compose_buf)\n\tkeysym_t *compose_buf;\n{\n\tint i, j, r;\n\tstruct compose_tab_s v;\n\n\tif (! compose_tab_inorder) {\n\t\t/* Insertion sort. */\n\t\tfor (i = 1; i < COMPOSE_SIZE; i++) {\n\t\t\tv = compose_tab[i];\n\t\t\t/* find correct slot, moving others up */\n\t\t\tfor (j = i; --j >= 0 && compose_tab_cmp(& v, & compose_tab[j]) < 0; )\n\t\t\t\tcompose_tab[j + 1] = compose_tab[j];\n\t\t\tcompose_tab[j + 1] = v;\n\t\t}\n\t\tcompose_tab_inorder = 1;\n\t}\n\n\tfor (j = 0, i = COMPOSE_SIZE; i != 0; i /= 2) {\n\t\tif (compose_tab[j + i/2].elem[0] == compose_buf[0]) {\n\t\t\tif (compose_tab[j + i/2].elem[1] == compose_buf[1])\n\t\t\t\treturn(compose_tab[j + i/2].result);\n\t\t\tr = compose_tab[j + i/2].elem[1] < compose_buf[1];\n\t\t} else\n\t\t\tr = compose_tab[j + i/2].elem[0] < compose_buf[0];\n\t\tif (r) {\n\t\t\tj += i/2 + 1;\n\t\t\ti--;\n\t\t}\n\t}\n\n\treturn(KS_voidSymbol);\n}",
          "includes": [
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdefs.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define COMPOSE_SIZE\tsizeof(compose_tab)/sizeof(compose_tab[0])"
          ],
          "globals_used": [
            "static struct compose_tab_s {\n\tkeysym_t elem[2];\n\tkeysym_t result;\n} compose_tab[] = {\n\t{ { KS_plus,\t\t\tKS_plus },\t\tKS_numbersign },\n\t{ { KS_a,\t\t\tKS_a },\t\t\tKS_at },\n\t{ { KS_parenleft,\t\tKS_parenleft },\t\tKS_bracketleft },\n\t{ { KS_slash,\t\t\tKS_slash },\t\tKS_backslash },\n\t{ { KS_parenright,\t\tKS_parenright },\tKS_bracketright },\n\t{ { KS_parenleft,\t\tKS_minus },\t\tKS_braceleft },\n\t{ { KS_slash,\t\t\tKS_minus },\t\tKS_bar },\n\t{ { KS_parenright,\t\tKS_minus },\t\tKS_braceright },\n\t{ { KS_exclam,\t\t\tKS_exclam },\t\tKS_exclamdown },\n\t{ { KS_c,\t\t\tKS_slash },\t\tKS_cent },\n\t{ { KS_l,\t\t\tKS_minus },\t\tKS_sterling },\n\t{ { KS_y,\t\t\tKS_minus },\t\tKS_yen },\n\t{ { KS_s,\t\t\tKS_o },\t\t\tKS_section },\n\t{ { KS_x,\t\t\tKS_o },\t\t\tKS_currency },\n\t{ { KS_c,\t\t\tKS_o },\t\t\tKS_copyright },\n\t{ { KS_less,\t\t\tKS_less },\t\tKS_guillemotleft },\n\t{ { KS_greater,\t\t\tKS_greater },\t\tKS_guillemotright },\n\t{ { KS_question,\t\tKS_question },\t\tKS_questiondown },\n\t{ { KS_dead_acute,\t\tKS_space },\t\tKS_acute },\n\t{ { KS_dead_grave,\t\tKS_space },\t\tKS_grave },\n\t{ { KS_dead_tilde,\t\tKS_space },\t\tKS_asciitilde },\n\t{ { KS_dead_circumflex,\t\tKS_space },\t\tKS_asciicircum },\n\t{ { KS_dead_circumflex,\t\tKS_A },\t\t\tKS_Acircumflex },\n\t{ { KS_dead_diaeresis,\t\tKS_A },\t\t\tKS_Adiaeresis },\n\t{ { KS_dead_grave,\t\tKS_A },\t\t\tKS_Agrave },\n\t{ { KS_dead_abovering,\t\tKS_A },\t\t\tKS_Aring },\n\t{ { KS_dead_tilde,\t\tKS_A },\t\t\tKS_Atilde },\n\t{ { KS_dead_cedilla,\t\tKS_C },\t\t\tKS_Ccedilla },\n\t{ { KS_dead_acute,\t\tKS_E },\t\t\tKS_Eacute },\n\t{ { KS_dead_circumflex,\t\tKS_E },\t\t\tKS_Ecircumflex },\n\t{ { KS_dead_diaeresis,\t\tKS_E },\t\t\tKS_Ediaeresis },\n\t{ { KS_dead_grave,\t\tKS_E },\t\t\tKS_Egrave },\n\t{ { KS_dead_acute,\t\tKS_I },\t\t\tKS_Iacute },\n\t{ { KS_dead_circumflex,\t\tKS_I },\t\t\tKS_Icircumflex },\n\t{ { KS_dead_diaeresis,\t\tKS_I },\t\t\tKS_Idiaeresis },\n\t{ { KS_dead_grave,\t\tKS_I },\t\t\tKS_Igrave },\n\t{ { KS_dead_tilde,\t\tKS_N },\t\t\tKS_Ntilde },\n\t{ { KS_dead_acute,\t\tKS_O },\t\t\tKS_Oacute },\n\t{ { KS_dead_circumflex,\t\tKS_O },\t\t\tKS_Ocircumflex },\n\t{ { KS_dead_diaeresis,\t\tKS_O },\t\t\tKS_Odiaeresis },\n\t{ { KS_dead_grave,\t\tKS_O },\t\t\tKS_Ograve },\n\t{ { KS_dead_tilde,\t\tKS_O },\t\t\tKS_Otilde },\n\t{ { KS_dead_acute,\t\tKS_U },\t\t\tKS_Uacute },\n\t{ { KS_dead_circumflex,\t\tKS_U },\t\t\tKS_Ucircumflex },\n\t{ { KS_dead_diaeresis,\t\tKS_U },\t\t\tKS_Udiaeresis },\n\t{ { KS_dead_grave,\t\tKS_U },\t\t\tKS_Ugrave },\n\t{ { KS_dead_acute,\t\tKS_Y },\t\t\tKS_Yacute },\n\t{ { KS_dead_acute,\t\tKS_a },\t\t\tKS_aacute },\n\t{ { KS_dead_circumflex,\t\tKS_a },\t\t\tKS_acircumflex },\n\t{ { KS_dead_diaeresis,\t\tKS_a },\t\t\tKS_adiaeresis },\n\t{ { KS_dead_grave,\t\tKS_a },\t\t\tKS_agrave },\n\t{ { KS_dead_abovering,\t\tKS_a },\t\t\tKS_aring },\n\t{ { KS_dead_tilde,\t\tKS_a },\t\t\tKS_atilde },\n\t{ { KS_dead_cedilla,\t\tKS_c },\t\t\tKS_ccedilla },\n\t{ { KS_dead_acute,\t\tKS_e },\t\t\tKS_eacute },\n\t{ { KS_dead_circumflex,\t\tKS_e },\t\t\tKS_ecircumflex },\n\t{ { KS_dead_diaeresis,\t\tKS_e },\t\t\tKS_ediaeresis },\n\t{ { KS_dead_grave,\t\tKS_e },\t\t\tKS_egrave },\n\t{ { KS_dead_acute,\t\tKS_i },\t\t\tKS_iacute },\n\t{ { KS_dead_circumflex,\t\tKS_i },\t\t\tKS_icircumflex },\n\t{ { KS_dead_diaeresis,\t\tKS_i },\t\t\tKS_idiaeresis },\n\t{ { KS_dead_grave,\t\tKS_i },\t\t\tKS_igrave },\n\t{ { KS_dead_tilde,\t\tKS_n },\t\t\tKS_ntilde },\n\t{ { KS_dead_acute,\t\tKS_o },\t\t\tKS_oacute },\n\t{ { KS_dead_circumflex,\t\tKS_o },\t\t\tKS_ocircumflex },\n\t{ { KS_dead_diaeresis,\t\tKS_o },\t\t\tKS_odiaeresis },\n\t{ { KS_dead_grave,\t\tKS_o },\t\t\tKS_ograve },\n\t{ { KS_dead_tilde,\t\tKS_o },\t\t\tKS_otilde },\n\t{ { KS_dead_acute,\t\tKS_u },\t\t\tKS_uacute },\n\t{ { KS_dead_circumflex,\t\tKS_u },\t\t\tKS_ucircumflex },\n\t{ { KS_dead_diaeresis,\t\tKS_u },\t\t\tKS_udiaeresis },\n\t{ { KS_dead_grave,\t\tKS_u },\t\t\tKS_ugrave },\n\t{ { KS_dead_acute,\t\tKS_y },\t\t\tKS_yacute },\n\t{ { KS_dead_diaeresis,\t\tKS_y },\t\t\tKS_ydiaeresis },\n\t{ { KS_quotedbl,\t\tKS_A },\t\t\tKS_Adiaeresis },\n\t{ { KS_quotedbl,\t\tKS_E },\t\t\tKS_Ediaeresis },\n\t{ { KS_quotedbl,\t\tKS_I },\t\t\tKS_Idiaeresis },\n\t{ { KS_quotedbl,\t\tKS_O },\t\t\tKS_Odiaeresis },\n\t{ { KS_quotedbl,\t\tKS_U },\t\t\tKS_Udiaeresis },\n\t{ { KS_quotedbl,\t\tKS_a },\t\t\tKS_adiaeresis },\n\t{ { KS_quotedbl,\t\tKS_e },\t\t\tKS_ediaeresis },\n\t{ { KS_quotedbl,\t\tKS_i },\t\t\tKS_idiaeresis },\n\t{ { KS_quotedbl,\t\tKS_o },\t\t\tKS_odiaeresis },\n\t{ { KS_quotedbl,\t\tKS_u },\t\t\tKS_udiaeresis },\n\t{ { KS_quotedbl,\t\tKS_y },\t\t\tKS_ydiaeresis },\n\t{ { KS_acute,\t\t\tKS_A },\t\t\tKS_Aacute },\n\t{ { KS_asciicircum,\t\tKS_A },\t\t\tKS_Acircumflex },\n\t{ { KS_grave,\t\t\tKS_A },\t\t\tKS_Agrave },\n\t{ { KS_asterisk,\t\tKS_A },\t\t\tKS_Aring },\n\t{ { KS_asciitilde,\t\tKS_A },\t\t\tKS_Atilde },\n\t{ { KS_cedilla,\t\t\tKS_C },\t\t\tKS_Ccedilla },\n\t{ { KS_acute,\t\t\tKS_E },\t\t\tKS_Eacute },\n\t{ { KS_asciicircum,\t\tKS_E },\t\t\tKS_Ecircumflex },\n\t{ { KS_grave,\t\t\tKS_E },\t\t\tKS_Egrave },\n\t{ { KS_acute,\t\t\tKS_I },\t\t\tKS_Iacute },\n\t{ { KS_asciicircum,\t\tKS_I },\t\t\tKS_Icircumflex },\n\t{ { KS_grave,\t\t\tKS_I },\t\t\tKS_Igrave },\n\t{ { KS_asciitilde,\t\tKS_N },\t\t\tKS_Ntilde },\n\t{ { KS_acute,\t\t\tKS_O },\t\t\tKS_Oacute },\n\t{ { KS_asciicircum,\t\tKS_O },\t\t\tKS_Ocircumflex },\n\t{ { KS_grave,\t\t\tKS_O },\t\t\tKS_Ograve },\n\t{ { KS_asciitilde,\t\tKS_O },\t\t\tKS_Otilde },\n\t{ { KS_acute,\t\t\tKS_U },\t\t\tKS_Uacute },\n\t{ { KS_asciicircum,\t\tKS_U },\t\t\tKS_Ucircumflex },\n\t{ { KS_grave,\t\t\tKS_U },\t\t\tKS_Ugrave },\n\t{ { KS_acute,\t\t\tKS_Y },\t\t\tKS_Yacute },\n\t{ { KS_acute,\t\t\tKS_a },\t\t\tKS_aacute },\n\t{ { KS_asciicircum,\t\tKS_a },\t\t\tKS_acircumflex },\n\t{ { KS_grave,\t\t\tKS_a },\t\t\tKS_agrave },\n\t{ { KS_asterisk,\t\tKS_a },\t\t\tKS_aring },\n\t{ { KS_asciitilde,\t\tKS_a },\t\t\tKS_atilde },\n\t{ { KS_cedilla,\t\t\tKS_c },\t\t\tKS_ccedilla },\n\t{ { KS_acute,\t\t\tKS_e },\t\t\tKS_eacute },\n\t{ { KS_asciicircum,\t\tKS_e },\t\t\tKS_ecircumflex },\n\t{ { KS_grave,\t\t\tKS_e },\t\t\tKS_egrave },\n\t{ { KS_acute,\t\t\tKS_i },\t\t\tKS_iacute },\n\t{ { KS_asciicircum,\t\tKS_i },\t\t\tKS_icircumflex },\n\t{ { KS_grave,\t\t\tKS_i },\t\t\tKS_igrave },\n\t{ { KS_asciitilde,\t\tKS_n },\t\t\tKS_ntilde },\n\t{ { KS_acute,\t\t\tKS_o },\t\t\tKS_oacute },\n\t{ { KS_asciicircum,\t\tKS_o },\t\t\tKS_ocircumflex },\n\t{ { KS_grave,\t\t\tKS_o },\t\t\tKS_ograve },\n\t{ { KS_asciitilde,\t\tKS_o },\t\t\tKS_otilde },\n\t{ { KS_acute,\t\t\tKS_u },\t\t\tKS_uacute },\n\t{ { KS_asciicircum,\t\tKS_u },\t\t\tKS_ucircumflex },\n\t{ { KS_grave,\t\t\tKS_u },\t\t\tKS_ugrave },\n\t{ { KS_acute,\t\t\tKS_y },\t\t\tKS_yacute }\n};",
            "static int compose_tab_inorder = 0;",
            "static inline int compose_tab_cmp"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/errno.h>\n#include <sys/cdefs.h>\n#include <sys/types.h>\n#include <sys/param.h>\n\n#define COMPOSE_SIZE\tsizeof(compose_tab)/sizeof(compose_tab[0])\n\nstatic struct compose_tab_s {\n\tkeysym_t elem[2];\n\tkeysym_t result;\n} compose_tab[] = {\n\t{ { KS_plus,\t\t\tKS_plus },\t\tKS_numbersign },\n\t{ { KS_a,\t\t\tKS_a },\t\t\tKS_at },\n\t{ { KS_parenleft,\t\tKS_parenleft },\t\tKS_bracketleft },\n\t{ { KS_slash,\t\t\tKS_slash },\t\tKS_backslash },\n\t{ { KS_parenright,\t\tKS_parenright },\tKS_bracketright },\n\t{ { KS_parenleft,\t\tKS_minus },\t\tKS_braceleft },\n\t{ { KS_slash,\t\t\tKS_minus },\t\tKS_bar },\n\t{ { KS_parenright,\t\tKS_minus },\t\tKS_braceright },\n\t{ { KS_exclam,\t\t\tKS_exclam },\t\tKS_exclamdown },\n\t{ { KS_c,\t\t\tKS_slash },\t\tKS_cent },\n\t{ { KS_l,\t\t\tKS_minus },\t\tKS_sterling },\n\t{ { KS_y,\t\t\tKS_minus },\t\tKS_yen },\n\t{ { KS_s,\t\t\tKS_o },\t\t\tKS_section },\n\t{ { KS_x,\t\t\tKS_o },\t\t\tKS_currency },\n\t{ { KS_c,\t\t\tKS_o },\t\t\tKS_copyright },\n\t{ { KS_less,\t\t\tKS_less },\t\tKS_guillemotleft },\n\t{ { KS_greater,\t\t\tKS_greater },\t\tKS_guillemotright },\n\t{ { KS_question,\t\tKS_question },\t\tKS_questiondown },\n\t{ { KS_dead_acute,\t\tKS_space },\t\tKS_acute },\n\t{ { KS_dead_grave,\t\tKS_space },\t\tKS_grave },\n\t{ { KS_dead_tilde,\t\tKS_space },\t\tKS_asciitilde },\n\t{ { KS_dead_circumflex,\t\tKS_space },\t\tKS_asciicircum },\n\t{ { KS_dead_circumflex,\t\tKS_A },\t\t\tKS_Acircumflex },\n\t{ { KS_dead_diaeresis,\t\tKS_A },\t\t\tKS_Adiaeresis },\n\t{ { KS_dead_grave,\t\tKS_A },\t\t\tKS_Agrave },\n\t{ { KS_dead_abovering,\t\tKS_A },\t\t\tKS_Aring },\n\t{ { KS_dead_tilde,\t\tKS_A },\t\t\tKS_Atilde },\n\t{ { KS_dead_cedilla,\t\tKS_C },\t\t\tKS_Ccedilla },\n\t{ { KS_dead_acute,\t\tKS_E },\t\t\tKS_Eacute },\n\t{ { KS_dead_circumflex,\t\tKS_E },\t\t\tKS_Ecircumflex },\n\t{ { KS_dead_diaeresis,\t\tKS_E },\t\t\tKS_Ediaeresis },\n\t{ { KS_dead_grave,\t\tKS_E },\t\t\tKS_Egrave },\n\t{ { KS_dead_acute,\t\tKS_I },\t\t\tKS_Iacute },\n\t{ { KS_dead_circumflex,\t\tKS_I },\t\t\tKS_Icircumflex },\n\t{ { KS_dead_diaeresis,\t\tKS_I },\t\t\tKS_Idiaeresis },\n\t{ { KS_dead_grave,\t\tKS_I },\t\t\tKS_Igrave },\n\t{ { KS_dead_tilde,\t\tKS_N },\t\t\tKS_Ntilde },\n\t{ { KS_dead_acute,\t\tKS_O },\t\t\tKS_Oacute },\n\t{ { KS_dead_circumflex,\t\tKS_O },\t\t\tKS_Ocircumflex },\n\t{ { KS_dead_diaeresis,\t\tKS_O },\t\t\tKS_Odiaeresis },\n\t{ { KS_dead_grave,\t\tKS_O },\t\t\tKS_Ograve },\n\t{ { KS_dead_tilde,\t\tKS_O },\t\t\tKS_Otilde },\n\t{ { KS_dead_acute,\t\tKS_U },\t\t\tKS_Uacute },\n\t{ { KS_dead_circumflex,\t\tKS_U },\t\t\tKS_Ucircumflex },\n\t{ { KS_dead_diaeresis,\t\tKS_U },\t\t\tKS_Udiaeresis },\n\t{ { KS_dead_grave,\t\tKS_U },\t\t\tKS_Ugrave },\n\t{ { KS_dead_acute,\t\tKS_Y },\t\t\tKS_Yacute },\n\t{ { KS_dead_acute,\t\tKS_a },\t\t\tKS_aacute },\n\t{ { KS_dead_circumflex,\t\tKS_a },\t\t\tKS_acircumflex },\n\t{ { KS_dead_diaeresis,\t\tKS_a },\t\t\tKS_adiaeresis },\n\t{ { KS_dead_grave,\t\tKS_a },\t\t\tKS_agrave },\n\t{ { KS_dead_abovering,\t\tKS_a },\t\t\tKS_aring },\n\t{ { KS_dead_tilde,\t\tKS_a },\t\t\tKS_atilde },\n\t{ { KS_dead_cedilla,\t\tKS_c },\t\t\tKS_ccedilla },\n\t{ { KS_dead_acute,\t\tKS_e },\t\t\tKS_eacute },\n\t{ { KS_dead_circumflex,\t\tKS_e },\t\t\tKS_ecircumflex },\n\t{ { KS_dead_diaeresis,\t\tKS_e },\t\t\tKS_ediaeresis },\n\t{ { KS_dead_grave,\t\tKS_e },\t\t\tKS_egrave },\n\t{ { KS_dead_acute,\t\tKS_i },\t\t\tKS_iacute },\n\t{ { KS_dead_circumflex,\t\tKS_i },\t\t\tKS_icircumflex },\n\t{ { KS_dead_diaeresis,\t\tKS_i },\t\t\tKS_idiaeresis },\n\t{ { KS_dead_grave,\t\tKS_i },\t\t\tKS_igrave },\n\t{ { KS_dead_tilde,\t\tKS_n },\t\t\tKS_ntilde },\n\t{ { KS_dead_acute,\t\tKS_o },\t\t\tKS_oacute },\n\t{ { KS_dead_circumflex,\t\tKS_o },\t\t\tKS_ocircumflex },\n\t{ { KS_dead_diaeresis,\t\tKS_o },\t\t\tKS_odiaeresis },\n\t{ { KS_dead_grave,\t\tKS_o },\t\t\tKS_ograve },\n\t{ { KS_dead_tilde,\t\tKS_o },\t\t\tKS_otilde },\n\t{ { KS_dead_acute,\t\tKS_u },\t\t\tKS_uacute },\n\t{ { KS_dead_circumflex,\t\tKS_u },\t\t\tKS_ucircumflex },\n\t{ { KS_dead_diaeresis,\t\tKS_u },\t\t\tKS_udiaeresis },\n\t{ { KS_dead_grave,\t\tKS_u },\t\t\tKS_ugrave },\n\t{ { KS_dead_acute,\t\tKS_y },\t\t\tKS_yacute },\n\t{ { KS_dead_diaeresis,\t\tKS_y },\t\t\tKS_ydiaeresis },\n\t{ { KS_quotedbl,\t\tKS_A },\t\t\tKS_Adiaeresis },\n\t{ { KS_quotedbl,\t\tKS_E },\t\t\tKS_Ediaeresis },\n\t{ { KS_quotedbl,\t\tKS_I },\t\t\tKS_Idiaeresis },\n\t{ { KS_quotedbl,\t\tKS_O },\t\t\tKS_Odiaeresis },\n\t{ { KS_quotedbl,\t\tKS_U },\t\t\tKS_Udiaeresis },\n\t{ { KS_quotedbl,\t\tKS_a },\t\t\tKS_adiaeresis },\n\t{ { KS_quotedbl,\t\tKS_e },\t\t\tKS_ediaeresis },\n\t{ { KS_quotedbl,\t\tKS_i },\t\t\tKS_idiaeresis },\n\t{ { KS_quotedbl,\t\tKS_o },\t\t\tKS_odiaeresis },\n\t{ { KS_quotedbl,\t\tKS_u },\t\t\tKS_udiaeresis },\n\t{ { KS_quotedbl,\t\tKS_y },\t\t\tKS_ydiaeresis },\n\t{ { KS_acute,\t\t\tKS_A },\t\t\tKS_Aacute },\n\t{ { KS_asciicircum,\t\tKS_A },\t\t\tKS_Acircumflex },\n\t{ { KS_grave,\t\t\tKS_A },\t\t\tKS_Agrave },\n\t{ { KS_asterisk,\t\tKS_A },\t\t\tKS_Aring },\n\t{ { KS_asciitilde,\t\tKS_A },\t\t\tKS_Atilde },\n\t{ { KS_cedilla,\t\t\tKS_C },\t\t\tKS_Ccedilla },\n\t{ { KS_acute,\t\t\tKS_E },\t\t\tKS_Eacute },\n\t{ { KS_asciicircum,\t\tKS_E },\t\t\tKS_Ecircumflex },\n\t{ { KS_grave,\t\t\tKS_E },\t\t\tKS_Egrave },\n\t{ { KS_acute,\t\t\tKS_I },\t\t\tKS_Iacute },\n\t{ { KS_asciicircum,\t\tKS_I },\t\t\tKS_Icircumflex },\n\t{ { KS_grave,\t\t\tKS_I },\t\t\tKS_Igrave },\n\t{ { KS_asciitilde,\t\tKS_N },\t\t\tKS_Ntilde },\n\t{ { KS_acute,\t\t\tKS_O },\t\t\tKS_Oacute },\n\t{ { KS_asciicircum,\t\tKS_O },\t\t\tKS_Ocircumflex },\n\t{ { KS_grave,\t\t\tKS_O },\t\t\tKS_Ograve },\n\t{ { KS_asciitilde,\t\tKS_O },\t\t\tKS_Otilde },\n\t{ { KS_acute,\t\t\tKS_U },\t\t\tKS_Uacute },\n\t{ { KS_asciicircum,\t\tKS_U },\t\t\tKS_Ucircumflex },\n\t{ { KS_grave,\t\t\tKS_U },\t\t\tKS_Ugrave },\n\t{ { KS_acute,\t\t\tKS_Y },\t\t\tKS_Yacute },\n\t{ { KS_acute,\t\t\tKS_a },\t\t\tKS_aacute },\n\t{ { KS_asciicircum,\t\tKS_a },\t\t\tKS_acircumflex },\n\t{ { KS_grave,\t\t\tKS_a },\t\t\tKS_agrave },\n\t{ { KS_asterisk,\t\tKS_a },\t\t\tKS_aring },\n\t{ { KS_asciitilde,\t\tKS_a },\t\t\tKS_atilde },\n\t{ { KS_cedilla,\t\t\tKS_c },\t\t\tKS_ccedilla },\n\t{ { KS_acute,\t\t\tKS_e },\t\t\tKS_eacute },\n\t{ { KS_asciicircum,\t\tKS_e },\t\t\tKS_ecircumflex },\n\t{ { KS_grave,\t\t\tKS_e },\t\t\tKS_egrave },\n\t{ { KS_acute,\t\t\tKS_i },\t\t\tKS_iacute },\n\t{ { KS_asciicircum,\t\tKS_i },\t\t\tKS_icircumflex },\n\t{ { KS_grave,\t\t\tKS_i },\t\t\tKS_igrave },\n\t{ { KS_asciitilde,\t\tKS_n },\t\t\tKS_ntilde },\n\t{ { KS_acute,\t\t\tKS_o },\t\t\tKS_oacute },\n\t{ { KS_asciicircum,\t\tKS_o },\t\t\tKS_ocircumflex },\n\t{ { KS_grave,\t\t\tKS_o },\t\t\tKS_ograve },\n\t{ { KS_asciitilde,\t\tKS_o },\t\t\tKS_otilde },\n\t{ { KS_acute,\t\t\tKS_u },\t\t\tKS_uacute },\n\t{ { KS_asciicircum,\t\tKS_u },\t\t\tKS_ucircumflex },\n\t{ { KS_grave,\t\t\tKS_u },\t\t\tKS_ugrave },\n\t{ { KS_acute,\t\t\tKS_y },\t\t\tKS_yacute }\n};\nstatic int compose_tab_inorder = 0;\nstatic inline int compose_tab_cmp;\n\nkeysym_t\nwskbd_compose_value(compose_buf)\n\tkeysym_t *compose_buf;\n{\n\tint i, j, r;\n\tstruct compose_tab_s v;\n\n\tif (! compose_tab_inorder) {\n\t\t/* Insertion sort. */\n\t\tfor (i = 1; i < COMPOSE_SIZE; i++) {\n\t\t\tv = compose_tab[i];\n\t\t\t/* find correct slot, moving others up */\n\t\t\tfor (j = i; --j >= 0 && compose_tab_cmp(& v, & compose_tab[j]) < 0; )\n\t\t\t\tcompose_tab[j + 1] = compose_tab[j];\n\t\t\tcompose_tab[j + 1] = v;\n\t\t}\n\t\tcompose_tab_inorder = 1;\n\t}\n\n\tfor (j = 0, i = COMPOSE_SIZE; i != 0; i /= 2) {\n\t\tif (compose_tab[j + i/2].elem[0] == compose_buf[0]) {\n\t\t\tif (compose_tab[j + i/2].elem[1] == compose_buf[1])\n\t\t\t\treturn(compose_tab[j + i/2].result);\n\t\t\tr = compose_tab[j + i/2].elem[1] < compose_buf[1];\n\t\t} else\n\t\t\tr = compose_tab[j + i/2].elem[0] < compose_buf[0];\n\t\tif (r) {\n\t\t\tj += i/2 + 1;\n\t\t\ti--;\n\t\t}\n\t}\n\n\treturn(KS_voidSymbol);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KS_GROUP",
          "args": [
            "ksym"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MOD_ONESET",
          "args": [
            "id",
            "MOD_ANYSHIFT"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MOD_ONESET",
          "args": [
            "id",
            "MOD_SHIFT_L | MOD_SHIFT_R"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MOD_ONESET",
          "args": [
            "id",
            "MOD_CAPSLOCK"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MOD_ONESET",
          "args": [
            "id",
            "MOD_ANYSHIFT | MOD_CAPSLOCK"
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MOD_ONESET",
          "args": [
            "id",
            "MOD_ANYSHIFT"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KS_GROUP",
          "args": [
            "group[1]"
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wskbd_holdscreen",
          "args": [
            "sc",
            "id->t_modifiers & MOD_HOLDSCREEN"
          ],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "wskbd_holdscreen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
          "lines": "647-667",
          "snippet": "static void\nwskbd_holdscreen(sc, hold)\n\tstruct wskbd_softc *sc;\n\tint hold;\n{\n\tint new_state;\n\n\tif (sc->sc_displaydv != NULL) {\n\t\twsdisplay_kbdholdscreen(sc->sc_displaydv, hold);\n\t\tnew_state = sc->sc_ledstate;\n\t\tif (hold)\n\t\t\tnew_state |= WSKBD_LED_SCROLL;\n\t\telse\n\t\t\tnew_state &= ~WSKBD_LED_SCROLL;\n\t\tif (new_state != sc->sc_ledstate) {\n\t\t\t(*sc->sc_accessops->set_leds)(sc->sc_accesscookie,\n\t\t\t\t\t\t      new_state);\n\t\t\tsc->sc_ledstate = new_state;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wsdisplay.h\"",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wskbdvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/malloc.h>",
            "#include <sys/timeout.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstatic void\nwskbd_holdscreen(sc, hold)\n\tstruct wskbd_softc *sc;\n\tint hold;\n{\n\tint new_state;\n\n\tif (sc->sc_displaydv != NULL) {\n\t\twsdisplay_kbdholdscreen(sc->sc_displaydv, hold);\n\t\tnew_state = sc->sc_ledstate;\n\t\tif (hold)\n\t\t\tnew_state |= WSKBD_LED_SCROLL;\n\t\telse\n\t\t\tnew_state &= ~WSKBD_LED_SCROLL;\n\t\tif (new_state != sc->sc_ledstate) {\n\t\t\t(*sc->sc_accessops->set_leds)(sc->sc_accesscookie,\n\t\t\t\t\t\t      new_state);\n\t\t\tsc->sc_ledstate = new_state;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "internal_command",
          "args": [
            "sc",
            "&type",
            "kp->command"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "internal_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
          "lines": "1276-1333",
          "snippet": "static int\ninternal_command(sc, type, ksym)\n\tstruct wskbd_softc *sc;\n\tu_int *type;\n\tkeysym_t ksym;\n{\n\tswitch (ksym) {\n\tcase KS_Cmd:\n\t\tupdate_modifier(sc->id, *type, 0, MOD_COMMAND);\n\t\tbreak;\n\n\tcase KS_Cmd1:\n\t\tupdate_modifier(sc->id, *type, 0, MOD_COMMAND1);\n\t\tbreak;\n\n\tcase KS_Cmd2:\n\t\tupdate_modifier(sc->id, *type, 0, MOD_COMMAND2);\n\t\tbreak;\n\t}\n\n\tif (*type != WSCONS_EVENT_KEY_DOWN ||\n\t    (! MOD_ONESET(sc->id, MOD_COMMAND) &&\n\t     ! MOD_ALLSET(sc->id, MOD_COMMAND1 | MOD_COMMAND2)))\n\t\treturn (0);\n\n\tswitch (ksym) {\n#ifdef DDB\n\tcase KS_Cmd_Debugger:\n\t\tif (sc->sc_isconsole)\n\t\t\tDebugger();\n\t\t/* discard this key (ddb discarded command modifiers) */\n\t\t*type = WSCONS_EVENT_KEY_UP;\n\t\treturn (1);\n#endif\n\n#if NWSDISPLAY > 0\n\tcase KS_Cmd_Screen0:\n\tcase KS_Cmd_Screen1:\n\tcase KS_Cmd_Screen2:\n\tcase KS_Cmd_Screen3:\n\tcase KS_Cmd_Screen4:\n\tcase KS_Cmd_Screen5:\n\tcase KS_Cmd_Screen6:\n\tcase KS_Cmd_Screen7:\n\tcase KS_Cmd_Screen8:\n\tcase KS_Cmd_Screen9:\n\t\twsdisplay_switch(sc->sc_displaydv, ksym - KS_Cmd_Screen0, 0);\n\t\treturn (1);\n\tcase KS_Cmd_ResetEmul:\n\t\twsdisplay_reset(sc->sc_displaydv, WSDISPLAY_RESETEMUL);\n\t\treturn (1);\n\tcase KS_Cmd_ResetClose:\n\t\twsdisplay_reset(sc->sc_displaydv, WSDISPLAY_RESETCLOSE);\n\t\treturn (1);\n#endif\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wsdisplay.h\"",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wskbdvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/malloc.h>",
            "#include <sys/timeout.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [
            "#define MOD_COMMAND2\t\t(1 << 14)",
            "#define MOD_COMMAND1\t\t(1 << 13)",
            "#define MOD_COMMAND\t\t(1 << 12)"
          ],
          "globals_used": [
            "static inline void update_modifier",
            "static int internal_command"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define MOD_COMMAND2\t\t(1 << 14)\n#define MOD_COMMAND1\t\t(1 << 13)\n#define MOD_COMMAND\t\t(1 << 12)\n\nstatic inline void update_modifier;\nstatic int internal_command;\n\nstatic int\ninternal_command(sc, type, ksym)\n\tstruct wskbd_softc *sc;\n\tu_int *type;\n\tkeysym_t ksym;\n{\n\tswitch (ksym) {\n\tcase KS_Cmd:\n\t\tupdate_modifier(sc->id, *type, 0, MOD_COMMAND);\n\t\tbreak;\n\n\tcase KS_Cmd1:\n\t\tupdate_modifier(sc->id, *type, 0, MOD_COMMAND1);\n\t\tbreak;\n\n\tcase KS_Cmd2:\n\t\tupdate_modifier(sc->id, *type, 0, MOD_COMMAND2);\n\t\tbreak;\n\t}\n\n\tif (*type != WSCONS_EVENT_KEY_DOWN ||\n\t    (! MOD_ONESET(sc->id, MOD_COMMAND) &&\n\t     ! MOD_ALLSET(sc->id, MOD_COMMAND1 | MOD_COMMAND2)))\n\t\treturn (0);\n\n\tswitch (ksym) {\n#ifdef DDB\n\tcase KS_Cmd_Debugger:\n\t\tif (sc->sc_isconsole)\n\t\t\tDebugger();\n\t\t/* discard this key (ddb discarded command modifiers) */\n\t\t*type = WSCONS_EVENT_KEY_UP;\n\t\treturn (1);\n#endif\n\n#if NWSDISPLAY > 0\n\tcase KS_Cmd_Screen0:\n\tcase KS_Cmd_Screen1:\n\tcase KS_Cmd_Screen2:\n\tcase KS_Cmd_Screen3:\n\tcase KS_Cmd_Screen4:\n\tcase KS_Cmd_Screen5:\n\tcase KS_Cmd_Screen6:\n\tcase KS_Cmd_Screen7:\n\tcase KS_Cmd_Screen8:\n\tcase KS_Cmd_Screen9:\n\t\twsdisplay_switch(sc->sc_displaydv, ksym - KS_Cmd_Screen0, 0);\n\t\treturn (1);\n\tcase KS_Cmd_ResetEmul:\n\t\twsdisplay_reset(sc->sc_displaydv, WSDISPLAY_RESETEMUL);\n\t\treturn (1);\n\tcase KS_Cmd_ResetClose:\n\t\twsdisplay_reset(sc->sc_displaydv, WSDISPLAY_RESETCLOSE);\n\t\treturn (1);\n#endif\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wskbd_get_mapentry",
          "args": [
            "id->t_keymap",
            "value",
            "kp"
          ],
          "line": 1367
        },
        "resolved": true,
        "details": {
          "function_name": "wskbd_get_mapentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbdutil.c",
          "lines": "330-380",
          "snippet": "void\nwskbd_get_mapentry(mapdata, kc, mapentry)\n\tconst struct wskbd_mapdata *mapdata;\n\tint kc;\n\tstruct wscons_keymap *mapentry;\n{\n\tkbd_t cur;\n\tconst keysym_t *kp;\n\tconst struct wscons_keydesc *mp;\n\tint l;\n\n\tmapentry->command = KS_voidSymbol;\n\tmapentry->group1[0] = KS_voidSymbol;\n\tmapentry->group1[1] = KS_voidSymbol;\n\tmapentry->group2[0] = KS_voidSymbol;\n\tmapentry->group2[1] = KS_voidSymbol;\n\n\tfor (cur = mapdata->layout & ~KB_HANDLEDBYWSKBD; cur != 0; ) {\n\t\tmp = mapdata->keydesc;\n\t\twhile (mp->map_size > 0) {\n\t\t\tif (mp->name == cur)\n\t\t\t\tbreak;\n\t\t\tmp++;\n\t\t}\n\n\t\t/* If map not found, return */\n\t\tif (mp->map_size <= 0)\n\t\t\treturn;\n\n\t\tfor (kp = mp->map; kp < mp->map + mp->map_size; kp++)\n\t\t\tif (KS_GROUP(*kp) == KS_GROUP_Keycode &&\n\t\t\t    KS_VALUE(*kp) == kc) {\n\t\t\t\t/* First skip keycode and possible command */\n\t\t\t\tkp++;\n\t\t\t\tif (KS_GROUP(*kp) == KS_GROUP_Command ||\n\t\t\t\t    *kp == KS_Cmd || *kp == KS_Cmd1 || *kp == KS_Cmd2)\n\t\t\t\t\tmapentry->command = *kp++;\n\n\t\t\t\tfor (l = 0; kp + l < mp->map + mp->map_size; l++)\n\t\t\t\t\tif (KS_GROUP(kp[l]) == KS_GROUP_Keycode)\n\t\t\t\t\t\tbreak;\n\t\t\t\tif (l > 4)\n\t\t\t\t\tpanic(\"wskbd_get_mapentry: %d(%d): bad entry\",\n\t\t\t\t\t      mp->name, *kp);\n\t\t\t\tfillmapentry(kp, l, mapentry);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\tcur = mp->base;\n\t}\n}",
          "includes": [
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdefs.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillmapentry"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/errno.h>\n#include <sys/cdefs.h>\n#include <sys/types.h>\n#include <sys/param.h>\n\nstatic void fillmapentry;\n\nvoid\nwskbd_get_mapentry(mapdata, kc, mapentry)\n\tconst struct wskbd_mapdata *mapdata;\n\tint kc;\n\tstruct wscons_keymap *mapentry;\n{\n\tkbd_t cur;\n\tconst keysym_t *kp;\n\tconst struct wscons_keydesc *mp;\n\tint l;\n\n\tmapentry->command = KS_voidSymbol;\n\tmapentry->group1[0] = KS_voidSymbol;\n\tmapentry->group1[1] = KS_voidSymbol;\n\tmapentry->group2[0] = KS_voidSymbol;\n\tmapentry->group2[1] = KS_voidSymbol;\n\n\tfor (cur = mapdata->layout & ~KB_HANDLEDBYWSKBD; cur != 0; ) {\n\t\tmp = mapdata->keydesc;\n\t\twhile (mp->map_size > 0) {\n\t\t\tif (mp->name == cur)\n\t\t\t\tbreak;\n\t\t\tmp++;\n\t\t}\n\n\t\t/* If map not found, return */\n\t\tif (mp->map_size <= 0)\n\t\t\treturn;\n\n\t\tfor (kp = mp->map; kp < mp->map + mp->map_size; kp++)\n\t\t\tif (KS_GROUP(*kp) == KS_GROUP_Keycode &&\n\t\t\t    KS_VALUE(*kp) == kc) {\n\t\t\t\t/* First skip keycode and possible command */\n\t\t\t\tkp++;\n\t\t\t\tif (KS_GROUP(*kp) == KS_GROUP_Command ||\n\t\t\t\t    *kp == KS_Cmd || *kp == KS_Cmd1 || *kp == KS_Cmd2)\n\t\t\t\t\tmapentry->command = *kp++;\n\n\t\t\t\tfor (l = 0; kp + l < mp->map + mp->map_size; l++)\n\t\t\t\t\tif (KS_GROUP(kp[l]) == KS_GROUP_Keycode)\n\t\t\t\t\t\tbreak;\n\t\t\t\tif (l > 4)\n\t\t\t\t\tpanic(\"wskbd_get_mapentry: %d(%d): bad entry\",\n\t\t\t\t\t      mp->name, *kp);\n\t\t\t\tfillmapentry(kp, l, mapentry);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\tcur = mp->base;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"wskbd_translate: keycode %d out of range\\n\"",
            "value"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define MOD_ANYMETA\t\t(MOD_META_L | MOD_META_R)\n#define MOD_ANYCONTROL\t\t(MOD_CONTROL_L | MOD_CONTROL_R)\n#define MOD_ANYSHIFT\t\t(MOD_SHIFT_L | MOD_SHIFT_R | MOD_SHIFTLOCK)\n#define MOD_COMMAND2\t\t(1 << 14)\n#define MOD_COMMAND1\t\t(1 << 13)\n#define MOD_COMMAND\t\t(1 << 12)\n#define MOD_HOLDSCREEN\t\t(1 << 11)\n#define MOD_COMPOSE\t\t(1 << 10)\n#define MOD_NUMLOCK\t\t(1 << 9)\n#define MOD_MODESHIFT\t\t(1 << 8)\n#define MOD_META_R\t\t(1 << 7)\n#define MOD_META_L\t\t(1 << 6)\n#define MOD_CONTROL_R\t\t(1 << 5)\n#define MOD_CONTROL_L\t\t(1 << 4)\n#define MOD_CAPSLOCK\t\t(1 << 3)\n#define MOD_SHIFTLOCK\t\t(1 << 2)\n#define MOD_SHIFT_R\t\t(1 << 1)\n#define MOD_SHIFT_L\t\t(1 << 0)\n#define WSKFL_METAESC 1\n\nstatic inline void update_leds;\nstatic inline void update_modifier;\nstatic int internal_command;\nstatic int wskbd_translate;\n\nstatic int\nwskbd_translate(id, type, value)\n\tstruct wskbd_internal *id;\n\tu_int type;\n\tint value;\n{\n\tstruct wskbd_softc *sc = id->t_sc;\n\tkeysym_t ksym, res, *group;\n\tstruct wscons_keymap kpbuf, *kp;\n\tint iscommand = 0;\n\n\tif (type == WSCONS_EVENT_ALL_KEYS_UP) {\n\t\tid->t_modifiers &= ~(MOD_SHIFT_L | MOD_SHIFT_R\n\t\t\t\t| MOD_CONTROL_L | MOD_CONTROL_R\n\t\t\t\t| MOD_META_L | MOD_META_R\n\t\t\t\t| MOD_MODESHIFT\n\t\t\t\t| MOD_COMMAND | MOD_COMMAND1 | MOD_COMMAND2);\n\t\tupdate_leds(id);\n\t\treturn (0);\n\t}\n\n\tif (sc != NULL) {\n\t\tif (value < 0 || value >= sc->sc_maplen) {\n#ifdef DEBUG\n\t\t\tprintf(\"wskbd_translate: keycode %d out of range\\n\",\n\t\t\t       value);\n#endif\n\t\t\treturn (0);\n\t\t}\n\t\tkp = sc->sc_map + value;\n\t} else {\n\t\tkp = &kpbuf;\n\t\twskbd_get_mapentry(id->t_keymap, value, kp);\n\t}\n\n\t/* if this key has a command, process it first */\n\tif (sc != NULL && kp->command != KS_voidSymbol)\n\t\tiscommand = internal_command(sc, &type, kp->command);\n\n\t/* Now update modifiers */\n\tswitch (kp->group1[0]) {\n\tcase KS_Shift_L:\n\t\tupdate_modifier(id, type, 0, MOD_SHIFT_L);\n\t\tbreak;\n\n\tcase KS_Shift_R:\n\t\tupdate_modifier(id, type, 0, MOD_SHIFT_R);\n\t\tbreak;\n\n\tcase KS_Shift_Lock:\n\t\tupdate_modifier(id, type, 1, MOD_SHIFTLOCK);\n\t\tbreak;\n\n\tcase KS_Caps_Lock:\n\t\tupdate_modifier(id, type, 1, MOD_CAPSLOCK);\n\t\tbreak;\n\n\tcase KS_Control_L:\n\t\tupdate_modifier(id, type, 0, MOD_CONTROL_L);\n\t\tbreak;\n\n\tcase KS_Control_R:\n\t\tupdate_modifier(id, type, 0, MOD_CONTROL_R);\n\t\tbreak;\n\n\tcase KS_Alt_L:\n\t\tupdate_modifier(id, type, 0, MOD_META_L);\n\t\tbreak;\n\n\tcase KS_Alt_R:\n\t\tupdate_modifier(id, type, 0, MOD_META_R);\n\t\tbreak;\n\n\tcase KS_Mode_switch:\n\t\tupdate_modifier(id, type, 0, MOD_MODESHIFT);\n\t\tbreak;\n\n\tcase KS_Num_Lock:\n\t\tupdate_modifier(id, type, 1, MOD_NUMLOCK);\n\t\tbreak;\n\n#if NWSDISPLAY > 0\n\tcase KS_Hold_Screen:\n\t\tif (sc != NULL) {\n\t\t\tupdate_modifier(id, type, 1, MOD_HOLDSCREEN);\n\t\t\twskbd_holdscreen(sc, id->t_modifiers & MOD_HOLDSCREEN);\n\t\t}\n\t\tbreak;\n#endif\n\t}\n\n\t/* If this is a key release or we are in command mode, we are done */\n\tif (type != WSCONS_EVENT_KEY_DOWN || iscommand) {\n\t\tupdate_leds(id);\n\t\treturn (0);\n\t}\n\n\t/* Get the keysym */\n\tif (id->t_modifiers & MOD_MODESHIFT)\n\t\tgroup = & kp->group2[0];\n\telse\n\t\tgroup = & kp->group1[0];\n\n\tif ((id->t_modifiers & MOD_NUMLOCK) != 0 &&\n\t    KS_GROUP(group[1]) == KS_GROUP_Keypad) {\n\t\tif (MOD_ONESET(id, MOD_ANYSHIFT))\n\t\t\tksym = group[0];\n\t\telse\n\t\t\tksym = group[1];\n\t} else if (! MOD_ONESET(id, MOD_ANYSHIFT | MOD_CAPSLOCK)) {\n\t\tksym = group[0];\n\t} else if (MOD_ONESET(id, MOD_CAPSLOCK)) {\n\t\tif (! MOD_ONESET(id, MOD_SHIFT_L | MOD_SHIFT_R))\n\t\t\tksym = group[0];\n\t\telse\n\t\t\tksym = group[1];\n\t\tif (ksym >= KS_a && ksym <= KS_z)\n\t\t\tksym += KS_A - KS_a;\n\t\telse if (ksym >= KS_agrave && ksym <= KS_thorn &&\n\t\t\t ksym != KS_division)\n\t\t\tksym += KS_Agrave - KS_agrave;\n\t} else if (MOD_ONESET(id, MOD_ANYSHIFT)) {\n\t\tksym = group[1];\n\t} else {\n\t\tksym = group[0];\n\t}\n\n\t/* Process compose sequence and dead accents */\n\tres = KS_voidSymbol;\n\n\tswitch (KS_GROUP(ksym)) {\n\tcase KS_GROUP_Ascii:\n\tcase KS_GROUP_Keypad:\n\tcase KS_GROUP_Function:\n\t\tres = ksym;\n\t\tbreak;\n\n\tcase KS_GROUP_Mod:\n\t\tif (ksym == KS_Multi_key) {\n\t\t\tupdate_modifier(id, 1, 0, MOD_COMPOSE);\n\t\t\tid->t_composelen = 2;\n\t\t}\n\t\tbreak;\n\n\tcase KS_GROUP_Dead:\n\t\tif (id->t_composelen == 0) {\n\t\t\tupdate_modifier(id, 1, 0, MOD_COMPOSE);\n\t\t\tid->t_composelen = 1;\n\t\t\tid->t_composebuf[0] = ksym;\n\t\t} else\n\t\t\tres = ksym;\n\t\tbreak;\n\t}\n\n\tif (res == KS_voidSymbol) {\n\t\tupdate_leds(id);\n\t\treturn (0);\n\t}\n\n\tif (id->t_composelen > 0) {\n\t\tid->t_composebuf[2 - id->t_composelen] = res;\n\t\tif (--id->t_composelen == 0) {\n\t\t\tres = wskbd_compose_value(id->t_composebuf);\n\t\t\tupdate_modifier(id, 0, 0, MOD_COMPOSE);\n\t\t} else {\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\tupdate_leds(id);\n\n\t/* We are done, return the symbol */\n\tif (KS_GROUP(res) == KS_GROUP_Ascii) {\n\t\tif (MOD_ONESET(id, MOD_ANYCONTROL)) {\n\t\t\tif ((res >= KS_at && res <= KS_z) || res == KS_space)\n\t\t\t\tres = res & 0x1f;\n\t\t\telse if (res == KS_2)\n\t\t\t\tres = 0x00;\n\t\t\telse if (res >= KS_3 && res <= KS_7)\n\t\t\t\tres = KS_Escape + (res - KS_3);\n\t\t\telse if (res == KS_8)\n\t\t\t\tres = KS_Delete;\n\t\t}\n\t\tif (MOD_ONESET(id, MOD_ANYMETA)) {\n\t\t\tif (id->t_flags & WSKFL_METAESC) {\n\t\t\t\tid->t_symbols[0] = KS_Escape;\n\t\t\t\tid->t_symbols[1] = res;\n\t\t\t\treturn (2);\n\t\t\t} else\n\t\t\tres |= 0x80;\n\t}\n\t}\n\n\tid->t_symbols[0] = res;\n\treturn (1);\n}"
  },
  {
    "function_name": "internal_command",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
    "lines": "1276-1333",
    "snippet": "static int\ninternal_command(sc, type, ksym)\n\tstruct wskbd_softc *sc;\n\tu_int *type;\n\tkeysym_t ksym;\n{\n\tswitch (ksym) {\n\tcase KS_Cmd:\n\t\tupdate_modifier(sc->id, *type, 0, MOD_COMMAND);\n\t\tbreak;\n\n\tcase KS_Cmd1:\n\t\tupdate_modifier(sc->id, *type, 0, MOD_COMMAND1);\n\t\tbreak;\n\n\tcase KS_Cmd2:\n\t\tupdate_modifier(sc->id, *type, 0, MOD_COMMAND2);\n\t\tbreak;\n\t}\n\n\tif (*type != WSCONS_EVENT_KEY_DOWN ||\n\t    (! MOD_ONESET(sc->id, MOD_COMMAND) &&\n\t     ! MOD_ALLSET(sc->id, MOD_COMMAND1 | MOD_COMMAND2)))\n\t\treturn (0);\n\n\tswitch (ksym) {\n#ifdef DDB\n\tcase KS_Cmd_Debugger:\n\t\tif (sc->sc_isconsole)\n\t\t\tDebugger();\n\t\t/* discard this key (ddb discarded command modifiers) */\n\t\t*type = WSCONS_EVENT_KEY_UP;\n\t\treturn (1);\n#endif\n\n#if NWSDISPLAY > 0\n\tcase KS_Cmd_Screen0:\n\tcase KS_Cmd_Screen1:\n\tcase KS_Cmd_Screen2:\n\tcase KS_Cmd_Screen3:\n\tcase KS_Cmd_Screen4:\n\tcase KS_Cmd_Screen5:\n\tcase KS_Cmd_Screen6:\n\tcase KS_Cmd_Screen7:\n\tcase KS_Cmd_Screen8:\n\tcase KS_Cmd_Screen9:\n\t\twsdisplay_switch(sc->sc_displaydv, ksym - KS_Cmd_Screen0, 0);\n\t\treturn (1);\n\tcase KS_Cmd_ResetEmul:\n\t\twsdisplay_reset(sc->sc_displaydv, WSDISPLAY_RESETEMUL);\n\t\treturn (1);\n\tcase KS_Cmd_ResetClose:\n\t\twsdisplay_reset(sc->sc_displaydv, WSDISPLAY_RESETCLOSE);\n\t\treturn (1);\n#endif\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wsdisplay.h\"",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wskbdvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [
      "#define MOD_COMMAND2\t\t(1 << 14)",
      "#define MOD_COMMAND1\t\t(1 << 13)",
      "#define MOD_COMMAND\t\t(1 << 12)"
    ],
    "globals_used": [
      "static inline void update_modifier",
      "static int internal_command"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wsdisplay_reset",
          "args": [
            "sc->sc_displaydv",
            "WSDISPLAY_RESETCLOSE"
          ],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "wsdisplay_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "1547-1572",
          "snippet": "void\nwsdisplay_reset(dev, op)\n\tstruct device *dev;\n\tenum wsdisplay_resetops op;\n{\n\tstruct wsdisplay_softc *sc = (struct wsdisplay_softc *)dev;\n\tstruct wsscreen *scr;\n\n\tKASSERT(sc != NULL);\n\tscr = sc->sc_focus;\n\n\tif (!scr)\n\t\treturn;\n\n\tswitch (op) {\n\tcase WSDISPLAY_RESETEMUL:\n\t\tif (!WSSCREEN_HAS_EMULATOR(scr))\n\t\t\tbreak;\n\t\t(*scr->scr_dconf->wsemul->reset)(scr->scr_dconf->wsemulcookie,\n\t\t\t\t\t\t WSEMUL_RESET);\n\t\tbreak;\n\tcase WSDISPLAY_RESETCLOSE:\n\t\twsdisplay_closescreen(sc, scr);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wsdisplay_closescreen",
            "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;",
            "struct tty *\nwsdisplaytty(dev)\n\tdev_t dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstatic void wsdisplay_closescreen;\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\nstruct tty *\nwsdisplaytty(dev)\n\tdev_t dev;\n\nvoid\nwsdisplay_reset(dev, op)\n\tstruct device *dev;\n\tenum wsdisplay_resetops op;\n{\n\tstruct wsdisplay_softc *sc = (struct wsdisplay_softc *)dev;\n\tstruct wsscreen *scr;\n\n\tKASSERT(sc != NULL);\n\tscr = sc->sc_focus;\n\n\tif (!scr)\n\t\treturn;\n\n\tswitch (op) {\n\tcase WSDISPLAY_RESETEMUL:\n\t\tif (!WSSCREEN_HAS_EMULATOR(scr))\n\t\t\tbreak;\n\t\t(*scr->scr_dconf->wsemul->reset)(scr->scr_dconf->wsemulcookie,\n\t\t\t\t\t\t WSEMUL_RESET);\n\t\tbreak;\n\tcase WSDISPLAY_RESETCLOSE:\n\t\twsdisplay_closescreen(sc, scr);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wsdisplay_switch",
          "args": [
            "sc->sc_displaydv",
            "ksym - KS_Cmd_Screen0",
            "0"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "wsdisplay_switchtoconsole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "1769-1775",
          "snippet": "void\nwsdisplay_switchtoconsole()\n{\n\tif (wsdisplay_console_device != NULL)\n\t\twsdisplay_switch((struct device *)wsdisplay_console_device, \n\t\t    0, 0);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct wsdisplay_softc *wsdisplay_console_device;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstatic struct wsdisplay_softc *wsdisplay_console_device;\n\nvoid\nwsdisplay_switchtoconsole()\n{\n\tif (wsdisplay_console_device != NULL)\n\t\twsdisplay_switch((struct device *)wsdisplay_console_device, \n\t\t    0, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Debugger",
          "args": [],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MOD_ALLSET",
          "args": [
            "sc->id",
            "MOD_COMMAND1 | MOD_COMMAND2"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MOD_ONESET",
          "args": [
            "sc->id",
            "MOD_COMMAND"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_modifier",
          "args": [
            "sc->id",
            "*type",
            "0",
            "MOD_COMMAND2"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "update_modifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
          "lines": "1258-1274",
          "snippet": "static inline void\nupdate_modifier(id, type, toggle, mask)\n\tstruct wskbd_internal *id;\n\tu_int type;\n\tint toggle;\n\tint mask;\n{\n\tif (toggle) {\n\t\tif (type == WSCONS_EVENT_KEY_DOWN)\n\t\t\tid->t_modifiers ^= mask;\n\t} else {\n\t\tif (type == WSCONS_EVENT_KEY_DOWN)\n\t\t\tid->t_modifiers |= mask;\n\t\telse\n\t\t\tid->t_modifiers &= ~mask;\n\t}\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wsdisplay.h\"",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wskbdvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/malloc.h>",
            "#include <sys/timeout.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void update_modifier"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstatic inline void update_modifier;\n\nstatic inline void\nupdate_modifier(id, type, toggle, mask)\n\tstruct wskbd_internal *id;\n\tu_int type;\n\tint toggle;\n\tint mask;\n{\n\tif (toggle) {\n\t\tif (type == WSCONS_EVENT_KEY_DOWN)\n\t\t\tid->t_modifiers ^= mask;\n\t} else {\n\t\tif (type == WSCONS_EVENT_KEY_DOWN)\n\t\t\tid->t_modifiers |= mask;\n\t\telse\n\t\t\tid->t_modifiers &= ~mask;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define MOD_COMMAND2\t\t(1 << 14)\n#define MOD_COMMAND1\t\t(1 << 13)\n#define MOD_COMMAND\t\t(1 << 12)\n\nstatic inline void update_modifier;\nstatic int internal_command;\n\nstatic int\ninternal_command(sc, type, ksym)\n\tstruct wskbd_softc *sc;\n\tu_int *type;\n\tkeysym_t ksym;\n{\n\tswitch (ksym) {\n\tcase KS_Cmd:\n\t\tupdate_modifier(sc->id, *type, 0, MOD_COMMAND);\n\t\tbreak;\n\n\tcase KS_Cmd1:\n\t\tupdate_modifier(sc->id, *type, 0, MOD_COMMAND1);\n\t\tbreak;\n\n\tcase KS_Cmd2:\n\t\tupdate_modifier(sc->id, *type, 0, MOD_COMMAND2);\n\t\tbreak;\n\t}\n\n\tif (*type != WSCONS_EVENT_KEY_DOWN ||\n\t    (! MOD_ONESET(sc->id, MOD_COMMAND) &&\n\t     ! MOD_ALLSET(sc->id, MOD_COMMAND1 | MOD_COMMAND2)))\n\t\treturn (0);\n\n\tswitch (ksym) {\n#ifdef DDB\n\tcase KS_Cmd_Debugger:\n\t\tif (sc->sc_isconsole)\n\t\t\tDebugger();\n\t\t/* discard this key (ddb discarded command modifiers) */\n\t\t*type = WSCONS_EVENT_KEY_UP;\n\t\treturn (1);\n#endif\n\n#if NWSDISPLAY > 0\n\tcase KS_Cmd_Screen0:\n\tcase KS_Cmd_Screen1:\n\tcase KS_Cmd_Screen2:\n\tcase KS_Cmd_Screen3:\n\tcase KS_Cmd_Screen4:\n\tcase KS_Cmd_Screen5:\n\tcase KS_Cmd_Screen6:\n\tcase KS_Cmd_Screen7:\n\tcase KS_Cmd_Screen8:\n\tcase KS_Cmd_Screen9:\n\t\twsdisplay_switch(sc->sc_displaydv, ksym - KS_Cmd_Screen0, 0);\n\t\treturn (1);\n\tcase KS_Cmd_ResetEmul:\n\t\twsdisplay_reset(sc->sc_displaydv, WSDISPLAY_RESETEMUL);\n\t\treturn (1);\n\tcase KS_Cmd_ResetClose:\n\t\twsdisplay_reset(sc->sc_displaydv, WSDISPLAY_RESETCLOSE);\n\t\treturn (1);\n#endif\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "update_modifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
    "lines": "1258-1274",
    "snippet": "static inline void\nupdate_modifier(id, type, toggle, mask)\n\tstruct wskbd_internal *id;\n\tu_int type;\n\tint toggle;\n\tint mask;\n{\n\tif (toggle) {\n\t\tif (type == WSCONS_EVENT_KEY_DOWN)\n\t\t\tid->t_modifiers ^= mask;\n\t} else {\n\t\tif (type == WSCONS_EVENT_KEY_DOWN)\n\t\t\tid->t_modifiers |= mask;\n\t\telse\n\t\t\tid->t_modifiers &= ~mask;\n\t}\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wsdisplay.h\"",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wskbdvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void update_modifier"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstatic inline void update_modifier;\n\nstatic inline void\nupdate_modifier(id, type, toggle, mask)\n\tstruct wskbd_internal *id;\n\tu_int type;\n\tint toggle;\n\tint mask;\n{\n\tif (toggle) {\n\t\tif (type == WSCONS_EVENT_KEY_DOWN)\n\t\t\tid->t_modifiers ^= mask;\n\t} else {\n\t\tif (type == WSCONS_EVENT_KEY_DOWN)\n\t\t\tid->t_modifiers |= mask;\n\t\telse\n\t\t\tid->t_modifiers &= ~mask;\n\t}\n}"
  },
  {
    "function_name": "update_leds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
    "lines": "1235-1256",
    "snippet": "static inline void\nupdate_leds(id)\n\tstruct wskbd_internal *id;\n{\n\tint new_state;\n\n\tnew_state = 0;\n\tif (id->t_modifiers & (MOD_SHIFTLOCK | MOD_CAPSLOCK))\n\t\tnew_state |= WSKBD_LED_CAPS;\n\tif (id->t_modifiers & MOD_NUMLOCK)\n\t\tnew_state |= WSKBD_LED_NUM;\n\tif (id->t_modifiers & MOD_COMPOSE)\n\t\tnew_state |= WSKBD_LED_COMPOSE;\n\tif (id->t_modifiers & MOD_HOLDSCREEN)\n\t\tnew_state |= WSKBD_LED_SCROLL;\n\n\tif (id->t_sc && new_state != id->t_sc->sc_ledstate) {\n\t\t(*id->t_sc->sc_accessops->set_leds)\n\t\t    (id->t_sc->sc_accesscookie, new_state);\n\t\tid->t_sc->sc_ledstate = new_state;\n\t}\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wsdisplay.h\"",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wskbdvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [
      "#define MOD_HOLDSCREEN\t\t(1 << 11)",
      "#define MOD_COMPOSE\t\t(1 << 10)",
      "#define MOD_NUMLOCK\t\t(1 << 9)",
      "#define MOD_CAPSLOCK\t\t(1 << 3)",
      "#define MOD_SHIFTLOCK\t\t(1 << 2)"
    ],
    "globals_used": [
      "static inline void update_leds"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "id->t_sc->sc_accesscookie",
            "new_state"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define MOD_HOLDSCREEN\t\t(1 << 11)\n#define MOD_COMPOSE\t\t(1 << 10)\n#define MOD_NUMLOCK\t\t(1 << 9)\n#define MOD_CAPSLOCK\t\t(1 << 3)\n#define MOD_SHIFTLOCK\t\t(1 << 2)\n\nstatic inline void update_leds;\n\nstatic inline void\nupdate_leds(id)\n\tstruct wskbd_internal *id;\n{\n\tint new_state;\n\n\tnew_state = 0;\n\tif (id->t_modifiers & (MOD_SHIFTLOCK | MOD_CAPSLOCK))\n\t\tnew_state |= WSKBD_LED_CAPS;\n\tif (id->t_modifiers & MOD_NUMLOCK)\n\t\tnew_state |= WSKBD_LED_NUM;\n\tif (id->t_modifiers & MOD_COMPOSE)\n\t\tnew_state |= WSKBD_LED_COMPOSE;\n\tif (id->t_modifiers & MOD_HOLDSCREEN)\n\t\tnew_state |= WSKBD_LED_SCROLL;\n\n\tif (id->t_sc && new_state != id->t_sc->sc_ledstate) {\n\t\t(*id->t_sc->sc_accessops->set_leds)\n\t\t    (id->t_sc->sc_accesscookie, new_state);\n\t\tid->t_sc->sc_ledstate = new_state;\n\t}\n}"
  },
  {
    "function_name": "wskbd_cnbell",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
    "lines": "1220-1233",
    "snippet": "void\nwskbd_cnbell(dev, pitch, period, volume)\n\tdev_t dev;\n\tu_int pitch, period, volume;\n{\n\n\tif (!wskbd_console_initted)\n\t\treturn;\n\n\tif (wskbd_console_data.t_consops->bell != NULL)\n\t\t(*wskbd_console_data.t_consops->bell)\n\t\t    (wskbd_console_data.t_consaccesscookie, pitch, period,\n\t\t\tvolume);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wsdisplay.h\"",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wskbdvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int wskbd_console_initted;",
      "static struct wskbd_internal wskbd_console_data;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "wskbd_console_data.t_consaccesscookie",
            "pitch",
            "period",
            "volume"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstatic int wskbd_console_initted;\nstatic struct wskbd_internal wskbd_console_data;\n\nvoid\nwskbd_cnbell(dev, pitch, period, volume)\n\tdev_t dev;\n\tu_int pitch, period, volume;\n{\n\n\tif (!wskbd_console_initted)\n\t\treturn;\n\n\tif (wskbd_console_data.t_consops->bell != NULL)\n\t\t(*wskbd_console_data.t_consops->bell)\n\t\t    (wskbd_console_data.t_consaccesscookie, pitch, period,\n\t\t\tvolume);\n}"
  },
  {
    "function_name": "wskbd_cnpollc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
    "lines": "1203-1218",
    "snippet": "void\nwskbd_cnpollc(dev, poll)\n\tdev_t dev;\n\tint poll;\n{\n\n\tif (!wskbd_console_initted)\n\t\treturn;\n\n\tif (wskbd_console_device != NULL &&\n\t    !wskbd_console_device->sc_translating)\n\t\treturn;\n\n\t(*wskbd_console_data.t_consops->pollc)\n\t    (wskbd_console_data.t_consaccesscookie, poll);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wsdisplay.h\"",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wskbdvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int wskbd_console_initted;",
      "static struct wskbd_softc *wskbd_console_device;",
      "static struct wskbd_internal wskbd_console_data;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "wskbd_console_data.t_consaccesscookie",
            "poll"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstatic int wskbd_console_initted;\nstatic struct wskbd_softc *wskbd_console_device;\nstatic struct wskbd_internal wskbd_console_data;\n\nvoid\nwskbd_cnpollc(dev, poll)\n\tdev_t dev;\n\tint poll;\n{\n\n\tif (!wskbd_console_initted)\n\t\treturn;\n\n\tif (wskbd_console_device != NULL &&\n\t    !wskbd_console_device->sc_translating)\n\t\treturn;\n\n\t(*wskbd_console_data.t_consops->pollc)\n\t    (wskbd_console_data.t_consaccesscookie, poll);\n}"
  },
  {
    "function_name": "wskbd_cngetc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
    "lines": "1171-1201",
    "snippet": "int\nwskbd_cngetc(dev)\n\tdev_t dev;\n{\n\tstatic int num = 0;\n\tstatic int pos;\n\tu_int type;\n\tint data;\n\tkeysym_t ks;\n\n\tif (!wskbd_console_initted)\n\t\treturn 0;\n\n\tif (wskbd_console_device != NULL &&\n\t    !wskbd_console_device->sc_translating)\n\t\treturn 0;\n\n\tfor(;;) {\n\t\tif (num-- > 0) {\n\t\t\tks = wskbd_console_data.t_symbols[pos++];\n\t\tif (KS_GROUP(ks) == KS_GROUP_Ascii)\n\t\t\treturn (KS_VALUE(ks));\t\n\t\t} else {\n\t\t\t(*wskbd_console_data.t_consops->getc)\n\t\t\t\t(wskbd_console_data.t_consaccesscookie,\n\t\t\t\t &type, &data);\n\t\t\tnum = wskbd_translate(&wskbd_console_data, type, data);\n\t\t\tpos = 0;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wsdisplay.h\"",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wskbdvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int wskbd_translate",
      "static int wskbd_console_initted;",
      "static struct wskbd_softc *wskbd_console_device;",
      "static struct wskbd_internal wskbd_console_data;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wskbd_translate",
          "args": [
            "&wskbd_console_data",
            "type",
            "data"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "wskbd_translate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
          "lines": "1335-1530",
          "snippet": "static int\nwskbd_translate(id, type, value)\n\tstruct wskbd_internal *id;\n\tu_int type;\n\tint value;\n{\n\tstruct wskbd_softc *sc = id->t_sc;\n\tkeysym_t ksym, res, *group;\n\tstruct wscons_keymap kpbuf, *kp;\n\tint iscommand = 0;\n\n\tif (type == WSCONS_EVENT_ALL_KEYS_UP) {\n\t\tid->t_modifiers &= ~(MOD_SHIFT_L | MOD_SHIFT_R\n\t\t\t\t| MOD_CONTROL_L | MOD_CONTROL_R\n\t\t\t\t| MOD_META_L | MOD_META_R\n\t\t\t\t| MOD_MODESHIFT\n\t\t\t\t| MOD_COMMAND | MOD_COMMAND1 | MOD_COMMAND2);\n\t\tupdate_leds(id);\n\t\treturn (0);\n\t}\n\n\tif (sc != NULL) {\n\t\tif (value < 0 || value >= sc->sc_maplen) {\n#ifdef DEBUG\n\t\t\tprintf(\"wskbd_translate: keycode %d out of range\\n\",\n\t\t\t       value);\n#endif\n\t\t\treturn (0);\n\t\t}\n\t\tkp = sc->sc_map + value;\n\t} else {\n\t\tkp = &kpbuf;\n\t\twskbd_get_mapentry(id->t_keymap, value, kp);\n\t}\n\n\t/* if this key has a command, process it first */\n\tif (sc != NULL && kp->command != KS_voidSymbol)\n\t\tiscommand = internal_command(sc, &type, kp->command);\n\n\t/* Now update modifiers */\n\tswitch (kp->group1[0]) {\n\tcase KS_Shift_L:\n\t\tupdate_modifier(id, type, 0, MOD_SHIFT_L);\n\t\tbreak;\n\n\tcase KS_Shift_R:\n\t\tupdate_modifier(id, type, 0, MOD_SHIFT_R);\n\t\tbreak;\n\n\tcase KS_Shift_Lock:\n\t\tupdate_modifier(id, type, 1, MOD_SHIFTLOCK);\n\t\tbreak;\n\n\tcase KS_Caps_Lock:\n\t\tupdate_modifier(id, type, 1, MOD_CAPSLOCK);\n\t\tbreak;\n\n\tcase KS_Control_L:\n\t\tupdate_modifier(id, type, 0, MOD_CONTROL_L);\n\t\tbreak;\n\n\tcase KS_Control_R:\n\t\tupdate_modifier(id, type, 0, MOD_CONTROL_R);\n\t\tbreak;\n\n\tcase KS_Alt_L:\n\t\tupdate_modifier(id, type, 0, MOD_META_L);\n\t\tbreak;\n\n\tcase KS_Alt_R:\n\t\tupdate_modifier(id, type, 0, MOD_META_R);\n\t\tbreak;\n\n\tcase KS_Mode_switch:\n\t\tupdate_modifier(id, type, 0, MOD_MODESHIFT);\n\t\tbreak;\n\n\tcase KS_Num_Lock:\n\t\tupdate_modifier(id, type, 1, MOD_NUMLOCK);\n\t\tbreak;\n\n#if NWSDISPLAY > 0\n\tcase KS_Hold_Screen:\n\t\tif (sc != NULL) {\n\t\t\tupdate_modifier(id, type, 1, MOD_HOLDSCREEN);\n\t\t\twskbd_holdscreen(sc, id->t_modifiers & MOD_HOLDSCREEN);\n\t\t}\n\t\tbreak;\n#endif\n\t}\n\n\t/* If this is a key release or we are in command mode, we are done */\n\tif (type != WSCONS_EVENT_KEY_DOWN || iscommand) {\n\t\tupdate_leds(id);\n\t\treturn (0);\n\t}\n\n\t/* Get the keysym */\n\tif (id->t_modifiers & MOD_MODESHIFT)\n\t\tgroup = & kp->group2[0];\n\telse\n\t\tgroup = & kp->group1[0];\n\n\tif ((id->t_modifiers & MOD_NUMLOCK) != 0 &&\n\t    KS_GROUP(group[1]) == KS_GROUP_Keypad) {\n\t\tif (MOD_ONESET(id, MOD_ANYSHIFT))\n\t\t\tksym = group[0];\n\t\telse\n\t\t\tksym = group[1];\n\t} else if (! MOD_ONESET(id, MOD_ANYSHIFT | MOD_CAPSLOCK)) {\n\t\tksym = group[0];\n\t} else if (MOD_ONESET(id, MOD_CAPSLOCK)) {\n\t\tif (! MOD_ONESET(id, MOD_SHIFT_L | MOD_SHIFT_R))\n\t\t\tksym = group[0];\n\t\telse\n\t\t\tksym = group[1];\n\t\tif (ksym >= KS_a && ksym <= KS_z)\n\t\t\tksym += KS_A - KS_a;\n\t\telse if (ksym >= KS_agrave && ksym <= KS_thorn &&\n\t\t\t ksym != KS_division)\n\t\t\tksym += KS_Agrave - KS_agrave;\n\t} else if (MOD_ONESET(id, MOD_ANYSHIFT)) {\n\t\tksym = group[1];\n\t} else {\n\t\tksym = group[0];\n\t}\n\n\t/* Process compose sequence and dead accents */\n\tres = KS_voidSymbol;\n\n\tswitch (KS_GROUP(ksym)) {\n\tcase KS_GROUP_Ascii:\n\tcase KS_GROUP_Keypad:\n\tcase KS_GROUP_Function:\n\t\tres = ksym;\n\t\tbreak;\n\n\tcase KS_GROUP_Mod:\n\t\tif (ksym == KS_Multi_key) {\n\t\t\tupdate_modifier(id, 1, 0, MOD_COMPOSE);\n\t\t\tid->t_composelen = 2;\n\t\t}\n\t\tbreak;\n\n\tcase KS_GROUP_Dead:\n\t\tif (id->t_composelen == 0) {\n\t\t\tupdate_modifier(id, 1, 0, MOD_COMPOSE);\n\t\t\tid->t_composelen = 1;\n\t\t\tid->t_composebuf[0] = ksym;\n\t\t} else\n\t\t\tres = ksym;\n\t\tbreak;\n\t}\n\n\tif (res == KS_voidSymbol) {\n\t\tupdate_leds(id);\n\t\treturn (0);\n\t}\n\n\tif (id->t_composelen > 0) {\n\t\tid->t_composebuf[2 - id->t_composelen] = res;\n\t\tif (--id->t_composelen == 0) {\n\t\t\tres = wskbd_compose_value(id->t_composebuf);\n\t\t\tupdate_modifier(id, 0, 0, MOD_COMPOSE);\n\t\t} else {\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\tupdate_leds(id);\n\n\t/* We are done, return the symbol */\n\tif (KS_GROUP(res) == KS_GROUP_Ascii) {\n\t\tif (MOD_ONESET(id, MOD_ANYCONTROL)) {\n\t\t\tif ((res >= KS_at && res <= KS_z) || res == KS_space)\n\t\t\t\tres = res & 0x1f;\n\t\t\telse if (res == KS_2)\n\t\t\t\tres = 0x00;\n\t\t\telse if (res >= KS_3 && res <= KS_7)\n\t\t\t\tres = KS_Escape + (res - KS_3);\n\t\t\telse if (res == KS_8)\n\t\t\t\tres = KS_Delete;\n\t\t}\n\t\tif (MOD_ONESET(id, MOD_ANYMETA)) {\n\t\t\tif (id->t_flags & WSKFL_METAESC) {\n\t\t\t\tid->t_symbols[0] = KS_Escape;\n\t\t\t\tid->t_symbols[1] = res;\n\t\t\t\treturn (2);\n\t\t\t} else\n\t\t\tres |= 0x80;\n\t}\n\t}\n\n\tid->t_symbols[0] = res;\n\treturn (1);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wsdisplay.h\"",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wskbdvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/malloc.h>",
            "#include <sys/timeout.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [
            "#define MOD_ANYMETA\t\t(MOD_META_L | MOD_META_R)",
            "#define MOD_ANYCONTROL\t\t(MOD_CONTROL_L | MOD_CONTROL_R)",
            "#define MOD_ANYSHIFT\t\t(MOD_SHIFT_L | MOD_SHIFT_R | MOD_SHIFTLOCK)",
            "#define MOD_COMMAND2\t\t(1 << 14)",
            "#define MOD_COMMAND1\t\t(1 << 13)",
            "#define MOD_COMMAND\t\t(1 << 12)",
            "#define MOD_HOLDSCREEN\t\t(1 << 11)",
            "#define MOD_COMPOSE\t\t(1 << 10)",
            "#define MOD_NUMLOCK\t\t(1 << 9)",
            "#define MOD_MODESHIFT\t\t(1 << 8)",
            "#define MOD_META_R\t\t(1 << 7)",
            "#define MOD_META_L\t\t(1 << 6)",
            "#define MOD_CONTROL_R\t\t(1 << 5)",
            "#define MOD_CONTROL_L\t\t(1 << 4)",
            "#define MOD_CAPSLOCK\t\t(1 << 3)",
            "#define MOD_SHIFTLOCK\t\t(1 << 2)",
            "#define MOD_SHIFT_R\t\t(1 << 1)",
            "#define MOD_SHIFT_L\t\t(1 << 0)",
            "#define WSKFL_METAESC 1"
          ],
          "globals_used": [
            "static inline void update_leds",
            "static inline void update_modifier",
            "static int internal_command",
            "static int wskbd_translate"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define MOD_ANYMETA\t\t(MOD_META_L | MOD_META_R)\n#define MOD_ANYCONTROL\t\t(MOD_CONTROL_L | MOD_CONTROL_R)\n#define MOD_ANYSHIFT\t\t(MOD_SHIFT_L | MOD_SHIFT_R | MOD_SHIFTLOCK)\n#define MOD_COMMAND2\t\t(1 << 14)\n#define MOD_COMMAND1\t\t(1 << 13)\n#define MOD_COMMAND\t\t(1 << 12)\n#define MOD_HOLDSCREEN\t\t(1 << 11)\n#define MOD_COMPOSE\t\t(1 << 10)\n#define MOD_NUMLOCK\t\t(1 << 9)\n#define MOD_MODESHIFT\t\t(1 << 8)\n#define MOD_META_R\t\t(1 << 7)\n#define MOD_META_L\t\t(1 << 6)\n#define MOD_CONTROL_R\t\t(1 << 5)\n#define MOD_CONTROL_L\t\t(1 << 4)\n#define MOD_CAPSLOCK\t\t(1 << 3)\n#define MOD_SHIFTLOCK\t\t(1 << 2)\n#define MOD_SHIFT_R\t\t(1 << 1)\n#define MOD_SHIFT_L\t\t(1 << 0)\n#define WSKFL_METAESC 1\n\nstatic inline void update_leds;\nstatic inline void update_modifier;\nstatic int internal_command;\nstatic int wskbd_translate;\n\nstatic int\nwskbd_translate(id, type, value)\n\tstruct wskbd_internal *id;\n\tu_int type;\n\tint value;\n{\n\tstruct wskbd_softc *sc = id->t_sc;\n\tkeysym_t ksym, res, *group;\n\tstruct wscons_keymap kpbuf, *kp;\n\tint iscommand = 0;\n\n\tif (type == WSCONS_EVENT_ALL_KEYS_UP) {\n\t\tid->t_modifiers &= ~(MOD_SHIFT_L | MOD_SHIFT_R\n\t\t\t\t| MOD_CONTROL_L | MOD_CONTROL_R\n\t\t\t\t| MOD_META_L | MOD_META_R\n\t\t\t\t| MOD_MODESHIFT\n\t\t\t\t| MOD_COMMAND | MOD_COMMAND1 | MOD_COMMAND2);\n\t\tupdate_leds(id);\n\t\treturn (0);\n\t}\n\n\tif (sc != NULL) {\n\t\tif (value < 0 || value >= sc->sc_maplen) {\n#ifdef DEBUG\n\t\t\tprintf(\"wskbd_translate: keycode %d out of range\\n\",\n\t\t\t       value);\n#endif\n\t\t\treturn (0);\n\t\t}\n\t\tkp = sc->sc_map + value;\n\t} else {\n\t\tkp = &kpbuf;\n\t\twskbd_get_mapentry(id->t_keymap, value, kp);\n\t}\n\n\t/* if this key has a command, process it first */\n\tif (sc != NULL && kp->command != KS_voidSymbol)\n\t\tiscommand = internal_command(sc, &type, kp->command);\n\n\t/* Now update modifiers */\n\tswitch (kp->group1[0]) {\n\tcase KS_Shift_L:\n\t\tupdate_modifier(id, type, 0, MOD_SHIFT_L);\n\t\tbreak;\n\n\tcase KS_Shift_R:\n\t\tupdate_modifier(id, type, 0, MOD_SHIFT_R);\n\t\tbreak;\n\n\tcase KS_Shift_Lock:\n\t\tupdate_modifier(id, type, 1, MOD_SHIFTLOCK);\n\t\tbreak;\n\n\tcase KS_Caps_Lock:\n\t\tupdate_modifier(id, type, 1, MOD_CAPSLOCK);\n\t\tbreak;\n\n\tcase KS_Control_L:\n\t\tupdate_modifier(id, type, 0, MOD_CONTROL_L);\n\t\tbreak;\n\n\tcase KS_Control_R:\n\t\tupdate_modifier(id, type, 0, MOD_CONTROL_R);\n\t\tbreak;\n\n\tcase KS_Alt_L:\n\t\tupdate_modifier(id, type, 0, MOD_META_L);\n\t\tbreak;\n\n\tcase KS_Alt_R:\n\t\tupdate_modifier(id, type, 0, MOD_META_R);\n\t\tbreak;\n\n\tcase KS_Mode_switch:\n\t\tupdate_modifier(id, type, 0, MOD_MODESHIFT);\n\t\tbreak;\n\n\tcase KS_Num_Lock:\n\t\tupdate_modifier(id, type, 1, MOD_NUMLOCK);\n\t\tbreak;\n\n#if NWSDISPLAY > 0\n\tcase KS_Hold_Screen:\n\t\tif (sc != NULL) {\n\t\t\tupdate_modifier(id, type, 1, MOD_HOLDSCREEN);\n\t\t\twskbd_holdscreen(sc, id->t_modifiers & MOD_HOLDSCREEN);\n\t\t}\n\t\tbreak;\n#endif\n\t}\n\n\t/* If this is a key release or we are in command mode, we are done */\n\tif (type != WSCONS_EVENT_KEY_DOWN || iscommand) {\n\t\tupdate_leds(id);\n\t\treturn (0);\n\t}\n\n\t/* Get the keysym */\n\tif (id->t_modifiers & MOD_MODESHIFT)\n\t\tgroup = & kp->group2[0];\n\telse\n\t\tgroup = & kp->group1[0];\n\n\tif ((id->t_modifiers & MOD_NUMLOCK) != 0 &&\n\t    KS_GROUP(group[1]) == KS_GROUP_Keypad) {\n\t\tif (MOD_ONESET(id, MOD_ANYSHIFT))\n\t\t\tksym = group[0];\n\t\telse\n\t\t\tksym = group[1];\n\t} else if (! MOD_ONESET(id, MOD_ANYSHIFT | MOD_CAPSLOCK)) {\n\t\tksym = group[0];\n\t} else if (MOD_ONESET(id, MOD_CAPSLOCK)) {\n\t\tif (! MOD_ONESET(id, MOD_SHIFT_L | MOD_SHIFT_R))\n\t\t\tksym = group[0];\n\t\telse\n\t\t\tksym = group[1];\n\t\tif (ksym >= KS_a && ksym <= KS_z)\n\t\t\tksym += KS_A - KS_a;\n\t\telse if (ksym >= KS_agrave && ksym <= KS_thorn &&\n\t\t\t ksym != KS_division)\n\t\t\tksym += KS_Agrave - KS_agrave;\n\t} else if (MOD_ONESET(id, MOD_ANYSHIFT)) {\n\t\tksym = group[1];\n\t} else {\n\t\tksym = group[0];\n\t}\n\n\t/* Process compose sequence and dead accents */\n\tres = KS_voidSymbol;\n\n\tswitch (KS_GROUP(ksym)) {\n\tcase KS_GROUP_Ascii:\n\tcase KS_GROUP_Keypad:\n\tcase KS_GROUP_Function:\n\t\tres = ksym;\n\t\tbreak;\n\n\tcase KS_GROUP_Mod:\n\t\tif (ksym == KS_Multi_key) {\n\t\t\tupdate_modifier(id, 1, 0, MOD_COMPOSE);\n\t\t\tid->t_composelen = 2;\n\t\t}\n\t\tbreak;\n\n\tcase KS_GROUP_Dead:\n\t\tif (id->t_composelen == 0) {\n\t\t\tupdate_modifier(id, 1, 0, MOD_COMPOSE);\n\t\t\tid->t_composelen = 1;\n\t\t\tid->t_composebuf[0] = ksym;\n\t\t} else\n\t\t\tres = ksym;\n\t\tbreak;\n\t}\n\n\tif (res == KS_voidSymbol) {\n\t\tupdate_leds(id);\n\t\treturn (0);\n\t}\n\n\tif (id->t_composelen > 0) {\n\t\tid->t_composebuf[2 - id->t_composelen] = res;\n\t\tif (--id->t_composelen == 0) {\n\t\t\tres = wskbd_compose_value(id->t_composebuf);\n\t\t\tupdate_modifier(id, 0, 0, MOD_COMPOSE);\n\t\t} else {\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\tupdate_leds(id);\n\n\t/* We are done, return the symbol */\n\tif (KS_GROUP(res) == KS_GROUP_Ascii) {\n\t\tif (MOD_ONESET(id, MOD_ANYCONTROL)) {\n\t\t\tif ((res >= KS_at && res <= KS_z) || res == KS_space)\n\t\t\t\tres = res & 0x1f;\n\t\t\telse if (res == KS_2)\n\t\t\t\tres = 0x00;\n\t\t\telse if (res >= KS_3 && res <= KS_7)\n\t\t\t\tres = KS_Escape + (res - KS_3);\n\t\t\telse if (res == KS_8)\n\t\t\t\tres = KS_Delete;\n\t\t}\n\t\tif (MOD_ONESET(id, MOD_ANYMETA)) {\n\t\t\tif (id->t_flags & WSKFL_METAESC) {\n\t\t\t\tid->t_symbols[0] = KS_Escape;\n\t\t\t\tid->t_symbols[1] = res;\n\t\t\t\treturn (2);\n\t\t\t} else\n\t\t\tres |= 0x80;\n\t}\n\t}\n\n\tid->t_symbols[0] = res;\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "wskbd_console_data.t_consaccesscookie",
            "&type",
            "&data"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KS_VALUE",
          "args": [
            "ks"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KS_GROUP",
          "args": [
            "ks"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstatic int wskbd_translate;\nstatic int wskbd_console_initted;\nstatic struct wskbd_softc *wskbd_console_device;\nstatic struct wskbd_internal wskbd_console_data;\n\nint\nwskbd_cngetc(dev)\n\tdev_t dev;\n{\n\tstatic int num = 0;\n\tstatic int pos;\n\tu_int type;\n\tint data;\n\tkeysym_t ks;\n\n\tif (!wskbd_console_initted)\n\t\treturn 0;\n\n\tif (wskbd_console_device != NULL &&\n\t    !wskbd_console_device->sc_translating)\n\t\treturn 0;\n\n\tfor(;;) {\n\t\tif (num-- > 0) {\n\t\t\tks = wskbd_console_data.t_symbols[pos++];\n\t\tif (KS_GROUP(ks) == KS_GROUP_Ascii)\n\t\t\treturn (KS_VALUE(ks));\t\n\t\t} else {\n\t\t\t(*wskbd_console_data.t_consops->getc)\n\t\t\t\t(wskbd_console_data.t_consaccesscookie,\n\t\t\t\t &type, &data);\n\t\t\tnum = wskbd_translate(&wskbd_console_data, type, data);\n\t\t\tpos = 0;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "wskbd_rem_mux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
    "lines": "1151-1164",
    "snippet": "int\nwskbd_rem_mux(unit, muxsc)\n\tint unit;\n\tstruct wsmux_softc *muxsc;\n{\n\tstruct wskbd_softc *sc;\n\n\tDPRINTF((\"wskbd_rem_mux: %d %s\\n\", unit, muxsc->sc_dv.dv_xname));\n\tif (unit < 0 || unit >= wskbd_cd.cd_ndevs ||\n\t    (sc = wskbd_cd.cd_devs[unit]) == NULL)\n\t\treturn (ENXIO);\n\n\treturn (wsmux_detach_sc(muxsc, &sc->sc_dv));\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wsdisplay.h\"",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wskbdvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cfdriver wskbd_cd = {\n\tNULL, \"wskbd\", DV_TTY\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wsmux_detach_sc",
          "args": [
            "muxsc",
            "&sc->sc_dv"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "wsmux_detach_sc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmux.c",
          "lines": "431-475",
          "snippet": "int\nwsmux_detach_sc(sc, dsc)\n\tstruct wsmux_softc *sc;\n        struct device *dsc;\n{\n\tstruct wsplink *m;\n\tint error = 0;\n\n\tDPRINTF((\"wsmux_detach_sc: %s: dsc=%p\\n\", sc->sc_dv.dv_xname, dsc));\n#ifdef DIAGNOSTIC\n\tif (sc == 0) {\n\t\tprintf(\"wsmux_detach_sc: not allocated\\n\");\n\t\treturn (ENXIO);\n\t}\n#endif\n\n\tfor (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {\n\t\tif (m->sc == dsc)\n\t\t\tbreak;\n\t}\n#ifdef DIAGNOSTIC\n\tif (!m) {\n\t\tprintf(\"wsmux_detach_sc: not found\\n\");\n\t\treturn (ENXIO);\n\t}\n#endif\n\tif (sc->sc_displaydv) {\n\t\tif (m->sc_ops->dsetdisplay)\n\t\t\terror = m->sc_ops->dsetdisplay(m->sc, 0);\n\t\tif (error)\n\t\t\treturn (error);\n\t\t*m->sc_muxp = 0;\n\t} else if (*m->sc_muxp) {\n\t\tDPRINTF((\"wsmux_detach_sc: close\\n\"));\n\t\t/* mux device is open, so close multiplexee */\n\t\tm->sc_ops->dclose(m->sc, FREAD, 0, 0);\n\t\t*m->sc_muxp = 0;\n\t}\n\n\tLIST_REMOVE(m, next);\n\n\tfree(m, M_DEVBUF);\n\tDPRINTF((\"wsmux_detach_sc: done sc=%p\\n\", sc));\n\treturn (0);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/device.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include \"wskbd.h\"",
            "#include \"wsdisplay.h\"",
            "#include \"wsmux.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n\nint\nwsmux_detach_sc(sc, dsc)\n\tstruct wsmux_softc *sc;\n        struct device *dsc;\n{\n\tstruct wsplink *m;\n\tint error = 0;\n\n\tDPRINTF((\"wsmux_detach_sc: %s: dsc=%p\\n\", sc->sc_dv.dv_xname, dsc));\n#ifdef DIAGNOSTIC\n\tif (sc == 0) {\n\t\tprintf(\"wsmux_detach_sc: not allocated\\n\");\n\t\treturn (ENXIO);\n\t}\n#endif\n\n\tfor (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {\n\t\tif (m->sc == dsc)\n\t\t\tbreak;\n\t}\n#ifdef DIAGNOSTIC\n\tif (!m) {\n\t\tprintf(\"wsmux_detach_sc: not found\\n\");\n\t\treturn (ENXIO);\n\t}\n#endif\n\tif (sc->sc_displaydv) {\n\t\tif (m->sc_ops->dsetdisplay)\n\t\t\terror = m->sc_ops->dsetdisplay(m->sc, 0);\n\t\tif (error)\n\t\t\treturn (error);\n\t\t*m->sc_muxp = 0;\n\t} else if (*m->sc_muxp) {\n\t\tDPRINTF((\"wsmux_detach_sc: close\\n\"));\n\t\t/* mux device is open, so close multiplexee */\n\t\tm->sc_ops->dclose(m->sc, FREAD, 0, 0);\n\t\t*m->sc_muxp = 0;\n\t}\n\n\tLIST_REMOVE(m, next);\n\n\tfree(m, M_DEVBUF);\n\tDPRINTF((\"wsmux_detach_sc: done sc=%p\\n\", sc));\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"wskbd_rem_mux: %d %s\\n\", unit, muxsc->sc_dv.dv_xname)"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct cfdriver wskbd_cd = {\n\tNULL, \"wskbd\", DV_TTY\n};\n\nint\nwskbd_rem_mux(unit, muxsc)\n\tint unit;\n\tstruct wsmux_softc *muxsc;\n{\n\tstruct wskbd_softc *sc;\n\n\tDPRINTF((\"wskbd_rem_mux: %d %s\\n\", unit, muxsc->sc_dv.dv_xname));\n\tif (unit < 0 || unit >= wskbd_cd.cd_ndevs ||\n\t    (sc = wskbd_cd.cd_devs[unit]) == NULL)\n\t\treturn (ENXIO);\n\n\treturn (wsmux_detach_sc(muxsc, &sc->sc_dv));\n}"
  },
  {
    "function_name": "wskbd_add_mux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
    "lines": "1131-1149",
    "snippet": "int\nwskbd_add_mux(unit, muxsc)\n\tint unit;\n\tstruct wsmux_softc *muxsc;\n{\n\tstruct wskbd_softc *sc;\n\n\tDPRINTF((\"wskbd_add_mux: %d %s %p\\n\", unit, muxsc->sc_dv.dv_xname,\n\t\t muxsc->sc_displaydv));\n\tif (unit < 0 || unit >= wskbd_cd.cd_ndevs ||\n\t    (sc = wskbd_cd.cd_devs[unit]) == NULL)\n\t\treturn (ENXIO);\n\n\tif (sc->sc_mux || sc->sc_events.io)\n\t\treturn (EBUSY);\n\n\treturn (wsmux_attach_sc(muxsc, WSMUX_KBD, &sc->sc_dv, &sc->sc_events, \n\t\t\t\t&sc->sc_mux, &wskbd_muxops));\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wsdisplay.h\"",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wskbdvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cfdriver wskbd_cd = {\n\tNULL, \"wskbd\", DV_TTY\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wsmux_attach_sc",
          "args": [
            "muxsc",
            "WSMUX_KBD",
            "&sc->sc_dv",
            "&sc->sc_events",
            "&sc->sc_mux",
            "&wskbd_muxops"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "wsmux_attach_sc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmux.c",
          "lines": "364-429",
          "snippet": "int\nwsmux_attach_sc(sc, type, dsc, ev, psp, ops)\n\tstruct wsmux_softc *sc;\n\tint type;\n        struct device *dsc;\n\tstruct wseventvar *ev;\n\tstruct wsmux_softc **psp;\n\tstruct wsmuxops *ops;\n{\n\tstruct wsplink *m;\n\tint error;\n\n\tDPRINTF((\"wsmux_attach_sc: %s: type=%d dsc=%p, *psp=%p\\n\",\n\t\t sc->sc_dv.dv_xname, type, dsc, *psp));\n\tm = malloc(sizeof *m, M_DEVBUF, M_NOWAIT);\n\tif (m == 0)\n\t\treturn (ENOMEM);\n\tm->type = type;\n\tm->mux = sc;\n\tm->sc = dsc;\n\tm->sc_mevents = ev;\n\tm->sc_muxp = psp;\n\tm->sc_ops = ops;\n\tLIST_INSERT_HEAD(&sc->sc_reals, m, next);\n\n\tif (sc->sc_displaydv) {\n\t\t/* This is a display mux, so attach the new device to it. */\n\t\tDPRINTF((\"wsmux_attach_sc: %s: set display %p\\n\", \n\t\t\t sc->sc_dv.dv_xname, sc->sc_displaydv));\n\t\terror = 0;\n\t\tif (m->sc_ops->dsetdisplay) {\n\t\t\terror = m->sc_ops->dsetdisplay(m->sc, sc);\n\t\t\t/* Ignore that the console already has a display. */\n\t\t\tif (error == EBUSY)\n\t\t\t\terror = 0;\n\t\t\tif (!error) {\n\t\t\t\t*m->sc_muxp = sc;\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t\t\t\tDPRINTF((\"wsmux_attach_sc: on %s set rawkbd=%d\\n\",\n\t\t\t\t\t m->sc->dv_xname, sc->sc_rawkbd));\n\t\t\t\t(void)m->sc_ops->dioctl(m->sc, \n\t\t\t\t\t     WSKBDIO_SETMODE, \n\t\t\t\t\t     (caddr_t)&sc->sc_rawkbd,\n\t\t\t\t\t     0, 0);\n#endif\n\t\t\t}\n\t\t}\n\t} else if (sc->sc_events.io) {\n\t\t/* Mux is open, so open the new subdevice */\n\t\tDPRINTF((\"wsmux_attach_sc: %s: calling open of %s\\n\",\n\t\t\t sc->sc_dv.dv_xname, m->sc->dv_xname));\n\t\t/* mux already open, join in */\n\t\terror = m->sc_ops->dopen(makedev(0, m->sc->dv_unit),\n\t\t\t\t\t sc->sc_flags, sc->sc_mode, sc->sc_p);\n\t\tif (!error)\n\t\t\t*m->sc_muxp = sc;\n\t} else {\n\t\tDPRINTF((\"wsmux_attach_sc: %s not open\\n\",\n\t\t\t sc->sc_dv.dv_xname));\n\t\terror = 0;\n\t}\n\tDPRINTF((\"wsmux_attach_sc: done sc=%p psp=%p *psp=%p\\n\", \n\t\t sc, psp, *psp));\n\n\treturn (error);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/device.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include \"wskbd.h\"",
            "#include \"wsdisplay.h\"",
            "#include \"wsmux.h\""
          ],
          "macros_used": [
            "#define d ((struct wsmux_device *)data)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n\n#define d ((struct wsmux_device *)data)\n\nint\nwsmux_attach_sc(sc, type, dsc, ev, psp, ops)\n\tstruct wsmux_softc *sc;\n\tint type;\n        struct device *dsc;\n\tstruct wseventvar *ev;\n\tstruct wsmux_softc **psp;\n\tstruct wsmuxops *ops;\n{\n\tstruct wsplink *m;\n\tint error;\n\n\tDPRINTF((\"wsmux_attach_sc: %s: type=%d dsc=%p, *psp=%p\\n\",\n\t\t sc->sc_dv.dv_xname, type, dsc, *psp));\n\tm = malloc(sizeof *m, M_DEVBUF, M_NOWAIT);\n\tif (m == 0)\n\t\treturn (ENOMEM);\n\tm->type = type;\n\tm->mux = sc;\n\tm->sc = dsc;\n\tm->sc_mevents = ev;\n\tm->sc_muxp = psp;\n\tm->sc_ops = ops;\n\tLIST_INSERT_HEAD(&sc->sc_reals, m, next);\n\n\tif (sc->sc_displaydv) {\n\t\t/* This is a display mux, so attach the new device to it. */\n\t\tDPRINTF((\"wsmux_attach_sc: %s: set display %p\\n\", \n\t\t\t sc->sc_dv.dv_xname, sc->sc_displaydv));\n\t\terror = 0;\n\t\tif (m->sc_ops->dsetdisplay) {\n\t\t\terror = m->sc_ops->dsetdisplay(m->sc, sc);\n\t\t\t/* Ignore that the console already has a display. */\n\t\t\tif (error == EBUSY)\n\t\t\t\terror = 0;\n\t\t\tif (!error) {\n\t\t\t\t*m->sc_muxp = sc;\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t\t\t\tDPRINTF((\"wsmux_attach_sc: on %s set rawkbd=%d\\n\",\n\t\t\t\t\t m->sc->dv_xname, sc->sc_rawkbd));\n\t\t\t\t(void)m->sc_ops->dioctl(m->sc, \n\t\t\t\t\t     WSKBDIO_SETMODE, \n\t\t\t\t\t     (caddr_t)&sc->sc_rawkbd,\n\t\t\t\t\t     0, 0);\n#endif\n\t\t\t}\n\t\t}\n\t} else if (sc->sc_events.io) {\n\t\t/* Mux is open, so open the new subdevice */\n\t\tDPRINTF((\"wsmux_attach_sc: %s: calling open of %s\\n\",\n\t\t\t sc->sc_dv.dv_xname, m->sc->dv_xname));\n\t\t/* mux already open, join in */\n\t\terror = m->sc_ops->dopen(makedev(0, m->sc->dv_unit),\n\t\t\t\t\t sc->sc_flags, sc->sc_mode, sc->sc_p);\n\t\tif (!error)\n\t\t\t*m->sc_muxp = sc;\n\t} else {\n\t\tDPRINTF((\"wsmux_attach_sc: %s not open\\n\",\n\t\t\t sc->sc_dv.dv_xname));\n\t\terror = 0;\n\t}\n\tDPRINTF((\"wsmux_attach_sc: done sc=%p psp=%p *psp=%p\\n\", \n\t\t sc, psp, *psp));\n\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"wskbd_add_mux: %d %s %p\\n\", unit, muxsc->sc_dv.dv_xname,\n\t\t muxsc->sc_displaydv)"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct cfdriver wskbd_cd = {\n\tNULL, \"wskbd\", DV_TTY\n};\n\nint\nwskbd_add_mux(unit, muxsc)\n\tint unit;\n\tstruct wsmux_softc *muxsc;\n{\n\tstruct wskbd_softc *sc;\n\n\tDPRINTF((\"wskbd_add_mux: %d %s %p\\n\", unit, muxsc->sc_dv.dv_xname,\n\t\t muxsc->sc_displaydv));\n\tif (unit < 0 || unit >= wskbd_cd.cd_ndevs ||\n\t    (sc = wskbd_cd.cd_devs[unit]) == NULL)\n\t\treturn (ENXIO);\n\n\tif (sc->sc_mux || sc->sc_events.io)\n\t\treturn (EBUSY);\n\n\treturn (wsmux_attach_sc(muxsc, WSMUX_KBD, &sc->sc_dv, &sc->sc_events, \n\t\t\t\t&sc->sc_mux, &wskbd_muxops));\n}"
  },
  {
    "function_name": "wskbd_set_display",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
    "lines": "1087-1129",
    "snippet": "int\nwskbd_set_display(dv, muxsc)\n\tstruct device *dv;\n\tstruct wsmux_softc *muxsc;\n{\n\tstruct wskbd_softc *sc = (struct wskbd_softc *)dv;\n\tstruct device *displaydv = muxsc ? muxsc->sc_displaydv : 0;\n\tstruct device *odisplaydv;\n\tint error;\n\n\tDPRINTF((\"wskbd_set_display: %s mux=%p disp=%p odisp=%p cons=%d\\n\",\n\t\t dv->dv_xname, muxsc, sc->sc_displaydv, displaydv, \n\t\t sc->sc_isconsole));\n\n\tif (sc->sc_isconsole)\n\t\treturn (EBUSY);\n\n\tif (displaydv) {\n\t\tif (sc->sc_displaydv)\n\t\t\treturn (EBUSY);\n\t} else {\n\t\tif (sc->sc_displaydv == NULL)\n\t\t\treturn (ENXIO);\n\t}\n\n\todisplaydv = sc->sc_displaydv;\n\tsc->sc_displaydv = displaydv;\n\n\terror = wskbd_enable(sc, displaydv != NULL);\n\tif (error) {\n\t\tsc->sc_displaydv = odisplaydv;\n\t\treturn (error);\n\t}\n\n\tif (displaydv)\n\t\tprintf(\"%s: connecting to %s\\n\",\n\t\t       sc->sc_dv.dv_xname, displaydv->dv_xname);\n\telse\n\t\tprintf(\"%s: disconnecting from %s\\n\",\n\t\t       sc->sc_dv.dv_xname, odisplaydv->dv_xname);\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wsdisplay.h\"",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wskbdvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\twskbd_set_display",
      "static int wskbd_enable"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: disconnecting from %s\\n\"",
            "sc->sc_dv.dv_xname",
            "odisplaydv->dv_xname"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wskbd_enable",
          "args": [
            "sc",
            "displaydv != NULL"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "wskbd_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
          "lines": "670-687",
          "snippet": "static int\nwskbd_enable(sc, on)\n\tstruct wskbd_softc *sc;\n\tint on;\n{\n\tint res;\n\n\t/* XXX reference count? */\n\tif (!on && (!sc->sc_translating\n#if NWSDISPLAY > 0\n\t\t    || sc->sc_displaydv\n#endif\n\t\t))\n\t\treturn (EBUSY);\n\n\tres = (*sc->sc_accessops->enable)(sc->sc_accesscookie, on);\n\treturn (res);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wsdisplay.h\"",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wskbdvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/malloc.h>",
            "#include <sys/timeout.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int wskbd_enable"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstatic int wskbd_enable;\n\nstatic int\nwskbd_enable(sc, on)\n\tstruct wskbd_softc *sc;\n\tint on;\n{\n\tint res;\n\n\t/* XXX reference count? */\n\tif (!on && (!sc->sc_translating\n#if NWSDISPLAY > 0\n\t\t    || sc->sc_displaydv\n#endif\n\t\t))\n\t\treturn (EBUSY);\n\n\tres = (*sc->sc_accessops->enable)(sc->sc_accesscookie, on);\n\treturn (res);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"wskbd_set_display: %s mux=%p disp=%p odisp=%p cons=%d\\n\",\n\t\t dv->dv_xname, muxsc, sc->sc_displaydv, displaydv, \n\t\t sc->sc_isconsole)"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nint\twskbd_set_display;\nstatic int wskbd_enable;\n\nint\nwskbd_set_display(dv, muxsc)\n\tstruct device *dv;\n\tstruct wsmux_softc *muxsc;\n{\n\tstruct wskbd_softc *sc = (struct wskbd_softc *)dv;\n\tstruct device *displaydv = muxsc ? muxsc->sc_displaydv : 0;\n\tstruct device *odisplaydv;\n\tint error;\n\n\tDPRINTF((\"wskbd_set_display: %s mux=%p disp=%p odisp=%p cons=%d\\n\",\n\t\t dv->dv_xname, muxsc, sc->sc_displaydv, displaydv, \n\t\t sc->sc_isconsole));\n\n\tif (sc->sc_isconsole)\n\t\treturn (EBUSY);\n\n\tif (displaydv) {\n\t\tif (sc->sc_displaydv)\n\t\t\treturn (EBUSY);\n\t} else {\n\t\tif (sc->sc_displaydv == NULL)\n\t\t\treturn (ENXIO);\n\t}\n\n\todisplaydv = sc->sc_displaydv;\n\tsc->sc_displaydv = displaydv;\n\n\terror = wskbd_enable(sc, displaydv != NULL);\n\tif (error) {\n\t\tsc->sc_displaydv = odisplaydv;\n\t\treturn (error);\n\t}\n\n\tif (displaydv)\n\t\tprintf(\"%s: connecting to %s\\n\",\n\t\t       sc->sc_dv.dv_xname, displaydv->dv_xname);\n\telse\n\t\tprintf(\"%s: disconnecting from %s\\n\",\n\t\t       sc->sc_dv.dv_xname, odisplaydv->dv_xname);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "wskbd_pickfree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
    "lines": "1057-1070",
    "snippet": "int\nwskbd_pickfree()\n{\n\tint i;\n\tstruct wskbd_softc *sc;\n\n\tfor (i = 0; i < wskbd_cd.cd_ndevs; i++) {\n\t\tif ((sc = wskbd_cd.cd_devs[i]) == NULL)\n\t\t\tcontinue;\n\t\tif (sc->sc_displaydv == NULL)\n\t\t\treturn (i);\n\t}\n\treturn (-1);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wsdisplay.h\"",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wskbdvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cfdriver wskbd_cd = {\n\tNULL, \"wskbd\", DV_TTY\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct cfdriver wskbd_cd = {\n\tNULL, \"wskbd\", DV_TTY\n};\n\nint\nwskbd_pickfree()\n{\n\tint i;\n\tstruct wskbd_softc *sc;\n\n\tfor (i = 0; i < wskbd_cd.cd_ndevs; i++) {\n\t\tif ((sc = wskbd_cd.cd_devs[i]) == NULL)\n\t\t\tcontinue;\n\t\tif (sc->sc_displaydv == NULL)\n\t\t\treturn (i);\n\t}\n\treturn (-1);\n}"
  },
  {
    "function_name": "wskbdselect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
    "lines": "1044-1053",
    "snippet": "int\nwskbdselect(dev, events, p)\n\tdev_t dev;\n\tint events;\n\tstruct proc *p;\n{\n\tstruct wskbd_softc *sc = wskbd_cd.cd_devs[minor(dev)];\n\n\treturn (wsevent_poll(&sc->sc_events, events, p));\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wsdisplay.h\"",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wskbdvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cfdriver wskbd_cd = {\n\tNULL, \"wskbd\", DV_TTY\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wsevent_poll",
          "args": [
            "&sc->sc_events",
            "events",
            "p"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "wsevent_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsevent.c",
          "lines": "183-201",
          "snippet": "int\nwsevent_poll(ev, events, p)\n\tstruct wseventvar *ev;\n\tint events;\n\tstruct proc *p;\n{\n\tint revents = 0;\n\tint s = splwsevent();\n\n        if (events & (POLLIN | POLLRDNORM)) {\n\t\tif (ev->get != ev->put)\n\t\t\trevents |= events & (POLLIN | POLLRDNORM);\n\t\telse\n\t\t\tselrecord(p, &ev->sel);\n\t}\n\n\tsplx(s);\n\treturn (revents);\n}",
          "includes": [
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nint\nwsevent_poll(ev, events, p)\n\tstruct wseventvar *ev;\n\tint events;\n\tstruct proc *p;\n{\n\tint revents = 0;\n\tint s = splwsevent();\n\n        if (events & (POLLIN | POLLRDNORM)) {\n\t\tif (ev->get != ev->put)\n\t\t\trevents |= events & (POLLIN | POLLRDNORM);\n\t\telse\n\t\t\tselrecord(p, &ev->sel);\n\t}\n\n\tsplx(s);\n\treturn (revents);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct cfdriver wskbd_cd = {\n\tNULL, \"wskbd\", DV_TTY\n};\n\nint\nwskbdselect(dev, events, p)\n\tdev_t dev;\n\tint events;\n\tstruct proc *p;\n{\n\tstruct wskbd_softc *sc = wskbd_cd.cd_devs[minor(dev)];\n\n\treturn (wsevent_poll(&sc->sc_events, events, p));\n}"
  },
  {
    "function_name": "wskbd_displayioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
    "lines": "851-1042",
    "snippet": "static int\nwskbd_displayioctl(dev, cmd, data, flag, p)\n\tstruct device *dev;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct wskbd_softc *sc = (struct wskbd_softc *)dev;\n\tstruct wskbd_bell_data *ubdp, *kbdp;\n\tstruct wskbd_keyrepeat_data *ukdp, *kkdp;\n\tstruct wskbd_map_data *umdp;\n\tstruct wskbd_mapdata md;\n\tkbd_t enc;\n\tvoid *buf;\n\tint len, error;\n\n\tswitch (cmd) {\n#define\tSETBELL(dstp, srcp, dfltp)\t\t\t\t\t\\\n    do {\t\t\t\t\t\t\t\t\\\n\t(dstp)->pitch = ((srcp)->which & WSKBD_BELL_DOPITCH) ?\t\t\\\n\t    (srcp)->pitch : (dfltp)->pitch;\t\t\t\t\\\n\t(dstp)->period = ((srcp)->which & WSKBD_BELL_DOPERIOD) ?\t\\\n\t    (srcp)->period : (dfltp)->period;\t\t\t\t\\\n\t(dstp)->volume = ((srcp)->which & WSKBD_BELL_DOVOLUME) ?\t\\\n\t    (srcp)->volume : (dfltp)->volume;\t\t\t\t\\\n\t(dstp)->which = WSKBD_BELL_DOALL;\t\t\t\t\\\n    } while (0)\n\n\tcase WSKBDIO_BELL:\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn (EACCES);\n\t\treturn ((*sc->sc_accessops->ioctl)(sc->sc_accesscookie,\n\t\t    WSKBDIO_COMPLEXBELL, (caddr_t)&sc->sc_bell_data, flag, p));\n\n\tcase WSKBDIO_COMPLEXBELL:\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn (EACCES);\n\t\tubdp = (struct wskbd_bell_data *)data;\n\t\tSETBELL(ubdp, ubdp, &sc->sc_bell_data);\n\t\treturn ((*sc->sc_accessops->ioctl)(sc->sc_accesscookie,\n\t\t    WSKBDIO_COMPLEXBELL, (caddr_t)ubdp, flag, p));\n\n\tcase WSKBDIO_SETBELL:\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn (EACCES);\n\t\tkbdp = &sc->sc_bell_data;\nsetbell:\n\t\tubdp = (struct wskbd_bell_data *)data;\n\t\tSETBELL(kbdp, ubdp, kbdp);\n\t\treturn (0);\n\n\tcase WSKBDIO_GETBELL:\n\t\tkbdp = &sc->sc_bell_data;\ngetbell:\n\t\tubdp = (struct wskbd_bell_data *)data;\n\t\tSETBELL(ubdp, kbdp, kbdp);\n\t\treturn (0);\n\n\tcase WSKBDIO_SETDEFAULTBELL:\n\t\tif ((error = suser(p->p_ucred, &p->p_acflag)) != 0)\n\t\t\treturn (error);\n\t\tkbdp = &wskbd_default_bell_data;\n\t\tgoto setbell;\n\n\n\tcase WSKBDIO_GETDEFAULTBELL:\n\t\tkbdp = &wskbd_default_bell_data;\n\t\tgoto getbell;\n\n#undef SETBELL\n\n#define\tSETKEYREPEAT(dstp, srcp, dfltp)\t\t\t\t\t\\\n    do {\t\t\t\t\t\t\t\t\\\n\t(dstp)->del1 = ((srcp)->which & WSKBD_KEYREPEAT_DODEL1) ?\t\\\n\t    (srcp)->del1 : (dfltp)->del1;\t\t\t\t\\\n\t(dstp)->delN = ((srcp)->which & WSKBD_KEYREPEAT_DODELN) ?\t\\\n\t    (srcp)->delN : (dfltp)->delN;\t\t\t\t\\\n\t(dstp)->which = WSKBD_KEYREPEAT_DOALL;\t\t\t\t\\\n    } while (0)\n\n\tcase WSKBDIO_SETKEYREPEAT:\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn (EACCES);\n\t\tkkdp = &sc->sc_keyrepeat_data;\nsetkeyrepeat:\n\t\tukdp = (struct wskbd_keyrepeat_data *)data;\n\t\tSETKEYREPEAT(kkdp, ukdp, kkdp);\n\t\treturn (0);\n\n\tcase WSKBDIO_GETKEYREPEAT:\n\t\tkkdp = &sc->sc_keyrepeat_data;\ngetkeyrepeat:\n\t\tukdp = (struct wskbd_keyrepeat_data *)data;\n\t\tSETKEYREPEAT(ukdp, kkdp, kkdp);\n\t\treturn (0);\n\n\tcase WSKBDIO_SETDEFAULTKEYREPEAT:\n\t\tif ((error = suser(p->p_ucred, &p->p_acflag)) != 0)\n\t\t\treturn (error);\n\t\tkkdp = &wskbd_default_keyrepeat_data;\n\t\tgoto setkeyrepeat;\n\n\n\tcase WSKBDIO_GETDEFAULTKEYREPEAT:\n\t\tkkdp = &wskbd_default_keyrepeat_data;\n\t\tgoto getkeyrepeat;\n\n#undef SETKEYREPEAT\n\n\tcase WSKBDIO_SETMAP:\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn (EACCES);\n\t\tumdp = (struct wskbd_map_data *)data;\n\t\tlen = umdp->maplen*sizeof(struct wscons_keymap);\n\t\tbuf = malloc(len, M_TEMP, M_WAITOK);\n\t\terror = copyin(umdp->map, buf, len);\n\t\tif (error == 0) {\n\t\t\twskbd_init_keymap(umdp->maplen,\n\t\t\t\t\t  &sc->sc_map, &sc->sc_maplen);\n\t\t\tmemcpy(sc->sc_map, buf, len);\n\t\t\t/* drop the variant bits handled by the map */\n\t\t\tsc->sc_layout = KB_USER |\n\t\t\t      (KB_VARIANT(sc->sc_layout) & KB_HANDLEDBYWSKBD);\n\t\t\twskbd_update_layout(sc->id, sc->sc_layout);\n\t\t}\n\t\tfree(buf, M_TEMP);\n\t\treturn(error);\n\n\tcase WSKBDIO_GETMAP:\n\t\tumdp = (struct wskbd_map_data *)data;\n\t\tif (umdp->maplen > sc->sc_maplen)\n\t\t\tumdp->maplen = sc->sc_maplen;\n\t\terror = copyout(sc->sc_map, umdp->map,\n\t\t\t\tumdp->maplen*sizeof(struct wscons_keymap));\n\t\treturn(error);\n\n\tcase WSKBDIO_GETENCODING:\n\t\t*((kbd_t *) data) = sc->sc_layout;\n\t\treturn(0);\n\n\tcase WSKBDIO_SETENCODING:\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn (EACCES);\n\t\tenc = *((kbd_t *)data);\n\t\tif (KB_ENCODING(enc) == KB_USER) {\n\t\t\t/* user map must already be loaded */\n\t\t\tif (KB_ENCODING(sc->sc_layout) != KB_USER)\n\t\t\t\treturn (EINVAL);\n\t\t\t/* map variants make no sense */\n\t\t\tif (KB_VARIANT(enc) & ~KB_HANDLEDBYWSKBD)\n\t\t\t\treturn (EINVAL);\n\t\t} else {\n\t\tmd = *(sc->id->t_keymap); /* structure assignment */\n\t\t\tmd.layout = enc;\n\t\t\terror = wskbd_load_keymap(&md, &sc->sc_map,\n\t\t\t\t\t\t  &sc->sc_maplen);\n\t\t\tif (error)\n\t\treturn(error);\n\t}\n\t\tsc->sc_layout = enc;\n\t\twskbd_update_layout(sc->id, enc);\n\t\treturn (0);\n\t}\n\n\t/*\n\t * Try the keyboard driver for WSKBDIO ioctls.  It returns -1\n\t * if it didn't recognize the request, and in turn we return\n\t * -1 if we didn't recognize the request.\n\t */\n/* printf(\"kbdaccess\\n\"); */\n\terror = (*sc->sc_accessops->ioctl)(sc->sc_accesscookie, cmd, data,\n\t\t\t\t\t   flag, p);\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\tif (!error && cmd == WSKBDIO_SETMODE && *(int *)data == WSKBD_RAW) {\n\t\tint s = spltty();\n\t\tsc->id->t_modifiers &= ~(MOD_SHIFT_L | MOD_SHIFT_R\n\t\t\t\t\t | MOD_CONTROL_L | MOD_CONTROL_R\n\t\t\t\t\t | MOD_META_L | MOD_META_R\n\t\t\t\t\t | MOD_COMMAND\n\t\t\t\t\t | MOD_COMMAND1 | MOD_COMMAND2);\n#if NWSDISPLAY > 0\n\t\tif (sc->sc_repeating) {\n\t\t\tsc->sc_repeating = 0;\n\t\t\ttimeout_del(&sc->sc_repeat_ch);\n\t\t}\n#endif\n\t\tsplx(s);\n\t}\n#endif\n\treturn (error);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wsdisplay.h\"",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wskbdvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [
      "#define MOD_COMMAND2\t\t(1 << 14)",
      "#define MOD_COMMAND1\t\t(1 << 13)",
      "#define MOD_COMMAND\t\t(1 << 12)",
      "#define MOD_META_R\t\t(1 << 7)",
      "#define MOD_META_L\t\t(1 << 6)",
      "#define MOD_CONTROL_R\t\t(1 << 5)",
      "#define MOD_CONTROL_L\t\t(1 << 4)",
      "#define MOD_SHIFT_R\t\t(1 << 1)",
      "#define MOD_SHIFT_L\t\t(1 << 0)"
    ],
    "globals_used": [
      "static int wskbd_displayioctl",
      "struct wskbd_bell_data wskbd_default_bell_data = {\n\tWSKBD_BELL_DOALL,\n\tWSKBD_DEFAULT_BELL_PITCH,\n\tWSKBD_DEFAULT_BELL_PERIOD,\n\tWSKBD_DEFAULT_BELL_VOLUME,\n};",
      "struct wskbd_keyrepeat_data wskbd_default_keyrepeat_data = {\n\tWSKBD_KEYREPEAT_DOALL,\n\tWSKBD_DEFAULT_KEYREPEAT_DEL1,\n\tWSKBD_DEFAULT_KEYREPEAT_DELN,\n};",
      "static void wskbd_update_layout"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout_del",
          "args": [
            "&sc->sc_repeat_ch"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc->sc_accesscookie",
            "cmd",
            "data",
            "flag",
            "p"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wskbd_update_layout",
          "args": [
            "sc->id",
            "enc"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "wskbd_update_layout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
          "lines": "288-298",
          "snippet": "static void\nwskbd_update_layout(id, enc)\n\tstruct wskbd_internal *id;\n\tkbd_t enc;\n{\n\n\tif (enc & KB_METAESC)\n\t\tid->t_flags |= WSKFL_METAESC;\n\telse\n\t\tid->t_flags &= ~WSKFL_METAESC;\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wsdisplay.h\"",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wskbdvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/malloc.h>",
            "#include <sys/timeout.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [
            "#define WSKFL_METAESC 1"
          ],
          "globals_used": [
            "static void wskbd_update_layout"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define WSKFL_METAESC 1\n\nstatic void wskbd_update_layout;\n\nstatic void\nwskbd_update_layout(id, enc)\n\tstruct wskbd_internal *id;\n\tkbd_t enc;\n{\n\n\tif (enc & KB_METAESC)\n\t\tid->t_flags |= WSKFL_METAESC;\n\telse\n\t\tid->t_flags &= ~WSKFL_METAESC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wskbd_load_keymap",
          "args": [
            "&md",
            "&sc->sc_map",
            "&sc->sc_maplen"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "wskbd_load_keymap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbdutil.c",
          "lines": "407-477",
          "snippet": "int\nwskbd_load_keymap(mapdata, map, maplen)\n\tconst struct wskbd_mapdata *mapdata;\n\tstruct wscons_keymap **map;\n\tint *maplen;\n{\n\tint i, s, kc, stack_ptr;\n\tconst keysym_t *kp;\n\tconst struct wscons_keydesc *mp, *stack[10];\n\tkbd_t cur;\n\n\tfor (cur = mapdata->layout & ~KB_HANDLEDBYWSKBD, stack_ptr = 0;\n\t     cur != 0; stack_ptr++) {\n\t\tmp = mapdata->keydesc;\n\t\twhile (mp->map_size > 0) {\n\t\t\tif (cur == 0 || mp->name == cur) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmp++;\n\t\t}\n\n\t\tif (stack_ptr == sizeof(stack)/sizeof(stack[0]))\n\t\t\tpanic(\"wskbd_load_keymap: %d: recursion too deep\",\n\t\t\t      mapdata->layout);\n\t\tif (mp->map_size <= 0)\n\t\t\treturn(EINVAL);\n\n\t\tstack[stack_ptr] = mp;\n\t\tcur = mp->base;\n\t}\n\n\tfor (i = 0, s = stack_ptr - 1; s >= 0; s--) {\n\t\tmp = stack[s];\n\t\tfor (kp = mp->map; kp < mp->map + mp->map_size; kp++)\n\t\t\tif (KS_GROUP(*kp) == KS_GROUP_Keycode && KS_VALUE(*kp) > i)\n\t\t\t\ti = KS_VALUE(*kp);\n\t}\n\n\twskbd_init_keymap(i + 1, map, maplen);\n\n\tfor (s = stack_ptr - 1; s >= 0; s--) {\n\t\tmp = stack[s];\n\t\tfor (kp = mp->map; kp < mp->map + mp->map_size; ) {\n\t\t\tif (KS_GROUP(*kp) != KS_GROUP_Keycode)\n\t\t\t\tpanic(\"wskbd_load_keymap: %d(%d): bad entry\",\n\t\t\t\t      mp->name, *kp);\n\n\t\t\tkc = KS_VALUE(*kp);\n\t\t\tkp++;\n\n\t\t\tif (KS_GROUP(*kp) == KS_GROUP_Command ||\n\t\t\t    *kp == KS_Cmd || *kp == KS_Cmd1 || *kp == KS_Cmd2) {\n\t\t\t\t(*map)[kc].command = *kp;\n\t\t\t\tkp++;\n\t\t\t}\n\n\t\t\tfor (i = 0; kp + i < mp->map + mp->map_size; i++)\n\t\t\t\tif (KS_GROUP(kp[i]) == KS_GROUP_Keycode)\n\t\t\t\t\tbreak;\n\n\t\t\tif (i > 4)\n\t\t\t\tpanic(\"wskbd_load_keymap: %d(%d): bad entry\",\n\t\t\t\t      mp->name, *kp);\n\n\t\t\tfillmapentry(kp, i, &(*map)[kc]);\n\t\t\tkp += i;\n\t\t}\n\t}\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdefs.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillmapentry"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/errno.h>\n#include <sys/cdefs.h>\n#include <sys/types.h>\n#include <sys/param.h>\n\nstatic void fillmapentry;\n\nint\nwskbd_load_keymap(mapdata, map, maplen)\n\tconst struct wskbd_mapdata *mapdata;\n\tstruct wscons_keymap **map;\n\tint *maplen;\n{\n\tint i, s, kc, stack_ptr;\n\tconst keysym_t *kp;\n\tconst struct wscons_keydesc *mp, *stack[10];\n\tkbd_t cur;\n\n\tfor (cur = mapdata->layout & ~KB_HANDLEDBYWSKBD, stack_ptr = 0;\n\t     cur != 0; stack_ptr++) {\n\t\tmp = mapdata->keydesc;\n\t\twhile (mp->map_size > 0) {\n\t\t\tif (cur == 0 || mp->name == cur) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmp++;\n\t\t}\n\n\t\tif (stack_ptr == sizeof(stack)/sizeof(stack[0]))\n\t\t\tpanic(\"wskbd_load_keymap: %d: recursion too deep\",\n\t\t\t      mapdata->layout);\n\t\tif (mp->map_size <= 0)\n\t\t\treturn(EINVAL);\n\n\t\tstack[stack_ptr] = mp;\n\t\tcur = mp->base;\n\t}\n\n\tfor (i = 0, s = stack_ptr - 1; s >= 0; s--) {\n\t\tmp = stack[s];\n\t\tfor (kp = mp->map; kp < mp->map + mp->map_size; kp++)\n\t\t\tif (KS_GROUP(*kp) == KS_GROUP_Keycode && KS_VALUE(*kp) > i)\n\t\t\t\ti = KS_VALUE(*kp);\n\t}\n\n\twskbd_init_keymap(i + 1, map, maplen);\n\n\tfor (s = stack_ptr - 1; s >= 0; s--) {\n\t\tmp = stack[s];\n\t\tfor (kp = mp->map; kp < mp->map + mp->map_size; ) {\n\t\t\tif (KS_GROUP(*kp) != KS_GROUP_Keycode)\n\t\t\t\tpanic(\"wskbd_load_keymap: %d(%d): bad entry\",\n\t\t\t\t      mp->name, *kp);\n\n\t\t\tkc = KS_VALUE(*kp);\n\t\t\tkp++;\n\n\t\t\tif (KS_GROUP(*kp) == KS_GROUP_Command ||\n\t\t\t    *kp == KS_Cmd || *kp == KS_Cmd1 || *kp == KS_Cmd2) {\n\t\t\t\t(*map)[kc].command = *kp;\n\t\t\t\tkp++;\n\t\t\t}\n\n\t\t\tfor (i = 0; kp + i < mp->map + mp->map_size; i++)\n\t\t\t\tif (KS_GROUP(kp[i]) == KS_GROUP_Keycode)\n\t\t\t\t\tbreak;\n\n\t\t\tif (i > 4)\n\t\t\t\tpanic(\"wskbd_load_keymap: %d(%d): bad entry\",\n\t\t\t\t      mp->name, *kp);\n\n\t\t\tfillmapentry(kp, i, &(*map)[kc]);\n\t\t\tkp += i;\n\t\t}\n\t}\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KB_VARIANT",
          "args": [
            "enc"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KB_ENCODING",
          "args": [
            "sc->sc_layout"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KB_ENCODING",
          "args": [
            "enc"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyout",
          "args": [
            "sc->sc_map",
            "umdp->map",
            "umdp->maplen*sizeof(struct wscons_keymap)"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "audio_silence_copyout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "1249-1268",
          "snippet": "int\naudio_silence_copyout(sc, n, uio)\n\tstruct audio_softc *sc;\n\tint n;\n\tstruct uio *uio;\n{\n\tint error;\n\tint k;\n\tu_char zerobuf[128];\n\n\taudio_fill_silence(&sc->sc_rparams, zerobuf, sizeof zerobuf);\n\n\terror = 0;\n        while (n > 0 && uio->uio_resid > 0 && !error) {\n\t\tk = min(n, min(uio->uio_resid, sizeof zerobuf));\n\t\terror = uiomove(zerobuf, k, uio);\n\t\tn -= k;\n\t}\n        return (error);\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudio_silence_copyout(sc, n, uio)\n\tstruct audio_softc *sc;\n\tint n;\n\tstruct uio *uio;\n{\n\tint error;\n\tint k;\n\tu_char zerobuf[128];\n\n\taudio_fill_silence(&sc->sc_rparams, zerobuf, sizeof zerobuf);\n\n\terror = 0;\n        while (n > 0 && uio->uio_resid > 0 && !error) {\n\t\tk = min(n, min(uio->uio_resid, sizeof zerobuf));\n\t\terror = uiomove(zerobuf, k, uio);\n\t\tn -= k;\n\t}\n        return (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "buf",
            "M_TEMP"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "wskbd_pickfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
          "lines": "1057-1070",
          "snippet": "int\nwskbd_pickfree()\n{\n\tint i;\n\tstruct wskbd_softc *sc;\n\n\tfor (i = 0; i < wskbd_cd.cd_ndevs; i++) {\n\t\tif ((sc = wskbd_cd.cd_devs[i]) == NULL)\n\t\t\tcontinue;\n\t\tif (sc->sc_displaydv == NULL)\n\t\t\treturn (i);\n\t}\n\treturn (-1);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wsdisplay.h\"",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wskbdvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/malloc.h>",
            "#include <sys/timeout.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cfdriver wskbd_cd = {\n\tNULL, \"wskbd\", DV_TTY\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct cfdriver wskbd_cd = {\n\tNULL, \"wskbd\", DV_TTY\n};\n\nint\nwskbd_pickfree()\n{\n\tint i;\n\tstruct wskbd_softc *sc;\n\n\tfor (i = 0; i < wskbd_cd.cd_ndevs; i++) {\n\t\tif ((sc = wskbd_cd.cd_devs[i]) == NULL)\n\t\t\tcontinue;\n\t\tif (sc->sc_displaydv == NULL)\n\t\t\treturn (i);\n\t}\n\treturn (-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KB_VARIANT",
          "args": [
            "sc->sc_layout"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sc->sc_map",
            "buf",
            "len"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wskbd_init_keymap",
          "args": [
            "umdp->maplen",
            "&sc->sc_map",
            "&sc->sc_maplen"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "wskbd_init_keymap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbdutil.c",
          "lines": "382-405",
          "snippet": "void\nwskbd_init_keymap(newlen, map, maplen)\n\tint newlen;\n\tstruct wscons_keymap **map;\n\tint *maplen;\n{\n\tint i;\n\n\tif (newlen != *maplen) {\n\t\tif (*maplen > 0)\n\t\t\tfree(*map, M_TEMP);\n\t\t*maplen = newlen;\n\t\t*map = malloc(newlen*sizeof(struct wscons_keymap),\n\t\t\t      M_TEMP, M_WAITOK);\n\t}\n\n\tfor (i = 0; i < *maplen; i++) {\n\t\t(*map)[i].command = KS_voidSymbol;\n\t\t(*map)[i].group1[0] = KS_voidSymbol;\n\t\t(*map)[i].group1[1] = KS_voidSymbol;\n\t\t(*map)[i].group2[0] = KS_voidSymbol;\n\t\t(*map)[i].group2[1] = KS_voidSymbol;\n\t}\n}",
          "includes": [
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdefs.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/errno.h>\n#include <sys/cdefs.h>\n#include <sys/types.h>\n#include <sys/param.h>\n\nvoid\nwskbd_init_keymap(newlen, map, maplen)\n\tint newlen;\n\tstruct wscons_keymap **map;\n\tint *maplen;\n{\n\tint i;\n\n\tif (newlen != *maplen) {\n\t\tif (*maplen > 0)\n\t\t\tfree(*map, M_TEMP);\n\t\t*maplen = newlen;\n\t\t*map = malloc(newlen*sizeof(struct wscons_keymap),\n\t\t\t      M_TEMP, M_WAITOK);\n\t}\n\n\tfor (i = 0; i < *maplen; i++) {\n\t\t(*map)[i].command = KS_voidSymbol;\n\t\t(*map)[i].group1[0] = KS_voidSymbol;\n\t\t(*map)[i].group1[1] = KS_voidSymbol;\n\t\t(*map)[i].group2[0] = KS_voidSymbol;\n\t\t(*map)[i].group2[1] = KS_voidSymbol;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "copyin",
          "args": [
            "umdp->map",
            "buf",
            "len"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len",
            "M_TEMP",
            "M_WAITOK"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "suser",
          "args": [
            "p->p_ucred",
            "&p->p_acflag"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SETKEYREPEAT",
          "args": [
            "ukdp",
            "kkdp",
            "kkdp"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SETKEYREPEAT",
          "args": [
            "kkdp",
            "ukdp",
            "kkdp"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "suser",
          "args": [
            "p->p_ucred",
            "&p->p_acflag"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SETBELL",
          "args": [
            "ubdp",
            "kbdp",
            "kbdp"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SETBELL",
          "args": [
            "kbdp",
            "ubdp",
            "kbdp"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc->sc_accesscookie",
            "WSKBDIO_COMPLEXBELL",
            "(caddr_t)ubdp",
            "flag",
            "p"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SETBELL",
          "args": [
            "ubdp",
            "ubdp",
            "&sc->sc_bell_data"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc->sc_accesscookie",
            "WSKBDIO_COMPLEXBELL",
            "(caddr_t)&sc->sc_bell_data",
            "flag",
            "p"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define MOD_COMMAND2\t\t(1 << 14)\n#define MOD_COMMAND1\t\t(1 << 13)\n#define MOD_COMMAND\t\t(1 << 12)\n#define MOD_META_R\t\t(1 << 7)\n#define MOD_META_L\t\t(1 << 6)\n#define MOD_CONTROL_R\t\t(1 << 5)\n#define MOD_CONTROL_L\t\t(1 << 4)\n#define MOD_SHIFT_R\t\t(1 << 1)\n#define MOD_SHIFT_L\t\t(1 << 0)\n\nstatic int wskbd_displayioctl;\nstruct wskbd_bell_data wskbd_default_bell_data = {\n\tWSKBD_BELL_DOALL,\n\tWSKBD_DEFAULT_BELL_PITCH,\n\tWSKBD_DEFAULT_BELL_PERIOD,\n\tWSKBD_DEFAULT_BELL_VOLUME,\n};\nstruct wskbd_keyrepeat_data wskbd_default_keyrepeat_data = {\n\tWSKBD_KEYREPEAT_DOALL,\n\tWSKBD_DEFAULT_KEYREPEAT_DEL1,\n\tWSKBD_DEFAULT_KEYREPEAT_DELN,\n};\nstatic void wskbd_update_layout;\n\nstatic int\nwskbd_displayioctl(dev, cmd, data, flag, p)\n\tstruct device *dev;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct wskbd_softc *sc = (struct wskbd_softc *)dev;\n\tstruct wskbd_bell_data *ubdp, *kbdp;\n\tstruct wskbd_keyrepeat_data *ukdp, *kkdp;\n\tstruct wskbd_map_data *umdp;\n\tstruct wskbd_mapdata md;\n\tkbd_t enc;\n\tvoid *buf;\n\tint len, error;\n\n\tswitch (cmd) {\n#define\tSETBELL(dstp, srcp, dfltp)\t\t\t\t\t\\\n    do {\t\t\t\t\t\t\t\t\\\n\t(dstp)->pitch = ((srcp)->which & WSKBD_BELL_DOPITCH) ?\t\t\\\n\t    (srcp)->pitch : (dfltp)->pitch;\t\t\t\t\\\n\t(dstp)->period = ((srcp)->which & WSKBD_BELL_DOPERIOD) ?\t\\\n\t    (srcp)->period : (dfltp)->period;\t\t\t\t\\\n\t(dstp)->volume = ((srcp)->which & WSKBD_BELL_DOVOLUME) ?\t\\\n\t    (srcp)->volume : (dfltp)->volume;\t\t\t\t\\\n\t(dstp)->which = WSKBD_BELL_DOALL;\t\t\t\t\\\n    } while (0)\n\n\tcase WSKBDIO_BELL:\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn (EACCES);\n\t\treturn ((*sc->sc_accessops->ioctl)(sc->sc_accesscookie,\n\t\t    WSKBDIO_COMPLEXBELL, (caddr_t)&sc->sc_bell_data, flag, p));\n\n\tcase WSKBDIO_COMPLEXBELL:\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn (EACCES);\n\t\tubdp = (struct wskbd_bell_data *)data;\n\t\tSETBELL(ubdp, ubdp, &sc->sc_bell_data);\n\t\treturn ((*sc->sc_accessops->ioctl)(sc->sc_accesscookie,\n\t\t    WSKBDIO_COMPLEXBELL, (caddr_t)ubdp, flag, p));\n\n\tcase WSKBDIO_SETBELL:\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn (EACCES);\n\t\tkbdp = &sc->sc_bell_data;\nsetbell:\n\t\tubdp = (struct wskbd_bell_data *)data;\n\t\tSETBELL(kbdp, ubdp, kbdp);\n\t\treturn (0);\n\n\tcase WSKBDIO_GETBELL:\n\t\tkbdp = &sc->sc_bell_data;\ngetbell:\n\t\tubdp = (struct wskbd_bell_data *)data;\n\t\tSETBELL(ubdp, kbdp, kbdp);\n\t\treturn (0);\n\n\tcase WSKBDIO_SETDEFAULTBELL:\n\t\tif ((error = suser(p->p_ucred, &p->p_acflag)) != 0)\n\t\t\treturn (error);\n\t\tkbdp = &wskbd_default_bell_data;\n\t\tgoto setbell;\n\n\n\tcase WSKBDIO_GETDEFAULTBELL:\n\t\tkbdp = &wskbd_default_bell_data;\n\t\tgoto getbell;\n\n#undef SETBELL\n\n#define\tSETKEYREPEAT(dstp, srcp, dfltp)\t\t\t\t\t\\\n    do {\t\t\t\t\t\t\t\t\\\n\t(dstp)->del1 = ((srcp)->which & WSKBD_KEYREPEAT_DODEL1) ?\t\\\n\t    (srcp)->del1 : (dfltp)->del1;\t\t\t\t\\\n\t(dstp)->delN = ((srcp)->which & WSKBD_KEYREPEAT_DODELN) ?\t\\\n\t    (srcp)->delN : (dfltp)->delN;\t\t\t\t\\\n\t(dstp)->which = WSKBD_KEYREPEAT_DOALL;\t\t\t\t\\\n    } while (0)\n\n\tcase WSKBDIO_SETKEYREPEAT:\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn (EACCES);\n\t\tkkdp = &sc->sc_keyrepeat_data;\nsetkeyrepeat:\n\t\tukdp = (struct wskbd_keyrepeat_data *)data;\n\t\tSETKEYREPEAT(kkdp, ukdp, kkdp);\n\t\treturn (0);\n\n\tcase WSKBDIO_GETKEYREPEAT:\n\t\tkkdp = &sc->sc_keyrepeat_data;\ngetkeyrepeat:\n\t\tukdp = (struct wskbd_keyrepeat_data *)data;\n\t\tSETKEYREPEAT(ukdp, kkdp, kkdp);\n\t\treturn (0);\n\n\tcase WSKBDIO_SETDEFAULTKEYREPEAT:\n\t\tif ((error = suser(p->p_ucred, &p->p_acflag)) != 0)\n\t\t\treturn (error);\n\t\tkkdp = &wskbd_default_keyrepeat_data;\n\t\tgoto setkeyrepeat;\n\n\n\tcase WSKBDIO_GETDEFAULTKEYREPEAT:\n\t\tkkdp = &wskbd_default_keyrepeat_data;\n\t\tgoto getkeyrepeat;\n\n#undef SETKEYREPEAT\n\n\tcase WSKBDIO_SETMAP:\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn (EACCES);\n\t\tumdp = (struct wskbd_map_data *)data;\n\t\tlen = umdp->maplen*sizeof(struct wscons_keymap);\n\t\tbuf = malloc(len, M_TEMP, M_WAITOK);\n\t\terror = copyin(umdp->map, buf, len);\n\t\tif (error == 0) {\n\t\t\twskbd_init_keymap(umdp->maplen,\n\t\t\t\t\t  &sc->sc_map, &sc->sc_maplen);\n\t\t\tmemcpy(sc->sc_map, buf, len);\n\t\t\t/* drop the variant bits handled by the map */\n\t\t\tsc->sc_layout = KB_USER |\n\t\t\t      (KB_VARIANT(sc->sc_layout) & KB_HANDLEDBYWSKBD);\n\t\t\twskbd_update_layout(sc->id, sc->sc_layout);\n\t\t}\n\t\tfree(buf, M_TEMP);\n\t\treturn(error);\n\n\tcase WSKBDIO_GETMAP:\n\t\tumdp = (struct wskbd_map_data *)data;\n\t\tif (umdp->maplen > sc->sc_maplen)\n\t\t\tumdp->maplen = sc->sc_maplen;\n\t\terror = copyout(sc->sc_map, umdp->map,\n\t\t\t\tumdp->maplen*sizeof(struct wscons_keymap));\n\t\treturn(error);\n\n\tcase WSKBDIO_GETENCODING:\n\t\t*((kbd_t *) data) = sc->sc_layout;\n\t\treturn(0);\n\n\tcase WSKBDIO_SETENCODING:\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn (EACCES);\n\t\tenc = *((kbd_t *)data);\n\t\tif (KB_ENCODING(enc) == KB_USER) {\n\t\t\t/* user map must already be loaded */\n\t\t\tif (KB_ENCODING(sc->sc_layout) != KB_USER)\n\t\t\t\treturn (EINVAL);\n\t\t\t/* map variants make no sense */\n\t\t\tif (KB_VARIANT(enc) & ~KB_HANDLEDBYWSKBD)\n\t\t\t\treturn (EINVAL);\n\t\t} else {\n\t\tmd = *(sc->id->t_keymap); /* structure assignment */\n\t\t\tmd.layout = enc;\n\t\t\terror = wskbd_load_keymap(&md, &sc->sc_map,\n\t\t\t\t\t\t  &sc->sc_maplen);\n\t\t\tif (error)\n\t\treturn(error);\n\t}\n\t\tsc->sc_layout = enc;\n\t\twskbd_update_layout(sc->id, enc);\n\t\treturn (0);\n\t}\n\n\t/*\n\t * Try the keyboard driver for WSKBDIO ioctls.  It returns -1\n\t * if it didn't recognize the request, and in turn we return\n\t * -1 if we didn't recognize the request.\n\t */\n/* printf(\"kbdaccess\\n\"); */\n\terror = (*sc->sc_accessops->ioctl)(sc->sc_accesscookie, cmd, data,\n\t\t\t\t\t   flag, p);\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\tif (!error && cmd == WSKBDIO_SETMODE && *(int *)data == WSKBD_RAW) {\n\t\tint s = spltty();\n\t\tsc->id->t_modifiers &= ~(MOD_SHIFT_L | MOD_SHIFT_R\n\t\t\t\t\t | MOD_CONTROL_L | MOD_CONTROL_R\n\t\t\t\t\t | MOD_META_L | MOD_META_R\n\t\t\t\t\t | MOD_COMMAND\n\t\t\t\t\t | MOD_COMMAND1 | MOD_COMMAND2);\n#if NWSDISPLAY > 0\n\t\tif (sc->sc_repeating) {\n\t\t\tsc->sc_repeating = 0;\n\t\t\ttimeout_del(&sc->sc_repeat_ch);\n\t\t}\n#endif\n\t\tsplx(s);\n\t}\n#endif\n\treturn (error);\n}"
  },
  {
    "function_name": "wskbd_do_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
    "lines": "812-845",
    "snippet": "int\nwskbd_do_ioctl(sc, cmd, data, flag, p)\n\tstruct wskbd_softc *sc;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tint error;\n\n\t/*      \n\t * Try the generic ioctls that the wskbd interface supports.\n\t */\n\tswitch (cmd) {\n\tcase FIONBIO:\t\t/* we will remove this someday (soon???) */\n\t\treturn (0);\n\n\tcase FIOASYNC:\n\t\tsc->sc_events.async = *(int *)data != 0;\n\t\treturn (0);\n\n\tcase TIOCSPGRP:\n\t\tif (*(int *)data != sc->sc_events.io->p_pgid)\n\t\t\treturn (EPERM);\n\t\treturn (0);\n\t}\n\n\t/*\n\t * Try the keyboard driver for WSKBDIO ioctls.  It returns -1\n\t * if it didn't recognize the request.\n\t */\n\terror = wskbd_displayioctl((struct device *)sc, cmd, data, flag, p);\n\treturn (error != -1 ? error : ENOTTY);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wsdisplay.h\"",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wskbdvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int wskbd_displayioctl",
      "int\twskbd_do_ioctl"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wskbd_displayioctl",
          "args": [
            "(struct device *)sc",
            "cmd",
            "data",
            "flag",
            "p"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "wskbd_displayioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
          "lines": "851-1042",
          "snippet": "static int\nwskbd_displayioctl(dev, cmd, data, flag, p)\n\tstruct device *dev;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct wskbd_softc *sc = (struct wskbd_softc *)dev;\n\tstruct wskbd_bell_data *ubdp, *kbdp;\n\tstruct wskbd_keyrepeat_data *ukdp, *kkdp;\n\tstruct wskbd_map_data *umdp;\n\tstruct wskbd_mapdata md;\n\tkbd_t enc;\n\tvoid *buf;\n\tint len, error;\n\n\tswitch (cmd) {\n#define\tSETBELL(dstp, srcp, dfltp)\t\t\t\t\t\\\n    do {\t\t\t\t\t\t\t\t\\\n\t(dstp)->pitch = ((srcp)->which & WSKBD_BELL_DOPITCH) ?\t\t\\\n\t    (srcp)->pitch : (dfltp)->pitch;\t\t\t\t\\\n\t(dstp)->period = ((srcp)->which & WSKBD_BELL_DOPERIOD) ?\t\\\n\t    (srcp)->period : (dfltp)->period;\t\t\t\t\\\n\t(dstp)->volume = ((srcp)->which & WSKBD_BELL_DOVOLUME) ?\t\\\n\t    (srcp)->volume : (dfltp)->volume;\t\t\t\t\\\n\t(dstp)->which = WSKBD_BELL_DOALL;\t\t\t\t\\\n    } while (0)\n\n\tcase WSKBDIO_BELL:\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn (EACCES);\n\t\treturn ((*sc->sc_accessops->ioctl)(sc->sc_accesscookie,\n\t\t    WSKBDIO_COMPLEXBELL, (caddr_t)&sc->sc_bell_data, flag, p));\n\n\tcase WSKBDIO_COMPLEXBELL:\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn (EACCES);\n\t\tubdp = (struct wskbd_bell_data *)data;\n\t\tSETBELL(ubdp, ubdp, &sc->sc_bell_data);\n\t\treturn ((*sc->sc_accessops->ioctl)(sc->sc_accesscookie,\n\t\t    WSKBDIO_COMPLEXBELL, (caddr_t)ubdp, flag, p));\n\n\tcase WSKBDIO_SETBELL:\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn (EACCES);\n\t\tkbdp = &sc->sc_bell_data;\nsetbell:\n\t\tubdp = (struct wskbd_bell_data *)data;\n\t\tSETBELL(kbdp, ubdp, kbdp);\n\t\treturn (0);\n\n\tcase WSKBDIO_GETBELL:\n\t\tkbdp = &sc->sc_bell_data;\ngetbell:\n\t\tubdp = (struct wskbd_bell_data *)data;\n\t\tSETBELL(ubdp, kbdp, kbdp);\n\t\treturn (0);\n\n\tcase WSKBDIO_SETDEFAULTBELL:\n\t\tif ((error = suser(p->p_ucred, &p->p_acflag)) != 0)\n\t\t\treturn (error);\n\t\tkbdp = &wskbd_default_bell_data;\n\t\tgoto setbell;\n\n\n\tcase WSKBDIO_GETDEFAULTBELL:\n\t\tkbdp = &wskbd_default_bell_data;\n\t\tgoto getbell;\n\n#undef SETBELL\n\n#define\tSETKEYREPEAT(dstp, srcp, dfltp)\t\t\t\t\t\\\n    do {\t\t\t\t\t\t\t\t\\\n\t(dstp)->del1 = ((srcp)->which & WSKBD_KEYREPEAT_DODEL1) ?\t\\\n\t    (srcp)->del1 : (dfltp)->del1;\t\t\t\t\\\n\t(dstp)->delN = ((srcp)->which & WSKBD_KEYREPEAT_DODELN) ?\t\\\n\t    (srcp)->delN : (dfltp)->delN;\t\t\t\t\\\n\t(dstp)->which = WSKBD_KEYREPEAT_DOALL;\t\t\t\t\\\n    } while (0)\n\n\tcase WSKBDIO_SETKEYREPEAT:\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn (EACCES);\n\t\tkkdp = &sc->sc_keyrepeat_data;\nsetkeyrepeat:\n\t\tukdp = (struct wskbd_keyrepeat_data *)data;\n\t\tSETKEYREPEAT(kkdp, ukdp, kkdp);\n\t\treturn (0);\n\n\tcase WSKBDIO_GETKEYREPEAT:\n\t\tkkdp = &sc->sc_keyrepeat_data;\ngetkeyrepeat:\n\t\tukdp = (struct wskbd_keyrepeat_data *)data;\n\t\tSETKEYREPEAT(ukdp, kkdp, kkdp);\n\t\treturn (0);\n\n\tcase WSKBDIO_SETDEFAULTKEYREPEAT:\n\t\tif ((error = suser(p->p_ucred, &p->p_acflag)) != 0)\n\t\t\treturn (error);\n\t\tkkdp = &wskbd_default_keyrepeat_data;\n\t\tgoto setkeyrepeat;\n\n\n\tcase WSKBDIO_GETDEFAULTKEYREPEAT:\n\t\tkkdp = &wskbd_default_keyrepeat_data;\n\t\tgoto getkeyrepeat;\n\n#undef SETKEYREPEAT\n\n\tcase WSKBDIO_SETMAP:\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn (EACCES);\n\t\tumdp = (struct wskbd_map_data *)data;\n\t\tlen = umdp->maplen*sizeof(struct wscons_keymap);\n\t\tbuf = malloc(len, M_TEMP, M_WAITOK);\n\t\terror = copyin(umdp->map, buf, len);\n\t\tif (error == 0) {\n\t\t\twskbd_init_keymap(umdp->maplen,\n\t\t\t\t\t  &sc->sc_map, &sc->sc_maplen);\n\t\t\tmemcpy(sc->sc_map, buf, len);\n\t\t\t/* drop the variant bits handled by the map */\n\t\t\tsc->sc_layout = KB_USER |\n\t\t\t      (KB_VARIANT(sc->sc_layout) & KB_HANDLEDBYWSKBD);\n\t\t\twskbd_update_layout(sc->id, sc->sc_layout);\n\t\t}\n\t\tfree(buf, M_TEMP);\n\t\treturn(error);\n\n\tcase WSKBDIO_GETMAP:\n\t\tumdp = (struct wskbd_map_data *)data;\n\t\tif (umdp->maplen > sc->sc_maplen)\n\t\t\tumdp->maplen = sc->sc_maplen;\n\t\terror = copyout(sc->sc_map, umdp->map,\n\t\t\t\tumdp->maplen*sizeof(struct wscons_keymap));\n\t\treturn(error);\n\n\tcase WSKBDIO_GETENCODING:\n\t\t*((kbd_t *) data) = sc->sc_layout;\n\t\treturn(0);\n\n\tcase WSKBDIO_SETENCODING:\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn (EACCES);\n\t\tenc = *((kbd_t *)data);\n\t\tif (KB_ENCODING(enc) == KB_USER) {\n\t\t\t/* user map must already be loaded */\n\t\t\tif (KB_ENCODING(sc->sc_layout) != KB_USER)\n\t\t\t\treturn (EINVAL);\n\t\t\t/* map variants make no sense */\n\t\t\tif (KB_VARIANT(enc) & ~KB_HANDLEDBYWSKBD)\n\t\t\t\treturn (EINVAL);\n\t\t} else {\n\t\tmd = *(sc->id->t_keymap); /* structure assignment */\n\t\t\tmd.layout = enc;\n\t\t\terror = wskbd_load_keymap(&md, &sc->sc_map,\n\t\t\t\t\t\t  &sc->sc_maplen);\n\t\t\tif (error)\n\t\treturn(error);\n\t}\n\t\tsc->sc_layout = enc;\n\t\twskbd_update_layout(sc->id, enc);\n\t\treturn (0);\n\t}\n\n\t/*\n\t * Try the keyboard driver for WSKBDIO ioctls.  It returns -1\n\t * if it didn't recognize the request, and in turn we return\n\t * -1 if we didn't recognize the request.\n\t */\n/* printf(\"kbdaccess\\n\"); */\n\terror = (*sc->sc_accessops->ioctl)(sc->sc_accesscookie, cmd, data,\n\t\t\t\t\t   flag, p);\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\tif (!error && cmd == WSKBDIO_SETMODE && *(int *)data == WSKBD_RAW) {\n\t\tint s = spltty();\n\t\tsc->id->t_modifiers &= ~(MOD_SHIFT_L | MOD_SHIFT_R\n\t\t\t\t\t | MOD_CONTROL_L | MOD_CONTROL_R\n\t\t\t\t\t | MOD_META_L | MOD_META_R\n\t\t\t\t\t | MOD_COMMAND\n\t\t\t\t\t | MOD_COMMAND1 | MOD_COMMAND2);\n#if NWSDISPLAY > 0\n\t\tif (sc->sc_repeating) {\n\t\t\tsc->sc_repeating = 0;\n\t\t\ttimeout_del(&sc->sc_repeat_ch);\n\t\t}\n#endif\n\t\tsplx(s);\n\t}\n#endif\n\treturn (error);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wsdisplay.h\"",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wskbdvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/malloc.h>",
            "#include <sys/timeout.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [
            "#define MOD_COMMAND2\t\t(1 << 14)",
            "#define MOD_COMMAND1\t\t(1 << 13)",
            "#define MOD_COMMAND\t\t(1 << 12)",
            "#define MOD_META_R\t\t(1 << 7)",
            "#define MOD_META_L\t\t(1 << 6)",
            "#define MOD_CONTROL_R\t\t(1 << 5)",
            "#define MOD_CONTROL_L\t\t(1 << 4)",
            "#define MOD_SHIFT_R\t\t(1 << 1)",
            "#define MOD_SHIFT_L\t\t(1 << 0)"
          ],
          "globals_used": [
            "static int wskbd_displayioctl",
            "struct wskbd_bell_data wskbd_default_bell_data = {\n\tWSKBD_BELL_DOALL,\n\tWSKBD_DEFAULT_BELL_PITCH,\n\tWSKBD_DEFAULT_BELL_PERIOD,\n\tWSKBD_DEFAULT_BELL_VOLUME,\n};",
            "struct wskbd_keyrepeat_data wskbd_default_keyrepeat_data = {\n\tWSKBD_KEYREPEAT_DOALL,\n\tWSKBD_DEFAULT_KEYREPEAT_DEL1,\n\tWSKBD_DEFAULT_KEYREPEAT_DELN,\n};",
            "static void wskbd_update_layout"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define MOD_COMMAND2\t\t(1 << 14)\n#define MOD_COMMAND1\t\t(1 << 13)\n#define MOD_COMMAND\t\t(1 << 12)\n#define MOD_META_R\t\t(1 << 7)\n#define MOD_META_L\t\t(1 << 6)\n#define MOD_CONTROL_R\t\t(1 << 5)\n#define MOD_CONTROL_L\t\t(1 << 4)\n#define MOD_SHIFT_R\t\t(1 << 1)\n#define MOD_SHIFT_L\t\t(1 << 0)\n\nstatic int wskbd_displayioctl;\nstruct wskbd_bell_data wskbd_default_bell_data = {\n\tWSKBD_BELL_DOALL,\n\tWSKBD_DEFAULT_BELL_PITCH,\n\tWSKBD_DEFAULT_BELL_PERIOD,\n\tWSKBD_DEFAULT_BELL_VOLUME,\n};\nstruct wskbd_keyrepeat_data wskbd_default_keyrepeat_data = {\n\tWSKBD_KEYREPEAT_DOALL,\n\tWSKBD_DEFAULT_KEYREPEAT_DEL1,\n\tWSKBD_DEFAULT_KEYREPEAT_DELN,\n};\nstatic void wskbd_update_layout;\n\nstatic int\nwskbd_displayioctl(dev, cmd, data, flag, p)\n\tstruct device *dev;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct wskbd_softc *sc = (struct wskbd_softc *)dev;\n\tstruct wskbd_bell_data *ubdp, *kbdp;\n\tstruct wskbd_keyrepeat_data *ukdp, *kkdp;\n\tstruct wskbd_map_data *umdp;\n\tstruct wskbd_mapdata md;\n\tkbd_t enc;\n\tvoid *buf;\n\tint len, error;\n\n\tswitch (cmd) {\n#define\tSETBELL(dstp, srcp, dfltp)\t\t\t\t\t\\\n    do {\t\t\t\t\t\t\t\t\\\n\t(dstp)->pitch = ((srcp)->which & WSKBD_BELL_DOPITCH) ?\t\t\\\n\t    (srcp)->pitch : (dfltp)->pitch;\t\t\t\t\\\n\t(dstp)->period = ((srcp)->which & WSKBD_BELL_DOPERIOD) ?\t\\\n\t    (srcp)->period : (dfltp)->period;\t\t\t\t\\\n\t(dstp)->volume = ((srcp)->which & WSKBD_BELL_DOVOLUME) ?\t\\\n\t    (srcp)->volume : (dfltp)->volume;\t\t\t\t\\\n\t(dstp)->which = WSKBD_BELL_DOALL;\t\t\t\t\\\n    } while (0)\n\n\tcase WSKBDIO_BELL:\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn (EACCES);\n\t\treturn ((*sc->sc_accessops->ioctl)(sc->sc_accesscookie,\n\t\t    WSKBDIO_COMPLEXBELL, (caddr_t)&sc->sc_bell_data, flag, p));\n\n\tcase WSKBDIO_COMPLEXBELL:\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn (EACCES);\n\t\tubdp = (struct wskbd_bell_data *)data;\n\t\tSETBELL(ubdp, ubdp, &sc->sc_bell_data);\n\t\treturn ((*sc->sc_accessops->ioctl)(sc->sc_accesscookie,\n\t\t    WSKBDIO_COMPLEXBELL, (caddr_t)ubdp, flag, p));\n\n\tcase WSKBDIO_SETBELL:\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn (EACCES);\n\t\tkbdp = &sc->sc_bell_data;\nsetbell:\n\t\tubdp = (struct wskbd_bell_data *)data;\n\t\tSETBELL(kbdp, ubdp, kbdp);\n\t\treturn (0);\n\n\tcase WSKBDIO_GETBELL:\n\t\tkbdp = &sc->sc_bell_data;\ngetbell:\n\t\tubdp = (struct wskbd_bell_data *)data;\n\t\tSETBELL(ubdp, kbdp, kbdp);\n\t\treturn (0);\n\n\tcase WSKBDIO_SETDEFAULTBELL:\n\t\tif ((error = suser(p->p_ucred, &p->p_acflag)) != 0)\n\t\t\treturn (error);\n\t\tkbdp = &wskbd_default_bell_data;\n\t\tgoto setbell;\n\n\n\tcase WSKBDIO_GETDEFAULTBELL:\n\t\tkbdp = &wskbd_default_bell_data;\n\t\tgoto getbell;\n\n#undef SETBELL\n\n#define\tSETKEYREPEAT(dstp, srcp, dfltp)\t\t\t\t\t\\\n    do {\t\t\t\t\t\t\t\t\\\n\t(dstp)->del1 = ((srcp)->which & WSKBD_KEYREPEAT_DODEL1) ?\t\\\n\t    (srcp)->del1 : (dfltp)->del1;\t\t\t\t\\\n\t(dstp)->delN = ((srcp)->which & WSKBD_KEYREPEAT_DODELN) ?\t\\\n\t    (srcp)->delN : (dfltp)->delN;\t\t\t\t\\\n\t(dstp)->which = WSKBD_KEYREPEAT_DOALL;\t\t\t\t\\\n    } while (0)\n\n\tcase WSKBDIO_SETKEYREPEAT:\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn (EACCES);\n\t\tkkdp = &sc->sc_keyrepeat_data;\nsetkeyrepeat:\n\t\tukdp = (struct wskbd_keyrepeat_data *)data;\n\t\tSETKEYREPEAT(kkdp, ukdp, kkdp);\n\t\treturn (0);\n\n\tcase WSKBDIO_GETKEYREPEAT:\n\t\tkkdp = &sc->sc_keyrepeat_data;\ngetkeyrepeat:\n\t\tukdp = (struct wskbd_keyrepeat_data *)data;\n\t\tSETKEYREPEAT(ukdp, kkdp, kkdp);\n\t\treturn (0);\n\n\tcase WSKBDIO_SETDEFAULTKEYREPEAT:\n\t\tif ((error = suser(p->p_ucred, &p->p_acflag)) != 0)\n\t\t\treturn (error);\n\t\tkkdp = &wskbd_default_keyrepeat_data;\n\t\tgoto setkeyrepeat;\n\n\n\tcase WSKBDIO_GETDEFAULTKEYREPEAT:\n\t\tkkdp = &wskbd_default_keyrepeat_data;\n\t\tgoto getkeyrepeat;\n\n#undef SETKEYREPEAT\n\n\tcase WSKBDIO_SETMAP:\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn (EACCES);\n\t\tumdp = (struct wskbd_map_data *)data;\n\t\tlen = umdp->maplen*sizeof(struct wscons_keymap);\n\t\tbuf = malloc(len, M_TEMP, M_WAITOK);\n\t\terror = copyin(umdp->map, buf, len);\n\t\tif (error == 0) {\n\t\t\twskbd_init_keymap(umdp->maplen,\n\t\t\t\t\t  &sc->sc_map, &sc->sc_maplen);\n\t\t\tmemcpy(sc->sc_map, buf, len);\n\t\t\t/* drop the variant bits handled by the map */\n\t\t\tsc->sc_layout = KB_USER |\n\t\t\t      (KB_VARIANT(sc->sc_layout) & KB_HANDLEDBYWSKBD);\n\t\t\twskbd_update_layout(sc->id, sc->sc_layout);\n\t\t}\n\t\tfree(buf, M_TEMP);\n\t\treturn(error);\n\n\tcase WSKBDIO_GETMAP:\n\t\tumdp = (struct wskbd_map_data *)data;\n\t\tif (umdp->maplen > sc->sc_maplen)\n\t\t\tumdp->maplen = sc->sc_maplen;\n\t\terror = copyout(sc->sc_map, umdp->map,\n\t\t\t\tumdp->maplen*sizeof(struct wscons_keymap));\n\t\treturn(error);\n\n\tcase WSKBDIO_GETENCODING:\n\t\t*((kbd_t *) data) = sc->sc_layout;\n\t\treturn(0);\n\n\tcase WSKBDIO_SETENCODING:\n\t\tif ((flag & FWRITE) == 0)\n\t\t\treturn (EACCES);\n\t\tenc = *((kbd_t *)data);\n\t\tif (KB_ENCODING(enc) == KB_USER) {\n\t\t\t/* user map must already be loaded */\n\t\t\tif (KB_ENCODING(sc->sc_layout) != KB_USER)\n\t\t\t\treturn (EINVAL);\n\t\t\t/* map variants make no sense */\n\t\t\tif (KB_VARIANT(enc) & ~KB_HANDLEDBYWSKBD)\n\t\t\t\treturn (EINVAL);\n\t\t} else {\n\t\tmd = *(sc->id->t_keymap); /* structure assignment */\n\t\t\tmd.layout = enc;\n\t\t\terror = wskbd_load_keymap(&md, &sc->sc_map,\n\t\t\t\t\t\t  &sc->sc_maplen);\n\t\t\tif (error)\n\t\treturn(error);\n\t}\n\t\tsc->sc_layout = enc;\n\t\twskbd_update_layout(sc->id, enc);\n\t\treturn (0);\n\t}\n\n\t/*\n\t * Try the keyboard driver for WSKBDIO ioctls.  It returns -1\n\t * if it didn't recognize the request, and in turn we return\n\t * -1 if we didn't recognize the request.\n\t */\n/* printf(\"kbdaccess\\n\"); */\n\terror = (*sc->sc_accessops->ioctl)(sc->sc_accesscookie, cmd, data,\n\t\t\t\t\t   flag, p);\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\tif (!error && cmd == WSKBDIO_SETMODE && *(int *)data == WSKBD_RAW) {\n\t\tint s = spltty();\n\t\tsc->id->t_modifiers &= ~(MOD_SHIFT_L | MOD_SHIFT_R\n\t\t\t\t\t | MOD_CONTROL_L | MOD_CONTROL_R\n\t\t\t\t\t | MOD_META_L | MOD_META_R\n\t\t\t\t\t | MOD_COMMAND\n\t\t\t\t\t | MOD_COMMAND1 | MOD_COMMAND2);\n#if NWSDISPLAY > 0\n\t\tif (sc->sc_repeating) {\n\t\t\tsc->sc_repeating = 0;\n\t\t\ttimeout_del(&sc->sc_repeat_ch);\n\t\t}\n#endif\n\t\tsplx(s);\n\t}\n#endif\n\treturn (error);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstatic int wskbd_displayioctl;\nint\twskbd_do_ioctl;\n\nint\nwskbd_do_ioctl(sc, cmd, data, flag, p)\n\tstruct wskbd_softc *sc;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tint error;\n\n\t/*      \n\t * Try the generic ioctls that the wskbd interface supports.\n\t */\n\tswitch (cmd) {\n\tcase FIONBIO:\t\t/* we will remove this someday (soon???) */\n\t\treturn (0);\n\n\tcase FIOASYNC:\n\t\tsc->sc_events.async = *(int *)data != 0;\n\t\treturn (0);\n\n\tcase TIOCSPGRP:\n\t\tif (*(int *)data != sc->sc_events.io->p_pgid)\n\t\t\treturn (EPERM);\n\t\treturn (0);\n\t}\n\n\t/*\n\t * Try the keyboard driver for WSKBDIO ioctls.  It returns -1\n\t * if it didn't recognize the request.\n\t */\n\terror = wskbd_displayioctl((struct device *)sc, cmd, data, flag, p);\n\treturn (error != -1 ? error : ENOTTY);\n}"
  },
  {
    "function_name": "wskbddoioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
    "lines": "794-810",
    "snippet": "int\nwskbddoioctl(dv, cmd, data, flag, p)\n\tstruct device *dv;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct wskbd_softc *sc = (struct wskbd_softc *)dv;\n\tint error;\n\n\tsc->sc_refcnt++;\n\terror = wskbd_do_ioctl(sc, cmd, data, flag, p);\n\tif (--sc->sc_refcnt < 0)\n\t\twakeup(sc);\n\treturn (error);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wsdisplay.h\"",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wskbdvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\twskbd_do_ioctl",
      "int\twskbddoioctl"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "sc"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wskbd_do_ioctl",
          "args": [
            "sc",
            "cmd",
            "data",
            "flag",
            "p"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "wskbd_do_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
          "lines": "812-845",
          "snippet": "int\nwskbd_do_ioctl(sc, cmd, data, flag, p)\n\tstruct wskbd_softc *sc;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tint error;\n\n\t/*      \n\t * Try the generic ioctls that the wskbd interface supports.\n\t */\n\tswitch (cmd) {\n\tcase FIONBIO:\t\t/* we will remove this someday (soon???) */\n\t\treturn (0);\n\n\tcase FIOASYNC:\n\t\tsc->sc_events.async = *(int *)data != 0;\n\t\treturn (0);\n\n\tcase TIOCSPGRP:\n\t\tif (*(int *)data != sc->sc_events.io->p_pgid)\n\t\t\treturn (EPERM);\n\t\treturn (0);\n\t}\n\n\t/*\n\t * Try the keyboard driver for WSKBDIO ioctls.  It returns -1\n\t * if it didn't recognize the request.\n\t */\n\terror = wskbd_displayioctl((struct device *)sc, cmd, data, flag, p);\n\treturn (error != -1 ? error : ENOTTY);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wsdisplay.h\"",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wskbdvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/malloc.h>",
            "#include <sys/timeout.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int wskbd_displayioctl",
            "int\twskbd_do_ioctl"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstatic int wskbd_displayioctl;\nint\twskbd_do_ioctl;\n\nint\nwskbd_do_ioctl(sc, cmd, data, flag, p)\n\tstruct wskbd_softc *sc;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tint error;\n\n\t/*      \n\t * Try the generic ioctls that the wskbd interface supports.\n\t */\n\tswitch (cmd) {\n\tcase FIONBIO:\t\t/* we will remove this someday (soon???) */\n\t\treturn (0);\n\n\tcase FIOASYNC:\n\t\tsc->sc_events.async = *(int *)data != 0;\n\t\treturn (0);\n\n\tcase TIOCSPGRP:\n\t\tif (*(int *)data != sc->sc_events.io->p_pgid)\n\t\t\treturn (EPERM);\n\t\treturn (0);\n\t}\n\n\t/*\n\t * Try the keyboard driver for WSKBDIO ioctls.  It returns -1\n\t * if it didn't recognize the request.\n\t */\n\terror = wskbd_displayioctl((struct device *)sc, cmd, data, flag, p);\n\treturn (error != -1 ? error : ENOTTY);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nint\twskbd_do_ioctl;\nint\twskbddoioctl;\n\nint\nwskbddoioctl(dv, cmd, data, flag, p)\n\tstruct device *dv;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct wskbd_softc *sc = (struct wskbd_softc *)dv;\n\tint error;\n\n\tsc->sc_refcnt++;\n\terror = wskbd_do_ioctl(sc, cmd, data, flag, p);\n\tif (--sc->sc_refcnt < 0)\n\t\twakeup(sc);\n\treturn (error);\n}"
  },
  {
    "function_name": "wskbdioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
    "lines": "782-791",
    "snippet": "int\nwskbdioctl(dev, cmd, data, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\treturn (wskbddoioctl(wskbd_cd.cd_devs[minor(dev)], cmd, data, flag,p));\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wsdisplay.h\"",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wskbdvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\twskbddoioctl",
      "struct cfdriver wskbd_cd = {\n\tNULL, \"wskbd\", DV_TTY\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wskbddoioctl",
          "args": [
            "wskbd_cd.cd_devs[minor(dev)]",
            "cmd",
            "data",
            "flag",
            "p"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "wskbddoioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
          "lines": "794-810",
          "snippet": "int\nwskbddoioctl(dv, cmd, data, flag, p)\n\tstruct device *dv;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct wskbd_softc *sc = (struct wskbd_softc *)dv;\n\tint error;\n\n\tsc->sc_refcnt++;\n\terror = wskbd_do_ioctl(sc, cmd, data, flag, p);\n\tif (--sc->sc_refcnt < 0)\n\t\twakeup(sc);\n\treturn (error);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wsdisplay.h\"",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wskbdvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/malloc.h>",
            "#include <sys/timeout.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\twskbd_do_ioctl",
            "int\twskbddoioctl"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nint\twskbd_do_ioctl;\nint\twskbddoioctl;\n\nint\nwskbddoioctl(dv, cmd, data, flag, p)\n\tstruct device *dv;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct wskbd_softc *sc = (struct wskbd_softc *)dv;\n\tint error;\n\n\tsc->sc_refcnt++;\n\terror = wskbd_do_ioctl(sc, cmd, data, flag, p);\n\tif (--sc->sc_refcnt < 0)\n\t\twakeup(sc);\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nint\twskbddoioctl;\nstruct cfdriver wskbd_cd = {\n\tNULL, \"wskbd\", DV_TTY\n};\n\nint\nwskbdioctl(dev, cmd, data, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\treturn (wskbddoioctl(wskbd_cd.cd_devs[minor(dev)], cmd, data, flag,p));\n}"
  },
  {
    "function_name": "wskbdread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
    "lines": "761-780",
    "snippet": "int\nwskbdread(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\tstruct wskbd_softc *sc = wskbd_cd.cd_devs[minor(dev)];\n\tint error;\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\tsc->sc_refcnt++;\n\terror = wsevent_read(&sc->sc_events, uio, flags);\n\tif (--sc->sc_refcnt < 0) {\n\t\twakeup(sc);\n\t\terror = EIO;\n\t}\n\treturn (error);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wsdisplay.h\"",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wskbdvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cfdriver wskbd_cd = {\n\tNULL, \"wskbd\", DV_TTY\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "sc"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wsevent_read",
          "args": [
            "&sc->sc_events",
            "uio",
            "flags"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "wsevent_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsevent.c",
          "lines": "125-181",
          "snippet": "int\nwsevent_read(ev, uio, flags)\n\tstruct wseventvar *ev;\n\tstruct uio *uio;\n\tint flags;\n{\n\tint s, n, cnt, error;\n\n\t/*\n\t * Make sure we can return at least 1.\n\t */\n\tif (uio->uio_resid < sizeof(struct wscons_event))\n\t\treturn (EMSGSIZE);\t/* ??? */\n\ts = splwsevent();\n\twhile (ev->get == ev->put) {\n\t\tif (flags & IO_NDELAY) {\n\t\t\tsplx(s);\n\t\t\treturn (EWOULDBLOCK);\n\t\t}\n\t\tev->wanted = 1;\n\t\terror = tsleep((caddr_t)ev, PWSEVENT | PCATCH,\n\t\t    \"wsevent_read\", 0);\n\t\tif (error) {\n\t\t\tsplx(s);\n\t\t\treturn (error);\n\t\t}\n\t}\n\t/*\n\t * Move wscons_event from tail end of queue (there is at least one\n\t * there).\n\t */\n\tif (ev->put < ev->get)\n\t\tcnt = WSEVENT_QSIZE - ev->get;\t/* events in [get..QSIZE) */\n\telse\n\t\tcnt = ev->put - ev->get;\t/* events in [get..put) */\n\tsplx(s);\n\tn = howmany(uio->uio_resid, sizeof(struct wscons_event));\n\tif (cnt > n)\n\t\tcnt = n;\n\terror = uiomove((caddr_t)&ev->q[ev->get],\n\t    cnt * sizeof(struct wscons_event), uio);\n\tn -= cnt;\n\t/*\n\t * If we do not wrap to 0, used up all our space, or had an error,\n\t * stop.  Otherwise move from front of queue to put index, if there\n\t * is anything there to move.\n\t */\n\tif ((ev->get = (ev->get + cnt) % WSEVENT_QSIZE) != 0 ||\n\t    n == 0 || error || (cnt = ev->put) == 0)\n\t\treturn (error);\n\tif (cnt > n)\n\t\tcnt = n;\n\terror = uiomove((caddr_t)&ev->q[0],\n\t    cnt * sizeof(struct wscons_event), uio);\n\tev->get = cnt;\n\treturn (error);\n}",
          "includes": [
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nint\nwsevent_read(ev, uio, flags)\n\tstruct wseventvar *ev;\n\tstruct uio *uio;\n\tint flags;\n{\n\tint s, n, cnt, error;\n\n\t/*\n\t * Make sure we can return at least 1.\n\t */\n\tif (uio->uio_resid < sizeof(struct wscons_event))\n\t\treturn (EMSGSIZE);\t/* ??? */\n\ts = splwsevent();\n\twhile (ev->get == ev->put) {\n\t\tif (flags & IO_NDELAY) {\n\t\t\tsplx(s);\n\t\t\treturn (EWOULDBLOCK);\n\t\t}\n\t\tev->wanted = 1;\n\t\terror = tsleep((caddr_t)ev, PWSEVENT | PCATCH,\n\t\t    \"wsevent_read\", 0);\n\t\tif (error) {\n\t\t\tsplx(s);\n\t\t\treturn (error);\n\t\t}\n\t}\n\t/*\n\t * Move wscons_event from tail end of queue (there is at least one\n\t * there).\n\t */\n\tif (ev->put < ev->get)\n\t\tcnt = WSEVENT_QSIZE - ev->get;\t/* events in [get..QSIZE) */\n\telse\n\t\tcnt = ev->put - ev->get;\t/* events in [get..put) */\n\tsplx(s);\n\tn = howmany(uio->uio_resid, sizeof(struct wscons_event));\n\tif (cnt > n)\n\t\tcnt = n;\n\terror = uiomove((caddr_t)&ev->q[ev->get],\n\t    cnt * sizeof(struct wscons_event), uio);\n\tn -= cnt;\n\t/*\n\t * If we do not wrap to 0, used up all our space, or had an error,\n\t * stop.  Otherwise move from front of queue to put index, if there\n\t * is anything there to move.\n\t */\n\tif ((ev->get = (ev->get + cnt) % WSEVENT_QSIZE) != 0 ||\n\t    n == 0 || error || (cnt = ev->put) == 0)\n\t\treturn (error);\n\tif (cnt > n)\n\t\tcnt = n;\n\terror = uiomove((caddr_t)&ev->q[0],\n\t    cnt * sizeof(struct wscons_event), uio);\n\tev->get = cnt;\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct cfdriver wskbd_cd = {\n\tNULL, \"wskbd\", DV_TTY\n};\n\nint\nwskbdread(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\tstruct wskbd_softc *sc = wskbd_cd.cd_devs[minor(dev)];\n\tint error;\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\tsc->sc_refcnt++;\n\terror = wsevent_read(&sc->sc_events, uio, flags);\n\tif (--sc->sc_refcnt < 0) {\n\t\twakeup(sc);\n\t\terror = EIO;\n\t}\n\treturn (error);\n}"
  },
  {
    "function_name": "wskbddoclose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
    "lines": "738-759",
    "snippet": "int\nwskbddoclose(dv, flags, mode, p)\n\tstruct device *dv;\n\tint flags, mode;\n\tstruct proc *p;\n{\n\tstruct wskbd_softc *sc = (struct wskbd_softc *)dv;\n\n\tif (!(flags & FREAD)) {\n\t\t/* Nothing to do, because open didn't do anything. */\n\t\treturn (0);\n\t}\n\n\tsc->sc_ready = 0;\t\t\t/* stop accepting events */\n\tsc->sc_translating = 1;\n\n\twsevent_fini(&sc->sc_events);\n\tsc->sc_events.io = NULL;\n\n\twskbd_enable(sc, 0);\n\treturn (0);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wsdisplay.h\"",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wskbdvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int wskbd_enable",
      "int\twskbddoclose"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wskbd_enable",
          "args": [
            "sc",
            "0"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "wskbd_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
          "lines": "670-687",
          "snippet": "static int\nwskbd_enable(sc, on)\n\tstruct wskbd_softc *sc;\n\tint on;\n{\n\tint res;\n\n\t/* XXX reference count? */\n\tif (!on && (!sc->sc_translating\n#if NWSDISPLAY > 0\n\t\t    || sc->sc_displaydv\n#endif\n\t\t))\n\t\treturn (EBUSY);\n\n\tres = (*sc->sc_accessops->enable)(sc->sc_accesscookie, on);\n\treturn (res);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wsdisplay.h\"",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wskbdvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/malloc.h>",
            "#include <sys/timeout.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int wskbd_enable"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstatic int wskbd_enable;\n\nstatic int\nwskbd_enable(sc, on)\n\tstruct wskbd_softc *sc;\n\tint on;\n{\n\tint res;\n\n\t/* XXX reference count? */\n\tif (!on && (!sc->sc_translating\n#if NWSDISPLAY > 0\n\t\t    || sc->sc_displaydv\n#endif\n\t\t))\n\t\treturn (EBUSY);\n\n\tres = (*sc->sc_accessops->enable)(sc->sc_accesscookie, on);\n\treturn (res);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wsevent_fini",
          "args": [
            "&sc->sc_events"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "wsevent_fini",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsevent.c",
          "lines": "113-119",
          "snippet": "void\nwsevent_fini(ev)\n\tstruct wseventvar *ev;\n{\n\n\tfree(ev->q, M_DEVBUF);\n}",
          "includes": [
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nvoid\nwsevent_fini(ev)\n\tstruct wseventvar *ev;\n{\n\n\tfree(ev->q, M_DEVBUF);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstatic int wskbd_enable;\nint\twskbddoclose;\n\nint\nwskbddoclose(dv, flags, mode, p)\n\tstruct device *dv;\n\tint flags, mode;\n\tstruct proc *p;\n{\n\tstruct wskbd_softc *sc = (struct wskbd_softc *)dv;\n\n\tif (!(flags & FREAD)) {\n\t\t/* Nothing to do, because open didn't do anything. */\n\t\treturn (0);\n\t}\n\n\tsc->sc_ready = 0;\t\t\t/* stop accepting events */\n\tsc->sc_translating = 1;\n\n\twsevent_fini(&sc->sc_events);\n\tsc->sc_events.io = NULL;\n\n\twskbd_enable(sc, 0);\n\treturn (0);\n}"
  },
  {
    "function_name": "wskbdclose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
    "lines": "729-736",
    "snippet": "int\nwskbdclose(dev, flags, mode, p)\n\tdev_t dev;\n\tint flags, mode;\n\tstruct proc *p;\n{\n\treturn (wskbddoclose(wskbd_cd.cd_devs[minor(dev)], flags, mode, p));\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wsdisplay.h\"",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wskbdvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\twskbddoclose",
      "struct cfdriver wskbd_cd = {\n\tNULL, \"wskbd\", DV_TTY\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wskbddoclose",
          "args": [
            "wskbd_cd.cd_devs[minor(dev)]",
            "flags",
            "mode",
            "p"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "wskbddoclose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
          "lines": "738-759",
          "snippet": "int\nwskbddoclose(dv, flags, mode, p)\n\tstruct device *dv;\n\tint flags, mode;\n\tstruct proc *p;\n{\n\tstruct wskbd_softc *sc = (struct wskbd_softc *)dv;\n\n\tif (!(flags & FREAD)) {\n\t\t/* Nothing to do, because open didn't do anything. */\n\t\treturn (0);\n\t}\n\n\tsc->sc_ready = 0;\t\t\t/* stop accepting events */\n\tsc->sc_translating = 1;\n\n\twsevent_fini(&sc->sc_events);\n\tsc->sc_events.io = NULL;\n\n\twskbd_enable(sc, 0);\n\treturn (0);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wsdisplay.h\"",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wskbdvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/malloc.h>",
            "#include <sys/timeout.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int wskbd_enable",
            "int\twskbddoclose"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstatic int wskbd_enable;\nint\twskbddoclose;\n\nint\nwskbddoclose(dv, flags, mode, p)\n\tstruct device *dv;\n\tint flags, mode;\n\tstruct proc *p;\n{\n\tstruct wskbd_softc *sc = (struct wskbd_softc *)dv;\n\n\tif (!(flags & FREAD)) {\n\t\t/* Nothing to do, because open didn't do anything. */\n\t\treturn (0);\n\t}\n\n\tsc->sc_ready = 0;\t\t\t/* stop accepting events */\n\tsc->sc_translating = 1;\n\n\twsevent_fini(&sc->sc_events);\n\tsc->sc_events.io = NULL;\n\n\twskbd_enable(sc, 0);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nint\twskbddoclose;\nstruct cfdriver wskbd_cd = {\n\tNULL, \"wskbd\", DV_TTY\n};\n\nint\nwskbdclose(dev, flags, mode, p)\n\tdev_t dev;\n\tint flags, mode;\n\tstruct proc *p;\n{\n\treturn (wskbddoclose(wskbd_cd.cd_devs[minor(dev)], flags, mode, p));\n}"
  },
  {
    "function_name": "wskbdopen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
    "lines": "689-727",
    "snippet": "int\nwskbdopen(dev, flags, mode, p)\n\tdev_t dev;\n\tint flags, mode;\n\tstruct proc *p;\n{\n\tstruct wskbd_softc *sc;\n\tint unit;\n\n\tunit = minor(dev);\n\tif (unit >= wskbd_cd.cd_ndevs ||\t/* make sure it was attached */\n\t    (sc = wskbd_cd.cd_devs[unit]) == NULL)\n\t\treturn (ENXIO);\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\tif (!(flags & FREAD)) {\n\t\t/* Not opening for read, only ioctl is available. */\n\t\treturn (0);\n\t}\n\n#if NWSMUX > 0\n\tif (sc->sc_mux)\n\t\treturn (EBUSY);\n#endif\n\n\tif (sc->sc_events.io)\t\t\t/* and that it's not in use */\n\t\treturn (EBUSY);\n\n\tsc->sc_events.io = p;\n\twsevent_init(&sc->sc_events);\t\t/* may cause sleep */\n\n\tsc->sc_translating = 0;\n\tsc->sc_ready = 1;\t\t\t/* start accepting events */\n\n\twskbd_enable(sc, 1);\n\treturn (0);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wsdisplay.h\"",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wskbdvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int wskbd_enable",
      "struct cfdriver wskbd_cd = {\n\tNULL, \"wskbd\", DV_TTY\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wskbd_enable",
          "args": [
            "sc",
            "1"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "wskbd_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
          "lines": "670-687",
          "snippet": "static int\nwskbd_enable(sc, on)\n\tstruct wskbd_softc *sc;\n\tint on;\n{\n\tint res;\n\n\t/* XXX reference count? */\n\tif (!on && (!sc->sc_translating\n#if NWSDISPLAY > 0\n\t\t    || sc->sc_displaydv\n#endif\n\t\t))\n\t\treturn (EBUSY);\n\n\tres = (*sc->sc_accessops->enable)(sc->sc_accesscookie, on);\n\treturn (res);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wsdisplay.h\"",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wskbdvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/malloc.h>",
            "#include <sys/timeout.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int wskbd_enable"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstatic int wskbd_enable;\n\nstatic int\nwskbd_enable(sc, on)\n\tstruct wskbd_softc *sc;\n\tint on;\n{\n\tint res;\n\n\t/* XXX reference count? */\n\tif (!on && (!sc->sc_translating\n#if NWSDISPLAY > 0\n\t\t    || sc->sc_displaydv\n#endif\n\t\t))\n\t\treturn (EBUSY);\n\n\tres = (*sc->sc_accessops->enable)(sc->sc_accesscookie, on);\n\treturn (res);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wsevent_init",
          "args": [
            "&sc->sc_events"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "wsevent_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsevent.c",
          "lines": "99-108",
          "snippet": "void\nwsevent_init(ev)\n\tstruct wseventvar *ev;\n{\n\n\tev->get = ev->put = 0;\n\tev->q = malloc((u_long)WSEVENT_QSIZE * sizeof(struct wscons_event),\n\t    M_DEVBUF, M_WAITOK);\n\tbzero((caddr_t)ev->q, WSEVENT_QSIZE * sizeof(struct wscons_event));\n}",
          "includes": [
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nvoid\nwsevent_init(ev)\n\tstruct wseventvar *ev;\n{\n\n\tev->get = ev->put = 0;\n\tev->q = malloc((u_long)WSEVENT_QSIZE * sizeof(struct wscons_event),\n\t    M_DEVBUF, M_WAITOK);\n\tbzero((caddr_t)ev->q, WSEVENT_QSIZE * sizeof(struct wscons_event));\n}"
        }
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstatic int wskbd_enable;\nstruct cfdriver wskbd_cd = {\n\tNULL, \"wskbd\", DV_TTY\n};\n\nint\nwskbdopen(dev, flags, mode, p)\n\tdev_t dev;\n\tint flags, mode;\n\tstruct proc *p;\n{\n\tstruct wskbd_softc *sc;\n\tint unit;\n\n\tunit = minor(dev);\n\tif (unit >= wskbd_cd.cd_ndevs ||\t/* make sure it was attached */\n\t    (sc = wskbd_cd.cd_devs[unit]) == NULL)\n\t\treturn (ENXIO);\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\tif (!(flags & FREAD)) {\n\t\t/* Not opening for read, only ioctl is available. */\n\t\treturn (0);\n\t}\n\n#if NWSMUX > 0\n\tif (sc->sc_mux)\n\t\treturn (EBUSY);\n#endif\n\n\tif (sc->sc_events.io)\t\t\t/* and that it's not in use */\n\t\treturn (EBUSY);\n\n\tsc->sc_events.io = p;\n\twsevent_init(&sc->sc_events);\t\t/* may cause sleep */\n\n\tsc->sc_translating = 0;\n\tsc->sc_ready = 1;\t\t\t/* start accepting events */\n\n\twskbd_enable(sc, 1);\n\treturn (0);\n}"
  },
  {
    "function_name": "wskbd_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
    "lines": "670-687",
    "snippet": "static int\nwskbd_enable(sc, on)\n\tstruct wskbd_softc *sc;\n\tint on;\n{\n\tint res;\n\n\t/* XXX reference count? */\n\tif (!on && (!sc->sc_translating\n#if NWSDISPLAY > 0\n\t\t    || sc->sc_displaydv\n#endif\n\t\t))\n\t\treturn (EBUSY);\n\n\tres = (*sc->sc_accessops->enable)(sc->sc_accesscookie, on);\n\treturn (res);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wsdisplay.h\"",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wskbdvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int wskbd_enable"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc->sc_accesscookie",
            "on"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstatic int wskbd_enable;\n\nstatic int\nwskbd_enable(sc, on)\n\tstruct wskbd_softc *sc;\n\tint on;\n{\n\tint res;\n\n\t/* XXX reference count? */\n\tif (!on && (!sc->sc_translating\n#if NWSDISPLAY > 0\n\t\t    || sc->sc_displaydv\n#endif\n\t\t))\n\t\treturn (EBUSY);\n\n\tres = (*sc->sc_accessops->enable)(sc->sc_accesscookie, on);\n\treturn (res);\n}"
  },
  {
    "function_name": "wskbd_holdscreen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
    "lines": "647-667",
    "snippet": "static void\nwskbd_holdscreen(sc, hold)\n\tstruct wskbd_softc *sc;\n\tint hold;\n{\n\tint new_state;\n\n\tif (sc->sc_displaydv != NULL) {\n\t\twsdisplay_kbdholdscreen(sc->sc_displaydv, hold);\n\t\tnew_state = sc->sc_ledstate;\n\t\tif (hold)\n\t\t\tnew_state |= WSKBD_LED_SCROLL;\n\t\telse\n\t\t\tnew_state &= ~WSKBD_LED_SCROLL;\n\t\tif (new_state != sc->sc_ledstate) {\n\t\t\t(*sc->sc_accessops->set_leds)(sc->sc_accesscookie,\n\t\t\t\t\t\t      new_state);\n\t\t\tsc->sc_ledstate = new_state;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wsdisplay.h\"",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wskbdvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc->sc_accesscookie",
            "new_state"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsdisplay_kbdholdscreen",
          "args": [
            "sc->sc_displaydv",
            "hold"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "wsdisplay_kbdholdscreen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "1674-1690",
          "snippet": "void\nwsdisplay_kbdholdscreen(dev, hold)\n\tstruct device *dev;\n\tint hold;\n{\n\tstruct wsdisplay_softc *sc = (struct wsdisplay_softc *)dev;\n\tstruct wsscreen *scr;\n\n\tscr = sc->sc_focus;\n\n\tif (hold)\n\t\tscr->scr_hold_screen = 1;\n\telse {\n\t\tscr->scr_hold_screen = 0;\n\t\ttimeout(ttrstrt, scr->scr_tty, 0);\t/* \"immediate\" */\n\t}\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;",
            "struct tty *\nwsdisplaytty(dev)\n\tdev_t dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\nstruct tty *\nwsdisplaytty(dev)\n\tdev_t dev;\n\nvoid\nwsdisplay_kbdholdscreen(dev, hold)\n\tstruct device *dev;\n\tint hold;\n{\n\tstruct wsdisplay_softc *sc = (struct wsdisplay_softc *)dev;\n\tstruct wsscreen *scr;\n\n\tscr = sc->sc_focus;\n\n\tif (hold)\n\t\tscr->scr_hold_screen = 1;\n\telse {\n\t\tscr->scr_hold_screen = 0;\n\t\ttimeout(ttrstrt, scr->scr_tty, 0);\t/* \"immediate\" */\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstatic void\nwskbd_holdscreen(sc, hold)\n\tstruct wskbd_softc *sc;\n\tint hold;\n{\n\tint new_state;\n\n\tif (sc->sc_displaydv != NULL) {\n\t\twsdisplay_kbdholdscreen(sc->sc_displaydv, hold);\n\t\tnew_state = sc->sc_ledstate;\n\t\tif (hold)\n\t\t\tnew_state |= WSKBD_LED_SCROLL;\n\t\telse\n\t\t\tnew_state &= ~WSKBD_LED_SCROLL;\n\t\tif (new_state != sc->sc_ledstate) {\n\t\t\t(*sc->sc_accessops->set_leds)(sc->sc_accesscookie,\n\t\t\t\t\t\t      new_state);\n\t\t\tsc->sc_ledstate = new_state;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "wskbd_rawinput",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
    "lines": "629-643",
    "snippet": "void\nwskbd_rawinput(dev, buf, len)\n\tstruct device *dev;\n\tu_char *buf;\n\tint len;\n{\n#if NWSDISPLAY > 0\n\tstruct wskbd_softc *sc = (struct wskbd_softc *)dev;\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\twsdisplay_kbdinput(sc->sc_displaydv, buf[i]);\n\t/* this is KS_GROUP_Ascii */\n#endif\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wsdisplay.h\"",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wskbdvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wsdisplay_kbdinput",
          "args": [
            "sc->sc_displaydv",
            "buf[i]"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "wsdisplay_kbdinput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "1290-1318",
          "snippet": "void\nwsdisplay_kbdinput(dev, ks)\n\tstruct device *dev;\n\tkeysym_t ks;\n{\n\tstruct wsdisplay_softc *sc = (struct wsdisplay_softc *)dev;\n\tstruct wsscreen *scr;\n\tchar *dp;\n\tint count;\n\tstruct tty *tp;\n\n\tKASSERT(sc != NULL);\n\n\tscr = sc->sc_focus;\n\n\tif (!scr || !WSSCREEN_HAS_TTY(scr))\n\t\treturn;\n\n\ttp = scr->scr_tty;\n\n\tif (KS_GROUP(ks) == KS_GROUP_Ascii)\n\t\t(*linesw[tp->t_line].l_rint)(KS_VALUE(ks), tp);\n\telse if (WSSCREEN_HAS_EMULATOR(scr)) {\n\t\tcount = (*scr->scr_dconf->wsemul->translate)\n\t\t    (scr->scr_dconf->wsemulcookie, ks, &dp);\n\t\twhile (count-- > 0)\n\t\t\t(*linesw[tp->t_line].l_rint)(*dp++, tp);\n\t}\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;",
            "struct tty *\nwsdisplaytty(dev)\n\tdev_t dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\nstruct tty *\nwsdisplaytty(dev)\n\tdev_t dev;\n\nvoid\nwsdisplay_kbdinput(dev, ks)\n\tstruct device *dev;\n\tkeysym_t ks;\n{\n\tstruct wsdisplay_softc *sc = (struct wsdisplay_softc *)dev;\n\tstruct wsscreen *scr;\n\tchar *dp;\n\tint count;\n\tstruct tty *tp;\n\n\tKASSERT(sc != NULL);\n\n\tscr = sc->sc_focus;\n\n\tif (!scr || !WSSCREEN_HAS_TTY(scr))\n\t\treturn;\n\n\ttp = scr->scr_tty;\n\n\tif (KS_GROUP(ks) == KS_GROUP_Ascii)\n\t\t(*linesw[tp->t_line].l_rint)(KS_VALUE(ks), tp);\n\telse if (WSSCREEN_HAS_EMULATOR(scr)) {\n\t\tcount = (*scr->scr_dconf->wsemul->translate)\n\t\t    (scr->scr_dconf->wsemulcookie, ks, &dp);\n\t\twhile (count-- > 0)\n\t\t\t(*linesw[tp->t_line].l_rint)(*dp++, tp);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nvoid\nwskbd_rawinput(dev, buf, len)\n\tstruct device *dev;\n\tu_char *buf;\n\tint len;\n{\n#if NWSDISPLAY > 0\n\tstruct wskbd_softc *sc = (struct wskbd_softc *)dev;\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\twsdisplay_kbdinput(sc->sc_displaydv, buf[i]);\n\t/* this is KS_GROUP_Ascii */\n#endif\n}"
  },
  {
    "function_name": "wskbd_input",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
    "lines": "553-626",
    "snippet": "void\nwskbd_input(dev, type, value)\n\tstruct device *dev;\n\tu_int type;\n\tint value;\n{\n\tstruct wskbd_softc *sc = (struct wskbd_softc *)dev; \n\tstruct wscons_event *ev;\n\tstruct wseventvar *evar;\n\tstruct timeval xxxtime;\n#if NWSDISPLAY > 0\n\tint num, i;\n#endif\n\tint put;\n\n#if NWSDISPLAY > 0\n\tif (sc->sc_repeating) {\n\t\tsc->sc_repeating = 0;\n\t\ttimeout_del(&sc->sc_repeat_ch);\n\t}\n\n\t/*\n\t * If /dev/wskbd is not connected in event mode translate and\n\t * send upstream.\n\t */\n\tif (sc->sc_translating) {\n\t\tnum = wskbd_translate(sc->id, type, value);\n\t\tif (num > 0) {\n\t\t\tif (sc->sc_displaydv != NULL) {\n\t\t\t\tfor (i = 0; i < num; i++)\n\t\t\t\twsdisplay_kbdinput(sc->sc_displaydv,\n\t\t\t\t\t\tsc->id->t_symbols[i]);\n\t\t\t}\n\n\t\t\tsc->sc_repeating = num;\n\t\t\ttimeout_add(&sc->sc_repeat_ch,\n\t\t\t    (hz * sc->sc_keyrepeat_data.del1) / 1000);\n\t\t}\n\t\treturn;\n\t}\n#endif\n\n\t/*\n\t * Keyboard is generating events.  Turn this keystroke into an\n\t * event and put it in the queue.  If the queue is full, the\n\t * keystroke is lost (sorry!).\n\t */\n\n\t/* no one to receive; punt!*/\n\tif (!sc->sc_ready)\n\t\treturn;\n\n#if NWSMUX > 0\n\tif (sc->sc_mux)\n\t\tevar = &sc->sc_mux->sc_events;\n\telse\n#endif\n\t\tevar = &sc->sc_events;\n\n\tput = evar->put;\n\tev = &evar->q[put];\n\tput = (put + 1) % WSEVENT_QSIZE;\n\tif (put == evar->get) {\n\t\tlog(LOG_WARNING, \"%s: event queue overflow\\n\",\n\t\t    sc->sc_dv.dv_xname);\n\t\treturn;\n\t}\n\tev->type = type;\n\tev->value = value;\n\tmicrotime(&xxxtime);\n\tTIMEVAL_TO_TIMESPEC(&xxxtime, &ev->time);\n\tevar->put = put;\n\tWSEVENT_WAKEUP(evar);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wsdisplay.h\"",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wskbdvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int wskbd_translate"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WSEVENT_WAKEUP",
          "args": [
            "evar"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMEVAL_TO_TIMESPEC",
          "args": [
            "&xxxtime",
            "&ev->time"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "microtime",
          "args": [
            "&xxxtime"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_WARNING",
            "\"%s: event queue overflow\\n\"",
            "sc->sc_dv.dv_xname"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_log_hard_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5909-5956",
          "snippet": "static void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "int\ti;",
            "ncb_p np = (struct ncb*) 0;",
            "int\ti;",
            "u_int8_t\tistat, dstat;",
            "u_int16_t\tsist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nint\ti;\nncb_p np = (struct ncb*) 0;\nint\ti;\nu_int8_t\tistat, dstat;\nu_int16_t\tsist;\n\nstatic void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "timeout_add",
          "args": [
            "&sc->sc_repeat_ch",
            "(hz * sc->sc_keyrepeat_data.del1) / 1000"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsdisplay_kbdinput",
          "args": [
            "sc->sc_displaydv",
            "sc->id->t_symbols[i]"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "wsdisplay_kbdinput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "1290-1318",
          "snippet": "void\nwsdisplay_kbdinput(dev, ks)\n\tstruct device *dev;\n\tkeysym_t ks;\n{\n\tstruct wsdisplay_softc *sc = (struct wsdisplay_softc *)dev;\n\tstruct wsscreen *scr;\n\tchar *dp;\n\tint count;\n\tstruct tty *tp;\n\n\tKASSERT(sc != NULL);\n\n\tscr = sc->sc_focus;\n\n\tif (!scr || !WSSCREEN_HAS_TTY(scr))\n\t\treturn;\n\n\ttp = scr->scr_tty;\n\n\tif (KS_GROUP(ks) == KS_GROUP_Ascii)\n\t\t(*linesw[tp->t_line].l_rint)(KS_VALUE(ks), tp);\n\telse if (WSSCREEN_HAS_EMULATOR(scr)) {\n\t\tcount = (*scr->scr_dconf->wsemul->translate)\n\t\t    (scr->scr_dconf->wsemulcookie, ks, &dp);\n\t\twhile (count-- > 0)\n\t\t\t(*linesw[tp->t_line].l_rint)(*dp++, tp);\n\t}\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;",
            "struct tty *\nwsdisplaytty(dev)\n\tdev_t dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\nstruct tty *\nwsdisplaytty(dev)\n\tdev_t dev;\n\nvoid\nwsdisplay_kbdinput(dev, ks)\n\tstruct device *dev;\n\tkeysym_t ks;\n{\n\tstruct wsdisplay_softc *sc = (struct wsdisplay_softc *)dev;\n\tstruct wsscreen *scr;\n\tchar *dp;\n\tint count;\n\tstruct tty *tp;\n\n\tKASSERT(sc != NULL);\n\n\tscr = sc->sc_focus;\n\n\tif (!scr || !WSSCREEN_HAS_TTY(scr))\n\t\treturn;\n\n\ttp = scr->scr_tty;\n\n\tif (KS_GROUP(ks) == KS_GROUP_Ascii)\n\t\t(*linesw[tp->t_line].l_rint)(KS_VALUE(ks), tp);\n\telse if (WSSCREEN_HAS_EMULATOR(scr)) {\n\t\tcount = (*scr->scr_dconf->wsemul->translate)\n\t\t    (scr->scr_dconf->wsemulcookie, ks, &dp);\n\t\twhile (count-- > 0)\n\t\t\t(*linesw[tp->t_line].l_rint)(*dp++, tp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wskbd_translate",
          "args": [
            "sc->id",
            "type",
            "value"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "wskbd_translate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
          "lines": "1335-1530",
          "snippet": "static int\nwskbd_translate(id, type, value)\n\tstruct wskbd_internal *id;\n\tu_int type;\n\tint value;\n{\n\tstruct wskbd_softc *sc = id->t_sc;\n\tkeysym_t ksym, res, *group;\n\tstruct wscons_keymap kpbuf, *kp;\n\tint iscommand = 0;\n\n\tif (type == WSCONS_EVENT_ALL_KEYS_UP) {\n\t\tid->t_modifiers &= ~(MOD_SHIFT_L | MOD_SHIFT_R\n\t\t\t\t| MOD_CONTROL_L | MOD_CONTROL_R\n\t\t\t\t| MOD_META_L | MOD_META_R\n\t\t\t\t| MOD_MODESHIFT\n\t\t\t\t| MOD_COMMAND | MOD_COMMAND1 | MOD_COMMAND2);\n\t\tupdate_leds(id);\n\t\treturn (0);\n\t}\n\n\tif (sc != NULL) {\n\t\tif (value < 0 || value >= sc->sc_maplen) {\n#ifdef DEBUG\n\t\t\tprintf(\"wskbd_translate: keycode %d out of range\\n\",\n\t\t\t       value);\n#endif\n\t\t\treturn (0);\n\t\t}\n\t\tkp = sc->sc_map + value;\n\t} else {\n\t\tkp = &kpbuf;\n\t\twskbd_get_mapentry(id->t_keymap, value, kp);\n\t}\n\n\t/* if this key has a command, process it first */\n\tif (sc != NULL && kp->command != KS_voidSymbol)\n\t\tiscommand = internal_command(sc, &type, kp->command);\n\n\t/* Now update modifiers */\n\tswitch (kp->group1[0]) {\n\tcase KS_Shift_L:\n\t\tupdate_modifier(id, type, 0, MOD_SHIFT_L);\n\t\tbreak;\n\n\tcase KS_Shift_R:\n\t\tupdate_modifier(id, type, 0, MOD_SHIFT_R);\n\t\tbreak;\n\n\tcase KS_Shift_Lock:\n\t\tupdate_modifier(id, type, 1, MOD_SHIFTLOCK);\n\t\tbreak;\n\n\tcase KS_Caps_Lock:\n\t\tupdate_modifier(id, type, 1, MOD_CAPSLOCK);\n\t\tbreak;\n\n\tcase KS_Control_L:\n\t\tupdate_modifier(id, type, 0, MOD_CONTROL_L);\n\t\tbreak;\n\n\tcase KS_Control_R:\n\t\tupdate_modifier(id, type, 0, MOD_CONTROL_R);\n\t\tbreak;\n\n\tcase KS_Alt_L:\n\t\tupdate_modifier(id, type, 0, MOD_META_L);\n\t\tbreak;\n\n\tcase KS_Alt_R:\n\t\tupdate_modifier(id, type, 0, MOD_META_R);\n\t\tbreak;\n\n\tcase KS_Mode_switch:\n\t\tupdate_modifier(id, type, 0, MOD_MODESHIFT);\n\t\tbreak;\n\n\tcase KS_Num_Lock:\n\t\tupdate_modifier(id, type, 1, MOD_NUMLOCK);\n\t\tbreak;\n\n#if NWSDISPLAY > 0\n\tcase KS_Hold_Screen:\n\t\tif (sc != NULL) {\n\t\t\tupdate_modifier(id, type, 1, MOD_HOLDSCREEN);\n\t\t\twskbd_holdscreen(sc, id->t_modifiers & MOD_HOLDSCREEN);\n\t\t}\n\t\tbreak;\n#endif\n\t}\n\n\t/* If this is a key release or we are in command mode, we are done */\n\tif (type != WSCONS_EVENT_KEY_DOWN || iscommand) {\n\t\tupdate_leds(id);\n\t\treturn (0);\n\t}\n\n\t/* Get the keysym */\n\tif (id->t_modifiers & MOD_MODESHIFT)\n\t\tgroup = & kp->group2[0];\n\telse\n\t\tgroup = & kp->group1[0];\n\n\tif ((id->t_modifiers & MOD_NUMLOCK) != 0 &&\n\t    KS_GROUP(group[1]) == KS_GROUP_Keypad) {\n\t\tif (MOD_ONESET(id, MOD_ANYSHIFT))\n\t\t\tksym = group[0];\n\t\telse\n\t\t\tksym = group[1];\n\t} else if (! MOD_ONESET(id, MOD_ANYSHIFT | MOD_CAPSLOCK)) {\n\t\tksym = group[0];\n\t} else if (MOD_ONESET(id, MOD_CAPSLOCK)) {\n\t\tif (! MOD_ONESET(id, MOD_SHIFT_L | MOD_SHIFT_R))\n\t\t\tksym = group[0];\n\t\telse\n\t\t\tksym = group[1];\n\t\tif (ksym >= KS_a && ksym <= KS_z)\n\t\t\tksym += KS_A - KS_a;\n\t\telse if (ksym >= KS_agrave && ksym <= KS_thorn &&\n\t\t\t ksym != KS_division)\n\t\t\tksym += KS_Agrave - KS_agrave;\n\t} else if (MOD_ONESET(id, MOD_ANYSHIFT)) {\n\t\tksym = group[1];\n\t} else {\n\t\tksym = group[0];\n\t}\n\n\t/* Process compose sequence and dead accents */\n\tres = KS_voidSymbol;\n\n\tswitch (KS_GROUP(ksym)) {\n\tcase KS_GROUP_Ascii:\n\tcase KS_GROUP_Keypad:\n\tcase KS_GROUP_Function:\n\t\tres = ksym;\n\t\tbreak;\n\n\tcase KS_GROUP_Mod:\n\t\tif (ksym == KS_Multi_key) {\n\t\t\tupdate_modifier(id, 1, 0, MOD_COMPOSE);\n\t\t\tid->t_composelen = 2;\n\t\t}\n\t\tbreak;\n\n\tcase KS_GROUP_Dead:\n\t\tif (id->t_composelen == 0) {\n\t\t\tupdate_modifier(id, 1, 0, MOD_COMPOSE);\n\t\t\tid->t_composelen = 1;\n\t\t\tid->t_composebuf[0] = ksym;\n\t\t} else\n\t\t\tres = ksym;\n\t\tbreak;\n\t}\n\n\tif (res == KS_voidSymbol) {\n\t\tupdate_leds(id);\n\t\treturn (0);\n\t}\n\n\tif (id->t_composelen > 0) {\n\t\tid->t_composebuf[2 - id->t_composelen] = res;\n\t\tif (--id->t_composelen == 0) {\n\t\t\tres = wskbd_compose_value(id->t_composebuf);\n\t\t\tupdate_modifier(id, 0, 0, MOD_COMPOSE);\n\t\t} else {\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\tupdate_leds(id);\n\n\t/* We are done, return the symbol */\n\tif (KS_GROUP(res) == KS_GROUP_Ascii) {\n\t\tif (MOD_ONESET(id, MOD_ANYCONTROL)) {\n\t\t\tif ((res >= KS_at && res <= KS_z) || res == KS_space)\n\t\t\t\tres = res & 0x1f;\n\t\t\telse if (res == KS_2)\n\t\t\t\tres = 0x00;\n\t\t\telse if (res >= KS_3 && res <= KS_7)\n\t\t\t\tres = KS_Escape + (res - KS_3);\n\t\t\telse if (res == KS_8)\n\t\t\t\tres = KS_Delete;\n\t\t}\n\t\tif (MOD_ONESET(id, MOD_ANYMETA)) {\n\t\t\tif (id->t_flags & WSKFL_METAESC) {\n\t\t\t\tid->t_symbols[0] = KS_Escape;\n\t\t\t\tid->t_symbols[1] = res;\n\t\t\t\treturn (2);\n\t\t\t} else\n\t\t\tres |= 0x80;\n\t}\n\t}\n\n\tid->t_symbols[0] = res;\n\treturn (1);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wsdisplay.h\"",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wskbdvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/malloc.h>",
            "#include <sys/timeout.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [
            "#define MOD_ANYMETA\t\t(MOD_META_L | MOD_META_R)",
            "#define MOD_ANYCONTROL\t\t(MOD_CONTROL_L | MOD_CONTROL_R)",
            "#define MOD_ANYSHIFT\t\t(MOD_SHIFT_L | MOD_SHIFT_R | MOD_SHIFTLOCK)",
            "#define MOD_COMMAND2\t\t(1 << 14)",
            "#define MOD_COMMAND1\t\t(1 << 13)",
            "#define MOD_COMMAND\t\t(1 << 12)",
            "#define MOD_HOLDSCREEN\t\t(1 << 11)",
            "#define MOD_COMPOSE\t\t(1 << 10)",
            "#define MOD_NUMLOCK\t\t(1 << 9)",
            "#define MOD_MODESHIFT\t\t(1 << 8)",
            "#define MOD_META_R\t\t(1 << 7)",
            "#define MOD_META_L\t\t(1 << 6)",
            "#define MOD_CONTROL_R\t\t(1 << 5)",
            "#define MOD_CONTROL_L\t\t(1 << 4)",
            "#define MOD_CAPSLOCK\t\t(1 << 3)",
            "#define MOD_SHIFTLOCK\t\t(1 << 2)",
            "#define MOD_SHIFT_R\t\t(1 << 1)",
            "#define MOD_SHIFT_L\t\t(1 << 0)",
            "#define WSKFL_METAESC 1"
          ],
          "globals_used": [
            "static inline void update_leds",
            "static inline void update_modifier",
            "static int internal_command",
            "static int wskbd_translate"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define MOD_ANYMETA\t\t(MOD_META_L | MOD_META_R)\n#define MOD_ANYCONTROL\t\t(MOD_CONTROL_L | MOD_CONTROL_R)\n#define MOD_ANYSHIFT\t\t(MOD_SHIFT_L | MOD_SHIFT_R | MOD_SHIFTLOCK)\n#define MOD_COMMAND2\t\t(1 << 14)\n#define MOD_COMMAND1\t\t(1 << 13)\n#define MOD_COMMAND\t\t(1 << 12)\n#define MOD_HOLDSCREEN\t\t(1 << 11)\n#define MOD_COMPOSE\t\t(1 << 10)\n#define MOD_NUMLOCK\t\t(1 << 9)\n#define MOD_MODESHIFT\t\t(1 << 8)\n#define MOD_META_R\t\t(1 << 7)\n#define MOD_META_L\t\t(1 << 6)\n#define MOD_CONTROL_R\t\t(1 << 5)\n#define MOD_CONTROL_L\t\t(1 << 4)\n#define MOD_CAPSLOCK\t\t(1 << 3)\n#define MOD_SHIFTLOCK\t\t(1 << 2)\n#define MOD_SHIFT_R\t\t(1 << 1)\n#define MOD_SHIFT_L\t\t(1 << 0)\n#define WSKFL_METAESC 1\n\nstatic inline void update_leds;\nstatic inline void update_modifier;\nstatic int internal_command;\nstatic int wskbd_translate;\n\nstatic int\nwskbd_translate(id, type, value)\n\tstruct wskbd_internal *id;\n\tu_int type;\n\tint value;\n{\n\tstruct wskbd_softc *sc = id->t_sc;\n\tkeysym_t ksym, res, *group;\n\tstruct wscons_keymap kpbuf, *kp;\n\tint iscommand = 0;\n\n\tif (type == WSCONS_EVENT_ALL_KEYS_UP) {\n\t\tid->t_modifiers &= ~(MOD_SHIFT_L | MOD_SHIFT_R\n\t\t\t\t| MOD_CONTROL_L | MOD_CONTROL_R\n\t\t\t\t| MOD_META_L | MOD_META_R\n\t\t\t\t| MOD_MODESHIFT\n\t\t\t\t| MOD_COMMAND | MOD_COMMAND1 | MOD_COMMAND2);\n\t\tupdate_leds(id);\n\t\treturn (0);\n\t}\n\n\tif (sc != NULL) {\n\t\tif (value < 0 || value >= sc->sc_maplen) {\n#ifdef DEBUG\n\t\t\tprintf(\"wskbd_translate: keycode %d out of range\\n\",\n\t\t\t       value);\n#endif\n\t\t\treturn (0);\n\t\t}\n\t\tkp = sc->sc_map + value;\n\t} else {\n\t\tkp = &kpbuf;\n\t\twskbd_get_mapentry(id->t_keymap, value, kp);\n\t}\n\n\t/* if this key has a command, process it first */\n\tif (sc != NULL && kp->command != KS_voidSymbol)\n\t\tiscommand = internal_command(sc, &type, kp->command);\n\n\t/* Now update modifiers */\n\tswitch (kp->group1[0]) {\n\tcase KS_Shift_L:\n\t\tupdate_modifier(id, type, 0, MOD_SHIFT_L);\n\t\tbreak;\n\n\tcase KS_Shift_R:\n\t\tupdate_modifier(id, type, 0, MOD_SHIFT_R);\n\t\tbreak;\n\n\tcase KS_Shift_Lock:\n\t\tupdate_modifier(id, type, 1, MOD_SHIFTLOCK);\n\t\tbreak;\n\n\tcase KS_Caps_Lock:\n\t\tupdate_modifier(id, type, 1, MOD_CAPSLOCK);\n\t\tbreak;\n\n\tcase KS_Control_L:\n\t\tupdate_modifier(id, type, 0, MOD_CONTROL_L);\n\t\tbreak;\n\n\tcase KS_Control_R:\n\t\tupdate_modifier(id, type, 0, MOD_CONTROL_R);\n\t\tbreak;\n\n\tcase KS_Alt_L:\n\t\tupdate_modifier(id, type, 0, MOD_META_L);\n\t\tbreak;\n\n\tcase KS_Alt_R:\n\t\tupdate_modifier(id, type, 0, MOD_META_R);\n\t\tbreak;\n\n\tcase KS_Mode_switch:\n\t\tupdate_modifier(id, type, 0, MOD_MODESHIFT);\n\t\tbreak;\n\n\tcase KS_Num_Lock:\n\t\tupdate_modifier(id, type, 1, MOD_NUMLOCK);\n\t\tbreak;\n\n#if NWSDISPLAY > 0\n\tcase KS_Hold_Screen:\n\t\tif (sc != NULL) {\n\t\t\tupdate_modifier(id, type, 1, MOD_HOLDSCREEN);\n\t\t\twskbd_holdscreen(sc, id->t_modifiers & MOD_HOLDSCREEN);\n\t\t}\n\t\tbreak;\n#endif\n\t}\n\n\t/* If this is a key release or we are in command mode, we are done */\n\tif (type != WSCONS_EVENT_KEY_DOWN || iscommand) {\n\t\tupdate_leds(id);\n\t\treturn (0);\n\t}\n\n\t/* Get the keysym */\n\tif (id->t_modifiers & MOD_MODESHIFT)\n\t\tgroup = & kp->group2[0];\n\telse\n\t\tgroup = & kp->group1[0];\n\n\tif ((id->t_modifiers & MOD_NUMLOCK) != 0 &&\n\t    KS_GROUP(group[1]) == KS_GROUP_Keypad) {\n\t\tif (MOD_ONESET(id, MOD_ANYSHIFT))\n\t\t\tksym = group[0];\n\t\telse\n\t\t\tksym = group[1];\n\t} else if (! MOD_ONESET(id, MOD_ANYSHIFT | MOD_CAPSLOCK)) {\n\t\tksym = group[0];\n\t} else if (MOD_ONESET(id, MOD_CAPSLOCK)) {\n\t\tif (! MOD_ONESET(id, MOD_SHIFT_L | MOD_SHIFT_R))\n\t\t\tksym = group[0];\n\t\telse\n\t\t\tksym = group[1];\n\t\tif (ksym >= KS_a && ksym <= KS_z)\n\t\t\tksym += KS_A - KS_a;\n\t\telse if (ksym >= KS_agrave && ksym <= KS_thorn &&\n\t\t\t ksym != KS_division)\n\t\t\tksym += KS_Agrave - KS_agrave;\n\t} else if (MOD_ONESET(id, MOD_ANYSHIFT)) {\n\t\tksym = group[1];\n\t} else {\n\t\tksym = group[0];\n\t}\n\n\t/* Process compose sequence and dead accents */\n\tres = KS_voidSymbol;\n\n\tswitch (KS_GROUP(ksym)) {\n\tcase KS_GROUP_Ascii:\n\tcase KS_GROUP_Keypad:\n\tcase KS_GROUP_Function:\n\t\tres = ksym;\n\t\tbreak;\n\n\tcase KS_GROUP_Mod:\n\t\tif (ksym == KS_Multi_key) {\n\t\t\tupdate_modifier(id, 1, 0, MOD_COMPOSE);\n\t\t\tid->t_composelen = 2;\n\t\t}\n\t\tbreak;\n\n\tcase KS_GROUP_Dead:\n\t\tif (id->t_composelen == 0) {\n\t\t\tupdate_modifier(id, 1, 0, MOD_COMPOSE);\n\t\t\tid->t_composelen = 1;\n\t\t\tid->t_composebuf[0] = ksym;\n\t\t} else\n\t\t\tres = ksym;\n\t\tbreak;\n\t}\n\n\tif (res == KS_voidSymbol) {\n\t\tupdate_leds(id);\n\t\treturn (0);\n\t}\n\n\tif (id->t_composelen > 0) {\n\t\tid->t_composebuf[2 - id->t_composelen] = res;\n\t\tif (--id->t_composelen == 0) {\n\t\t\tres = wskbd_compose_value(id->t_composebuf);\n\t\t\tupdate_modifier(id, 0, 0, MOD_COMPOSE);\n\t\t} else {\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\tupdate_leds(id);\n\n\t/* We are done, return the symbol */\n\tif (KS_GROUP(res) == KS_GROUP_Ascii) {\n\t\tif (MOD_ONESET(id, MOD_ANYCONTROL)) {\n\t\t\tif ((res >= KS_at && res <= KS_z) || res == KS_space)\n\t\t\t\tres = res & 0x1f;\n\t\t\telse if (res == KS_2)\n\t\t\t\tres = 0x00;\n\t\t\telse if (res >= KS_3 && res <= KS_7)\n\t\t\t\tres = KS_Escape + (res - KS_3);\n\t\t\telse if (res == KS_8)\n\t\t\t\tres = KS_Delete;\n\t\t}\n\t\tif (MOD_ONESET(id, MOD_ANYMETA)) {\n\t\t\tif (id->t_flags & WSKFL_METAESC) {\n\t\t\t\tid->t_symbols[0] = KS_Escape;\n\t\t\t\tid->t_symbols[1] = res;\n\t\t\t\treturn (2);\n\t\t\t} else\n\t\t\tres |= 0x80;\n\t}\n\t}\n\n\tid->t_symbols[0] = res;\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timeout_del",
          "args": [
            "&sc->sc_repeat_ch"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstatic int wskbd_translate;\n\nvoid\nwskbd_input(dev, type, value)\n\tstruct device *dev;\n\tu_int type;\n\tint value;\n{\n\tstruct wskbd_softc *sc = (struct wskbd_softc *)dev; \n\tstruct wscons_event *ev;\n\tstruct wseventvar *evar;\n\tstruct timeval xxxtime;\n#if NWSDISPLAY > 0\n\tint num, i;\n#endif\n\tint put;\n\n#if NWSDISPLAY > 0\n\tif (sc->sc_repeating) {\n\t\tsc->sc_repeating = 0;\n\t\ttimeout_del(&sc->sc_repeat_ch);\n\t}\n\n\t/*\n\t * If /dev/wskbd is not connected in event mode translate and\n\t * send upstream.\n\t */\n\tif (sc->sc_translating) {\n\t\tnum = wskbd_translate(sc->id, type, value);\n\t\tif (num > 0) {\n\t\t\tif (sc->sc_displaydv != NULL) {\n\t\t\t\tfor (i = 0; i < num; i++)\n\t\t\t\twsdisplay_kbdinput(sc->sc_displaydv,\n\t\t\t\t\t\tsc->id->t_symbols[i]);\n\t\t\t}\n\n\t\t\tsc->sc_repeating = num;\n\t\t\ttimeout_add(&sc->sc_repeat_ch,\n\t\t\t    (hz * sc->sc_keyrepeat_data.del1) / 1000);\n\t\t}\n\t\treturn;\n\t}\n#endif\n\n\t/*\n\t * Keyboard is generating events.  Turn this keystroke into an\n\t * event and put it in the queue.  If the queue is full, the\n\t * keystroke is lost (sorry!).\n\t */\n\n\t/* no one to receive; punt!*/\n\tif (!sc->sc_ready)\n\t\treturn;\n\n#if NWSMUX > 0\n\tif (sc->sc_mux)\n\t\tevar = &sc->sc_mux->sc_events;\n\telse\n#endif\n\t\tevar = &sc->sc_events;\n\n\tput = evar->put;\n\tev = &evar->q[put];\n\tput = (put + 1) % WSEVENT_QSIZE;\n\tif (put == evar->get) {\n\t\tlog(LOG_WARNING, \"%s: event queue overflow\\n\",\n\t\t    sc->sc_dv.dv_xname);\n\t\treturn;\n\t}\n\tev->type = type;\n\tev->value = value;\n\tmicrotime(&xxxtime);\n\tTIMEVAL_TO_TIMESPEC(&xxxtime, &ev->time);\n\tevar->put = put;\n\tWSEVENT_WAKEUP(evar);\n}"
  },
  {
    "function_name": "wskbd_detach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
    "lines": "508-551",
    "snippet": "int\nwskbd_detach(self, flags)\n\tstruct device  *self;\n\tint flags;\n{\n\tstruct wskbd_softc *sc = (struct wskbd_softc *)self;\n\tstruct wseventvar *evar;\n\tint maj, mn;\n\tint s;\n#if NWSMUX > 0\n\tint mux;\n\n\tmux = sc->sc_dv.dv_cfdata->wskbddevcf_mux;\n\tif (mux != WSMOUSEDEVCF_MUX_DEFAULT)\n\t\twsmux_detach(mux, &sc->sc_dv);\n#endif\n\n\tevar = &sc->sc_events;\n\tif (evar->io) {\n\t\ts = spltty();\n\t\tif (--sc->sc_refcnt >= 0) {\n\t\t\t/* Wake everyone by generating a dummy event. */\n\t\t\tif (++evar->put >= WSEVENT_QSIZE)\n\t\t\t\tevar->put = 0;\n\t\t\tWSEVENT_WAKEUP(evar);\n\t\t\t/* Wait for processes to go away. */\n\t\t\tif (tsleep(sc, PZERO, \"wskdet\", hz * 60))\n\t\t\t\tprintf(\"wskbd_detach: %s didn't detach\\n\",\n\t\t\t\t       sc->sc_dv.dv_xname);\n\t\t}\n\t\tsplx(s);\n\t}\n\n\t/* locate the major number */\n\tfor (maj = 0; maj < nchrdev; maj++)\n\t\tif (cdevsw[maj].d_open == wskbdopen)\n\t\t\tbreak;\n\n\t/* Nuke the vnodes for any open instances. */\n\tmn = self->dv_unit;\n\tvdevgone(maj, mn, mn, VCHR);\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wsdisplay.h\"",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wskbdvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\twskbd_detach"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vdevgone",
          "args": [
            "maj",
            "mn",
            "mn",
            "VCHR"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"wskbd_detach: %s didn't detach\\n\"",
            "sc->sc_dv.dv_xname"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "sc",
            "PZERO",
            "\"wskdet\"",
            "hz * 60"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSEVENT_WAKEUP",
          "args": [
            "evar"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsmux_detach",
          "args": [
            "mux",
            "&sc->sc_dv"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "wsmux_detach_sc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmux.c",
          "lines": "431-475",
          "snippet": "int\nwsmux_detach_sc(sc, dsc)\n\tstruct wsmux_softc *sc;\n        struct device *dsc;\n{\n\tstruct wsplink *m;\n\tint error = 0;\n\n\tDPRINTF((\"wsmux_detach_sc: %s: dsc=%p\\n\", sc->sc_dv.dv_xname, dsc));\n#ifdef DIAGNOSTIC\n\tif (sc == 0) {\n\t\tprintf(\"wsmux_detach_sc: not allocated\\n\");\n\t\treturn (ENXIO);\n\t}\n#endif\n\n\tfor (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {\n\t\tif (m->sc == dsc)\n\t\t\tbreak;\n\t}\n#ifdef DIAGNOSTIC\n\tif (!m) {\n\t\tprintf(\"wsmux_detach_sc: not found\\n\");\n\t\treturn (ENXIO);\n\t}\n#endif\n\tif (sc->sc_displaydv) {\n\t\tif (m->sc_ops->dsetdisplay)\n\t\t\terror = m->sc_ops->dsetdisplay(m->sc, 0);\n\t\tif (error)\n\t\t\treturn (error);\n\t\t*m->sc_muxp = 0;\n\t} else if (*m->sc_muxp) {\n\t\tDPRINTF((\"wsmux_detach_sc: close\\n\"));\n\t\t/* mux device is open, so close multiplexee */\n\t\tm->sc_ops->dclose(m->sc, FREAD, 0, 0);\n\t\t*m->sc_muxp = 0;\n\t}\n\n\tLIST_REMOVE(m, next);\n\n\tfree(m, M_DEVBUF);\n\tDPRINTF((\"wsmux_detach_sc: done sc=%p\\n\", sc));\n\treturn (0);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/device.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include \"wskbd.h\"",
            "#include \"wsdisplay.h\"",
            "#include \"wsmux.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n\nint\nwsmux_detach_sc(sc, dsc)\n\tstruct wsmux_softc *sc;\n        struct device *dsc;\n{\n\tstruct wsplink *m;\n\tint error = 0;\n\n\tDPRINTF((\"wsmux_detach_sc: %s: dsc=%p\\n\", sc->sc_dv.dv_xname, dsc));\n#ifdef DIAGNOSTIC\n\tif (sc == 0) {\n\t\tprintf(\"wsmux_detach_sc: not allocated\\n\");\n\t\treturn (ENXIO);\n\t}\n#endif\n\n\tfor (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {\n\t\tif (m->sc == dsc)\n\t\t\tbreak;\n\t}\n#ifdef DIAGNOSTIC\n\tif (!m) {\n\t\tprintf(\"wsmux_detach_sc: not found\\n\");\n\t\treturn (ENXIO);\n\t}\n#endif\n\tif (sc->sc_displaydv) {\n\t\tif (m->sc_ops->dsetdisplay)\n\t\t\terror = m->sc_ops->dsetdisplay(m->sc, 0);\n\t\tif (error)\n\t\t\treturn (error);\n\t\t*m->sc_muxp = 0;\n\t} else if (*m->sc_muxp) {\n\t\tDPRINTF((\"wsmux_detach_sc: close\\n\"));\n\t\t/* mux device is open, so close multiplexee */\n\t\tm->sc_ops->dclose(m->sc, FREAD, 0, 0);\n\t\t*m->sc_muxp = 0;\n\t}\n\n\tLIST_REMOVE(m, next);\n\n\tfree(m, M_DEVBUF);\n\tDPRINTF((\"wsmux_detach_sc: done sc=%p\\n\", sc));\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nint\twskbd_detach;\n\nint\nwskbd_detach(self, flags)\n\tstruct device  *self;\n\tint flags;\n{\n\tstruct wskbd_softc *sc = (struct wskbd_softc *)self;\n\tstruct wseventvar *evar;\n\tint maj, mn;\n\tint s;\n#if NWSMUX > 0\n\tint mux;\n\n\tmux = sc->sc_dv.dv_cfdata->wskbddevcf_mux;\n\tif (mux != WSMOUSEDEVCF_MUX_DEFAULT)\n\t\twsmux_detach(mux, &sc->sc_dv);\n#endif\n\n\tevar = &sc->sc_events;\n\tif (evar->io) {\n\t\ts = spltty();\n\t\tif (--sc->sc_refcnt >= 0) {\n\t\t\t/* Wake everyone by generating a dummy event. */\n\t\t\tif (++evar->put >= WSEVENT_QSIZE)\n\t\t\t\tevar->put = 0;\n\t\t\tWSEVENT_WAKEUP(evar);\n\t\t\t/* Wait for processes to go away. */\n\t\t\tif (tsleep(sc, PZERO, \"wskdet\", hz * 60))\n\t\t\t\tprintf(\"wskbd_detach: %s didn't detach\\n\",\n\t\t\t\t       sc->sc_dv.dv_xname);\n\t\t}\n\t\tsplx(s);\n\t}\n\n\t/* locate the major number */\n\tfor (maj = 0; maj < nchrdev; maj++)\n\t\tif (cdevsw[maj].d_open == wskbdopen)\n\t\t\tbreak;\n\n\t/* Nuke the vnodes for any open instances. */\n\tmn = self->dv_unit;\n\tvdevgone(maj, mn, mn, VCHR);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "wskbd_activate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
    "lines": "491-498",
    "snippet": "int\nwskbd_activate(self, act)\n\tstruct device *self;\n\tenum devact act;\n{\n\t/* XXX should we do something more? */\n\treturn (0);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wsdisplay.h\"",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wskbdvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\twskbd_activate"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nint\twskbd_activate;\n\nint\nwskbd_activate(self, act)\n\tstruct device *self;\n\tenum devact act;\n{\n\t/* XXX should we do something more? */\n\treturn (0);\n}"
  },
  {
    "function_name": "wskbd_repeat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
    "lines": "464-488",
    "snippet": "static void\nwskbd_repeat(v)\n\tvoid *v;\n{\n\tstruct wskbd_softc *sc = (struct wskbd_softc *)v;\n\tint s = spltty();\n\n\tif (!sc->sc_repeating) {\n\t\t/*\n\t\t * race condition: a \"key up\" event came in when wskbd_repeat()\n\t\t * was already called but not yet spltty()'d\n\t\t */\n\t\tsplx(s);\n\t\treturn;\n\t}\n\tif (sc->sc_displaydv != NULL) {\n\t\tint i;\n\t\tfor (i = 0; i < sc->sc_repeating; i++)\n\t\t\twsdisplay_kbdinput(sc->sc_displaydv,\n\t\t\t\t\t   sc->id->t_symbols[i]);\n\t}\n\ttimeout_add(&sc->sc_repeat_ch,\n\t    (hz * sc->sc_keyrepeat_data.delN) / 1000);\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wsdisplay.h\"",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wskbdvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout_add",
          "args": [
            "&sc->sc_repeat_ch",
            "(hz * sc->sc_keyrepeat_data.delN) / 1000"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsdisplay_kbdinput",
          "args": [
            "sc->sc_displaydv",
            "sc->id->t_symbols[i]"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "wsdisplay_kbdinput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "1290-1318",
          "snippet": "void\nwsdisplay_kbdinput(dev, ks)\n\tstruct device *dev;\n\tkeysym_t ks;\n{\n\tstruct wsdisplay_softc *sc = (struct wsdisplay_softc *)dev;\n\tstruct wsscreen *scr;\n\tchar *dp;\n\tint count;\n\tstruct tty *tp;\n\n\tKASSERT(sc != NULL);\n\n\tscr = sc->sc_focus;\n\n\tif (!scr || !WSSCREEN_HAS_TTY(scr))\n\t\treturn;\n\n\ttp = scr->scr_tty;\n\n\tif (KS_GROUP(ks) == KS_GROUP_Ascii)\n\t\t(*linesw[tp->t_line].l_rint)(KS_VALUE(ks), tp);\n\telse if (WSSCREEN_HAS_EMULATOR(scr)) {\n\t\tcount = (*scr->scr_dconf->wsemul->translate)\n\t\t    (scr->scr_dconf->wsemulcookie, ks, &dp);\n\t\twhile (count-- > 0)\n\t\t\t(*linesw[tp->t_line].l_rint)(*dp++, tp);\n\t}\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;",
            "struct tty *\nwsdisplaytty(dev)\n\tdev_t dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct wsscreen *\nwsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)\n\tstruct wsdisplay_softc *sc;\nstruct tty *\nwsdisplaytty(dev)\n\tdev_t dev;\n\nvoid\nwsdisplay_kbdinput(dev, ks)\n\tstruct device *dev;\n\tkeysym_t ks;\n{\n\tstruct wsdisplay_softc *sc = (struct wsdisplay_softc *)dev;\n\tstruct wsscreen *scr;\n\tchar *dp;\n\tint count;\n\tstruct tty *tp;\n\n\tKASSERT(sc != NULL);\n\n\tscr = sc->sc_focus;\n\n\tif (!scr || !WSSCREEN_HAS_TTY(scr))\n\t\treturn;\n\n\ttp = scr->scr_tty;\n\n\tif (KS_GROUP(ks) == KS_GROUP_Ascii)\n\t\t(*linesw[tp->t_line].l_rint)(KS_VALUE(ks), tp);\n\telse if (WSSCREEN_HAS_EMULATOR(scr)) {\n\t\tcount = (*scr->scr_dconf->wsemul->translate)\n\t\t    (scr->scr_dconf->wsemulcookie, ks, &dp);\n\t\twhile (count-- > 0)\n\t\t\t(*linesw[tp->t_line].l_rint)(*dp++, tp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstatic void\nwskbd_repeat(v)\n\tvoid *v;\n{\n\tstruct wskbd_softc *sc = (struct wskbd_softc *)v;\n\tint s = spltty();\n\n\tif (!sc->sc_repeating) {\n\t\t/*\n\t\t * race condition: a \"key up\" event came in when wskbd_repeat()\n\t\t * was already called but not yet spltty()'d\n\t\t */\n\t\tsplx(s);\n\t\treturn;\n\t}\n\tif (sc->sc_displaydv != NULL) {\n\t\tint i;\n\t\tfor (i = 0; i < sc->sc_repeating; i++)\n\t\t\twsdisplay_kbdinput(sc->sc_displaydv,\n\t\t\t\t\t   sc->id->t_symbols[i]);\n\t}\n\ttimeout_add(&sc->sc_repeat_ch,\n\t    (hz * sc->sc_keyrepeat_data.delN) / 1000);\n\tsplx(s);\n}"
  },
  {
    "function_name": "wskbd_cndetach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
    "lines": "446-461",
    "snippet": "void    \nwskbd_cndetach()\n{\n\tKASSERT(wskbd_console_initted);\n\n\twskbd_console_data.t_keymap = 0;\n\n\twskbd_console_data.t_consops = 0;\n\twskbd_console_data.t_consaccesscookie = 0;\n\n#if NWSDISPLAY > 0\n\twsdisplay_unset_cons_kbd();\n#endif\n\n\twskbd_console_initted = 0;\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wsdisplay.h\"",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wskbdvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int wskbd_console_initted;",
      "static struct wskbd_internal wskbd_console_data;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wsdisplay_unset_cons_kbd",
          "args": [],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "wsdisplay_unset_cons_kbd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "1758-1764",
          "snippet": "void\nwsdisplay_unset_cons_kbd()\n{\n\twsdisplay_cons.cn_getc = wsdisplay_getc_dummy;\n\t/* wsdisplay_cons.cn_bell = NULL; XXX */\n\twsdisplay_cons_kbd_pollc = NULL;\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int wsdisplay_getc_dummy",
            "static void (*wsdisplay_cons_kbd_pollc)",
            "static struct consdev wsdisplay_cons = {\n\tNULL, NULL, wsdisplay_getc_dummy, wsdisplay_cnputc,\n\twsdisplay_pollc, NODEV, CN_NORMAL\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstatic int wsdisplay_getc_dummy;\nstatic void (*wsdisplay_cons_kbd_pollc);\nstatic struct consdev wsdisplay_cons = {\n\tNULL, NULL, wsdisplay_getc_dummy, wsdisplay_cnputc,\n\twsdisplay_pollc, NODEV, CN_NORMAL\n};\n\nvoid\nwsdisplay_unset_cons_kbd()\n{\n\twsdisplay_cons.cn_getc = wsdisplay_getc_dummy;\n\t/* wsdisplay_cons.cn_bell = NULL; XXX */\n\twsdisplay_cons_kbd_pollc = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KASSERT",
          "args": [
            "wskbd_console_initted"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstatic int wskbd_console_initted;\nstatic struct wskbd_internal wskbd_console_data;\n\nvoid    \nwskbd_cndetach()\n{\n\tKASSERT(wskbd_console_initted);\n\n\twskbd_console_data.t_keymap = 0;\n\n\twskbd_console_data.t_consops = 0;\n\twskbd_console_data.t_consaccesscookie = 0;\n\n#if NWSDISPLAY > 0\n\twsdisplay_unset_cons_kbd();\n#endif\n\n\twskbd_console_initted = 0;\n}"
  },
  {
    "function_name": "wskbd_cnattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
    "lines": "424-444",
    "snippet": "void    \nwskbd_cnattach(consops, conscookie, mapdata)\n\tconst struct wskbd_consops *consops;\n\tvoid *conscookie;\n\tconst struct wskbd_mapdata *mapdata;\n{\n\n\tKASSERT(!wskbd_console_initted);\n\n\twskbd_console_data.t_keymap = mapdata;\n\twskbd_update_layout(&wskbd_console_data, mapdata->layout);\n\n\twskbd_console_data.t_consops = consops;\n\twskbd_console_data.t_consaccesscookie = conscookie;\n\n#if NWSDISPLAY > 0\n\twsdisplay_set_cons_kbd(wskbd_cngetc, wskbd_cnpollc, wskbd_cnbell);\n#endif\n\n\twskbd_console_initted = 1;\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wsdisplay.h\"",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wskbdvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int wskbd_console_initted;",
      "static struct wskbd_internal wskbd_console_data;",
      "static void wskbd_update_layout"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wsdisplay_set_cons_kbd",
          "args": [
            "wskbd_cngetc",
            "wskbd_cnpollc",
            "wskbd_cnbell"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "wsdisplay_set_cons_kbd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsdisplay.c",
          "lines": "1747-1756",
          "snippet": "void\nwsdisplay_set_cons_kbd(get, poll, bell)\n\tint (*get) __P((dev_t));\n\tvoid (*poll) __P((dev_t, int));\n\tvoid (*bell) __P((dev_t, u_int, u_int, u_int));\n{\n\twsdisplay_cons.cn_getc = get;\n\t/* wsdisplay_cons.cn_bell = bell; XXX */\n\twsdisplay_cons_kbd_pollc = poll;\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wskbd.h\"",
            "#include <dev/cons.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wsemulvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsdisplayvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void (*wsdisplay_cons_kbd_pollc)",
            "static struct consdev wsdisplay_cons = {\n\tNULL, NULL, wsdisplay_getc_dummy, wsdisplay_cnputc,\n\twsdisplay_pollc, NODEV, CN_NORMAL\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wseventvar.h>\n#include \"wsmux.h\"\n#include \"wskbd.h\"\n#include <dev/cons.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wsemulvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsdisplayvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstatic void (*wsdisplay_cons_kbd_pollc);\nstatic struct consdev wsdisplay_cons = {\n\tNULL, NULL, wsdisplay_getc_dummy, wsdisplay_cnputc,\n\twsdisplay_pollc, NODEV, CN_NORMAL\n};\n\nvoid\nwsdisplay_set_cons_kbd(get, poll, bell)\n\tint (*get) __P((dev_t));\n\tvoid (*poll) __P((dev_t, int));\n\tvoid (*bell) __P((dev_t, u_int, u_int, u_int));\n{\n\twsdisplay_cons.cn_getc = get;\n\t/* wsdisplay_cons.cn_bell = bell; XXX */\n\twsdisplay_cons_kbd_pollc = poll;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wskbd_update_layout",
          "args": [
            "&wskbd_console_data",
            "mapdata->layout"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "wskbd_update_layout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
          "lines": "288-298",
          "snippet": "static void\nwskbd_update_layout(id, enc)\n\tstruct wskbd_internal *id;\n\tkbd_t enc;\n{\n\n\tif (enc & KB_METAESC)\n\t\tid->t_flags |= WSKFL_METAESC;\n\telse\n\t\tid->t_flags &= ~WSKFL_METAESC;\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wsdisplay.h\"",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wskbdvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/malloc.h>",
            "#include <sys/timeout.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [
            "#define WSKFL_METAESC 1"
          ],
          "globals_used": [
            "static void wskbd_update_layout"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define WSKFL_METAESC 1\n\nstatic void wskbd_update_layout;\n\nstatic void\nwskbd_update_layout(id, enc)\n\tstruct wskbd_internal *id;\n\tkbd_t enc;\n{\n\n\tif (enc & KB_METAESC)\n\t\tid->t_flags |= WSKFL_METAESC;\n\telse\n\t\tid->t_flags &= ~WSKFL_METAESC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KASSERT",
          "args": [
            "!wskbd_console_initted"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstatic int wskbd_console_initted;\nstatic struct wskbd_internal wskbd_console_data;\nstatic void wskbd_update_layout;\n\nvoid    \nwskbd_cnattach(consops, conscookie, mapdata)\n\tconst struct wskbd_consops *consops;\n\tvoid *conscookie;\n\tconst struct wskbd_mapdata *mapdata;\n{\n\n\tKASSERT(!wskbd_console_initted);\n\n\twskbd_console_data.t_keymap = mapdata;\n\twskbd_update_layout(&wskbd_console_data, mapdata->layout);\n\n\twskbd_console_data.t_consops = consops;\n\twskbd_console_data.t_consaccesscookie = conscookie;\n\n#if NWSDISPLAY > 0\n\twsdisplay_set_cons_kbd(wskbd_cngetc, wskbd_cnpollc, wskbd_cnbell);\n#endif\n\n\twskbd_console_initted = 1;\n}"
  },
  {
    "function_name": "wskbd_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
    "lines": "344-422",
    "snippet": "void\nwskbd_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct wskbd_softc *sc = (struct wskbd_softc *)self;\n\tstruct wskbddev_attach_args *ap = aux;\n#if NWSMUX > 0 || NWSDISPLAY > 0\n\tint mux;\n#endif\n\n#if NWSDISPLAY > 0\n\tsc->sc_displaydv = NULL;\n#endif\n\tsc->sc_isconsole = ap->console;\n\n#if NWSMUX > 0 || NWSDISPLAY > 0\n\tmux = sc->sc_dv.dv_cfdata->wskbddevcf_mux;\n\tif (sc->sc_isconsole && mux != WSKBDDEVCF_MUX_DEFAULT) {\n\t\tprintf(\" (mux %d ignored for console)\", mux);\n\t\tmux = WSKBDDEVCF_MUX_DEFAULT;\n\t}\n\tif (mux != WSKBDDEVCF_MUX_DEFAULT)\n\t\tprintf(\" mux %d\", mux);\n#endif\n\n\tif (ap->console) {\n\t\tsc->id = &wskbd_console_data;\n\t} else {\n\t\tsc->id = malloc(sizeof(struct wskbd_internal),\n\t\t\t\tM_DEVBUF, M_WAITOK);\n\t\tbzero(sc->id, sizeof(struct wskbd_internal));\n\t\tsc->id->t_keymap = ap->keymap;\n\t\twskbd_update_layout(sc->id, ap->keymap->layout);\n\t}\n\n\ttimeout_set(&sc->sc_repeat_ch, wskbd_repeat, sc);\n\n\tsc->id->t_sc = sc;\n\n\tsc->sc_accessops = ap->accessops;\n\tsc->sc_accesscookie = ap->accesscookie;\n\tsc->sc_ready = 0;\t\t\t\t/* sanity */\n\tsc->sc_repeating = 0;\n\tsc->sc_translating = 1;\n\tsc->sc_ledstate = -1; /* force update */\n\n\tif (wskbd_load_keymap(sc->id->t_keymap,\n\t\t\t      &sc->sc_map, &sc->sc_maplen) != 0)\n\t\tpanic(\"cannot load keymap\");\n\n\tsc->sc_layout = sc->id->t_keymap->layout;\n\n\t/* set default bell and key repeat data */\n\tsc->sc_bell_data = wskbd_default_bell_data;\n\tsc->sc_keyrepeat_data = wskbd_default_keyrepeat_data;\n\n\tif (ap->console) {\n\t\tKASSERT(wskbd_console_initted); \n\t\tKASSERT(wskbd_console_device == NULL);\n\n\t\twskbd_console_device = sc;\n\n\t\tprintf(\": console keyboard\");\n\n#if NWSDISPLAY > 0\n\t\tif ((sc->sc_displaydv = wsdisplay_set_console_kbd(self)))\n\t\t\tprintf(\", using %s\", sc->sc_displaydv->dv_xname);\n#endif\n\t}\n\tprintf(\"\\n\");\n\n#if NWSMUX > 0\n\tif (mux != WSKBDDEVCF_MUX_DEFAULT)\n\t\twsmux_attach(mux, WSMUX_KBD, &sc->sc_dv, &sc->sc_events, \n\t\t\t     &sc->sc_mux, &wskbd_muxops);\n#endif\n\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wsdisplay.h\"",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wskbdvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\twskbd_attach",
      "struct wskbd_bell_data wskbd_default_bell_data = {\n\tWSKBD_BELL_DOALL,\n\tWSKBD_DEFAULT_BELL_PITCH,\n\tWSKBD_DEFAULT_BELL_PERIOD,\n\tWSKBD_DEFAULT_BELL_VOLUME,\n};",
      "struct wskbd_keyrepeat_data wskbd_default_keyrepeat_data = {\n\tWSKBD_KEYREPEAT_DOALL,\n\tWSKBD_DEFAULT_KEYREPEAT_DEL1,\n\tWSKBD_DEFAULT_KEYREPEAT_DELN,\n};",
      "static int wskbd_console_initted;",
      "static struct wskbd_softc *wskbd_console_device;",
      "static struct wskbd_internal wskbd_console_data;",
      "static void wskbd_update_layout"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wsmux_attach",
          "args": [
            "mux",
            "WSMUX_KBD",
            "&sc->sc_dv",
            "&sc->sc_events",
            "&sc->sc_mux",
            "&wskbd_muxops"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "wsmux_attach_sc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmux.c",
          "lines": "364-429",
          "snippet": "int\nwsmux_attach_sc(sc, type, dsc, ev, psp, ops)\n\tstruct wsmux_softc *sc;\n\tint type;\n        struct device *dsc;\n\tstruct wseventvar *ev;\n\tstruct wsmux_softc **psp;\n\tstruct wsmuxops *ops;\n{\n\tstruct wsplink *m;\n\tint error;\n\n\tDPRINTF((\"wsmux_attach_sc: %s: type=%d dsc=%p, *psp=%p\\n\",\n\t\t sc->sc_dv.dv_xname, type, dsc, *psp));\n\tm = malloc(sizeof *m, M_DEVBUF, M_NOWAIT);\n\tif (m == 0)\n\t\treturn (ENOMEM);\n\tm->type = type;\n\tm->mux = sc;\n\tm->sc = dsc;\n\tm->sc_mevents = ev;\n\tm->sc_muxp = psp;\n\tm->sc_ops = ops;\n\tLIST_INSERT_HEAD(&sc->sc_reals, m, next);\n\n\tif (sc->sc_displaydv) {\n\t\t/* This is a display mux, so attach the new device to it. */\n\t\tDPRINTF((\"wsmux_attach_sc: %s: set display %p\\n\", \n\t\t\t sc->sc_dv.dv_xname, sc->sc_displaydv));\n\t\terror = 0;\n\t\tif (m->sc_ops->dsetdisplay) {\n\t\t\terror = m->sc_ops->dsetdisplay(m->sc, sc);\n\t\t\t/* Ignore that the console already has a display. */\n\t\t\tif (error == EBUSY)\n\t\t\t\terror = 0;\n\t\t\tif (!error) {\n\t\t\t\t*m->sc_muxp = sc;\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t\t\t\tDPRINTF((\"wsmux_attach_sc: on %s set rawkbd=%d\\n\",\n\t\t\t\t\t m->sc->dv_xname, sc->sc_rawkbd));\n\t\t\t\t(void)m->sc_ops->dioctl(m->sc, \n\t\t\t\t\t     WSKBDIO_SETMODE, \n\t\t\t\t\t     (caddr_t)&sc->sc_rawkbd,\n\t\t\t\t\t     0, 0);\n#endif\n\t\t\t}\n\t\t}\n\t} else if (sc->sc_events.io) {\n\t\t/* Mux is open, so open the new subdevice */\n\t\tDPRINTF((\"wsmux_attach_sc: %s: calling open of %s\\n\",\n\t\t\t sc->sc_dv.dv_xname, m->sc->dv_xname));\n\t\t/* mux already open, join in */\n\t\terror = m->sc_ops->dopen(makedev(0, m->sc->dv_unit),\n\t\t\t\t\t sc->sc_flags, sc->sc_mode, sc->sc_p);\n\t\tif (!error)\n\t\t\t*m->sc_muxp = sc;\n\t} else {\n\t\tDPRINTF((\"wsmux_attach_sc: %s not open\\n\",\n\t\t\t sc->sc_dv.dv_xname));\n\t\terror = 0;\n\t}\n\tDPRINTF((\"wsmux_attach_sc: done sc=%p psp=%p *psp=%p\\n\", \n\t\t sc, psp, *psp));\n\n\treturn (error);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/device.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include \"wskbd.h\"",
            "#include \"wsdisplay.h\"",
            "#include \"wsmux.h\""
          ],
          "macros_used": [
            "#define d ((struct wsmux_device *)data)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n\n#define d ((struct wsmux_device *)data)\n\nint\nwsmux_attach_sc(sc, type, dsc, ev, psp, ops)\n\tstruct wsmux_softc *sc;\n\tint type;\n        struct device *dsc;\n\tstruct wseventvar *ev;\n\tstruct wsmux_softc **psp;\n\tstruct wsmuxops *ops;\n{\n\tstruct wsplink *m;\n\tint error;\n\n\tDPRINTF((\"wsmux_attach_sc: %s: type=%d dsc=%p, *psp=%p\\n\",\n\t\t sc->sc_dv.dv_xname, type, dsc, *psp));\n\tm = malloc(sizeof *m, M_DEVBUF, M_NOWAIT);\n\tif (m == 0)\n\t\treturn (ENOMEM);\n\tm->type = type;\n\tm->mux = sc;\n\tm->sc = dsc;\n\tm->sc_mevents = ev;\n\tm->sc_muxp = psp;\n\tm->sc_ops = ops;\n\tLIST_INSERT_HEAD(&sc->sc_reals, m, next);\n\n\tif (sc->sc_displaydv) {\n\t\t/* This is a display mux, so attach the new device to it. */\n\t\tDPRINTF((\"wsmux_attach_sc: %s: set display %p\\n\", \n\t\t\t sc->sc_dv.dv_xname, sc->sc_displaydv));\n\t\terror = 0;\n\t\tif (m->sc_ops->dsetdisplay) {\n\t\t\terror = m->sc_ops->dsetdisplay(m->sc, sc);\n\t\t\t/* Ignore that the console already has a display. */\n\t\t\tif (error == EBUSY)\n\t\t\t\terror = 0;\n\t\t\tif (!error) {\n\t\t\t\t*m->sc_muxp = sc;\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t\t\t\tDPRINTF((\"wsmux_attach_sc: on %s set rawkbd=%d\\n\",\n\t\t\t\t\t m->sc->dv_xname, sc->sc_rawkbd));\n\t\t\t\t(void)m->sc_ops->dioctl(m->sc, \n\t\t\t\t\t     WSKBDIO_SETMODE, \n\t\t\t\t\t     (caddr_t)&sc->sc_rawkbd,\n\t\t\t\t\t     0, 0);\n#endif\n\t\t\t}\n\t\t}\n\t} else if (sc->sc_events.io) {\n\t\t/* Mux is open, so open the new subdevice */\n\t\tDPRINTF((\"wsmux_attach_sc: %s: calling open of %s\\n\",\n\t\t\t sc->sc_dv.dv_xname, m->sc->dv_xname));\n\t\t/* mux already open, join in */\n\t\terror = m->sc_ops->dopen(makedev(0, m->sc->dv_unit),\n\t\t\t\t\t sc->sc_flags, sc->sc_mode, sc->sc_p);\n\t\tif (!error)\n\t\t\t*m->sc_muxp = sc;\n\t} else {\n\t\tDPRINTF((\"wsmux_attach_sc: %s not open\\n\",\n\t\t\t sc->sc_dv.dv_xname));\n\t\terror = 0;\n\t}\n\tDPRINTF((\"wsmux_attach_sc: done sc=%p psp=%p *psp=%p\\n\", \n\t\t sc, psp, *psp));\n\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wsdisplay_set_console_kbd",
          "args": [
            "self"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KASSERT",
          "args": [
            "wskbd_console_device == NULL"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KASSERT",
          "args": [
            "wskbd_console_initted"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"cannot load keymap\""
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wskbd_load_keymap",
          "args": [
            "sc->id->t_keymap",
            "&sc->sc_map",
            "&sc->sc_maplen"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "wskbd_load_keymap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbdutil.c",
          "lines": "407-477",
          "snippet": "int\nwskbd_load_keymap(mapdata, map, maplen)\n\tconst struct wskbd_mapdata *mapdata;\n\tstruct wscons_keymap **map;\n\tint *maplen;\n{\n\tint i, s, kc, stack_ptr;\n\tconst keysym_t *kp;\n\tconst struct wscons_keydesc *mp, *stack[10];\n\tkbd_t cur;\n\n\tfor (cur = mapdata->layout & ~KB_HANDLEDBYWSKBD, stack_ptr = 0;\n\t     cur != 0; stack_ptr++) {\n\t\tmp = mapdata->keydesc;\n\t\twhile (mp->map_size > 0) {\n\t\t\tif (cur == 0 || mp->name == cur) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmp++;\n\t\t}\n\n\t\tif (stack_ptr == sizeof(stack)/sizeof(stack[0]))\n\t\t\tpanic(\"wskbd_load_keymap: %d: recursion too deep\",\n\t\t\t      mapdata->layout);\n\t\tif (mp->map_size <= 0)\n\t\t\treturn(EINVAL);\n\n\t\tstack[stack_ptr] = mp;\n\t\tcur = mp->base;\n\t}\n\n\tfor (i = 0, s = stack_ptr - 1; s >= 0; s--) {\n\t\tmp = stack[s];\n\t\tfor (kp = mp->map; kp < mp->map + mp->map_size; kp++)\n\t\t\tif (KS_GROUP(*kp) == KS_GROUP_Keycode && KS_VALUE(*kp) > i)\n\t\t\t\ti = KS_VALUE(*kp);\n\t}\n\n\twskbd_init_keymap(i + 1, map, maplen);\n\n\tfor (s = stack_ptr - 1; s >= 0; s--) {\n\t\tmp = stack[s];\n\t\tfor (kp = mp->map; kp < mp->map + mp->map_size; ) {\n\t\t\tif (KS_GROUP(*kp) != KS_GROUP_Keycode)\n\t\t\t\tpanic(\"wskbd_load_keymap: %d(%d): bad entry\",\n\t\t\t\t      mp->name, *kp);\n\n\t\t\tkc = KS_VALUE(*kp);\n\t\t\tkp++;\n\n\t\t\tif (KS_GROUP(*kp) == KS_GROUP_Command ||\n\t\t\t    *kp == KS_Cmd || *kp == KS_Cmd1 || *kp == KS_Cmd2) {\n\t\t\t\t(*map)[kc].command = *kp;\n\t\t\t\tkp++;\n\t\t\t}\n\n\t\t\tfor (i = 0; kp + i < mp->map + mp->map_size; i++)\n\t\t\t\tif (KS_GROUP(kp[i]) == KS_GROUP_Keycode)\n\t\t\t\t\tbreak;\n\n\t\t\tif (i > 4)\n\t\t\t\tpanic(\"wskbd_load_keymap: %d(%d): bad entry\",\n\t\t\t\t      mp->name, *kp);\n\n\t\t\tfillmapentry(kp, i, &(*map)[kc]);\n\t\t\tkp += i;\n\t\t}\n\t}\n\n\treturn(0);\n}",
          "includes": [
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/errno.h>",
            "#include <sys/cdefs.h>",
            "#include <sys/types.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillmapentry"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/errno.h>\n#include <sys/cdefs.h>\n#include <sys/types.h>\n#include <sys/param.h>\n\nstatic void fillmapentry;\n\nint\nwskbd_load_keymap(mapdata, map, maplen)\n\tconst struct wskbd_mapdata *mapdata;\n\tstruct wscons_keymap **map;\n\tint *maplen;\n{\n\tint i, s, kc, stack_ptr;\n\tconst keysym_t *kp;\n\tconst struct wscons_keydesc *mp, *stack[10];\n\tkbd_t cur;\n\n\tfor (cur = mapdata->layout & ~KB_HANDLEDBYWSKBD, stack_ptr = 0;\n\t     cur != 0; stack_ptr++) {\n\t\tmp = mapdata->keydesc;\n\t\twhile (mp->map_size > 0) {\n\t\t\tif (cur == 0 || mp->name == cur) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmp++;\n\t\t}\n\n\t\tif (stack_ptr == sizeof(stack)/sizeof(stack[0]))\n\t\t\tpanic(\"wskbd_load_keymap: %d: recursion too deep\",\n\t\t\t      mapdata->layout);\n\t\tif (mp->map_size <= 0)\n\t\t\treturn(EINVAL);\n\n\t\tstack[stack_ptr] = mp;\n\t\tcur = mp->base;\n\t}\n\n\tfor (i = 0, s = stack_ptr - 1; s >= 0; s--) {\n\t\tmp = stack[s];\n\t\tfor (kp = mp->map; kp < mp->map + mp->map_size; kp++)\n\t\t\tif (KS_GROUP(*kp) == KS_GROUP_Keycode && KS_VALUE(*kp) > i)\n\t\t\t\ti = KS_VALUE(*kp);\n\t}\n\n\twskbd_init_keymap(i + 1, map, maplen);\n\n\tfor (s = stack_ptr - 1; s >= 0; s--) {\n\t\tmp = stack[s];\n\t\tfor (kp = mp->map; kp < mp->map + mp->map_size; ) {\n\t\t\tif (KS_GROUP(*kp) != KS_GROUP_Keycode)\n\t\t\t\tpanic(\"wskbd_load_keymap: %d(%d): bad entry\",\n\t\t\t\t      mp->name, *kp);\n\n\t\t\tkc = KS_VALUE(*kp);\n\t\t\tkp++;\n\n\t\t\tif (KS_GROUP(*kp) == KS_GROUP_Command ||\n\t\t\t    *kp == KS_Cmd || *kp == KS_Cmd1 || *kp == KS_Cmd2) {\n\t\t\t\t(*map)[kc].command = *kp;\n\t\t\t\tkp++;\n\t\t\t}\n\n\t\t\tfor (i = 0; kp + i < mp->map + mp->map_size; i++)\n\t\t\t\tif (KS_GROUP(kp[i]) == KS_GROUP_Keycode)\n\t\t\t\t\tbreak;\n\n\t\t\tif (i > 4)\n\t\t\t\tpanic(\"wskbd_load_keymap: %d(%d): bad entry\",\n\t\t\t\t      mp->name, *kp);\n\n\t\t\tfillmapentry(kp, i, &(*map)[kc]);\n\t\t\tkp += i;\n\t\t}\n\t}\n\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timeout_set",
          "args": [
            "&sc->sc_repeat_ch",
            "wskbd_repeat",
            "sc"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wskbd_update_layout",
          "args": [
            "sc->id",
            "ap->keymap->layout"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "wskbd_update_layout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
          "lines": "288-298",
          "snippet": "static void\nwskbd_update_layout(id, enc)\n\tstruct wskbd_internal *id;\n\tkbd_t enc;\n{\n\n\tif (enc & KB_METAESC)\n\t\tid->t_flags |= WSKFL_METAESC;\n\telse\n\t\tid->t_flags &= ~WSKFL_METAESC;\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wsdisplay.h\"",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wskbdvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/malloc.h>",
            "#include <sys/timeout.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [
            "#define WSKFL_METAESC 1"
          ],
          "globals_used": [
            "static void wskbd_update_layout"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define WSKFL_METAESC 1\n\nstatic void wskbd_update_layout;\n\nstatic void\nwskbd_update_layout(id, enc)\n\tstruct wskbd_internal *id;\n\tkbd_t enc;\n{\n\n\tif (enc & KB_METAESC)\n\t\tid->t_flags |= WSKFL_METAESC;\n\telse\n\t\tid->t_flags &= ~WSKFL_METAESC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "sc->id",
            "sizeof(struct wskbd_internal)"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct wskbd_internal)",
            "M_DEVBUF",
            "M_WAITOK"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nvoid\twskbd_attach;\nstruct wskbd_bell_data wskbd_default_bell_data = {\n\tWSKBD_BELL_DOALL,\n\tWSKBD_DEFAULT_BELL_PITCH,\n\tWSKBD_DEFAULT_BELL_PERIOD,\n\tWSKBD_DEFAULT_BELL_VOLUME,\n};\nstruct wskbd_keyrepeat_data wskbd_default_keyrepeat_data = {\n\tWSKBD_KEYREPEAT_DOALL,\n\tWSKBD_DEFAULT_KEYREPEAT_DEL1,\n\tWSKBD_DEFAULT_KEYREPEAT_DELN,\n};\nstatic int wskbd_console_initted;\nstatic struct wskbd_softc *wskbd_console_device;\nstatic struct wskbd_internal wskbd_console_data;\nstatic void wskbd_update_layout;\n\nvoid\nwskbd_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid *aux;\n{\n\tstruct wskbd_softc *sc = (struct wskbd_softc *)self;\n\tstruct wskbddev_attach_args *ap = aux;\n#if NWSMUX > 0 || NWSDISPLAY > 0\n\tint mux;\n#endif\n\n#if NWSDISPLAY > 0\n\tsc->sc_displaydv = NULL;\n#endif\n\tsc->sc_isconsole = ap->console;\n\n#if NWSMUX > 0 || NWSDISPLAY > 0\n\tmux = sc->sc_dv.dv_cfdata->wskbddevcf_mux;\n\tif (sc->sc_isconsole && mux != WSKBDDEVCF_MUX_DEFAULT) {\n\t\tprintf(\" (mux %d ignored for console)\", mux);\n\t\tmux = WSKBDDEVCF_MUX_DEFAULT;\n\t}\n\tif (mux != WSKBDDEVCF_MUX_DEFAULT)\n\t\tprintf(\" mux %d\", mux);\n#endif\n\n\tif (ap->console) {\n\t\tsc->id = &wskbd_console_data;\n\t} else {\n\t\tsc->id = malloc(sizeof(struct wskbd_internal),\n\t\t\t\tM_DEVBUF, M_WAITOK);\n\t\tbzero(sc->id, sizeof(struct wskbd_internal));\n\t\tsc->id->t_keymap = ap->keymap;\n\t\twskbd_update_layout(sc->id, ap->keymap->layout);\n\t}\n\n\ttimeout_set(&sc->sc_repeat_ch, wskbd_repeat, sc);\n\n\tsc->id->t_sc = sc;\n\n\tsc->sc_accessops = ap->accessops;\n\tsc->sc_accesscookie = ap->accesscookie;\n\tsc->sc_ready = 0;\t\t\t\t/* sanity */\n\tsc->sc_repeating = 0;\n\tsc->sc_translating = 1;\n\tsc->sc_ledstate = -1; /* force update */\n\n\tif (wskbd_load_keymap(sc->id->t_keymap,\n\t\t\t      &sc->sc_map, &sc->sc_maplen) != 0)\n\t\tpanic(\"cannot load keymap\");\n\n\tsc->sc_layout = sc->id->t_keymap->layout;\n\n\t/* set default bell and key repeat data */\n\tsc->sc_bell_data = wskbd_default_bell_data;\n\tsc->sc_keyrepeat_data = wskbd_default_keyrepeat_data;\n\n\tif (ap->console) {\n\t\tKASSERT(wskbd_console_initted); \n\t\tKASSERT(wskbd_console_device == NULL);\n\n\t\twskbd_console_device = sc;\n\n\t\tprintf(\": console keyboard\");\n\n#if NWSDISPLAY > 0\n\t\tif ((sc->sc_displaydv = wsdisplay_set_console_kbd(self)))\n\t\t\tprintf(\", using %s\", sc->sc_displaydv->dv_xname);\n#endif\n\t}\n\tprintf(\"\\n\");\n\n#if NWSMUX > 0\n\tif (mux != WSKBDDEVCF_MUX_DEFAULT)\n\t\twsmux_attach(mux, WSMUX_KBD, &sc->sc_dv, &sc->sc_events, \n\t\t\t     &sc->sc_mux, &wskbd_muxops);\n#endif\n\n}"
  },
  {
    "function_name": "wskbd_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
    "lines": "321-342",
    "snippet": "int\nwskbd_match(parent, match, aux)\n\tstruct device *parent;\n\tstruct cfdata *match;\n\tvoid *aux;\n{\n\tstruct wskbddev_attach_args *ap = aux;\n\n\tif (match->wskbddevcf_console != WSKBDDEVCF_CONSOLE_UNK) {\n\t\t/*\n\t\t * If console-ness of device specified, either match\n\t\t * exactly (at high priority), or fail.\n\t\t */\n\t\tif (match->wskbddevcf_console != 0 && ap->console != 0)\n\t\t\treturn (10);\n\t\telse\n\t\t\treturn (0);\n\t}\n\n\t/* If console-ness unspecified, it wins. */\n\treturn (1);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wsdisplay.h\"",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wskbdvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\twskbd_match"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nint\twskbd_match;\n\nint\nwskbd_match(parent, match, aux)\n\tstruct device *parent;\n\tstruct cfdata *match;\n\tvoid *aux;\n{\n\tstruct wskbddev_attach_args *ap = aux;\n\n\tif (match->wskbddevcf_console != WSKBDDEVCF_CONSOLE_UNK) {\n\t\t/*\n\t\t * If console-ness of device specified, either match\n\t\t * exactly (at high priority), or fail.\n\t\t */\n\t\tif (match->wskbddevcf_console != 0 && ap->console != 0)\n\t\t\treturn (10);\n\t\telse\n\t\t\treturn (0);\n\t}\n\n\t/* If console-ness unspecified, it wins. */\n\treturn (1);\n}"
  },
  {
    "function_name": "wskbddevprint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
    "lines": "303-319",
    "snippet": "int\nwskbddevprint(aux, pnp)\n\tvoid *aux;\n\tconst char *pnp;\n{\n#if 0\n\tstruct wskbddev_attach_args *ap = aux;\n#endif\n\n\tif (pnp)\n\t\tprintf(\"wskbd at %s\", pnp);\n#if 0\n\tprintf(\" console %d\", ap->console);\n#endif\n\n\treturn (UNCONF);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wsdisplay.h\"",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wskbdvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" console %d\"",
            "ap->console"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nint\nwskbddevprint(aux, pnp)\n\tvoid *aux;\n\tconst char *pnp;\n{\n#if 0\n\tstruct wskbddev_attach_args *ap = aux;\n#endif\n\n\tif (pnp)\n\t\tprintf(\"wskbd at %s\", pnp);\n#if 0\n\tprintf(\" console %d\", ap->console);\n#endif\n\n\treturn (UNCONF);\n}"
  },
  {
    "function_name": "wskbd_update_layout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
    "lines": "288-298",
    "snippet": "static void\nwskbd_update_layout(id, enc)\n\tstruct wskbd_internal *id;\n\tkbd_t enc;\n{\n\n\tif (enc & KB_METAESC)\n\t\tid->t_flags |= WSKFL_METAESC;\n\telse\n\t\tid->t_flags &= ~WSKFL_METAESC;\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include \"wsmux.h\"",
      "#include \"wsdisplay.h\"",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsksymvar.h>",
      "#include <dev/wscons/wsksymdef.h>",
      "#include <dev/wscons/wskbdvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/vnode.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/errno.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/malloc.h>",
      "#include <sys/timeout.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include <sys/cdefs.h>"
    ],
    "macros_used": [
      "#define WSKFL_METAESC 1"
    ],
    "globals_used": [
      "static void wskbd_update_layout"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\n#define WSKFL_METAESC 1\n\nstatic void wskbd_update_layout;\n\nstatic void\nwskbd_update_layout(id, enc)\n\tstruct wskbd_internal *id;\n\tkbd_t enc;\n{\n\n\tif (enc & KB_METAESC)\n\t\tid->t_flags |= WSKFL_METAESC;\n\telse\n\t\tid->t_flags &= ~WSKFL_METAESC;\n}"
  }
]