[
  {
    "function_name": "gus_test_iobase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "3597-3666",
    "snippet": "int\ngus_test_iobase (iot, iobase)\n\tbus_space_tag_t iot;\n\tint iobase;\n{\n\tbus_space_handle_t ioh1, ioh2, ioh3, ioh4;\n\tu_char s1, s2;\n\tint s, rv = 0;\n\n\t/* Map i/o space */\n\tif (bus_space_map(iot, iobase, GUS_NPORT1, 0, &ioh1))\n\t\treturn 0;\n\tif (bus_space_map(iot, iobase+GUS_IOH2_OFFSET, GUS_NPORT2, 0, &ioh2))\n\t\tgoto bad1;\n\n\t/* XXX Maybe we shouldn't fail on mapping this, but just assume\n\t * the card is of revision 0? */\n\tif (bus_space_map(iot, iobase+GUS_IOH3_OFFSET, GUS_NPORT3, 0, &ioh3))\n\t\tgoto bad2;\n\n\tif (bus_space_map(iot, iobase+GUS_IOH4_OFFSET, GUS_NPORT4, 0, &ioh4))\n\t\tgoto bad3;\n\n\t/*\n\t * Reset GUS to an initial state before we do anything.\n\t */\n\n\ts = splgus();\n\tdelay(500);\n\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_RESET);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);\n\n \tdelay(500);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_RESET);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, GUSMASK_MASTER_RESET);\n\n \tdelay(500);\n\n\tsplx(s);\n\n\t/*\n\t * See if we can write to the board's memory\n\t */\n\n \ts1 = guspeek(iot, ioh2, 0L);\n \ts2 = guspeek(iot, ioh2, 1L);\n\n \tguspoke(iot, ioh2, 0L, 0xaa);\n \tguspoke(iot, ioh2, 1L, 0x55);\n\n \tif (guspeek(iot, ioh2, 0L) != 0xaa)\n\t\tgoto bad;\n\n\tguspoke(iot, ioh2, 0L, s1);\n\tguspoke(iot, ioh2, 1L, s2);\n\n\trv = 1;\n\nbad:\n\tbus_space_unmap(iot, ioh4, GUS_NPORT4);\nbad3:\n\tbus_space_unmap(iot, ioh3, GUS_NPORT3);\nbad2:\n\tbus_space_unmap(iot, ioh2, GUS_NPORT2);\nbad1:\n\tbus_space_unmap(iot, ioh1, GUS_NPORT1);\n\treturn rv;\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "iot",
            "ioh1",
            "GUS_NPORT1"
          ],
          "line": 3664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "iot",
            "ioh2",
            "GUS_NPORT2"
          ],
          "line": 3662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "iot",
            "ioh3",
            "GUS_NPORT3"
          ],
          "line": 3660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_unmap",
          "args": [
            "iot",
            "ioh4",
            "GUS_NPORT4"
          ],
          "line": 3658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "guspoke",
          "args": [
            "iot",
            "ioh2",
            "1L",
            "s2"
          ],
          "line": 3653
        },
        "resolved": true,
        "details": {
          "function_name": "guspoke",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "1997-2019",
          "snippet": "void\nguspoke(iot, ioh2, address, value)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh2;\n\tlong address;\n\tunsigned char value;\n{\n\n\t/*\n\t * Select the DRAM address\n\t */\n\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_LOW);\n \tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, (unsigned int) (address & 0xffff));\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_HIGH);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, (unsigned char) ((address >> 16) & 0xff));\n\n\t/*\n\t * Actually write the data\n\t */\n\n\tbus_space_write_1(iot, ioh2, GUS_DRAM_DATA, value);\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nguspoke(iot, ioh2, address, value)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh2;\n\tlong address;\n\tunsigned char value;\n{\n\n\t/*\n\t * Select the DRAM address\n\t */\n\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_LOW);\n \tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, (unsigned int) (address & 0xffff));\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_HIGH);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, (unsigned char) ((address >> 16) & 0xff));\n\n\t/*\n\t * Actually write the data\n\t */\n\n\tbus_space_write_1(iot, ioh2, GUS_DRAM_DATA, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "guspeek",
          "args": [
            "iot",
            "ioh2",
            "0L"
          ],
          "line": 3649
        },
        "resolved": true,
        "details": {
          "function_name": "guspeek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "2025-2046",
          "snippet": "unsigned char\nguspeek(iot, ioh2, address)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh2;\n\tu_long address;\n{\n\n\t/*\n\t * Select the DRAM address\n\t */\n\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_LOW);\n \tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, (unsigned int) (address & 0xffff));\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_HIGH);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, (unsigned char) ((address >> 16) & 0xff));\n\n\t/*\n\t * Read in the data from the board\n\t */\n\n\treturn (unsigned char) bus_space_read_1(iot, ioh2, GUS_DRAM_DATA);\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nunsigned char\nguspeek(iot, ioh2, address)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh2;\n\tu_long address;\n{\n\n\t/*\n\t * Select the DRAM address\n\t */\n\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_LOW);\n \tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, (unsigned int) (address & 0xffff));\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_HIGH);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, (unsigned char) ((address >> 16) & 0xff));\n\n\t/*\n\t * Read in the data from the board\n\t */\n\n\treturn (unsigned char) bus_space_read_1(iot, ioh2, GUS_DRAM_DATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 3637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "500"
          ],
          "line": 3635
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "GUSMASK_MASTER_RESET"
          ],
          "line": 3633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_RESET"
          ],
          "line": 3632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "0x00"
          ],
          "line": 3628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_RESET"
          ],
          "line": 3627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splgus",
          "args": [],
          "line": 3624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "iot",
            "iobase+GUS_IOH4_OFFSET",
            "GUS_NPORT4",
            "0",
            "&ioh4"
          ],
          "line": 3617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "iot",
            "iobase+GUS_IOH3_OFFSET",
            "GUS_NPORT3",
            "0",
            "&ioh3"
          ],
          "line": 3614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "iot",
            "iobase+GUS_IOH2_OFFSET",
            "GUS_NPORT2",
            "0",
            "&ioh2"
          ],
          "line": 3609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_map",
          "args": [
            "iot",
            "iobase",
            "GUS_NPORT1",
            "0",
            "&ioh1"
          ],
          "line": 3607
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngus_test_iobase (iot, iobase)\n\tbus_space_tag_t iot;\n\tint iobase;\n{\n\tbus_space_handle_t ioh1, ioh2, ioh3, ioh4;\n\tu_char s1, s2;\n\tint s, rv = 0;\n\n\t/* Map i/o space */\n\tif (bus_space_map(iot, iobase, GUS_NPORT1, 0, &ioh1))\n\t\treturn 0;\n\tif (bus_space_map(iot, iobase+GUS_IOH2_OFFSET, GUS_NPORT2, 0, &ioh2))\n\t\tgoto bad1;\n\n\t/* XXX Maybe we shouldn't fail on mapping this, but just assume\n\t * the card is of revision 0? */\n\tif (bus_space_map(iot, iobase+GUS_IOH3_OFFSET, GUS_NPORT3, 0, &ioh3))\n\t\tgoto bad2;\n\n\tif (bus_space_map(iot, iobase+GUS_IOH4_OFFSET, GUS_NPORT4, 0, &ioh4))\n\t\tgoto bad3;\n\n\t/*\n\t * Reset GUS to an initial state before we do anything.\n\t */\n\n\ts = splgus();\n\tdelay(500);\n\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_RESET);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);\n\n \tdelay(500);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_RESET);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, GUSMASK_MASTER_RESET);\n\n \tdelay(500);\n\n\tsplx(s);\n\n\t/*\n\t * See if we can write to the board's memory\n\t */\n\n \ts1 = guspeek(iot, ioh2, 0L);\n \ts2 = guspeek(iot, ioh2, 1L);\n\n \tguspoke(iot, ioh2, 0L, 0xaa);\n \tguspoke(iot, ioh2, 1L, 0x55);\n\n \tif (guspeek(iot, ioh2, 0L) != 0xaa)\n\t\tgoto bad;\n\n\tguspoke(iot, ioh2, 0L, s1);\n\tguspoke(iot, ioh2, 1L, s2);\n\n\trv = 1;\n\nbad:\n\tbus_space_unmap(iot, ioh4, GUS_NPORT4);\nbad3:\n\tbus_space_unmap(iot, ioh3, GUS_NPORT3);\nbad2:\n\tbus_space_unmap(iot, ioh2, GUS_NPORT2);\nbad1:\n\tbus_space_unmap(iot, ioh1, GUS_NPORT1);\n\treturn rv;\n}"
  },
  {
    "function_name": "gus_subattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "3388-3590",
    "snippet": "void\ngus_subattach(sc, ia)\n\tstruct gus_softc *sc;\n\tstruct isa_attach_args *ia;\n{\n \tint\t\ti;\n\tbus_space_tag_t iot;\n\tunsigned char\tc,d,m;\n\n\tiot = sc->sc_iot;\n\n\t/*\n\t * Figure out our board rev, and see if we need to initialize the\n\t * mixer\n\t */\n\n \tc = bus_space_read_1(iot, sc->sc_ioh3, GUS_BOARD_REV);\n\tif (c != 0xff)\n\t\tsc->sc_revision = c;\n\telse\n\t\tsc->sc_revision = 0;\n\n \tSELECT_GUS_REG(iot, sc->sc_ioh2, GUSREG_RESET);\n \tbus_space_write_1(iot, sc->sc_ioh2, GUS_DATA_HIGH, 0x00);\n\n\tgusreset(sc, GUS_MAX_VOICES); /* initialize all voices */\n\tgusreset(sc, GUS_MIN_VOICES); /* then set to just the ones we use */\n\n\t/*\n\t * Setup the IRQ and DRQ lines in software, using values from\n\t * config file\n\t */\n\n\tm = GUSMASK_LINE_IN|GUSMASK_LINE_OUT;\t\t/* disable all */\n\n\tc = ((unsigned char) gus_irq_map[ia->ia_irq]) | GUSMASK_BOTH_RQ;\n\n\tif (sc->sc_recdrq == sc->sc_drq)\n\t\td = (unsigned char) (gus_drq_map[sc->sc_drq] |\n\t\t\t\tGUSMASK_BOTH_RQ);\n\telse\n\t\td = (unsigned char) (gus_drq_map[sc->sc_drq] |\n\t\t\t\tgus_drq_map[sc->sc_recdrq] << 3);\n\n\t/*\n\t * Program the IRQ and DMA channels on the GUS.  Note that we hardwire\n\t * the GUS to only use one IRQ channel, but we give the user the\n\t * option of using two DMA channels (the other one given by the flags\n\t * option in the config file).  Two DMA channels are needed for full-\n\t * duplex operation.\n\t *\n\t * The order of these operations is very magical.\n\t */\n\n\tdisable_intr();\t\t/* XXX needed? */\n\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_REG_CONTROL, GUS_REG_IRQCTL);\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_MIX_CONTROL, m);\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_IRQCTL_CONTROL, 0x00);\n\tbus_space_write_1(iot, sc->sc_ioh1, 0x0f, 0x00);\n\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_MIX_CONTROL, m);\n\n\t/* magic reset? */\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_DMA_CONTROL, d | 0x80);\n\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_MIX_CONTROL,\n\t    m | GUSMASK_CONTROL_SEL);\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_IRQ_CONTROL, c);\n\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_MIX_CONTROL, m);\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_DMA_CONTROL, d);\n\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_MIX_CONTROL,\n\t    m | GUSMASK_CONTROL_SEL);\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_IRQ_CONTROL, c);\n\n\tbus_space_write_1(iot, sc->sc_ioh2, GUS_VOICE_SELECT, 0x00);\n\n\t/* enable line in, line out.  leave mic disabled. */\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_MIX_CONTROL,\n\t     (m | GUSMASK_LATCHES) & ~(GUSMASK_LINE_OUT|GUSMASK_LINE_IN));\n\tbus_space_write_1(iot, sc->sc_ioh2, GUS_VOICE_SELECT, 0x00);\n\n\tenable_intr();\n\n\tsc->sc_mixcontrol =\n\t\t(m | GUSMASK_LATCHES) & ~(GUSMASK_LINE_OUT|GUSMASK_LINE_IN);\n\n\tsc->sc_codec.sc_isa = sc->sc_isa;\n\n \tif (sc->sc_revision >= 5 && sc->sc_revision <= 9) {\n \t\tsc->sc_flags |= GUS_MIXER_INSTALLED;\n \t\tgus_init_ics2101(sc);\n\t}\n\tif (sc->sc_revision < 0xa || !gus_init_cs4231(sc)) {\n\t\t/* Not using the CS4231, so create our DMA maps. */\n\t\tif (sc->sc_drq != -1) {\n\t\t\tif (isa_dmamap_create(sc->sc_isa, sc->sc_drq,\n\t\t\t    MAX_ISADMA, BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\t\t\tprintf(\"%s: can't create map for drq %d\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, sc->sc_drq);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (sc->sc_recdrq != -1 && sc->sc_recdrq != sc->sc_drq) {\n\t\t\tif (isa_dmamap_create(sc->sc_isa, sc->sc_recdrq,\n\t\t\t    MAX_ISADMA, BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\t\t\tprintf(\"%s: can't create map for drq %d\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, sc->sc_recdrq);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n \tSELECT_GUS_REG(iot, sc->sc_ioh2, GUSREG_RESET);\n \t/*\n \t * Check to see how much memory we have on this card; see if any\n \t * \"mirroring\" occurs.  We're assuming at least 256K already exists\n \t * on the card; otherwise the initial probe would have failed\n \t */\n\n\tguspoke(iot, sc->sc_ioh2, 0L, 0x00);\n\tfor(i = 1; i < 1024; i++) {\n\t\tu_long loc;\n\n\t\t/*\n\t\t * See if we've run into mirroring yet\n\t\t */\n\n\t\tif (guspeek(iot, sc->sc_ioh2, 0L) != 0)\n\t\t\tbreak;\n\n\t\tloc = i << 10;\n\n\t\tguspoke(iot, sc->sc_ioh2, loc, 0xaa);\n\t\tif (guspeek(iot, sc->sc_ioh2, loc) != 0xaa)\n\t\t\tbreak;\n\t}\n\n\tsc->sc_dsize = i;\n\tsprintf(gus_device.version, \"3.%d\", sc->sc_revision);\n\n\tprintf(\": ver 3.%d, %dKB DRAM, \",\n\t       sc->sc_revision, sc->sc_dsize);\n\tif (HAS_MIXER(sc))\n\t\tprintf(\"ICS2101 mixer, \");\n\tif (HAS_CODEC(sc))\n\t\tprintf(\"%s codec/mixer, \", sc->sc_codec.chip_name);\n\tif (sc->sc_recdrq == sc->sc_drq) {\n\t\tprintf(\"half-duplex\");\n\t} else {\n\t\tprintf(\"full-duplex, record drq %d\", sc->sc_recdrq);\n\t}\n\n\tprintf(\"\\n\");\n\n\t/*\n\t * Setup a default interrupt handler\n\t */\n\n\t/* XXX we shouldn't have to use splgus == splclock, nor should\n\t * we use IPL_CLOCK.\n\t */\n\tsc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,\n\t    IPL_AUDIO, gusintr, sc /* sc->sc_gusdsp */, sc->sc_dev.dv_xname);\n\n\t/*\n\t * Set some default values\n\t * XXX others start with 8kHz mono mulaw\n\t */\n\n\tsc->sc_irate = sc->sc_orate = 44100;\n\tsc->sc_encoding = AUDIO_ENCODING_SLINEAR_LE;\n\tsc->sc_precision = 16;\n\tsc->sc_voc[GUS_VOICE_LEFT].voccntl |= GUSMASK_DATA_SIZE16;\n\tsc->sc_voc[GUS_VOICE_RIGHT].voccntl |= GUSMASK_DATA_SIZE16;\n\tsc->sc_channels = 1;\n\tsc->sc_ogain = 340;\n\tgus_commit_settings(sc);\n\n\t/*\n\t * We always put the left channel full left & right channel\n\t * full right.\n\t * For mono playback, we set up both voices playing the same buffer.\n\t */\n\tbus_space_write_1(iot, sc->sc_ioh2, GUS_VOICE_SELECT,\n\t    (u_char)GUS_VOICE_LEFT);\n\tSELECT_GUS_REG(iot, sc->sc_ioh2, GUSREG_PAN_POS);\n\tbus_space_write_1(iot, sc->sc_ioh2, GUS_DATA_HIGH, GUS_PAN_FULL_LEFT);\n\n\tbus_space_write_1(iot, sc->sc_ioh2, GUS_VOICE_SELECT,\n\t    (u_char)GUS_VOICE_RIGHT);\n\tSELECT_GUS_REG(iot, sc->sc_ioh2, GUSREG_PAN_POS);\n\tbus_space_write_1(iot, sc->sc_ioh2, GUS_DATA_HIGH, GUS_PAN_FULL_RIGHT);\n\n\t/*\n\t * Attach to the generic audio layer\n\t */\n\n\taudio_attach_mi(&gus_hw_if, HAS_CODEC(sc) ? (void *)&sc->sc_codec :\n\t    (void *)sc, &sc->sc_dev);\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int gus_irq_map[] = {\n\tIRQUNK, IRQUNK, 1, 3, IRQUNK, 2, IRQUNK, 4, IRQUNK, 1, IRQUNK, 5, 6,\n\tIRQUNK, IRQUNK, 7\n};",
      "int gus_drq_map[] = {\n\tDRQUNK, 1, DRQUNK, 2, DRQUNK, 3, 4, 5\n};",
      "struct audio_hw_if gus_hw_if = {\n\tgusopen,\n\tgusclose,\n\tNULL,\t\t\t\t/* drain */\n\n\tgus_query_encoding,\n\n\tgus_set_params,\n\n\tgus_round_blocksize,\n\n\tgus_commit_settings,\n\n\tNULL,\n\tNULL,\n\n\tgus_dma_output,\n\tgus_dma_input,\n\tgus_halt_out_dma,\n\tgus_halt_in_dma,\n\tgus_speaker_ctl,\n\n\tgus_getdev,\n\tNULL,\n\tgus_mixer_set_port,\n\tgus_mixer_get_port,\n\tgus_mixer_query_devinfo,\n\tad1848_malloc,\n\tad1848_free,\n\tad1848_round,\n\tad1848_mappage,\n\tgus_get_props,\n\n\tNULL,\n\tNULL\n};",
      "struct audio_device gus_device = {\n\t\"UltraSound\",\n\t\"\",\n\t\"gus\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audio_attach_mi",
          "args": [
            "&gus_hw_if",
            "HAS_CODEC(sc) ? (void *)&sc->sc_codec :\n\t    (void *)sc",
            "&sc->sc_dev"
          ],
          "line": 3588
        },
        "resolved": true,
        "details": {
          "function_name": "audio_attach_mi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "394-408",
          "snippet": "void\naudio_attach_mi(ahwp, hdlp, dev)\n\tstruct audio_hw_if *ahwp;\n\tvoid *hdlp;\n\tstruct device *dev;\n{\n\tstruct audio_attach_args arg;\n\n\tif (ahwp != NULL) {\n\t\targ.type = AUDIODEV_TYPE_AUDIO;\n\t\targ.hwif = ahwp;\n\t\targ.hdl = hdlp;\n\t\t(void)config_found(dev, &arg, audioprint);\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nvoid\naudio_attach_mi(ahwp, hdlp, dev)\n\tstruct audio_hw_if *ahwp;\n\tvoid *hdlp;\n\tstruct device *dev;\n{\n\tstruct audio_attach_args arg;\n\n\tif (ahwp != NULL) {\n\t\targ.type = AUDIODEV_TYPE_AUDIO;\n\t\targ.hwif = ahwp;\n\t\targ.hdl = hdlp;\n\t\t(void)config_found(dev, &arg, audioprint);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "HAS_CODEC",
          "args": [
            "sc"
          ],
          "line": 3588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "sc->sc_ioh2",
            "GUS_DATA_HIGH",
            "GUS_PAN_FULL_RIGHT"
          ],
          "line": 3582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "sc->sc_ioh2",
            "GUSREG_PAN_POS"
          ],
          "line": 3581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "sc->sc_ioh2",
            "GUS_VOICE_SELECT",
            "(u_char)GUS_VOICE_RIGHT"
          ],
          "line": 3579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "sc->sc_ioh2",
            "GUS_DATA_HIGH",
            "GUS_PAN_FULL_LEFT"
          ],
          "line": 3577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "sc->sc_ioh2",
            "GUSREG_PAN_POS"
          ],
          "line": 3576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "sc->sc_ioh2",
            "GUS_VOICE_SELECT",
            "(u_char)GUS_VOICE_LEFT"
          ],
          "line": 3574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gus_commit_settings",
          "args": [
            "sc"
          ],
          "line": 3567
        },
        "resolved": true,
        "details": {
          "function_name": "gus_commit_settings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "1689-1710",
          "snippet": "int\ngus_commit_settings(addr)\n\tvoid * addr;\n{\n\tstruct gus_softc *sc = addr;\n\tint s;\n\n\tDPRINTF((\"gus_commit_settings called (gain = %d)\\n\",sc->sc_ogain));\n\n\n\ts = splgus();\n\n\tgus_set_recrate(sc, sc->sc_irate);\n\tgus_set_volume(sc, GUS_VOICE_LEFT, sc->sc_ogain);\n\tgus_set_volume(sc, GUS_VOICE_RIGHT, sc->sc_ogain);\n\tgus_set_samprate(sc, GUS_VOICE_LEFT, sc->sc_orate);\n\tgus_set_samprate(sc, GUS_VOICE_RIGHT, sc->sc_orate);\n\tsplx(s);\n\tgus_set_chan_addrs(sc);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngus_commit_settings(addr)\n\tvoid * addr;\n{\n\tstruct gus_softc *sc = addr;\n\tint s;\n\n\tDPRINTF((\"gus_commit_settings called (gain = %d)\\n\",sc->sc_ogain));\n\n\n\ts = splgus();\n\n\tgus_set_recrate(sc, sc->sc_irate);\n\tgus_set_volume(sc, GUS_VOICE_LEFT, sc->sc_ogain);\n\tgus_set_volume(sc, GUS_VOICE_RIGHT, sc->sc_ogain);\n\tgus_set_samprate(sc, GUS_VOICE_LEFT, sc->sc_orate);\n\tgus_set_samprate(sc, GUS_VOICE_RIGHT, sc->sc_orate);\n\tsplx(s);\n\tgus_set_chan_addrs(sc);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isa_intr_establish",
          "args": [
            "ia->ia_ic",
            "ia->ia_irq",
            "IST_EDGE",
            "IPL_AUDIO",
            "gusintr",
            "sc/* sc->sc_gusdsp */",
            "sc->sc_dev.dv_xname"
          ],
          "line": 3552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 3543
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "HAS_CODEC",
          "args": [
            "sc"
          ],
          "line": 3535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_MIXER",
          "args": [
            "sc"
          ],
          "line": 3533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "gus_device.version",
            "\"3.%d\"",
            "sc->sc_revision"
          ],
          "line": 3529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "guspeek",
          "args": [
            "iot",
            "sc->sc_ioh2",
            "loc"
          ],
          "line": 3524
        },
        "resolved": true,
        "details": {
          "function_name": "guspeek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "2025-2046",
          "snippet": "unsigned char\nguspeek(iot, ioh2, address)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh2;\n\tu_long address;\n{\n\n\t/*\n\t * Select the DRAM address\n\t */\n\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_LOW);\n \tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, (unsigned int) (address & 0xffff));\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_HIGH);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, (unsigned char) ((address >> 16) & 0xff));\n\n\t/*\n\t * Read in the data from the board\n\t */\n\n\treturn (unsigned char) bus_space_read_1(iot, ioh2, GUS_DRAM_DATA);\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nunsigned char\nguspeek(iot, ioh2, address)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh2;\n\tu_long address;\n{\n\n\t/*\n\t * Select the DRAM address\n\t */\n\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_LOW);\n \tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, (unsigned int) (address & 0xffff));\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_HIGH);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, (unsigned char) ((address >> 16) & 0xff));\n\n\t/*\n\t * Read in the data from the board\n\t */\n\n\treturn (unsigned char) bus_space_read_1(iot, ioh2, GUS_DRAM_DATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "guspoke",
          "args": [
            "iot",
            "sc->sc_ioh2",
            "loc",
            "0xaa"
          ],
          "line": 3523
        },
        "resolved": true,
        "details": {
          "function_name": "guspoke",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "1997-2019",
          "snippet": "void\nguspoke(iot, ioh2, address, value)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh2;\n\tlong address;\n\tunsigned char value;\n{\n\n\t/*\n\t * Select the DRAM address\n\t */\n\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_LOW);\n \tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, (unsigned int) (address & 0xffff));\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_HIGH);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, (unsigned char) ((address >> 16) & 0xff));\n\n\t/*\n\t * Actually write the data\n\t */\n\n\tbus_space_write_1(iot, ioh2, GUS_DRAM_DATA, value);\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nguspoke(iot, ioh2, address, value)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh2;\n\tlong address;\n\tunsigned char value;\n{\n\n\t/*\n\t * Select the DRAM address\n\t */\n\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_LOW);\n \tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, (unsigned int) (address & 0xffff));\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_HIGH);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, (unsigned char) ((address >> 16) & 0xff));\n\n\t/*\n\t * Actually write the data\n\t */\n\n\tbus_space_write_1(iot, ioh2, GUS_DRAM_DATA, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "sc->sc_ioh2",
            "GUSREG_RESET"
          ],
          "line": 3503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isa_dmamap_create",
          "args": [
            "sc->sc_isa",
            "sc->sc_recdrq",
            "MAX_ISADMA",
            "BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW"
          ],
          "line": 3494
        },
        "resolved": true,
        "details": {
          "function_name": "isa_dmamap_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/isadma.c",
          "lines": "220-255",
          "snippet": "int\nisa_dmamap_create(isadev, chan, size, flags)\n\tstruct device *isadev;\n\tint chan;\n\tbus_size_t size;\n\tint flags;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tbus_size_t maxsize;\n\n\tif (chan < 0 || chan > 7) {\n\t\tprintf(\"%s: bogus drq %d\\n\", sc->sc_dev.dv_xname, chan);\n\t\tgoto lose;\n\t}\n\n\tif (chan & 4)\n\t\tmaxsize = (1 << 17);\n\telse\n\t\tmaxsize = (1 << 16);\n\n\tif (size > maxsize)\n\t\treturn (EINVAL);\n\n\tif (ISA_DRQ_ISFREE(sc, chan) == 0) {\n\t\tprintf(\"%s: drq %d is not free\\n\", sc->sc_dev.dv_xname, chan);\n\t\tgoto lose;\n\t}\n\n\tISA_DRQ_ALLOC(sc, chan);\n\n\treturn (bus_dmamap_create(sc->sc_dmat, size, 1, size, maxsize,\n\t    flags, &sc->sc_dmamaps[chan]));\n\n lose:\n\tpanic(\"isa_dmamap_create\");\n}",
          "includes": [
            "#include <sys/malloc.h>",
            "#include <dev/isa/isadmareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;",
            "int chan;",
            "size_t size;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/malloc.h>\n#include <dev/isa/isadmareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;\nint chan;\nsize_t size;\nint flags;\n\nint\nisa_dmamap_create(isadev, chan, size, flags)\n\tstruct device *isadev;\n\tint chan;\n\tbus_size_t size;\n\tint flags;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tbus_size_t maxsize;\n\n\tif (chan < 0 || chan > 7) {\n\t\tprintf(\"%s: bogus drq %d\\n\", sc->sc_dev.dv_xname, chan);\n\t\tgoto lose;\n\t}\n\n\tif (chan & 4)\n\t\tmaxsize = (1 << 17);\n\telse\n\t\tmaxsize = (1 << 16);\n\n\tif (size > maxsize)\n\t\treturn (EINVAL);\n\n\tif (ISA_DRQ_ISFREE(sc, chan) == 0) {\n\t\tprintf(\"%s: drq %d is not free\\n\", sc->sc_dev.dv_xname, chan);\n\t\tgoto lose;\n\t}\n\n\tISA_DRQ_ALLOC(sc, chan);\n\n\treturn (bus_dmamap_create(sc->sc_dmat, size, 1, size, maxsize,\n\t    flags, &sc->sc_dmamaps[chan]));\n\n lose:\n\tpanic(\"isa_dmamap_create\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "gus_init_cs4231",
          "args": [
            "sc"
          ],
          "line": 3483
        },
        "resolved": true,
        "details": {
          "function_name": "gus_init_cs4231",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "2182-2228",
          "snippet": "int\ngus_init_cs4231(sc)\n\tstruct gus_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh1 = sc->sc_ioh1;\n\tint port = sc->sc_iobase;\n\tu_char ctrl;\n\n\tctrl = (port & 0xf0) >> 4;\t/* set port address middle nibble */\n\t/*\n\t * The codec is a bit weird--swapped dma channels.\n\t */\n\tctrl |= GUS_MAX_CODEC_ENABLE;\n\tif (sc->sc_drq >= 4)\n\t\tctrl |= GUS_MAX_RECCHAN16;\n\tif (sc->sc_recdrq >= 4)\n\t\tctrl |= GUS_MAX_PLAYCHAN16;\n\n\tbus_space_write_1(iot, ioh1, GUS_MAX_CTRL, ctrl);\n\n\tsc->sc_codec.sc_iot = sc->sc_iot;\n\tsc->sc_codec.sc_iobase = port+GUS_MAX_CODEC_BASE;\n\n\tif (ad1848_probe(&sc->sc_codec) == 0) {\n\t\tsc->sc_flags &= ~GUS_CODEC_INSTALLED;\n\t\treturn (0);\n\t} else {\n\t\tstruct ad1848_volume vol = {AUDIO_MAX_GAIN, AUDIO_MAX_GAIN};\n\t\tsc->sc_flags |= GUS_CODEC_INSTALLED;\n\t\tsc->sc_codec.parent = sc;\n\t\tsc->sc_codec.sc_drq = sc->sc_recdrq;\n\t\tsc->sc_codec.sc_recdrq = sc->sc_drq;\n\t\tgus_hw_if = gusmax_hw_if;\n\t\t/* enable line in and mic in the GUS mixer; the codec chip\n\t\t   will do the real mixing for them. */\n\t\tsc->sc_mixcontrol &= ~GUSMASK_LINE_IN; /* 0 enables. */\n\t\tsc->sc_mixcontrol |= GUSMASK_MIC_IN; /* 1 enables. */\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t\t\n\t\tad1848_attach(&sc->sc_codec);\n\t\t/* turn on pre-MUX microphone gain. */\n\t\tad1848_set_mic_gain(&sc->sc_codec, &vol);\n\n\t\treturn (1);\n\t}\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct audio_hw_if gus_hw_if = {\n\tgusopen,\n\tgusclose,\n\tNULL,\t\t\t\t/* drain */\n\n\tgus_query_encoding,\n\n\tgus_set_params,\n\n\tgus_round_blocksize,\n\n\tgus_commit_settings,\n\n\tNULL,\n\tNULL,\n\n\tgus_dma_output,\n\tgus_dma_input,\n\tgus_halt_out_dma,\n\tgus_halt_in_dma,\n\tgus_speaker_ctl,\n\n\tgus_getdev,\n\tNULL,\n\tgus_mixer_set_port,\n\tgus_mixer_get_port,\n\tgus_mixer_query_devinfo,\n\tad1848_malloc,\n\tad1848_free,\n\tad1848_round,\n\tad1848_mappage,\n\tgus_get_props,\n\n\tNULL,\n\tNULL\n};",
            "static struct audio_hw_if gusmax_hw_if = {\n\tgusmaxopen,\n\tgusmax_close,\n\tNULL,\t\t\t\t/* drain */\n\t\n\tgus_query_encoding, /* query encoding */\n\t\n\tgusmax_set_params,\n\t\n\tgusmax_round_blocksize,\n\t\n\tgusmax_commit_settings,\n\t\n\tNULL,\n\tNULL,\n\t\n\tgusmax_dma_output,\n\tgusmax_dma_input,\n\tgusmax_halt_out_dma,\n\tgusmax_halt_in_dma,\n\t\n\tgusmax_speaker_ctl,\n\t\n\tgus_getdev,\n\tNULL,\n\tgusmax_mixer_set_port,\n\tgusmax_mixer_get_port,\n\tgusmax_mixer_query_devinfo,\n\tad1848_malloc,\n\tad1848_free,\n\tad1848_round,\n\tad1848_mappage,\n\tgusmax_get_props,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct audio_hw_if gus_hw_if = {\n\tgusopen,\n\tgusclose,\n\tNULL,\t\t\t\t/* drain */\n\n\tgus_query_encoding,\n\n\tgus_set_params,\n\n\tgus_round_blocksize,\n\n\tgus_commit_settings,\n\n\tNULL,\n\tNULL,\n\n\tgus_dma_output,\n\tgus_dma_input,\n\tgus_halt_out_dma,\n\tgus_halt_in_dma,\n\tgus_speaker_ctl,\n\n\tgus_getdev,\n\tNULL,\n\tgus_mixer_set_port,\n\tgus_mixer_get_port,\n\tgus_mixer_query_devinfo,\n\tad1848_malloc,\n\tad1848_free,\n\tad1848_round,\n\tad1848_mappage,\n\tgus_get_props,\n\n\tNULL,\n\tNULL\n};\nstatic struct audio_hw_if gusmax_hw_if = {\n\tgusmaxopen,\n\tgusmax_close,\n\tNULL,\t\t\t\t/* drain */\n\t\n\tgus_query_encoding, /* query encoding */\n\t\n\tgusmax_set_params,\n\t\n\tgusmax_round_blocksize,\n\t\n\tgusmax_commit_settings,\n\t\n\tNULL,\n\tNULL,\n\t\n\tgusmax_dma_output,\n\tgusmax_dma_input,\n\tgusmax_halt_out_dma,\n\tgusmax_halt_in_dma,\n\t\n\tgusmax_speaker_ctl,\n\t\n\tgus_getdev,\n\tNULL,\n\tgusmax_mixer_set_port,\n\tgusmax_mixer_get_port,\n\tgusmax_mixer_query_devinfo,\n\tad1848_malloc,\n\tad1848_free,\n\tad1848_round,\n\tad1848_mappage,\n\tgusmax_get_props,\n};\n\nint\ngus_init_cs4231(sc)\n\tstruct gus_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh1 = sc->sc_ioh1;\n\tint port = sc->sc_iobase;\n\tu_char ctrl;\n\n\tctrl = (port & 0xf0) >> 4;\t/* set port address middle nibble */\n\t/*\n\t * The codec is a bit weird--swapped dma channels.\n\t */\n\tctrl |= GUS_MAX_CODEC_ENABLE;\n\tif (sc->sc_drq >= 4)\n\t\tctrl |= GUS_MAX_RECCHAN16;\n\tif (sc->sc_recdrq >= 4)\n\t\tctrl |= GUS_MAX_PLAYCHAN16;\n\n\tbus_space_write_1(iot, ioh1, GUS_MAX_CTRL, ctrl);\n\n\tsc->sc_codec.sc_iot = sc->sc_iot;\n\tsc->sc_codec.sc_iobase = port+GUS_MAX_CODEC_BASE;\n\n\tif (ad1848_probe(&sc->sc_codec) == 0) {\n\t\tsc->sc_flags &= ~GUS_CODEC_INSTALLED;\n\t\treturn (0);\n\t} else {\n\t\tstruct ad1848_volume vol = {AUDIO_MAX_GAIN, AUDIO_MAX_GAIN};\n\t\tsc->sc_flags |= GUS_CODEC_INSTALLED;\n\t\tsc->sc_codec.parent = sc;\n\t\tsc->sc_codec.sc_drq = sc->sc_recdrq;\n\t\tsc->sc_codec.sc_recdrq = sc->sc_drq;\n\t\tgus_hw_if = gusmax_hw_if;\n\t\t/* enable line in and mic in the GUS mixer; the codec chip\n\t\t   will do the real mixing for them. */\n\t\tsc->sc_mixcontrol &= ~GUSMASK_LINE_IN; /* 0 enables. */\n\t\tsc->sc_mixcontrol |= GUSMASK_MIC_IN; /* 1 enables. */\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t\t\n\t\tad1848_attach(&sc->sc_codec);\n\t\t/* turn on pre-MUX microphone gain. */\n\t\tad1848_set_mic_gain(&sc->sc_codec, &vol);\n\n\t\treturn (1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gus_init_ics2101",
          "args": [
            "sc"
          ],
          "line": 3481
        },
        "resolved": true,
        "details": {
          "function_name": "gus_init_ics2101",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "3307-3384",
          "snippet": "void\ngus_init_ics2101(sc)\n\tstruct gus_softc *sc;\n{\n\tstruct ics2101_softc *ic = &sc->sc_mixer;\n\tsc->sc_mixer.sc_iot = sc->sc_iot;\n\tsc->sc_mixer.sc_selio = GUS_MIXER_SELECT;\n\tsc->sc_mixer.sc_selio_ioh = sc->sc_ioh3;\n\tsc->sc_mixer.sc_dataio = GUS_MIXER_DATA;\n\tsc->sc_mixer.sc_dataio_ioh = sc->sc_ioh2;\n\tsc->sc_mixer.sc_flags = (sc->sc_revision == 5) ? ICS_FLIP : 0;\n\n\tics2101_mix_attenuate(ic,\n\t\t\t      GUSMIX_CHAN_MIC,\n\t\t\t      ICSMIX_LEFT,\n\t\t\t      ICSMIX_MIN_ATTN);\n\tics2101_mix_attenuate(ic,\n\t\t\t      GUSMIX_CHAN_MIC,\n\t\t\t      ICSMIX_RIGHT,\n\t\t\t      ICSMIX_MIN_ATTN);\n\t/*\n\t * Start with microphone muted by the mixer...\n\t */\n\tgusics_mic_mute(ic, 1);\n\n\t/* ... and enabled by the GUS master mix control */\n\tgus_mic_ctl(sc, SPKR_ON);\n\n\tics2101_mix_attenuate(ic,\n\t\t\t      GUSMIX_CHAN_LINE,\n\t\t\t      ICSMIX_LEFT,\n\t\t\t      ICSMIX_MIN_ATTN);\n\tics2101_mix_attenuate(ic,\n\t\t\t      GUSMIX_CHAN_LINE,\n\t\t\t      ICSMIX_RIGHT,\n\t\t\t      ICSMIX_MIN_ATTN);\n\n\tics2101_mix_attenuate(ic,\n\t\t\t      GUSMIX_CHAN_CD,\n\t\t\t      ICSMIX_LEFT,\n\t\t\t      ICSMIX_MIN_ATTN);\n\tics2101_mix_attenuate(ic,\n\t\t\t      GUSMIX_CHAN_CD,\n\t\t\t      ICSMIX_RIGHT,\n\t\t\t      ICSMIX_MIN_ATTN);\n\n\tics2101_mix_attenuate(ic,\n\t\t\t      GUSMIX_CHAN_DAC,\n\t\t\t      ICSMIX_LEFT,\n\t\t\t      ICSMIX_MIN_ATTN);\n\tics2101_mix_attenuate(ic,\n\t\t\t      GUSMIX_CHAN_DAC,\n\t\t\t      ICSMIX_RIGHT,\n\t\t\t      ICSMIX_MIN_ATTN);\n\n\tics2101_mix_attenuate(ic,\n\t\t\t      ICSMIX_CHAN_4,\n\t\t\t      ICSMIX_LEFT,\n\t\t\t      ICSMIX_MAX_ATTN);\n\tics2101_mix_attenuate(ic,\n\t\t\t      ICSMIX_CHAN_4,\n\t\t\t      ICSMIX_RIGHT,\n\t\t\t      ICSMIX_MAX_ATTN);\n\n\tics2101_mix_attenuate(ic,\n\t\t\t      GUSMIX_CHAN_MASTER,\n\t\t\t      ICSMIX_LEFT,\n\t\t\t      ICSMIX_MIN_ATTN);\n\tics2101_mix_attenuate(ic,\n\t\t\t      GUSMIX_CHAN_MASTER,\n\t\t\t      ICSMIX_RIGHT,\n\t\t\t      ICSMIX_MIN_ATTN);\n\t/* unmute other stuff: */\n\tgusics_cd_mute(ic, 0);\n\tgusics_dac_mute(ic, 0);\n\tgusics_linein_mute(ic, 0);\n\treturn;\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ngus_init_ics2101(sc)\n\tstruct gus_softc *sc;\n{\n\tstruct ics2101_softc *ic = &sc->sc_mixer;\n\tsc->sc_mixer.sc_iot = sc->sc_iot;\n\tsc->sc_mixer.sc_selio = GUS_MIXER_SELECT;\n\tsc->sc_mixer.sc_selio_ioh = sc->sc_ioh3;\n\tsc->sc_mixer.sc_dataio = GUS_MIXER_DATA;\n\tsc->sc_mixer.sc_dataio_ioh = sc->sc_ioh2;\n\tsc->sc_mixer.sc_flags = (sc->sc_revision == 5) ? ICS_FLIP : 0;\n\n\tics2101_mix_attenuate(ic,\n\t\t\t      GUSMIX_CHAN_MIC,\n\t\t\t      ICSMIX_LEFT,\n\t\t\t      ICSMIX_MIN_ATTN);\n\tics2101_mix_attenuate(ic,\n\t\t\t      GUSMIX_CHAN_MIC,\n\t\t\t      ICSMIX_RIGHT,\n\t\t\t      ICSMIX_MIN_ATTN);\n\t/*\n\t * Start with microphone muted by the mixer...\n\t */\n\tgusics_mic_mute(ic, 1);\n\n\t/* ... and enabled by the GUS master mix control */\n\tgus_mic_ctl(sc, SPKR_ON);\n\n\tics2101_mix_attenuate(ic,\n\t\t\t      GUSMIX_CHAN_LINE,\n\t\t\t      ICSMIX_LEFT,\n\t\t\t      ICSMIX_MIN_ATTN);\n\tics2101_mix_attenuate(ic,\n\t\t\t      GUSMIX_CHAN_LINE,\n\t\t\t      ICSMIX_RIGHT,\n\t\t\t      ICSMIX_MIN_ATTN);\n\n\tics2101_mix_attenuate(ic,\n\t\t\t      GUSMIX_CHAN_CD,\n\t\t\t      ICSMIX_LEFT,\n\t\t\t      ICSMIX_MIN_ATTN);\n\tics2101_mix_attenuate(ic,\n\t\t\t      GUSMIX_CHAN_CD,\n\t\t\t      ICSMIX_RIGHT,\n\t\t\t      ICSMIX_MIN_ATTN);\n\n\tics2101_mix_attenuate(ic,\n\t\t\t      GUSMIX_CHAN_DAC,\n\t\t\t      ICSMIX_LEFT,\n\t\t\t      ICSMIX_MIN_ATTN);\n\tics2101_mix_attenuate(ic,\n\t\t\t      GUSMIX_CHAN_DAC,\n\t\t\t      ICSMIX_RIGHT,\n\t\t\t      ICSMIX_MIN_ATTN);\n\n\tics2101_mix_attenuate(ic,\n\t\t\t      ICSMIX_CHAN_4,\n\t\t\t      ICSMIX_LEFT,\n\t\t\t      ICSMIX_MAX_ATTN);\n\tics2101_mix_attenuate(ic,\n\t\t\t      ICSMIX_CHAN_4,\n\t\t\t      ICSMIX_RIGHT,\n\t\t\t      ICSMIX_MAX_ATTN);\n\n\tics2101_mix_attenuate(ic,\n\t\t\t      GUSMIX_CHAN_MASTER,\n\t\t\t      ICSMIX_LEFT,\n\t\t\t      ICSMIX_MIN_ATTN);\n\tics2101_mix_attenuate(ic,\n\t\t\t      GUSMIX_CHAN_MASTER,\n\t\t\t      ICSMIX_RIGHT,\n\t\t\t      ICSMIX_MIN_ATTN);\n\t/* unmute other stuff: */\n\tgusics_cd_mute(ic, 0);\n\tgusics_dac_mute(ic, 0);\n\tgusics_linein_mute(ic, 0);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "enable_intr",
          "args": [],
          "line": 3472
        },
        "resolved": true,
        "details": {
          "function_name": "gdt_pci_enable_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/gdt_pci.c",
          "lines": "594-624",
          "snippet": "void\ngdt_pci_enable_intr(gdt)\n\tstruct gdt_softc *gdt;\n{\n\tGDT_DPRINTF(GDT_D_INTR, (\"gdt_pci_enable_intr(%p) \", gdt));\n\n\tswitch(GDT_CLASS(gdt)) {\n\tcase GDT_PCI:\n\t\tbus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh, GDT_IRQDEL,\n\t\t    1);\n\t\tbus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh,\n\t\t    GDT_CMD_INDEX, 0);\n\t\tbus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh, GDT_IRQEN,\n\t\t    1);\n\t\tbreak;\n\n\tcase GDT_PCINEW:\n\t\tbus_space_write_1(gdt->sc_iot, gdt->sc_ioh, GDT_EDOOR_REG,\n\t\t    0xff);\n\t\tbus_space_write_1(gdt->sc_iot, gdt->sc_ioh, GDT_CONTROL1, 3);\n\t\tbreak;\n\n\tcase GDT_MPR:\n\t\tbus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh,\n\t\t    GDT_MPR_EDOOR, 0xff);\n\t\tbus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh, GDT_EDOOR_EN,\n\t\t    bus_space_read_1(gdt->sc_dpmemt, gdt->sc_dpmemh,\n\t\t    GDT_EDOOR_EN) & ~4);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include <dev/ic/gdtvar.h>",
            "#include <dev/ic/gdtreg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <machine/intr.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define GDT_EDOOR_EN\t0x34\t/* u_int8_t, board interrupts enable */",
            "#define GDT_MPR_EDOOR\t0x2c\t/* volatile u_int8_t, locl to PCI doorbell */",
            "#define GDT_CONTROL1\t0x69\t/* u_int8_t, board interrupts enable */",
            "#define GDT_EDOOR_REG\t0x64\t/* volatile u_int8_t, local to PCI doorbell */",
            "#define GDT_IRQDEL\t0xffc\t/* u_int8_t, acknowledge board interrupt */",
            "#define GDT_IRQEN\t0xff5\t/* u_int8_t, board interrupts enable */"
          ],
          "globals_used": [
            "void\tgdt_pci_enable_intr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/gdtvar.h>\n#include <dev/ic/gdtreg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcidevs.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <machine/intr.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define GDT_EDOOR_EN\t0x34\t/* u_int8_t, board interrupts enable */\n#define GDT_MPR_EDOOR\t0x2c\t/* volatile u_int8_t, locl to PCI doorbell */\n#define GDT_CONTROL1\t0x69\t/* u_int8_t, board interrupts enable */\n#define GDT_EDOOR_REG\t0x64\t/* volatile u_int8_t, local to PCI doorbell */\n#define GDT_IRQDEL\t0xffc\t/* u_int8_t, acknowledge board interrupt */\n#define GDT_IRQEN\t0xff5\t/* u_int8_t, board interrupts enable */\n\nvoid\tgdt_pci_enable_intr;\n\nvoid\ngdt_pci_enable_intr(gdt)\n\tstruct gdt_softc *gdt;\n{\n\tGDT_DPRINTF(GDT_D_INTR, (\"gdt_pci_enable_intr(%p) \", gdt));\n\n\tswitch(GDT_CLASS(gdt)) {\n\tcase GDT_PCI:\n\t\tbus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh, GDT_IRQDEL,\n\t\t    1);\n\t\tbus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh,\n\t\t    GDT_CMD_INDEX, 0);\n\t\tbus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh, GDT_IRQEN,\n\t\t    1);\n\t\tbreak;\n\n\tcase GDT_PCINEW:\n\t\tbus_space_write_1(gdt->sc_iot, gdt->sc_ioh, GDT_EDOOR_REG,\n\t\t    0xff);\n\t\tbus_space_write_1(gdt->sc_iot, gdt->sc_ioh, GDT_CONTROL1, 3);\n\t\tbreak;\n\n\tcase GDT_MPR:\n\t\tbus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh,\n\t\t    GDT_MPR_EDOOR, 0xff);\n\t\tbus_space_write_1(gdt->sc_dpmemt, gdt->sc_dpmemh, GDT_EDOOR_EN,\n\t\t    bus_space_read_1(gdt->sc_dpmemt, gdt->sc_dpmemh,\n\t\t    GDT_EDOOR_EN) & ~4);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "sc->sc_ioh2",
            "GUS_VOICE_SELECT",
            "0x00"
          ],
          "line": 3470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "sc->sc_ioh1",
            "GUS_MIX_CONTROL",
            "(m | GUSMASK_LATCHES) & ~(GUSMASK_LINE_OUT|GUSMASK_LINE_IN)"
          ],
          "line": 3468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "sc->sc_ioh2",
            "GUS_VOICE_SELECT",
            "0x00"
          ],
          "line": 3465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "sc->sc_ioh1",
            "GUS_IRQ_CONTROL",
            "c"
          ],
          "line": 3463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "sc->sc_ioh1",
            "GUS_MIX_CONTROL",
            "m | GUSMASK_CONTROL_SEL"
          ],
          "line": 3461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "sc->sc_ioh1",
            "GUS_DMA_CONTROL",
            "d"
          ],
          "line": 3459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "sc->sc_ioh1",
            "GUS_MIX_CONTROL",
            "m"
          ],
          "line": 3458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "sc->sc_ioh1",
            "GUS_IRQ_CONTROL",
            "c"
          ],
          "line": 3456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "sc->sc_ioh1",
            "GUS_MIX_CONTROL",
            "m | GUSMASK_CONTROL_SEL"
          ],
          "line": 3454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "sc->sc_ioh1",
            "GUS_DMA_CONTROL",
            "d | 0x80"
          ],
          "line": 3452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "sc->sc_ioh1",
            "GUS_MIX_CONTROL",
            "m"
          ],
          "line": 3449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "sc->sc_ioh1",
            "0x0f",
            "0x00"
          ],
          "line": 3447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "sc->sc_ioh1",
            "GUS_IRQCTL_CONTROL",
            "0x00"
          ],
          "line": 3446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "sc->sc_ioh1",
            "GUS_MIX_CONTROL",
            "m"
          ],
          "line": 3445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "sc->sc_ioh1",
            "GUS_REG_CONTROL",
            "GUS_REG_IRQCTL"
          ],
          "line": 3444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disable_intr",
          "args": [],
          "line": 3442
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_disable_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "307-312",
          "snippet": "void\nwdc_disable_intr(chp)\n\tstruct channel_softc *chp;\n{\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_IDS);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwdc_disable_intr(chp)\n\tstruct channel_softc *chp;\n{\n\tCHP_WRITE_REG(chp, wdr_ctlr, WDCTL_IDS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gusreset",
          "args": [
            "sc",
            "GUS_MIN_VOICES"
          ],
          "line": 3414
        },
        "resolved": true,
        "details": {
          "function_name": "gusreset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "2052-2179",
          "snippet": "void\ngusreset(sc, voices)\n\tstruct gus_softc *sc;\n\tint voices;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh1 = sc->sc_ioh1;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tbus_space_handle_t ioh4 = sc->sc_ioh4;\n\tint i,s;\n\n\ts = splgus();\n\n\t/*\n\t * Reset the GF1 chip\n\t */\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_RESET);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);\n\n\tdelay(500);\n\n\t/*\n\t * Release reset\n\t */\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_RESET);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, GUSMASK_MASTER_RESET);\n\n\tdelay(500);\n\n\t/*\n\t * Reset MIDI port as well\n\t */\n\n\tbus_space_write_1(iot, ioh4, GUS_MIDI_CONTROL, MIDI_RESET);\n\n\tdelay(500);\n\n\tbus_space_write_1(iot, ioh4, GUS_MIDI_CONTROL, 0x00);\n\n\t/*\n\t * Clear interrupts\n\t */\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_TIMER_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_SAMPLE_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);\n\n\tgus_set_voices(sc, voices);\n\n\tbus_space_read_1(iot, ioh1, GUS_IRQ_STATUS);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);\n\tbus_space_read_1(iot, ioh2, GUS_DATA_HIGH);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_SAMPLE_CONTROL);\n\tbus_space_read_1(iot, ioh2, GUS_DATA_HIGH);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_IRQ_STATUS);\n\tbus_space_read_1(iot, ioh2, GUS_DATA_HIGH);\n\n\t/*\n\t * Reset voice specific information\n\t */\n\n\tfor(i = 0; i < voices; i++) {\n\t\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, (unsigned char) i);\n\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\n\t\tsc->sc_voc[i].voccntl = GUSMASK_VOICE_STOPPED |\n\t\t\tGUSMASK_STOP_VOICE;\n\n\t\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[i].voccntl);\n\n\t\tsc->sc_voc[i].volcntl = GUSMASK_VOLUME_STOPPED |\n\t\t\t\tGUSMASK_STOP_VOLUME;\n\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_CONTROL);\n\t\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[i].volcntl);\n\n\t\tdelay(100);\n\n\t\tgus_set_samprate(sc, i, 8000);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_START_ADDR_HIGH);\n\t\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_START_ADDR_LOW);\n\t\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_END_ADDR_HIGH);\n\t\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_END_ADDR_LOW);\n\t\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_RATE);\n\t\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x01);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_START_VOLUME);\n\t\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x10);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_END_VOLUME);\n\t\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0xe0);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_VOLUME);\n\t\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_HIGH);\n\t\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_LOW);\n\t\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_PAN_POS);\n\t\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x07);\n\t}\n\n\t/*\n\t * Clear out any pending IRQs\n\t */\n\n\tbus_space_read_1(iot, ioh1, GUS_IRQ_STATUS);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);\n\tbus_space_read_1(iot, ioh2, GUS_DATA_HIGH);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_SAMPLE_CONTROL);\n\tbus_space_read_1(iot, ioh2, GUS_DATA_HIGH);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_IRQ_STATUS);\n\tbus_space_read_1(iot, ioh2, GUS_DATA_HIGH);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_RESET);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, GUSMASK_MASTER_RESET | GUSMASK_DAC_ENABLE |\n\t\tGUSMASK_IRQ_ENABLE);\n\n\tsplx(s);\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ngusreset(sc, voices)\n\tstruct gus_softc *sc;\n\tint voices;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh1 = sc->sc_ioh1;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tbus_space_handle_t ioh4 = sc->sc_ioh4;\n\tint i,s;\n\n\ts = splgus();\n\n\t/*\n\t * Reset the GF1 chip\n\t */\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_RESET);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);\n\n\tdelay(500);\n\n\t/*\n\t * Release reset\n\t */\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_RESET);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, GUSMASK_MASTER_RESET);\n\n\tdelay(500);\n\n\t/*\n\t * Reset MIDI port as well\n\t */\n\n\tbus_space_write_1(iot, ioh4, GUS_MIDI_CONTROL, MIDI_RESET);\n\n\tdelay(500);\n\n\tbus_space_write_1(iot, ioh4, GUS_MIDI_CONTROL, 0x00);\n\n\t/*\n\t * Clear interrupts\n\t */\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_TIMER_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_SAMPLE_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);\n\n\tgus_set_voices(sc, voices);\n\n\tbus_space_read_1(iot, ioh1, GUS_IRQ_STATUS);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);\n\tbus_space_read_1(iot, ioh2, GUS_DATA_HIGH);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_SAMPLE_CONTROL);\n\tbus_space_read_1(iot, ioh2, GUS_DATA_HIGH);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_IRQ_STATUS);\n\tbus_space_read_1(iot, ioh2, GUS_DATA_HIGH);\n\n\t/*\n\t * Reset voice specific information\n\t */\n\n\tfor(i = 0; i < voices; i++) {\n\t\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, (unsigned char) i);\n\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\n\t\tsc->sc_voc[i].voccntl = GUSMASK_VOICE_STOPPED |\n\t\t\tGUSMASK_STOP_VOICE;\n\n\t\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[i].voccntl);\n\n\t\tsc->sc_voc[i].volcntl = GUSMASK_VOLUME_STOPPED |\n\t\t\t\tGUSMASK_STOP_VOLUME;\n\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_CONTROL);\n\t\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[i].volcntl);\n\n\t\tdelay(100);\n\n\t\tgus_set_samprate(sc, i, 8000);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_START_ADDR_HIGH);\n\t\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_START_ADDR_LOW);\n\t\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_END_ADDR_HIGH);\n\t\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_END_ADDR_LOW);\n\t\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_RATE);\n\t\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x01);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_START_VOLUME);\n\t\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x10);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_END_VOLUME);\n\t\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0xe0);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_VOLUME);\n\t\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_HIGH);\n\t\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_LOW);\n\t\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_PAN_POS);\n\t\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x07);\n\t}\n\n\t/*\n\t * Clear out any pending IRQs\n\t */\n\n\tbus_space_read_1(iot, ioh1, GUS_IRQ_STATUS);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);\n\tbus_space_read_1(iot, ioh2, GUS_DATA_HIGH);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_SAMPLE_CONTROL);\n\tbus_space_read_1(iot, ioh2, GUS_DATA_HIGH);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_IRQ_STATUS);\n\tbus_space_read_1(iot, ioh2, GUS_DATA_HIGH);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_RESET);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, GUSMASK_MASTER_RESET | GUSMASK_DAC_ENABLE |\n\t\tGUSMASK_IRQ_ENABLE);\n\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "sc->sc_ioh2",
            "GUS_DATA_HIGH",
            "0x00"
          ],
          "line": 3411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "sc->sc_ioh2",
            "GUSREG_RESET"
          ],
          "line": 3410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "sc->sc_ioh3",
            "GUS_BOARD_REV"
          ],
          "line": 3404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint gus_irq_map[] = {\n\tIRQUNK, IRQUNK, 1, 3, IRQUNK, 2, IRQUNK, 4, IRQUNK, 1, IRQUNK, 5, 6,\n\tIRQUNK, IRQUNK, 7\n};\nint gus_drq_map[] = {\n\tDRQUNK, 1, DRQUNK, 2, DRQUNK, 3, 4, 5\n};\nstruct audio_hw_if gus_hw_if = {\n\tgusopen,\n\tgusclose,\n\tNULL,\t\t\t\t/* drain */\n\n\tgus_query_encoding,\n\n\tgus_set_params,\n\n\tgus_round_blocksize,\n\n\tgus_commit_settings,\n\n\tNULL,\n\tNULL,\n\n\tgus_dma_output,\n\tgus_dma_input,\n\tgus_halt_out_dma,\n\tgus_halt_in_dma,\n\tgus_speaker_ctl,\n\n\tgus_getdev,\n\tNULL,\n\tgus_mixer_set_port,\n\tgus_mixer_get_port,\n\tgus_mixer_query_devinfo,\n\tad1848_malloc,\n\tad1848_free,\n\tad1848_round,\n\tad1848_mappage,\n\tgus_get_props,\n\n\tNULL,\n\tNULL\n};\nstruct audio_device gus_device = {\n\t\"UltraSound\",\n\t\"\",\n\t\"gus\",\n};\n\nvoid\ngus_subattach(sc, ia)\n\tstruct gus_softc *sc;\n\tstruct isa_attach_args *ia;\n{\n \tint\t\ti;\n\tbus_space_tag_t iot;\n\tunsigned char\tc,d,m;\n\n\tiot = sc->sc_iot;\n\n\t/*\n\t * Figure out our board rev, and see if we need to initialize the\n\t * mixer\n\t */\n\n \tc = bus_space_read_1(iot, sc->sc_ioh3, GUS_BOARD_REV);\n\tif (c != 0xff)\n\t\tsc->sc_revision = c;\n\telse\n\t\tsc->sc_revision = 0;\n\n \tSELECT_GUS_REG(iot, sc->sc_ioh2, GUSREG_RESET);\n \tbus_space_write_1(iot, sc->sc_ioh2, GUS_DATA_HIGH, 0x00);\n\n\tgusreset(sc, GUS_MAX_VOICES); /* initialize all voices */\n\tgusreset(sc, GUS_MIN_VOICES); /* then set to just the ones we use */\n\n\t/*\n\t * Setup the IRQ and DRQ lines in software, using values from\n\t * config file\n\t */\n\n\tm = GUSMASK_LINE_IN|GUSMASK_LINE_OUT;\t\t/* disable all */\n\n\tc = ((unsigned char) gus_irq_map[ia->ia_irq]) | GUSMASK_BOTH_RQ;\n\n\tif (sc->sc_recdrq == sc->sc_drq)\n\t\td = (unsigned char) (gus_drq_map[sc->sc_drq] |\n\t\t\t\tGUSMASK_BOTH_RQ);\n\telse\n\t\td = (unsigned char) (gus_drq_map[sc->sc_drq] |\n\t\t\t\tgus_drq_map[sc->sc_recdrq] << 3);\n\n\t/*\n\t * Program the IRQ and DMA channels on the GUS.  Note that we hardwire\n\t * the GUS to only use one IRQ channel, but we give the user the\n\t * option of using two DMA channels (the other one given by the flags\n\t * option in the config file).  Two DMA channels are needed for full-\n\t * duplex operation.\n\t *\n\t * The order of these operations is very magical.\n\t */\n\n\tdisable_intr();\t\t/* XXX needed? */\n\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_REG_CONTROL, GUS_REG_IRQCTL);\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_MIX_CONTROL, m);\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_IRQCTL_CONTROL, 0x00);\n\tbus_space_write_1(iot, sc->sc_ioh1, 0x0f, 0x00);\n\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_MIX_CONTROL, m);\n\n\t/* magic reset? */\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_DMA_CONTROL, d | 0x80);\n\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_MIX_CONTROL,\n\t    m | GUSMASK_CONTROL_SEL);\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_IRQ_CONTROL, c);\n\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_MIX_CONTROL, m);\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_DMA_CONTROL, d);\n\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_MIX_CONTROL,\n\t    m | GUSMASK_CONTROL_SEL);\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_IRQ_CONTROL, c);\n\n\tbus_space_write_1(iot, sc->sc_ioh2, GUS_VOICE_SELECT, 0x00);\n\n\t/* enable line in, line out.  leave mic disabled. */\n\tbus_space_write_1(iot, sc->sc_ioh1, GUS_MIX_CONTROL,\n\t     (m | GUSMASK_LATCHES) & ~(GUSMASK_LINE_OUT|GUSMASK_LINE_IN));\n\tbus_space_write_1(iot, sc->sc_ioh2, GUS_VOICE_SELECT, 0x00);\n\n\tenable_intr();\n\n\tsc->sc_mixcontrol =\n\t\t(m | GUSMASK_LATCHES) & ~(GUSMASK_LINE_OUT|GUSMASK_LINE_IN);\n\n\tsc->sc_codec.sc_isa = sc->sc_isa;\n\n \tif (sc->sc_revision >= 5 && sc->sc_revision <= 9) {\n \t\tsc->sc_flags |= GUS_MIXER_INSTALLED;\n \t\tgus_init_ics2101(sc);\n\t}\n\tif (sc->sc_revision < 0xa || !gus_init_cs4231(sc)) {\n\t\t/* Not using the CS4231, so create our DMA maps. */\n\t\tif (sc->sc_drq != -1) {\n\t\t\tif (isa_dmamap_create(sc->sc_isa, sc->sc_drq,\n\t\t\t    MAX_ISADMA, BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\t\t\tprintf(\"%s: can't create map for drq %d\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, sc->sc_drq);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (sc->sc_recdrq != -1 && sc->sc_recdrq != sc->sc_drq) {\n\t\t\tif (isa_dmamap_create(sc->sc_isa, sc->sc_recdrq,\n\t\t\t    MAX_ISADMA, BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\t\t\tprintf(\"%s: can't create map for drq %d\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, sc->sc_recdrq);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n \tSELECT_GUS_REG(iot, sc->sc_ioh2, GUSREG_RESET);\n \t/*\n \t * Check to see how much memory we have on this card; see if any\n \t * \"mirroring\" occurs.  We're assuming at least 256K already exists\n \t * on the card; otherwise the initial probe would have failed\n \t */\n\n\tguspoke(iot, sc->sc_ioh2, 0L, 0x00);\n\tfor(i = 1; i < 1024; i++) {\n\t\tu_long loc;\n\n\t\t/*\n\t\t * See if we've run into mirroring yet\n\t\t */\n\n\t\tif (guspeek(iot, sc->sc_ioh2, 0L) != 0)\n\t\t\tbreak;\n\n\t\tloc = i << 10;\n\n\t\tguspoke(iot, sc->sc_ioh2, loc, 0xaa);\n\t\tif (guspeek(iot, sc->sc_ioh2, loc) != 0xaa)\n\t\t\tbreak;\n\t}\n\n\tsc->sc_dsize = i;\n\tsprintf(gus_device.version, \"3.%d\", sc->sc_revision);\n\n\tprintf(\": ver 3.%d, %dKB DRAM, \",\n\t       sc->sc_revision, sc->sc_dsize);\n\tif (HAS_MIXER(sc))\n\t\tprintf(\"ICS2101 mixer, \");\n\tif (HAS_CODEC(sc))\n\t\tprintf(\"%s codec/mixer, \", sc->sc_codec.chip_name);\n\tif (sc->sc_recdrq == sc->sc_drq) {\n\t\tprintf(\"half-duplex\");\n\t} else {\n\t\tprintf(\"full-duplex, record drq %d\", sc->sc_recdrq);\n\t}\n\n\tprintf(\"\\n\");\n\n\t/*\n\t * Setup a default interrupt handler\n\t */\n\n\t/* XXX we shouldn't have to use splgus == splclock, nor should\n\t * we use IPL_CLOCK.\n\t */\n\tsc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,\n\t    IPL_AUDIO, gusintr, sc /* sc->sc_gusdsp */, sc->sc_dev.dv_xname);\n\n\t/*\n\t * Set some default values\n\t * XXX others start with 8kHz mono mulaw\n\t */\n\n\tsc->sc_irate = sc->sc_orate = 44100;\n\tsc->sc_encoding = AUDIO_ENCODING_SLINEAR_LE;\n\tsc->sc_precision = 16;\n\tsc->sc_voc[GUS_VOICE_LEFT].voccntl |= GUSMASK_DATA_SIZE16;\n\tsc->sc_voc[GUS_VOICE_RIGHT].voccntl |= GUSMASK_DATA_SIZE16;\n\tsc->sc_channels = 1;\n\tsc->sc_ogain = 340;\n\tgus_commit_settings(sc);\n\n\t/*\n\t * We always put the left channel full left & right channel\n\t * full right.\n\t * For mono playback, we set up both voices playing the same buffer.\n\t */\n\tbus_space_write_1(iot, sc->sc_ioh2, GUS_VOICE_SELECT,\n\t    (u_char)GUS_VOICE_LEFT);\n\tSELECT_GUS_REG(iot, sc->sc_ioh2, GUSREG_PAN_POS);\n\tbus_space_write_1(iot, sc->sc_ioh2, GUS_DATA_HIGH, GUS_PAN_FULL_LEFT);\n\n\tbus_space_write_1(iot, sc->sc_ioh2, GUS_VOICE_SELECT,\n\t    (u_char)GUS_VOICE_RIGHT);\n\tSELECT_GUS_REG(iot, sc->sc_ioh2, GUSREG_PAN_POS);\n\tbus_space_write_1(iot, sc->sc_ioh2, GUS_DATA_HIGH, GUS_PAN_FULL_RIGHT);\n\n\t/*\n\t * Attach to the generic audio layer\n\t */\n\n\taudio_attach_mi(&gus_hw_if, HAS_CODEC(sc) ? (void *)&sc->sc_codec :\n\t    (void *)sc, &sc->sc_dev);\n}"
  },
  {
    "function_name": "gus_init_ics2101",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "3307-3384",
    "snippet": "void\ngus_init_ics2101(sc)\n\tstruct gus_softc *sc;\n{\n\tstruct ics2101_softc *ic = &sc->sc_mixer;\n\tsc->sc_mixer.sc_iot = sc->sc_iot;\n\tsc->sc_mixer.sc_selio = GUS_MIXER_SELECT;\n\tsc->sc_mixer.sc_selio_ioh = sc->sc_ioh3;\n\tsc->sc_mixer.sc_dataio = GUS_MIXER_DATA;\n\tsc->sc_mixer.sc_dataio_ioh = sc->sc_ioh2;\n\tsc->sc_mixer.sc_flags = (sc->sc_revision == 5) ? ICS_FLIP : 0;\n\n\tics2101_mix_attenuate(ic,\n\t\t\t      GUSMIX_CHAN_MIC,\n\t\t\t      ICSMIX_LEFT,\n\t\t\t      ICSMIX_MIN_ATTN);\n\tics2101_mix_attenuate(ic,\n\t\t\t      GUSMIX_CHAN_MIC,\n\t\t\t      ICSMIX_RIGHT,\n\t\t\t      ICSMIX_MIN_ATTN);\n\t/*\n\t * Start with microphone muted by the mixer...\n\t */\n\tgusics_mic_mute(ic, 1);\n\n\t/* ... and enabled by the GUS master mix control */\n\tgus_mic_ctl(sc, SPKR_ON);\n\n\tics2101_mix_attenuate(ic,\n\t\t\t      GUSMIX_CHAN_LINE,\n\t\t\t      ICSMIX_LEFT,\n\t\t\t      ICSMIX_MIN_ATTN);\n\tics2101_mix_attenuate(ic,\n\t\t\t      GUSMIX_CHAN_LINE,\n\t\t\t      ICSMIX_RIGHT,\n\t\t\t      ICSMIX_MIN_ATTN);\n\n\tics2101_mix_attenuate(ic,\n\t\t\t      GUSMIX_CHAN_CD,\n\t\t\t      ICSMIX_LEFT,\n\t\t\t      ICSMIX_MIN_ATTN);\n\tics2101_mix_attenuate(ic,\n\t\t\t      GUSMIX_CHAN_CD,\n\t\t\t      ICSMIX_RIGHT,\n\t\t\t      ICSMIX_MIN_ATTN);\n\n\tics2101_mix_attenuate(ic,\n\t\t\t      GUSMIX_CHAN_DAC,\n\t\t\t      ICSMIX_LEFT,\n\t\t\t      ICSMIX_MIN_ATTN);\n\tics2101_mix_attenuate(ic,\n\t\t\t      GUSMIX_CHAN_DAC,\n\t\t\t      ICSMIX_RIGHT,\n\t\t\t      ICSMIX_MIN_ATTN);\n\n\tics2101_mix_attenuate(ic,\n\t\t\t      ICSMIX_CHAN_4,\n\t\t\t      ICSMIX_LEFT,\n\t\t\t      ICSMIX_MAX_ATTN);\n\tics2101_mix_attenuate(ic,\n\t\t\t      ICSMIX_CHAN_4,\n\t\t\t      ICSMIX_RIGHT,\n\t\t\t      ICSMIX_MAX_ATTN);\n\n\tics2101_mix_attenuate(ic,\n\t\t\t      GUSMIX_CHAN_MASTER,\n\t\t\t      ICSMIX_LEFT,\n\t\t\t      ICSMIX_MIN_ATTN);\n\tics2101_mix_attenuate(ic,\n\t\t\t      GUSMIX_CHAN_MASTER,\n\t\t\t      ICSMIX_RIGHT,\n\t\t\t      ICSMIX_MIN_ATTN);\n\t/* unmute other stuff: */\n\tgusics_cd_mute(ic, 0);\n\tgusics_dac_mute(ic, 0);\n\tgusics_linein_mute(ic, 0);\n\treturn;\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gusics_linein_mute",
          "args": [
            "ic",
            "0"
          ],
          "line": 3382
        },
        "resolved": true,
        "details": {
          "function_name": "gusics_linein_mute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "2647-2654",
          "snippet": "void\ngusics_linein_mute(ic, mute)\n\tstruct ics2101_softc *ic;\n\tint mute;\n{\n\tics2101_mix_mute(ic, GUSMIX_CHAN_LINE, ICSMIX_LEFT, mute);\n\tics2101_mix_mute(ic, GUSMIX_CHAN_LINE, ICSMIX_RIGHT, mute);\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ngusics_linein_mute(ic, mute)\n\tstruct ics2101_softc *ic;\n\tint mute;\n{\n\tics2101_mix_mute(ic, GUSMIX_CHAN_LINE, ICSMIX_LEFT, mute);\n\tics2101_mix_mute(ic, GUSMIX_CHAN_LINE, ICSMIX_RIGHT, mute);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gusics_dac_mute",
          "args": [
            "ic",
            "0"
          ],
          "line": 3381
        },
        "resolved": true,
        "details": {
          "function_name": "gusics_dac_mute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "2665-2672",
          "snippet": "void\ngusics_dac_mute(ic, mute)\n\tstruct ics2101_softc *ic;\n\tint mute;\n{\n\tics2101_mix_mute(ic, GUSMIX_CHAN_DAC, ICSMIX_LEFT, mute);\n\tics2101_mix_mute(ic, GUSMIX_CHAN_DAC, ICSMIX_RIGHT, mute);\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ngusics_dac_mute(ic, mute)\n\tstruct ics2101_softc *ic;\n\tint mute;\n{\n\tics2101_mix_mute(ic, GUSMIX_CHAN_DAC, ICSMIX_LEFT, mute);\n\tics2101_mix_mute(ic, GUSMIX_CHAN_DAC, ICSMIX_RIGHT, mute);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gusics_cd_mute",
          "args": [
            "ic",
            "0"
          ],
          "line": 3380
        },
        "resolved": true,
        "details": {
          "function_name": "gusics_cd_mute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "2656-2663",
          "snippet": "void\ngusics_cd_mute(ic, mute)\n\tstruct ics2101_softc *ic;\n\tint mute;\n{\n\tics2101_mix_mute(ic, GUSMIX_CHAN_CD, ICSMIX_LEFT, mute);\n\tics2101_mix_mute(ic, GUSMIX_CHAN_CD, ICSMIX_RIGHT, mute);\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ngusics_cd_mute(ic, mute)\n\tstruct ics2101_softc *ic;\n\tint mute;\n{\n\tics2101_mix_mute(ic, GUSMIX_CHAN_CD, ICSMIX_LEFT, mute);\n\tics2101_mix_mute(ic, GUSMIX_CHAN_CD, ICSMIX_RIGHT, mute);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ics2101_mix_attenuate",
          "args": [
            "ic",
            "GUSMIX_CHAN_MASTER",
            "ICSMIX_RIGHT",
            "ICSMIX_MIN_ATTN"
          ],
          "line": 3375
        },
        "resolved": true,
        "details": {
          "function_name": "ics2101_mix_attenuate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ics2101.c",
          "lines": "150-156",
          "snippet": "void\nics2101_mix_attenuate(sc, chan, side, value)\n\tstruct ics2101_softc *sc;\n\tunsigned int chan, side, value;\n{\n    ics2101_mix_doit(sc, chan, side, value, ICS_VALUE);\n}",
          "includes": [
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/pio.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define ICS_VALUE\t0x01"
          ],
          "globals_used": [
            "static void ics2101_mix_doit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/ics2101var.h>\n#include <dev/ic/ics2101reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define ICS_VALUE\t0x01\n\nstatic void ics2101_mix_doit;\n\nvoid\nics2101_mix_attenuate(sc, chan, side, value)\n\tstruct ics2101_softc *sc;\n\tunsigned int chan, side, value;\n{\n    ics2101_mix_doit(sc, chan, side, value, ICS_VALUE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gus_mic_ctl",
          "args": [
            "sc",
            "SPKR_ON"
          ],
          "line": 3333
        },
        "resolved": true,
        "details": {
          "function_name": "gus_mic_ctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "1870-1892",
          "snippet": "int\ngus_mic_ctl(addr, newstate)\n\tvoid * addr;\n\tint newstate;\n{\n\tstruct gus_softc *sc = (struct gus_softc *) addr;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh1 = sc->sc_ioh1;\n\n\t/* Mic bit is normal: 1 enables, 0 disables */\n\tif ((newstate == SPKR_ON) &&\n\t    (sc->sc_mixcontrol & GUSMASK_MIC_IN) == 0) {\n\t\tsc->sc_mixcontrol |= GUSMASK_MIC_IN;\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t}\n\tif ((newstate == SPKR_OFF) &&\n\t    (sc->sc_mixcontrol & GUSMASK_MIC_IN)) {\n\t\tsc->sc_mixcontrol &= ~GUSMASK_MIC_IN;\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngus_mic_ctl(addr, newstate)\n\tvoid * addr;\n\tint newstate;\n{\n\tstruct gus_softc *sc = (struct gus_softc *) addr;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh1 = sc->sc_ioh1;\n\n\t/* Mic bit is normal: 1 enables, 0 disables */\n\tif ((newstate == SPKR_ON) &&\n\t    (sc->sc_mixcontrol & GUSMASK_MIC_IN) == 0) {\n\t\tsc->sc_mixcontrol |= GUSMASK_MIC_IN;\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t}\n\tif ((newstate == SPKR_OFF) &&\n\t    (sc->sc_mixcontrol & GUSMASK_MIC_IN)) {\n\t\tsc->sc_mixcontrol &= ~GUSMASK_MIC_IN;\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gusics_mic_mute",
          "args": [
            "ic",
            "1"
          ],
          "line": 3330
        },
        "resolved": true,
        "details": {
          "function_name": "gusics_mic_mute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "2638-2645",
          "snippet": "void\ngusics_mic_mute(ic, mute)\n\tstruct ics2101_softc *ic;\n\tint mute;\n{\n\tics2101_mix_mute(ic, GUSMIX_CHAN_MIC, ICSMIX_LEFT, mute);\n\tics2101_mix_mute(ic, GUSMIX_CHAN_MIC, ICSMIX_RIGHT, mute);\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ngusics_mic_mute(ic, mute)\n\tstruct ics2101_softc *ic;\n\tint mute;\n{\n\tics2101_mix_mute(ic, GUSMIX_CHAN_MIC, ICSMIX_LEFT, mute);\n\tics2101_mix_mute(ic, GUSMIX_CHAN_MIC, ICSMIX_RIGHT, mute);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ngus_init_ics2101(sc)\n\tstruct gus_softc *sc;\n{\n\tstruct ics2101_softc *ic = &sc->sc_mixer;\n\tsc->sc_mixer.sc_iot = sc->sc_iot;\n\tsc->sc_mixer.sc_selio = GUS_MIXER_SELECT;\n\tsc->sc_mixer.sc_selio_ioh = sc->sc_ioh3;\n\tsc->sc_mixer.sc_dataio = GUS_MIXER_DATA;\n\tsc->sc_mixer.sc_dataio_ioh = sc->sc_ioh2;\n\tsc->sc_mixer.sc_flags = (sc->sc_revision == 5) ? ICS_FLIP : 0;\n\n\tics2101_mix_attenuate(ic,\n\t\t\t      GUSMIX_CHAN_MIC,\n\t\t\t      ICSMIX_LEFT,\n\t\t\t      ICSMIX_MIN_ATTN);\n\tics2101_mix_attenuate(ic,\n\t\t\t      GUSMIX_CHAN_MIC,\n\t\t\t      ICSMIX_RIGHT,\n\t\t\t      ICSMIX_MIN_ATTN);\n\t/*\n\t * Start with microphone muted by the mixer...\n\t */\n\tgusics_mic_mute(ic, 1);\n\n\t/* ... and enabled by the GUS master mix control */\n\tgus_mic_ctl(sc, SPKR_ON);\n\n\tics2101_mix_attenuate(ic,\n\t\t\t      GUSMIX_CHAN_LINE,\n\t\t\t      ICSMIX_LEFT,\n\t\t\t      ICSMIX_MIN_ATTN);\n\tics2101_mix_attenuate(ic,\n\t\t\t      GUSMIX_CHAN_LINE,\n\t\t\t      ICSMIX_RIGHT,\n\t\t\t      ICSMIX_MIN_ATTN);\n\n\tics2101_mix_attenuate(ic,\n\t\t\t      GUSMIX_CHAN_CD,\n\t\t\t      ICSMIX_LEFT,\n\t\t\t      ICSMIX_MIN_ATTN);\n\tics2101_mix_attenuate(ic,\n\t\t\t      GUSMIX_CHAN_CD,\n\t\t\t      ICSMIX_RIGHT,\n\t\t\t      ICSMIX_MIN_ATTN);\n\n\tics2101_mix_attenuate(ic,\n\t\t\t      GUSMIX_CHAN_DAC,\n\t\t\t      ICSMIX_LEFT,\n\t\t\t      ICSMIX_MIN_ATTN);\n\tics2101_mix_attenuate(ic,\n\t\t\t      GUSMIX_CHAN_DAC,\n\t\t\t      ICSMIX_RIGHT,\n\t\t\t      ICSMIX_MIN_ATTN);\n\n\tics2101_mix_attenuate(ic,\n\t\t\t      ICSMIX_CHAN_4,\n\t\t\t      ICSMIX_LEFT,\n\t\t\t      ICSMIX_MAX_ATTN);\n\tics2101_mix_attenuate(ic,\n\t\t\t      ICSMIX_CHAN_4,\n\t\t\t      ICSMIX_RIGHT,\n\t\t\t      ICSMIX_MAX_ATTN);\n\n\tics2101_mix_attenuate(ic,\n\t\t\t      GUSMIX_CHAN_MASTER,\n\t\t\t      ICSMIX_LEFT,\n\t\t\t      ICSMIX_MIN_ATTN);\n\tics2101_mix_attenuate(ic,\n\t\t\t      GUSMIX_CHAN_MASTER,\n\t\t\t      ICSMIX_RIGHT,\n\t\t\t      ICSMIX_MIN_ATTN);\n\t/* unmute other stuff: */\n\tgusics_cd_mute(ic, 0);\n\tgusics_dac_mute(ic, 0);\n\tgusics_linein_mute(ic, 0);\n\treturn;\n}"
  },
  {
    "function_name": "gus_query_encoding",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "3240-3300",
    "snippet": "int\ngus_query_encoding(addr, fp)\n\tvoid *addr;\n\tstruct audio_encoding *fp;\n{\n\tswitch (fp->index) {\n\tcase 0:\n\t\tstrcpy(fp->name, AudioEmulaw);\n\t\tfp->encoding = AUDIO_ENCODING_ULAW;\n\t\tfp->precision = 8;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\tbreak;\n\tcase 1:\n\t\tstrcpy(fp->name, AudioEslinear);\n\t\tfp->encoding = AUDIO_ENCODING_SLINEAR;\n\t\tfp->precision = 8;\n\t\tfp->flags = 0;\n\t\tbreak;\n\tcase 2:\n\t\tstrcpy(fp->name, AudioEslinear_le);\n\t\tfp->encoding = AUDIO_ENCODING_SLINEAR_LE;\n\t\tfp->precision = 16;\n\t\tfp->flags = 0;\n\t\tbreak;\n\tcase 3:\n\t\tstrcpy(fp->name, AudioEulinear);\n\t\tfp->encoding = AUDIO_ENCODING_ULINEAR;\n\t\tfp->precision = 8;\n\t\tfp->flags = 0;\n\t\tbreak;\n\tcase 4:\n\t\tstrcpy(fp->name, AudioEulinear_le);\n\t\tfp->encoding = AUDIO_ENCODING_ULINEAR_LE;\n\t\tfp->precision = 16;\n\t\tfp->flags = 0;\n\t\tbreak;\n\tcase 5:\n\t\tstrcpy(fp->name, AudioEslinear_be);\n\t\tfp->encoding = AUDIO_ENCODING_SLINEAR_BE;\n\t\tfp->precision = 16;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\tbreak;\n\tcase 6:\n\t\tstrcpy(fp->name, AudioEulinear_be);\n\t\tfp->encoding = AUDIO_ENCODING_ULINEAR_BE;\n\t\tfp->precision = 16;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\tbreak;\n\tcase 7:\n\t\tstrcpy(fp->name, AudioEalaw);\n\t\tfp->encoding = AUDIO_ENCODING_ALAW;\n\t\tfp->precision = 8;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\tbreak;\n\n\tdefault:\n\t\treturn(EINVAL);\n\t\t/*NOTREACHED*/\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEalaw"
          ],
          "line": 3289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEulinear_be"
          ],
          "line": 3283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEslinear_be"
          ],
          "line": 3277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEulinear_le"
          ],
          "line": 3271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEulinear"
          ],
          "line": 3265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEslinear_le"
          ],
          "line": 3259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEslinear"
          ],
          "line": 3253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fp->name",
            "AudioEmulaw"
          ],
          "line": 3247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngus_query_encoding(addr, fp)\n\tvoid *addr;\n\tstruct audio_encoding *fp;\n{\n\tswitch (fp->index) {\n\tcase 0:\n\t\tstrcpy(fp->name, AudioEmulaw);\n\t\tfp->encoding = AUDIO_ENCODING_ULAW;\n\t\tfp->precision = 8;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\tbreak;\n\tcase 1:\n\t\tstrcpy(fp->name, AudioEslinear);\n\t\tfp->encoding = AUDIO_ENCODING_SLINEAR;\n\t\tfp->precision = 8;\n\t\tfp->flags = 0;\n\t\tbreak;\n\tcase 2:\n\t\tstrcpy(fp->name, AudioEslinear_le);\n\t\tfp->encoding = AUDIO_ENCODING_SLINEAR_LE;\n\t\tfp->precision = 16;\n\t\tfp->flags = 0;\n\t\tbreak;\n\tcase 3:\n\t\tstrcpy(fp->name, AudioEulinear);\n\t\tfp->encoding = AUDIO_ENCODING_ULINEAR;\n\t\tfp->precision = 8;\n\t\tfp->flags = 0;\n\t\tbreak;\n\tcase 4:\n\t\tstrcpy(fp->name, AudioEulinear_le);\n\t\tfp->encoding = AUDIO_ENCODING_ULINEAR_LE;\n\t\tfp->precision = 16;\n\t\tfp->flags = 0;\n\t\tbreak;\n\tcase 5:\n\t\tstrcpy(fp->name, AudioEslinear_be);\n\t\tfp->encoding = AUDIO_ENCODING_SLINEAR_BE;\n\t\tfp->precision = 16;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\tbreak;\n\tcase 6:\n\t\tstrcpy(fp->name, AudioEulinear_be);\n\t\tfp->encoding = AUDIO_ENCODING_ULINEAR_BE;\n\t\tfp->precision = 16;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\tbreak;\n\tcase 7:\n\t\tstrcpy(fp->name, AudioEalaw);\n\t\tfp->encoding = AUDIO_ENCODING_ALAW;\n\t\tfp->precision = 8;\n\t\tfp->flags = AUDIO_ENCODINGFLAG_EMULATED;\n\t\tbreak;\n\n\tdefault:\n\t\treturn(EINVAL);\n\t\t/*NOTREACHED*/\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "gus_mixer_query_devinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "3094-3238",
    "snippet": "int\ngus_mixer_query_devinfo(addr, dip)\n\tvoid *addr;\n\tmixer_devinfo_t *dip;\n{\n\tstruct gus_softc *sc = addr;\n\n\tDPRINTF((\"gusmax_query_devinfo: index=%d\\n\", dip->index));\n\n\tif (!HAS_MIXER(sc) && dip->index > GUSICS_MASTER_MUTE)\n\t\treturn ENXIO;\n\n\tswitch(dip->index) {\n\n\tcase GUSICS_MIC_IN_LVL:\t/* Microphone */\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->mixer_class = GUSICS_INPUT_CLASS;\n\t\tdip->prev = AUDIO_MIXER_LAST;\n\t\tdip->next = GUSICS_MIC_IN_MUTE;\n\t\tstrcpy(dip->label.name, AudioNmicrophone);\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\tbreak;\n\n\tcase GUSICS_LINE_IN_LVL:\t/* line */\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->mixer_class = GUSICS_INPUT_CLASS;\n\t\tdip->prev = AUDIO_MIXER_LAST;\n\t\tdip->next = GUSICS_LINE_IN_MUTE;\n\t\tstrcpy(dip->label.name, AudioNline);\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\tbreak;\n\n\tcase GUSICS_CD_LVL:\t\t/* cd */\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->mixer_class = GUSICS_INPUT_CLASS;\n\t\tdip->prev = AUDIO_MIXER_LAST;\n\t\tdip->next = GUSICS_CD_MUTE;\n\t\tstrcpy(dip->label.name, AudioNcd);\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\tbreak;\n\n\tcase GUSICS_DAC_LVL:\t\t/*  dacout */\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->mixer_class = GUSICS_INPUT_CLASS;\n\t\tdip->prev = AUDIO_MIXER_LAST;\n\t\tdip->next = GUSICS_DAC_MUTE;\n\t\tstrcpy(dip->label.name, AudioNdac);\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\tbreak;\n\n\tcase GUSICS_MASTER_LVL:\t\t/*  master output */\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->mixer_class = GUSICS_OUTPUT_CLASS;\n\t\tdip->prev = AUDIO_MIXER_LAST;\n\t\tdip->next = GUSICS_MASTER_MUTE;\n\t\tstrcpy(dip->label.name, AudioNmaster);\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\tbreak;\n\n\n\tcase GUSICS_LINE_IN_MUTE:\n\t\tdip->mixer_class = GUSICS_INPUT_CLASS;\n\t\tdip->type = AUDIO_MIXER_ENUM;\n\t\tdip->prev = GUSICS_LINE_IN_LVL;\n\t\tdip->next = AUDIO_MIXER_LAST;\n\t\tgoto mute;\n\t\n\tcase GUSICS_DAC_MUTE:\n\t\tdip->mixer_class = GUSICS_INPUT_CLASS;\n\t\tdip->type = AUDIO_MIXER_ENUM;\n\t\tdip->prev = GUSICS_DAC_LVL;\n\t\tdip->next = AUDIO_MIXER_LAST;\n\t\tgoto mute;\n\n\tcase GUSICS_CD_MUTE:\n\t\tdip->mixer_class = GUSICS_INPUT_CLASS;\n\t\tdip->type = AUDIO_MIXER_ENUM;\n\t\tdip->prev = GUSICS_CD_LVL;\n\t\tdip->next = AUDIO_MIXER_LAST;\n\t\tgoto mute;\n\t\n\tcase GUSICS_MIC_IN_MUTE:\n\t\tdip->mixer_class = GUSICS_INPUT_CLASS;\n\t\tdip->type = AUDIO_MIXER_ENUM;\n\t\tdip->prev = GUSICS_MIC_IN_LVL;\n\t\tdip->next = AUDIO_MIXER_LAST;\n\t\tgoto mute;\n\n\tcase GUSICS_MASTER_MUTE:\n\t\tdip->mixer_class = GUSICS_OUTPUT_CLASS;\n\t\tdip->type = AUDIO_MIXER_ENUM;\n\t\tdip->prev = GUSICS_MASTER_LVL;\n\t\tdip->next = AUDIO_MIXER_LAST;\nmute:\n\t\tstrcpy(dip->label.name, AudioNmute);\n\t\tdip->un.e.num_mem = 2;\n\t\tstrcpy(dip->un.e.member[0].label.name, AudioNoff);\n\t\tdip->un.e.member[0].ord = 0;\n\t\tstrcpy(dip->un.e.member[1].label.name, AudioNon);\n\t\tdip->un.e.member[1].ord = 1;\n\t\tbreak;\n\t\n\tcase GUSICS_RECORD_SOURCE:\n\t\tdip->mixer_class = GUSICS_RECORD_CLASS;\n\t\tdip->type = AUDIO_MIXER_ENUM;\n\t\tdip->prev = dip->next = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNsource);\n\t\tdip->un.e.num_mem = 1;\n\t\tstrcpy(dip->un.e.member[0].label.name, AudioNoutput);\n\t\tdip->un.e.member[0].ord = GUSICS_MASTER_LVL;\n\t\tbreak;\n\n\tcase GUSICS_INPUT_CLASS:\n\t\tdip->type = AUDIO_MIXER_CLASS;\n\t\tdip->mixer_class = GUSICS_INPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioCinputs);\n\t\tbreak;\n\n\tcase GUSICS_OUTPUT_CLASS:\n\t\tdip->type = AUDIO_MIXER_CLASS;\n\t\tdip->mixer_class = GUSICS_OUTPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioCoutputs);\n\t\tbreak;\n\n\tcase GUSICS_RECORD_CLASS:\n\t\tdip->type = AUDIO_MIXER_CLASS;\n\t\tdip->mixer_class = GUSICS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioCrecord);\n\t\tbreak;\n\n\tdefault:\n\t\treturn ENXIO;\n\t/*NOTREACHED*/\n\t}\n\tDPRINTF((\"AUDIO_MIXER_DEVINFO: name=%s\\n\", dip->label.name));\n\treturn 0;\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"AUDIO_MIXER_DEVINFO: name=%s\\n\", dip->label.name)"
          ],
          "line": 3236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioCrecord"
          ],
          "line": 3229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioCoutputs"
          ],
          "line": 3222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioCinputs"
          ],
          "line": 3215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[0].label.name",
            "AudioNoutput"
          ],
          "line": 3207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNsource"
          ],
          "line": 3205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[1].label.name",
            "AudioNon"
          ],
          "line": 3197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[0].label.name",
            "AudioNoff"
          ],
          "line": 3195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNmute"
          ],
          "line": 3193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 3155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNmaster"
          ],
          "line": 3153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 3145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNdac"
          ],
          "line": 3143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 3135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNcd"
          ],
          "line": 3133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 3125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNline"
          ],
          "line": 3123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 3115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNmicrophone"
          ],
          "line": 3113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_MIXER",
          "args": [
            "sc"
          ],
          "line": 3103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"gusmax_query_devinfo: index=%d\\n\", dip->index)"
          ],
          "line": 3101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngus_mixer_query_devinfo(addr, dip)\n\tvoid *addr;\n\tmixer_devinfo_t *dip;\n{\n\tstruct gus_softc *sc = addr;\n\n\tDPRINTF((\"gusmax_query_devinfo: index=%d\\n\", dip->index));\n\n\tif (!HAS_MIXER(sc) && dip->index > GUSICS_MASTER_MUTE)\n\t\treturn ENXIO;\n\n\tswitch(dip->index) {\n\n\tcase GUSICS_MIC_IN_LVL:\t/* Microphone */\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->mixer_class = GUSICS_INPUT_CLASS;\n\t\tdip->prev = AUDIO_MIXER_LAST;\n\t\tdip->next = GUSICS_MIC_IN_MUTE;\n\t\tstrcpy(dip->label.name, AudioNmicrophone);\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\tbreak;\n\n\tcase GUSICS_LINE_IN_LVL:\t/* line */\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->mixer_class = GUSICS_INPUT_CLASS;\n\t\tdip->prev = AUDIO_MIXER_LAST;\n\t\tdip->next = GUSICS_LINE_IN_MUTE;\n\t\tstrcpy(dip->label.name, AudioNline);\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\tbreak;\n\n\tcase GUSICS_CD_LVL:\t\t/* cd */\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->mixer_class = GUSICS_INPUT_CLASS;\n\t\tdip->prev = AUDIO_MIXER_LAST;\n\t\tdip->next = GUSICS_CD_MUTE;\n\t\tstrcpy(dip->label.name, AudioNcd);\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\tbreak;\n\n\tcase GUSICS_DAC_LVL:\t\t/*  dacout */\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->mixer_class = GUSICS_INPUT_CLASS;\n\t\tdip->prev = AUDIO_MIXER_LAST;\n\t\tdip->next = GUSICS_DAC_MUTE;\n\t\tstrcpy(dip->label.name, AudioNdac);\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\tbreak;\n\n\tcase GUSICS_MASTER_LVL:\t\t/*  master output */\n\t\tdip->type = AUDIO_MIXER_VALUE;\n\t\tdip->mixer_class = GUSICS_OUTPUT_CLASS;\n\t\tdip->prev = AUDIO_MIXER_LAST;\n\t\tdip->next = GUSICS_MASTER_MUTE;\n\t\tstrcpy(dip->label.name, AudioNmaster);\n\t\tdip->un.v.num_channels = 2;\n\t\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\t\tbreak;\n\n\n\tcase GUSICS_LINE_IN_MUTE:\n\t\tdip->mixer_class = GUSICS_INPUT_CLASS;\n\t\tdip->type = AUDIO_MIXER_ENUM;\n\t\tdip->prev = GUSICS_LINE_IN_LVL;\n\t\tdip->next = AUDIO_MIXER_LAST;\n\t\tgoto mute;\n\t\n\tcase GUSICS_DAC_MUTE:\n\t\tdip->mixer_class = GUSICS_INPUT_CLASS;\n\t\tdip->type = AUDIO_MIXER_ENUM;\n\t\tdip->prev = GUSICS_DAC_LVL;\n\t\tdip->next = AUDIO_MIXER_LAST;\n\t\tgoto mute;\n\n\tcase GUSICS_CD_MUTE:\n\t\tdip->mixer_class = GUSICS_INPUT_CLASS;\n\t\tdip->type = AUDIO_MIXER_ENUM;\n\t\tdip->prev = GUSICS_CD_LVL;\n\t\tdip->next = AUDIO_MIXER_LAST;\n\t\tgoto mute;\n\t\n\tcase GUSICS_MIC_IN_MUTE:\n\t\tdip->mixer_class = GUSICS_INPUT_CLASS;\n\t\tdip->type = AUDIO_MIXER_ENUM;\n\t\tdip->prev = GUSICS_MIC_IN_LVL;\n\t\tdip->next = AUDIO_MIXER_LAST;\n\t\tgoto mute;\n\n\tcase GUSICS_MASTER_MUTE:\n\t\tdip->mixer_class = GUSICS_OUTPUT_CLASS;\n\t\tdip->type = AUDIO_MIXER_ENUM;\n\t\tdip->prev = GUSICS_MASTER_LVL;\n\t\tdip->next = AUDIO_MIXER_LAST;\nmute:\n\t\tstrcpy(dip->label.name, AudioNmute);\n\t\tdip->un.e.num_mem = 2;\n\t\tstrcpy(dip->un.e.member[0].label.name, AudioNoff);\n\t\tdip->un.e.member[0].ord = 0;\n\t\tstrcpy(dip->un.e.member[1].label.name, AudioNon);\n\t\tdip->un.e.member[1].ord = 1;\n\t\tbreak;\n\t\n\tcase GUSICS_RECORD_SOURCE:\n\t\tdip->mixer_class = GUSICS_RECORD_CLASS;\n\t\tdip->type = AUDIO_MIXER_ENUM;\n\t\tdip->prev = dip->next = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioNsource);\n\t\tdip->un.e.num_mem = 1;\n\t\tstrcpy(dip->un.e.member[0].label.name, AudioNoutput);\n\t\tdip->un.e.member[0].ord = GUSICS_MASTER_LVL;\n\t\tbreak;\n\n\tcase GUSICS_INPUT_CLASS:\n\t\tdip->type = AUDIO_MIXER_CLASS;\n\t\tdip->mixer_class = GUSICS_INPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioCinputs);\n\t\tbreak;\n\n\tcase GUSICS_OUTPUT_CLASS:\n\t\tdip->type = AUDIO_MIXER_CLASS;\n\t\tdip->mixer_class = GUSICS_OUTPUT_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioCoutputs);\n\t\tbreak;\n\n\tcase GUSICS_RECORD_CLASS:\n\t\tdip->type = AUDIO_MIXER_CLASS;\n\t\tdip->mixer_class = GUSICS_RECORD_CLASS;\n\t\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\t\tstrcpy(dip->label.name, AudioCrecord);\n\t\tbreak;\n\n\tdefault:\n\t\treturn ENXIO;\n\t/*NOTREACHED*/\n\t}\n\tDPRINTF((\"AUDIO_MIXER_DEVINFO: name=%s\\n\", dip->label.name));\n\treturn 0;\n}"
  },
  {
    "function_name": "gusmax_mixer_query_devinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "2892-3092",
    "snippet": "int\ngusmax_mixer_query_devinfo(addr, dip)\n\tvoid *addr;\n\tmixer_devinfo_t *dip;\n{\n\tDPRINTF((\"gusmax_query_devinfo: index=%d\\n\", dip->index));\n\n\tswitch(dip->index) {\n#if 0\n    case GUSMAX_MIC_IN_LVL:\t/* Microphone */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_MIC_IN_MUTE;\n\tstrcpy(dip->label.name, AudioNmicrophone);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n#endif\n\n    case GUSMAX_MONO_LVL:\t/* mono/microphone mixer */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_MONO_MUTE;\n\tstrcpy(dip->label.name, AudioNmicrophone);\n\tdip->un.v.num_channels = 1;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_DAC_LVL:\t\t/*  dacout */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_DAC_MUTE;\n\tstrcpy(dip->label.name, AudioNdac);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_LINE_IN_LVL:\t/* line */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_LINE_IN_MUTE;\n\tstrcpy(dip->label.name, AudioNline);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_CD_LVL:\t\t/* cd */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_CD_MUTE;\n\tstrcpy(dip->label.name, AudioNcd);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n\n    case GUSMAX_MONITOR_LVL:\t/* monitor level */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_MONITOR_CLASS;\n\tdip->next = GUSMAX_MONITOR_MUTE;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNmonitor);\n\tdip->un.v.num_channels = 1;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_OUT_LVL:\t\t/* cs4231 output volume: not useful? */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_MONITOR_CLASS;\n\tdip->prev = dip->next = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNoutput);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_SPEAKER_LVL:\t\t/* fake speaker volume */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_MONITOR_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_SPEAKER_MUTE;\n\tstrcpy(dip->label.name, AudioNmaster);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_LINE_IN_MUTE:\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_LINE_IN_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\t\n    case GUSMAX_DAC_MUTE:\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_DAC_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\n    case GUSMAX_CD_MUTE:\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_CD_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\t\n    case GUSMAX_MONO_MUTE:\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_MONO_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\n    case GUSMAX_MONITOR_MUTE:\n\tdip->mixer_class = GUSMAX_OUTPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_MONITOR_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\n    case GUSMAX_SPEAKER_MUTE:\n\tdip->mixer_class = GUSMAX_OUTPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_SPEAKER_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n    mute:\n\tstrcpy(dip->label.name, AudioNmute);\n\tdip->un.e.num_mem = 2;\n\tstrcpy(dip->un.e.member[0].label.name, AudioNoff);\n\tdip->un.e.member[0].ord = 0;\n\tstrcpy(dip->un.e.member[1].label.name, AudioNon);\n\tdip->un.e.member[1].ord = 1;\n\tbreak;\n\t\n    case GUSMAX_REC_LVL:\t/* record level */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_RECORD_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_RECORD_SOURCE;\n\tstrcpy(dip->label.name, AudioNrecord);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_RECORD_SOURCE:\n\tdip->mixer_class = GUSMAX_RECORD_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_REC_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNsource);\n\tdip->un.e.num_mem = 4;\n\tstrcpy(dip->un.e.member[0].label.name, AudioNoutput);\n\tdip->un.e.member[0].ord = DAC_IN_PORT;\n\tstrcpy(dip->un.e.member[1].label.name, AudioNmicrophone);\n\tdip->un.e.member[1].ord = MIC_IN_PORT;\n\tstrcpy(dip->un.e.member[2].label.name, AudioNdac);\n\tdip->un.e.member[2].ord = AUX1_IN_PORT;\n\tstrcpy(dip->un.e.member[3].label.name, AudioNline);\n\tdip->un.e.member[3].ord = LINE_IN_PORT;\n\tbreak;\n\n    case GUSMAX_INPUT_CLASS:\t\t\t/* input class descriptor */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCinputs);\n\tbreak;\n\n    case GUSMAX_OUTPUT_CLASS:\t\t\t/* output class descriptor */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = GUSMAX_OUTPUT_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCoutputs);\n\tbreak;\n\n    case GUSMAX_MONITOR_CLASS:\t\t\t/* monitor class descriptor */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = GUSMAX_MONITOR_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCmonitor);\n\tbreak;\n\t    \n    case GUSMAX_RECORD_CLASS:\t\t\t/* record source class */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = GUSMAX_RECORD_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCrecord);\n\tbreak;\n\n    default:\n\treturn ENXIO;\n\t/*NOTREACHED*/\n    }\n    DPRINTF((\"AUDIO_MIXER_DEVINFO: name=%s\\n\", dip->label.name));\n\treturn 0;\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"AUDIO_MIXER_DEVINFO: name=%s\\n\", dip->label.name)"
          ],
          "line": 3090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioCrecord"
          ],
          "line": 3083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioCmonitor"
          ],
          "line": 3076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioCoutputs"
          ],
          "line": 3069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioCinputs"
          ],
          "line": 3062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[3].label.name",
            "AudioNline"
          ],
          "line": 3054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[2].label.name",
            "AudioNdac"
          ],
          "line": 3052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[1].label.name",
            "AudioNmicrophone"
          ],
          "line": 3050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[0].label.name",
            "AudioNoutput"
          ],
          "line": 3048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNsource"
          ],
          "line": 3046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 3038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNrecord"
          ],
          "line": 3036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[1].label.name",
            "AudioNon"
          ],
          "line": 3027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.e.member[0].label.name",
            "AudioNoff"
          ],
          "line": 3025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNmute"
          ],
          "line": 3023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 2979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNmaster"
          ],
          "line": 2977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 2969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNoutput"
          ],
          "line": 2967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 2960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNmonitor"
          ],
          "line": 2958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 2949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNcd"
          ],
          "line": 2947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 2939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNline"
          ],
          "line": 2937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 2929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNdac"
          ],
          "line": 2927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 2919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNmicrophone"
          ],
          "line": 2917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->un.v.units.name",
            "AudioNvolume"
          ],
          "line": 2908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dip->label.name",
            "AudioNmicrophone"
          ],
          "line": 2906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"gusmax_query_devinfo: index=%d\\n\", dip->index)"
          ],
          "line": 2897
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngusmax_mixer_query_devinfo(addr, dip)\n\tvoid *addr;\n\tmixer_devinfo_t *dip;\n{\n\tDPRINTF((\"gusmax_query_devinfo: index=%d\\n\", dip->index));\n\n\tswitch(dip->index) {\n#if 0\n    case GUSMAX_MIC_IN_LVL:\t/* Microphone */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_MIC_IN_MUTE;\n\tstrcpy(dip->label.name, AudioNmicrophone);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n#endif\n\n    case GUSMAX_MONO_LVL:\t/* mono/microphone mixer */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_MONO_MUTE;\n\tstrcpy(dip->label.name, AudioNmicrophone);\n\tdip->un.v.num_channels = 1;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_DAC_LVL:\t\t/*  dacout */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_DAC_MUTE;\n\tstrcpy(dip->label.name, AudioNdac);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_LINE_IN_LVL:\t/* line */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_LINE_IN_MUTE;\n\tstrcpy(dip->label.name, AudioNline);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_CD_LVL:\t\t/* cd */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_CD_MUTE;\n\tstrcpy(dip->label.name, AudioNcd);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n\n    case GUSMAX_MONITOR_LVL:\t/* monitor level */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_MONITOR_CLASS;\n\tdip->next = GUSMAX_MONITOR_MUTE;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNmonitor);\n\tdip->un.v.num_channels = 1;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_OUT_LVL:\t\t/* cs4231 output volume: not useful? */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_MONITOR_CLASS;\n\tdip->prev = dip->next = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNoutput);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_SPEAKER_LVL:\t\t/* fake speaker volume */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_MONITOR_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_SPEAKER_MUTE;\n\tstrcpy(dip->label.name, AudioNmaster);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_LINE_IN_MUTE:\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_LINE_IN_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\t\n    case GUSMAX_DAC_MUTE:\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_DAC_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\n    case GUSMAX_CD_MUTE:\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_CD_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\t\n    case GUSMAX_MONO_MUTE:\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_MONO_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\n    case GUSMAX_MONITOR_MUTE:\n\tdip->mixer_class = GUSMAX_OUTPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_MONITOR_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tgoto mute;\n\n    case GUSMAX_SPEAKER_MUTE:\n\tdip->mixer_class = GUSMAX_OUTPUT_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_SPEAKER_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n    mute:\n\tstrcpy(dip->label.name, AudioNmute);\n\tdip->un.e.num_mem = 2;\n\tstrcpy(dip->un.e.member[0].label.name, AudioNoff);\n\tdip->un.e.member[0].ord = 0;\n\tstrcpy(dip->un.e.member[1].label.name, AudioNon);\n\tdip->un.e.member[1].ord = 1;\n\tbreak;\n\t\n    case GUSMAX_REC_LVL:\t/* record level */\n\tdip->type = AUDIO_MIXER_VALUE;\n\tdip->mixer_class = GUSMAX_RECORD_CLASS;\n\tdip->prev = AUDIO_MIXER_LAST;\n\tdip->next = GUSMAX_RECORD_SOURCE;\n\tstrcpy(dip->label.name, AudioNrecord);\n\tdip->un.v.num_channels = 2;\n\tstrcpy(dip->un.v.units.name, AudioNvolume);\n\tbreak;\n\n    case GUSMAX_RECORD_SOURCE:\n\tdip->mixer_class = GUSMAX_RECORD_CLASS;\n\tdip->type = AUDIO_MIXER_ENUM;\n\tdip->prev = GUSMAX_REC_LVL;\n\tdip->next = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioNsource);\n\tdip->un.e.num_mem = 4;\n\tstrcpy(dip->un.e.member[0].label.name, AudioNoutput);\n\tdip->un.e.member[0].ord = DAC_IN_PORT;\n\tstrcpy(dip->un.e.member[1].label.name, AudioNmicrophone);\n\tdip->un.e.member[1].ord = MIC_IN_PORT;\n\tstrcpy(dip->un.e.member[2].label.name, AudioNdac);\n\tdip->un.e.member[2].ord = AUX1_IN_PORT;\n\tstrcpy(dip->un.e.member[3].label.name, AudioNline);\n\tdip->un.e.member[3].ord = LINE_IN_PORT;\n\tbreak;\n\n    case GUSMAX_INPUT_CLASS:\t\t\t/* input class descriptor */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = GUSMAX_INPUT_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCinputs);\n\tbreak;\n\n    case GUSMAX_OUTPUT_CLASS:\t\t\t/* output class descriptor */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = GUSMAX_OUTPUT_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCoutputs);\n\tbreak;\n\n    case GUSMAX_MONITOR_CLASS:\t\t\t/* monitor class descriptor */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = GUSMAX_MONITOR_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCmonitor);\n\tbreak;\n\t    \n    case GUSMAX_RECORD_CLASS:\t\t\t/* record source class */\n\tdip->type = AUDIO_MIXER_CLASS;\n\tdip->mixer_class = GUSMAX_RECORD_CLASS;\n\tdip->next = dip->prev = AUDIO_MIXER_LAST;\n\tstrcpy(dip->label.name, AudioCrecord);\n\tbreak;\n\n    default:\n\treturn ENXIO;\n\t/*NOTREACHED*/\n    }\n    DPRINTF((\"AUDIO_MIXER_DEVINFO: name=%s\\n\", dip->label.name));\n\treturn 0;\n}"
  },
  {
    "function_name": "gusmax_get_props",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "2884-2890",
    "snippet": "int\ngusmax_get_props(addr)\n\tvoid *addr;\n{\n\tstruct ad1848_softc *ac = addr;\n\treturn gus_get_props(ac->parent);\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gus_get_props",
          "args": [
            "ac->parent"
          ],
          "line": 2889
        },
        "resolved": true,
        "details": {
          "function_name": "gus_get_props",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "2875-2882",
          "snippet": "int\ngus_get_props(addr)\n\tvoid *addr;\n{\n\tstruct gus_softc *sc = addr;\n\treturn AUDIO_PROP_MMAP |\n\t\t(sc->sc_recdrq == sc->sc_drq ? 0 : AUDIO_PROP_FULLDUPLEX);\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngus_get_props(addr)\n\tvoid *addr;\n{\n\tstruct gus_softc *sc = addr;\n\treturn AUDIO_PROP_MMAP |\n\t\t(sc->sc_recdrq == sc->sc_drq ? 0 : AUDIO_PROP_FULLDUPLEX);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngusmax_get_props(addr)\n\tvoid *addr;\n{\n\tstruct ad1848_softc *ac = addr;\n\treturn gus_get_props(ac->parent);\n}"
  },
  {
    "function_name": "gus_get_props",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "2875-2882",
    "snippet": "int\ngus_get_props(addr)\n\tvoid *addr;\n{\n\tstruct gus_softc *sc = addr;\n\treturn AUDIO_PROP_MMAP |\n\t\t(sc->sc_recdrq == sc->sc_drq ? 0 : AUDIO_PROP_FULLDUPLEX);\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngus_get_props(addr)\n\tvoid *addr;\n{\n\tstruct gus_softc *sc = addr;\n\treturn AUDIO_PROP_MMAP |\n\t\t(sc->sc_recdrq == sc->sc_drq ? 0 : AUDIO_PROP_FULLDUPLEX);\n}"
  },
  {
    "function_name": "gus_mixer_set_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "2715-2873",
    "snippet": "int\ngus_mixer_set_port(addr, cp)\n\tvoid *addr;\n\tmixer_ctrl_t *cp;\n{\n\tstruct gus_softc *sc = addr;\n\tstruct ics2101_softc *ic = &sc->sc_mixer;\n\tstruct ad1848_volume vol;\n\tint error = EINVAL;\n\n\tDPRINTF((\"gus_mixer_set_port: dev=%d type=%d\\n\", cp->dev, cp->type));\n\n\tif (!HAS_MIXER(sc) && cp->dev > GUSICS_MASTER_MUTE)\n\t\treturn ENXIO;\n    \n\tswitch (cp->dev) {\n\n\tcase GUSICS_MIC_IN_MUTE:\t/* Microphone */\n\t\tif (cp->type == AUDIO_MIXER_ENUM) {\n\t\t\tDPRINTF((\"mic mute %d\\n\", cp->un.ord));\n\t\t\tif (HAS_MIXER(sc)) {\n\t\t\t\tgusics_mic_mute(ic, cp->un.ord);\n\t\t\t}\n\t\t\tgus_mic_ctl(sc, cp->un.ord ? SPKR_OFF : SPKR_ON);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tcase GUSICS_LINE_IN_MUTE:\n\t\tif (cp->type == AUDIO_MIXER_ENUM) {\n\t\t\tDPRINTF((\"linein mute %d\\n\", cp->un.ord));\n\t\t\tif (HAS_MIXER(sc)) {\n\t\t\t\tgusics_linein_mute(ic, cp->un.ord);\n\t\t\t}\n\t\t\tgus_linein_ctl(sc, cp->un.ord ? SPKR_OFF : SPKR_ON);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tcase GUSICS_MASTER_MUTE:\n\t\tif (cp->type == AUDIO_MIXER_ENUM) {\n\t\t\tDPRINTF((\"master mute %d\\n\", cp->un.ord));\n\t\t\tif (HAS_MIXER(sc)) {\n\t\t\t\tgusics_master_mute(ic, cp->un.ord);\n\t\t\t}\n\t\t\tgus_speaker_ctl(sc, cp->un.ord ? SPKR_OFF : SPKR_ON);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tcase GUSICS_DAC_MUTE:\n\t\tif (cp->type == AUDIO_MIXER_ENUM) {\n\t\t\tgusics_dac_mute(ic, cp->un.ord);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tcase GUSICS_CD_MUTE:\n\t\tif (cp->type == AUDIO_MIXER_ENUM) {\n\t\t\tgusics_cd_mute(ic, cp->un.ord);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tcase GUSICS_MASTER_LVL:\n\t\tif (cp->type == AUDIO_MIXER_VALUE) {\n\t\t\tif (ad1848_to_vol(cp, &vol)) {\n\t\t\t\tics2101_mix_attenuate(ic,\n\t\t\t\t\t\t      GUSMIX_CHAN_MASTER,\n\t\t\t\t\t\t      ICSMIX_LEFT,\n\t\t\t\t\t\t      vol.left);\n\t\t\t\tics2101_mix_attenuate(ic,\n\t\t\t\t\t\t      GUSMIX_CHAN_MASTER,\n\t\t\t\t\t\t      ICSMIX_RIGHT,\n\t\t\t\t\t\t      vol.right);\n\t\t\t\terror = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase GUSICS_MIC_IN_LVL:\t/* Microphone */\n\t\tif (cp->type == AUDIO_MIXER_VALUE) {\n\t\t\tif (ad1848_to_vol(cp, &vol)) {\n\t\t\t\tics2101_mix_attenuate(ic,\n\t\t\t\t\t\t      GUSMIX_CHAN_MIC,\n\t\t\t\t\t\t      ICSMIX_LEFT,\n\t\t\t\t\t\t      vol.left);\n\t\t\t\tics2101_mix_attenuate(ic,\n\t\t\t\t\t\t      GUSMIX_CHAN_MIC,\n\t\t\t\t\t\t      ICSMIX_RIGHT,\n\t\t\t\t\t\t      vol.right);\n\t\t\t\terror = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\n\tcase GUSICS_LINE_IN_LVL:\t/* line in */\n\t\tif (cp->type == AUDIO_MIXER_VALUE) {\n\t\t\tif (ad1848_to_vol(cp, &vol)) {\n\t\t\t\tics2101_mix_attenuate(ic,\n\t\t\t\t\t\t      GUSMIX_CHAN_LINE,\n\t\t\t\t\t\t      ICSMIX_LEFT,\n\t\t\t\t\t\t      vol.left);\n\t\t\t\tics2101_mix_attenuate(ic,\n\t\t\t\t\t\t      GUSMIX_CHAN_LINE,\n\t\t\t\t\t\t      ICSMIX_RIGHT,\n\t\t\t\t\t\t      vol.right);\n\t\t\t\terror = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\n\tcase GUSICS_CD_LVL:\n\t\tif (cp->type == AUDIO_MIXER_VALUE) {\n\t\t\tif (ad1848_to_vol(cp, &vol)) {\n\t\t\t\tics2101_mix_attenuate(ic,\n\t\t\t\t\t\t      GUSMIX_CHAN_CD,\n\t\t\t\t\t\t      ICSMIX_LEFT,\n\t\t\t\t\t\t      vol.left);\n\t\t\t\tics2101_mix_attenuate(ic,\n\t\t\t\t\t\t      GUSMIX_CHAN_CD,\n\t\t\t\t\t\t      ICSMIX_RIGHT,\n\t\t\t\t\t\t      vol.right);\n\t\t\t\terror = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase GUSICS_DAC_LVL:\t\t/* dac out */\n\t\tif (cp->type == AUDIO_MIXER_VALUE) {\n\t\t\tif (ad1848_to_vol(cp, &vol)) {\n\t\t\t\tics2101_mix_attenuate(ic,\n\t\t\t\t\t\t      GUSMIX_CHAN_DAC,\n\t\t\t\t\t\t      ICSMIX_LEFT,\n\t\t\t\t\t\t      vol.left);\n\t\t\t\tics2101_mix_attenuate(ic,\n\t\t\t\t\t\t      GUSMIX_CHAN_DAC,\n\t\t\t\t\t\t      ICSMIX_RIGHT,\n\t\t\t\t\t\t      vol.right);\n\t\t\t\terror = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\n\tcase GUSICS_RECORD_SOURCE:\n\t\tif (cp->type == AUDIO_MIXER_ENUM && cp->un.ord == 0) {\n\t\t\t/* Can't set anything else useful, sigh. */\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn ENXIO;\n\t    /*NOTREACHED*/\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ics2101_mix_attenuate",
          "args": [
            "ic",
            "GUSMIX_CHAN_DAC",
            "ICSMIX_RIGHT",
            "vol.right"
          ],
          "line": 2851
        },
        "resolved": true,
        "details": {
          "function_name": "ics2101_mix_attenuate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ics2101.c",
          "lines": "150-156",
          "snippet": "void\nics2101_mix_attenuate(sc, chan, side, value)\n\tstruct ics2101_softc *sc;\n\tunsigned int chan, side, value;\n{\n    ics2101_mix_doit(sc, chan, side, value, ICS_VALUE);\n}",
          "includes": [
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/pio.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define ICS_VALUE\t0x01"
          ],
          "globals_used": [
            "static void ics2101_mix_doit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/ics2101var.h>\n#include <dev/ic/ics2101reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define ICS_VALUE\t0x01\n\nstatic void ics2101_mix_doit;\n\nvoid\nics2101_mix_attenuate(sc, chan, side, value)\n\tstruct ics2101_softc *sc;\n\tunsigned int chan, side, value;\n{\n    ics2101_mix_doit(sc, chan, side, value, ICS_VALUE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad1848_to_vol",
          "args": [
            "cp",
            "&vol"
          ],
          "line": 2846
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_to_vol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848var.h",
          "lines": "145-160",
          "snippet": "static __inline int\nad1848_to_vol(cp, vol)\n\tmixer_ctrl_t *cp;\n\tstruct ad1848_volume *vol;\n{\n\tif (cp->un.value.num_channels == 1) {\n\t\tvol->left = vol->right = cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];\n\t\treturn(1);\n\t}\n\telse if (cp->un.value.num_channels == 2) {\n\t\tvol->left  = cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];\n\t\tvol->right = cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];\n\t\treturn(1);\n\t}\n\treturn(0);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static __inline int\nad1848_to_vol(cp, vol)\n\tmixer_ctrl_t *cp;\n\tstruct ad1848_volume *vol;\n{\n\tif (cp->un.value.num_channels == 1) {\n\t\tvol->left = vol->right = cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];\n\t\treturn(1);\n\t}\n\telse if (cp->un.value.num_channels == 2) {\n\t\tvol->left  = cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];\n\t\tvol->right = cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];\n\t\treturn(1);\n\t}\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gusics_cd_mute",
          "args": [
            "ic",
            "cp->un.ord"
          ],
          "line": 2774
        },
        "resolved": true,
        "details": {
          "function_name": "gusics_cd_mute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "2656-2663",
          "snippet": "void\ngusics_cd_mute(ic, mute)\n\tstruct ics2101_softc *ic;\n\tint mute;\n{\n\tics2101_mix_mute(ic, GUSMIX_CHAN_CD, ICSMIX_LEFT, mute);\n\tics2101_mix_mute(ic, GUSMIX_CHAN_CD, ICSMIX_RIGHT, mute);\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ngusics_cd_mute(ic, mute)\n\tstruct ics2101_softc *ic;\n\tint mute;\n{\n\tics2101_mix_mute(ic, GUSMIX_CHAN_CD, ICSMIX_LEFT, mute);\n\tics2101_mix_mute(ic, GUSMIX_CHAN_CD, ICSMIX_RIGHT, mute);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gusics_dac_mute",
          "args": [
            "ic",
            "cp->un.ord"
          ],
          "line": 2767
        },
        "resolved": true,
        "details": {
          "function_name": "gusics_dac_mute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "2665-2672",
          "snippet": "void\ngusics_dac_mute(ic, mute)\n\tstruct ics2101_softc *ic;\n\tint mute;\n{\n\tics2101_mix_mute(ic, GUSMIX_CHAN_DAC, ICSMIX_LEFT, mute);\n\tics2101_mix_mute(ic, GUSMIX_CHAN_DAC, ICSMIX_RIGHT, mute);\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ngusics_dac_mute(ic, mute)\n\tstruct ics2101_softc *ic;\n\tint mute;\n{\n\tics2101_mix_mute(ic, GUSMIX_CHAN_DAC, ICSMIX_LEFT, mute);\n\tics2101_mix_mute(ic, GUSMIX_CHAN_DAC, ICSMIX_RIGHT, mute);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gus_speaker_ctl",
          "args": [
            "sc",
            "cp->un.ord ? SPKR_OFF : SPKR_ON"
          ],
          "line": 2760
        },
        "resolved": true,
        "details": {
          "function_name": "gus_speaker_ctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "1822-1844",
          "snippet": "int\ngus_speaker_ctl(addr, newstate)\n\tvoid * addr;\n\tint newstate;\n{\n\tstruct gus_softc *sc = (struct gus_softc *) addr;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh1 = sc->sc_ioh1;\n\n\t/* Line out bit is flipped: 0 enables, 1 disables */\n\tif ((newstate == SPKR_ON) &&\n\t    (sc->sc_mixcontrol & GUSMASK_LINE_OUT)) {\n\t\tsc->sc_mixcontrol &= ~GUSMASK_LINE_OUT;\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t}\n\tif ((newstate == SPKR_OFF) &&\n\t    (sc->sc_mixcontrol & GUSMASK_LINE_OUT) == 0) {\n\t\tsc->sc_mixcontrol |= GUSMASK_LINE_OUT;\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngus_speaker_ctl(addr, newstate)\n\tvoid * addr;\n\tint newstate;\n{\n\tstruct gus_softc *sc = (struct gus_softc *) addr;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh1 = sc->sc_ioh1;\n\n\t/* Line out bit is flipped: 0 enables, 1 disables */\n\tif ((newstate == SPKR_ON) &&\n\t    (sc->sc_mixcontrol & GUSMASK_LINE_OUT)) {\n\t\tsc->sc_mixcontrol &= ~GUSMASK_LINE_OUT;\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t}\n\tif ((newstate == SPKR_OFF) &&\n\t    (sc->sc_mixcontrol & GUSMASK_LINE_OUT) == 0) {\n\t\tsc->sc_mixcontrol |= GUSMASK_LINE_OUT;\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gusics_master_mute",
          "args": [
            "ic",
            "cp->un.ord"
          ],
          "line": 2758
        },
        "resolved": true,
        "details": {
          "function_name": "gusics_master_mute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "2629-2636",
          "snippet": "void\ngusics_master_mute(ic, mute)\n\tstruct ics2101_softc *ic;\n\tint mute;\n{\n\tics2101_mix_mute(ic, GUSMIX_CHAN_MASTER, ICSMIX_LEFT, mute);\n\tics2101_mix_mute(ic, GUSMIX_CHAN_MASTER, ICSMIX_RIGHT, mute);\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ngusics_master_mute(ic, mute)\n\tstruct ics2101_softc *ic;\n\tint mute;\n{\n\tics2101_mix_mute(ic, GUSMIX_CHAN_MASTER, ICSMIX_LEFT, mute);\n\tics2101_mix_mute(ic, GUSMIX_CHAN_MASTER, ICSMIX_RIGHT, mute);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HAS_MIXER",
          "args": [
            "sc"
          ],
          "line": 2757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"master mute %d\\n\", cp->un.ord)"
          ],
          "line": 2756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gus_linein_ctl",
          "args": [
            "sc",
            "cp->un.ord ? SPKR_OFF : SPKR_ON"
          ],
          "line": 2749
        },
        "resolved": true,
        "details": {
          "function_name": "gus_linein_ctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "1846-1868",
          "snippet": "int\ngus_linein_ctl(addr, newstate)\n\tvoid * addr;\n\tint newstate;\n{\n\tstruct gus_softc *sc = (struct gus_softc *) addr;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh1 = sc->sc_ioh1;\n\n\t/* Line in bit is flipped: 0 enables, 1 disables */\n\tif ((newstate == SPKR_ON) &&\n\t    (sc->sc_mixcontrol & GUSMASK_LINE_IN)) {\n\t\tsc->sc_mixcontrol &= ~GUSMASK_LINE_IN;\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t}\n\tif ((newstate == SPKR_OFF) &&\n\t    (sc->sc_mixcontrol & GUSMASK_LINE_IN) == 0) {\n\t\tsc->sc_mixcontrol |= GUSMASK_LINE_IN;\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngus_linein_ctl(addr, newstate)\n\tvoid * addr;\n\tint newstate;\n{\n\tstruct gus_softc *sc = (struct gus_softc *) addr;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh1 = sc->sc_ioh1;\n\n\t/* Line in bit is flipped: 0 enables, 1 disables */\n\tif ((newstate == SPKR_ON) &&\n\t    (sc->sc_mixcontrol & GUSMASK_LINE_IN)) {\n\t\tsc->sc_mixcontrol &= ~GUSMASK_LINE_IN;\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t}\n\tif ((newstate == SPKR_OFF) &&\n\t    (sc->sc_mixcontrol & GUSMASK_LINE_IN) == 0) {\n\t\tsc->sc_mixcontrol |= GUSMASK_LINE_IN;\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gusics_linein_mute",
          "args": [
            "ic",
            "cp->un.ord"
          ],
          "line": 2747
        },
        "resolved": true,
        "details": {
          "function_name": "gusics_linein_mute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "2647-2654",
          "snippet": "void\ngusics_linein_mute(ic, mute)\n\tstruct ics2101_softc *ic;\n\tint mute;\n{\n\tics2101_mix_mute(ic, GUSMIX_CHAN_LINE, ICSMIX_LEFT, mute);\n\tics2101_mix_mute(ic, GUSMIX_CHAN_LINE, ICSMIX_RIGHT, mute);\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ngusics_linein_mute(ic, mute)\n\tstruct ics2101_softc *ic;\n\tint mute;\n{\n\tics2101_mix_mute(ic, GUSMIX_CHAN_LINE, ICSMIX_LEFT, mute);\n\tics2101_mix_mute(ic, GUSMIX_CHAN_LINE, ICSMIX_RIGHT, mute);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HAS_MIXER",
          "args": [
            "sc"
          ],
          "line": 2746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"linein mute %d\\n\", cp->un.ord)"
          ],
          "line": 2745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gus_mic_ctl",
          "args": [
            "sc",
            "cp->un.ord ? SPKR_OFF : SPKR_ON"
          ],
          "line": 2738
        },
        "resolved": true,
        "details": {
          "function_name": "gus_mic_ctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "1870-1892",
          "snippet": "int\ngus_mic_ctl(addr, newstate)\n\tvoid * addr;\n\tint newstate;\n{\n\tstruct gus_softc *sc = (struct gus_softc *) addr;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh1 = sc->sc_ioh1;\n\n\t/* Mic bit is normal: 1 enables, 0 disables */\n\tif ((newstate == SPKR_ON) &&\n\t    (sc->sc_mixcontrol & GUSMASK_MIC_IN) == 0) {\n\t\tsc->sc_mixcontrol |= GUSMASK_MIC_IN;\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t}\n\tif ((newstate == SPKR_OFF) &&\n\t    (sc->sc_mixcontrol & GUSMASK_MIC_IN)) {\n\t\tsc->sc_mixcontrol &= ~GUSMASK_MIC_IN;\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngus_mic_ctl(addr, newstate)\n\tvoid * addr;\n\tint newstate;\n{\n\tstruct gus_softc *sc = (struct gus_softc *) addr;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh1 = sc->sc_ioh1;\n\n\t/* Mic bit is normal: 1 enables, 0 disables */\n\tif ((newstate == SPKR_ON) &&\n\t    (sc->sc_mixcontrol & GUSMASK_MIC_IN) == 0) {\n\t\tsc->sc_mixcontrol |= GUSMASK_MIC_IN;\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t}\n\tif ((newstate == SPKR_OFF) &&\n\t    (sc->sc_mixcontrol & GUSMASK_MIC_IN)) {\n\t\tsc->sc_mixcontrol &= ~GUSMASK_MIC_IN;\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gusics_mic_mute",
          "args": [
            "ic",
            "cp->un.ord"
          ],
          "line": 2736
        },
        "resolved": true,
        "details": {
          "function_name": "gusics_mic_mute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "2638-2645",
          "snippet": "void\ngusics_mic_mute(ic, mute)\n\tstruct ics2101_softc *ic;\n\tint mute;\n{\n\tics2101_mix_mute(ic, GUSMIX_CHAN_MIC, ICSMIX_LEFT, mute);\n\tics2101_mix_mute(ic, GUSMIX_CHAN_MIC, ICSMIX_RIGHT, mute);\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ngusics_mic_mute(ic, mute)\n\tstruct ics2101_softc *ic;\n\tint mute;\n{\n\tics2101_mix_mute(ic, GUSMIX_CHAN_MIC, ICSMIX_LEFT, mute);\n\tics2101_mix_mute(ic, GUSMIX_CHAN_MIC, ICSMIX_RIGHT, mute);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HAS_MIXER",
          "args": [
            "sc"
          ],
          "line": 2735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"mic mute %d\\n\", cp->un.ord)"
          ],
          "line": 2734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_MIXER",
          "args": [
            "sc"
          ],
          "line": 2727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"gus_mixer_set_port: dev=%d type=%d\\n\", cp->dev, cp->type)"
          ],
          "line": 2725
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngus_mixer_set_port(addr, cp)\n\tvoid *addr;\n\tmixer_ctrl_t *cp;\n{\n\tstruct gus_softc *sc = addr;\n\tstruct ics2101_softc *ic = &sc->sc_mixer;\n\tstruct ad1848_volume vol;\n\tint error = EINVAL;\n\n\tDPRINTF((\"gus_mixer_set_port: dev=%d type=%d\\n\", cp->dev, cp->type));\n\n\tif (!HAS_MIXER(sc) && cp->dev > GUSICS_MASTER_MUTE)\n\t\treturn ENXIO;\n    \n\tswitch (cp->dev) {\n\n\tcase GUSICS_MIC_IN_MUTE:\t/* Microphone */\n\t\tif (cp->type == AUDIO_MIXER_ENUM) {\n\t\t\tDPRINTF((\"mic mute %d\\n\", cp->un.ord));\n\t\t\tif (HAS_MIXER(sc)) {\n\t\t\t\tgusics_mic_mute(ic, cp->un.ord);\n\t\t\t}\n\t\t\tgus_mic_ctl(sc, cp->un.ord ? SPKR_OFF : SPKR_ON);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tcase GUSICS_LINE_IN_MUTE:\n\t\tif (cp->type == AUDIO_MIXER_ENUM) {\n\t\t\tDPRINTF((\"linein mute %d\\n\", cp->un.ord));\n\t\t\tif (HAS_MIXER(sc)) {\n\t\t\t\tgusics_linein_mute(ic, cp->un.ord);\n\t\t\t}\n\t\t\tgus_linein_ctl(sc, cp->un.ord ? SPKR_OFF : SPKR_ON);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tcase GUSICS_MASTER_MUTE:\n\t\tif (cp->type == AUDIO_MIXER_ENUM) {\n\t\t\tDPRINTF((\"master mute %d\\n\", cp->un.ord));\n\t\t\tif (HAS_MIXER(sc)) {\n\t\t\t\tgusics_master_mute(ic, cp->un.ord);\n\t\t\t}\n\t\t\tgus_speaker_ctl(sc, cp->un.ord ? SPKR_OFF : SPKR_ON);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tcase GUSICS_DAC_MUTE:\n\t\tif (cp->type == AUDIO_MIXER_ENUM) {\n\t\t\tgusics_dac_mute(ic, cp->un.ord);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tcase GUSICS_CD_MUTE:\n\t\tif (cp->type == AUDIO_MIXER_ENUM) {\n\t\t\tgusics_cd_mute(ic, cp->un.ord);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tcase GUSICS_MASTER_LVL:\n\t\tif (cp->type == AUDIO_MIXER_VALUE) {\n\t\t\tif (ad1848_to_vol(cp, &vol)) {\n\t\t\t\tics2101_mix_attenuate(ic,\n\t\t\t\t\t\t      GUSMIX_CHAN_MASTER,\n\t\t\t\t\t\t      ICSMIX_LEFT,\n\t\t\t\t\t\t      vol.left);\n\t\t\t\tics2101_mix_attenuate(ic,\n\t\t\t\t\t\t      GUSMIX_CHAN_MASTER,\n\t\t\t\t\t\t      ICSMIX_RIGHT,\n\t\t\t\t\t\t      vol.right);\n\t\t\t\terror = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase GUSICS_MIC_IN_LVL:\t/* Microphone */\n\t\tif (cp->type == AUDIO_MIXER_VALUE) {\n\t\t\tif (ad1848_to_vol(cp, &vol)) {\n\t\t\t\tics2101_mix_attenuate(ic,\n\t\t\t\t\t\t      GUSMIX_CHAN_MIC,\n\t\t\t\t\t\t      ICSMIX_LEFT,\n\t\t\t\t\t\t      vol.left);\n\t\t\t\tics2101_mix_attenuate(ic,\n\t\t\t\t\t\t      GUSMIX_CHAN_MIC,\n\t\t\t\t\t\t      ICSMIX_RIGHT,\n\t\t\t\t\t\t      vol.right);\n\t\t\t\terror = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\n\tcase GUSICS_LINE_IN_LVL:\t/* line in */\n\t\tif (cp->type == AUDIO_MIXER_VALUE) {\n\t\t\tif (ad1848_to_vol(cp, &vol)) {\n\t\t\t\tics2101_mix_attenuate(ic,\n\t\t\t\t\t\t      GUSMIX_CHAN_LINE,\n\t\t\t\t\t\t      ICSMIX_LEFT,\n\t\t\t\t\t\t      vol.left);\n\t\t\t\tics2101_mix_attenuate(ic,\n\t\t\t\t\t\t      GUSMIX_CHAN_LINE,\n\t\t\t\t\t\t      ICSMIX_RIGHT,\n\t\t\t\t\t\t      vol.right);\n\t\t\t\terror = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\n\tcase GUSICS_CD_LVL:\n\t\tif (cp->type == AUDIO_MIXER_VALUE) {\n\t\t\tif (ad1848_to_vol(cp, &vol)) {\n\t\t\t\tics2101_mix_attenuate(ic,\n\t\t\t\t\t\t      GUSMIX_CHAN_CD,\n\t\t\t\t\t\t      ICSMIX_LEFT,\n\t\t\t\t\t\t      vol.left);\n\t\t\t\tics2101_mix_attenuate(ic,\n\t\t\t\t\t\t      GUSMIX_CHAN_CD,\n\t\t\t\t\t\t      ICSMIX_RIGHT,\n\t\t\t\t\t\t      vol.right);\n\t\t\t\terror = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase GUSICS_DAC_LVL:\t\t/* dac out */\n\t\tif (cp->type == AUDIO_MIXER_VALUE) {\n\t\t\tif (ad1848_to_vol(cp, &vol)) {\n\t\t\t\tics2101_mix_attenuate(ic,\n\t\t\t\t\t\t      GUSMIX_CHAN_DAC,\n\t\t\t\t\t\t      ICSMIX_LEFT,\n\t\t\t\t\t\t      vol.left);\n\t\t\t\tics2101_mix_attenuate(ic,\n\t\t\t\t\t\t      GUSMIX_CHAN_DAC,\n\t\t\t\t\t\t      ICSMIX_RIGHT,\n\t\t\t\t\t\t      vol.right);\n\t\t\t\terror = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\n\tcase GUSICS_RECORD_SOURCE:\n\t\tif (cp->type == AUDIO_MIXER_ENUM && cp->un.ord == 0) {\n\t\t\t/* Can't set anything else useful, sigh. */\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn ENXIO;\n\t    /*NOTREACHED*/\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "gusmax_mixer_set_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "2674-2713",
    "snippet": "int\ngusmax_mixer_set_port(addr, cp)\n\tvoid *addr;\n\tmixer_ctrl_t *cp;\n{\n\tstruct ad1848_softc *ac = addr;\n\tstruct gus_softc *sc = ac->parent;\n\tstruct ad1848_volume vol;\n\tint error = ad1848_mixer_set_port(ac, gusmapping, nummap, cp);\n    \n\tif (error != ENXIO)\n\t  return (error);\n\n\tDPRINTF((\"gusmax_mixer_set_port: dev=%d type=%d\\n\", cp->dev, cp->type));\n\n\tswitch (cp->dev) {\n\tcase GUSMAX_SPEAKER_LVL:\n\t\tif (cp->type == AUDIO_MIXER_VALUE &&\n\t\t    cp->un.value.num_channels == 1) {\n\t\t\tif (ad1848_to_vol(cp, &vol)) {\n\t\t\t\tgus_speaker_ctl(sc, vol.left > AUDIO_MIN_GAIN ?\n\t\t\t\t\t\tSPKR_ON : SPKR_OFF);\n\t\t\t\terror = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase GUSMAX_SPEAKER_MUTE:\n\t\tif (cp->type == AUDIO_MIXER_ENUM) {\n\t\t\tgus_speaker_ctl(sc, cp->un.ord ? SPKR_OFF : SPKR_ON);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn ENXIO;\n\t    /*NOTREACHED*/\n    }\n    return error;\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ad1848_devmap_t gusmapping[] = {\n  {GUSMAX_DAC_LVL, AD1848_KIND_LVL, AD1848_AUX1_CHANNEL},\n  {GUSMAX_LINE_IN_LVL, AD1848_KIND_LVL, AD1848_LINE_CHANNEL},\n  {GUSMAX_MONO_LVL, AD1848_KIND_LVL, AD1848_MONO_CHANNEL},\n  {GUSMAX_CD_LVL, AD1848_KIND_LVL, AD1848_AUX2_CHANNEL},\n  {GUSMAX_MONITOR_LVL, AD1848_KIND_LVL, AD1848_MONITOR_CHANNEL},\n  {GUSMAX_OUT_LVL, AD1848_KIND_LVL, AD1848_DAC_CHANNEL},\n  {GUSMAX_DAC_MUTE, AD1848_KIND_MUTE, AD1848_AUX1_CHANNEL},\n  {GUSMAX_LINE_IN_MUTE, AD1848_KIND_MUTE, AD1848_LINE_CHANNEL},\n  {GUSMAX_MONO_MUTE, AD1848_KIND_MUTE, AD1848_MONO_CHANNEL},\n  {GUSMAX_CD_MUTE, AD1848_KIND_MUTE, AD1848_AUX2_CHANNEL},\n  {GUSMAX_MONITOR_MUTE, AD1848_KIND_MUTE, AD1848_MONITOR_CHANNEL},\n  {GUSMAX_REC_LVL, AD1848_KIND_RECORDGAIN, -1},\n  {GUSMAX_RECORD_SOURCE, AD1848_KIND_RECORDSOURCE, -1}\n};",
      "int nummap = sizeof(gusmapping) / sizeof(gusmapping[0]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gus_speaker_ctl",
          "args": [
            "sc",
            "cp->un.ord ? SPKR_OFF : SPKR_ON"
          ],
          "line": 2703
        },
        "resolved": true,
        "details": {
          "function_name": "gus_speaker_ctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "1822-1844",
          "snippet": "int\ngus_speaker_ctl(addr, newstate)\n\tvoid * addr;\n\tint newstate;\n{\n\tstruct gus_softc *sc = (struct gus_softc *) addr;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh1 = sc->sc_ioh1;\n\n\t/* Line out bit is flipped: 0 enables, 1 disables */\n\tif ((newstate == SPKR_ON) &&\n\t    (sc->sc_mixcontrol & GUSMASK_LINE_OUT)) {\n\t\tsc->sc_mixcontrol &= ~GUSMASK_LINE_OUT;\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t}\n\tif ((newstate == SPKR_OFF) &&\n\t    (sc->sc_mixcontrol & GUSMASK_LINE_OUT) == 0) {\n\t\tsc->sc_mixcontrol |= GUSMASK_LINE_OUT;\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngus_speaker_ctl(addr, newstate)\n\tvoid * addr;\n\tint newstate;\n{\n\tstruct gus_softc *sc = (struct gus_softc *) addr;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh1 = sc->sc_ioh1;\n\n\t/* Line out bit is flipped: 0 enables, 1 disables */\n\tif ((newstate == SPKR_ON) &&\n\t    (sc->sc_mixcontrol & GUSMASK_LINE_OUT)) {\n\t\tsc->sc_mixcontrol &= ~GUSMASK_LINE_OUT;\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t}\n\tif ((newstate == SPKR_OFF) &&\n\t    (sc->sc_mixcontrol & GUSMASK_LINE_OUT) == 0) {\n\t\tsc->sc_mixcontrol |= GUSMASK_LINE_OUT;\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad1848_to_vol",
          "args": [
            "cp",
            "&vol"
          ],
          "line": 2693
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_to_vol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848var.h",
          "lines": "145-160",
          "snippet": "static __inline int\nad1848_to_vol(cp, vol)\n\tmixer_ctrl_t *cp;\n\tstruct ad1848_volume *vol;\n{\n\tif (cp->un.value.num_channels == 1) {\n\t\tvol->left = vol->right = cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];\n\t\treturn(1);\n\t}\n\telse if (cp->un.value.num_channels == 2) {\n\t\tvol->left  = cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];\n\t\tvol->right = cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];\n\t\treturn(1);\n\t}\n\treturn(0);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static __inline int\nad1848_to_vol(cp, vol)\n\tmixer_ctrl_t *cp;\n\tstruct ad1848_volume *vol;\n{\n\tif (cp->un.value.num_channels == 1) {\n\t\tvol->left = vol->right = cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];\n\t\treturn(1);\n\t}\n\telse if (cp->un.value.num_channels == 2) {\n\t\tvol->left  = cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];\n\t\tvol->right = cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];\n\t\treturn(1);\n\t}\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"gusmax_mixer_set_port: dev=%d type=%d\\n\", cp->dev, cp->type)"
          ],
          "line": 2687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ad1848_mixer_set_port",
          "args": [
            "ac",
            "gusmapping",
            "nummap",
            "cp"
          ],
          "line": 2682
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_mixer_set_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "867-934",
          "snippet": "int     \nad1848_mixer_set_port(ac, map, cnt, cp)\n  struct ad1848_softc *ac;\n  struct ad1848_devmap *map;\n  int cnt;\n  mixer_ctrl_t *cp;\n{\n  ad1848_devmap_t *entry;\n  struct ad1848_volume vol;\n  int error = EINVAL;\n  int dev;\n\n  if (!(entry = ad1848_mixer_find_dev(map, cnt, cp)))\n    return (ENXIO);\n\n  dev = entry->dev;\n\n  switch (entry->kind) {\n  case AD1848_KIND_LVL:\n    if (cp->type != AUDIO_MIXER_VALUE)\n      break;\n\n    if (dev < AD1848_AUX2_CHANNEL ||\n\tdev > AD1848_MONITOR_CHANNEL)\n      break;\n\n    if (cp->un.value.num_channels != 1 &&\n        mixer_channel_info[dev].right_reg == 0) \n      break;\n    \n    ad1848_to_vol(cp, &vol);\n    error = ad1848_set_channel_gain(ac, dev, &vol);\n    break;\n\n  case AD1848_KIND_MUTE:\n    if (cp->type != AUDIO_MIXER_ENUM) break;\n    \n    ac->mute[dev] = (cp->un.ord ? MUTE_ALL : 0);\n    ad1848_mute_channel(ac, dev, ac->mute[dev]);\n    error = 0;\n    break;\n\n  case AD1848_KIND_RECORDGAIN:\n    if (cp->type != AUDIO_MIXER_VALUE) break;\n\n    ad1848_to_vol(cp, &vol);\n    error = ad1848_set_rec_gain(ac, &vol);\n    break;\n\n  case AD1848_KIND_MICGAIN:\n    if (cp->type != AUDIO_MIXER_VALUE) break;\n\n    ad1848_to_vol(cp, &vol);\n    error = ad1848_set_mic_gain(ac, &vol);\n    break;\n\n  case AD1848_KIND_RECORDSOURCE:\n    if (cp->type != AUDIO_MIXER_ENUM) break;\n\n    error = ad1848_set_rec_port(ac,  cp->un.ord);\n    break;\n  default:\n    printf (\"Invalid kind\\n\");\n    break;\n  }\n\n  return (error);\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct ad1848_mixerinfo {\n  int  left_reg;\n  int  right_reg;\n  int  atten_bits;\n  int  atten_mask;\n} mixer_channel_info[] = \n{ { SP_LEFT_AUX2_CONTROL, SP_RIGHT_AUX2_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_AUX1_CONTROL, SP_RIGHT_AUX1_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_OUTPUT_CONTROL, SP_RIGHT_OUTPUT_CONTROL, \n    OUTPUT_ATTEN_BITS, OUTPUT_ATTEN_MASK }, \n  { CS_LEFT_LINE_CONTROL, CS_RIGHT_LINE_CONTROL, LINE_INPUT_ATTEN_BITS,\n    LINE_INPUT_ATTEN_MASK },\n  { CS_MONO_IO_CONTROL, 0, MONO_INPUT_ATTEN_BITS, MONO_INPUT_ATTEN_MASK },\n  { SP_DIGITAL_MIX, 0, OUTPUT_ATTEN_BITS, MIX_ATTEN_MASK }\n};",
            "static ad1848_devmap_t *ad1848_mixer_find_dev",
            "static ad1848_devmap_t *\nad1848_mixer_find_dev(map, cnt, cp)\n  ad1848_devmap_t *map;",
            "int cnt;",
            "mixer_ctrl_t *cp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct ad1848_mixerinfo {\n  int  left_reg;\n  int  right_reg;\n  int  atten_bits;\n  int  atten_mask;\n} mixer_channel_info[] = \n{ { SP_LEFT_AUX2_CONTROL, SP_RIGHT_AUX2_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_AUX1_CONTROL, SP_RIGHT_AUX1_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_OUTPUT_CONTROL, SP_RIGHT_OUTPUT_CONTROL, \n    OUTPUT_ATTEN_BITS, OUTPUT_ATTEN_MASK }, \n  { CS_LEFT_LINE_CONTROL, CS_RIGHT_LINE_CONTROL, LINE_INPUT_ATTEN_BITS,\n    LINE_INPUT_ATTEN_MASK },\n  { CS_MONO_IO_CONTROL, 0, MONO_INPUT_ATTEN_BITS, MONO_INPUT_ATTEN_MASK },\n  { SP_DIGITAL_MIX, 0, OUTPUT_ATTEN_BITS, MIX_ATTEN_MASK }\n};\nstatic ad1848_devmap_t *ad1848_mixer_find_dev;\nstatic ad1848_devmap_t *\nad1848_mixer_find_dev(map, cnt, cp)\n  ad1848_devmap_t *map;\nint cnt;\nmixer_ctrl_t *cp;\n\nint     \nad1848_mixer_set_port(ac, map, cnt, cp)\n  struct ad1848_softc *ac;\n  struct ad1848_devmap *map;\n  int cnt;\n  mixer_ctrl_t *cp;\n{\n  ad1848_devmap_t *entry;\n  struct ad1848_volume vol;\n  int error = EINVAL;\n  int dev;\n\n  if (!(entry = ad1848_mixer_find_dev(map, cnt, cp)))\n    return (ENXIO);\n\n  dev = entry->dev;\n\n  switch (entry->kind) {\n  case AD1848_KIND_LVL:\n    if (cp->type != AUDIO_MIXER_VALUE)\n      break;\n\n    if (dev < AD1848_AUX2_CHANNEL ||\n\tdev > AD1848_MONITOR_CHANNEL)\n      break;\n\n    if (cp->un.value.num_channels != 1 &&\n        mixer_channel_info[dev].right_reg == 0) \n      break;\n    \n    ad1848_to_vol(cp, &vol);\n    error = ad1848_set_channel_gain(ac, dev, &vol);\n    break;\n\n  case AD1848_KIND_MUTE:\n    if (cp->type != AUDIO_MIXER_ENUM) break;\n    \n    ac->mute[dev] = (cp->un.ord ? MUTE_ALL : 0);\n    ad1848_mute_channel(ac, dev, ac->mute[dev]);\n    error = 0;\n    break;\n\n  case AD1848_KIND_RECORDGAIN:\n    if (cp->type != AUDIO_MIXER_VALUE) break;\n\n    ad1848_to_vol(cp, &vol);\n    error = ad1848_set_rec_gain(ac, &vol);\n    break;\n\n  case AD1848_KIND_MICGAIN:\n    if (cp->type != AUDIO_MIXER_VALUE) break;\n\n    ad1848_to_vol(cp, &vol);\n    error = ad1848_set_mic_gain(ac, &vol);\n    break;\n\n  case AD1848_KIND_RECORDSOURCE:\n    if (cp->type != AUDIO_MIXER_ENUM) break;\n\n    error = ad1848_set_rec_port(ac,  cp->un.ord);\n    break;\n  default:\n    printf (\"Invalid kind\\n\");\n    break;\n  }\n\n  return (error);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nad1848_devmap_t gusmapping[] = {\n  {GUSMAX_DAC_LVL, AD1848_KIND_LVL, AD1848_AUX1_CHANNEL},\n  {GUSMAX_LINE_IN_LVL, AD1848_KIND_LVL, AD1848_LINE_CHANNEL},\n  {GUSMAX_MONO_LVL, AD1848_KIND_LVL, AD1848_MONO_CHANNEL},\n  {GUSMAX_CD_LVL, AD1848_KIND_LVL, AD1848_AUX2_CHANNEL},\n  {GUSMAX_MONITOR_LVL, AD1848_KIND_LVL, AD1848_MONITOR_CHANNEL},\n  {GUSMAX_OUT_LVL, AD1848_KIND_LVL, AD1848_DAC_CHANNEL},\n  {GUSMAX_DAC_MUTE, AD1848_KIND_MUTE, AD1848_AUX1_CHANNEL},\n  {GUSMAX_LINE_IN_MUTE, AD1848_KIND_MUTE, AD1848_LINE_CHANNEL},\n  {GUSMAX_MONO_MUTE, AD1848_KIND_MUTE, AD1848_MONO_CHANNEL},\n  {GUSMAX_CD_MUTE, AD1848_KIND_MUTE, AD1848_AUX2_CHANNEL},\n  {GUSMAX_MONITOR_MUTE, AD1848_KIND_MUTE, AD1848_MONITOR_CHANNEL},\n  {GUSMAX_REC_LVL, AD1848_KIND_RECORDGAIN, -1},\n  {GUSMAX_RECORD_SOURCE, AD1848_KIND_RECORDSOURCE, -1}\n};\nint nummap = sizeof(gusmapping) / sizeof(gusmapping[0]);\n\nint\ngusmax_mixer_set_port(addr, cp)\n\tvoid *addr;\n\tmixer_ctrl_t *cp;\n{\n\tstruct ad1848_softc *ac = addr;\n\tstruct gus_softc *sc = ac->parent;\n\tstruct ad1848_volume vol;\n\tint error = ad1848_mixer_set_port(ac, gusmapping, nummap, cp);\n    \n\tif (error != ENXIO)\n\t  return (error);\n\n\tDPRINTF((\"gusmax_mixer_set_port: dev=%d type=%d\\n\", cp->dev, cp->type));\n\n\tswitch (cp->dev) {\n\tcase GUSMAX_SPEAKER_LVL:\n\t\tif (cp->type == AUDIO_MIXER_VALUE &&\n\t\t    cp->un.value.num_channels == 1) {\n\t\t\tif (ad1848_to_vol(cp, &vol)) {\n\t\t\t\tgus_speaker_ctl(sc, vol.left > AUDIO_MIN_GAIN ?\n\t\t\t\t\t\tSPKR_ON : SPKR_OFF);\n\t\t\t\terror = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase GUSMAX_SPEAKER_MUTE:\n\t\tif (cp->type == AUDIO_MIXER_ENUM) {\n\t\t\tgus_speaker_ctl(sc, cp->un.ord ? SPKR_OFF : SPKR_ON);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn ENXIO;\n\t    /*NOTREACHED*/\n    }\n    return error;\n}"
  },
  {
    "function_name": "gusics_dac_mute",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "2665-2672",
    "snippet": "void\ngusics_dac_mute(ic, mute)\n\tstruct ics2101_softc *ic;\n\tint mute;\n{\n\tics2101_mix_mute(ic, GUSMIX_CHAN_DAC, ICSMIX_LEFT, mute);\n\tics2101_mix_mute(ic, GUSMIX_CHAN_DAC, ICSMIX_RIGHT, mute);\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ics2101_mix_mute",
          "args": [
            "ic",
            "GUSMIX_CHAN_DAC",
            "ICSMIX_RIGHT",
            "mute"
          ],
          "line": 2671
        },
        "resolved": true,
        "details": {
          "function_name": "ics2101_mix_mute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ics2101.c",
          "lines": "141-148",
          "snippet": "void\nics2101_mix_mute(sc, chan, side, domute)\n\tstruct ics2101_softc *sc;\n\tunsigned int chan, side, domute;\n{\n    ics2101_mix_doit(sc, chan, side, 0,\n\t\t     domute ? ICS_MUTE|ICS_MUTE_MUTED : ICS_MUTE);\n}",
          "includes": [
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/pio.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define ICS_MUTE_MUTED\t0x04",
            "#define ICS_MUTE\t0x02"
          ],
          "globals_used": [
            "static void ics2101_mix_doit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/ics2101var.h>\n#include <dev/ic/ics2101reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define ICS_MUTE_MUTED\t0x04\n#define ICS_MUTE\t0x02\n\nstatic void ics2101_mix_doit;\n\nvoid\nics2101_mix_mute(sc, chan, side, domute)\n\tstruct ics2101_softc *sc;\n\tunsigned int chan, side, domute;\n{\n    ics2101_mix_doit(sc, chan, side, 0,\n\t\t     domute ? ICS_MUTE|ICS_MUTE_MUTED : ICS_MUTE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ngusics_dac_mute(ic, mute)\n\tstruct ics2101_softc *ic;\n\tint mute;\n{\n\tics2101_mix_mute(ic, GUSMIX_CHAN_DAC, ICSMIX_LEFT, mute);\n\tics2101_mix_mute(ic, GUSMIX_CHAN_DAC, ICSMIX_RIGHT, mute);\n}"
  },
  {
    "function_name": "gusics_cd_mute",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "2656-2663",
    "snippet": "void\ngusics_cd_mute(ic, mute)\n\tstruct ics2101_softc *ic;\n\tint mute;\n{\n\tics2101_mix_mute(ic, GUSMIX_CHAN_CD, ICSMIX_LEFT, mute);\n\tics2101_mix_mute(ic, GUSMIX_CHAN_CD, ICSMIX_RIGHT, mute);\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ics2101_mix_mute",
          "args": [
            "ic",
            "GUSMIX_CHAN_CD",
            "ICSMIX_RIGHT",
            "mute"
          ],
          "line": 2662
        },
        "resolved": true,
        "details": {
          "function_name": "ics2101_mix_mute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ics2101.c",
          "lines": "141-148",
          "snippet": "void\nics2101_mix_mute(sc, chan, side, domute)\n\tstruct ics2101_softc *sc;\n\tunsigned int chan, side, domute;\n{\n    ics2101_mix_doit(sc, chan, side, 0,\n\t\t     domute ? ICS_MUTE|ICS_MUTE_MUTED : ICS_MUTE);\n}",
          "includes": [
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/pio.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define ICS_MUTE_MUTED\t0x04",
            "#define ICS_MUTE\t0x02"
          ],
          "globals_used": [
            "static void ics2101_mix_doit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/ics2101var.h>\n#include <dev/ic/ics2101reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define ICS_MUTE_MUTED\t0x04\n#define ICS_MUTE\t0x02\n\nstatic void ics2101_mix_doit;\n\nvoid\nics2101_mix_mute(sc, chan, side, domute)\n\tstruct ics2101_softc *sc;\n\tunsigned int chan, side, domute;\n{\n    ics2101_mix_doit(sc, chan, side, 0,\n\t\t     domute ? ICS_MUTE|ICS_MUTE_MUTED : ICS_MUTE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ngusics_cd_mute(ic, mute)\n\tstruct ics2101_softc *ic;\n\tint mute;\n{\n\tics2101_mix_mute(ic, GUSMIX_CHAN_CD, ICSMIX_LEFT, mute);\n\tics2101_mix_mute(ic, GUSMIX_CHAN_CD, ICSMIX_RIGHT, mute);\n}"
  },
  {
    "function_name": "gusics_linein_mute",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "2647-2654",
    "snippet": "void\ngusics_linein_mute(ic, mute)\n\tstruct ics2101_softc *ic;\n\tint mute;\n{\n\tics2101_mix_mute(ic, GUSMIX_CHAN_LINE, ICSMIX_LEFT, mute);\n\tics2101_mix_mute(ic, GUSMIX_CHAN_LINE, ICSMIX_RIGHT, mute);\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ics2101_mix_mute",
          "args": [
            "ic",
            "GUSMIX_CHAN_LINE",
            "ICSMIX_RIGHT",
            "mute"
          ],
          "line": 2653
        },
        "resolved": true,
        "details": {
          "function_name": "ics2101_mix_mute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ics2101.c",
          "lines": "141-148",
          "snippet": "void\nics2101_mix_mute(sc, chan, side, domute)\n\tstruct ics2101_softc *sc;\n\tunsigned int chan, side, domute;\n{\n    ics2101_mix_doit(sc, chan, side, 0,\n\t\t     domute ? ICS_MUTE|ICS_MUTE_MUTED : ICS_MUTE);\n}",
          "includes": [
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/pio.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define ICS_MUTE_MUTED\t0x04",
            "#define ICS_MUTE\t0x02"
          ],
          "globals_used": [
            "static void ics2101_mix_doit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/ics2101var.h>\n#include <dev/ic/ics2101reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define ICS_MUTE_MUTED\t0x04\n#define ICS_MUTE\t0x02\n\nstatic void ics2101_mix_doit;\n\nvoid\nics2101_mix_mute(sc, chan, side, domute)\n\tstruct ics2101_softc *sc;\n\tunsigned int chan, side, domute;\n{\n    ics2101_mix_doit(sc, chan, side, 0,\n\t\t     domute ? ICS_MUTE|ICS_MUTE_MUTED : ICS_MUTE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ngusics_linein_mute(ic, mute)\n\tstruct ics2101_softc *ic;\n\tint mute;\n{\n\tics2101_mix_mute(ic, GUSMIX_CHAN_LINE, ICSMIX_LEFT, mute);\n\tics2101_mix_mute(ic, GUSMIX_CHAN_LINE, ICSMIX_RIGHT, mute);\n}"
  },
  {
    "function_name": "gusics_mic_mute",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "2638-2645",
    "snippet": "void\ngusics_mic_mute(ic, mute)\n\tstruct ics2101_softc *ic;\n\tint mute;\n{\n\tics2101_mix_mute(ic, GUSMIX_CHAN_MIC, ICSMIX_LEFT, mute);\n\tics2101_mix_mute(ic, GUSMIX_CHAN_MIC, ICSMIX_RIGHT, mute);\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ics2101_mix_mute",
          "args": [
            "ic",
            "GUSMIX_CHAN_MIC",
            "ICSMIX_RIGHT",
            "mute"
          ],
          "line": 2644
        },
        "resolved": true,
        "details": {
          "function_name": "ics2101_mix_mute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ics2101.c",
          "lines": "141-148",
          "snippet": "void\nics2101_mix_mute(sc, chan, side, domute)\n\tstruct ics2101_softc *sc;\n\tunsigned int chan, side, domute;\n{\n    ics2101_mix_doit(sc, chan, side, 0,\n\t\t     domute ? ICS_MUTE|ICS_MUTE_MUTED : ICS_MUTE);\n}",
          "includes": [
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/pio.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define ICS_MUTE_MUTED\t0x04",
            "#define ICS_MUTE\t0x02"
          ],
          "globals_used": [
            "static void ics2101_mix_doit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/ics2101var.h>\n#include <dev/ic/ics2101reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define ICS_MUTE_MUTED\t0x04\n#define ICS_MUTE\t0x02\n\nstatic void ics2101_mix_doit;\n\nvoid\nics2101_mix_mute(sc, chan, side, domute)\n\tstruct ics2101_softc *sc;\n\tunsigned int chan, side, domute;\n{\n    ics2101_mix_doit(sc, chan, side, 0,\n\t\t     domute ? ICS_MUTE|ICS_MUTE_MUTED : ICS_MUTE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ngusics_mic_mute(ic, mute)\n\tstruct ics2101_softc *ic;\n\tint mute;\n{\n\tics2101_mix_mute(ic, GUSMIX_CHAN_MIC, ICSMIX_LEFT, mute);\n\tics2101_mix_mute(ic, GUSMIX_CHAN_MIC, ICSMIX_RIGHT, mute);\n}"
  },
  {
    "function_name": "gusics_master_mute",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "2629-2636",
    "snippet": "void\ngusics_master_mute(ic, mute)\n\tstruct ics2101_softc *ic;\n\tint mute;\n{\n\tics2101_mix_mute(ic, GUSMIX_CHAN_MASTER, ICSMIX_LEFT, mute);\n\tics2101_mix_mute(ic, GUSMIX_CHAN_MASTER, ICSMIX_RIGHT, mute);\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ics2101_mix_mute",
          "args": [
            "ic",
            "GUSMIX_CHAN_MASTER",
            "ICSMIX_RIGHT",
            "mute"
          ],
          "line": 2635
        },
        "resolved": true,
        "details": {
          "function_name": "ics2101_mix_mute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ics2101.c",
          "lines": "141-148",
          "snippet": "void\nics2101_mix_mute(sc, chan, side, domute)\n\tstruct ics2101_softc *sc;\n\tunsigned int chan, side, domute;\n{\n    ics2101_mix_doit(sc, chan, side, 0,\n\t\t     domute ? ICS_MUTE|ICS_MUTE_MUTED : ICS_MUTE);\n}",
          "includes": [
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/pio.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define ICS_MUTE_MUTED\t0x04",
            "#define ICS_MUTE\t0x02"
          ],
          "globals_used": [
            "static void ics2101_mix_doit"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/ics2101var.h>\n#include <dev/ic/ics2101reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/pio.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define ICS_MUTE_MUTED\t0x04\n#define ICS_MUTE\t0x02\n\nstatic void ics2101_mix_doit;\n\nvoid\nics2101_mix_mute(sc, chan, side, domute)\n\tstruct ics2101_softc *sc;\n\tunsigned int chan, side, domute;\n{\n    ics2101_mix_doit(sc, chan, side, 0,\n\t\t     domute ? ICS_MUTE|ICS_MUTE_MUTED : ICS_MUTE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ngusics_master_mute(ic, mute)\n\tstruct ics2101_softc *ic;\n\tint mute;\n{\n\tics2101_mix_mute(ic, GUSMIX_CHAN_MASTER, ICSMIX_LEFT, mute);\n\tics2101_mix_mute(ic, GUSMIX_CHAN_MASTER, ICSMIX_RIGHT, mute);\n}"
  },
  {
    "function_name": "gus_mixer_get_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "2504-2627",
    "snippet": "int\ngus_mixer_get_port(addr, cp)\n\tvoid *addr;\n\tmixer_ctrl_t *cp;\n{\n\tstruct gus_softc *sc = addr;\n\tstruct ics2101_softc *ic = &sc->sc_mixer;\n\tstruct ad1848_volume vol;\n\tint error = EINVAL;\n\n\tDPRINTF((\"gus_mixer_get_port: dev=%d type=%d\\n\", cp->dev, cp->type));\n\n\tif (!HAS_MIXER(sc) && cp->dev > GUSICS_MASTER_MUTE)\n\t\treturn ENXIO;\n    \n\tswitch (cp->dev) {\n\n\tcase GUSICS_MIC_IN_MUTE:\t/* Microphone */\n\t\tif (cp->type == AUDIO_MIXER_ENUM) {\n\t\t\tif (HAS_MIXER(sc))\n\t\t\t\tcp->un.ord = ic->sc_mute[GUSMIX_CHAN_MIC][ICSMIX_LEFT];\n\t\t\telse\n\t\t\t\tcp->un.ord =\n\t\t\t\t    sc->sc_mixcontrol & GUSMASK_MIC_IN ? 0 : 1;\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tcase GUSICS_LINE_IN_MUTE:\n\t\tif (cp->type == AUDIO_MIXER_ENUM) {\n\t\t\tif (HAS_MIXER(sc))\n\t\t\t\tcp->un.ord = ic->sc_mute[GUSMIX_CHAN_LINE][ICSMIX_LEFT];\n\t\t\telse\n\t\t\t\tcp->un.ord =\n\t\t\t\t    sc->sc_mixcontrol & GUSMASK_LINE_IN ? 1 : 0;\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tcase GUSICS_MASTER_MUTE:\n\t\tif (cp->type == AUDIO_MIXER_ENUM) {\n\t\t\tif (HAS_MIXER(sc))\n\t\t\t\tcp->un.ord = ic->sc_mute[GUSMIX_CHAN_MASTER][ICSMIX_LEFT];\n\t\t\telse\n\t\t\t\tcp->un.ord =\n\t\t\t\t    sc->sc_mixcontrol & GUSMASK_LINE_OUT ? 1 : 0;\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tcase GUSICS_DAC_MUTE:\n\t\tif (cp->type == AUDIO_MIXER_ENUM) {\n\t\t\tcp->un.ord = ic->sc_mute[GUSMIX_CHAN_DAC][ICSMIX_LEFT];\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tcase GUSICS_CD_MUTE:\n\t\tif (cp->type == AUDIO_MIXER_ENUM) {\n\t\t\tcp->un.ord = ic->sc_mute[GUSMIX_CHAN_CD][ICSMIX_LEFT];\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tcase GUSICS_MASTER_LVL:\n\t\tif (cp->type == AUDIO_MIXER_VALUE) {\n\t\t\tvol.left = ic->sc_setting[GUSMIX_CHAN_MASTER][ICSMIX_LEFT];\n\t\t\tvol.right = ic->sc_setting[GUSMIX_CHAN_MASTER][ICSMIX_RIGHT];\n\t\t\tif (ad1848_from_vol(cp, &vol))\n\t\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tcase GUSICS_MIC_IN_LVL:\t/* Microphone */\n\t\tif (cp->type == AUDIO_MIXER_VALUE) {\n\t\t\tvol.left = ic->sc_setting[GUSMIX_CHAN_MIC][ICSMIX_LEFT];\n\t\t\tvol.right = ic->sc_setting[GUSMIX_CHAN_MIC][ICSMIX_RIGHT];\n\t\t\tif (ad1848_from_vol(cp, &vol))\n\t\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\t\n\tcase GUSICS_LINE_IN_LVL:\t/* line in */\n\t\tif (cp->type == AUDIO_MIXER_VALUE) {\n\t\t\tvol.left = ic->sc_setting[GUSMIX_CHAN_LINE][ICSMIX_LEFT];\n\t\t\tvol.right = ic->sc_setting[GUSMIX_CHAN_LINE][ICSMIX_RIGHT];\n\t\t\tif (ad1848_from_vol(cp, &vol))\n\t\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\n\tcase GUSICS_CD_LVL:\n\t\tif (cp->type == AUDIO_MIXER_VALUE) {\n\t\t\tvol.left = ic->sc_setting[GUSMIX_CHAN_CD][ICSMIX_LEFT];\n\t\t\tvol.right = ic->sc_setting[GUSMIX_CHAN_CD][ICSMIX_RIGHT];\n\t\t\tif (ad1848_from_vol(cp, &vol))\n\t\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tcase GUSICS_DAC_LVL:\t\t/* dac out */\n\t\tif (cp->type == AUDIO_MIXER_VALUE) {\n\t\t\tvol.left = ic->sc_setting[GUSMIX_CHAN_DAC][ICSMIX_LEFT];\n\t\t\tvol.right = ic->sc_setting[GUSMIX_CHAN_DAC][ICSMIX_RIGHT];\n\t\t\tif (ad1848_from_vol(cp, &vol))\n\t\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\n\tcase GUSICS_RECORD_SOURCE:\n\t\tif (cp->type == AUDIO_MIXER_ENUM) {\n\t\t\t/* Can't set anything else useful, sigh. */\n\t\t\t cp->un.ord = 0;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn ENXIO;\n\t    /*NOTREACHED*/\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ad1848_from_vol",
          "args": [
            "cp",
            "&vol"
          ],
          "line": 2609
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_from_vol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848var.h",
          "lines": "162-177",
          "snippet": "static __inline int\nad1848_from_vol(cp, vol)\n\tmixer_ctrl_t *cp;\n\tstruct ad1848_volume *vol;\n{\n\tif (cp->un.value.num_channels == 1) {\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = vol->left;\n\t\treturn(1);\n\t}\n\telse if (cp->un.value.num_channels == 2) {\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] = vol->left;\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = vol->right;\n\t\treturn(1);\n\t}\n\treturn(0);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static __inline int\nad1848_from_vol(cp, vol)\n\tmixer_ctrl_t *cp;\n\tstruct ad1848_volume *vol;\n{\n\tif (cp->un.value.num_channels == 1) {\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = vol->left;\n\t\treturn(1);\n\t}\n\telse if (cp->un.value.num_channels == 2) {\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] = vol->left;\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = vol->right;\n\t\treturn(1);\n\t}\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HAS_MIXER",
          "args": [
            "sc"
          ],
          "line": 2545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_MIXER",
          "args": [
            "sc"
          ],
          "line": 2534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_MIXER",
          "args": [
            "sc"
          ],
          "line": 2523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_MIXER",
          "args": [
            "sc"
          ],
          "line": 2516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"gus_mixer_get_port: dev=%d type=%d\\n\", cp->dev, cp->type)"
          ],
          "line": 2514
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngus_mixer_get_port(addr, cp)\n\tvoid *addr;\n\tmixer_ctrl_t *cp;\n{\n\tstruct gus_softc *sc = addr;\n\tstruct ics2101_softc *ic = &sc->sc_mixer;\n\tstruct ad1848_volume vol;\n\tint error = EINVAL;\n\n\tDPRINTF((\"gus_mixer_get_port: dev=%d type=%d\\n\", cp->dev, cp->type));\n\n\tif (!HAS_MIXER(sc) && cp->dev > GUSICS_MASTER_MUTE)\n\t\treturn ENXIO;\n    \n\tswitch (cp->dev) {\n\n\tcase GUSICS_MIC_IN_MUTE:\t/* Microphone */\n\t\tif (cp->type == AUDIO_MIXER_ENUM) {\n\t\t\tif (HAS_MIXER(sc))\n\t\t\t\tcp->un.ord = ic->sc_mute[GUSMIX_CHAN_MIC][ICSMIX_LEFT];\n\t\t\telse\n\t\t\t\tcp->un.ord =\n\t\t\t\t    sc->sc_mixcontrol & GUSMASK_MIC_IN ? 0 : 1;\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tcase GUSICS_LINE_IN_MUTE:\n\t\tif (cp->type == AUDIO_MIXER_ENUM) {\n\t\t\tif (HAS_MIXER(sc))\n\t\t\t\tcp->un.ord = ic->sc_mute[GUSMIX_CHAN_LINE][ICSMIX_LEFT];\n\t\t\telse\n\t\t\t\tcp->un.ord =\n\t\t\t\t    sc->sc_mixcontrol & GUSMASK_LINE_IN ? 1 : 0;\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tcase GUSICS_MASTER_MUTE:\n\t\tif (cp->type == AUDIO_MIXER_ENUM) {\n\t\t\tif (HAS_MIXER(sc))\n\t\t\t\tcp->un.ord = ic->sc_mute[GUSMIX_CHAN_MASTER][ICSMIX_LEFT];\n\t\t\telse\n\t\t\t\tcp->un.ord =\n\t\t\t\t    sc->sc_mixcontrol & GUSMASK_LINE_OUT ? 1 : 0;\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tcase GUSICS_DAC_MUTE:\n\t\tif (cp->type == AUDIO_MIXER_ENUM) {\n\t\t\tcp->un.ord = ic->sc_mute[GUSMIX_CHAN_DAC][ICSMIX_LEFT];\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tcase GUSICS_CD_MUTE:\n\t\tif (cp->type == AUDIO_MIXER_ENUM) {\n\t\t\tcp->un.ord = ic->sc_mute[GUSMIX_CHAN_CD][ICSMIX_LEFT];\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tcase GUSICS_MASTER_LVL:\n\t\tif (cp->type == AUDIO_MIXER_VALUE) {\n\t\t\tvol.left = ic->sc_setting[GUSMIX_CHAN_MASTER][ICSMIX_LEFT];\n\t\t\tvol.right = ic->sc_setting[GUSMIX_CHAN_MASTER][ICSMIX_RIGHT];\n\t\t\tif (ad1848_from_vol(cp, &vol))\n\t\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tcase GUSICS_MIC_IN_LVL:\t/* Microphone */\n\t\tif (cp->type == AUDIO_MIXER_VALUE) {\n\t\t\tvol.left = ic->sc_setting[GUSMIX_CHAN_MIC][ICSMIX_LEFT];\n\t\t\tvol.right = ic->sc_setting[GUSMIX_CHAN_MIC][ICSMIX_RIGHT];\n\t\t\tif (ad1848_from_vol(cp, &vol))\n\t\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\t\n\tcase GUSICS_LINE_IN_LVL:\t/* line in */\n\t\tif (cp->type == AUDIO_MIXER_VALUE) {\n\t\t\tvol.left = ic->sc_setting[GUSMIX_CHAN_LINE][ICSMIX_LEFT];\n\t\t\tvol.right = ic->sc_setting[GUSMIX_CHAN_LINE][ICSMIX_RIGHT];\n\t\t\tif (ad1848_from_vol(cp, &vol))\n\t\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\n\tcase GUSICS_CD_LVL:\n\t\tif (cp->type == AUDIO_MIXER_VALUE) {\n\t\t\tvol.left = ic->sc_setting[GUSMIX_CHAN_CD][ICSMIX_LEFT];\n\t\t\tvol.right = ic->sc_setting[GUSMIX_CHAN_CD][ICSMIX_RIGHT];\n\t\t\tif (ad1848_from_vol(cp, &vol))\n\t\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tcase GUSICS_DAC_LVL:\t\t/* dac out */\n\t\tif (cp->type == AUDIO_MIXER_VALUE) {\n\t\t\tvol.left = ic->sc_setting[GUSMIX_CHAN_DAC][ICSMIX_LEFT];\n\t\t\tvol.right = ic->sc_setting[GUSMIX_CHAN_DAC][ICSMIX_RIGHT];\n\t\t\tif (ad1848_from_vol(cp, &vol))\n\t\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\n\tcase GUSICS_RECORD_SOURCE:\n\t\tif (cp->type == AUDIO_MIXER_ENUM) {\n\t\t\t/* Can't set anything else useful, sigh. */\n\t\t\t cp->un.ord = 0;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn ENXIO;\n\t    /*NOTREACHED*/\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "gusmax_mixer_get_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "2463-2502",
    "snippet": "int\ngusmax_mixer_get_port(addr, cp)\n\tvoid *addr;\n\tmixer_ctrl_t *cp;\n{\n\tstruct ad1848_softc *ac = addr;\n\tstruct gus_softc *sc = ac->parent;\n\tstruct ad1848_volume vol;\n\tint error = ad1848_mixer_get_port(ac, gusmapping, nummap, cp);\n    \n\tif (error != ENXIO)\n\t  return (error);\n\n\terror = EINVAL;\n\n\tswitch (cp->dev) {\n\tcase GUSMAX_SPEAKER_LVL:\t/* fake speaker for mute naming */\n\t\tif (cp->type == AUDIO_MIXER_VALUE) {\n\t\t\tif (sc->sc_mixcontrol & GUSMASK_LINE_OUT)\n\t\t\t\tvol.left = vol.right = AUDIO_MAX_GAIN;\n\t\t\telse\n\t\t\t\tvol.left = vol.right = AUDIO_MIN_GAIN;\n\t\t\terror = 0;\n\t\t\tad1848_from_vol(cp, &vol);\n\t\t}\n\t\tbreak;\n\n\tcase GUSMAX_SPEAKER_MUTE:\n\t\tif (cp->type == AUDIO_MIXER_ENUM) {\n\t\t\tcp->un.ord = sc->sc_mixcontrol & GUSMASK_LINE_OUT ? 1 : 0;\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terror = ENXIO;\n\t\tbreak;\n\t}\n\n\treturn(error);\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "ad1848_devmap_t gusmapping[] = {\n  {GUSMAX_DAC_LVL, AD1848_KIND_LVL, AD1848_AUX1_CHANNEL},\n  {GUSMAX_LINE_IN_LVL, AD1848_KIND_LVL, AD1848_LINE_CHANNEL},\n  {GUSMAX_MONO_LVL, AD1848_KIND_LVL, AD1848_MONO_CHANNEL},\n  {GUSMAX_CD_LVL, AD1848_KIND_LVL, AD1848_AUX2_CHANNEL},\n  {GUSMAX_MONITOR_LVL, AD1848_KIND_LVL, AD1848_MONITOR_CHANNEL},\n  {GUSMAX_OUT_LVL, AD1848_KIND_LVL, AD1848_DAC_CHANNEL},\n  {GUSMAX_DAC_MUTE, AD1848_KIND_MUTE, AD1848_AUX1_CHANNEL},\n  {GUSMAX_LINE_IN_MUTE, AD1848_KIND_MUTE, AD1848_LINE_CHANNEL},\n  {GUSMAX_MONO_MUTE, AD1848_KIND_MUTE, AD1848_MONO_CHANNEL},\n  {GUSMAX_CD_MUTE, AD1848_KIND_MUTE, AD1848_AUX2_CHANNEL},\n  {GUSMAX_MONITOR_MUTE, AD1848_KIND_MUTE, AD1848_MONITOR_CHANNEL},\n  {GUSMAX_REC_LVL, AD1848_KIND_RECORDGAIN, -1},\n  {GUSMAX_RECORD_SOURCE, AD1848_KIND_RECORDSOURCE, -1}\n};",
      "int nummap = sizeof(gusmapping) / sizeof(gusmapping[0]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ad1848_from_vol",
          "args": [
            "cp",
            "&vol"
          ],
          "line": 2486
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_from_vol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848var.h",
          "lines": "162-177",
          "snippet": "static __inline int\nad1848_from_vol(cp, vol)\n\tmixer_ctrl_t *cp;\n\tstruct ad1848_volume *vol;\n{\n\tif (cp->un.value.num_channels == 1) {\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = vol->left;\n\t\treturn(1);\n\t}\n\telse if (cp->un.value.num_channels == 2) {\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] = vol->left;\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = vol->right;\n\t\treturn(1);\n\t}\n\treturn(0);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static __inline int\nad1848_from_vol(cp, vol)\n\tmixer_ctrl_t *cp;\n\tstruct ad1848_volume *vol;\n{\n\tif (cp->un.value.num_channels == 1) {\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = vol->left;\n\t\treturn(1);\n\t}\n\telse if (cp->un.value.num_channels == 2) {\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] = vol->left;\n\t\tcp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = vol->right;\n\t\treturn(1);\n\t}\n\treturn(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad1848_mixer_get_port",
          "args": [
            "ac",
            "gusmapping",
            "nummap",
            "cp"
          ],
          "line": 2471
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_mixer_get_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "793-865",
          "snippet": "int     \nad1848_mixer_get_port(ac, map, cnt, cp)\n  struct ad1848_softc *ac;\n  struct ad1848_devmap *map;\n  int cnt;\n  mixer_ctrl_t *cp;\n{\n  ad1848_devmap_t *entry;\n  struct ad1848_volume vol;\n  int error = EINVAL;\n  int dev;\n\n  if (!(entry = ad1848_mixer_find_dev(map, cnt, cp)))\n    return (ENXIO);\n\n  dev = entry->dev;\n\n  switch (entry->kind) {\n  case AD1848_KIND_LVL:\n    if (cp->type != AUDIO_MIXER_VALUE)\n      break;\n\n    if (dev < AD1848_AUX2_CHANNEL ||\n\tdev > AD1848_MONITOR_CHANNEL)\n      break;\n\n    if (cp->un.value.num_channels != 1 &&\n        mixer_channel_info[dev].right_reg == 0) \n      break;\n\n    error = ad1848_get_device_gain(ac, dev, &vol);\n    if (!error)\n      ad1848_from_vol(cp, &vol);\n\n    break;\n\n  case AD1848_KIND_MUTE:\n    if (cp->type != AUDIO_MIXER_ENUM) break;\n\n    cp->un.ord = ac->mute[dev] ? 1 : 0;\n    error = 0;\n    break;\n\n  case AD1848_KIND_RECORDGAIN:\n    if (cp->type != AUDIO_MIXER_VALUE) break;\n\n    error = ad1848_get_rec_gain(ac, &vol);\n    if (!error)\n      ad1848_from_vol(cp, &vol);\n\n    break;\n\n  case AD1848_KIND_MICGAIN:\n    if (cp->type != AUDIO_MIXER_VALUE) break;\n\n    error = ad1848_get_mic_gain(ac, &vol);\n    if (!error)\n      ad1848_from_vol(cp, &vol);\n\n    break;\n\n  case AD1848_KIND_RECORDSOURCE:\n    if (cp->type != AUDIO_MIXER_ENUM) break;\n    cp->un.ord = ad1848_get_rec_port(ac);\n    error = 0;\n    break;\n  default:\n    printf (\"Invalid kind\\n\");\n    break;\n  }\n\n  return (error);\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct ad1848_mixerinfo {\n  int  left_reg;\n  int  right_reg;\n  int  atten_bits;\n  int  atten_mask;\n} mixer_channel_info[] = \n{ { SP_LEFT_AUX2_CONTROL, SP_RIGHT_AUX2_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_AUX1_CONTROL, SP_RIGHT_AUX1_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_OUTPUT_CONTROL, SP_RIGHT_OUTPUT_CONTROL, \n    OUTPUT_ATTEN_BITS, OUTPUT_ATTEN_MASK }, \n  { CS_LEFT_LINE_CONTROL, CS_RIGHT_LINE_CONTROL, LINE_INPUT_ATTEN_BITS,\n    LINE_INPUT_ATTEN_MASK },\n  { CS_MONO_IO_CONTROL, 0, MONO_INPUT_ATTEN_BITS, MONO_INPUT_ATTEN_MASK },\n  { SP_DIGITAL_MIX, 0, OUTPUT_ATTEN_BITS, MIX_ATTEN_MASK }\n};",
            "static ad1848_devmap_t *ad1848_mixer_find_dev",
            "static ad1848_devmap_t *\nad1848_mixer_find_dev(map, cnt, cp)\n  ad1848_devmap_t *map;",
            "int cnt;",
            "mixer_ctrl_t *cp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct ad1848_mixerinfo {\n  int  left_reg;\n  int  right_reg;\n  int  atten_bits;\n  int  atten_mask;\n} mixer_channel_info[] = \n{ { SP_LEFT_AUX2_CONTROL, SP_RIGHT_AUX2_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_AUX1_CONTROL, SP_RIGHT_AUX1_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_OUTPUT_CONTROL, SP_RIGHT_OUTPUT_CONTROL, \n    OUTPUT_ATTEN_BITS, OUTPUT_ATTEN_MASK }, \n  { CS_LEFT_LINE_CONTROL, CS_RIGHT_LINE_CONTROL, LINE_INPUT_ATTEN_BITS,\n    LINE_INPUT_ATTEN_MASK },\n  { CS_MONO_IO_CONTROL, 0, MONO_INPUT_ATTEN_BITS, MONO_INPUT_ATTEN_MASK },\n  { SP_DIGITAL_MIX, 0, OUTPUT_ATTEN_BITS, MIX_ATTEN_MASK }\n};\nstatic ad1848_devmap_t *ad1848_mixer_find_dev;\nstatic ad1848_devmap_t *\nad1848_mixer_find_dev(map, cnt, cp)\n  ad1848_devmap_t *map;\nint cnt;\nmixer_ctrl_t *cp;\n\nint     \nad1848_mixer_get_port(ac, map, cnt, cp)\n  struct ad1848_softc *ac;\n  struct ad1848_devmap *map;\n  int cnt;\n  mixer_ctrl_t *cp;\n{\n  ad1848_devmap_t *entry;\n  struct ad1848_volume vol;\n  int error = EINVAL;\n  int dev;\n\n  if (!(entry = ad1848_mixer_find_dev(map, cnt, cp)))\n    return (ENXIO);\n\n  dev = entry->dev;\n\n  switch (entry->kind) {\n  case AD1848_KIND_LVL:\n    if (cp->type != AUDIO_MIXER_VALUE)\n      break;\n\n    if (dev < AD1848_AUX2_CHANNEL ||\n\tdev > AD1848_MONITOR_CHANNEL)\n      break;\n\n    if (cp->un.value.num_channels != 1 &&\n        mixer_channel_info[dev].right_reg == 0) \n      break;\n\n    error = ad1848_get_device_gain(ac, dev, &vol);\n    if (!error)\n      ad1848_from_vol(cp, &vol);\n\n    break;\n\n  case AD1848_KIND_MUTE:\n    if (cp->type != AUDIO_MIXER_ENUM) break;\n\n    cp->un.ord = ac->mute[dev] ? 1 : 0;\n    error = 0;\n    break;\n\n  case AD1848_KIND_RECORDGAIN:\n    if (cp->type != AUDIO_MIXER_VALUE) break;\n\n    error = ad1848_get_rec_gain(ac, &vol);\n    if (!error)\n      ad1848_from_vol(cp, &vol);\n\n    break;\n\n  case AD1848_KIND_MICGAIN:\n    if (cp->type != AUDIO_MIXER_VALUE) break;\n\n    error = ad1848_get_mic_gain(ac, &vol);\n    if (!error)\n      ad1848_from_vol(cp, &vol);\n\n    break;\n\n  case AD1848_KIND_RECORDSOURCE:\n    if (cp->type != AUDIO_MIXER_ENUM) break;\n    cp->un.ord = ad1848_get_rec_port(ac);\n    error = 0;\n    break;\n  default:\n    printf (\"Invalid kind\\n\");\n    break;\n  }\n\n  return (error);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nad1848_devmap_t gusmapping[] = {\n  {GUSMAX_DAC_LVL, AD1848_KIND_LVL, AD1848_AUX1_CHANNEL},\n  {GUSMAX_LINE_IN_LVL, AD1848_KIND_LVL, AD1848_LINE_CHANNEL},\n  {GUSMAX_MONO_LVL, AD1848_KIND_LVL, AD1848_MONO_CHANNEL},\n  {GUSMAX_CD_LVL, AD1848_KIND_LVL, AD1848_AUX2_CHANNEL},\n  {GUSMAX_MONITOR_LVL, AD1848_KIND_LVL, AD1848_MONITOR_CHANNEL},\n  {GUSMAX_OUT_LVL, AD1848_KIND_LVL, AD1848_DAC_CHANNEL},\n  {GUSMAX_DAC_MUTE, AD1848_KIND_MUTE, AD1848_AUX1_CHANNEL},\n  {GUSMAX_LINE_IN_MUTE, AD1848_KIND_MUTE, AD1848_LINE_CHANNEL},\n  {GUSMAX_MONO_MUTE, AD1848_KIND_MUTE, AD1848_MONO_CHANNEL},\n  {GUSMAX_CD_MUTE, AD1848_KIND_MUTE, AD1848_AUX2_CHANNEL},\n  {GUSMAX_MONITOR_MUTE, AD1848_KIND_MUTE, AD1848_MONITOR_CHANNEL},\n  {GUSMAX_REC_LVL, AD1848_KIND_RECORDGAIN, -1},\n  {GUSMAX_RECORD_SOURCE, AD1848_KIND_RECORDSOURCE, -1}\n};\nint nummap = sizeof(gusmapping) / sizeof(gusmapping[0]);\n\nint\ngusmax_mixer_get_port(addr, cp)\n\tvoid *addr;\n\tmixer_ctrl_t *cp;\n{\n\tstruct ad1848_softc *ac = addr;\n\tstruct gus_softc *sc = ac->parent;\n\tstruct ad1848_volume vol;\n\tint error = ad1848_mixer_get_port(ac, gusmapping, nummap, cp);\n    \n\tif (error != ENXIO)\n\t  return (error);\n\n\terror = EINVAL;\n\n\tswitch (cp->dev) {\n\tcase GUSMAX_SPEAKER_LVL:\t/* fake speaker for mute naming */\n\t\tif (cp->type == AUDIO_MIXER_VALUE) {\n\t\t\tif (sc->sc_mixcontrol & GUSMASK_LINE_OUT)\n\t\t\t\tvol.left = vol.right = AUDIO_MAX_GAIN;\n\t\t\telse\n\t\t\t\tvol.left = vol.right = AUDIO_MIN_GAIN;\n\t\t\terror = 0;\n\t\t\tad1848_from_vol(cp, &vol);\n\t\t}\n\t\tbreak;\n\n\tcase GUSMAX_SPEAKER_MUTE:\n\t\tif (cp->type == AUDIO_MIXER_ENUM) {\n\t\t\tcp->un.ord = sc->sc_mixcontrol & GUSMASK_LINE_OUT ? 1 : 0;\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terror = ENXIO;\n\t\tbreak;\n\t}\n\n\treturn(error);\n}"
  },
  {
    "function_name": "gus_halt_in_dma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "2417-2442",
    "snippet": "int\ngus_halt_in_dma(addr)\n\tvoid * addr;\n{\n \tstruct gus_softc *sc = addr;\n \tbus_space_tag_t iot = sc->sc_iot;\n \tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tDMAPRINTF((\"gus_halt_in_dma called\\n\"));\n\n\t/*\n\t * Make sure the GUS _isn't_ setup for DMA\n\t */\n\n  \tSELECT_GUS_REG(iot, ioh2, GUSREG_SAMPLE_CONTROL);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH,\n \t     bus_space_read_1(iot, ioh2, GUS_DATA_HIGH) & ~(GUSMASK_SAMPLE_START|GUSMASK_SAMPLE_IRQ));\n  \n \tisa_dmaabort(sc->sc_dev.dv_parent, sc->sc_recdrq);\n\tsc->sc_flags &= ~GUS_DMAIN_ACTIVE;\n\tsc->sc_dmainintr = 0;\n\tsc->sc_inarg = 0;\n\tsc->sc_dmainaddr = 0;\n\tsc->sc_dmaincnt = 0;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isa_dmaabort",
          "args": [
            "sc->sc_dev.dv_parent",
            "sc->sc_recdrq"
          ],
          "line": 2434
        },
        "resolved": true,
        "details": {
          "function_name": "isa_dmaabort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/isadma.c",
          "lines": "424-439",
          "snippet": "void\nisa_dmaabort(isadev, chan)\n\tstruct device *isadev;\n\tint chan;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\n\tif (chan < 0 || chan > 7) {\n\t\tpanic(\"isa_dmaabort: %s: bogus drq %d\", sc->sc_dev.dv_xname,\n\t\t    chan);\n\t}\n\n\tisa_dmamask(sc, chan);\n\tbus_dmamap_unload(sc->sc_dmat, sc->sc_dmamaps[chan]);\n\tsc->sc_dmareads &= ~(1 << chan);\n}",
          "includes": [
            "#include <sys/malloc.h>",
            "#include <dev/isa/isadmareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void isa_dmamask",
            "void *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;",
            "int chan;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/malloc.h>\n#include <dev/isa/isadmareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic inline void isa_dmamask;\nvoid *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;\nint chan;\n\nvoid\nisa_dmaabort(isadev, chan)\n\tstruct device *isadev;\n\tint chan;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\n\tif (chan < 0 || chan > 7) {\n\t\tpanic(\"isa_dmaabort: %s: bogus drq %d\", sc->sc_dev.dv_xname,\n\t\t    chan);\n\t}\n\n\tisa_dmamask(sc, chan);\n\tbus_dmamap_unload(sc->sc_dmat, sc->sc_dmamaps[chan]);\n\tsc->sc_dmareads &= ~(1 << chan);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "bus_space_read_1(iot, ioh2, GUS_DATA_HIGH) & ~(GUSMASK_SAMPLE_START|GUSMASK_SAMPLE_IRQ)"
          ],
          "line": 2431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH"
          ],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_SAMPLE_CONTROL"
          ],
          "line": 2430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMAPRINTF",
          "args": [
            "(\"gus_halt_in_dma called\\n\")"
          ],
          "line": 2424
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngus_halt_in_dma(addr)\n\tvoid * addr;\n{\n \tstruct gus_softc *sc = addr;\n \tbus_space_tag_t iot = sc->sc_iot;\n \tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tDMAPRINTF((\"gus_halt_in_dma called\\n\"));\n\n\t/*\n\t * Make sure the GUS _isn't_ setup for DMA\n\t */\n\n  \tSELECT_GUS_REG(iot, ioh2, GUSREG_SAMPLE_CONTROL);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH,\n \t     bus_space_read_1(iot, ioh2, GUS_DATA_HIGH) & ~(GUSMASK_SAMPLE_START|GUSMASK_SAMPLE_IRQ));\n  \n \tisa_dmaabort(sc->sc_dev.dv_parent, sc->sc_recdrq);\n\tsc->sc_flags &= ~GUS_DMAIN_ACTIVE;\n\tsc->sc_dmainintr = 0;\n\tsc->sc_inarg = 0;\n\tsc->sc_dmainaddr = 0;\n\tsc->sc_dmaincnt = 0;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "gus_halt_out_dma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "2381-2412",
    "snippet": "int\ngus_halt_out_dma(addr)\n\tvoid * addr;\n{\n \tstruct gus_softc *sc = addr;\n \tbus_space_tag_t iot = sc->sc_iot;\n \tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\n\tDMAPRINTF((\"gus_halt_out_dma called\\n\"));\n\t/*\n\t * Make sure the GUS _isn't_ setup for DMA\n\t */\n\n  \tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0);\n\n\tuntimeout(gus_dmaout_timeout, sc);\n \tisa_dmaabort(sc->sc_dev.dv_parent, sc->sc_drq);\n\tsc->sc_flags &= ~(GUS_DMAOUT_ACTIVE|GUS_LOCKED);\n\tsc->sc_dmaoutintr = 0;\n\tsc->sc_outarg = 0;\n\tsc->sc_dmaoutaddr = 0;\n\tsc->sc_dmaoutcnt = 0;\n\tsc->sc_dmabuf = 0;\n\tsc->sc_bufcnt = 0;\n\tsc->sc_playbuf = -1;\n\t/* also stop playing */\n\tgus_stop_voice(sc, GUS_VOICE_LEFT, 1);\n\tgus_stop_voice(sc, GUS_VOICE_RIGHT, 0);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gus_stop_voice",
          "args": [
            "sc",
            "GUS_VOICE_RIGHT",
            "0"
          ],
          "line": 2409
        },
        "resolved": true,
        "details": {
          "function_name": "gus_stop_voice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "1435-1472",
          "snippet": "void\ngus_stop_voice(sc, voice, intrs_too)\n\tstruct gus_softc *sc;\n\tint voice;\n\tint intrs_too;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\n\tsc->sc_voc[voice].voccntl |= GUSMASK_VOICE_STOPPED |\n\t\tGUSMASK_STOP_VOICE;\n\tif (intrs_too) {\n\t  sc->sc_voc[voice].voccntl &= ~(GUSMASK_VOICE_IRQ);\n\t  /* no more DMA to do */\n\t  sc->sc_flags &= ~GUS_PLAYING;\n\t}\n\tDMAPRINTF((\"gusintr voice notplaying=%x\\n\", sc->sc_flags));\n\n\tguspoke(iot, ioh2, 0L, 0);\n\n\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, (unsigned char) voice);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_VOLUME);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].voccntl);\n\tdelay(100);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_VOLUME);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].voccntl);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_HIGH);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_LOW);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ngus_stop_voice(sc, voice, intrs_too)\n\tstruct gus_softc *sc;\n\tint voice;\n\tint intrs_too;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\n\tsc->sc_voc[voice].voccntl |= GUSMASK_VOICE_STOPPED |\n\t\tGUSMASK_STOP_VOICE;\n\tif (intrs_too) {\n\t  sc->sc_voc[voice].voccntl &= ~(GUSMASK_VOICE_IRQ);\n\t  /* no more DMA to do */\n\t  sc->sc_flags &= ~GUS_PLAYING;\n\t}\n\tDMAPRINTF((\"gusintr voice notplaying=%x\\n\", sc->sc_flags));\n\n\tguspoke(iot, ioh2, 0L, 0);\n\n\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, (unsigned char) voice);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_VOLUME);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].voccntl);\n\tdelay(100);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_VOLUME);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].voccntl);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_HIGH);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_LOW);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "isa_dmaabort",
          "args": [
            "sc->sc_dev.dv_parent",
            "sc->sc_drq"
          ],
          "line": 2398
        },
        "resolved": true,
        "details": {
          "function_name": "isa_dmaabort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/isadma.c",
          "lines": "424-439",
          "snippet": "void\nisa_dmaabort(isadev, chan)\n\tstruct device *isadev;\n\tint chan;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\n\tif (chan < 0 || chan > 7) {\n\t\tpanic(\"isa_dmaabort: %s: bogus drq %d\", sc->sc_dev.dv_xname,\n\t\t    chan);\n\t}\n\n\tisa_dmamask(sc, chan);\n\tbus_dmamap_unload(sc->sc_dmat, sc->sc_dmamaps[chan]);\n\tsc->sc_dmareads &= ~(1 << chan);\n}",
          "includes": [
            "#include <sys/malloc.h>",
            "#include <dev/isa/isadmareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void isa_dmamask",
            "void *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;",
            "int chan;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/malloc.h>\n#include <dev/isa/isadmareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic inline void isa_dmamask;\nvoid *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;\nint chan;\n\nvoid\nisa_dmaabort(isadev, chan)\n\tstruct device *isadev;\n\tint chan;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\n\tif (chan < 0 || chan > 7) {\n\t\tpanic(\"isa_dmaabort: %s: bogus drq %d\", sc->sc_dev.dv_xname,\n\t\t    chan);\n\t}\n\n\tisa_dmamask(sc, chan);\n\tbus_dmamap_unload(sc->sc_dmat, sc->sc_dmamaps[chan]);\n\tsc->sc_dmareads &= ~(1 << chan);\n}"
        }
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "gus_dmaout_timeout",
            "sc"
          ],
          "line": 2397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "0"
          ],
          "line": 2395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_DMA_CONTROL"
          ],
          "line": 2394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMAPRINTF",
          "args": [
            "(\"gus_halt_out_dma called\\n\")"
          ],
          "line": 2389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngus_halt_out_dma(addr)\n\tvoid * addr;\n{\n \tstruct gus_softc *sc = addr;\n \tbus_space_tag_t iot = sc->sc_iot;\n \tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\n\tDMAPRINTF((\"gus_halt_out_dma called\\n\"));\n\t/*\n\t * Make sure the GUS _isn't_ setup for DMA\n\t */\n\n  \tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0);\n\n\tuntimeout(gus_dmaout_timeout, sc);\n \tisa_dmaabort(sc->sc_dev.dv_parent, sc->sc_drq);\n\tsc->sc_flags &= ~(GUS_DMAOUT_ACTIVE|GUS_LOCKED);\n\tsc->sc_dmaoutintr = 0;\n\tsc->sc_outarg = 0;\n\tsc->sc_dmaoutaddr = 0;\n\tsc->sc_dmaoutcnt = 0;\n\tsc->sc_dmabuf = 0;\n\tsc->sc_bufcnt = 0;\n\tsc->sc_playbuf = -1;\n\t/* also stop playing */\n\tgus_stop_voice(sc, GUS_VOICE_LEFT, 1);\n\tgus_stop_voice(sc, GUS_VOICE_RIGHT, 0);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "gusmax_halt_in_dma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "2370-2376",
    "snippet": "int\ngusmax_halt_in_dma(addr)\n\tvoid * addr;\n{\n\tstruct ad1848_softc *sc = addr;\n\treturn gus_halt_in_dma(sc->parent);\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gus_halt_in_dma",
          "args": [
            "sc->parent"
          ],
          "line": 2375
        },
        "resolved": true,
        "details": {
          "function_name": "gus_halt_in_dma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "2417-2442",
          "snippet": "int\ngus_halt_in_dma(addr)\n\tvoid * addr;\n{\n \tstruct gus_softc *sc = addr;\n \tbus_space_tag_t iot = sc->sc_iot;\n \tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tDMAPRINTF((\"gus_halt_in_dma called\\n\"));\n\n\t/*\n\t * Make sure the GUS _isn't_ setup for DMA\n\t */\n\n  \tSELECT_GUS_REG(iot, ioh2, GUSREG_SAMPLE_CONTROL);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH,\n \t     bus_space_read_1(iot, ioh2, GUS_DATA_HIGH) & ~(GUSMASK_SAMPLE_START|GUSMASK_SAMPLE_IRQ));\n  \n \tisa_dmaabort(sc->sc_dev.dv_parent, sc->sc_recdrq);\n\tsc->sc_flags &= ~GUS_DMAIN_ACTIVE;\n\tsc->sc_dmainintr = 0;\n\tsc->sc_inarg = 0;\n\tsc->sc_dmainaddr = 0;\n\tsc->sc_dmaincnt = 0;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngus_halt_in_dma(addr)\n\tvoid * addr;\n{\n \tstruct gus_softc *sc = addr;\n \tbus_space_tag_t iot = sc->sc_iot;\n \tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tDMAPRINTF((\"gus_halt_in_dma called\\n\"));\n\n\t/*\n\t * Make sure the GUS _isn't_ setup for DMA\n\t */\n\n  \tSELECT_GUS_REG(iot, ioh2, GUSREG_SAMPLE_CONTROL);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH,\n \t     bus_space_read_1(iot, ioh2, GUS_DATA_HIGH) & ~(GUSMASK_SAMPLE_START|GUSMASK_SAMPLE_IRQ));\n  \n \tisa_dmaabort(sc->sc_dev.dv_parent, sc->sc_recdrq);\n\tsc->sc_flags &= ~GUS_DMAIN_ACTIVE;\n\tsc->sc_dmainintr = 0;\n\tsc->sc_inarg = 0;\n\tsc->sc_dmainaddr = 0;\n\tsc->sc_dmaincnt = 0;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngusmax_halt_in_dma(addr)\n\tvoid * addr;\n{\n\tstruct ad1848_softc *sc = addr;\n\treturn gus_halt_in_dma(sc->parent);\n}"
  },
  {
    "function_name": "gusmax_halt_out_dma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "2361-2367",
    "snippet": "int\ngusmax_halt_out_dma(addr)\n\tvoid * addr;\n{\n\tstruct ad1848_softc *sc = addr;\n\treturn gus_halt_out_dma(sc->parent);\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gus_halt_out_dma",
          "args": [
            "sc->parent"
          ],
          "line": 2366
        },
        "resolved": true,
        "details": {
          "function_name": "gus_halt_out_dma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "2381-2412",
          "snippet": "int\ngus_halt_out_dma(addr)\n\tvoid * addr;\n{\n \tstruct gus_softc *sc = addr;\n \tbus_space_tag_t iot = sc->sc_iot;\n \tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\n\tDMAPRINTF((\"gus_halt_out_dma called\\n\"));\n\t/*\n\t * Make sure the GUS _isn't_ setup for DMA\n\t */\n\n  \tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0);\n\n\tuntimeout(gus_dmaout_timeout, sc);\n \tisa_dmaabort(sc->sc_dev.dv_parent, sc->sc_drq);\n\tsc->sc_flags &= ~(GUS_DMAOUT_ACTIVE|GUS_LOCKED);\n\tsc->sc_dmaoutintr = 0;\n\tsc->sc_outarg = 0;\n\tsc->sc_dmaoutaddr = 0;\n\tsc->sc_dmaoutcnt = 0;\n\tsc->sc_dmabuf = 0;\n\tsc->sc_bufcnt = 0;\n\tsc->sc_playbuf = -1;\n\t/* also stop playing */\n\tgus_stop_voice(sc, GUS_VOICE_LEFT, 1);\n\tgus_stop_voice(sc, GUS_VOICE_RIGHT, 0);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngus_halt_out_dma(addr)\n\tvoid * addr;\n{\n \tstruct gus_softc *sc = addr;\n \tbus_space_tag_t iot = sc->sc_iot;\n \tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\n\tDMAPRINTF((\"gus_halt_out_dma called\\n\"));\n\t/*\n\t * Make sure the GUS _isn't_ setup for DMA\n\t */\n\n  \tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0);\n\n\tuntimeout(gus_dmaout_timeout, sc);\n \tisa_dmaabort(sc->sc_dev.dv_parent, sc->sc_drq);\n\tsc->sc_flags &= ~(GUS_DMAOUT_ACTIVE|GUS_LOCKED);\n\tsc->sc_dmaoutintr = 0;\n\tsc->sc_outarg = 0;\n\tsc->sc_dmaoutaddr = 0;\n\tsc->sc_dmaoutcnt = 0;\n\tsc->sc_dmabuf = 0;\n\tsc->sc_bufcnt = 0;\n\tsc->sc_playbuf = -1;\n\t/* also stop playing */\n\tgus_stop_voice(sc, GUS_VOICE_LEFT, 1);\n\tgus_stop_voice(sc, GUS_VOICE_RIGHT, 0);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngusmax_halt_out_dma(addr)\n\tvoid * addr;\n{\n\tstruct ad1848_softc *sc = addr;\n\treturn gus_halt_out_dma(sc->parent);\n}"
  },
  {
    "function_name": "gus_dmain_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "2333-2359",
    "snippet": "int\ngus_dmain_intr(sc)\n\tstruct gus_softc *sc;\n{\n        void (*callback) __P((void *));\n\tvoid *arg;\n\n\tDMAPRINTF((\"gus_dmain_intr called\\n\"));\n\tif (sc->sc_dmainintr) {\n \t    isa_dmadone(sc->sc_dev.dv_parent, sc->sc_recdrq);\n\t    callback = sc->sc_dmainintr;\n\t    arg = sc->sc_inarg;\n\n\t    sc->sc_dmainaddr = 0;\n\t    sc->sc_dmaincnt = 0;\n\t    sc->sc_dmainintr = 0;\n\t    sc->sc_inarg = 0;\n\n\t    sc->sc_flags &= ~GUS_DMAIN_ACTIVE;\n\t    DMAPRINTF((\"calling dmain_intr callback %p(%p)\\n\", callback, arg));\n\t    (*callback)(arg);\n\t    return 1;\n\t} else {\n\t    DMAPRINTF((\"gus_dmain_intr false?\\n\"));\n\t    return 0;\t\t\t/* XXX ??? */\n\t}\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DMAPRINTF",
          "args": [
            "(\"gus_dmain_intr false?\\n\")"
          ],
          "line": 2356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "arg"
          ],
          "line": 2353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMAPRINTF",
          "args": [
            "(\"calling dmain_intr callback %p(%p)\\n\", callback, arg)"
          ],
          "line": 2352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isa_dmadone",
          "args": [
            "sc->sc_dev.dv_parent",
            "sc->sc_recdrq"
          ],
          "line": 2342
        },
        "resolved": true,
        "details": {
          "function_name": "isa_dmadone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/isadma.c",
          "lines": "513-540",
          "snippet": "void\nisa_dmadone(isadev, chan)\n\tstruct device *isadev;\n\tint chan;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tbus_dmamap_t dmam;\n\n\tif (chan < 0 || chan > 7) {\n\t\tpanic(\"isa_dmadone: %s: bogus drq %d\", sc->sc_dev.dv_xname,\n\t\t    chan);\n\t}\n\n\tdmam = sc->sc_dmamaps[chan];\n\n\tisa_dmamask(sc, chan);\n\n\tif (isa_dmafinished(isadev, chan) == 0)\n\t\tprintf(\"%s: isa_dmadone: channel %d not finished\\n\",\n\t\t    sc->sc_dev.dv_xname, chan);\n\n\tbus_dmamap_sync(sc->sc_dmat, dmam,\n\t    (sc->sc_dmareads & (1 << chan)) ? BUS_DMASYNC_POSTREAD :\n\t    BUS_DMASYNC_POSTWRITE);\n\n\tbus_dmamap_unload(sc->sc_dmat, dmam);\n\tsc->sc_dmareads &= ~(1 << chan);\n}",
          "includes": [
            "#include <sys/malloc.h>",
            "#include <dev/isa/isadmareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void isa_dmamask",
            "void *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;",
            "int chan;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/malloc.h>\n#include <dev/isa/isadmareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic inline void isa_dmamask;\nvoid *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;\nint chan;\n\nvoid\nisa_dmadone(isadev, chan)\n\tstruct device *isadev;\n\tint chan;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tbus_dmamap_t dmam;\n\n\tif (chan < 0 || chan > 7) {\n\t\tpanic(\"isa_dmadone: %s: bogus drq %d\", sc->sc_dev.dv_xname,\n\t\t    chan);\n\t}\n\n\tdmam = sc->sc_dmamaps[chan];\n\n\tisa_dmamask(sc, chan);\n\n\tif (isa_dmafinished(isadev, chan) == 0)\n\t\tprintf(\"%s: isa_dmadone: channel %d not finished\\n\",\n\t\t    sc->sc_dev.dv_xname, chan);\n\n\tbus_dmamap_sync(sc->sc_dmat, dmam,\n\t    (sc->sc_dmareads & (1 << chan)) ? BUS_DMASYNC_POSTREAD :\n\t    BUS_DMASYNC_POSTWRITE);\n\n\tbus_dmamap_unload(sc->sc_dmat, dmam);\n\tsc->sc_dmareads &= ~(1 << chan);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DMAPRINTF",
          "args": [
            "(\"gus_dmain_intr called\\n\")"
          ],
          "line": 2340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__P",
          "args": [
            "(void *)"
          ],
          "line": 2337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngus_dmain_intr(sc)\n\tstruct gus_softc *sc;\n{\n        void (*callback) __P((void *));\n\tvoid *arg;\n\n\tDMAPRINTF((\"gus_dmain_intr called\\n\"));\n\tif (sc->sc_dmainintr) {\n \t    isa_dmadone(sc->sc_dev.dv_parent, sc->sc_recdrq);\n\t    callback = sc->sc_dmainintr;\n\t    arg = sc->sc_inarg;\n\n\t    sc->sc_dmainaddr = 0;\n\t    sc->sc_dmaincnt = 0;\n\t    sc->sc_dmainintr = 0;\n\t    sc->sc_inarg = 0;\n\n\t    sc->sc_flags &= ~GUS_DMAIN_ACTIVE;\n\t    DMAPRINTF((\"calling dmain_intr callback %p(%p)\\n\", callback, arg));\n\t    (*callback)(arg);\n\t    return 1;\n\t} else {\n\t    DMAPRINTF((\"gus_dmain_intr false?\\n\"));\n\t    return 0;\t\t\t/* XXX ??? */\n\t}\n}"
  },
  {
    "function_name": "gus_dma_input",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "2282-2331",
    "snippet": "int\ngus_dma_input(addr, buf, size, callback, arg)\n\tvoid * addr;\n\tvoid *buf;\n\tint size;\n\tvoid (*callback) __P((void *));\n\tvoid *arg;\n{\n\tstruct gus_softc *sc = addr;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tu_char dmac;\n\tDMAPRINTF((\"gus_dma_input called\\n\"));\n    \n\t/*\n\t * Sample SIZE bytes of data from the card, into buffer at BUF.\n\t */\n\n\tif (sc->sc_precision == 16)\n\t    return EINVAL;\t\t/* XXX */\n\n\t/* set DMA modes */\n\tdmac = GUSMASK_SAMPLE_IRQ|GUSMASK_SAMPLE_START;\n\tif (sc->sc_recdrq >= 4)\n\t\tdmac |= GUSMASK_SAMPLE_DATA16;\n\tif (sc->sc_encoding == AUDIO_ENCODING_ULAW ||\n \t    sc->sc_encoding == AUDIO_ENCODING_ALAW ||\n \t    sc->sc_encoding == AUDIO_ENCODING_ULINEAR_LE ||\n \t    sc->sc_encoding == AUDIO_ENCODING_ULINEAR_BE)\n\t    dmac |= GUSMASK_SAMPLE_INVBIT;\n\tif (sc->sc_channels == 2)\n\t    dmac |= GUSMASK_SAMPLE_STEREO;\n \tisa_dmastart(sc->sc_dev.dv_parent, sc->sc_recdrq, buf, size,\n \t    NULL, DMAMODE_READ, BUS_DMA_NOWAIT);\n\n\tDMAPRINTF((\"gus_dma_input isadma_started\\n\"));\n\tsc->sc_flags |= GUS_DMAIN_ACTIVE;\n\tsc->sc_dmainintr = callback;\n\tsc->sc_inarg = arg;\n\tsc->sc_dmaincnt = size;\n\tsc->sc_dmainaddr = buf;\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_SAMPLE_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, dmac);\t/* Go! */\n\n\n\tDMAPRINTF((\"gus_dma_input returning\\n\"));\n\n\treturn 0;\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DMAPRINTF",
          "args": [
            "(\"gus_dma_input returning\\n\")"
          ],
          "line": 2328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "dmac"
          ],
          "line": 2325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_SAMPLE_CONTROL"
          ],
          "line": 2324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMAPRINTF",
          "args": [
            "(\"gus_dma_input isadma_started\\n\")"
          ],
          "line": 2317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isa_dmastart",
          "args": [
            "sc->sc_dev.dv_parent",
            "sc->sc_recdrq",
            "buf",
            "size",
            "NULL",
            "DMAMODE_READ",
            "BUS_DMA_NOWAIT"
          ],
          "line": 2314
        },
        "resolved": true,
        "details": {
          "function_name": "isa_dmastart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/isadma.c",
          "lines": "288-422",
          "snippet": "int\nisa_dmastart(isadev, chan, addr, nbytes, p, flags, busdmaflags)\n\tstruct device *isadev;\n\tint chan;\n\tvoid *addr;\n\tbus_size_t nbytes;\n\tstruct proc *p;\n\tint flags;\n\tint busdmaflags;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tbus_dmamap_t dmam;\n\tbus_addr_t dmaaddr;\n\tint waport;\n\tint ochan = chan & 3;\n\tint error;\n#ifdef __ISADMA_COMPAT\n\tint compat = busdmaflags & BUS_DMA_BUS1;\n\n\tbusdmaflags &= ~BUS_DMA_BUS1;\n#endif /* __ISADMA_COMPAT */\n\n\tif (chan < 0 || chan > 7) {\n\t\tprintf(\"%s: bogus drq %d\\n\", sc->sc_dev.dv_xname, chan);\n\t\tgoto lose;\n\t}\n\n#ifdef ISADMA_DEBUG\n\tprintf(\"isa_dmastart: drq %d, addr %p, nbytes 0x%lx, p %p, \"\n\t    \"flags 0x%x, dmaflags 0x%x\\n\",\n\t    chan, addr, nbytes, p, flags, busdmaflags);\n#endif\n\n\tif (chan & 4) {\n\t\tif (nbytes > (1 << 17) || nbytes & 1 || (u_long)addr & 1) {\n\t\t\tprintf(\"%s: drq %d, nbytes 0x%lx, addr %p\\n\",\n\t\t\t    sc->sc_dev.dv_xname, chan, nbytes, addr);\n\t\t\tgoto lose;\n\t\t}\n\t} else {\n\t\tif (nbytes > (1 << 16)) {\n\t\t\tprintf(\"%s: drq %d, nbytes 0x%lx\\n\",\n\t\t\t    sc->sc_dev.dv_xname, chan, nbytes);\n\t\t\tgoto lose;\n\t\t}\n\t}\n\n\tdmam = sc->sc_dmamaps[chan];\n\tif (dmam == NULL) {\n#ifdef __ISADMA_COMPAT\n\t\tif (compat)\n\t\t\tdmam = sc->sc_dmamaps[chan] = isadma_dmam[chan];\n\t\telse\n#endif /* __ISADMA_COMPAT */\n\t\tpanic(\"isa_dmastart: no DMA map for chan %d\", chan);\n\t}\n\n\terror = bus_dmamap_load(sc->sc_dmat, dmam, addr, nbytes, p,\n\t    busdmaflags);\n\tif (error)\n\t\treturn (error);\n\n#ifdef ISADMA_DEBUG\n\t__asm(\".globl isa_dmastart_afterload ; isa_dmastart_afterload:\");\n#endif\n\n\tif (flags & DMAMODE_READ) {\n\t\tbus_dmamap_sync(sc->sc_dmat, dmam, BUS_DMASYNC_PREREAD);\n\t\tsc->sc_dmareads |= (1 << chan);\n\t} else {\n\t\tbus_dmamap_sync(sc->sc_dmat, dmam, BUS_DMASYNC_PREWRITE);\n\t\tsc->sc_dmareads &= ~(1 << chan);\n\t}\n\n\tdmaaddr = dmam->dm_segs[0].ds_addr;\n\n#ifdef ISADMA_DEBUG\n\tprintf(\"     dmaaddr 0x%lx\\n\", dmaaddr);\n\n\t__asm(\".globl isa_dmastart_aftersync ; isa_dmastart_aftersync:\");\n#endif\n\n\tsc->sc_dmalength[chan] = nbytes;\n\n\tisa_dmamask(sc, chan);\n\tsc->sc_dmafinished &= ~(1 << chan);\n\n\tif ((chan & 4) == 0) {\n\t\t/* set dma channel mode */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, DMA1_MODE,\n\t\t    ochan | dmamode[flags]);\n\n\t\t/* send start address */\n\t\twaport = DMA1_CHN(ochan);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dmapgh,\n\t\t    dmapageport[0][ochan], (dmaaddr >> 16) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport,\n\t\t    dmaaddr & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport,\n\t\t    (dmaaddr >> 8) & 0xff);\n\n\t\t/* send count */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport + 1,\n\t\t    (--nbytes) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport + 1,\n\t\t    (nbytes >> 8) & 0xff);\n\t} else {\n\t\t/* set dma channel mode */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, DMA2_MODE,\n\t\t    ochan | dmamode[flags]);\n\n\t\t/* send start address */\n\t\twaport = DMA2_CHN(ochan);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dmapgh,\n\t\t    dmapageport[1][ochan], (dmaaddr >> 16) & 0xff);\n\t\tdmaaddr >>= 1;\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport,\n\t\t    dmaaddr & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport,\n\t\t    (dmaaddr >> 8) & 0xff);\n\n\t\t/* send count */\n\t\tnbytes >>= 1;\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport + 2,\n\t\t    (--nbytes) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport + 2,\n\t\t    (nbytes >> 8) & 0xff);\n\t}\n\n\tisa_dmaunmask(sc, chan);\n\treturn (0);\n\n lose:\n\tpanic(\"isa_dmastart\");\n}",
          "includes": [
            "#include <sys/malloc.h>",
            "#include <dev/isa/isadmareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dmapageport[2][4] = {\n\t{0x7, 0x3, 0x1, 0x2},\n\t{0xf, 0xb, 0x9, 0xa}\n};",
            "static u_int8_t dmamode[4] = {\n\tDMA37MD_READ | DMA37MD_SINGLE,\n\tDMA37MD_WRITE | DMA37MD_SINGLE,\n\tDMA37MD_READ | DMA37MD_SINGLE | DMA37MD_LOOP,\n\tDMA37MD_WRITE | DMA37MD_SINGLE | DMA37MD_LOOP\n};",
            "static inline void isa_dmaunmask",
            "static inline void isa_dmamask",
            "void *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;",
            "int chan;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/malloc.h>\n#include <dev/isa/isadmareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int dmapageport[2][4] = {\n\t{0x7, 0x3, 0x1, 0x2},\n\t{0xf, 0xb, 0x9, 0xa}\n};\nstatic u_int8_t dmamode[4] = {\n\tDMA37MD_READ | DMA37MD_SINGLE,\n\tDMA37MD_WRITE | DMA37MD_SINGLE,\n\tDMA37MD_READ | DMA37MD_SINGLE | DMA37MD_LOOP,\n\tDMA37MD_WRITE | DMA37MD_SINGLE | DMA37MD_LOOP\n};\nstatic inline void isa_dmaunmask;\nstatic inline void isa_dmamask;\nvoid *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;\nint chan;\nint flags;\n\nint\nisa_dmastart(isadev, chan, addr, nbytes, p, flags, busdmaflags)\n\tstruct device *isadev;\n\tint chan;\n\tvoid *addr;\n\tbus_size_t nbytes;\n\tstruct proc *p;\n\tint flags;\n\tint busdmaflags;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tbus_dmamap_t dmam;\n\tbus_addr_t dmaaddr;\n\tint waport;\n\tint ochan = chan & 3;\n\tint error;\n#ifdef __ISADMA_COMPAT\n\tint compat = busdmaflags & BUS_DMA_BUS1;\n\n\tbusdmaflags &= ~BUS_DMA_BUS1;\n#endif /* __ISADMA_COMPAT */\n\n\tif (chan < 0 || chan > 7) {\n\t\tprintf(\"%s: bogus drq %d\\n\", sc->sc_dev.dv_xname, chan);\n\t\tgoto lose;\n\t}\n\n#ifdef ISADMA_DEBUG\n\tprintf(\"isa_dmastart: drq %d, addr %p, nbytes 0x%lx, p %p, \"\n\t    \"flags 0x%x, dmaflags 0x%x\\n\",\n\t    chan, addr, nbytes, p, flags, busdmaflags);\n#endif\n\n\tif (chan & 4) {\n\t\tif (nbytes > (1 << 17) || nbytes & 1 || (u_long)addr & 1) {\n\t\t\tprintf(\"%s: drq %d, nbytes 0x%lx, addr %p\\n\",\n\t\t\t    sc->sc_dev.dv_xname, chan, nbytes, addr);\n\t\t\tgoto lose;\n\t\t}\n\t} else {\n\t\tif (nbytes > (1 << 16)) {\n\t\t\tprintf(\"%s: drq %d, nbytes 0x%lx\\n\",\n\t\t\t    sc->sc_dev.dv_xname, chan, nbytes);\n\t\t\tgoto lose;\n\t\t}\n\t}\n\n\tdmam = sc->sc_dmamaps[chan];\n\tif (dmam == NULL) {\n#ifdef __ISADMA_COMPAT\n\t\tif (compat)\n\t\t\tdmam = sc->sc_dmamaps[chan] = isadma_dmam[chan];\n\t\telse\n#endif /* __ISADMA_COMPAT */\n\t\tpanic(\"isa_dmastart: no DMA map for chan %d\", chan);\n\t}\n\n\terror = bus_dmamap_load(sc->sc_dmat, dmam, addr, nbytes, p,\n\t    busdmaflags);\n\tif (error)\n\t\treturn (error);\n\n#ifdef ISADMA_DEBUG\n\t__asm(\".globl isa_dmastart_afterload ; isa_dmastart_afterload:\");\n#endif\n\n\tif (flags & DMAMODE_READ) {\n\t\tbus_dmamap_sync(sc->sc_dmat, dmam, BUS_DMASYNC_PREREAD);\n\t\tsc->sc_dmareads |= (1 << chan);\n\t} else {\n\t\tbus_dmamap_sync(sc->sc_dmat, dmam, BUS_DMASYNC_PREWRITE);\n\t\tsc->sc_dmareads &= ~(1 << chan);\n\t}\n\n\tdmaaddr = dmam->dm_segs[0].ds_addr;\n\n#ifdef ISADMA_DEBUG\n\tprintf(\"     dmaaddr 0x%lx\\n\", dmaaddr);\n\n\t__asm(\".globl isa_dmastart_aftersync ; isa_dmastart_aftersync:\");\n#endif\n\n\tsc->sc_dmalength[chan] = nbytes;\n\n\tisa_dmamask(sc, chan);\n\tsc->sc_dmafinished &= ~(1 << chan);\n\n\tif ((chan & 4) == 0) {\n\t\t/* set dma channel mode */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, DMA1_MODE,\n\t\t    ochan | dmamode[flags]);\n\n\t\t/* send start address */\n\t\twaport = DMA1_CHN(ochan);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dmapgh,\n\t\t    dmapageport[0][ochan], (dmaaddr >> 16) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport,\n\t\t    dmaaddr & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport,\n\t\t    (dmaaddr >> 8) & 0xff);\n\n\t\t/* send count */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport + 1,\n\t\t    (--nbytes) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport + 1,\n\t\t    (nbytes >> 8) & 0xff);\n\t} else {\n\t\t/* set dma channel mode */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, DMA2_MODE,\n\t\t    ochan | dmamode[flags]);\n\n\t\t/* send start address */\n\t\twaport = DMA2_CHN(ochan);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dmapgh,\n\t\t    dmapageport[1][ochan], (dmaaddr >> 16) & 0xff);\n\t\tdmaaddr >>= 1;\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport,\n\t\t    dmaaddr & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport,\n\t\t    (dmaaddr >> 8) & 0xff);\n\n\t\t/* send count */\n\t\tnbytes >>= 1;\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport + 2,\n\t\t    (--nbytes) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport + 2,\n\t\t    (nbytes >> 8) & 0xff);\n\t}\n\n\tisa_dmaunmask(sc, chan);\n\treturn (0);\n\n lose:\n\tpanic(\"isa_dmastart\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "DMAPRINTF",
          "args": [
            "(\"gus_dma_input called\\n\")"
          ],
          "line": 2294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngus_dma_input(addr, buf, size, callback, arg)\n\tvoid * addr;\n\tvoid *buf;\n\tint size;\n\tvoid (*callback) __P((void *));\n\tvoid *arg;\n{\n\tstruct gus_softc *sc = addr;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tu_char dmac;\n\tDMAPRINTF((\"gus_dma_input called\\n\"));\n    \n\t/*\n\t * Sample SIZE bytes of data from the card, into buffer at BUF.\n\t */\n\n\tif (sc->sc_precision == 16)\n\t    return EINVAL;\t\t/* XXX */\n\n\t/* set DMA modes */\n\tdmac = GUSMASK_SAMPLE_IRQ|GUSMASK_SAMPLE_START;\n\tif (sc->sc_recdrq >= 4)\n\t\tdmac |= GUSMASK_SAMPLE_DATA16;\n\tif (sc->sc_encoding == AUDIO_ENCODING_ULAW ||\n \t    sc->sc_encoding == AUDIO_ENCODING_ALAW ||\n \t    sc->sc_encoding == AUDIO_ENCODING_ULINEAR_LE ||\n \t    sc->sc_encoding == AUDIO_ENCODING_ULINEAR_BE)\n\t    dmac |= GUSMASK_SAMPLE_INVBIT;\n\tif (sc->sc_channels == 2)\n\t    dmac |= GUSMASK_SAMPLE_STEREO;\n \tisa_dmastart(sc->sc_dev.dv_parent, sc->sc_recdrq, buf, size,\n \t    NULL, DMAMODE_READ, BUS_DMA_NOWAIT);\n\n\tDMAPRINTF((\"gus_dma_input isadma_started\\n\"));\n\tsc->sc_flags |= GUS_DMAIN_ACTIVE;\n\tsc->sc_dmainintr = callback;\n\tsc->sc_inarg = arg;\n\tsc->sc_dmaincnt = size;\n\tsc->sc_dmainaddr = buf;\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_SAMPLE_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, dmac);\t/* Go! */\n\n\n\tDMAPRINTF((\"gus_dma_input returning\\n\"));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "gusmax_dma_input",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "2266-2276",
    "snippet": "int\ngusmax_dma_input(addr, buf, size, callback, arg)\n\tvoid * addr;\n\tvoid *buf;\n\tint size;\n\tvoid (*callback) __P((void *));\n\tvoid *arg;\n{\n\tstruct ad1848_softc *sc = addr;\n\treturn gus_dma_input(sc->parent, buf, size, callback, arg);\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gus_dma_input",
          "args": [
            "sc->parent",
            "buf",
            "size",
            "callback",
            "arg"
          ],
          "line": 2275
        },
        "resolved": true,
        "details": {
          "function_name": "gus_dma_input",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "2282-2331",
          "snippet": "int\ngus_dma_input(addr, buf, size, callback, arg)\n\tvoid * addr;\n\tvoid *buf;\n\tint size;\n\tvoid (*callback) __P((void *));\n\tvoid *arg;\n{\n\tstruct gus_softc *sc = addr;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tu_char dmac;\n\tDMAPRINTF((\"gus_dma_input called\\n\"));\n    \n\t/*\n\t * Sample SIZE bytes of data from the card, into buffer at BUF.\n\t */\n\n\tif (sc->sc_precision == 16)\n\t    return EINVAL;\t\t/* XXX */\n\n\t/* set DMA modes */\n\tdmac = GUSMASK_SAMPLE_IRQ|GUSMASK_SAMPLE_START;\n\tif (sc->sc_recdrq >= 4)\n\t\tdmac |= GUSMASK_SAMPLE_DATA16;\n\tif (sc->sc_encoding == AUDIO_ENCODING_ULAW ||\n \t    sc->sc_encoding == AUDIO_ENCODING_ALAW ||\n \t    sc->sc_encoding == AUDIO_ENCODING_ULINEAR_LE ||\n \t    sc->sc_encoding == AUDIO_ENCODING_ULINEAR_BE)\n\t    dmac |= GUSMASK_SAMPLE_INVBIT;\n\tif (sc->sc_channels == 2)\n\t    dmac |= GUSMASK_SAMPLE_STEREO;\n \tisa_dmastart(sc->sc_dev.dv_parent, sc->sc_recdrq, buf, size,\n \t    NULL, DMAMODE_READ, BUS_DMA_NOWAIT);\n\n\tDMAPRINTF((\"gus_dma_input isadma_started\\n\"));\n\tsc->sc_flags |= GUS_DMAIN_ACTIVE;\n\tsc->sc_dmainintr = callback;\n\tsc->sc_inarg = arg;\n\tsc->sc_dmaincnt = size;\n\tsc->sc_dmainaddr = buf;\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_SAMPLE_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, dmac);\t/* Go! */\n\n\n\tDMAPRINTF((\"gus_dma_input returning\\n\"));\n\n\treturn 0;\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngus_dma_input(addr, buf, size, callback, arg)\n\tvoid * addr;\n\tvoid *buf;\n\tint size;\n\tvoid (*callback) __P((void *));\n\tvoid *arg;\n{\n\tstruct gus_softc *sc = addr;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tu_char dmac;\n\tDMAPRINTF((\"gus_dma_input called\\n\"));\n    \n\t/*\n\t * Sample SIZE bytes of data from the card, into buffer at BUF.\n\t */\n\n\tif (sc->sc_precision == 16)\n\t    return EINVAL;\t\t/* XXX */\n\n\t/* set DMA modes */\n\tdmac = GUSMASK_SAMPLE_IRQ|GUSMASK_SAMPLE_START;\n\tif (sc->sc_recdrq >= 4)\n\t\tdmac |= GUSMASK_SAMPLE_DATA16;\n\tif (sc->sc_encoding == AUDIO_ENCODING_ULAW ||\n \t    sc->sc_encoding == AUDIO_ENCODING_ALAW ||\n \t    sc->sc_encoding == AUDIO_ENCODING_ULINEAR_LE ||\n \t    sc->sc_encoding == AUDIO_ENCODING_ULINEAR_BE)\n\t    dmac |= GUSMASK_SAMPLE_INVBIT;\n\tif (sc->sc_channels == 2)\n\t    dmac |= GUSMASK_SAMPLE_STEREO;\n \tisa_dmastart(sc->sc_dev.dv_parent, sc->sc_recdrq, buf, size,\n \t    NULL, DMAMODE_READ, BUS_DMA_NOWAIT);\n\n\tDMAPRINTF((\"gus_dma_input isadma_started\\n\"));\n\tsc->sc_flags |= GUS_DMAIN_ACTIVE;\n\tsc->sc_dmainintr = callback;\n\tsc->sc_inarg = arg;\n\tsc->sc_dmaincnt = size;\n\tsc->sc_dmainaddr = buf;\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_SAMPLE_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, dmac);\t/* Go! */\n\n\n\tDMAPRINTF((\"gus_dma_input returning\\n\"));\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngusmax_dma_input(addr, buf, size, callback, arg)\n\tvoid * addr;\n\tvoid *buf;\n\tint size;\n\tvoid (*callback) __P((void *));\n\tvoid *arg;\n{\n\tstruct ad1848_softc *sc = addr;\n\treturn gus_dma_input(sc->parent, buf, size, callback, arg);\n}"
  },
  {
    "function_name": "gus_get_in_gain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "2258-2264",
    "snippet": "int\ngus_get_in_gain(addr)\n\tcaddr_t addr;\n{\n\tDPRINTF((\"gus_get_in_gain called\\n\"));\n\treturn 0;\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"gus_get_in_gain called\\n\")"
          ],
          "line": 2262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngus_get_in_gain(addr)\n\tcaddr_t addr;\n{\n\tDPRINTF((\"gus_get_in_gain called\\n\"));\n\treturn 0;\n}"
  },
  {
    "function_name": "gus_set_in_gain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "2248-2256",
    "snippet": "int\ngus_set_in_gain(addr, gain, balance)\n\tcaddr_t addr;\n\tu_int gain;\n\tu_char balance;\n{\n\tDPRINTF((\"gus_set_in_gain called\\n\"));\n\treturn 0;\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"gus_set_in_gain called\\n\")"
          ],
          "line": 2254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngus_set_in_gain(addr, gain, balance)\n\tcaddr_t addr;\n\tu_int gain;\n\tu_char balance;\n{\n\tDPRINTF((\"gus_set_in_gain called\\n\"));\n\treturn 0;\n}"
  },
  {
    "function_name": "gus_getdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "2235-2242",
    "snippet": "int\ngus_getdev(addr, dev)\n\tvoid * addr;\n\tstruct audio_device *dev;\n{\n\t*dev = gus_device;\n\treturn 0;\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct audio_device gus_device = {\n\t\"UltraSound\",\n\t\"\",\n\t\"gus\",\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct audio_device gus_device = {\n\t\"UltraSound\",\n\t\"\",\n\t\"gus\",\n};\n\nint\ngus_getdev(addr, dev)\n\tvoid * addr;\n\tstruct audio_device *dev;\n{\n\t*dev = gus_device;\n\treturn 0;\n}"
  },
  {
    "function_name": "gus_init_cs4231",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "2182-2228",
    "snippet": "int\ngus_init_cs4231(sc)\n\tstruct gus_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh1 = sc->sc_ioh1;\n\tint port = sc->sc_iobase;\n\tu_char ctrl;\n\n\tctrl = (port & 0xf0) >> 4;\t/* set port address middle nibble */\n\t/*\n\t * The codec is a bit weird--swapped dma channels.\n\t */\n\tctrl |= GUS_MAX_CODEC_ENABLE;\n\tif (sc->sc_drq >= 4)\n\t\tctrl |= GUS_MAX_RECCHAN16;\n\tif (sc->sc_recdrq >= 4)\n\t\tctrl |= GUS_MAX_PLAYCHAN16;\n\n\tbus_space_write_1(iot, ioh1, GUS_MAX_CTRL, ctrl);\n\n\tsc->sc_codec.sc_iot = sc->sc_iot;\n\tsc->sc_codec.sc_iobase = port+GUS_MAX_CODEC_BASE;\n\n\tif (ad1848_probe(&sc->sc_codec) == 0) {\n\t\tsc->sc_flags &= ~GUS_CODEC_INSTALLED;\n\t\treturn (0);\n\t} else {\n\t\tstruct ad1848_volume vol = {AUDIO_MAX_GAIN, AUDIO_MAX_GAIN};\n\t\tsc->sc_flags |= GUS_CODEC_INSTALLED;\n\t\tsc->sc_codec.parent = sc;\n\t\tsc->sc_codec.sc_drq = sc->sc_recdrq;\n\t\tsc->sc_codec.sc_recdrq = sc->sc_drq;\n\t\tgus_hw_if = gusmax_hw_if;\n\t\t/* enable line in and mic in the GUS mixer; the codec chip\n\t\t   will do the real mixing for them. */\n\t\tsc->sc_mixcontrol &= ~GUSMASK_LINE_IN; /* 0 enables. */\n\t\tsc->sc_mixcontrol |= GUSMASK_MIC_IN; /* 1 enables. */\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t\t\n\t\tad1848_attach(&sc->sc_codec);\n\t\t/* turn on pre-MUX microphone gain. */\n\t\tad1848_set_mic_gain(&sc->sc_codec, &vol);\n\n\t\treturn (1);\n\t}\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct audio_hw_if gus_hw_if = {\n\tgusopen,\n\tgusclose,\n\tNULL,\t\t\t\t/* drain */\n\n\tgus_query_encoding,\n\n\tgus_set_params,\n\n\tgus_round_blocksize,\n\n\tgus_commit_settings,\n\n\tNULL,\n\tNULL,\n\n\tgus_dma_output,\n\tgus_dma_input,\n\tgus_halt_out_dma,\n\tgus_halt_in_dma,\n\tgus_speaker_ctl,\n\n\tgus_getdev,\n\tNULL,\n\tgus_mixer_set_port,\n\tgus_mixer_get_port,\n\tgus_mixer_query_devinfo,\n\tad1848_malloc,\n\tad1848_free,\n\tad1848_round,\n\tad1848_mappage,\n\tgus_get_props,\n\n\tNULL,\n\tNULL\n};",
      "static struct audio_hw_if gusmax_hw_if = {\n\tgusmaxopen,\n\tgusmax_close,\n\tNULL,\t\t\t\t/* drain */\n\t\n\tgus_query_encoding, /* query encoding */\n\t\n\tgusmax_set_params,\n\t\n\tgusmax_round_blocksize,\n\t\n\tgusmax_commit_settings,\n\t\n\tNULL,\n\tNULL,\n\t\n\tgusmax_dma_output,\n\tgusmax_dma_input,\n\tgusmax_halt_out_dma,\n\tgusmax_halt_in_dma,\n\t\n\tgusmax_speaker_ctl,\n\t\n\tgus_getdev,\n\tNULL,\n\tgusmax_mixer_set_port,\n\tgusmax_mixer_get_port,\n\tgusmax_mixer_query_devinfo,\n\tad1848_malloc,\n\tad1848_free,\n\tad1848_round,\n\tad1848_mappage,\n\tgusmax_get_props,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ad1848_set_mic_gain",
          "args": [
            "&sc->sc_codec",
            "&vol"
          ],
          "line": 2224
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_set_mic_gain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "739-759",
          "snippet": "int\nad1848_set_mic_gain(sc, gp)\n    struct ad1848_softc *sc;\n    struct ad1848_volume *gp;\n{\n    u_char reg;\n    \n    DPRINTF((\"cs4231_set_mic_gain: %d\\n\", gp->left));\n\n    if (gp->left > AUDIO_MAX_GAIN/2) {\n\t    sc->mic_gain_on = 1;\n\t    reg = ad_read(sc, SP_LEFT_INPUT_CONTROL);\n\t    ad_write(sc, SP_LEFT_INPUT_CONTROL, reg | INPUT_MIC_GAIN_ENABLE);\n    } else {\n\t    sc->mic_gain_on = 0;\n\t    reg = ad_read(sc, SP_LEFT_INPUT_CONTROL);\n\t    ad_write(sc, SP_LEFT_INPUT_CONTROL, reg & ~INPUT_MIC_GAIN_ENABLE);\n    }\n\n    return(0);\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ad_read",
            "static void ad_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\nstatic void ad_write;\n\nint\nad1848_set_mic_gain(sc, gp)\n    struct ad1848_softc *sc;\n    struct ad1848_volume *gp;\n{\n    u_char reg;\n    \n    DPRINTF((\"cs4231_set_mic_gain: %d\\n\", gp->left));\n\n    if (gp->left > AUDIO_MAX_GAIN/2) {\n\t    sc->mic_gain_on = 1;\n\t    reg = ad_read(sc, SP_LEFT_INPUT_CONTROL);\n\t    ad_write(sc, SP_LEFT_INPUT_CONTROL, reg | INPUT_MIC_GAIN_ENABLE);\n    } else {\n\t    sc->mic_gain_on = 0;\n\t    reg = ad_read(sc, SP_LEFT_INPUT_CONTROL);\n\t    ad_write(sc, SP_LEFT_INPUT_CONTROL, reg & ~INPUT_MIC_GAIN_ENABLE);\n    }\n\n    return(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad1848_attach",
          "args": [
            "&sc->sc_codec"
          ],
          "line": 2222
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "502-577",
          "snippet": "void\nad1848_attach(sc)\n    struct ad1848_softc *sc;\n{\n    int i;\n    struct ad1848_volume vol_mid = {220, 220};\n    struct ad1848_volume vol_0   = {0, 0};\n    struct audio_params pparams, rparams;\n    int timeout;\n    \n    sc->sc_locked = 0;\n    sc->sc_playrun = NOTRUNNING;\n    sc->sc_recrun = NOTRUNNING;\n\n    if (sc->sc_drq != -1) {\n\tif (isa_dmamap_create(sc->sc_isa, sc->sc_drq, MAX_ISADMA,\n\t    BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\tprintf(\"ad1848_attach: can't create map for drq %d\\n\",\n\t\t    sc->sc_drq);\n\t\treturn;\n\t}\n    }\n    if (sc->sc_recdrq != -1 && sc->sc_recdrq != sc->sc_drq) {\n\tif (isa_dmamap_create(sc->sc_isa, sc->sc_recdrq, MAX_ISADMA,\n\t    BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\tprintf(\"ad1848_attach: can't creape map for drq %d\\n\",\n\t\t    sc->sc_recdrq);\n\t\treturn;\n\t}\n    }\n\n    /* Initialize the ad1848... */\n    for (i = 0; i < 0x10; i++) {\n\tad_write(sc, i, ad1848_init_values[i]);\n        timeout = 100000;\n        while (timeout > 0 && ad_read(sc, AD1848_IADDR) & SP_IN_INIT)\n\t    timeout--;\n    }\n    /* ...and additional CS4231 stuff too */\n    if (sc->mode == 2) {\n\t    ad_write(sc, SP_INTERFACE_CONFIG, 0); /* disable SINGLE_DMA */\n\t    for (i = 0x10; i < 0x20; i++)\n\t\t    if (ad1848_init_values[i] != 0) {\n\t\t\t    ad_write(sc, i, ad1848_init_values[i]);\n\t\t\t    timeout = 100000;\n    \t\t\t    while (timeout > 0 && \n\t\t\t\t   ad_read(sc, AD1848_IADDR) & SP_IN_INIT)\n\t\t\t\ttimeout--;\n\t\t    }\n    }\n    ad1848_reset(sc);\n\n    pparams = audio_default;\n    rparams = audio_default;\n    (void) ad1848_set_params(sc, AUMODE_RECORD|AUMODE_PLAY, 0, &pparams, &rparams);\n\n    /* Set default gains */\n    (void) ad1848_set_rec_gain(sc, &vol_mid);\n    (void) ad1848_set_channel_gain(sc, AD1848_DAC_CHANNEL, &vol_mid);\n    (void) ad1848_set_channel_gain(sc, AD1848_MONITOR_CHANNEL, &vol_0);\n    (void) ad1848_set_channel_gain(sc, AD1848_AUX1_CHANNEL, &vol_mid);\t/* CD volume */\n    if (sc->mode == 2) {\n\t(void) ad1848_set_channel_gain(sc, AD1848_AUX2_CHANNEL, &vol_mid); /* CD volume */\n\t(void) ad1848_set_channel_gain(sc, AD1848_LINE_CHANNEL, &vol_mid);\n\t(void) ad1848_set_channel_gain(sc, AD1848_MONO_CHANNEL, &vol_0);\n\tsc->mute[AD1848_MONO_CHANNEL] = MUTE_ALL;\n    } else\n\t(void) ad1848_set_channel_gain(sc, AD1848_AUX2_CHANNEL, &vol_0);\n\n    /* Set default port */\n    (void) ad1848_set_rec_port(sc, MIC_IN_PORT);\n\n    if (sc->chip_name)\n\tprintf(\": %s\", sc->chip_name);\n#undef WAITREADY\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ad1848_init_values[] = {\n\t\t\t/* Left Input Control */\n    GAIN_12|INPUT_MIC_GAIN_ENABLE,\n\t\t\t/* Right Input Control */\n    GAIN_12|INPUT_MIC_GAIN_ENABLE,\n    ATTEN_12,\t\t/* Left Aux #1 Input Control */\n    ATTEN_12,\t\t/* Right Aux #1 Input Control */\n    ATTEN_12,\t\t/* Left Aux #2 Input Control */\n    ATTEN_12,\t\t/* Right Aux #2 Input Control */\n    /* bits 5-0 are attenuation select */\n    ATTEN_12,\t\t/* Left DAC output Control */\n    ATTEN_12,\t\t/* Right DAC output Control */\n\t\t\t/* Clock and Data Format */\n    CLOCK_XTAL1|FMT_PCM8,\n\t\t\t/* Interface Config */\n    SINGLE_DMA|AUTO_CAL_ENABLE,\n    INTERRUPT_ENABLE,\t/* Pin control */\n    0x00,\t\t/* Test and Init */\n    MODE2,\t\t/* Misc control */\n    ATTEN_0<<2,\t\t/* Digital Mix Control */\n    0,\t\t\t/* Upper base Count */\n    0,\t\t\t/* Lower base Count */\n\n    /* These are for CS4231 &c. only (additional registers): */\n    0,\t\t\t/* Alt feature 1 */\n    0,\t\t\t/* Alt feature 2 */\n    ATTEN_12,\t\t/* Left line in */\n    ATTEN_12,\t\t/* Right line in */\n    0,\t\t\t/* Timer low */\n    0,\t\t\t/* Timer high */\n    0,\t\t\t/* unused */\n    0,\t\t\t/* unused */\n    0,\t\t\t/* IRQ status */\n    0,\t\t\t/* unused */\n\t\t\t/* Mono input (a.k.a speaker) (mic) Control */\n    MONO_INPUT_MUTE|ATTEN_6,\t\t/* mute speaker by default */\n    0,\t\t\t/* unused */\n    0,\t\t\t/* record format */\n    0,\t\t\t/* Crystal Clock Select */\n    0,\t\t\t/* upper record count */\n    0\t\t\t/* lower record count */\n};",
            "void\tad1848_reset",
            "static int ad_read",
            "static void ad_write",
            "static ad1848_devmap_t *\nad1848_mixer_find_dev(map, cnt, cp)\n  ad1848_devmap_t *map;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad1848_init_values[] = {\n\t\t\t/* Left Input Control */\n    GAIN_12|INPUT_MIC_GAIN_ENABLE,\n\t\t\t/* Right Input Control */\n    GAIN_12|INPUT_MIC_GAIN_ENABLE,\n    ATTEN_12,\t\t/* Left Aux #1 Input Control */\n    ATTEN_12,\t\t/* Right Aux #1 Input Control */\n    ATTEN_12,\t\t/* Left Aux #2 Input Control */\n    ATTEN_12,\t\t/* Right Aux #2 Input Control */\n    /* bits 5-0 are attenuation select */\n    ATTEN_12,\t\t/* Left DAC output Control */\n    ATTEN_12,\t\t/* Right DAC output Control */\n\t\t\t/* Clock and Data Format */\n    CLOCK_XTAL1|FMT_PCM8,\n\t\t\t/* Interface Config */\n    SINGLE_DMA|AUTO_CAL_ENABLE,\n    INTERRUPT_ENABLE,\t/* Pin control */\n    0x00,\t\t/* Test and Init */\n    MODE2,\t\t/* Misc control */\n    ATTEN_0<<2,\t\t/* Digital Mix Control */\n    0,\t\t\t/* Upper base Count */\n    0,\t\t\t/* Lower base Count */\n\n    /* These are for CS4231 &c. only (additional registers): */\n    0,\t\t\t/* Alt feature 1 */\n    0,\t\t\t/* Alt feature 2 */\n    ATTEN_12,\t\t/* Left line in */\n    ATTEN_12,\t\t/* Right line in */\n    0,\t\t\t/* Timer low */\n    0,\t\t\t/* Timer high */\n    0,\t\t\t/* unused */\n    0,\t\t\t/* unused */\n    0,\t\t\t/* IRQ status */\n    0,\t\t\t/* unused */\n\t\t\t/* Mono input (a.k.a speaker) (mic) Control */\n    MONO_INPUT_MUTE|ATTEN_6,\t\t/* mute speaker by default */\n    0,\t\t\t/* unused */\n    0,\t\t\t/* record format */\n    0,\t\t\t/* Crystal Clock Select */\n    0,\t\t\t/* upper record count */\n    0\t\t\t/* lower record count */\n};\nvoid\tad1848_reset;\nstatic int ad_read;\nstatic void ad_write;\nstatic ad1848_devmap_t *\nad1848_mixer_find_dev(map, cnt, cp)\n  ad1848_devmap_t *map;\n\nvoid\nad1848_attach(sc)\n    struct ad1848_softc *sc;\n{\n    int i;\n    struct ad1848_volume vol_mid = {220, 220};\n    struct ad1848_volume vol_0   = {0, 0};\n    struct audio_params pparams, rparams;\n    int timeout;\n    \n    sc->sc_locked = 0;\n    sc->sc_playrun = NOTRUNNING;\n    sc->sc_recrun = NOTRUNNING;\n\n    if (sc->sc_drq != -1) {\n\tif (isa_dmamap_create(sc->sc_isa, sc->sc_drq, MAX_ISADMA,\n\t    BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\tprintf(\"ad1848_attach: can't create map for drq %d\\n\",\n\t\t    sc->sc_drq);\n\t\treturn;\n\t}\n    }\n    if (sc->sc_recdrq != -1 && sc->sc_recdrq != sc->sc_drq) {\n\tif (isa_dmamap_create(sc->sc_isa, sc->sc_recdrq, MAX_ISADMA,\n\t    BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {\n\t\tprintf(\"ad1848_attach: can't creape map for drq %d\\n\",\n\t\t    sc->sc_recdrq);\n\t\treturn;\n\t}\n    }\n\n    /* Initialize the ad1848... */\n    for (i = 0; i < 0x10; i++) {\n\tad_write(sc, i, ad1848_init_values[i]);\n        timeout = 100000;\n        while (timeout > 0 && ad_read(sc, AD1848_IADDR) & SP_IN_INIT)\n\t    timeout--;\n    }\n    /* ...and additional CS4231 stuff too */\n    if (sc->mode == 2) {\n\t    ad_write(sc, SP_INTERFACE_CONFIG, 0); /* disable SINGLE_DMA */\n\t    for (i = 0x10; i < 0x20; i++)\n\t\t    if (ad1848_init_values[i] != 0) {\n\t\t\t    ad_write(sc, i, ad1848_init_values[i]);\n\t\t\t    timeout = 100000;\n    \t\t\t    while (timeout > 0 && \n\t\t\t\t   ad_read(sc, AD1848_IADDR) & SP_IN_INIT)\n\t\t\t\ttimeout--;\n\t\t    }\n    }\n    ad1848_reset(sc);\n\n    pparams = audio_default;\n    rparams = audio_default;\n    (void) ad1848_set_params(sc, AUMODE_RECORD|AUMODE_PLAY, 0, &pparams, &rparams);\n\n    /* Set default gains */\n    (void) ad1848_set_rec_gain(sc, &vol_mid);\n    (void) ad1848_set_channel_gain(sc, AD1848_DAC_CHANNEL, &vol_mid);\n    (void) ad1848_set_channel_gain(sc, AD1848_MONITOR_CHANNEL, &vol_0);\n    (void) ad1848_set_channel_gain(sc, AD1848_AUX1_CHANNEL, &vol_mid);\t/* CD volume */\n    if (sc->mode == 2) {\n\t(void) ad1848_set_channel_gain(sc, AD1848_AUX2_CHANNEL, &vol_mid); /* CD volume */\n\t(void) ad1848_set_channel_gain(sc, AD1848_LINE_CHANNEL, &vol_mid);\n\t(void) ad1848_set_channel_gain(sc, AD1848_MONO_CHANNEL, &vol_0);\n\tsc->mute[AD1848_MONO_CHANNEL] = MUTE_ALL;\n    } else\n\t(void) ad1848_set_channel_gain(sc, AD1848_AUX2_CHANNEL, &vol_0);\n\n    /* Set default port */\n    (void) ad1848_set_rec_port(sc, MIC_IN_PORT);\n\n    if (sc->chip_name)\n\tprintf(\": %s\", sc->chip_name);\n#undef WAITREADY\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh1",
            "GUS_MIX_CONTROL",
            "sc->sc_mixcontrol"
          ],
          "line": 2220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ad1848_probe",
          "args": [
            "&sc->sc_codec"
          ],
          "line": 2206
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "303-488",
          "snippet": "int\nad1848_probe(sc)\n    struct ad1848_softc *sc;\n{\n    u_char tmp, tmp1 = 0xff, tmp2 = 0xff;\n#if 0\n    int i;\n#endif\n    \n    /* Is there an ad1848 chip ? */\n    sc->MCE_bit = MODE_CHANGE_ENABLE;\n    sc->mode = 1;\t/* MODE 1 = original ad1848/ad1846/cs4248 */\n    \n    /*\n     * Check that the I/O address is in use.\n     *\n     * The SP_IN_INIT bit of the base I/O port is known to be 0 after the\n     * chip has performed its power-on initialization. Just assume\n     * this has happened before the OS is starting.\n     *\n     * If the I/O address is unused, inb() typically returns 0xff.\n     */\n    tmp = ADREAD(sc, AD1848_IADDR);\n    if (tmp & SP_IN_INIT) { /* Not a AD1848 */\n#if 0\n\tDPRINTF((\"ad_detect_A %x\\n\", tmp));\n#endif\n\tgoto bad;\n    }\n\n    /*\n     * Test if it's possible to change contents of the indirect registers.\n     * Registers 0 and 1 are ADC volume registers. The bit 0x10 is read only\n     * so try to avoid using it.\n     */\n    ad_write(sc, 0, 0xaa);\n    ad_write(sc, 1, 0x45);\t/* 0x55 with bit 0x10 clear */\n\n    if ((tmp1 = ad_read(sc, 0)) != 0xaa ||\n\t(tmp2 = ad_read(sc, 1)) != 0x45) {\n\tDPRINTF((\"ad_detect_B (%x/%x)\\n\", tmp1, tmp2));\n\tgoto bad;\n    }\n\n    ad_write(sc, 0, 0x45);\n    ad_write(sc, 1, 0xaa);\n\n    if ((tmp1 = ad_read(sc, 0)) != 0x45 ||\n\t(tmp2 = ad_read(sc, 1)) != 0xaa) {\n\tDPRINTF((\"ad_detect_C (%x/%x)\\n\", tmp1, tmp2));\n\tgoto bad;\n    }\n\n    /*\n     * The indirect register I12 has some read only bits. Lets\n     * try to change them.\n     */\n    tmp = ad_read(sc, SP_MISC_INFO);\n    ad_write(sc, SP_MISC_INFO, (~tmp) & 0x0f);\n\n    if ((tmp & 0x0f) != ((tmp1 = ad_read(sc, SP_MISC_INFO)) & 0x0f)) {\n\tDPRINTF((\"ad_detect_D (%x)\\n\", tmp1));\n\tgoto bad;\n    }\n\n    /*\n     * MSB and 4 LSBs of the reg I12 tell the chip revision.\n     *\n     * A preliminary version of the AD1846 data sheet stated that it\n     * used an ID field of 0x0B.  The current version, however,\n     * states that the AD1846 uses ID 0x0A, just like the AD1848K.\n     *\n     * this switch statement will need updating as newer clones arrive....\n     */\n    switch (tmp1 & 0x8f) {\n    case 0x09:\n\tsc->chip_name = \"AD1848J\";\n\tbreak;\n    case 0x0A:\n\tsc->chip_name = \"AD1848K\";\n\tbreak;\n#if 0\t/* See above */\n    case 0x0B:\n\tsc->chip_name = \"AD1846\";\n\tbreak;\n#endif\n    case 0x81:\n\tsc->chip_name = \"CS4248revB\"; /* or CS4231 rev B; see below */\n\tbreak;\n    case 0x89:\n\tsc->chip_name = \"CS4248\";\n\tbreak;\n    case 0x8A:\n\tsc->chip_name = \"broken\"; /* CS4231/AD1845; see below */\n\tbreak;\n    default:\n\tsc->chip_name = \"unknown\";\n\tDPRINTF((\"ad1848: unknown codec version %#02X\\n\", (tmp1 & 0x8f)));\n    }\t\n    \n#if 0\n    /*\n     * XXX I don't know why, but this probe fails on an otherwise well-working\n     * AW35/pro card, so I'll just take it out for now. [niklas@openbsd.org]\n     */\n\n    /*\n     * The original AD1848/CS4248 has just 16 indirect registers. This means\n     * that I0 and I16 should return the same value (etc.).\n     * Ensure that the Mode2 enable bit of I12 is 0. Otherwise this test fails\n     * with CS4231, AD1845, etc.\n     */\n    ad_write(sc, SP_MISC_INFO, 0);\t/* Mode2 = disabled */\n\n    for (i = 0; i < 16; i++)\n\tif ((tmp1 = ad_read(sc, i)) != (tmp2 = ad_read(sc, i + 16))) {\n\t    if (i != SP_TEST_AND_INIT) {\n\t        DPRINTF((\"ad_detect_F(%d/%x/%x)\\n\", i, tmp1, tmp2));\n\t        goto bad;\n\t    }\n\t}\n#endif\n\n    /*\n     * Try to switch the chip to mode2 (CS4231) by setting the MODE2 bit\n     * The bit 0x80 is always 1 in CS4248, CS4231, and AD1845.\n     */\n    ad_write(sc, SP_MISC_INFO, MODE2);\t/* Set mode2, clear 0x80 */\n\n    tmp1 = ad_read(sc, SP_MISC_INFO);\n    if ((tmp1 & 0xc0) == (0x80 | MODE2)) {\n\t/*\n\t *      CS4231 or AD1845 detected - is it?\n\t *\n\t *\tVerify that setting I2 doesn't change I18.\n\t */\n\tad_write(sc, 18, 0x88); /* Set I18 to known value */\n\n\tad_write(sc, 2, 0x45);\n\tif ((tmp2 = ad_read(sc, 18)) != 0x45) { /* No change -> CS4231? */\n\t    ad_write(sc, 2, 0xaa);\n\t    if ((tmp2 = ad_read(sc, 18)) == 0xaa) {     /* Rotten bits? */\n\t\tDPRINTF((\"ad_detect_H(%x)\\n\", tmp2));\n\t\tgoto bad;\n\t    }\n\n\t    /*\n\t     *  It's a CS4231, or another clone with 32 registers.\n\t     *  Let's find out which by checking I25.\n\t     */\n\t    if ((tmp1 & 0x8f) == 0x8a) {\n\t\ttmp1 = ad_read(sc, CS_VERSION_ID);\n\t\tswitch (tmp1 & 0xe7) {\n\t\tcase 0xA0:\n\t\t    sc->chip_name = \"CS4231A\";\n\t\t    break;\n\t\tcase 0x80:\n\t\t    /*  XXX I25 no good, AD1845 same as CS4231 */\n\t\t    sc->chip_name = \"CS4231 or AD1845\";\n\t\t    break;\n\t\tcase 0x82:\n\t\tcase 0xa2:\n\t\t    sc->chip_name = \"CS4232\";\n\t\t    break;\n\t\tcase 0x03:\n\t\t    sc->chip_name = \"CS4236/CS4236B\";\n\t\t    break;\n\t\t}\n\t    }\n\t    sc->mode = 2;\n\t}\n    }\n\n    /* Wait for 1848 to init */\n    while(ADREAD(sc, AD1848_IADDR) & SP_IN_INIT)\n        ;\n\t\n    /* Wait for 1848 to autocal */\n    ADWRITE(sc, AD1848_IADDR, SP_TEST_AND_INIT);\n    while(ADREAD(sc, AD1848_IDATA) & AUTO_CAL_IN_PROG)\n        ;\n\n    return 1;\nbad:\n    return 0;\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ad_read",
            "static void ad_write"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\nstatic void ad_write;\n\nint\nad1848_probe(sc)\n    struct ad1848_softc *sc;\n{\n    u_char tmp, tmp1 = 0xff, tmp2 = 0xff;\n#if 0\n    int i;\n#endif\n    \n    /* Is there an ad1848 chip ? */\n    sc->MCE_bit = MODE_CHANGE_ENABLE;\n    sc->mode = 1;\t/* MODE 1 = original ad1848/ad1846/cs4248 */\n    \n    /*\n     * Check that the I/O address is in use.\n     *\n     * The SP_IN_INIT bit of the base I/O port is known to be 0 after the\n     * chip has performed its power-on initialization. Just assume\n     * this has happened before the OS is starting.\n     *\n     * If the I/O address is unused, inb() typically returns 0xff.\n     */\n    tmp = ADREAD(sc, AD1848_IADDR);\n    if (tmp & SP_IN_INIT) { /* Not a AD1848 */\n#if 0\n\tDPRINTF((\"ad_detect_A %x\\n\", tmp));\n#endif\n\tgoto bad;\n    }\n\n    /*\n     * Test if it's possible to change contents of the indirect registers.\n     * Registers 0 and 1 are ADC volume registers. The bit 0x10 is read only\n     * so try to avoid using it.\n     */\n    ad_write(sc, 0, 0xaa);\n    ad_write(sc, 1, 0x45);\t/* 0x55 with bit 0x10 clear */\n\n    if ((tmp1 = ad_read(sc, 0)) != 0xaa ||\n\t(tmp2 = ad_read(sc, 1)) != 0x45) {\n\tDPRINTF((\"ad_detect_B (%x/%x)\\n\", tmp1, tmp2));\n\tgoto bad;\n    }\n\n    ad_write(sc, 0, 0x45);\n    ad_write(sc, 1, 0xaa);\n\n    if ((tmp1 = ad_read(sc, 0)) != 0x45 ||\n\t(tmp2 = ad_read(sc, 1)) != 0xaa) {\n\tDPRINTF((\"ad_detect_C (%x/%x)\\n\", tmp1, tmp2));\n\tgoto bad;\n    }\n\n    /*\n     * The indirect register I12 has some read only bits. Lets\n     * try to change them.\n     */\n    tmp = ad_read(sc, SP_MISC_INFO);\n    ad_write(sc, SP_MISC_INFO, (~tmp) & 0x0f);\n\n    if ((tmp & 0x0f) != ((tmp1 = ad_read(sc, SP_MISC_INFO)) & 0x0f)) {\n\tDPRINTF((\"ad_detect_D (%x)\\n\", tmp1));\n\tgoto bad;\n    }\n\n    /*\n     * MSB and 4 LSBs of the reg I12 tell the chip revision.\n     *\n     * A preliminary version of the AD1846 data sheet stated that it\n     * used an ID field of 0x0B.  The current version, however,\n     * states that the AD1846 uses ID 0x0A, just like the AD1848K.\n     *\n     * this switch statement will need updating as newer clones arrive....\n     */\n    switch (tmp1 & 0x8f) {\n    case 0x09:\n\tsc->chip_name = \"AD1848J\";\n\tbreak;\n    case 0x0A:\n\tsc->chip_name = \"AD1848K\";\n\tbreak;\n#if 0\t/* See above */\n    case 0x0B:\n\tsc->chip_name = \"AD1846\";\n\tbreak;\n#endif\n    case 0x81:\n\tsc->chip_name = \"CS4248revB\"; /* or CS4231 rev B; see below */\n\tbreak;\n    case 0x89:\n\tsc->chip_name = \"CS4248\";\n\tbreak;\n    case 0x8A:\n\tsc->chip_name = \"broken\"; /* CS4231/AD1845; see below */\n\tbreak;\n    default:\n\tsc->chip_name = \"unknown\";\n\tDPRINTF((\"ad1848: unknown codec version %#02X\\n\", (tmp1 & 0x8f)));\n    }\t\n    \n#if 0\n    /*\n     * XXX I don't know why, but this probe fails on an otherwise well-working\n     * AW35/pro card, so I'll just take it out for now. [niklas@openbsd.org]\n     */\n\n    /*\n     * The original AD1848/CS4248 has just 16 indirect registers. This means\n     * that I0 and I16 should return the same value (etc.).\n     * Ensure that the Mode2 enable bit of I12 is 0. Otherwise this test fails\n     * with CS4231, AD1845, etc.\n     */\n    ad_write(sc, SP_MISC_INFO, 0);\t/* Mode2 = disabled */\n\n    for (i = 0; i < 16; i++)\n\tif ((tmp1 = ad_read(sc, i)) != (tmp2 = ad_read(sc, i + 16))) {\n\t    if (i != SP_TEST_AND_INIT) {\n\t        DPRINTF((\"ad_detect_F(%d/%x/%x)\\n\", i, tmp1, tmp2));\n\t        goto bad;\n\t    }\n\t}\n#endif\n\n    /*\n     * Try to switch the chip to mode2 (CS4231) by setting the MODE2 bit\n     * The bit 0x80 is always 1 in CS4248, CS4231, and AD1845.\n     */\n    ad_write(sc, SP_MISC_INFO, MODE2);\t/* Set mode2, clear 0x80 */\n\n    tmp1 = ad_read(sc, SP_MISC_INFO);\n    if ((tmp1 & 0xc0) == (0x80 | MODE2)) {\n\t/*\n\t *      CS4231 or AD1845 detected - is it?\n\t *\n\t *\tVerify that setting I2 doesn't change I18.\n\t */\n\tad_write(sc, 18, 0x88); /* Set I18 to known value */\n\n\tad_write(sc, 2, 0x45);\n\tif ((tmp2 = ad_read(sc, 18)) != 0x45) { /* No change -> CS4231? */\n\t    ad_write(sc, 2, 0xaa);\n\t    if ((tmp2 = ad_read(sc, 18)) == 0xaa) {     /* Rotten bits? */\n\t\tDPRINTF((\"ad_detect_H(%x)\\n\", tmp2));\n\t\tgoto bad;\n\t    }\n\n\t    /*\n\t     *  It's a CS4231, or another clone with 32 registers.\n\t     *  Let's find out which by checking I25.\n\t     */\n\t    if ((tmp1 & 0x8f) == 0x8a) {\n\t\ttmp1 = ad_read(sc, CS_VERSION_ID);\n\t\tswitch (tmp1 & 0xe7) {\n\t\tcase 0xA0:\n\t\t    sc->chip_name = \"CS4231A\";\n\t\t    break;\n\t\tcase 0x80:\n\t\t    /*  XXX I25 no good, AD1845 same as CS4231 */\n\t\t    sc->chip_name = \"CS4231 or AD1845\";\n\t\t    break;\n\t\tcase 0x82:\n\t\tcase 0xa2:\n\t\t    sc->chip_name = \"CS4232\";\n\t\t    break;\n\t\tcase 0x03:\n\t\t    sc->chip_name = \"CS4236/CS4236B\";\n\t\t    break;\n\t\t}\n\t    }\n\t    sc->mode = 2;\n\t}\n    }\n\n    /* Wait for 1848 to init */\n    while(ADREAD(sc, AD1848_IADDR) & SP_IN_INIT)\n        ;\n\t\n    /* Wait for 1848 to autocal */\n    ADWRITE(sc, AD1848_IADDR, SP_TEST_AND_INIT);\n    while(ADREAD(sc, AD1848_IDATA) & AUTO_CAL_IN_PROG)\n        ;\n\n    return 1;\nbad:\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh1",
            "GUS_MAX_CTRL",
            "ctrl"
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstruct audio_hw_if gus_hw_if = {\n\tgusopen,\n\tgusclose,\n\tNULL,\t\t\t\t/* drain */\n\n\tgus_query_encoding,\n\n\tgus_set_params,\n\n\tgus_round_blocksize,\n\n\tgus_commit_settings,\n\n\tNULL,\n\tNULL,\n\n\tgus_dma_output,\n\tgus_dma_input,\n\tgus_halt_out_dma,\n\tgus_halt_in_dma,\n\tgus_speaker_ctl,\n\n\tgus_getdev,\n\tNULL,\n\tgus_mixer_set_port,\n\tgus_mixer_get_port,\n\tgus_mixer_query_devinfo,\n\tad1848_malloc,\n\tad1848_free,\n\tad1848_round,\n\tad1848_mappage,\n\tgus_get_props,\n\n\tNULL,\n\tNULL\n};\nstatic struct audio_hw_if gusmax_hw_if = {\n\tgusmaxopen,\n\tgusmax_close,\n\tNULL,\t\t\t\t/* drain */\n\t\n\tgus_query_encoding, /* query encoding */\n\t\n\tgusmax_set_params,\n\t\n\tgusmax_round_blocksize,\n\t\n\tgusmax_commit_settings,\n\t\n\tNULL,\n\tNULL,\n\t\n\tgusmax_dma_output,\n\tgusmax_dma_input,\n\tgusmax_halt_out_dma,\n\tgusmax_halt_in_dma,\n\t\n\tgusmax_speaker_ctl,\n\t\n\tgus_getdev,\n\tNULL,\n\tgusmax_mixer_set_port,\n\tgusmax_mixer_get_port,\n\tgusmax_mixer_query_devinfo,\n\tad1848_malloc,\n\tad1848_free,\n\tad1848_round,\n\tad1848_mappage,\n\tgusmax_get_props,\n};\n\nint\ngus_init_cs4231(sc)\n\tstruct gus_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh1 = sc->sc_ioh1;\n\tint port = sc->sc_iobase;\n\tu_char ctrl;\n\n\tctrl = (port & 0xf0) >> 4;\t/* set port address middle nibble */\n\t/*\n\t * The codec is a bit weird--swapped dma channels.\n\t */\n\tctrl |= GUS_MAX_CODEC_ENABLE;\n\tif (sc->sc_drq >= 4)\n\t\tctrl |= GUS_MAX_RECCHAN16;\n\tif (sc->sc_recdrq >= 4)\n\t\tctrl |= GUS_MAX_PLAYCHAN16;\n\n\tbus_space_write_1(iot, ioh1, GUS_MAX_CTRL, ctrl);\n\n\tsc->sc_codec.sc_iot = sc->sc_iot;\n\tsc->sc_codec.sc_iobase = port+GUS_MAX_CODEC_BASE;\n\n\tif (ad1848_probe(&sc->sc_codec) == 0) {\n\t\tsc->sc_flags &= ~GUS_CODEC_INSTALLED;\n\t\treturn (0);\n\t} else {\n\t\tstruct ad1848_volume vol = {AUDIO_MAX_GAIN, AUDIO_MAX_GAIN};\n\t\tsc->sc_flags |= GUS_CODEC_INSTALLED;\n\t\tsc->sc_codec.parent = sc;\n\t\tsc->sc_codec.sc_drq = sc->sc_recdrq;\n\t\tsc->sc_codec.sc_recdrq = sc->sc_drq;\n\t\tgus_hw_if = gusmax_hw_if;\n\t\t/* enable line in and mic in the GUS mixer; the codec chip\n\t\t   will do the real mixing for them. */\n\t\tsc->sc_mixcontrol &= ~GUSMASK_LINE_IN; /* 0 enables. */\n\t\tsc->sc_mixcontrol |= GUSMASK_MIC_IN; /* 1 enables. */\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t\t\n\t\tad1848_attach(&sc->sc_codec);\n\t\t/* turn on pre-MUX microphone gain. */\n\t\tad1848_set_mic_gain(&sc->sc_codec, &vol);\n\n\t\treturn (1);\n\t}\n}"
  },
  {
    "function_name": "gusreset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "2052-2179",
    "snippet": "void\ngusreset(sc, voices)\n\tstruct gus_softc *sc;\n\tint voices;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh1 = sc->sc_ioh1;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tbus_space_handle_t ioh4 = sc->sc_ioh4;\n\tint i,s;\n\n\ts = splgus();\n\n\t/*\n\t * Reset the GF1 chip\n\t */\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_RESET);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);\n\n\tdelay(500);\n\n\t/*\n\t * Release reset\n\t */\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_RESET);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, GUSMASK_MASTER_RESET);\n\n\tdelay(500);\n\n\t/*\n\t * Reset MIDI port as well\n\t */\n\n\tbus_space_write_1(iot, ioh4, GUS_MIDI_CONTROL, MIDI_RESET);\n\n\tdelay(500);\n\n\tbus_space_write_1(iot, ioh4, GUS_MIDI_CONTROL, 0x00);\n\n\t/*\n\t * Clear interrupts\n\t */\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_TIMER_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_SAMPLE_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);\n\n\tgus_set_voices(sc, voices);\n\n\tbus_space_read_1(iot, ioh1, GUS_IRQ_STATUS);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);\n\tbus_space_read_1(iot, ioh2, GUS_DATA_HIGH);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_SAMPLE_CONTROL);\n\tbus_space_read_1(iot, ioh2, GUS_DATA_HIGH);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_IRQ_STATUS);\n\tbus_space_read_1(iot, ioh2, GUS_DATA_HIGH);\n\n\t/*\n\t * Reset voice specific information\n\t */\n\n\tfor(i = 0; i < voices; i++) {\n\t\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, (unsigned char) i);\n\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\n\t\tsc->sc_voc[i].voccntl = GUSMASK_VOICE_STOPPED |\n\t\t\tGUSMASK_STOP_VOICE;\n\n\t\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[i].voccntl);\n\n\t\tsc->sc_voc[i].volcntl = GUSMASK_VOLUME_STOPPED |\n\t\t\t\tGUSMASK_STOP_VOLUME;\n\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_CONTROL);\n\t\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[i].volcntl);\n\n\t\tdelay(100);\n\n\t\tgus_set_samprate(sc, i, 8000);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_START_ADDR_HIGH);\n\t\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_START_ADDR_LOW);\n\t\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_END_ADDR_HIGH);\n\t\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_END_ADDR_LOW);\n\t\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_RATE);\n\t\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x01);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_START_VOLUME);\n\t\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x10);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_END_VOLUME);\n\t\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0xe0);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_VOLUME);\n\t\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_HIGH);\n\t\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_LOW);\n\t\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_PAN_POS);\n\t\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x07);\n\t}\n\n\t/*\n\t * Clear out any pending IRQs\n\t */\n\n\tbus_space_read_1(iot, ioh1, GUS_IRQ_STATUS);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);\n\tbus_space_read_1(iot, ioh2, GUS_DATA_HIGH);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_SAMPLE_CONTROL);\n\tbus_space_read_1(iot, ioh2, GUS_DATA_HIGH);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_IRQ_STATUS);\n\tbus_space_read_1(iot, ioh2, GUS_DATA_HIGH);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_RESET);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, GUSMASK_MASTER_RESET | GUSMASK_DAC_ENABLE |\n\t\tGUSMASK_IRQ_ENABLE);\n\n\tsplx(s);\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "GUSMASK_MASTER_RESET | GUSMASK_DAC_ENABLE |\n\t\tGUSMASK_IRQ_ENABLE"
          ],
          "line": 2175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_RESET"
          ],
          "line": 2174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH"
          ],
          "line": 2172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_IRQ_STATUS"
          ],
          "line": 2171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH"
          ],
          "line": 2170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_SAMPLE_CONTROL"
          ],
          "line": 2169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH"
          ],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_DMA_CONTROL"
          ],
          "line": 2167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh1",
            "GUS_IRQ_STATUS"
          ],
          "line": 2166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "0x07"
          ],
          "line": 2159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_PAN_POS"
          ],
          "line": 2158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_LOW",
            "0x0000"
          ],
          "line": 2157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_CUR_ADDR_LOW"
          ],
          "line": 2156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_LOW",
            "0x0000"
          ],
          "line": 2155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_CUR_ADDR_HIGH"
          ],
          "line": 2154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_LOW",
            "0x0000"
          ],
          "line": 2152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_CUR_VOLUME"
          ],
          "line": 2151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "0xe0"
          ],
          "line": 2150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_END_VOLUME"
          ],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "0x10"
          ],
          "line": 2148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_START_VOLUME"
          ],
          "line": 2147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "0x01"
          ],
          "line": 2146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_VOLUME_RATE"
          ],
          "line": 2145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_LOW",
            "0x0000"
          ],
          "line": 2144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_END_ADDR_LOW"
          ],
          "line": 2143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_LOW",
            "0x0000"
          ],
          "line": 2142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_END_ADDR_HIGH"
          ],
          "line": 2141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_LOW",
            "0x0000"
          ],
          "line": 2140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_START_ADDR_LOW"
          ],
          "line": 2139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_LOW",
            "0x0000"
          ],
          "line": 2138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_START_ADDR_HIGH"
          ],
          "line": 2137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gus_set_samprate",
          "args": [
            "sc",
            "i",
            "8000"
          ],
          "line": 2136
        },
        "resolved": true,
        "details": {
          "function_name": "gus_set_samprate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "1750-1782",
          "snippet": "void\ngus_set_samprate(sc, voice, freq)\n\tstruct gus_softc *sc;\n\tint voice, freq;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tunsigned int fc;\n\tu_long temp, f = (u_long) freq;\n\n\t/*\n\t * calculate fc based on the number of active voices;\n\t * we need to use longs to preserve enough bits\n\t */\n\n\ttemp = (u_long) gus_max_frequency[sc->sc_voices-GUS_MIN_VOICES];\n\n \tfc = (unsigned int)(((f << 9L) + (temp >> 1L)) / temp);\n\n \tfc <<= 1;\n\n\n\t/*\n\t * Program the voice frequency, and set it in the voice data record\n\t */\n\n\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, (unsigned char) voice);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_FREQ_CONTROL);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, fc);\n\n\tsc->sc_voc[voice].rate = freq;\n\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int gus_max_frequency[] = {\n\t\t44100,\t\t/* 14 voices */\n\t\t41160,\t\t/* 15 voices */\n\t\t38587,\t\t/* 16 voices */\n\t\t36317,\t\t/* 17 voices */\n\t\t34300,\t\t/* 18 voices */\n\t\t32494,\t\t/* 19 voices */\n\t\t30870,\t\t/* 20 voices */\n\t\t29400,\t\t/* 21 voices */\n\t\t28063,\t\t/* 22 voices */\n\t\t26843,\t\t/* 23 voices */\n\t\t25725,\t\t/* 24 voices */\n\t\t24696,\t\t/* 25 voices */\n\t\t23746,\t\t/* 26 voices */\n\t\t22866,\t\t/* 27 voices */\n\t\t22050,\t\t/* 28 voices */\n\t\t21289,\t\t/* 29 voices */\n\t\t20580,\t\t/* 30 voices */\n\t\t19916,\t\t/* 31 voices */\n\t\t19293\t\t/* 32 voices */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int gus_max_frequency[] = {\n\t\t44100,\t\t/* 14 voices */\n\t\t41160,\t\t/* 15 voices */\n\t\t38587,\t\t/* 16 voices */\n\t\t36317,\t\t/* 17 voices */\n\t\t34300,\t\t/* 18 voices */\n\t\t32494,\t\t/* 19 voices */\n\t\t30870,\t\t/* 20 voices */\n\t\t29400,\t\t/* 21 voices */\n\t\t28063,\t\t/* 22 voices */\n\t\t26843,\t\t/* 23 voices */\n\t\t25725,\t\t/* 24 voices */\n\t\t24696,\t\t/* 25 voices */\n\t\t23746,\t\t/* 26 voices */\n\t\t22866,\t\t/* 27 voices */\n\t\t22050,\t\t/* 28 voices */\n\t\t21289,\t\t/* 29 voices */\n\t\t20580,\t\t/* 30 voices */\n\t\t19916,\t\t/* 31 voices */\n\t\t19293\t\t/* 32 voices */\n};\n\nvoid\ngus_set_samprate(sc, voice, freq)\n\tstruct gus_softc *sc;\n\tint voice, freq;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tunsigned int fc;\n\tu_long temp, f = (u_long) freq;\n\n\t/*\n\t * calculate fc based on the number of active voices;\n\t * we need to use longs to preserve enough bits\n\t */\n\n\ttemp = (u_long) gus_max_frequency[sc->sc_voices-GUS_MIN_VOICES];\n\n \tfc = (unsigned int)(((f << 9L) + (temp >> 1L)) / temp);\n\n \tfc <<= 1;\n\n\n\t/*\n\t * Program the voice frequency, and set it in the voice data record\n\t */\n\n\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, (unsigned char) voice);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_FREQ_CONTROL);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, fc);\n\n\tsc->sc_voc[voice].rate = freq;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "100"
          ],
          "line": 2134
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "sc->sc_voc[i].volcntl"
          ],
          "line": 2132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_VOLUME_CONTROL"
          ],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "sc->sc_voc[i].voccntl"
          ],
          "line": 2126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_VOICE_CNTL"
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_VOICE_SELECT",
            "(unsigned char) i"
          ],
          "line": 2119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH"
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_IRQ_STATUS"
          ],
          "line": 2111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH"
          ],
          "line": 2110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_SAMPLE_CONTROL"
          ],
          "line": 2109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH"
          ],
          "line": 2108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_DMA_CONTROL"
          ],
          "line": 2107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh1",
            "GUS_IRQ_STATUS"
          ],
          "line": 2106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gus_set_voices",
          "args": [
            "sc",
            "voices"
          ],
          "line": 2104
        },
        "resolved": true,
        "details": {
          "function_name": "gus_set_voices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "1652-1666",
          "snippet": "inline void gus_set_voices(sc, voices)\nstruct gus_softc *sc;\nint voices;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\t/*\n\t * Select the active number of voices\n\t */\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_ACTIVE_VOICES);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, (voices-1) | 0xc0);\n\n\tsc->sc_voices = voices;\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\ninline void gus_set_voices(sc, voices)\nstruct gus_softc *sc;\nint voices;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\t/*\n\t * Select the active number of voices\n\t */\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_ACTIVE_VOICES);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, (voices-1) | 0xc0);\n\n\tsc->sc_voices = voices;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "0x00"
          ],
          "line": 2102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_SAMPLE_CONTROL"
          ],
          "line": 2101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "0x00"
          ],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_TIMER_CONTROL"
          ],
          "line": 2099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "0x00"
          ],
          "line": 2098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_DMA_CONTROL"
          ],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh4",
            "GUS_MIDI_CONTROL",
            "0x00"
          ],
          "line": 2091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh4",
            "GUS_MIDI_CONTROL",
            "MIDI_RESET"
          ],
          "line": 2087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "GUSMASK_MASTER_RESET"
          ],
          "line": 2079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_RESET"
          ],
          "line": 2078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "0x00"
          ],
          "line": 2070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_RESET"
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splgus",
          "args": [],
          "line": 2063
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ngusreset(sc, voices)\n\tstruct gus_softc *sc;\n\tint voices;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh1 = sc->sc_ioh1;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tbus_space_handle_t ioh4 = sc->sc_ioh4;\n\tint i,s;\n\n\ts = splgus();\n\n\t/*\n\t * Reset the GF1 chip\n\t */\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_RESET);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);\n\n\tdelay(500);\n\n\t/*\n\t * Release reset\n\t */\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_RESET);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, GUSMASK_MASTER_RESET);\n\n\tdelay(500);\n\n\t/*\n\t * Reset MIDI port as well\n\t */\n\n\tbus_space_write_1(iot, ioh4, GUS_MIDI_CONTROL, MIDI_RESET);\n\n\tdelay(500);\n\n\tbus_space_write_1(iot, ioh4, GUS_MIDI_CONTROL, 0x00);\n\n\t/*\n\t * Clear interrupts\n\t */\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_TIMER_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_SAMPLE_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);\n\n\tgus_set_voices(sc, voices);\n\n\tbus_space_read_1(iot, ioh1, GUS_IRQ_STATUS);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);\n\tbus_space_read_1(iot, ioh2, GUS_DATA_HIGH);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_SAMPLE_CONTROL);\n\tbus_space_read_1(iot, ioh2, GUS_DATA_HIGH);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_IRQ_STATUS);\n\tbus_space_read_1(iot, ioh2, GUS_DATA_HIGH);\n\n\t/*\n\t * Reset voice specific information\n\t */\n\n\tfor(i = 0; i < voices; i++) {\n\t\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, (unsigned char) i);\n\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\n\t\tsc->sc_voc[i].voccntl = GUSMASK_VOICE_STOPPED |\n\t\t\tGUSMASK_STOP_VOICE;\n\n\t\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[i].voccntl);\n\n\t\tsc->sc_voc[i].volcntl = GUSMASK_VOLUME_STOPPED |\n\t\t\t\tGUSMASK_STOP_VOLUME;\n\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_CONTROL);\n\t\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[i].volcntl);\n\n\t\tdelay(100);\n\n\t\tgus_set_samprate(sc, i, 8000);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_START_ADDR_HIGH);\n\t\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_START_ADDR_LOW);\n\t\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_END_ADDR_HIGH);\n\t\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_END_ADDR_LOW);\n\t\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_RATE);\n\t\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x01);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_START_VOLUME);\n\t\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x10);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_END_VOLUME);\n\t\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0xe0);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_VOLUME);\n\t\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_HIGH);\n\t\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_LOW);\n\t\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_PAN_POS);\n\t\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x07);\n\t}\n\n\t/*\n\t * Clear out any pending IRQs\n\t */\n\n\tbus_space_read_1(iot, ioh1, GUS_IRQ_STATUS);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);\n\tbus_space_read_1(iot, ioh2, GUS_DATA_HIGH);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_SAMPLE_CONTROL);\n\tbus_space_read_1(iot, ioh2, GUS_DATA_HIGH);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_IRQ_STATUS);\n\tbus_space_read_1(iot, ioh2, GUS_DATA_HIGH);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_RESET);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, GUSMASK_MASTER_RESET | GUSMASK_DAC_ENABLE |\n\t\tGUSMASK_IRQ_ENABLE);\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "guspeek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "2025-2046",
    "snippet": "unsigned char\nguspeek(iot, ioh2, address)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh2;\n\tu_long address;\n{\n\n\t/*\n\t * Select the DRAM address\n\t */\n\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_LOW);\n \tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, (unsigned int) (address & 0xffff));\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_HIGH);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, (unsigned char) ((address >> 16) & 0xff));\n\n\t/*\n\t * Read in the data from the board\n\t */\n\n\treturn (unsigned char) bus_space_read_1(iot, ioh2, GUS_DRAM_DATA);\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DRAM_DATA"
          ],
          "line": 2045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "(unsigned char) ((address >> 16) & 0xff)"
          ],
          "line": 2039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_DRAM_ADDR_HIGH"
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_LOW",
            "(unsigned int) (address & 0xffff)"
          ],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_DRAM_ADDR_LOW"
          ],
          "line": 2036
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nunsigned char\nguspeek(iot, ioh2, address)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh2;\n\tu_long address;\n{\n\n\t/*\n\t * Select the DRAM address\n\t */\n\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_LOW);\n \tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, (unsigned int) (address & 0xffff));\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_HIGH);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, (unsigned char) ((address >> 16) & 0xff));\n\n\t/*\n\t * Read in the data from the board\n\t */\n\n\treturn (unsigned char) bus_space_read_1(iot, ioh2, GUS_DRAM_DATA);\n}"
  },
  {
    "function_name": "guspoke",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "1997-2019",
    "snippet": "void\nguspoke(iot, ioh2, address, value)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh2;\n\tlong address;\n\tunsigned char value;\n{\n\n\t/*\n\t * Select the DRAM address\n\t */\n\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_LOW);\n \tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, (unsigned int) (address & 0xffff));\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_HIGH);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, (unsigned char) ((address >> 16) & 0xff));\n\n\t/*\n\t * Actually write the data\n\t */\n\n\tbus_space_write_1(iot, ioh2, GUS_DRAM_DATA, value);\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DRAM_DATA",
            "value"
          ],
          "line": 2018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "(unsigned char) ((address >> 16) & 0xff)"
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_DRAM_ADDR_HIGH"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_LOW",
            "(unsigned int) (address & 0xffff)"
          ],
          "line": 2010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_DRAM_ADDR_LOW"
          ],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nguspoke(iot, ioh2, address, value)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh2;\n\tlong address;\n\tunsigned char value;\n{\n\n\t/*\n\t * Select the DRAM address\n\t */\n\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_LOW);\n \tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, (unsigned int) (address & 0xffff));\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_HIGH);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, (unsigned char) ((address >> 16) & 0xff));\n\n\t/*\n\t * Actually write the data\n\t */\n\n\tbus_space_write_1(iot, ioh2, GUS_DRAM_DATA, value);\n}"
  },
  {
    "function_name": "convert_to_16bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "1979-1991",
    "snippet": "u_long\nconvert_to_16bit(address)\n\tu_long address;\n{\n\tu_long old_address;\n\n\told_address = address;\n\taddress >>= 1;\n\taddress &= 0x0001ffffL;\n\taddress |= (old_address & 0x000c0000L);\n\n\treturn (address);\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_long\nconvert_to_16bit(address)\n\tu_long address;\n{\n\tu_long old_address;\n\n\told_address = address;\n\taddress >>= 1;\n\taddress &= 0x0001ffffL;\n\taddress |= (old_address & 0x000c0000L);\n\n\treturn (address);\n}"
  },
  {
    "function_name": "gus_get_curaddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "1949-1971",
    "snippet": "u_long\ngus_get_curaddr(sc, voice)\n\tstruct gus_softc *sc;\n\tint voice;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tu_long addr;\n\n\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, (unsigned char) voice);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_HIGH|GUSREG_READ);\n\taddr = (bus_space_read_2(iot, ioh2, GUS_DATA_LOW) & 0x1fff) << 7;\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_LOW|GUSREG_READ);\n\taddr |= (bus_space_read_2(iot, ioh2, GUS_DATA_LOW) >> 9L) & 0x7f;\n\n\tif (sc->sc_voc[voice].voccntl & GUSMASK_DATA_SIZE16)\n\t    addr = (addr & 0xc0000) | ((addr & 0x1ffff) << 1); /* undo 16-bit change */\n\tDPRINTF((\"gus voice %d curaddr %ld end_addr %ld\\n\",\n\t\t voice, addr, sc->sc_voc[voice].end_addr));\n\t/* XXX sanity check the address? */\n\n\treturn(addr);\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"gus voice %d curaddr %ld end_addr %ld\\n\",\n\t\t voice, addr, sc->sc_voc[voice].end_addr)"
          ],
          "line": 1966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_LOW"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_CUR_ADDR_LOW|GUSREG_READ"
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_2",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_LOW"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_CUR_ADDR_HIGH|GUSREG_READ"
          ],
          "line": 1959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_VOICE_SELECT",
            "(unsigned char) voice"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_long\ngus_get_curaddr(sc, voice)\n\tstruct gus_softc *sc;\n\tint voice;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tu_long addr;\n\n\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, (unsigned char) voice);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_HIGH|GUSREG_READ);\n\taddr = (bus_space_read_2(iot, ioh2, GUS_DATA_LOW) & 0x1fff) << 7;\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_LOW|GUSREG_READ);\n\taddr |= (bus_space_read_2(iot, ioh2, GUS_DATA_LOW) >> 9L) & 0x7f;\n\n\tif (sc->sc_voc[voice].voccntl & GUSMASK_DATA_SIZE16)\n\t    addr = (addr & 0xc0000) | ((addr & 0x1ffff) << 1); /* undo 16-bit change */\n\tDPRINTF((\"gus voice %d curaddr %ld end_addr %ld\\n\",\n\t\t voice, addr, sc->sc_voc[voice].end_addr));\n\t/* XXX sanity check the address? */\n\n\treturn(addr);\n}"
  },
  {
    "function_name": "gus_set_curaddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "1923-1944",
    "snippet": "void\ngus_set_curaddr(sc, voice, addr)\n\tstruct gus_softc *sc;\n\tint voice;\n\tu_long addr;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\n\tsc->sc_voc[voice].current_addr = addr;\n\n\tif (sc->sc_voc[voice].voccntl & GUSMASK_DATA_SIZE16)\n\t\taddr = convert_to_16bit(addr);\n\n\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, (unsigned char) voice);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_HIGH);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_HIGH(addr));\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_LOW);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_LOW(addr));\n\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_LOW",
            "ADDR_LOW(addr)"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADDR_LOW",
          "args": [
            "addr"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_CUR_ADDR_LOW"
          ],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_LOW",
            "ADDR_HIGH(addr)"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADDR_HIGH",
          "args": [
            "addr"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_CUR_ADDR_HIGH"
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_VOICE_SELECT",
            "(unsigned char) voice"
          ],
          "line": 1937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "convert_to_16bit",
          "args": [
            "addr"
          ],
          "line": 1935
        },
        "resolved": true,
        "details": {
          "function_name": "convert_to_16bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "1979-1991",
          "snippet": "u_long\nconvert_to_16bit(address)\n\tu_long address;\n{\n\tu_long old_address;\n\n\told_address = address;\n\taddress >>= 1;\n\taddress &= 0x0001ffffL;\n\taddress |= (old_address & 0x000c0000L);\n\n\treturn (address);\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_long\nconvert_to_16bit(address)\n\tu_long address;\n{\n\tu_long old_address;\n\n\told_address = address;\n\taddress >>= 1;\n\taddress &= 0x0001ffffL;\n\taddress |= (old_address & 0x000c0000L);\n\n\treturn (address);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ngus_set_curaddr(sc, voice, addr)\n\tstruct gus_softc *sc;\n\tint voice;\n\tu_long addr;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\n\tsc->sc_voc[voice].current_addr = addr;\n\n\tif (sc->sc_voc[voice].voccntl & GUSMASK_DATA_SIZE16)\n\t\taddr = convert_to_16bit(addr);\n\n\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, (unsigned char) voice);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_HIGH);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_HIGH(addr));\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_LOW);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_LOW(addr));\n\n}"
  },
  {
    "function_name": "gus_set_endaddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "1898-1917",
    "snippet": "void\ngus_set_endaddr(sc, voice, addr)\n\tstruct gus_softc *sc;\n\tint voice;\n\tu_long addr;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\n\tsc->sc_voc[voice].end_addr = addr;\n\n\tif (sc->sc_voc[voice].voccntl & GUSMASK_DATA_SIZE16)\n\t\taddr = convert_to_16bit(addr);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_END_ADDR_HIGH);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_HIGH(addr));\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_END_ADDR_LOW);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_LOW(addr));\n\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_LOW",
            "ADDR_LOW(addr)"
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADDR_LOW",
          "args": [
            "addr"
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_END_ADDR_LOW"
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_LOW",
            "ADDR_HIGH(addr)"
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADDR_HIGH",
          "args": [
            "addr"
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_END_ADDR_HIGH"
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "convert_to_16bit",
          "args": [
            "addr"
          ],
          "line": 1910
        },
        "resolved": true,
        "details": {
          "function_name": "convert_to_16bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "1979-1991",
          "snippet": "u_long\nconvert_to_16bit(address)\n\tu_long address;\n{\n\tu_long old_address;\n\n\told_address = address;\n\taddress >>= 1;\n\taddress &= 0x0001ffffL;\n\taddress |= (old_address & 0x000c0000L);\n\n\treturn (address);\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_long\nconvert_to_16bit(address)\n\tu_long address;\n{\n\tu_long old_address;\n\n\told_address = address;\n\taddress >>= 1;\n\taddress &= 0x0001ffffL;\n\taddress |= (old_address & 0x000c0000L);\n\n\treturn (address);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ngus_set_endaddr(sc, voice, addr)\n\tstruct gus_softc *sc;\n\tint voice;\n\tu_long addr;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\n\tsc->sc_voc[voice].end_addr = addr;\n\n\tif (sc->sc_voc[voice].voccntl & GUSMASK_DATA_SIZE16)\n\t\taddr = convert_to_16bit(addr);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_END_ADDR_HIGH);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_HIGH(addr));\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_END_ADDR_LOW);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_LOW(addr));\n\n}"
  },
  {
    "function_name": "gus_mic_ctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "1870-1892",
    "snippet": "int\ngus_mic_ctl(addr, newstate)\n\tvoid * addr;\n\tint newstate;\n{\n\tstruct gus_softc *sc = (struct gus_softc *) addr;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh1 = sc->sc_ioh1;\n\n\t/* Mic bit is normal: 1 enables, 0 disables */\n\tif ((newstate == SPKR_ON) &&\n\t    (sc->sc_mixcontrol & GUSMASK_MIC_IN) == 0) {\n\t\tsc->sc_mixcontrol |= GUSMASK_MIC_IN;\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t}\n\tif ((newstate == SPKR_OFF) &&\n\t    (sc->sc_mixcontrol & GUSMASK_MIC_IN)) {\n\t\tsc->sc_mixcontrol &= ~GUSMASK_MIC_IN;\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh1",
            "GUS_MIX_CONTROL",
            "sc->sc_mixcontrol"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh1",
            "GUS_MIX_CONTROL",
            "sc->sc_mixcontrol"
          ],
          "line": 1883
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngus_mic_ctl(addr, newstate)\n\tvoid * addr;\n\tint newstate;\n{\n\tstruct gus_softc *sc = (struct gus_softc *) addr;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh1 = sc->sc_ioh1;\n\n\t/* Mic bit is normal: 1 enables, 0 disables */\n\tif ((newstate == SPKR_ON) &&\n\t    (sc->sc_mixcontrol & GUSMASK_MIC_IN) == 0) {\n\t\tsc->sc_mixcontrol |= GUSMASK_MIC_IN;\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t}\n\tif ((newstate == SPKR_OFF) &&\n\t    (sc->sc_mixcontrol & GUSMASK_MIC_IN)) {\n\t\tsc->sc_mixcontrol &= ~GUSMASK_MIC_IN;\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "gus_linein_ctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "1846-1868",
    "snippet": "int\ngus_linein_ctl(addr, newstate)\n\tvoid * addr;\n\tint newstate;\n{\n\tstruct gus_softc *sc = (struct gus_softc *) addr;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh1 = sc->sc_ioh1;\n\n\t/* Line in bit is flipped: 0 enables, 1 disables */\n\tif ((newstate == SPKR_ON) &&\n\t    (sc->sc_mixcontrol & GUSMASK_LINE_IN)) {\n\t\tsc->sc_mixcontrol &= ~GUSMASK_LINE_IN;\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t}\n\tif ((newstate == SPKR_OFF) &&\n\t    (sc->sc_mixcontrol & GUSMASK_LINE_IN) == 0) {\n\t\tsc->sc_mixcontrol |= GUSMASK_LINE_IN;\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh1",
            "GUS_MIX_CONTROL",
            "sc->sc_mixcontrol"
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh1",
            "GUS_MIX_CONTROL",
            "sc->sc_mixcontrol"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngus_linein_ctl(addr, newstate)\n\tvoid * addr;\n\tint newstate;\n{\n\tstruct gus_softc *sc = (struct gus_softc *) addr;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh1 = sc->sc_ioh1;\n\n\t/* Line in bit is flipped: 0 enables, 1 disables */\n\tif ((newstate == SPKR_ON) &&\n\t    (sc->sc_mixcontrol & GUSMASK_LINE_IN)) {\n\t\tsc->sc_mixcontrol &= ~GUSMASK_LINE_IN;\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t}\n\tif ((newstate == SPKR_OFF) &&\n\t    (sc->sc_mixcontrol & GUSMASK_LINE_IN) == 0) {\n\t\tsc->sc_mixcontrol |= GUSMASK_LINE_IN;\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "gus_speaker_ctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "1822-1844",
    "snippet": "int\ngus_speaker_ctl(addr, newstate)\n\tvoid * addr;\n\tint newstate;\n{\n\tstruct gus_softc *sc = (struct gus_softc *) addr;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh1 = sc->sc_ioh1;\n\n\t/* Line out bit is flipped: 0 enables, 1 disables */\n\tif ((newstate == SPKR_ON) &&\n\t    (sc->sc_mixcontrol & GUSMASK_LINE_OUT)) {\n\t\tsc->sc_mixcontrol &= ~GUSMASK_LINE_OUT;\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t}\n\tif ((newstate == SPKR_OFF) &&\n\t    (sc->sc_mixcontrol & GUSMASK_LINE_OUT) == 0) {\n\t\tsc->sc_mixcontrol |= GUSMASK_LINE_OUT;\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh1",
            "GUS_MIX_CONTROL",
            "sc->sc_mixcontrol"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh1",
            "GUS_MIX_CONTROL",
            "sc->sc_mixcontrol"
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngus_speaker_ctl(addr, newstate)\n\tvoid * addr;\n\tint newstate;\n{\n\tstruct gus_softc *sc = (struct gus_softc *) addr;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh1 = sc->sc_ioh1;\n\n\t/* Line out bit is flipped: 0 enables, 1 disables */\n\tif ((newstate == SPKR_ON) &&\n\t    (sc->sc_mixcontrol & GUSMASK_LINE_OUT)) {\n\t\tsc->sc_mixcontrol &= ~GUSMASK_LINE_OUT;\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t}\n\tif ((newstate == SPKR_OFF) &&\n\t    (sc->sc_mixcontrol & GUSMASK_LINE_OUT) == 0) {\n\t\tsc->sc_mixcontrol |= GUSMASK_LINE_OUT;\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "gusmax_speaker_ctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "1813-1820",
    "snippet": "int\ngusmax_speaker_ctl(addr, newstate)\n\tvoid * addr;\n\tint newstate;\n{\n\tstruct ad1848_softc *sc = addr;\n\treturn gus_speaker_ctl(sc->parent, newstate);\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gus_speaker_ctl",
          "args": [
            "sc->parent",
            "newstate"
          ],
          "line": 1819
        },
        "resolved": true,
        "details": {
          "function_name": "gus_speaker_ctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "1822-1844",
          "snippet": "int\ngus_speaker_ctl(addr, newstate)\n\tvoid * addr;\n\tint newstate;\n{\n\tstruct gus_softc *sc = (struct gus_softc *) addr;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh1 = sc->sc_ioh1;\n\n\t/* Line out bit is flipped: 0 enables, 1 disables */\n\tif ((newstate == SPKR_ON) &&\n\t    (sc->sc_mixcontrol & GUSMASK_LINE_OUT)) {\n\t\tsc->sc_mixcontrol &= ~GUSMASK_LINE_OUT;\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t}\n\tif ((newstate == SPKR_OFF) &&\n\t    (sc->sc_mixcontrol & GUSMASK_LINE_OUT) == 0) {\n\t\tsc->sc_mixcontrol |= GUSMASK_LINE_OUT;\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngus_speaker_ctl(addr, newstate)\n\tvoid * addr;\n\tint newstate;\n{\n\tstruct gus_softc *sc = (struct gus_softc *) addr;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh1 = sc->sc_ioh1;\n\n\t/* Line out bit is flipped: 0 enables, 1 disables */\n\tif ((newstate == SPKR_ON) &&\n\t    (sc->sc_mixcontrol & GUSMASK_LINE_OUT)) {\n\t\tsc->sc_mixcontrol &= ~GUSMASK_LINE_OUT;\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t}\n\tif ((newstate == SPKR_OFF) &&\n\t    (sc->sc_mixcontrol & GUSMASK_LINE_OUT) == 0) {\n\t\tsc->sc_mixcontrol |= GUSMASK_LINE_OUT;\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngusmax_speaker_ctl(addr, newstate)\n\tvoid * addr;\n\tint newstate;\n{\n\tstruct ad1848_softc *sc = addr;\n\treturn gus_speaker_ctl(sc->parent, newstate);\n}"
  },
  {
    "function_name": "gus_set_recrate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "1789-1806",
    "snippet": "void\ngus_set_recrate(sc, rate)\n\tstruct gus_softc *sc;\n\tu_long rate;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tu_char realrate;\n\tDPRINTF((\"gus_set_recrate %lu\\n\", rate));\n\n#if 0\n\trealrate = 9878400/(16*(rate+2)); /* formula from GUS docs */\n#endif\n\trealrate = (9878400 >> 4)/rate - 2; /* formula from code, sigh. */\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_SAMPLE_FREQ);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, realrate);\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "realrate"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_SAMPLE_FREQ"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"gus_set_recrate %lu\\n\", rate)"
          ],
          "line": 1797
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ngus_set_recrate(sc, rate)\n\tstruct gus_softc *sc;\n\tu_long rate;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tu_char realrate;\n\tDPRINTF((\"gus_set_recrate %lu\\n\", rate));\n\n#if 0\n\trealrate = 9878400/(16*(rate+2)); /* formula from GUS docs */\n#endif\n\trealrate = (9878400 >> 4)/rate - 2; /* formula from code, sigh. */\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_SAMPLE_FREQ);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, realrate);\n}"
  },
  {
    "function_name": "gus_set_samprate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "1750-1782",
    "snippet": "void\ngus_set_samprate(sc, voice, freq)\n\tstruct gus_softc *sc;\n\tint voice, freq;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tunsigned int fc;\n\tu_long temp, f = (u_long) freq;\n\n\t/*\n\t * calculate fc based on the number of active voices;\n\t * we need to use longs to preserve enough bits\n\t */\n\n\ttemp = (u_long) gus_max_frequency[sc->sc_voices-GUS_MIN_VOICES];\n\n \tfc = (unsigned int)(((f << 9L) + (temp >> 1L)) / temp);\n\n \tfc <<= 1;\n\n\n\t/*\n\t * Program the voice frequency, and set it in the voice data record\n\t */\n\n\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, (unsigned char) voice);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_FREQ_CONTROL);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, fc);\n\n\tsc->sc_voc[voice].rate = freq;\n\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int gus_max_frequency[] = {\n\t\t44100,\t\t/* 14 voices */\n\t\t41160,\t\t/* 15 voices */\n\t\t38587,\t\t/* 16 voices */\n\t\t36317,\t\t/* 17 voices */\n\t\t34300,\t\t/* 18 voices */\n\t\t32494,\t\t/* 19 voices */\n\t\t30870,\t\t/* 20 voices */\n\t\t29400,\t\t/* 21 voices */\n\t\t28063,\t\t/* 22 voices */\n\t\t26843,\t\t/* 23 voices */\n\t\t25725,\t\t/* 24 voices */\n\t\t24696,\t\t/* 25 voices */\n\t\t23746,\t\t/* 26 voices */\n\t\t22866,\t\t/* 27 voices */\n\t\t22050,\t\t/* 28 voices */\n\t\t21289,\t\t/* 29 voices */\n\t\t20580,\t\t/* 30 voices */\n\t\t19916,\t\t/* 31 voices */\n\t\t19293\t\t/* 32 voices */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_LOW",
            "fc"
          ],
          "line": 1778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_FREQ_CONTROL"
          ],
          "line": 1777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_VOICE_SELECT",
            "(unsigned char) voice"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int gus_max_frequency[] = {\n\t\t44100,\t\t/* 14 voices */\n\t\t41160,\t\t/* 15 voices */\n\t\t38587,\t\t/* 16 voices */\n\t\t36317,\t\t/* 17 voices */\n\t\t34300,\t\t/* 18 voices */\n\t\t32494,\t\t/* 19 voices */\n\t\t30870,\t\t/* 20 voices */\n\t\t29400,\t\t/* 21 voices */\n\t\t28063,\t\t/* 22 voices */\n\t\t26843,\t\t/* 23 voices */\n\t\t25725,\t\t/* 24 voices */\n\t\t24696,\t\t/* 25 voices */\n\t\t23746,\t\t/* 26 voices */\n\t\t22866,\t\t/* 27 voices */\n\t\t22050,\t\t/* 28 voices */\n\t\t21289,\t\t/* 29 voices */\n\t\t20580,\t\t/* 30 voices */\n\t\t19916,\t\t/* 31 voices */\n\t\t19293\t\t/* 32 voices */\n};\n\nvoid\ngus_set_samprate(sc, voice, freq)\n\tstruct gus_softc *sc;\n\tint voice, freq;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tunsigned int fc;\n\tu_long temp, f = (u_long) freq;\n\n\t/*\n\t * calculate fc based on the number of active voices;\n\t * we need to use longs to preserve enough bits\n\t */\n\n\ttemp = (u_long) gus_max_frequency[sc->sc_voices-GUS_MIN_VOICES];\n\n \tfc = (unsigned int)(((f << 9L) + (temp >> 1L)) / temp);\n\n \tfc <<= 1;\n\n\n\t/*\n\t * Program the voice frequency, and set it in the voice data record\n\t */\n\n\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, (unsigned char) voice);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_FREQ_CONTROL);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, fc);\n\n\tsc->sc_voc[voice].rate = freq;\n\n}"
  },
  {
    "function_name": "gus_set_chan_addrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "1712-1744",
    "snippet": "void\ngus_set_chan_addrs(sc)\nstruct gus_softc *sc;\n{\n\t/*\n\t * We use sc_nbufs * blocksize bytes of storage in the on-board GUS\n\t * ram. \n\t * For mono, each of the sc_nbufs buffers is DMA'd to in one chunk,\n\t * and both left & right channels play the same buffer.\n\t *\n\t * For stereo, each channel gets a contiguous half of the memory,\n\t * and each has sc_nbufs buffers of size blocksize/2.\n\t * Stereo data are deinterleaved in main memory before the DMA out\n\t * routines are called to queue the output.\n\t *\n\t * The blocksize per channel is kept in sc_chanblocksize.\n\t */\n\tif (sc->sc_channels == 2)\n\t    sc->sc_chanblocksize = sc->sc_blocksize/2;\n\telse\n\t    sc->sc_chanblocksize = sc->sc_blocksize;\n\n\tsc->sc_voc[GUS_VOICE_LEFT].start_addr = GUS_MEM_OFFSET - 1;\n\tsc->sc_voc[GUS_VOICE_RIGHT].start_addr =\n\t    (gus_dostereo && sc->sc_channels == 2 ? GUS_LEFT_RIGHT_OFFSET : 0)\n\t      + GUS_MEM_OFFSET - 1;\n\tsc->sc_voc[GUS_VOICE_RIGHT].current_addr =\n\t    sc->sc_voc[GUS_VOICE_RIGHT].start_addr + 1;\n\tsc->sc_voc[GUS_VOICE_RIGHT].end_addr =\n\t    sc->sc_voc[GUS_VOICE_RIGHT].start_addr +\n\t    sc->sc_nbufs * sc->sc_chanblocksize;\n\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int\tgus_dostereo = 1;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tgus_dostereo = 1;\n\nvoid\ngus_set_chan_addrs(sc)\nstruct gus_softc *sc;\n{\n\t/*\n\t * We use sc_nbufs * blocksize bytes of storage in the on-board GUS\n\t * ram. \n\t * For mono, each of the sc_nbufs buffers is DMA'd to in one chunk,\n\t * and both left & right channels play the same buffer.\n\t *\n\t * For stereo, each channel gets a contiguous half of the memory,\n\t * and each has sc_nbufs buffers of size blocksize/2.\n\t * Stereo data are deinterleaved in main memory before the DMA out\n\t * routines are called to queue the output.\n\t *\n\t * The blocksize per channel is kept in sc_chanblocksize.\n\t */\n\tif (sc->sc_channels == 2)\n\t    sc->sc_chanblocksize = sc->sc_blocksize/2;\n\telse\n\t    sc->sc_chanblocksize = sc->sc_blocksize;\n\n\tsc->sc_voc[GUS_VOICE_LEFT].start_addr = GUS_MEM_OFFSET - 1;\n\tsc->sc_voc[GUS_VOICE_RIGHT].start_addr =\n\t    (gus_dostereo && sc->sc_channels == 2 ? GUS_LEFT_RIGHT_OFFSET : 0)\n\t      + GUS_MEM_OFFSET - 1;\n\tsc->sc_voc[GUS_VOICE_RIGHT].current_addr =\n\t    sc->sc_voc[GUS_VOICE_RIGHT].start_addr + 1;\n\tsc->sc_voc[GUS_VOICE_RIGHT].end_addr =\n\t    sc->sc_voc[GUS_VOICE_RIGHT].start_addr +\n\t    sc->sc_nbufs * sc->sc_chanblocksize;\n\n}"
  },
  {
    "function_name": "gus_commit_settings",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "1689-1710",
    "snippet": "int\ngus_commit_settings(addr)\n\tvoid * addr;\n{\n\tstruct gus_softc *sc = addr;\n\tint s;\n\n\tDPRINTF((\"gus_commit_settings called (gain = %d)\\n\",sc->sc_ogain));\n\n\n\ts = splgus();\n\n\tgus_set_recrate(sc, sc->sc_irate);\n\tgus_set_volume(sc, GUS_VOICE_LEFT, sc->sc_ogain);\n\tgus_set_volume(sc, GUS_VOICE_RIGHT, sc->sc_ogain);\n\tgus_set_samprate(sc, GUS_VOICE_LEFT, sc->sc_orate);\n\tgus_set_samprate(sc, GUS_VOICE_RIGHT, sc->sc_orate);\n\tsplx(s);\n\tgus_set_chan_addrs(sc);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gus_set_chan_addrs",
          "args": [
            "sc"
          ],
          "line": 1707
        },
        "resolved": true,
        "details": {
          "function_name": "gus_set_chan_addrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "1712-1744",
          "snippet": "void\ngus_set_chan_addrs(sc)\nstruct gus_softc *sc;\n{\n\t/*\n\t * We use sc_nbufs * blocksize bytes of storage in the on-board GUS\n\t * ram. \n\t * For mono, each of the sc_nbufs buffers is DMA'd to in one chunk,\n\t * and both left & right channels play the same buffer.\n\t *\n\t * For stereo, each channel gets a contiguous half of the memory,\n\t * and each has sc_nbufs buffers of size blocksize/2.\n\t * Stereo data are deinterleaved in main memory before the DMA out\n\t * routines are called to queue the output.\n\t *\n\t * The blocksize per channel is kept in sc_chanblocksize.\n\t */\n\tif (sc->sc_channels == 2)\n\t    sc->sc_chanblocksize = sc->sc_blocksize/2;\n\telse\n\t    sc->sc_chanblocksize = sc->sc_blocksize;\n\n\tsc->sc_voc[GUS_VOICE_LEFT].start_addr = GUS_MEM_OFFSET - 1;\n\tsc->sc_voc[GUS_VOICE_RIGHT].start_addr =\n\t    (gus_dostereo && sc->sc_channels == 2 ? GUS_LEFT_RIGHT_OFFSET : 0)\n\t      + GUS_MEM_OFFSET - 1;\n\tsc->sc_voc[GUS_VOICE_RIGHT].current_addr =\n\t    sc->sc_voc[GUS_VOICE_RIGHT].start_addr + 1;\n\tsc->sc_voc[GUS_VOICE_RIGHT].end_addr =\n\t    sc->sc_voc[GUS_VOICE_RIGHT].start_addr +\n\t    sc->sc_nbufs * sc->sc_chanblocksize;\n\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tgus_dostereo = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tgus_dostereo = 1;\n\nvoid\ngus_set_chan_addrs(sc)\nstruct gus_softc *sc;\n{\n\t/*\n\t * We use sc_nbufs * blocksize bytes of storage in the on-board GUS\n\t * ram. \n\t * For mono, each of the sc_nbufs buffers is DMA'd to in one chunk,\n\t * and both left & right channels play the same buffer.\n\t *\n\t * For stereo, each channel gets a contiguous half of the memory,\n\t * and each has sc_nbufs buffers of size blocksize/2.\n\t * Stereo data are deinterleaved in main memory before the DMA out\n\t * routines are called to queue the output.\n\t *\n\t * The blocksize per channel is kept in sc_chanblocksize.\n\t */\n\tif (sc->sc_channels == 2)\n\t    sc->sc_chanblocksize = sc->sc_blocksize/2;\n\telse\n\t    sc->sc_chanblocksize = sc->sc_blocksize;\n\n\tsc->sc_voc[GUS_VOICE_LEFT].start_addr = GUS_MEM_OFFSET - 1;\n\tsc->sc_voc[GUS_VOICE_RIGHT].start_addr =\n\t    (gus_dostereo && sc->sc_channels == 2 ? GUS_LEFT_RIGHT_OFFSET : 0)\n\t      + GUS_MEM_OFFSET - 1;\n\tsc->sc_voc[GUS_VOICE_RIGHT].current_addr =\n\t    sc->sc_voc[GUS_VOICE_RIGHT].start_addr + 1;\n\tsc->sc_voc[GUS_VOICE_RIGHT].end_addr =\n\t    sc->sc_voc[GUS_VOICE_RIGHT].start_addr +\n\t    sc->sc_nbufs * sc->sc_chanblocksize;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gus_set_samprate",
          "args": [
            "sc",
            "GUS_VOICE_RIGHT",
            "sc->sc_orate"
          ],
          "line": 1705
        },
        "resolved": true,
        "details": {
          "function_name": "gus_set_samprate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "1750-1782",
          "snippet": "void\ngus_set_samprate(sc, voice, freq)\n\tstruct gus_softc *sc;\n\tint voice, freq;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tunsigned int fc;\n\tu_long temp, f = (u_long) freq;\n\n\t/*\n\t * calculate fc based on the number of active voices;\n\t * we need to use longs to preserve enough bits\n\t */\n\n\ttemp = (u_long) gus_max_frequency[sc->sc_voices-GUS_MIN_VOICES];\n\n \tfc = (unsigned int)(((f << 9L) + (temp >> 1L)) / temp);\n\n \tfc <<= 1;\n\n\n\t/*\n\t * Program the voice frequency, and set it in the voice data record\n\t */\n\n\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, (unsigned char) voice);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_FREQ_CONTROL);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, fc);\n\n\tsc->sc_voc[voice].rate = freq;\n\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int gus_max_frequency[] = {\n\t\t44100,\t\t/* 14 voices */\n\t\t41160,\t\t/* 15 voices */\n\t\t38587,\t\t/* 16 voices */\n\t\t36317,\t\t/* 17 voices */\n\t\t34300,\t\t/* 18 voices */\n\t\t32494,\t\t/* 19 voices */\n\t\t30870,\t\t/* 20 voices */\n\t\t29400,\t\t/* 21 voices */\n\t\t28063,\t\t/* 22 voices */\n\t\t26843,\t\t/* 23 voices */\n\t\t25725,\t\t/* 24 voices */\n\t\t24696,\t\t/* 25 voices */\n\t\t23746,\t\t/* 26 voices */\n\t\t22866,\t\t/* 27 voices */\n\t\t22050,\t\t/* 28 voices */\n\t\t21289,\t\t/* 29 voices */\n\t\t20580,\t\t/* 30 voices */\n\t\t19916,\t\t/* 31 voices */\n\t\t19293\t\t/* 32 voices */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int gus_max_frequency[] = {\n\t\t44100,\t\t/* 14 voices */\n\t\t41160,\t\t/* 15 voices */\n\t\t38587,\t\t/* 16 voices */\n\t\t36317,\t\t/* 17 voices */\n\t\t34300,\t\t/* 18 voices */\n\t\t32494,\t\t/* 19 voices */\n\t\t30870,\t\t/* 20 voices */\n\t\t29400,\t\t/* 21 voices */\n\t\t28063,\t\t/* 22 voices */\n\t\t26843,\t\t/* 23 voices */\n\t\t25725,\t\t/* 24 voices */\n\t\t24696,\t\t/* 25 voices */\n\t\t23746,\t\t/* 26 voices */\n\t\t22866,\t\t/* 27 voices */\n\t\t22050,\t\t/* 28 voices */\n\t\t21289,\t\t/* 29 voices */\n\t\t20580,\t\t/* 30 voices */\n\t\t19916,\t\t/* 31 voices */\n\t\t19293\t\t/* 32 voices */\n};\n\nvoid\ngus_set_samprate(sc, voice, freq)\n\tstruct gus_softc *sc;\n\tint voice, freq;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tunsigned int fc;\n\tu_long temp, f = (u_long) freq;\n\n\t/*\n\t * calculate fc based on the number of active voices;\n\t * we need to use longs to preserve enough bits\n\t */\n\n\ttemp = (u_long) gus_max_frequency[sc->sc_voices-GUS_MIN_VOICES];\n\n \tfc = (unsigned int)(((f << 9L) + (temp >> 1L)) / temp);\n\n \tfc <<= 1;\n\n\n\t/*\n\t * Program the voice frequency, and set it in the voice data record\n\t */\n\n\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, (unsigned char) voice);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_FREQ_CONTROL);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, fc);\n\n\tsc->sc_voc[voice].rate = freq;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "gus_set_volume",
          "args": [
            "sc",
            "GUS_VOICE_RIGHT",
            "sc->sc_ogain"
          ],
          "line": 1703
        },
        "resolved": true,
        "details": {
          "function_name": "gus_set_volume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "1478-1504",
          "snippet": "void\ngus_set_volume(sc, voice, volume)\n\tstruct gus_softc *sc;\n\tint voice, volume;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tunsigned int gusvol;\n\n\tgusvol = gus_log_volumes[volume < 512 ? volume : 511];\n\n\tsc->sc_voc[voice].current_volume = gusvol;\n\n\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, (unsigned char) voice);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_START_VOLUME);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, (unsigned char) (gusvol >> 4));\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_END_VOLUME);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, (unsigned char) (gusvol >> 4));\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_VOLUME);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, gusvol << 4);\n\tdelay(500);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, gusvol << 4);\n\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned short gus_log_volumes[512] = {\n 0x0000,\n 0x0700, 0x07ff, 0x0880, 0x08ff, 0x0940, 0x0980, 0x09c0, 0x09ff, 0x0a20,\n 0x0a40, 0x0a60, 0x0a80, 0x0aa0, 0x0ac0, 0x0ae0, 0x0aff, 0x0b10, 0x0b20,\n 0x0b30, 0x0b40, 0x0b50, 0x0b60, 0x0b70, 0x0b80, 0x0b90, 0x0ba0, 0x0bb0,\n 0x0bc0, 0x0bd0, 0x0be0, 0x0bf0, 0x0bff, 0x0c08, 0x0c10, 0x0c18, 0x0c20,\n 0x0c28, 0x0c30, 0x0c38, 0x0c40, 0x0c48, 0x0c50, 0x0c58, 0x0c60, 0x0c68,\n 0x0c70, 0x0c78, 0x0c80, 0x0c88, 0x0c90, 0x0c98, 0x0ca0, 0x0ca8, 0x0cb0,\n 0x0cb8, 0x0cc0, 0x0cc8, 0x0cd0, 0x0cd8, 0x0ce0, 0x0ce8, 0x0cf0, 0x0cf8,\n 0x0cff, 0x0d04, 0x0d08, 0x0d0c, 0x0d10, 0x0d14, 0x0d18, 0x0d1c, 0x0d20,\n 0x0d24, 0x0d28, 0x0d2c, 0x0d30, 0x0d34, 0x0d38, 0x0d3c, 0x0d40, 0x0d44,\n 0x0d48, 0x0d4c, 0x0d50, 0x0d54, 0x0d58, 0x0d5c, 0x0d60, 0x0d64, 0x0d68,\n 0x0d6c, 0x0d70, 0x0d74, 0x0d78, 0x0d7c, 0x0d80, 0x0d84, 0x0d88, 0x0d8c,\n 0x0d90, 0x0d94, 0x0d98, 0x0d9c, 0x0da0, 0x0da4, 0x0da8, 0x0dac, 0x0db0,\n 0x0db4, 0x0db8, 0x0dbc, 0x0dc0, 0x0dc4, 0x0dc8, 0x0dcc, 0x0dd0, 0x0dd4,\n 0x0dd8, 0x0ddc, 0x0de0, 0x0de4, 0x0de8, 0x0dec, 0x0df0, 0x0df4, 0x0df8,\n 0x0dfc, 0x0dff, 0x0e02, 0x0e04, 0x0e06, 0x0e08, 0x0e0a, 0x0e0c, 0x0e0e,\n 0x0e10, 0x0e12, 0x0e14, 0x0e16, 0x0e18, 0x0e1a, 0x0e1c, 0x0e1e, 0x0e20,\n 0x0e22, 0x0e24, 0x0e26, 0x0e28, 0x0e2a, 0x0e2c, 0x0e2e, 0x0e30, 0x0e32,\n 0x0e34, 0x0e36, 0x0e38, 0x0e3a, 0x0e3c, 0x0e3e, 0x0e40, 0x0e42, 0x0e44,\n 0x0e46, 0x0e48, 0x0e4a, 0x0e4c, 0x0e4e, 0x0e50, 0x0e52, 0x0e54, 0x0e56,\n 0x0e58, 0x0e5a, 0x0e5c, 0x0e5e, 0x0e60, 0x0e62, 0x0e64, 0x0e66, 0x0e68,\n 0x0e6a, 0x0e6c, 0x0e6e, 0x0e70, 0x0e72, 0x0e74, 0x0e76, 0x0e78, 0x0e7a,\n 0x0e7c, 0x0e7e, 0x0e80, 0x0e82, 0x0e84, 0x0e86, 0x0e88, 0x0e8a, 0x0e8c,\n 0x0e8e, 0x0e90, 0x0e92, 0x0e94, 0x0e96, 0x0e98, 0x0e9a, 0x0e9c, 0x0e9e,\n 0x0ea0, 0x0ea2, 0x0ea4, 0x0ea6, 0x0ea8, 0x0eaa, 0x0eac, 0x0eae, 0x0eb0,\n 0x0eb2, 0x0eb4, 0x0eb6, 0x0eb8, 0x0eba, 0x0ebc, 0x0ebe, 0x0ec0, 0x0ec2,\n 0x0ec4, 0x0ec6, 0x0ec8, 0x0eca, 0x0ecc, 0x0ece, 0x0ed0, 0x0ed2, 0x0ed4,\n 0x0ed6, 0x0ed8, 0x0eda, 0x0edc, 0x0ede, 0x0ee0, 0x0ee2, 0x0ee4, 0x0ee6,\n 0x0ee8, 0x0eea, 0x0eec, 0x0eee, 0x0ef0, 0x0ef2, 0x0ef4, 0x0ef6, 0x0ef8,\n 0x0efa, 0x0efc, 0x0efe, 0x0eff, 0x0f01, 0x0f02, 0x0f03, 0x0f04, 0x0f05,\n 0x0f06, 0x0f07, 0x0f08, 0x0f09, 0x0f0a, 0x0f0b, 0x0f0c, 0x0f0d, 0x0f0e,\n 0x0f0f, 0x0f10, 0x0f11, 0x0f12, 0x0f13, 0x0f14, 0x0f15, 0x0f16, 0x0f17,\n 0x0f18, 0x0f19, 0x0f1a, 0x0f1b, 0x0f1c, 0x0f1d, 0x0f1e, 0x0f1f, 0x0f20,\n 0x0f21, 0x0f22, 0x0f23, 0x0f24, 0x0f25, 0x0f26, 0x0f27, 0x0f28, 0x0f29,\n 0x0f2a, 0x0f2b, 0x0f2c, 0x0f2d, 0x0f2e, 0x0f2f, 0x0f30, 0x0f31, 0x0f32,\n 0x0f33, 0x0f34, 0x0f35, 0x0f36, 0x0f37, 0x0f38, 0x0f39, 0x0f3a, 0x0f3b,\n 0x0f3c, 0x0f3d, 0x0f3e, 0x0f3f, 0x0f40, 0x0f41, 0x0f42, 0x0f43, 0x0f44,\n 0x0f45, 0x0f46, 0x0f47, 0x0f48, 0x0f49, 0x0f4a, 0x0f4b, 0x0f4c, 0x0f4d,\n 0x0f4e, 0x0f4f, 0x0f50, 0x0f51, 0x0f52, 0x0f53, 0x0f54, 0x0f55, 0x0f56,\n 0x0f57, 0x0f58, 0x0f59, 0x0f5a, 0x0f5b, 0x0f5c, 0x0f5d, 0x0f5e, 0x0f5f,\n 0x0f60, 0x0f61, 0x0f62, 0x0f63, 0x0f64, 0x0f65, 0x0f66, 0x0f67, 0x0f68,\n 0x0f69, 0x0f6a, 0x0f6b, 0x0f6c, 0x0f6d, 0x0f6e, 0x0f6f, 0x0f70, 0x0f71,\n 0x0f72, 0x0f73, 0x0f74, 0x0f75, 0x0f76, 0x0f77, 0x0f78, 0x0f79, 0x0f7a,\n 0x0f7b, 0x0f7c, 0x0f7d, 0x0f7e, 0x0f7f, 0x0f80, 0x0f81, 0x0f82, 0x0f83,\n 0x0f84, 0x0f85, 0x0f86, 0x0f87, 0x0f88, 0x0f89, 0x0f8a, 0x0f8b, 0x0f8c,\n 0x0f8d, 0x0f8e, 0x0f8f, 0x0f90, 0x0f91, 0x0f92, 0x0f93, 0x0f94, 0x0f95,\n 0x0f96, 0x0f97, 0x0f98, 0x0f99, 0x0f9a, 0x0f9b, 0x0f9c, 0x0f9d, 0x0f9e,\n 0x0f9f, 0x0fa0, 0x0fa1, 0x0fa2, 0x0fa3, 0x0fa4, 0x0fa5, 0x0fa6, 0x0fa7,\n 0x0fa8, 0x0fa9, 0x0faa, 0x0fab, 0x0fac, 0x0fad, 0x0fae, 0x0faf, 0x0fb0,\n 0x0fb1, 0x0fb2, 0x0fb3, 0x0fb4, 0x0fb5, 0x0fb6, 0x0fb7, 0x0fb8, 0x0fb9,\n 0x0fba, 0x0fbb, 0x0fbc, 0x0fbd, 0x0fbe, 0x0fbf, 0x0fc0, 0x0fc1, 0x0fc2,\n 0x0fc3, 0x0fc4, 0x0fc5, 0x0fc6, 0x0fc7, 0x0fc8, 0x0fc9, 0x0fca, 0x0fcb,\n 0x0fcc, 0x0fcd, 0x0fce, 0x0fcf, 0x0fd0, 0x0fd1, 0x0fd2, 0x0fd3, 0x0fd4,\n 0x0fd5, 0x0fd6, 0x0fd7, 0x0fd8, 0x0fd9, 0x0fda, 0x0fdb, 0x0fdc, 0x0fdd,\n 0x0fde, 0x0fdf, 0x0fe0, 0x0fe1, 0x0fe2, 0x0fe3, 0x0fe4, 0x0fe5, 0x0fe6,\n 0x0fe7, 0x0fe8, 0x0fe9, 0x0fea, 0x0feb, 0x0fec, 0x0fed, 0x0fee, 0x0fef,\n 0x0ff0, 0x0ff1, 0x0ff2, 0x0ff3, 0x0ff4, 0x0ff5, 0x0ff6, 0x0ff7, 0x0ff8,\n 0x0ff9, 0x0ffa, 0x0ffb, 0x0ffc, 0x0ffd, 0x0ffe, 0x0fff};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic unsigned short gus_log_volumes[512] = {\n 0x0000,\n 0x0700, 0x07ff, 0x0880, 0x08ff, 0x0940, 0x0980, 0x09c0, 0x09ff, 0x0a20,\n 0x0a40, 0x0a60, 0x0a80, 0x0aa0, 0x0ac0, 0x0ae0, 0x0aff, 0x0b10, 0x0b20,\n 0x0b30, 0x0b40, 0x0b50, 0x0b60, 0x0b70, 0x0b80, 0x0b90, 0x0ba0, 0x0bb0,\n 0x0bc0, 0x0bd0, 0x0be0, 0x0bf0, 0x0bff, 0x0c08, 0x0c10, 0x0c18, 0x0c20,\n 0x0c28, 0x0c30, 0x0c38, 0x0c40, 0x0c48, 0x0c50, 0x0c58, 0x0c60, 0x0c68,\n 0x0c70, 0x0c78, 0x0c80, 0x0c88, 0x0c90, 0x0c98, 0x0ca0, 0x0ca8, 0x0cb0,\n 0x0cb8, 0x0cc0, 0x0cc8, 0x0cd0, 0x0cd8, 0x0ce0, 0x0ce8, 0x0cf0, 0x0cf8,\n 0x0cff, 0x0d04, 0x0d08, 0x0d0c, 0x0d10, 0x0d14, 0x0d18, 0x0d1c, 0x0d20,\n 0x0d24, 0x0d28, 0x0d2c, 0x0d30, 0x0d34, 0x0d38, 0x0d3c, 0x0d40, 0x0d44,\n 0x0d48, 0x0d4c, 0x0d50, 0x0d54, 0x0d58, 0x0d5c, 0x0d60, 0x0d64, 0x0d68,\n 0x0d6c, 0x0d70, 0x0d74, 0x0d78, 0x0d7c, 0x0d80, 0x0d84, 0x0d88, 0x0d8c,\n 0x0d90, 0x0d94, 0x0d98, 0x0d9c, 0x0da0, 0x0da4, 0x0da8, 0x0dac, 0x0db0,\n 0x0db4, 0x0db8, 0x0dbc, 0x0dc0, 0x0dc4, 0x0dc8, 0x0dcc, 0x0dd0, 0x0dd4,\n 0x0dd8, 0x0ddc, 0x0de0, 0x0de4, 0x0de8, 0x0dec, 0x0df0, 0x0df4, 0x0df8,\n 0x0dfc, 0x0dff, 0x0e02, 0x0e04, 0x0e06, 0x0e08, 0x0e0a, 0x0e0c, 0x0e0e,\n 0x0e10, 0x0e12, 0x0e14, 0x0e16, 0x0e18, 0x0e1a, 0x0e1c, 0x0e1e, 0x0e20,\n 0x0e22, 0x0e24, 0x0e26, 0x0e28, 0x0e2a, 0x0e2c, 0x0e2e, 0x0e30, 0x0e32,\n 0x0e34, 0x0e36, 0x0e38, 0x0e3a, 0x0e3c, 0x0e3e, 0x0e40, 0x0e42, 0x0e44,\n 0x0e46, 0x0e48, 0x0e4a, 0x0e4c, 0x0e4e, 0x0e50, 0x0e52, 0x0e54, 0x0e56,\n 0x0e58, 0x0e5a, 0x0e5c, 0x0e5e, 0x0e60, 0x0e62, 0x0e64, 0x0e66, 0x0e68,\n 0x0e6a, 0x0e6c, 0x0e6e, 0x0e70, 0x0e72, 0x0e74, 0x0e76, 0x0e78, 0x0e7a,\n 0x0e7c, 0x0e7e, 0x0e80, 0x0e82, 0x0e84, 0x0e86, 0x0e88, 0x0e8a, 0x0e8c,\n 0x0e8e, 0x0e90, 0x0e92, 0x0e94, 0x0e96, 0x0e98, 0x0e9a, 0x0e9c, 0x0e9e,\n 0x0ea0, 0x0ea2, 0x0ea4, 0x0ea6, 0x0ea8, 0x0eaa, 0x0eac, 0x0eae, 0x0eb0,\n 0x0eb2, 0x0eb4, 0x0eb6, 0x0eb8, 0x0eba, 0x0ebc, 0x0ebe, 0x0ec0, 0x0ec2,\n 0x0ec4, 0x0ec6, 0x0ec8, 0x0eca, 0x0ecc, 0x0ece, 0x0ed0, 0x0ed2, 0x0ed4,\n 0x0ed6, 0x0ed8, 0x0eda, 0x0edc, 0x0ede, 0x0ee0, 0x0ee2, 0x0ee4, 0x0ee6,\n 0x0ee8, 0x0eea, 0x0eec, 0x0eee, 0x0ef0, 0x0ef2, 0x0ef4, 0x0ef6, 0x0ef8,\n 0x0efa, 0x0efc, 0x0efe, 0x0eff, 0x0f01, 0x0f02, 0x0f03, 0x0f04, 0x0f05,\n 0x0f06, 0x0f07, 0x0f08, 0x0f09, 0x0f0a, 0x0f0b, 0x0f0c, 0x0f0d, 0x0f0e,\n 0x0f0f, 0x0f10, 0x0f11, 0x0f12, 0x0f13, 0x0f14, 0x0f15, 0x0f16, 0x0f17,\n 0x0f18, 0x0f19, 0x0f1a, 0x0f1b, 0x0f1c, 0x0f1d, 0x0f1e, 0x0f1f, 0x0f20,\n 0x0f21, 0x0f22, 0x0f23, 0x0f24, 0x0f25, 0x0f26, 0x0f27, 0x0f28, 0x0f29,\n 0x0f2a, 0x0f2b, 0x0f2c, 0x0f2d, 0x0f2e, 0x0f2f, 0x0f30, 0x0f31, 0x0f32,\n 0x0f33, 0x0f34, 0x0f35, 0x0f36, 0x0f37, 0x0f38, 0x0f39, 0x0f3a, 0x0f3b,\n 0x0f3c, 0x0f3d, 0x0f3e, 0x0f3f, 0x0f40, 0x0f41, 0x0f42, 0x0f43, 0x0f44,\n 0x0f45, 0x0f46, 0x0f47, 0x0f48, 0x0f49, 0x0f4a, 0x0f4b, 0x0f4c, 0x0f4d,\n 0x0f4e, 0x0f4f, 0x0f50, 0x0f51, 0x0f52, 0x0f53, 0x0f54, 0x0f55, 0x0f56,\n 0x0f57, 0x0f58, 0x0f59, 0x0f5a, 0x0f5b, 0x0f5c, 0x0f5d, 0x0f5e, 0x0f5f,\n 0x0f60, 0x0f61, 0x0f62, 0x0f63, 0x0f64, 0x0f65, 0x0f66, 0x0f67, 0x0f68,\n 0x0f69, 0x0f6a, 0x0f6b, 0x0f6c, 0x0f6d, 0x0f6e, 0x0f6f, 0x0f70, 0x0f71,\n 0x0f72, 0x0f73, 0x0f74, 0x0f75, 0x0f76, 0x0f77, 0x0f78, 0x0f79, 0x0f7a,\n 0x0f7b, 0x0f7c, 0x0f7d, 0x0f7e, 0x0f7f, 0x0f80, 0x0f81, 0x0f82, 0x0f83,\n 0x0f84, 0x0f85, 0x0f86, 0x0f87, 0x0f88, 0x0f89, 0x0f8a, 0x0f8b, 0x0f8c,\n 0x0f8d, 0x0f8e, 0x0f8f, 0x0f90, 0x0f91, 0x0f92, 0x0f93, 0x0f94, 0x0f95,\n 0x0f96, 0x0f97, 0x0f98, 0x0f99, 0x0f9a, 0x0f9b, 0x0f9c, 0x0f9d, 0x0f9e,\n 0x0f9f, 0x0fa0, 0x0fa1, 0x0fa2, 0x0fa3, 0x0fa4, 0x0fa5, 0x0fa6, 0x0fa7,\n 0x0fa8, 0x0fa9, 0x0faa, 0x0fab, 0x0fac, 0x0fad, 0x0fae, 0x0faf, 0x0fb0,\n 0x0fb1, 0x0fb2, 0x0fb3, 0x0fb4, 0x0fb5, 0x0fb6, 0x0fb7, 0x0fb8, 0x0fb9,\n 0x0fba, 0x0fbb, 0x0fbc, 0x0fbd, 0x0fbe, 0x0fbf, 0x0fc0, 0x0fc1, 0x0fc2,\n 0x0fc3, 0x0fc4, 0x0fc5, 0x0fc6, 0x0fc7, 0x0fc8, 0x0fc9, 0x0fca, 0x0fcb,\n 0x0fcc, 0x0fcd, 0x0fce, 0x0fcf, 0x0fd0, 0x0fd1, 0x0fd2, 0x0fd3, 0x0fd4,\n 0x0fd5, 0x0fd6, 0x0fd7, 0x0fd8, 0x0fd9, 0x0fda, 0x0fdb, 0x0fdc, 0x0fdd,\n 0x0fde, 0x0fdf, 0x0fe0, 0x0fe1, 0x0fe2, 0x0fe3, 0x0fe4, 0x0fe5, 0x0fe6,\n 0x0fe7, 0x0fe8, 0x0fe9, 0x0fea, 0x0feb, 0x0fec, 0x0fed, 0x0fee, 0x0fef,\n 0x0ff0, 0x0ff1, 0x0ff2, 0x0ff3, 0x0ff4, 0x0ff5, 0x0ff6, 0x0ff7, 0x0ff8,\n 0x0ff9, 0x0ffa, 0x0ffb, 0x0ffc, 0x0ffd, 0x0ffe, 0x0fff};\n\nvoid\ngus_set_volume(sc, voice, volume)\n\tstruct gus_softc *sc;\n\tint voice, volume;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tunsigned int gusvol;\n\n\tgusvol = gus_log_volumes[volume < 512 ? volume : 511];\n\n\tsc->sc_voc[voice].current_volume = gusvol;\n\n\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, (unsigned char) voice);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_START_VOLUME);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, (unsigned char) (gusvol >> 4));\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_END_VOLUME);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, (unsigned char) (gusvol >> 4));\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_VOLUME);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, gusvol << 4);\n\tdelay(500);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, gusvol << 4);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "gus_set_recrate",
          "args": [
            "sc",
            "sc->sc_irate"
          ],
          "line": 1701
        },
        "resolved": true,
        "details": {
          "function_name": "gus_set_recrate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "1789-1806",
          "snippet": "void\ngus_set_recrate(sc, rate)\n\tstruct gus_softc *sc;\n\tu_long rate;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tu_char realrate;\n\tDPRINTF((\"gus_set_recrate %lu\\n\", rate));\n\n#if 0\n\trealrate = 9878400/(16*(rate+2)); /* formula from GUS docs */\n#endif\n\trealrate = (9878400 >> 4)/rate - 2; /* formula from code, sigh. */\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_SAMPLE_FREQ);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, realrate);\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ngus_set_recrate(sc, rate)\n\tstruct gus_softc *sc;\n\tu_long rate;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tu_char realrate;\n\tDPRINTF((\"gus_set_recrate %lu\\n\", rate));\n\n#if 0\n\trealrate = 9878400/(16*(rate+2)); /* formula from GUS docs */\n#endif\n\trealrate = (9878400 >> 4)/rate - 2; /* formula from code, sigh. */\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_SAMPLE_FREQ);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, realrate);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splgus",
          "args": [],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"gus_commit_settings called (gain = %d)\\n\",sc->sc_ogain)"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngus_commit_settings(addr)\n\tvoid * addr;\n{\n\tstruct gus_softc *sc = addr;\n\tint s;\n\n\tDPRINTF((\"gus_commit_settings called (gain = %d)\\n\",sc->sc_ogain));\n\n\n\ts = splgus();\n\n\tgus_set_recrate(sc, sc->sc_irate);\n\tgus_set_volume(sc, GUS_VOICE_LEFT, sc->sc_ogain);\n\tgus_set_volume(sc, GUS_VOICE_RIGHT, sc->sc_ogain);\n\tgus_set_samprate(sc, GUS_VOICE_LEFT, sc->sc_orate);\n\tgus_set_samprate(sc, GUS_VOICE_RIGHT, sc->sc_orate);\n\tsplx(s);\n\tgus_set_chan_addrs(sc);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "gusmax_commit_settings",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "1672-1684",
    "snippet": "int\ngusmax_commit_settings(addr)\n\tvoid * addr;\n{\n\tstruct ad1848_softc *ac = addr;\n\tstruct gus_softc *sc = ac->parent;\n\tint error;\n\n\terror = ad1848_commit_settings(ac);\n\tif (error)\n\t\treturn error;\n\treturn gus_commit_settings(sc);\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gus_commit_settings",
          "args": [
            "sc"
          ],
          "line": 1683
        },
        "resolved": true,
        "details": {
          "function_name": "gus_commit_settings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "1689-1710",
          "snippet": "int\ngus_commit_settings(addr)\n\tvoid * addr;\n{\n\tstruct gus_softc *sc = addr;\n\tint s;\n\n\tDPRINTF((\"gus_commit_settings called (gain = %d)\\n\",sc->sc_ogain));\n\n\n\ts = splgus();\n\n\tgus_set_recrate(sc, sc->sc_irate);\n\tgus_set_volume(sc, GUS_VOICE_LEFT, sc->sc_ogain);\n\tgus_set_volume(sc, GUS_VOICE_RIGHT, sc->sc_ogain);\n\tgus_set_samprate(sc, GUS_VOICE_LEFT, sc->sc_orate);\n\tgus_set_samprate(sc, GUS_VOICE_RIGHT, sc->sc_orate);\n\tsplx(s);\n\tgus_set_chan_addrs(sc);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngus_commit_settings(addr)\n\tvoid * addr;\n{\n\tstruct gus_softc *sc = addr;\n\tint s;\n\n\tDPRINTF((\"gus_commit_settings called (gain = %d)\\n\",sc->sc_ogain));\n\n\n\ts = splgus();\n\n\tgus_set_recrate(sc, sc->sc_irate);\n\tgus_set_volume(sc, GUS_VOICE_LEFT, sc->sc_ogain);\n\tgus_set_volume(sc, GUS_VOICE_RIGHT, sc->sc_ogain);\n\tgus_set_samprate(sc, GUS_VOICE_LEFT, sc->sc_orate);\n\tgus_set_samprate(sc, GUS_VOICE_RIGHT, sc->sc_orate);\n\tsplx(s);\n\tgus_set_chan_addrs(sc);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad1848_commit_settings",
          "args": [
            "ac"
          ],
          "line": 1680
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_commit_settings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "1233-1307",
          "snippet": "int\nad1848_commit_settings(addr)\n    void *addr;\n{\n    struct ad1848_softc *sc = addr;\n    int timeout;\n    u_char fs;\n    int s;\n\n    if (!sc->need_commit)\n\treturn 0;\n\n    s = splaudio();\n    \n    ad1848_mute_monitor(sc, 1);\n    \n    ad_set_MCE(sc, 1);\t\t/* Enables changes to the format select reg */\n\n    fs = sc->speed_bits | (sc->format_bits << 5);\n\n    if (sc->channels == 2)\n\tfs |= FMT_STEREO;\n\n    ad_write(sc, SP_CLOCK_DATA_FORMAT, fs);\n\n    /*\n     * If mode == 2 (CS4231), set I28 also. It's the capture format register.\n     */\n    if (sc->mode == 2) {\n\t/* Gravis Ultrasound MAX SDK sources says something about errata\n\t * sheets, with the implication that these inb()s are necessary.\n\t */\n\t(void)ADREAD(sc, AD1848_IDATA);\n\t(void)ADREAD(sc, AD1848_IDATA);\n\t/*\n\t * Write to I8 starts resyncronization. Wait until it completes.\n\t */\n\ttimeout = 100000;\n\twhile (timeout > 0 && ADREAD(sc, AD1848_IADDR) == SP_IN_INIT)\n\t    timeout--;\n\n\tad_write(sc, CS_REC_FORMAT, fs);\n\t/* Gravis Ultrasound MAX SDK sources says something about errata\n\t * sheets, with the implication that these inb()s are necessary.\n\t */\n\t(void)ADREAD(sc, AD1848_IDATA);\n\t(void)ADREAD(sc, AD1848_IDATA);\n\t/* Now wait for resync for capture side of the house */\n    }\n    /*\n     * Write to I8 starts resyncronization. Wait until it completes.\n     */\n    timeout = 100000;\n    while (timeout > 0 && ADREAD(sc, AD1848_IADDR) == SP_IN_INIT)\n\ttimeout--;\n\n    if (ADREAD(sc, AD1848_IADDR) == SP_IN_INIT)\n\tprintf(\"ad1848_commit: Auto calibration timed out\\n\");\n\n    /*\n     * Starts the calibration process and\n     * enters playback mode after it.\n     */\n    ad_set_MCE(sc, 0);\n    wait_for_calibration(sc);\n\n    ad1848_mute_monitor(sc, 0);\n\n    sc->sc_lastcc = -1;\n\n    splx(s);\n    \n    sc->need_commit = 0;\n    return 0;\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tad1848_mute_monitor",
            "static void ad_write",
            "static void ad_set_MCE",
            "static void wait_for_calibration",
            "void *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\tad1848_mute_monitor;\nstatic void ad_write;\nstatic void ad_set_MCE;\nstatic void wait_for_calibration;\nvoid *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\nad1848_commit_settings(addr)\n    void *addr;\n{\n    struct ad1848_softc *sc = addr;\n    int timeout;\n    u_char fs;\n    int s;\n\n    if (!sc->need_commit)\n\treturn 0;\n\n    s = splaudio();\n    \n    ad1848_mute_monitor(sc, 1);\n    \n    ad_set_MCE(sc, 1);\t\t/* Enables changes to the format select reg */\n\n    fs = sc->speed_bits | (sc->format_bits << 5);\n\n    if (sc->channels == 2)\n\tfs |= FMT_STEREO;\n\n    ad_write(sc, SP_CLOCK_DATA_FORMAT, fs);\n\n    /*\n     * If mode == 2 (CS4231), set I28 also. It's the capture format register.\n     */\n    if (sc->mode == 2) {\n\t/* Gravis Ultrasound MAX SDK sources says something about errata\n\t * sheets, with the implication that these inb()s are necessary.\n\t */\n\t(void)ADREAD(sc, AD1848_IDATA);\n\t(void)ADREAD(sc, AD1848_IDATA);\n\t/*\n\t * Write to I8 starts resyncronization. Wait until it completes.\n\t */\n\ttimeout = 100000;\n\twhile (timeout > 0 && ADREAD(sc, AD1848_IADDR) == SP_IN_INIT)\n\t    timeout--;\n\n\tad_write(sc, CS_REC_FORMAT, fs);\n\t/* Gravis Ultrasound MAX SDK sources says something about errata\n\t * sheets, with the implication that these inb()s are necessary.\n\t */\n\t(void)ADREAD(sc, AD1848_IDATA);\n\t(void)ADREAD(sc, AD1848_IDATA);\n\t/* Now wait for resync for capture side of the house */\n    }\n    /*\n     * Write to I8 starts resyncronization. Wait until it completes.\n     */\n    timeout = 100000;\n    while (timeout > 0 && ADREAD(sc, AD1848_IADDR) == SP_IN_INIT)\n\ttimeout--;\n\n    if (ADREAD(sc, AD1848_IADDR) == SP_IN_INIT)\n\tprintf(\"ad1848_commit: Auto calibration timed out\\n\");\n\n    /*\n     * Starts the calibration process and\n     * enters playback mode after it.\n     */\n    ad_set_MCE(sc, 0);\n    wait_for_calibration(sc);\n\n    ad1848_mute_monitor(sc, 0);\n\n    sc->sc_lastcc = -1;\n\n    splx(s);\n    \n    sc->need_commit = 0;\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngusmax_commit_settings(addr)\n\tvoid * addr;\n{\n\tstruct ad1848_softc *ac = addr;\n\tstruct gus_softc *sc = ac->parent;\n\tint error;\n\n\terror = ad1848_commit_settings(ac);\n\tif (error)\n\t\treturn error;\n\treturn gus_commit_settings(sc);\n}"
  },
  {
    "function_name": "gus_set_voices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "1652-1666",
    "snippet": "inline void gus_set_voices(sc, voices)\nstruct gus_softc *sc;\nint voices;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\t/*\n\t * Select the active number of voices\n\t */\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_ACTIVE_VOICES);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, (voices-1) | 0xc0);\n\n\tsc->sc_voices = voices;\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "(voices-1) | 0xc0"
          ],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_ACTIVE_VOICES"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\ninline void gus_set_voices(sc, voices)\nstruct gus_softc *sc;\nint voices;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\t/*\n\t * Select the active number of voices\n\t */\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_ACTIVE_VOICES);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, (voices-1) | 0xc0);\n\n\tsc->sc_voices = voices;\n}"
  },
  {
    "function_name": "gus_get_out_gain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "1642-1650",
    "snippet": "int\ngus_get_out_gain(addr)\n\tcaddr_t addr;\n{\n\tstruct gus_softc *sc = (struct gus_softc *) addr;\n\n\tDPRINTF((\"gus_get_out_gain called\\n\"));\n\treturn sc->sc_ogain / 2;\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"gus_get_out_gain called\\n\")"
          ],
          "line": 1648
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngus_get_out_gain(addr)\n\tcaddr_t addr;\n{\n\tstruct gus_softc *sc = (struct gus_softc *) addr;\n\n\tDPRINTF((\"gus_get_out_gain called\\n\"));\n\treturn sc->sc_ogain / 2;\n}"
  },
  {
    "function_name": "gus_round_blocksize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "1606-1640",
    "snippet": "int\ngus_round_blocksize(addr, blocksize)\n\tvoid * addr;\n\tint blocksize;\n{\n\tstruct gus_softc *sc = addr;\n\n\tDPRINTF((\"gus_round_blocksize called\\n\"));\n\n\tif ((sc->sc_encoding == AUDIO_ENCODING_ULAW ||\n\t     sc->sc_encoding == AUDIO_ENCODING_ALAW) && blocksize > 32768)\n\t\tblocksize = 32768;\n\telse if (blocksize > 65536)\n\t\tblocksize = 65536;\n\n\tif ((blocksize % GUS_BUFFER_MULTIPLE) != 0)\n\t\tblocksize = (blocksize / GUS_BUFFER_MULTIPLE + 1) *\n\t\t\tGUS_BUFFER_MULTIPLE;\n\n\t/* set up temporary buffer to hold the deinterleave, if necessary\n\t   for stereo output */\n\tif (sc->sc_deintr_buf) {\n\t\tFREE(sc->sc_deintr_buf, M_DEVBUF);\n\t\tsc->sc_deintr_buf = NULL;\n\t}\n\tMALLOC(sc->sc_deintr_buf, void *, blocksize>>1, M_DEVBUF, M_WAITOK);\n\n\tsc->sc_blocksize = blocksize;\n\t/* multi-buffering not quite working yet. */\n\tsc->sc_nbufs = /*GUS_MEM_FOR_BUFFERS / blocksize*/ 2;\n\n\tgus_set_chan_addrs(sc);\n\n\treturn blocksize;\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gus_set_chan_addrs",
          "args": [
            "sc"
          ],
          "line": 1637
        },
        "resolved": true,
        "details": {
          "function_name": "gus_set_chan_addrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "1712-1744",
          "snippet": "void\ngus_set_chan_addrs(sc)\nstruct gus_softc *sc;\n{\n\t/*\n\t * We use sc_nbufs * blocksize bytes of storage in the on-board GUS\n\t * ram. \n\t * For mono, each of the sc_nbufs buffers is DMA'd to in one chunk,\n\t * and both left & right channels play the same buffer.\n\t *\n\t * For stereo, each channel gets a contiguous half of the memory,\n\t * and each has sc_nbufs buffers of size blocksize/2.\n\t * Stereo data are deinterleaved in main memory before the DMA out\n\t * routines are called to queue the output.\n\t *\n\t * The blocksize per channel is kept in sc_chanblocksize.\n\t */\n\tif (sc->sc_channels == 2)\n\t    sc->sc_chanblocksize = sc->sc_blocksize/2;\n\telse\n\t    sc->sc_chanblocksize = sc->sc_blocksize;\n\n\tsc->sc_voc[GUS_VOICE_LEFT].start_addr = GUS_MEM_OFFSET - 1;\n\tsc->sc_voc[GUS_VOICE_RIGHT].start_addr =\n\t    (gus_dostereo && sc->sc_channels == 2 ? GUS_LEFT_RIGHT_OFFSET : 0)\n\t      + GUS_MEM_OFFSET - 1;\n\tsc->sc_voc[GUS_VOICE_RIGHT].current_addr =\n\t    sc->sc_voc[GUS_VOICE_RIGHT].start_addr + 1;\n\tsc->sc_voc[GUS_VOICE_RIGHT].end_addr =\n\t    sc->sc_voc[GUS_VOICE_RIGHT].start_addr +\n\t    sc->sc_nbufs * sc->sc_chanblocksize;\n\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tgus_dostereo = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tgus_dostereo = 1;\n\nvoid\ngus_set_chan_addrs(sc)\nstruct gus_softc *sc;\n{\n\t/*\n\t * We use sc_nbufs * blocksize bytes of storage in the on-board GUS\n\t * ram. \n\t * For mono, each of the sc_nbufs buffers is DMA'd to in one chunk,\n\t * and both left & right channels play the same buffer.\n\t *\n\t * For stereo, each channel gets a contiguous half of the memory,\n\t * and each has sc_nbufs buffers of size blocksize/2.\n\t * Stereo data are deinterleaved in main memory before the DMA out\n\t * routines are called to queue the output.\n\t *\n\t * The blocksize per channel is kept in sc_chanblocksize.\n\t */\n\tif (sc->sc_channels == 2)\n\t    sc->sc_chanblocksize = sc->sc_blocksize/2;\n\telse\n\t    sc->sc_chanblocksize = sc->sc_blocksize;\n\n\tsc->sc_voc[GUS_VOICE_LEFT].start_addr = GUS_MEM_OFFSET - 1;\n\tsc->sc_voc[GUS_VOICE_RIGHT].start_addr =\n\t    (gus_dostereo && sc->sc_channels == 2 ? GUS_LEFT_RIGHT_OFFSET : 0)\n\t      + GUS_MEM_OFFSET - 1;\n\tsc->sc_voc[GUS_VOICE_RIGHT].current_addr =\n\t    sc->sc_voc[GUS_VOICE_RIGHT].start_addr + 1;\n\tsc->sc_voc[GUS_VOICE_RIGHT].end_addr =\n\t    sc->sc_voc[GUS_VOICE_RIGHT].start_addr +\n\t    sc->sc_nbufs * sc->sc_chanblocksize;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "MALLOC",
          "args": [
            "sc->sc_deintr_buf",
            "void *, blocksize>>1",
            "M_DEVBUF",
            "M_WAITOK"
          ],
          "line": 1631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FREE",
          "args": [
            "sc->sc_deintr_buf",
            "M_DEVBUF"
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"gus_round_blocksize called\\n\")"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngus_round_blocksize(addr, blocksize)\n\tvoid * addr;\n\tint blocksize;\n{\n\tstruct gus_softc *sc = addr;\n\n\tDPRINTF((\"gus_round_blocksize called\\n\"));\n\n\tif ((sc->sc_encoding == AUDIO_ENCODING_ULAW ||\n\t     sc->sc_encoding == AUDIO_ENCODING_ALAW) && blocksize > 32768)\n\t\tblocksize = 32768;\n\telse if (blocksize > 65536)\n\t\tblocksize = 65536;\n\n\tif ((blocksize % GUS_BUFFER_MULTIPLE) != 0)\n\t\tblocksize = (blocksize / GUS_BUFFER_MULTIPLE + 1) *\n\t\t\tGUS_BUFFER_MULTIPLE;\n\n\t/* set up temporary buffer to hold the deinterleave, if necessary\n\t   for stereo output */\n\tif (sc->sc_deintr_buf) {\n\t\tFREE(sc->sc_deintr_buf, M_DEVBUF);\n\t\tsc->sc_deintr_buf = NULL;\n\t}\n\tMALLOC(sc->sc_deintr_buf, void *, blocksize>>1, M_DEVBUF, M_WAITOK);\n\n\tsc->sc_blocksize = blocksize;\n\t/* multi-buffering not quite working yet. */\n\tsc->sc_nbufs = /*GUS_MEM_FOR_BUFFERS / blocksize*/ 2;\n\n\tgus_set_chan_addrs(sc);\n\n\treturn blocksize;\n}"
  },
  {
    "function_name": "gusmax_round_blocksize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "1594-1604",
    "snippet": "int\ngusmax_round_blocksize(addr, blocksize)\n\tvoid * addr;\n\tint blocksize;\n{\n\tstruct ad1848_softc *ac = addr;\n\tstruct gus_softc *sc = ac->parent;\n\n/*\tblocksize = ad1848_round_blocksize(ac, blocksize);*/\n\treturn gus_round_blocksize(sc, blocksize);\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gus_round_blocksize",
          "args": [
            "sc",
            "blocksize"
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "gus_round_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "1606-1640",
          "snippet": "int\ngus_round_blocksize(addr, blocksize)\n\tvoid * addr;\n\tint blocksize;\n{\n\tstruct gus_softc *sc = addr;\n\n\tDPRINTF((\"gus_round_blocksize called\\n\"));\n\n\tif ((sc->sc_encoding == AUDIO_ENCODING_ULAW ||\n\t     sc->sc_encoding == AUDIO_ENCODING_ALAW) && blocksize > 32768)\n\t\tblocksize = 32768;\n\telse if (blocksize > 65536)\n\t\tblocksize = 65536;\n\n\tif ((blocksize % GUS_BUFFER_MULTIPLE) != 0)\n\t\tblocksize = (blocksize / GUS_BUFFER_MULTIPLE + 1) *\n\t\t\tGUS_BUFFER_MULTIPLE;\n\n\t/* set up temporary buffer to hold the deinterleave, if necessary\n\t   for stereo output */\n\tif (sc->sc_deintr_buf) {\n\t\tFREE(sc->sc_deintr_buf, M_DEVBUF);\n\t\tsc->sc_deintr_buf = NULL;\n\t}\n\tMALLOC(sc->sc_deintr_buf, void *, blocksize>>1, M_DEVBUF, M_WAITOK);\n\n\tsc->sc_blocksize = blocksize;\n\t/* multi-buffering not quite working yet. */\n\tsc->sc_nbufs = /*GUS_MEM_FOR_BUFFERS / blocksize*/ 2;\n\n\tgus_set_chan_addrs(sc);\n\n\treturn blocksize;\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngus_round_blocksize(addr, blocksize)\n\tvoid * addr;\n\tint blocksize;\n{\n\tstruct gus_softc *sc = addr;\n\n\tDPRINTF((\"gus_round_blocksize called\\n\"));\n\n\tif ((sc->sc_encoding == AUDIO_ENCODING_ULAW ||\n\t     sc->sc_encoding == AUDIO_ENCODING_ALAW) && blocksize > 32768)\n\t\tblocksize = 32768;\n\telse if (blocksize > 65536)\n\t\tblocksize = 65536;\n\n\tif ((blocksize % GUS_BUFFER_MULTIPLE) != 0)\n\t\tblocksize = (blocksize / GUS_BUFFER_MULTIPLE + 1) *\n\t\t\tGUS_BUFFER_MULTIPLE;\n\n\t/* set up temporary buffer to hold the deinterleave, if necessary\n\t   for stereo output */\n\tif (sc->sc_deintr_buf) {\n\t\tFREE(sc->sc_deintr_buf, M_DEVBUF);\n\t\tsc->sc_deintr_buf = NULL;\n\t}\n\tMALLOC(sc->sc_deintr_buf, void *, blocksize>>1, M_DEVBUF, M_WAITOK);\n\n\tsc->sc_blocksize = blocksize;\n\t/* multi-buffering not quite working yet. */\n\tsc->sc_nbufs = /*GUS_MEM_FOR_BUFFERS / blocksize*/ 2;\n\n\tgus_set_chan_addrs(sc);\n\n\treturn blocksize;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngusmax_round_blocksize(addr, blocksize)\n\tvoid * addr;\n\tint blocksize;\n{\n\tstruct ad1848_softc *ac = addr;\n\tstruct gus_softc *sc = ac->parent;\n\n/*\tblocksize = ad1848_round_blocksize(ac, blocksize);*/\n\treturn gus_round_blocksize(sc, blocksize);\n}"
  },
  {
    "function_name": "gus_set_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "1527-1587",
    "snippet": "int\ngus_set_params(addr, setmode, usemode, p, r)\n\tvoid *addr;\n\tint setmode, usemode;\n\tstruct audio_params *p, *r;\n{\n\tstruct gus_softc *sc = addr;\n\tint s;\n\n\tswitch (p->encoding) {\n\tcase AUDIO_ENCODING_ULAW:\n\tcase AUDIO_ENCODING_ALAW:\n\tcase AUDIO_ENCODING_SLINEAR_LE:\n\tcase AUDIO_ENCODING_ULINEAR_LE:\n\tcase AUDIO_ENCODING_SLINEAR_BE:\n\tcase AUDIO_ENCODING_ULINEAR_BE:\n\t\tbreak;\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\ts = splaudio();\n\n\tif (p->precision == 8) {\n\t\tsc->sc_voc[GUS_VOICE_LEFT].voccntl &= ~GUSMASK_DATA_SIZE16;\n\t\tsc->sc_voc[GUS_VOICE_RIGHT].voccntl &= ~GUSMASK_DATA_SIZE16;\n\t} else {\n\t\tsc->sc_voc[GUS_VOICE_LEFT].voccntl |= GUSMASK_DATA_SIZE16;\n\t\tsc->sc_voc[GUS_VOICE_RIGHT].voccntl |= GUSMASK_DATA_SIZE16;\n\t}\n\n\tsc->sc_encoding = p->encoding;\n\tsc->sc_precision = p->precision;\n\tsc->sc_channels = p->channels;\n\n\tsplx(s);\n\n\tif (p->sample_rate > gus_max_frequency[sc->sc_voices - GUS_MIN_VOICES])\n\t\tp->sample_rate = gus_max_frequency[sc->sc_voices - GUS_MIN_VOICES];\n\tif (setmode & AUMODE_RECORD)\n\t\tsc->sc_irate = p->sample_rate;\n\tif (setmode & AUMODE_PLAY)\n\t\tsc->sc_orate = p->sample_rate;\n\n\tswitch (p->encoding) {\n\tcase AUDIO_ENCODING_ULAW:\n\t\tp->sw_code = mulaw_to_ulinear8;\n\t\tr->sw_code = ulinear8_to_mulaw;\n\t\tbreak;\n\tcase AUDIO_ENCODING_ALAW:\n\t\tp->sw_code = alaw_to_ulinear8;\n\t\tr->sw_code = ulinear8_to_alaw;\n\t\tbreak;\n\tcase AUDIO_ENCODING_ULINEAR_BE:\n\tcase AUDIO_ENCODING_SLINEAR_BE:\n\t\tr->sw_code = p->sw_code = swap_bytes;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int gus_max_frequency[] = {\n\t\t44100,\t\t/* 14 voices */\n\t\t41160,\t\t/* 15 voices */\n\t\t38587,\t\t/* 16 voices */\n\t\t36317,\t\t/* 17 voices */\n\t\t34300,\t\t/* 18 voices */\n\t\t32494,\t\t/* 19 voices */\n\t\t30870,\t\t/* 20 voices */\n\t\t29400,\t\t/* 21 voices */\n\t\t28063,\t\t/* 22 voices */\n\t\t26843,\t\t/* 23 voices */\n\t\t25725,\t\t/* 24 voices */\n\t\t24696,\t\t/* 25 voices */\n\t\t23746,\t\t/* 26 voices */\n\t\t22866,\t\t/* 27 voices */\n\t\t22050,\t\t/* 28 voices */\n\t\t21289,\t\t/* 29 voices */\n\t\t20580,\t\t/* 30 voices */\n\t\t19916,\t\t/* 31 voices */\n\t\t19293\t\t/* 32 voices */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splaudio",
          "args": [],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int gus_max_frequency[] = {\n\t\t44100,\t\t/* 14 voices */\n\t\t41160,\t\t/* 15 voices */\n\t\t38587,\t\t/* 16 voices */\n\t\t36317,\t\t/* 17 voices */\n\t\t34300,\t\t/* 18 voices */\n\t\t32494,\t\t/* 19 voices */\n\t\t30870,\t\t/* 20 voices */\n\t\t29400,\t\t/* 21 voices */\n\t\t28063,\t\t/* 22 voices */\n\t\t26843,\t\t/* 23 voices */\n\t\t25725,\t\t/* 24 voices */\n\t\t24696,\t\t/* 25 voices */\n\t\t23746,\t\t/* 26 voices */\n\t\t22866,\t\t/* 27 voices */\n\t\t22050,\t\t/* 28 voices */\n\t\t21289,\t\t/* 29 voices */\n\t\t20580,\t\t/* 30 voices */\n\t\t19916,\t\t/* 31 voices */\n\t\t19293\t\t/* 32 voices */\n};\n\nint\ngus_set_params(addr, setmode, usemode, p, r)\n\tvoid *addr;\n\tint setmode, usemode;\n\tstruct audio_params *p, *r;\n{\n\tstruct gus_softc *sc = addr;\n\tint s;\n\n\tswitch (p->encoding) {\n\tcase AUDIO_ENCODING_ULAW:\n\tcase AUDIO_ENCODING_ALAW:\n\tcase AUDIO_ENCODING_SLINEAR_LE:\n\tcase AUDIO_ENCODING_ULINEAR_LE:\n\tcase AUDIO_ENCODING_SLINEAR_BE:\n\tcase AUDIO_ENCODING_ULINEAR_BE:\n\t\tbreak;\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\ts = splaudio();\n\n\tif (p->precision == 8) {\n\t\tsc->sc_voc[GUS_VOICE_LEFT].voccntl &= ~GUSMASK_DATA_SIZE16;\n\t\tsc->sc_voc[GUS_VOICE_RIGHT].voccntl &= ~GUSMASK_DATA_SIZE16;\n\t} else {\n\t\tsc->sc_voc[GUS_VOICE_LEFT].voccntl |= GUSMASK_DATA_SIZE16;\n\t\tsc->sc_voc[GUS_VOICE_RIGHT].voccntl |= GUSMASK_DATA_SIZE16;\n\t}\n\n\tsc->sc_encoding = p->encoding;\n\tsc->sc_precision = p->precision;\n\tsc->sc_channels = p->channels;\n\n\tsplx(s);\n\n\tif (p->sample_rate > gus_max_frequency[sc->sc_voices - GUS_MIN_VOICES])\n\t\tp->sample_rate = gus_max_frequency[sc->sc_voices - GUS_MIN_VOICES];\n\tif (setmode & AUMODE_RECORD)\n\t\tsc->sc_irate = p->sample_rate;\n\tif (setmode & AUMODE_PLAY)\n\t\tsc->sc_orate = p->sample_rate;\n\n\tswitch (p->encoding) {\n\tcase AUDIO_ENCODING_ULAW:\n\t\tp->sw_code = mulaw_to_ulinear8;\n\t\tr->sw_code = ulinear8_to_mulaw;\n\t\tbreak;\n\tcase AUDIO_ENCODING_ALAW:\n\t\tp->sw_code = alaw_to_ulinear8;\n\t\tr->sw_code = ulinear8_to_alaw;\n\t\tbreak;\n\tcase AUDIO_ENCODING_ULINEAR_BE:\n\tcase AUDIO_ENCODING_SLINEAR_BE:\n\t\tr->sw_code = p->sw_code = swap_bytes;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "gusmax_set_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "1510-1525",
    "snippet": "int\ngusmax_set_params(addr, setmode, usemode, p, r)\n\tvoid *addr;\n\tint setmode, usemode;\n\tstruct audio_params *p, *r;\n{\n\tstruct ad1848_softc *ac = addr;\n\tstruct gus_softc *sc = ac->parent;\n\tint error;\n\n\terror = ad1848_set_params(ac, setmode, usemode, p, r);\n\tif (error)\n\t\treturn error;\n\terror = gus_set_params(sc, setmode, usemode, p, r);\n\treturn error;\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gus_set_params",
          "args": [
            "sc",
            "setmode",
            "usemode",
            "p",
            "r"
          ],
          "line": 1523
        },
        "resolved": true,
        "details": {
          "function_name": "gus_set_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "1527-1587",
          "snippet": "int\ngus_set_params(addr, setmode, usemode, p, r)\n\tvoid *addr;\n\tint setmode, usemode;\n\tstruct audio_params *p, *r;\n{\n\tstruct gus_softc *sc = addr;\n\tint s;\n\n\tswitch (p->encoding) {\n\tcase AUDIO_ENCODING_ULAW:\n\tcase AUDIO_ENCODING_ALAW:\n\tcase AUDIO_ENCODING_SLINEAR_LE:\n\tcase AUDIO_ENCODING_ULINEAR_LE:\n\tcase AUDIO_ENCODING_SLINEAR_BE:\n\tcase AUDIO_ENCODING_ULINEAR_BE:\n\t\tbreak;\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\ts = splaudio();\n\n\tif (p->precision == 8) {\n\t\tsc->sc_voc[GUS_VOICE_LEFT].voccntl &= ~GUSMASK_DATA_SIZE16;\n\t\tsc->sc_voc[GUS_VOICE_RIGHT].voccntl &= ~GUSMASK_DATA_SIZE16;\n\t} else {\n\t\tsc->sc_voc[GUS_VOICE_LEFT].voccntl |= GUSMASK_DATA_SIZE16;\n\t\tsc->sc_voc[GUS_VOICE_RIGHT].voccntl |= GUSMASK_DATA_SIZE16;\n\t}\n\n\tsc->sc_encoding = p->encoding;\n\tsc->sc_precision = p->precision;\n\tsc->sc_channels = p->channels;\n\n\tsplx(s);\n\n\tif (p->sample_rate > gus_max_frequency[sc->sc_voices - GUS_MIN_VOICES])\n\t\tp->sample_rate = gus_max_frequency[sc->sc_voices - GUS_MIN_VOICES];\n\tif (setmode & AUMODE_RECORD)\n\t\tsc->sc_irate = p->sample_rate;\n\tif (setmode & AUMODE_PLAY)\n\t\tsc->sc_orate = p->sample_rate;\n\n\tswitch (p->encoding) {\n\tcase AUDIO_ENCODING_ULAW:\n\t\tp->sw_code = mulaw_to_ulinear8;\n\t\tr->sw_code = ulinear8_to_mulaw;\n\t\tbreak;\n\tcase AUDIO_ENCODING_ALAW:\n\t\tp->sw_code = alaw_to_ulinear8;\n\t\tr->sw_code = ulinear8_to_alaw;\n\t\tbreak;\n\tcase AUDIO_ENCODING_ULINEAR_BE:\n\tcase AUDIO_ENCODING_SLINEAR_BE:\n\t\tr->sw_code = p->sw_code = swap_bytes;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int gus_max_frequency[] = {\n\t\t44100,\t\t/* 14 voices */\n\t\t41160,\t\t/* 15 voices */\n\t\t38587,\t\t/* 16 voices */\n\t\t36317,\t\t/* 17 voices */\n\t\t34300,\t\t/* 18 voices */\n\t\t32494,\t\t/* 19 voices */\n\t\t30870,\t\t/* 20 voices */\n\t\t29400,\t\t/* 21 voices */\n\t\t28063,\t\t/* 22 voices */\n\t\t26843,\t\t/* 23 voices */\n\t\t25725,\t\t/* 24 voices */\n\t\t24696,\t\t/* 25 voices */\n\t\t23746,\t\t/* 26 voices */\n\t\t22866,\t\t/* 27 voices */\n\t\t22050,\t\t/* 28 voices */\n\t\t21289,\t\t/* 29 voices */\n\t\t20580,\t\t/* 30 voices */\n\t\t19916,\t\t/* 31 voices */\n\t\t19293\t\t/* 32 voices */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int gus_max_frequency[] = {\n\t\t44100,\t\t/* 14 voices */\n\t\t41160,\t\t/* 15 voices */\n\t\t38587,\t\t/* 16 voices */\n\t\t36317,\t\t/* 17 voices */\n\t\t34300,\t\t/* 18 voices */\n\t\t32494,\t\t/* 19 voices */\n\t\t30870,\t\t/* 20 voices */\n\t\t29400,\t\t/* 21 voices */\n\t\t28063,\t\t/* 22 voices */\n\t\t26843,\t\t/* 23 voices */\n\t\t25725,\t\t/* 24 voices */\n\t\t24696,\t\t/* 25 voices */\n\t\t23746,\t\t/* 26 voices */\n\t\t22866,\t\t/* 27 voices */\n\t\t22050,\t\t/* 28 voices */\n\t\t21289,\t\t/* 29 voices */\n\t\t20580,\t\t/* 30 voices */\n\t\t19916,\t\t/* 31 voices */\n\t\t19293\t\t/* 32 voices */\n};\n\nint\ngus_set_params(addr, setmode, usemode, p, r)\n\tvoid *addr;\n\tint setmode, usemode;\n\tstruct audio_params *p, *r;\n{\n\tstruct gus_softc *sc = addr;\n\tint s;\n\n\tswitch (p->encoding) {\n\tcase AUDIO_ENCODING_ULAW:\n\tcase AUDIO_ENCODING_ALAW:\n\tcase AUDIO_ENCODING_SLINEAR_LE:\n\tcase AUDIO_ENCODING_ULINEAR_LE:\n\tcase AUDIO_ENCODING_SLINEAR_BE:\n\tcase AUDIO_ENCODING_ULINEAR_BE:\n\t\tbreak;\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\ts = splaudio();\n\n\tif (p->precision == 8) {\n\t\tsc->sc_voc[GUS_VOICE_LEFT].voccntl &= ~GUSMASK_DATA_SIZE16;\n\t\tsc->sc_voc[GUS_VOICE_RIGHT].voccntl &= ~GUSMASK_DATA_SIZE16;\n\t} else {\n\t\tsc->sc_voc[GUS_VOICE_LEFT].voccntl |= GUSMASK_DATA_SIZE16;\n\t\tsc->sc_voc[GUS_VOICE_RIGHT].voccntl |= GUSMASK_DATA_SIZE16;\n\t}\n\n\tsc->sc_encoding = p->encoding;\n\tsc->sc_precision = p->precision;\n\tsc->sc_channels = p->channels;\n\n\tsplx(s);\n\n\tif (p->sample_rate > gus_max_frequency[sc->sc_voices - GUS_MIN_VOICES])\n\t\tp->sample_rate = gus_max_frequency[sc->sc_voices - GUS_MIN_VOICES];\n\tif (setmode & AUMODE_RECORD)\n\t\tsc->sc_irate = p->sample_rate;\n\tif (setmode & AUMODE_PLAY)\n\t\tsc->sc_orate = p->sample_rate;\n\n\tswitch (p->encoding) {\n\tcase AUDIO_ENCODING_ULAW:\n\t\tp->sw_code = mulaw_to_ulinear8;\n\t\tr->sw_code = ulinear8_to_mulaw;\n\t\tbreak;\n\tcase AUDIO_ENCODING_ALAW:\n\t\tp->sw_code = alaw_to_ulinear8;\n\t\tr->sw_code = ulinear8_to_alaw;\n\t\tbreak;\n\tcase AUDIO_ENCODING_ULINEAR_BE:\n\tcase AUDIO_ENCODING_SLINEAR_BE:\n\t\tr->sw_code = p->sw_code = swap_bytes;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad1848_set_params",
          "args": [
            "ac",
            "setmode",
            "usemode",
            "p",
            "r"
          ],
          "line": 1520
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_set_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "1012-1104",
          "snippet": "int\nad1848_set_params(addr, setmode, usemode, p, r)\n    void *addr;\n    int setmode, usemode;\n    struct audio_params *p, *r;\n{\n    struct ad1848_softc *sc = addr;\n    int error, bits, enc;\n    void (*pswcode) __P((void *, u_char *buf, int cnt));\n    void (*rswcode) __P((void *, u_char *buf, int cnt));\n\n    DPRINTF((\"ad1848_set_params: %d %d %d %ld\\n\", \n\t     p->encoding, p->precision, p->channels, p->sample_rate));\n\n    enc = p->encoding;\n    pswcode = rswcode = 0;\n    switch (enc) {\n    case AUDIO_ENCODING_SLINEAR_LE:\n\tif (p->precision == 8) {\n\t    enc = AUDIO_ENCODING_ULINEAR_LE;\n\t    pswcode = rswcode = change_sign8;\n\t}\n\tbreak;\n    case AUDIO_ENCODING_SLINEAR_BE:\n\tif (p->precision == 16 && sc->mode == 1) {\n\t    enc = AUDIO_ENCODING_SLINEAR_LE;\n\t    pswcode = rswcode = swap_bytes;\n\t}\n\tbreak;\n    case AUDIO_ENCODING_ULINEAR_LE:\n\tif (p->precision == 16) {\n\t    enc = AUDIO_ENCODING_SLINEAR_LE;\n\t    pswcode = rswcode = change_sign16;\n\t}\n\tbreak;\n    case AUDIO_ENCODING_ULINEAR_BE:\n\tif (p->precision == 16) {\n\t    enc = AUDIO_ENCODING_SLINEAR_LE;\n\t    pswcode = swap_bytes_change_sign16;\n\t    rswcode = change_sign16_swap_bytes;\n\t}\n\tbreak;\n    }\n    switch (enc) {\n    case AUDIO_ENCODING_ULAW:\n\tbits = FMT_ULAW >> 5;\n\tbreak;\n    case AUDIO_ENCODING_ALAW:\n\tbits = FMT_ALAW >> 5;\n\tbreak;\n    case AUDIO_ENCODING_ADPCM:\n\tbits = FMT_ADPCM >> 5;\n\tbreak;\n    case AUDIO_ENCODING_SLINEAR_LE:\n\tif (p->precision == 16)\n\t    bits = FMT_TWOS_COMP >> 5;\n\telse\n\t    return EINVAL;\n\tbreak;\n    case AUDIO_ENCODING_SLINEAR_BE:\n\tif (p->precision == 16)\n\t    bits = FMT_TWOS_COMP_BE >> 5;\n\telse\n\t    return EINVAL;\n\tbreak;\n    case AUDIO_ENCODING_ULINEAR_LE:\n\tif (p->precision == 8)\n\t    bits = FMT_PCM8 >> 5;\n\telse\n\t    return EINVAL;\n\tbreak;\n    default:\n\treturn EINVAL;\n    }\n\n    if (p->channels < 1 || p->channels > 2)\n\treturn EINVAL;\n\n    error = ad1848_set_speed(sc, &p->sample_rate);\n    if (error)\n\treturn error;\n\n    p->sw_code = pswcode;\n    r->sw_code = rswcode;\n\n    sc->format_bits = bits;\n    sc->channels = p->channels;\n    sc->precision = p->precision;\n    sc->need_commit = 1;\n\n    DPRINTF((\"ad1848_set_params succeeded, bits=%x\\n\", bits));\n    return (0);\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tad1848_set_speed",
            "int cnt;",
            "void *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\tad1848_set_speed;\nint cnt;\nvoid *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nint\nad1848_set_params(addr, setmode, usemode, p, r)\n    void *addr;\n    int setmode, usemode;\n    struct audio_params *p, *r;\n{\n    struct ad1848_softc *sc = addr;\n    int error, bits, enc;\n    void (*pswcode) __P((void *, u_char *buf, int cnt));\n    void (*rswcode) __P((void *, u_char *buf, int cnt));\n\n    DPRINTF((\"ad1848_set_params: %d %d %d %ld\\n\", \n\t     p->encoding, p->precision, p->channels, p->sample_rate));\n\n    enc = p->encoding;\n    pswcode = rswcode = 0;\n    switch (enc) {\n    case AUDIO_ENCODING_SLINEAR_LE:\n\tif (p->precision == 8) {\n\t    enc = AUDIO_ENCODING_ULINEAR_LE;\n\t    pswcode = rswcode = change_sign8;\n\t}\n\tbreak;\n    case AUDIO_ENCODING_SLINEAR_BE:\n\tif (p->precision == 16 && sc->mode == 1) {\n\t    enc = AUDIO_ENCODING_SLINEAR_LE;\n\t    pswcode = rswcode = swap_bytes;\n\t}\n\tbreak;\n    case AUDIO_ENCODING_ULINEAR_LE:\n\tif (p->precision == 16) {\n\t    enc = AUDIO_ENCODING_SLINEAR_LE;\n\t    pswcode = rswcode = change_sign16;\n\t}\n\tbreak;\n    case AUDIO_ENCODING_ULINEAR_BE:\n\tif (p->precision == 16) {\n\t    enc = AUDIO_ENCODING_SLINEAR_LE;\n\t    pswcode = swap_bytes_change_sign16;\n\t    rswcode = change_sign16_swap_bytes;\n\t}\n\tbreak;\n    }\n    switch (enc) {\n    case AUDIO_ENCODING_ULAW:\n\tbits = FMT_ULAW >> 5;\n\tbreak;\n    case AUDIO_ENCODING_ALAW:\n\tbits = FMT_ALAW >> 5;\n\tbreak;\n    case AUDIO_ENCODING_ADPCM:\n\tbits = FMT_ADPCM >> 5;\n\tbreak;\n    case AUDIO_ENCODING_SLINEAR_LE:\n\tif (p->precision == 16)\n\t    bits = FMT_TWOS_COMP >> 5;\n\telse\n\t    return EINVAL;\n\tbreak;\n    case AUDIO_ENCODING_SLINEAR_BE:\n\tif (p->precision == 16)\n\t    bits = FMT_TWOS_COMP_BE >> 5;\n\telse\n\t    return EINVAL;\n\tbreak;\n    case AUDIO_ENCODING_ULINEAR_LE:\n\tif (p->precision == 8)\n\t    bits = FMT_PCM8 >> 5;\n\telse\n\t    return EINVAL;\n\tbreak;\n    default:\n\treturn EINVAL;\n    }\n\n    if (p->channels < 1 || p->channels > 2)\n\treturn EINVAL;\n\n    error = ad1848_set_speed(sc, &p->sample_rate);\n    if (error)\n\treturn error;\n\n    p->sw_code = pswcode;\n    r->sw_code = rswcode;\n\n    sc->format_bits = bits;\n    sc->channels = p->channels;\n    sc->precision = p->precision;\n    sc->need_commit = 1;\n\n    DPRINTF((\"ad1848_set_params succeeded, bits=%x\\n\", bits));\n    return (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngusmax_set_params(addr, setmode, usemode, p, r)\n\tvoid *addr;\n\tint setmode, usemode;\n\tstruct audio_params *p, *r;\n{\n\tstruct ad1848_softc *ac = addr;\n\tstruct gus_softc *sc = ac->parent;\n\tint error;\n\n\terror = ad1848_set_params(ac, setmode, usemode, p, r);\n\tif (error)\n\t\treturn error;\n\terror = gus_set_params(sc, setmode, usemode, p, r);\n\treturn error;\n}"
  },
  {
    "function_name": "gus_set_volume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "1478-1504",
    "snippet": "void\ngus_set_volume(sc, voice, volume)\n\tstruct gus_softc *sc;\n\tint voice, volume;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tunsigned int gusvol;\n\n\tgusvol = gus_log_volumes[volume < 512 ? volume : 511];\n\n\tsc->sc_voc[voice].current_volume = gusvol;\n\n\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, (unsigned char) voice);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_START_VOLUME);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, (unsigned char) (gusvol >> 4));\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_END_VOLUME);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, (unsigned char) (gusvol >> 4));\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_VOLUME);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, gusvol << 4);\n\tdelay(500);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, gusvol << 4);\n\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned short gus_log_volumes[512] = {\n 0x0000,\n 0x0700, 0x07ff, 0x0880, 0x08ff, 0x0940, 0x0980, 0x09c0, 0x09ff, 0x0a20,\n 0x0a40, 0x0a60, 0x0a80, 0x0aa0, 0x0ac0, 0x0ae0, 0x0aff, 0x0b10, 0x0b20,\n 0x0b30, 0x0b40, 0x0b50, 0x0b60, 0x0b70, 0x0b80, 0x0b90, 0x0ba0, 0x0bb0,\n 0x0bc0, 0x0bd0, 0x0be0, 0x0bf0, 0x0bff, 0x0c08, 0x0c10, 0x0c18, 0x0c20,\n 0x0c28, 0x0c30, 0x0c38, 0x0c40, 0x0c48, 0x0c50, 0x0c58, 0x0c60, 0x0c68,\n 0x0c70, 0x0c78, 0x0c80, 0x0c88, 0x0c90, 0x0c98, 0x0ca0, 0x0ca8, 0x0cb0,\n 0x0cb8, 0x0cc0, 0x0cc8, 0x0cd0, 0x0cd8, 0x0ce0, 0x0ce8, 0x0cf0, 0x0cf8,\n 0x0cff, 0x0d04, 0x0d08, 0x0d0c, 0x0d10, 0x0d14, 0x0d18, 0x0d1c, 0x0d20,\n 0x0d24, 0x0d28, 0x0d2c, 0x0d30, 0x0d34, 0x0d38, 0x0d3c, 0x0d40, 0x0d44,\n 0x0d48, 0x0d4c, 0x0d50, 0x0d54, 0x0d58, 0x0d5c, 0x0d60, 0x0d64, 0x0d68,\n 0x0d6c, 0x0d70, 0x0d74, 0x0d78, 0x0d7c, 0x0d80, 0x0d84, 0x0d88, 0x0d8c,\n 0x0d90, 0x0d94, 0x0d98, 0x0d9c, 0x0da0, 0x0da4, 0x0da8, 0x0dac, 0x0db0,\n 0x0db4, 0x0db8, 0x0dbc, 0x0dc0, 0x0dc4, 0x0dc8, 0x0dcc, 0x0dd0, 0x0dd4,\n 0x0dd8, 0x0ddc, 0x0de0, 0x0de4, 0x0de8, 0x0dec, 0x0df0, 0x0df4, 0x0df8,\n 0x0dfc, 0x0dff, 0x0e02, 0x0e04, 0x0e06, 0x0e08, 0x0e0a, 0x0e0c, 0x0e0e,\n 0x0e10, 0x0e12, 0x0e14, 0x0e16, 0x0e18, 0x0e1a, 0x0e1c, 0x0e1e, 0x0e20,\n 0x0e22, 0x0e24, 0x0e26, 0x0e28, 0x0e2a, 0x0e2c, 0x0e2e, 0x0e30, 0x0e32,\n 0x0e34, 0x0e36, 0x0e38, 0x0e3a, 0x0e3c, 0x0e3e, 0x0e40, 0x0e42, 0x0e44,\n 0x0e46, 0x0e48, 0x0e4a, 0x0e4c, 0x0e4e, 0x0e50, 0x0e52, 0x0e54, 0x0e56,\n 0x0e58, 0x0e5a, 0x0e5c, 0x0e5e, 0x0e60, 0x0e62, 0x0e64, 0x0e66, 0x0e68,\n 0x0e6a, 0x0e6c, 0x0e6e, 0x0e70, 0x0e72, 0x0e74, 0x0e76, 0x0e78, 0x0e7a,\n 0x0e7c, 0x0e7e, 0x0e80, 0x0e82, 0x0e84, 0x0e86, 0x0e88, 0x0e8a, 0x0e8c,\n 0x0e8e, 0x0e90, 0x0e92, 0x0e94, 0x0e96, 0x0e98, 0x0e9a, 0x0e9c, 0x0e9e,\n 0x0ea0, 0x0ea2, 0x0ea4, 0x0ea6, 0x0ea8, 0x0eaa, 0x0eac, 0x0eae, 0x0eb0,\n 0x0eb2, 0x0eb4, 0x0eb6, 0x0eb8, 0x0eba, 0x0ebc, 0x0ebe, 0x0ec0, 0x0ec2,\n 0x0ec4, 0x0ec6, 0x0ec8, 0x0eca, 0x0ecc, 0x0ece, 0x0ed0, 0x0ed2, 0x0ed4,\n 0x0ed6, 0x0ed8, 0x0eda, 0x0edc, 0x0ede, 0x0ee0, 0x0ee2, 0x0ee4, 0x0ee6,\n 0x0ee8, 0x0eea, 0x0eec, 0x0eee, 0x0ef0, 0x0ef2, 0x0ef4, 0x0ef6, 0x0ef8,\n 0x0efa, 0x0efc, 0x0efe, 0x0eff, 0x0f01, 0x0f02, 0x0f03, 0x0f04, 0x0f05,\n 0x0f06, 0x0f07, 0x0f08, 0x0f09, 0x0f0a, 0x0f0b, 0x0f0c, 0x0f0d, 0x0f0e,\n 0x0f0f, 0x0f10, 0x0f11, 0x0f12, 0x0f13, 0x0f14, 0x0f15, 0x0f16, 0x0f17,\n 0x0f18, 0x0f19, 0x0f1a, 0x0f1b, 0x0f1c, 0x0f1d, 0x0f1e, 0x0f1f, 0x0f20,\n 0x0f21, 0x0f22, 0x0f23, 0x0f24, 0x0f25, 0x0f26, 0x0f27, 0x0f28, 0x0f29,\n 0x0f2a, 0x0f2b, 0x0f2c, 0x0f2d, 0x0f2e, 0x0f2f, 0x0f30, 0x0f31, 0x0f32,\n 0x0f33, 0x0f34, 0x0f35, 0x0f36, 0x0f37, 0x0f38, 0x0f39, 0x0f3a, 0x0f3b,\n 0x0f3c, 0x0f3d, 0x0f3e, 0x0f3f, 0x0f40, 0x0f41, 0x0f42, 0x0f43, 0x0f44,\n 0x0f45, 0x0f46, 0x0f47, 0x0f48, 0x0f49, 0x0f4a, 0x0f4b, 0x0f4c, 0x0f4d,\n 0x0f4e, 0x0f4f, 0x0f50, 0x0f51, 0x0f52, 0x0f53, 0x0f54, 0x0f55, 0x0f56,\n 0x0f57, 0x0f58, 0x0f59, 0x0f5a, 0x0f5b, 0x0f5c, 0x0f5d, 0x0f5e, 0x0f5f,\n 0x0f60, 0x0f61, 0x0f62, 0x0f63, 0x0f64, 0x0f65, 0x0f66, 0x0f67, 0x0f68,\n 0x0f69, 0x0f6a, 0x0f6b, 0x0f6c, 0x0f6d, 0x0f6e, 0x0f6f, 0x0f70, 0x0f71,\n 0x0f72, 0x0f73, 0x0f74, 0x0f75, 0x0f76, 0x0f77, 0x0f78, 0x0f79, 0x0f7a,\n 0x0f7b, 0x0f7c, 0x0f7d, 0x0f7e, 0x0f7f, 0x0f80, 0x0f81, 0x0f82, 0x0f83,\n 0x0f84, 0x0f85, 0x0f86, 0x0f87, 0x0f88, 0x0f89, 0x0f8a, 0x0f8b, 0x0f8c,\n 0x0f8d, 0x0f8e, 0x0f8f, 0x0f90, 0x0f91, 0x0f92, 0x0f93, 0x0f94, 0x0f95,\n 0x0f96, 0x0f97, 0x0f98, 0x0f99, 0x0f9a, 0x0f9b, 0x0f9c, 0x0f9d, 0x0f9e,\n 0x0f9f, 0x0fa0, 0x0fa1, 0x0fa2, 0x0fa3, 0x0fa4, 0x0fa5, 0x0fa6, 0x0fa7,\n 0x0fa8, 0x0fa9, 0x0faa, 0x0fab, 0x0fac, 0x0fad, 0x0fae, 0x0faf, 0x0fb0,\n 0x0fb1, 0x0fb2, 0x0fb3, 0x0fb4, 0x0fb5, 0x0fb6, 0x0fb7, 0x0fb8, 0x0fb9,\n 0x0fba, 0x0fbb, 0x0fbc, 0x0fbd, 0x0fbe, 0x0fbf, 0x0fc0, 0x0fc1, 0x0fc2,\n 0x0fc3, 0x0fc4, 0x0fc5, 0x0fc6, 0x0fc7, 0x0fc8, 0x0fc9, 0x0fca, 0x0fcb,\n 0x0fcc, 0x0fcd, 0x0fce, 0x0fcf, 0x0fd0, 0x0fd1, 0x0fd2, 0x0fd3, 0x0fd4,\n 0x0fd5, 0x0fd6, 0x0fd7, 0x0fd8, 0x0fd9, 0x0fda, 0x0fdb, 0x0fdc, 0x0fdd,\n 0x0fde, 0x0fdf, 0x0fe0, 0x0fe1, 0x0fe2, 0x0fe3, 0x0fe4, 0x0fe5, 0x0fe6,\n 0x0fe7, 0x0fe8, 0x0fe9, 0x0fea, 0x0feb, 0x0fec, 0x0fed, 0x0fee, 0x0fef,\n 0x0ff0, 0x0ff1, 0x0ff2, 0x0ff3, 0x0ff4, 0x0ff5, 0x0ff6, 0x0ff7, 0x0ff8,\n 0x0ff9, 0x0ffa, 0x0ffb, 0x0ffc, 0x0ffd, 0x0ffe, 0x0fff};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_LOW",
            "gusvol << 4"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "500"
          ],
          "line": 1501
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_LOW",
            "gusvol << 4"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_CUR_VOLUME"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "(unsigned char) (gusvol >> 4)"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_END_VOLUME"
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "(unsigned char) (gusvol >> 4)"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_START_VOLUME"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_VOICE_SELECT",
            "(unsigned char) voice"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic unsigned short gus_log_volumes[512] = {\n 0x0000,\n 0x0700, 0x07ff, 0x0880, 0x08ff, 0x0940, 0x0980, 0x09c0, 0x09ff, 0x0a20,\n 0x0a40, 0x0a60, 0x0a80, 0x0aa0, 0x0ac0, 0x0ae0, 0x0aff, 0x0b10, 0x0b20,\n 0x0b30, 0x0b40, 0x0b50, 0x0b60, 0x0b70, 0x0b80, 0x0b90, 0x0ba0, 0x0bb0,\n 0x0bc0, 0x0bd0, 0x0be0, 0x0bf0, 0x0bff, 0x0c08, 0x0c10, 0x0c18, 0x0c20,\n 0x0c28, 0x0c30, 0x0c38, 0x0c40, 0x0c48, 0x0c50, 0x0c58, 0x0c60, 0x0c68,\n 0x0c70, 0x0c78, 0x0c80, 0x0c88, 0x0c90, 0x0c98, 0x0ca0, 0x0ca8, 0x0cb0,\n 0x0cb8, 0x0cc0, 0x0cc8, 0x0cd0, 0x0cd8, 0x0ce0, 0x0ce8, 0x0cf0, 0x0cf8,\n 0x0cff, 0x0d04, 0x0d08, 0x0d0c, 0x0d10, 0x0d14, 0x0d18, 0x0d1c, 0x0d20,\n 0x0d24, 0x0d28, 0x0d2c, 0x0d30, 0x0d34, 0x0d38, 0x0d3c, 0x0d40, 0x0d44,\n 0x0d48, 0x0d4c, 0x0d50, 0x0d54, 0x0d58, 0x0d5c, 0x0d60, 0x0d64, 0x0d68,\n 0x0d6c, 0x0d70, 0x0d74, 0x0d78, 0x0d7c, 0x0d80, 0x0d84, 0x0d88, 0x0d8c,\n 0x0d90, 0x0d94, 0x0d98, 0x0d9c, 0x0da0, 0x0da4, 0x0da8, 0x0dac, 0x0db0,\n 0x0db4, 0x0db8, 0x0dbc, 0x0dc0, 0x0dc4, 0x0dc8, 0x0dcc, 0x0dd0, 0x0dd4,\n 0x0dd8, 0x0ddc, 0x0de0, 0x0de4, 0x0de8, 0x0dec, 0x0df0, 0x0df4, 0x0df8,\n 0x0dfc, 0x0dff, 0x0e02, 0x0e04, 0x0e06, 0x0e08, 0x0e0a, 0x0e0c, 0x0e0e,\n 0x0e10, 0x0e12, 0x0e14, 0x0e16, 0x0e18, 0x0e1a, 0x0e1c, 0x0e1e, 0x0e20,\n 0x0e22, 0x0e24, 0x0e26, 0x0e28, 0x0e2a, 0x0e2c, 0x0e2e, 0x0e30, 0x0e32,\n 0x0e34, 0x0e36, 0x0e38, 0x0e3a, 0x0e3c, 0x0e3e, 0x0e40, 0x0e42, 0x0e44,\n 0x0e46, 0x0e48, 0x0e4a, 0x0e4c, 0x0e4e, 0x0e50, 0x0e52, 0x0e54, 0x0e56,\n 0x0e58, 0x0e5a, 0x0e5c, 0x0e5e, 0x0e60, 0x0e62, 0x0e64, 0x0e66, 0x0e68,\n 0x0e6a, 0x0e6c, 0x0e6e, 0x0e70, 0x0e72, 0x0e74, 0x0e76, 0x0e78, 0x0e7a,\n 0x0e7c, 0x0e7e, 0x0e80, 0x0e82, 0x0e84, 0x0e86, 0x0e88, 0x0e8a, 0x0e8c,\n 0x0e8e, 0x0e90, 0x0e92, 0x0e94, 0x0e96, 0x0e98, 0x0e9a, 0x0e9c, 0x0e9e,\n 0x0ea0, 0x0ea2, 0x0ea4, 0x0ea6, 0x0ea8, 0x0eaa, 0x0eac, 0x0eae, 0x0eb0,\n 0x0eb2, 0x0eb4, 0x0eb6, 0x0eb8, 0x0eba, 0x0ebc, 0x0ebe, 0x0ec0, 0x0ec2,\n 0x0ec4, 0x0ec6, 0x0ec8, 0x0eca, 0x0ecc, 0x0ece, 0x0ed0, 0x0ed2, 0x0ed4,\n 0x0ed6, 0x0ed8, 0x0eda, 0x0edc, 0x0ede, 0x0ee0, 0x0ee2, 0x0ee4, 0x0ee6,\n 0x0ee8, 0x0eea, 0x0eec, 0x0eee, 0x0ef0, 0x0ef2, 0x0ef4, 0x0ef6, 0x0ef8,\n 0x0efa, 0x0efc, 0x0efe, 0x0eff, 0x0f01, 0x0f02, 0x0f03, 0x0f04, 0x0f05,\n 0x0f06, 0x0f07, 0x0f08, 0x0f09, 0x0f0a, 0x0f0b, 0x0f0c, 0x0f0d, 0x0f0e,\n 0x0f0f, 0x0f10, 0x0f11, 0x0f12, 0x0f13, 0x0f14, 0x0f15, 0x0f16, 0x0f17,\n 0x0f18, 0x0f19, 0x0f1a, 0x0f1b, 0x0f1c, 0x0f1d, 0x0f1e, 0x0f1f, 0x0f20,\n 0x0f21, 0x0f22, 0x0f23, 0x0f24, 0x0f25, 0x0f26, 0x0f27, 0x0f28, 0x0f29,\n 0x0f2a, 0x0f2b, 0x0f2c, 0x0f2d, 0x0f2e, 0x0f2f, 0x0f30, 0x0f31, 0x0f32,\n 0x0f33, 0x0f34, 0x0f35, 0x0f36, 0x0f37, 0x0f38, 0x0f39, 0x0f3a, 0x0f3b,\n 0x0f3c, 0x0f3d, 0x0f3e, 0x0f3f, 0x0f40, 0x0f41, 0x0f42, 0x0f43, 0x0f44,\n 0x0f45, 0x0f46, 0x0f47, 0x0f48, 0x0f49, 0x0f4a, 0x0f4b, 0x0f4c, 0x0f4d,\n 0x0f4e, 0x0f4f, 0x0f50, 0x0f51, 0x0f52, 0x0f53, 0x0f54, 0x0f55, 0x0f56,\n 0x0f57, 0x0f58, 0x0f59, 0x0f5a, 0x0f5b, 0x0f5c, 0x0f5d, 0x0f5e, 0x0f5f,\n 0x0f60, 0x0f61, 0x0f62, 0x0f63, 0x0f64, 0x0f65, 0x0f66, 0x0f67, 0x0f68,\n 0x0f69, 0x0f6a, 0x0f6b, 0x0f6c, 0x0f6d, 0x0f6e, 0x0f6f, 0x0f70, 0x0f71,\n 0x0f72, 0x0f73, 0x0f74, 0x0f75, 0x0f76, 0x0f77, 0x0f78, 0x0f79, 0x0f7a,\n 0x0f7b, 0x0f7c, 0x0f7d, 0x0f7e, 0x0f7f, 0x0f80, 0x0f81, 0x0f82, 0x0f83,\n 0x0f84, 0x0f85, 0x0f86, 0x0f87, 0x0f88, 0x0f89, 0x0f8a, 0x0f8b, 0x0f8c,\n 0x0f8d, 0x0f8e, 0x0f8f, 0x0f90, 0x0f91, 0x0f92, 0x0f93, 0x0f94, 0x0f95,\n 0x0f96, 0x0f97, 0x0f98, 0x0f99, 0x0f9a, 0x0f9b, 0x0f9c, 0x0f9d, 0x0f9e,\n 0x0f9f, 0x0fa0, 0x0fa1, 0x0fa2, 0x0fa3, 0x0fa4, 0x0fa5, 0x0fa6, 0x0fa7,\n 0x0fa8, 0x0fa9, 0x0faa, 0x0fab, 0x0fac, 0x0fad, 0x0fae, 0x0faf, 0x0fb0,\n 0x0fb1, 0x0fb2, 0x0fb3, 0x0fb4, 0x0fb5, 0x0fb6, 0x0fb7, 0x0fb8, 0x0fb9,\n 0x0fba, 0x0fbb, 0x0fbc, 0x0fbd, 0x0fbe, 0x0fbf, 0x0fc0, 0x0fc1, 0x0fc2,\n 0x0fc3, 0x0fc4, 0x0fc5, 0x0fc6, 0x0fc7, 0x0fc8, 0x0fc9, 0x0fca, 0x0fcb,\n 0x0fcc, 0x0fcd, 0x0fce, 0x0fcf, 0x0fd0, 0x0fd1, 0x0fd2, 0x0fd3, 0x0fd4,\n 0x0fd5, 0x0fd6, 0x0fd7, 0x0fd8, 0x0fd9, 0x0fda, 0x0fdb, 0x0fdc, 0x0fdd,\n 0x0fde, 0x0fdf, 0x0fe0, 0x0fe1, 0x0fe2, 0x0fe3, 0x0fe4, 0x0fe5, 0x0fe6,\n 0x0fe7, 0x0fe8, 0x0fe9, 0x0fea, 0x0feb, 0x0fec, 0x0fed, 0x0fee, 0x0fef,\n 0x0ff0, 0x0ff1, 0x0ff2, 0x0ff3, 0x0ff4, 0x0ff5, 0x0ff6, 0x0ff7, 0x0ff8,\n 0x0ff9, 0x0ffa, 0x0ffb, 0x0ffc, 0x0ffd, 0x0ffe, 0x0fff};\n\nvoid\ngus_set_volume(sc, voice, volume)\n\tstruct gus_softc *sc;\n\tint voice, volume;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tunsigned int gusvol;\n\n\tgusvol = gus_log_volumes[volume < 512 ? volume : 511];\n\n\tsc->sc_voc[voice].current_volume = gusvol;\n\n\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, (unsigned char) voice);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_START_VOLUME);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, (unsigned char) (gusvol >> 4));\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_END_VOLUME);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, (unsigned char) (gusvol >> 4));\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_VOLUME);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, gusvol << 4);\n\tdelay(500);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, gusvol << 4);\n\n}"
  },
  {
    "function_name": "gus_stop_voice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "1435-1472",
    "snippet": "void\ngus_stop_voice(sc, voice, intrs_too)\n\tstruct gus_softc *sc;\n\tint voice;\n\tint intrs_too;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\n\tsc->sc_voc[voice].voccntl |= GUSMASK_VOICE_STOPPED |\n\t\tGUSMASK_STOP_VOICE;\n\tif (intrs_too) {\n\t  sc->sc_voc[voice].voccntl &= ~(GUSMASK_VOICE_IRQ);\n\t  /* no more DMA to do */\n\t  sc->sc_flags &= ~GUS_PLAYING;\n\t}\n\tDMAPRINTF((\"gusintr voice notplaying=%x\\n\", sc->sc_flags));\n\n\tguspoke(iot, ioh2, 0L, 0);\n\n\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, (unsigned char) voice);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_VOLUME);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].voccntl);\n\tdelay(100);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_VOLUME);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].voccntl);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_HIGH);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_LOW);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_LOW",
            "0x0000"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_CUR_ADDR_LOW"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_LOW",
            "0x0000"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_CUR_ADDR_HIGH"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "sc->sc_voc[voice].voccntl"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_VOICE_CNTL"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_LOW",
            "0x0000"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_CUR_VOLUME"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "100"
          ],
          "line": 1461
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "sc->sc_voc[voice].voccntl"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_VOICE_CNTL"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_LOW",
            "0x0000"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_CUR_VOLUME"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_VOICE_SELECT",
            "(unsigned char) voice"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "guspoke",
          "args": [
            "iot",
            "ioh2",
            "0L",
            "0"
          ],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "guspoke",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "1997-2019",
          "snippet": "void\nguspoke(iot, ioh2, address, value)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh2;\n\tlong address;\n\tunsigned char value;\n{\n\n\t/*\n\t * Select the DRAM address\n\t */\n\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_LOW);\n \tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, (unsigned int) (address & 0xffff));\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_HIGH);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, (unsigned char) ((address >> 16) & 0xff));\n\n\t/*\n\t * Actually write the data\n\t */\n\n\tbus_space_write_1(iot, ioh2, GUS_DRAM_DATA, value);\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nguspoke(iot, ioh2, address, value)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh2;\n\tlong address;\n\tunsigned char value;\n{\n\n\t/*\n\t * Select the DRAM address\n\t */\n\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_LOW);\n \tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, (unsigned int) (address & 0xffff));\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_HIGH);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, (unsigned char) ((address >> 16) & 0xff));\n\n\t/*\n\t * Actually write the data\n\t */\n\n\tbus_space_write_1(iot, ioh2, GUS_DRAM_DATA, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DMAPRINTF",
          "args": [
            "(\"gusintr voice notplaying=%x\\n\", sc->sc_flags)"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ngus_stop_voice(sc, voice, intrs_too)\n\tstruct gus_softc *sc;\n\tint voice;\n\tint intrs_too;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\n\tsc->sc_voc[voice].voccntl |= GUSMASK_VOICE_STOPPED |\n\t\tGUSMASK_STOP_VOICE;\n\tif (intrs_too) {\n\t  sc->sc_voc[voice].voccntl &= ~(GUSMASK_VOICE_IRQ);\n\t  /* no more DMA to do */\n\t  sc->sc_flags &= ~GUS_PLAYING;\n\t}\n\tDMAPRINTF((\"gusintr voice notplaying=%x\\n\", sc->sc_flags));\n\n\tguspoke(iot, ioh2, 0L, 0);\n\n\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, (unsigned char) voice);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_VOLUME);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].voccntl);\n\tdelay(100);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_VOLUME);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].voccntl);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_HIGH);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_LOW);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\n}"
  },
  {
    "function_name": "gus_start_voice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "1338-1429",
    "snippet": "void\ngus_start_voice(sc, voice, intrs)\n\tstruct gus_softc *sc;\n\tint voice;\n\tint intrs;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tu_long start;\n\tu_long current;\n\tu_long end;\n\n\t/*\n\t * Pick all the values for the voice out of the gus_voice struct\n\t * and use those to program the voice\n\t */\n\n \tstart = sc->sc_voc[voice].start_addr;\n \tcurrent = sc->sc_voc[voice].current_addr;\n \tend = sc->sc_voc[voice].end_addr;\n\n \t/*\n\t * If we're using 16 bit data, mangle the addresses a bit\n\t */\n\n\tif (sc->sc_voc[voice].voccntl & GUSMASK_DATA_SIZE16) {\n\t        /* -1 on start so that we get onto sample boundary--other\n\t\t   code always sets it for 1-byte rollover protection */\n\t\tstart = convert_to_16bit(start-1);\n\t\tcurrent = convert_to_16bit(current);\n\t\tend = convert_to_16bit(end);\n\t}\n\n\t/*\n\t * Select the voice we want to use, and program the data addresses\n\t */\n\n\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, (unsigned char) voice);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_START_ADDR_HIGH);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_HIGH(start));\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_START_ADDR_LOW);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_LOW(start));\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_HIGH);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_HIGH(current));\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_LOW);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_LOW(current));\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_END_ADDR_HIGH);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_HIGH(end));\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_END_ADDR_LOW);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_LOW(end));\n\n\t/*\n\t * (maybe) enable interrupts, disable voice stopping\n\t */\n\n\tif (intrs) {\n\t\tsc->sc_flags |= GUS_PLAYING; /* playing is about to start */\n\t\tsc->sc_voc[voice].voccntl |= GUSMASK_VOICE_IRQ;\n\t\tDMAPRINTF((\"gus voice playing=%x\\n\", sc->sc_flags));\n\t} else\n\t\tsc->sc_voc[voice].voccntl &= ~GUSMASK_VOICE_IRQ;\n\tsc->sc_voc[voice].voccntl &= ~(GUSMASK_VOICE_STOPPED |\n\t\tGUSMASK_STOP_VOICE);\n\n\t/*\n\t * Tell the GUS about it.  Note that we're doing volume ramping here\n\t * from 0 up to the set volume to help reduce clicks.\n\t */\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_START_VOLUME);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_END_VOLUME);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].current_volume >> 4);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_VOLUME);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x00);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_RATE);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 63);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].voccntl);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);\n\tdelay(50);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].voccntl);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);\n\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "0x00"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_VOLUME_CONTROL"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "sc->sc_voc[voice].voccntl"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_VOICE_CNTL"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "50"
          ],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "lmc_delay_300ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_lmc.c",
          "lines": "217-223",
          "snippet": "static inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}",
          "includes": [
            "#include \"i386/pci/if_lmcvar.h\"",
            "#include \"i386/pci/if_lmcioctl.h\"",
            "#include \"i386/pci/if_lmctypes.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"",
            "#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <net/if_c_hdlc.h>",
            "#include <net/if_p2p.h>",
            "#include <net/if_types.h>",
            "#include <net/netisr.h>",
            "#include <net/if.h>",
            "#include <net/netisr.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_sppp.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <net/netisr.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if.h>",
            "#include <sys/rnd.h>",
            "#include \"rnd.h\"",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void lmc_rx_intr(lmc_softc_t * const sc);",
            "static void lmc_ifup(lmc_softc_t * const sc);",
            "static void lmc_ifdown(lmc_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"i386/pci/if_lmcvar.h\"\n#include \"i386/pci/if_lmcioctl.h\"\n#include \"i386/pci/if_lmctypes.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcvar.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmcioctl.h\"\n#include INCLUDE_PATH_PREFIX \"if_lmc_types.h\"\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <net/if_c_hdlc.h>\n#include <net/if_p2p.h>\n#include <net/if_types.h>\n#include <net/netisr.h>\n#include <net/if.h>\n#include <net/netisr.h>\n#include <netinet/ip.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_sppp.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <net/netisr.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if.h>\n#include <sys/rnd.h>\n#include \"rnd.h\"\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void lmc_rx_intr(lmc_softc_t * const sc);\nstatic void lmc_ifup(lmc_softc_t * const sc);\nstatic void lmc_ifdown(lmc_softc_t * const sc);\n\nstatic inline void\nlmc_delay_300ns(lmc_softc_t * const sc)\n{\n\tint idx;\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\t(void)LMC_CSR_READ(sc, csr_busmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "0x00"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_VOLUME_CONTROL"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "sc->sc_voc[voice].voccntl"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_VOICE_CNTL"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "63"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_VOLUME_RATE"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_LOW",
            "0x00"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_CUR_VOLUME"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "sc->sc_voc[voice].current_volume >> 4"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_END_VOLUME"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "0x00"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_START_VOLUME"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMAPRINTF",
          "args": [
            "(\"gus voice playing=%x\\n\", sc->sc_flags)"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_LOW",
            "ADDR_LOW(end)"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADDR_LOW",
          "args": [
            "end"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_END_ADDR_LOW"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_LOW",
            "ADDR_HIGH(end)"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADDR_HIGH",
          "args": [
            "end"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_END_ADDR_HIGH"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_LOW",
            "ADDR_LOW(current)"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADDR_LOW",
          "args": [
            "current"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_CUR_ADDR_LOW"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_LOW",
            "ADDR_HIGH(current)"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADDR_HIGH",
          "args": [
            "current"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_CUR_ADDR_HIGH"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_LOW",
            "ADDR_LOW(start)"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADDR_LOW",
          "args": [
            "start"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_START_ADDR_LOW"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_LOW",
            "ADDR_HIGH(start)"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ADDR_HIGH",
          "args": [
            "start"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_START_ADDR_HIGH"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_VOICE_SELECT",
            "(unsigned char) voice"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "convert_to_16bit",
          "args": [
            "end"
          ],
          "line": 1368
        },
        "resolved": true,
        "details": {
          "function_name": "convert_to_16bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "1979-1991",
          "snippet": "u_long\nconvert_to_16bit(address)\n\tu_long address;\n{\n\tu_long old_address;\n\n\told_address = address;\n\taddress >>= 1;\n\taddress &= 0x0001ffffL;\n\taddress |= (old_address & 0x000c0000L);\n\n\treturn (address);\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_long\nconvert_to_16bit(address)\n\tu_long address;\n{\n\tu_long old_address;\n\n\told_address = address;\n\taddress >>= 1;\n\taddress &= 0x0001ffffL;\n\taddress |= (old_address & 0x000c0000L);\n\n\treturn (address);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ngus_start_voice(sc, voice, intrs)\n\tstruct gus_softc *sc;\n\tint voice;\n\tint intrs;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tu_long start;\n\tu_long current;\n\tu_long end;\n\n\t/*\n\t * Pick all the values for the voice out of the gus_voice struct\n\t * and use those to program the voice\n\t */\n\n \tstart = sc->sc_voc[voice].start_addr;\n \tcurrent = sc->sc_voc[voice].current_addr;\n \tend = sc->sc_voc[voice].end_addr;\n\n \t/*\n\t * If we're using 16 bit data, mangle the addresses a bit\n\t */\n\n\tif (sc->sc_voc[voice].voccntl & GUSMASK_DATA_SIZE16) {\n\t        /* -1 on start so that we get onto sample boundary--other\n\t\t   code always sets it for 1-byte rollover protection */\n\t\tstart = convert_to_16bit(start-1);\n\t\tcurrent = convert_to_16bit(current);\n\t\tend = convert_to_16bit(end);\n\t}\n\n\t/*\n\t * Select the voice we want to use, and program the data addresses\n\t */\n\n\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, (unsigned char) voice);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_START_ADDR_HIGH);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_HIGH(start));\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_START_ADDR_LOW);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_LOW(start));\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_HIGH);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_HIGH(current));\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_LOW);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_LOW(current));\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_END_ADDR_HIGH);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_HIGH(end));\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_END_ADDR_LOW);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_LOW(end));\n\n\t/*\n\t * (maybe) enable interrupts, disable voice stopping\n\t */\n\n\tif (intrs) {\n\t\tsc->sc_flags |= GUS_PLAYING; /* playing is about to start */\n\t\tsc->sc_voc[voice].voccntl |= GUSMASK_VOICE_IRQ;\n\t\tDMAPRINTF((\"gus voice playing=%x\\n\", sc->sc_flags));\n\t} else\n\t\tsc->sc_voc[voice].voccntl &= ~GUSMASK_VOICE_IRQ;\n\tsc->sc_voc[voice].voccntl &= ~(GUSMASK_VOICE_STOPPED |\n\t\tGUSMASK_STOP_VOICE);\n\n\t/*\n\t * Tell the GUS about it.  Note that we're doing volume ramping here\n\t * from 0 up to the set volume to help reduce clicks.\n\t */\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_START_VOLUME);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_END_VOLUME);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].current_volume >> 4);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_VOLUME);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x00);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_RATE);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 63);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].voccntl);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);\n\tdelay(50);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].voccntl);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);\n\n}"
  },
  {
    "function_name": "gusdmaout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "1263-1331",
    "snippet": "void\ngusdmaout(sc, flags, gusaddr, buffaddr, length)\n\tstruct gus_softc *sc;\n\tint flags, length;\n\tu_long gusaddr;\n\tcaddr_t buffaddr;\n{\n\tunsigned char c = (unsigned char) flags;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\n\tDMAPRINTF((\"gusdmaout flags=%x scflags=%x\\n\", flags, sc->sc_flags));\n\n\tsc->sc_gusaddr = gusaddr;\n\n\t/*\n\t * If we're using a 16 bit DMA channel, we have to jump through some\n\t * extra hoops; this includes translating the DRAM address a bit\n\t */\n\n\tif (sc->sc_drq >= 4) {\n\t\tc |= GUSMASK_DMA_WIDTH;\n\t\tgusaddr = convert_to_16bit(gusaddr);\n\t}\n\n\t/*\n\t * Add flag bits that we always set - fast DMA, enable IRQ\n\t */\n\n\tc |= GUSMASK_DMA_ENABLE | GUSMASK_DMA_R0 | GUSMASK_DMA_IRQ;\n\n\t/*\n\t * Make sure the GUS _isn't_ setup for DMA\n\t */\n\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0);\n\n\t/*\n\t * Tell the PC DMA controller to start doing DMA\n\t */\n\n\tsc->sc_dmaoutaddr = (u_char *) buffaddr;\n\tsc->sc_dmaoutcnt = length;\n \tisa_dmastart(sc->sc_dev.dv_parent, sc->sc_drq, buffaddr, length,\n \t    NULL, DMAMODE_WRITE, BUS_DMA_NOWAIT);\n\n\t/*\n\t * Set up DMA address - use the upper 16 bits ONLY\n\t */\n\n\tsc->sc_flags |= GUS_DMAOUT_ACTIVE;\n\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_START);\n \tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, (int) (gusaddr >> 4));\n\n \t/*\n \t * Tell the GUS to start doing DMA\n \t */\n\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, c);\n\n\t/*\n\t * XXX If we don't finish in one second, give up...\n\t */\n\tuntimeout(gus_dmaout_timeout, sc); /* flush old one, if there is one */\n\ttimeout(gus_dmaout_timeout, sc, hz);\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "gus_dmaout_timeout",
            "sc",
            "hz"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "gus_dmaout_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "725-750",
          "snippet": "void\ngus_dmaout_timeout(arg)\n \tvoid *arg;\n{\n \tstruct gus_softc *sc = arg;\n \tbus_space_tag_t iot = sc->sc_iot;\n \tbus_space_handle_t ioh2 = sc->sc_ioh2;\n \tint s;\n\n \tprintf(\"%s: dmaout timeout\\n\", sc->sc_dev.dv_xname);\n \t/*\n \t * Stop any DMA.\n \t */\n\n \ts = splgus();\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0);\n \t\n#if 0\n \t/* XXX we will dmadone below? */\n \tisa_dmaabort(sc->sc_dev.dv_parent, sc->sc_drq);\n#endif\n \t\n \tgus_dmaout_dointr(sc);\n \tsplx(s);\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ngus_dmaout_timeout(arg)\n \tvoid *arg;\n{\n \tstruct gus_softc *sc = arg;\n \tbus_space_tag_t iot = sc->sc_iot;\n \tbus_space_handle_t ioh2 = sc->sc_ioh2;\n \tint s;\n\n \tprintf(\"%s: dmaout timeout\\n\", sc->sc_dev.dv_xname);\n \t/*\n \t * Stop any DMA.\n \t */\n\n \ts = splgus();\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0);\n \t\n#if 0\n \t/* XXX we will dmadone below? */\n \tisa_dmaabort(sc->sc_dev.dv_parent, sc->sc_drq);\n#endif\n \t\n \tgus_dmaout_dointr(sc);\n \tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "gus_dmaout_timeout",
            "sc"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "c"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_DMA_CONTROL"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_2",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_LOW",
            "(int) (gusaddr >> 4)"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_DMA_START"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isa_dmastart",
          "args": [
            "sc->sc_dev.dv_parent",
            "sc->sc_drq",
            "buffaddr",
            "length",
            "NULL",
            "DMAMODE_WRITE",
            "BUS_DMA_NOWAIT"
          ],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "isa_dmastart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/isadma.c",
          "lines": "288-422",
          "snippet": "int\nisa_dmastart(isadev, chan, addr, nbytes, p, flags, busdmaflags)\n\tstruct device *isadev;\n\tint chan;\n\tvoid *addr;\n\tbus_size_t nbytes;\n\tstruct proc *p;\n\tint flags;\n\tint busdmaflags;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tbus_dmamap_t dmam;\n\tbus_addr_t dmaaddr;\n\tint waport;\n\tint ochan = chan & 3;\n\tint error;\n#ifdef __ISADMA_COMPAT\n\tint compat = busdmaflags & BUS_DMA_BUS1;\n\n\tbusdmaflags &= ~BUS_DMA_BUS1;\n#endif /* __ISADMA_COMPAT */\n\n\tif (chan < 0 || chan > 7) {\n\t\tprintf(\"%s: bogus drq %d\\n\", sc->sc_dev.dv_xname, chan);\n\t\tgoto lose;\n\t}\n\n#ifdef ISADMA_DEBUG\n\tprintf(\"isa_dmastart: drq %d, addr %p, nbytes 0x%lx, p %p, \"\n\t    \"flags 0x%x, dmaflags 0x%x\\n\",\n\t    chan, addr, nbytes, p, flags, busdmaflags);\n#endif\n\n\tif (chan & 4) {\n\t\tif (nbytes > (1 << 17) || nbytes & 1 || (u_long)addr & 1) {\n\t\t\tprintf(\"%s: drq %d, nbytes 0x%lx, addr %p\\n\",\n\t\t\t    sc->sc_dev.dv_xname, chan, nbytes, addr);\n\t\t\tgoto lose;\n\t\t}\n\t} else {\n\t\tif (nbytes > (1 << 16)) {\n\t\t\tprintf(\"%s: drq %d, nbytes 0x%lx\\n\",\n\t\t\t    sc->sc_dev.dv_xname, chan, nbytes);\n\t\t\tgoto lose;\n\t\t}\n\t}\n\n\tdmam = sc->sc_dmamaps[chan];\n\tif (dmam == NULL) {\n#ifdef __ISADMA_COMPAT\n\t\tif (compat)\n\t\t\tdmam = sc->sc_dmamaps[chan] = isadma_dmam[chan];\n\t\telse\n#endif /* __ISADMA_COMPAT */\n\t\tpanic(\"isa_dmastart: no DMA map for chan %d\", chan);\n\t}\n\n\terror = bus_dmamap_load(sc->sc_dmat, dmam, addr, nbytes, p,\n\t    busdmaflags);\n\tif (error)\n\t\treturn (error);\n\n#ifdef ISADMA_DEBUG\n\t__asm(\".globl isa_dmastart_afterload ; isa_dmastart_afterload:\");\n#endif\n\n\tif (flags & DMAMODE_READ) {\n\t\tbus_dmamap_sync(sc->sc_dmat, dmam, BUS_DMASYNC_PREREAD);\n\t\tsc->sc_dmareads |= (1 << chan);\n\t} else {\n\t\tbus_dmamap_sync(sc->sc_dmat, dmam, BUS_DMASYNC_PREWRITE);\n\t\tsc->sc_dmareads &= ~(1 << chan);\n\t}\n\n\tdmaaddr = dmam->dm_segs[0].ds_addr;\n\n#ifdef ISADMA_DEBUG\n\tprintf(\"     dmaaddr 0x%lx\\n\", dmaaddr);\n\n\t__asm(\".globl isa_dmastart_aftersync ; isa_dmastart_aftersync:\");\n#endif\n\n\tsc->sc_dmalength[chan] = nbytes;\n\n\tisa_dmamask(sc, chan);\n\tsc->sc_dmafinished &= ~(1 << chan);\n\n\tif ((chan & 4) == 0) {\n\t\t/* set dma channel mode */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, DMA1_MODE,\n\t\t    ochan | dmamode[flags]);\n\n\t\t/* send start address */\n\t\twaport = DMA1_CHN(ochan);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dmapgh,\n\t\t    dmapageport[0][ochan], (dmaaddr >> 16) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport,\n\t\t    dmaaddr & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport,\n\t\t    (dmaaddr >> 8) & 0xff);\n\n\t\t/* send count */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport + 1,\n\t\t    (--nbytes) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport + 1,\n\t\t    (nbytes >> 8) & 0xff);\n\t} else {\n\t\t/* set dma channel mode */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, DMA2_MODE,\n\t\t    ochan | dmamode[flags]);\n\n\t\t/* send start address */\n\t\twaport = DMA2_CHN(ochan);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dmapgh,\n\t\t    dmapageport[1][ochan], (dmaaddr >> 16) & 0xff);\n\t\tdmaaddr >>= 1;\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport,\n\t\t    dmaaddr & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport,\n\t\t    (dmaaddr >> 8) & 0xff);\n\n\t\t/* send count */\n\t\tnbytes >>= 1;\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport + 2,\n\t\t    (--nbytes) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport + 2,\n\t\t    (nbytes >> 8) & 0xff);\n\t}\n\n\tisa_dmaunmask(sc, chan);\n\treturn (0);\n\n lose:\n\tpanic(\"isa_dmastart\");\n}",
          "includes": [
            "#include <sys/malloc.h>",
            "#include <dev/isa/isadmareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dmapageport[2][4] = {\n\t{0x7, 0x3, 0x1, 0x2},\n\t{0xf, 0xb, 0x9, 0xa}\n};",
            "static u_int8_t dmamode[4] = {\n\tDMA37MD_READ | DMA37MD_SINGLE,\n\tDMA37MD_WRITE | DMA37MD_SINGLE,\n\tDMA37MD_READ | DMA37MD_SINGLE | DMA37MD_LOOP,\n\tDMA37MD_WRITE | DMA37MD_SINGLE | DMA37MD_LOOP\n};",
            "static inline void isa_dmaunmask",
            "static inline void isa_dmamask",
            "void *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;",
            "int chan;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/malloc.h>\n#include <dev/isa/isadmareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int dmapageport[2][4] = {\n\t{0x7, 0x3, 0x1, 0x2},\n\t{0xf, 0xb, 0x9, 0xa}\n};\nstatic u_int8_t dmamode[4] = {\n\tDMA37MD_READ | DMA37MD_SINGLE,\n\tDMA37MD_WRITE | DMA37MD_SINGLE,\n\tDMA37MD_READ | DMA37MD_SINGLE | DMA37MD_LOOP,\n\tDMA37MD_WRITE | DMA37MD_SINGLE | DMA37MD_LOOP\n};\nstatic inline void isa_dmaunmask;\nstatic inline void isa_dmamask;\nvoid *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;\nint chan;\nint flags;\n\nint\nisa_dmastart(isadev, chan, addr, nbytes, p, flags, busdmaflags)\n\tstruct device *isadev;\n\tint chan;\n\tvoid *addr;\n\tbus_size_t nbytes;\n\tstruct proc *p;\n\tint flags;\n\tint busdmaflags;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tbus_dmamap_t dmam;\n\tbus_addr_t dmaaddr;\n\tint waport;\n\tint ochan = chan & 3;\n\tint error;\n#ifdef __ISADMA_COMPAT\n\tint compat = busdmaflags & BUS_DMA_BUS1;\n\n\tbusdmaflags &= ~BUS_DMA_BUS1;\n#endif /* __ISADMA_COMPAT */\n\n\tif (chan < 0 || chan > 7) {\n\t\tprintf(\"%s: bogus drq %d\\n\", sc->sc_dev.dv_xname, chan);\n\t\tgoto lose;\n\t}\n\n#ifdef ISADMA_DEBUG\n\tprintf(\"isa_dmastart: drq %d, addr %p, nbytes 0x%lx, p %p, \"\n\t    \"flags 0x%x, dmaflags 0x%x\\n\",\n\t    chan, addr, nbytes, p, flags, busdmaflags);\n#endif\n\n\tif (chan & 4) {\n\t\tif (nbytes > (1 << 17) || nbytes & 1 || (u_long)addr & 1) {\n\t\t\tprintf(\"%s: drq %d, nbytes 0x%lx, addr %p\\n\",\n\t\t\t    sc->sc_dev.dv_xname, chan, nbytes, addr);\n\t\t\tgoto lose;\n\t\t}\n\t} else {\n\t\tif (nbytes > (1 << 16)) {\n\t\t\tprintf(\"%s: drq %d, nbytes 0x%lx\\n\",\n\t\t\t    sc->sc_dev.dv_xname, chan, nbytes);\n\t\t\tgoto lose;\n\t\t}\n\t}\n\n\tdmam = sc->sc_dmamaps[chan];\n\tif (dmam == NULL) {\n#ifdef __ISADMA_COMPAT\n\t\tif (compat)\n\t\t\tdmam = sc->sc_dmamaps[chan] = isadma_dmam[chan];\n\t\telse\n#endif /* __ISADMA_COMPAT */\n\t\tpanic(\"isa_dmastart: no DMA map for chan %d\", chan);\n\t}\n\n\terror = bus_dmamap_load(sc->sc_dmat, dmam, addr, nbytes, p,\n\t    busdmaflags);\n\tif (error)\n\t\treturn (error);\n\n#ifdef ISADMA_DEBUG\n\t__asm(\".globl isa_dmastart_afterload ; isa_dmastart_afterload:\");\n#endif\n\n\tif (flags & DMAMODE_READ) {\n\t\tbus_dmamap_sync(sc->sc_dmat, dmam, BUS_DMASYNC_PREREAD);\n\t\tsc->sc_dmareads |= (1 << chan);\n\t} else {\n\t\tbus_dmamap_sync(sc->sc_dmat, dmam, BUS_DMASYNC_PREWRITE);\n\t\tsc->sc_dmareads &= ~(1 << chan);\n\t}\n\n\tdmaaddr = dmam->dm_segs[0].ds_addr;\n\n#ifdef ISADMA_DEBUG\n\tprintf(\"     dmaaddr 0x%lx\\n\", dmaaddr);\n\n\t__asm(\".globl isa_dmastart_aftersync ; isa_dmastart_aftersync:\");\n#endif\n\n\tsc->sc_dmalength[chan] = nbytes;\n\n\tisa_dmamask(sc, chan);\n\tsc->sc_dmafinished &= ~(1 << chan);\n\n\tif ((chan & 4) == 0) {\n\t\t/* set dma channel mode */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, DMA1_MODE,\n\t\t    ochan | dmamode[flags]);\n\n\t\t/* send start address */\n\t\twaport = DMA1_CHN(ochan);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dmapgh,\n\t\t    dmapageport[0][ochan], (dmaaddr >> 16) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport,\n\t\t    dmaaddr & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport,\n\t\t    (dmaaddr >> 8) & 0xff);\n\n\t\t/* send count */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport + 1,\n\t\t    (--nbytes) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport + 1,\n\t\t    (nbytes >> 8) & 0xff);\n\t} else {\n\t\t/* set dma channel mode */\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, DMA2_MODE,\n\t\t    ochan | dmamode[flags]);\n\n\t\t/* send start address */\n\t\twaport = DMA2_CHN(ochan);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dmapgh,\n\t\t    dmapageport[1][ochan], (dmaaddr >> 16) & 0xff);\n\t\tdmaaddr >>= 1;\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport,\n\t\t    dmaaddr & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport,\n\t\t    (dmaaddr >> 8) & 0xff);\n\n\t\t/* send count */\n\t\tnbytes >>= 1;\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport + 2,\n\t\t    (--nbytes) & 0xff);\n\t\tbus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport + 2,\n\t\t    (nbytes >> 8) & 0xff);\n\t}\n\n\tisa_dmaunmask(sc, chan);\n\treturn (0);\n\n lose:\n\tpanic(\"isa_dmastart\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "0"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_DMA_CONTROL"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "convert_to_16bit",
          "args": [
            "gusaddr"
          ],
          "line": 1285
        },
        "resolved": true,
        "details": {
          "function_name": "convert_to_16bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "1979-1991",
          "snippet": "u_long\nconvert_to_16bit(address)\n\tu_long address;\n{\n\tu_long old_address;\n\n\told_address = address;\n\taddress >>= 1;\n\taddress &= 0x0001ffffL;\n\taddress |= (old_address & 0x000c0000L);\n\n\treturn (address);\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_long\nconvert_to_16bit(address)\n\tu_long address;\n{\n\tu_long old_address;\n\n\told_address = address;\n\taddress >>= 1;\n\taddress &= 0x0001ffffL;\n\taddress |= (old_address & 0x000c0000L);\n\n\treturn (address);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DMAPRINTF",
          "args": [
            "(\"gusdmaout flags=%x scflags=%x\\n\", flags, sc->sc_flags)"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ngusdmaout(sc, flags, gusaddr, buffaddr, length)\n\tstruct gus_softc *sc;\n\tint flags, length;\n\tu_long gusaddr;\n\tcaddr_t buffaddr;\n{\n\tunsigned char c = (unsigned char) flags;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\n\tDMAPRINTF((\"gusdmaout flags=%x scflags=%x\\n\", flags, sc->sc_flags));\n\n\tsc->sc_gusaddr = gusaddr;\n\n\t/*\n\t * If we're using a 16 bit DMA channel, we have to jump through some\n\t * extra hoops; this includes translating the DRAM address a bit\n\t */\n\n\tif (sc->sc_drq >= 4) {\n\t\tc |= GUSMASK_DMA_WIDTH;\n\t\tgusaddr = convert_to_16bit(gusaddr);\n\t}\n\n\t/*\n\t * Add flag bits that we always set - fast DMA, enable IRQ\n\t */\n\n\tc |= GUSMASK_DMA_ENABLE | GUSMASK_DMA_R0 | GUSMASK_DMA_IRQ;\n\n\t/*\n\t * Make sure the GUS _isn't_ setup for DMA\n\t */\n\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0);\n\n\t/*\n\t * Tell the PC DMA controller to start doing DMA\n\t */\n\n\tsc->sc_dmaoutaddr = (u_char *) buffaddr;\n\tsc->sc_dmaoutcnt = length;\n \tisa_dmastart(sc->sc_dev.dv_parent, sc->sc_drq, buffaddr, length,\n \t    NULL, DMAMODE_WRITE, BUS_DMA_NOWAIT);\n\n\t/*\n\t * Set up DMA address - use the upper 16 bits ONLY\n\t */\n\n\tsc->sc_flags |= GUS_DMAOUT_ACTIVE;\n\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_START);\n \tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, (int) (gusaddr >> 4));\n\n \t/*\n \t * Tell the GUS to start doing DMA\n \t */\n\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, c);\n\n\t/*\n\t * XXX If we don't finish in one second, give up...\n\t */\n\tuntimeout(gus_dmaout_timeout, sc); /* flush old one, if there is one */\n\ttimeout(gus_dmaout_timeout, sc, hz);\n}"
  },
  {
    "function_name": "gus_continue_playing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "1162-1257",
    "snippet": "int\ngus_continue_playing(sc, voice)\n\tstruct gus_softc *sc;\n\tint voice;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\n\t/*\n\t * stop this voice from interrupting while we work.\n\t */\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].voccntl & ~(GUSMASK_VOICE_IRQ));\n\n\t/* \n\t * update playbuf to point to the buffer the hardware just started\n\t * playing\n\t */\n\tsc->sc_playbuf = ++sc->sc_playbuf % sc->sc_nbufs;\n    \n\t/*\n\t * account for buffer just finished\n\t */\n\tif (--sc->sc_bufcnt == 0) {\n\t\tDPRINTF((\"gus: bufcnt 0 on continuing voice?\\n\"));\n\t}\n\tif (sc->sc_playbuf == sc->sc_dmabuf && (sc->sc_flags & GUS_LOCKED)) {\n\t\tprintf(\"%s: continue into active dmabuf?\\n\", sc->sc_dev.dv_xname);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Select the end of the buffer based on the currently active\n\t * buffer, [plus extra contiguous buffers (if ready)].\n\t */\n\n\t/* \n\t * set endpoint at end of buffer we just started playing.\n\t *\n\t * The total gets -1 because end addrs are one less than you might\n\t * think (the end_addr is the address of the last sample to play)\n\t */\n\tgus_set_endaddr(sc, voice, GUS_MEM_OFFSET +\n\t\t\tsc->sc_chanblocksize * (sc->sc_playbuf + 1) - 1);\n\n\tif (sc->sc_bufcnt < 2) {\n\t\t/*\n\t\t * Clear out the loop and roll flags, and rotate the currently\n\t\t * playing buffer.  That way, if we don't manage to get more\n\t\t * data before this buffer finishes, we'll just stop.\n\t\t */\n\t\tsc->sc_voc[voice].voccntl &= ~GUSMASK_LOOP_ENABLE;\n\t\tsc->sc_voc[voice].volcntl &= ~GUSMASK_VOICE_ROLL;\n\t\tplaystats[playcntr].vaction = 0;\n\t} else {\n\t\t/*\n\t\t * We have some buffers to play.  set LOOP if we're on the\n\t\t * last buffer in the ring, otherwise set ROLL.\n\t\t */\n\t\tif (sc->sc_playbuf == sc->sc_nbufs - 1) {\n\t\t\tsc->sc_voc[voice].voccntl |= GUSMASK_LOOP_ENABLE;\n\t\t\tsc->sc_voc[voice].volcntl &= ~GUSMASK_VOICE_ROLL;\n\t\t\tplaystats[playcntr].vaction = 1;\n\t\t} else {\n\t\t\tsc->sc_voc[voice].voccntl &= ~GUSMASK_LOOP_ENABLE;\n\t\t\tsc->sc_voc[voice].volcntl |= GUSMASK_VOICE_ROLL;\n\t\t\tplaystats[playcntr].vaction = 2;\n\t\t}\n\t}\n#ifdef GUSPLAYDEBUG\n\tif (gusstats) {\n\t\tmicrotime(&playstats[playcntr].tv);\n\t\tplaystats[playcntr].curaddr = gus_get_curaddr(sc, voice);\n\n\t\tplaystats[playcntr].voccntl = sc->sc_voc[voice].voccntl;\n\t\tplaystats[playcntr].volcntl = sc->sc_voc[voice].volcntl;\n\t\tplaystats[playcntr].endaddr = sc->sc_voc[voice].end_addr;\n\t\tplaystats[playcntr].playbuf = sc->sc_playbuf;\n\t\tplaystats[playcntr].dmabuf = sc->sc_dmabuf;\n\t\tplaystats[playcntr].bufcnt = sc->sc_bufcnt;\n\t\tplaycntr = ++playcntr % NDMARECS;\n\t}\n#endif\n\n\t/*\n\t * (re-)set voice parameters.  This will reenable interrupts from this\n\t * voice.\n\t */\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].voccntl);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].volcntl);\n\treturn 0;\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define NDMARECS 2048",
      "#define GUSPLAYDEBUG\t/*XXX*/"
    ],
    "globals_used": [
      "struct playcont {\n\tstruct timeval tv;\n\tu_int playbuf;\n\tu_int dmabuf;\n\tu_char bufcnt;\n\tu_char vaction;\n\tu_char voccntl;\n\tu_char volcntl;\n\tu_long curaddr;\n\tu_long endaddr;\n} playstats[NDMARECS];",
      "int playcntr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "sc->sc_voc[voice].volcntl"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_VOLUME_CONTROL"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "sc->sc_voc[voice].voccntl"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_VOICE_CNTL"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gus_get_curaddr",
          "args": [
            "sc",
            "voice"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "gus_get_curaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "1949-1971",
          "snippet": "u_long\ngus_get_curaddr(sc, voice)\n\tstruct gus_softc *sc;\n\tint voice;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tu_long addr;\n\n\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, (unsigned char) voice);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_HIGH|GUSREG_READ);\n\taddr = (bus_space_read_2(iot, ioh2, GUS_DATA_LOW) & 0x1fff) << 7;\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_LOW|GUSREG_READ);\n\taddr |= (bus_space_read_2(iot, ioh2, GUS_DATA_LOW) >> 9L) & 0x7f;\n\n\tif (sc->sc_voc[voice].voccntl & GUSMASK_DATA_SIZE16)\n\t    addr = (addr & 0xc0000) | ((addr & 0x1ffff) << 1); /* undo 16-bit change */\n\tDPRINTF((\"gus voice %d curaddr %ld end_addr %ld\\n\",\n\t\t voice, addr, sc->sc_voc[voice].end_addr));\n\t/* XXX sanity check the address? */\n\n\treturn(addr);\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_long\ngus_get_curaddr(sc, voice)\n\tstruct gus_softc *sc;\n\tint voice;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tu_long addr;\n\n\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, (unsigned char) voice);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_HIGH|GUSREG_READ);\n\taddr = (bus_space_read_2(iot, ioh2, GUS_DATA_LOW) & 0x1fff) << 7;\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_LOW|GUSREG_READ);\n\taddr |= (bus_space_read_2(iot, ioh2, GUS_DATA_LOW) >> 9L) & 0x7f;\n\n\tif (sc->sc_voc[voice].voccntl & GUSMASK_DATA_SIZE16)\n\t    addr = (addr & 0xc0000) | ((addr & 0x1ffff) << 1); /* undo 16-bit change */\n\tDPRINTF((\"gus voice %d curaddr %ld end_addr %ld\\n\",\n\t\t voice, addr, sc->sc_voc[voice].end_addr));\n\t/* XXX sanity check the address? */\n\n\treturn(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "microtime",
          "args": [
            "&playstats[playcntr].tv"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gus_set_endaddr",
          "args": [
            "sc",
            "voice",
            "GUS_MEM_OFFSET +\n\t\t\tsc->sc_chanblocksize * (sc->sc_playbuf + 1) - 1"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "gus_set_endaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "1898-1917",
          "snippet": "void\ngus_set_endaddr(sc, voice, addr)\n\tstruct gus_softc *sc;\n\tint voice;\n\tu_long addr;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\n\tsc->sc_voc[voice].end_addr = addr;\n\n\tif (sc->sc_voc[voice].voccntl & GUSMASK_DATA_SIZE16)\n\t\taddr = convert_to_16bit(addr);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_END_ADDR_HIGH);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_HIGH(addr));\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_END_ADDR_LOW);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_LOW(addr));\n\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ngus_set_endaddr(sc, voice, addr)\n\tstruct gus_softc *sc;\n\tint voice;\n\tu_long addr;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\n\tsc->sc_voc[voice].end_addr = addr;\n\n\tif (sc->sc_voc[voice].voccntl & GUSMASK_DATA_SIZE16)\n\t\taddr = convert_to_16bit(addr);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_END_ADDR_HIGH);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_HIGH(addr));\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_END_ADDR_LOW);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_LOW(addr));\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: continue into active dmabuf?\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"gus: bufcnt 0 on continuing voice?\\n\")"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "sc->sc_voc[voice].voccntl & ~(GUSMASK_VOICE_IRQ)"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_VOICE_CNTL"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define NDMARECS 2048\n#define GUSPLAYDEBUG\t/*XXX*/\n\nstruct playcont {\n\tstruct timeval tv;\n\tu_int playbuf;\n\tu_int dmabuf;\n\tu_char bufcnt;\n\tu_char vaction;\n\tu_char voccntl;\n\tu_char volcntl;\n\tu_long curaddr;\n\tu_long endaddr;\n} playstats[NDMARECS];\nint playcntr;\n\nint\ngus_continue_playing(sc, voice)\n\tstruct gus_softc *sc;\n\tint voice;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\n\t/*\n\t * stop this voice from interrupting while we work.\n\t */\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].voccntl & ~(GUSMASK_VOICE_IRQ));\n\n\t/* \n\t * update playbuf to point to the buffer the hardware just started\n\t * playing\n\t */\n\tsc->sc_playbuf = ++sc->sc_playbuf % sc->sc_nbufs;\n    \n\t/*\n\t * account for buffer just finished\n\t */\n\tif (--sc->sc_bufcnt == 0) {\n\t\tDPRINTF((\"gus: bufcnt 0 on continuing voice?\\n\"));\n\t}\n\tif (sc->sc_playbuf == sc->sc_dmabuf && (sc->sc_flags & GUS_LOCKED)) {\n\t\tprintf(\"%s: continue into active dmabuf?\\n\", sc->sc_dev.dv_xname);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Select the end of the buffer based on the currently active\n\t * buffer, [plus extra contiguous buffers (if ready)].\n\t */\n\n\t/* \n\t * set endpoint at end of buffer we just started playing.\n\t *\n\t * The total gets -1 because end addrs are one less than you might\n\t * think (the end_addr is the address of the last sample to play)\n\t */\n\tgus_set_endaddr(sc, voice, GUS_MEM_OFFSET +\n\t\t\tsc->sc_chanblocksize * (sc->sc_playbuf + 1) - 1);\n\n\tif (sc->sc_bufcnt < 2) {\n\t\t/*\n\t\t * Clear out the loop and roll flags, and rotate the currently\n\t\t * playing buffer.  That way, if we don't manage to get more\n\t\t * data before this buffer finishes, we'll just stop.\n\t\t */\n\t\tsc->sc_voc[voice].voccntl &= ~GUSMASK_LOOP_ENABLE;\n\t\tsc->sc_voc[voice].volcntl &= ~GUSMASK_VOICE_ROLL;\n\t\tplaystats[playcntr].vaction = 0;\n\t} else {\n\t\t/*\n\t\t * We have some buffers to play.  set LOOP if we're on the\n\t\t * last buffer in the ring, otherwise set ROLL.\n\t\t */\n\t\tif (sc->sc_playbuf == sc->sc_nbufs - 1) {\n\t\t\tsc->sc_voc[voice].voccntl |= GUSMASK_LOOP_ENABLE;\n\t\t\tsc->sc_voc[voice].volcntl &= ~GUSMASK_VOICE_ROLL;\n\t\t\tplaystats[playcntr].vaction = 1;\n\t\t} else {\n\t\t\tsc->sc_voc[voice].voccntl &= ~GUSMASK_LOOP_ENABLE;\n\t\t\tsc->sc_voc[voice].volcntl |= GUSMASK_VOICE_ROLL;\n\t\t\tplaystats[playcntr].vaction = 2;\n\t\t}\n\t}\n#ifdef GUSPLAYDEBUG\n\tif (gusstats) {\n\t\tmicrotime(&playstats[playcntr].tv);\n\t\tplaystats[playcntr].curaddr = gus_get_curaddr(sc, voice);\n\n\t\tplaystats[playcntr].voccntl = sc->sc_voc[voice].voccntl;\n\t\tplaystats[playcntr].volcntl = sc->sc_voc[voice].volcntl;\n\t\tplaystats[playcntr].endaddr = sc->sc_voc[voice].end_addr;\n\t\tplaystats[playcntr].playbuf = sc->sc_playbuf;\n\t\tplaystats[playcntr].dmabuf = sc->sc_dmabuf;\n\t\tplaystats[playcntr].bufcnt = sc->sc_bufcnt;\n\t\tplaycntr = ++playcntr % NDMARECS;\n\t}\n#endif\n\n\t/*\n\t * (re-)set voice parameters.  This will reenable interrupts from this\n\t * voice.\n\t */\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].voccntl);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].volcntl);\n\treturn 0;\n}"
  },
  {
    "function_name": "gus_start_playing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "1082-1160",
    "snippet": "void\ngus_start_playing(sc, bufno)\n\tstruct gus_softc *sc;\n\tint bufno;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\t/*\n\t * Start the voices playing, with buffer BUFNO.\n\t */\n\n\t/*\n\t * Loop or roll if we have buffers ready.\n\t */\n\n\tif (sc->sc_bufcnt == 1) {\n\t\tsc->sc_voc[GUS_VOICE_LEFT].voccntl &= ~(GUSMASK_LOOP_ENABLE);\n\t\tsc->sc_voc[GUS_VOICE_LEFT].volcntl &= ~(GUSMASK_VOICE_ROLL);\n\t} else {\n\t\tif (bufno == sc->sc_nbufs - 1) {\n\t\t\tsc->sc_voc[GUS_VOICE_LEFT].voccntl |= GUSMASK_LOOP_ENABLE;\n\t\t\tsc->sc_voc[GUS_VOICE_LEFT].volcntl &= ~(GUSMASK_VOICE_ROLL);\n\t\t} else {\n\t\t\tsc->sc_voc[GUS_VOICE_LEFT].voccntl &= ~GUSMASK_LOOP_ENABLE;\n\t\t\tsc->sc_voc[GUS_VOICE_LEFT].volcntl |= GUSMASK_VOICE_ROLL;\n\t\t}\n\t}\n\n\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, GUS_VOICE_LEFT);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_LEFT].voccntl);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_LEFT].volcntl);\n\n\tsc->sc_voc[GUS_VOICE_LEFT].current_addr =\n\t\tGUS_MEM_OFFSET + sc->sc_chanblocksize * bufno;\n\tsc->sc_voc[GUS_VOICE_LEFT].end_addr =\n\t\tsc->sc_voc[GUS_VOICE_LEFT].current_addr + sc->sc_chanblocksize - 1;\n\tsc->sc_voc[GUS_VOICE_RIGHT].current_addr =\n\t\tsc->sc_voc[GUS_VOICE_LEFT].current_addr + \n\t\t(gus_dostereo && sc->sc_channels == 2 ? GUS_LEFT_RIGHT_OFFSET : 0);\n\t/*\n\t * set up right channel to just loop forever, no interrupts,\n\t * starting at the buffer we just filled.  We'll feed it data\n\t * at the same time as left channel.\n\t */\n\tsc->sc_voc[GUS_VOICE_RIGHT].voccntl |= GUSMASK_LOOP_ENABLE;\n\tsc->sc_voc[GUS_VOICE_RIGHT].volcntl &= ~(GUSMASK_VOICE_ROLL);\n\n#ifdef GUSPLAYDEBUG\n\tif (gusstats) {\n\t\tmicrotime(&playstats[playcntr].tv);\n\t\tplaystats[playcntr].curaddr = sc->sc_voc[GUS_VOICE_LEFT].current_addr;\n\n\t\tplaystats[playcntr].voccntl = sc->sc_voc[GUS_VOICE_LEFT].voccntl;\n\t\tplaystats[playcntr].volcntl = sc->sc_voc[GUS_VOICE_LEFT].volcntl;\n\t\tplaystats[playcntr].endaddr = sc->sc_voc[GUS_VOICE_LEFT].end_addr;\n\t\tplaystats[playcntr].playbuf = bufno;\n\t\tplaystats[playcntr].dmabuf = sc->sc_dmabuf;\n\t\tplaystats[playcntr].bufcnt = sc->sc_bufcnt;\n\t\tplaystats[playcntr].vaction = 5;\n\t\tplaycntr = ++playcntr % NDMARECS;\n\t}\n#endif\n\n\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, GUS_VOICE_RIGHT);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_RIGHT].voccntl);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_RIGHT].volcntl);\n\n\tgus_start_voice(sc, GUS_VOICE_RIGHT, 0);\n\tgus_start_voice(sc, GUS_VOICE_LEFT, 1);\n\tif (sc->sc_playbuf == -1)\n\t\t/* mark start of playing */\n\t\tsc->sc_playbuf = bufno;\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define NDMARECS 2048",
      "#define GUSPLAYDEBUG\t/*XXX*/"
    ],
    "globals_used": [
      "int\tgus_dostereo = 1;",
      "struct playcont {\n\tstruct timeval tv;\n\tu_int playbuf;\n\tu_int dmabuf;\n\tu_char bufcnt;\n\tu_char vaction;\n\tu_char voccntl;\n\tu_char volcntl;\n\tu_long curaddr;\n\tu_long endaddr;\n} playstats[NDMARECS];",
      "int playcntr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gus_start_voice",
          "args": [
            "sc",
            "GUS_VOICE_LEFT",
            "1"
          ],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "gus_start_voice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "1338-1429",
          "snippet": "void\ngus_start_voice(sc, voice, intrs)\n\tstruct gus_softc *sc;\n\tint voice;\n\tint intrs;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tu_long start;\n\tu_long current;\n\tu_long end;\n\n\t/*\n\t * Pick all the values for the voice out of the gus_voice struct\n\t * and use those to program the voice\n\t */\n\n \tstart = sc->sc_voc[voice].start_addr;\n \tcurrent = sc->sc_voc[voice].current_addr;\n \tend = sc->sc_voc[voice].end_addr;\n\n \t/*\n\t * If we're using 16 bit data, mangle the addresses a bit\n\t */\n\n\tif (sc->sc_voc[voice].voccntl & GUSMASK_DATA_SIZE16) {\n\t        /* -1 on start so that we get onto sample boundary--other\n\t\t   code always sets it for 1-byte rollover protection */\n\t\tstart = convert_to_16bit(start-1);\n\t\tcurrent = convert_to_16bit(current);\n\t\tend = convert_to_16bit(end);\n\t}\n\n\t/*\n\t * Select the voice we want to use, and program the data addresses\n\t */\n\n\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, (unsigned char) voice);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_START_ADDR_HIGH);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_HIGH(start));\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_START_ADDR_LOW);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_LOW(start));\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_HIGH);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_HIGH(current));\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_LOW);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_LOW(current));\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_END_ADDR_HIGH);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_HIGH(end));\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_END_ADDR_LOW);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_LOW(end));\n\n\t/*\n\t * (maybe) enable interrupts, disable voice stopping\n\t */\n\n\tif (intrs) {\n\t\tsc->sc_flags |= GUS_PLAYING; /* playing is about to start */\n\t\tsc->sc_voc[voice].voccntl |= GUSMASK_VOICE_IRQ;\n\t\tDMAPRINTF((\"gus voice playing=%x\\n\", sc->sc_flags));\n\t} else\n\t\tsc->sc_voc[voice].voccntl &= ~GUSMASK_VOICE_IRQ;\n\tsc->sc_voc[voice].voccntl &= ~(GUSMASK_VOICE_STOPPED |\n\t\tGUSMASK_STOP_VOICE);\n\n\t/*\n\t * Tell the GUS about it.  Note that we're doing volume ramping here\n\t * from 0 up to the set volume to help reduce clicks.\n\t */\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_START_VOLUME);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_END_VOLUME);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].current_volume >> 4);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_VOLUME);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x00);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_RATE);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 63);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].voccntl);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);\n\tdelay(50);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].voccntl);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);\n\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ngus_start_voice(sc, voice, intrs)\n\tstruct gus_softc *sc;\n\tint voice;\n\tint intrs;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tu_long start;\n\tu_long current;\n\tu_long end;\n\n\t/*\n\t * Pick all the values for the voice out of the gus_voice struct\n\t * and use those to program the voice\n\t */\n\n \tstart = sc->sc_voc[voice].start_addr;\n \tcurrent = sc->sc_voc[voice].current_addr;\n \tend = sc->sc_voc[voice].end_addr;\n\n \t/*\n\t * If we're using 16 bit data, mangle the addresses a bit\n\t */\n\n\tif (sc->sc_voc[voice].voccntl & GUSMASK_DATA_SIZE16) {\n\t        /* -1 on start so that we get onto sample boundary--other\n\t\t   code always sets it for 1-byte rollover protection */\n\t\tstart = convert_to_16bit(start-1);\n\t\tcurrent = convert_to_16bit(current);\n\t\tend = convert_to_16bit(end);\n\t}\n\n\t/*\n\t * Select the voice we want to use, and program the data addresses\n\t */\n\n\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, (unsigned char) voice);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_START_ADDR_HIGH);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_HIGH(start));\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_START_ADDR_LOW);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_LOW(start));\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_HIGH);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_HIGH(current));\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_LOW);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_LOW(current));\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_END_ADDR_HIGH);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_HIGH(end));\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_END_ADDR_LOW);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_LOW(end));\n\n\t/*\n\t * (maybe) enable interrupts, disable voice stopping\n\t */\n\n\tif (intrs) {\n\t\tsc->sc_flags |= GUS_PLAYING; /* playing is about to start */\n\t\tsc->sc_voc[voice].voccntl |= GUSMASK_VOICE_IRQ;\n\t\tDMAPRINTF((\"gus voice playing=%x\\n\", sc->sc_flags));\n\t} else\n\t\tsc->sc_voc[voice].voccntl &= ~GUSMASK_VOICE_IRQ;\n\tsc->sc_voc[voice].voccntl &= ~(GUSMASK_VOICE_STOPPED |\n\t\tGUSMASK_STOP_VOICE);\n\n\t/*\n\t * Tell the GUS about it.  Note that we're doing volume ramping here\n\t * from 0 up to the set volume to help reduce clicks.\n\t */\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_START_VOLUME);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_END_VOLUME);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].current_volume >> 4);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_VOLUME);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x00);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_RATE);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 63);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].voccntl);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);\n\tdelay(50);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].voccntl);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "sc->sc_voc[GUS_VOICE_RIGHT].volcntl"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_VOLUME_CONTROL"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "sc->sc_voc[GUS_VOICE_RIGHT].voccntl"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_VOICE_CNTL"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_VOICE_SELECT",
            "GUS_VOICE_RIGHT"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "microtime",
          "args": [
            "&playstats[playcntr].tv"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "sc->sc_voc[GUS_VOICE_LEFT].volcntl"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_VOLUME_CONTROL"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "sc->sc_voc[GUS_VOICE_LEFT].voccntl"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_VOICE_CNTL"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_VOICE_SELECT",
            "GUS_VOICE_LEFT"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define NDMARECS 2048\n#define GUSPLAYDEBUG\t/*XXX*/\n\nint\tgus_dostereo = 1;\nstruct playcont {\n\tstruct timeval tv;\n\tu_int playbuf;\n\tu_int dmabuf;\n\tu_char bufcnt;\n\tu_char vaction;\n\tu_char voccntl;\n\tu_char volcntl;\n\tu_long curaddr;\n\tu_long endaddr;\n} playstats[NDMARECS];\nint playcntr;\n\nvoid\ngus_start_playing(sc, bufno)\n\tstruct gus_softc *sc;\n\tint bufno;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\t/*\n\t * Start the voices playing, with buffer BUFNO.\n\t */\n\n\t/*\n\t * Loop or roll if we have buffers ready.\n\t */\n\n\tif (sc->sc_bufcnt == 1) {\n\t\tsc->sc_voc[GUS_VOICE_LEFT].voccntl &= ~(GUSMASK_LOOP_ENABLE);\n\t\tsc->sc_voc[GUS_VOICE_LEFT].volcntl &= ~(GUSMASK_VOICE_ROLL);\n\t} else {\n\t\tif (bufno == sc->sc_nbufs - 1) {\n\t\t\tsc->sc_voc[GUS_VOICE_LEFT].voccntl |= GUSMASK_LOOP_ENABLE;\n\t\t\tsc->sc_voc[GUS_VOICE_LEFT].volcntl &= ~(GUSMASK_VOICE_ROLL);\n\t\t} else {\n\t\t\tsc->sc_voc[GUS_VOICE_LEFT].voccntl &= ~GUSMASK_LOOP_ENABLE;\n\t\t\tsc->sc_voc[GUS_VOICE_LEFT].volcntl |= GUSMASK_VOICE_ROLL;\n\t\t}\n\t}\n\n\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, GUS_VOICE_LEFT);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_LEFT].voccntl);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_LEFT].volcntl);\n\n\tsc->sc_voc[GUS_VOICE_LEFT].current_addr =\n\t\tGUS_MEM_OFFSET + sc->sc_chanblocksize * bufno;\n\tsc->sc_voc[GUS_VOICE_LEFT].end_addr =\n\t\tsc->sc_voc[GUS_VOICE_LEFT].current_addr + sc->sc_chanblocksize - 1;\n\tsc->sc_voc[GUS_VOICE_RIGHT].current_addr =\n\t\tsc->sc_voc[GUS_VOICE_LEFT].current_addr + \n\t\t(gus_dostereo && sc->sc_channels == 2 ? GUS_LEFT_RIGHT_OFFSET : 0);\n\t/*\n\t * set up right channel to just loop forever, no interrupts,\n\t * starting at the buffer we just filled.  We'll feed it data\n\t * at the same time as left channel.\n\t */\n\tsc->sc_voc[GUS_VOICE_RIGHT].voccntl |= GUSMASK_LOOP_ENABLE;\n\tsc->sc_voc[GUS_VOICE_RIGHT].volcntl &= ~(GUSMASK_VOICE_ROLL);\n\n#ifdef GUSPLAYDEBUG\n\tif (gusstats) {\n\t\tmicrotime(&playstats[playcntr].tv);\n\t\tplaystats[playcntr].curaddr = sc->sc_voc[GUS_VOICE_LEFT].current_addr;\n\n\t\tplaystats[playcntr].voccntl = sc->sc_voc[GUS_VOICE_LEFT].voccntl;\n\t\tplaystats[playcntr].volcntl = sc->sc_voc[GUS_VOICE_LEFT].volcntl;\n\t\tplaystats[playcntr].endaddr = sc->sc_voc[GUS_VOICE_LEFT].end_addr;\n\t\tplaystats[playcntr].playbuf = bufno;\n\t\tplaystats[playcntr].dmabuf = sc->sc_dmabuf;\n\t\tplaystats[playcntr].bufcnt = sc->sc_bufcnt;\n\t\tplaystats[playcntr].vaction = 5;\n\t\tplaycntr = ++playcntr % NDMARECS;\n\t}\n#endif\n\n\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, GUS_VOICE_RIGHT);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_RIGHT].voccntl);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_RIGHT].volcntl);\n\n\tgus_start_voice(sc, GUS_VOICE_RIGHT, 0);\n\tgus_start_voice(sc, GUS_VOICE_LEFT, 1);\n\tif (sc->sc_playbuf == -1)\n\t\t/* mark start of playing */\n\t\tsc->sc_playbuf = bufno;\n}"
  },
  {
    "function_name": "gus_voice_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "933-1080",
    "snippet": "int\ngus_voice_intr(sc)\n\tstruct gus_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tint ignore = 0, voice, rval = 0;\n\tunsigned char intr, status;\n\n\t/*\n\t * The point of this may not be obvious at first.  A voice can\n\t * interrupt more than once; according to the GUS SDK we are supposed\n\t * to ignore multiple interrupts for the same voice.\n\t */\n\n\twhile(1) {\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_IRQ_STATUS);\n\t\tintr = bus_space_read_1(iot, ioh2, GUS_DATA_HIGH);\n\n\t\tif ((intr & (GUSMASK_WIRQ_VOLUME | GUSMASK_WIRQ_VOICE))\n\t\t\t== (GUSMASK_WIRQ_VOLUME | GUSMASK_WIRQ_VOICE))\n\t\t\t/*\n\t\t\t * No more interrupts, time to return\n\t\t\t */\n\t\t \treturn rval;\n\n\t\tif ((intr & GUSMASK_WIRQ_VOICE) == 0) {\n\n\t\t    /*\n\t\t     * We've got a voice interrupt.  Ignore previous\n\t\t     * interrupts by the same voice.\n\t\t     */\n\n\t\t    rval = 1;\n\t\t    voice = intr & GUSMASK_WIRQ_VOICEMASK;\n\n\t\t    if ((1 << voice) & ignore)\n\t\t\tbreak;\n\n\t\t    ignore |= 1 << voice;\n\n\t\t    /*\n\t\t     * If the voice is stopped, then force it to stop\n\t\t     * (this stops it from continuously generating IRQs)\n\t\t     */\n\n\t\t    SELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL+0x80);\n\t\t    status = bus_space_read_1(iot, ioh2, GUS_DATA_HIGH);\n\t\t    if (status & GUSMASK_VOICE_STOPPED) {\n\t\t\tif (voice != GUS_VOICE_LEFT) {\n\t\t\t    DMAPRINTF((\"%s: spurious voice %d stop?\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, voice));\n\t\t\t    gus_stop_voice(sc, voice, 0);\n\t\t\t    continue;\n\t\t\t}\n\t\t\tgus_stop_voice(sc, voice, 1);\n\t\t\t/* also kill right voice */\n\t\t\tgus_stop_voice(sc, GUS_VOICE_RIGHT, 0);\n\t\t\tsc->sc_bufcnt--; /* it finished a buffer */\n\t\t\tif (sc->sc_bufcnt > 0) {\n\t\t\t    /*\n\t\t\t     * probably a race to get here: the voice\n\t\t\t     * stopped while the DMA code was just trying to\n\t\t\t     * get the next buffer in place. \n\t\t\t     * Start the voice again.\n\t\t\t     */\n\t\t\t    printf(\"%s: stopped voice not drained? (%x)\\n\",\n\t\t\t\t   sc->sc_dev.dv_xname, sc->sc_bufcnt);\n\t\t\t    gus_falsestops++;\n\n\t\t\t    sc->sc_playbuf = ++sc->sc_playbuf % sc->sc_nbufs;\n\t\t\t    gus_start_playing(sc, sc->sc_playbuf);\n\t\t\t} else if (sc->sc_bufcnt < 0) {\n#ifdef DDB\n\t\t\t    printf(\"%s: negative bufcnt in stopped voice\\n\",\n\t\t\t\t   sc->sc_dev.dv_xname);\n\t\t\t    Debugger();\n#else\n\t\t\t    panic(\"%s: negative bufcnt in stopped voice\",\n\t\t\t\t  sc->sc_dev.dv_xname);\n#endif\n\t\t\t} else {\n\t\t\t    sc->sc_playbuf = -1; /* none are active */\n\t\t\t    gus_stops++;\n\t\t\t}\n\t\t\t/* fall through to callback and admit another\n\t\t\t   buffer.... */\n\t\t    } else if (sc->sc_bufcnt != 0) {\n\t\t\t/*\n\t\t\t * This should always be taken if the voice\n\t\t\t * is not stopped.\n\t\t\t */\n\t\t\tgus_continues++;\n\t\t\tif (gus_continue_playing(sc, voice)) {\n\t\t\t\t/*\n\t\t\t\t * we shouldn't have continued--active DMA\n\t\t\t\t * is in the way in the ring, for\n\t\t\t\t * some as-yet undebugged reason.\n\t\t\t\t */\n\t\t\t\tgus_stop_voice(sc, GUS_VOICE_LEFT, 1);\n\t\t\t\t/* also kill right voice */\n\t\t\t\tgus_stop_voice(sc, GUS_VOICE_RIGHT, 0);\n\t\t\t\tsc->sc_playbuf = -1;\n\t\t\t\tgus_stops++;\n\t\t\t}\n\t\t    }\n\t\t    /*\n\t\t     * call the upper level to send on down another\n\t\t     * block. We do admission rate control as follows:\n\t\t     *\n\t\t     * When starting up output (in the first N\n\t\t     * blocks), call the upper layer after the DMA is\n\t\t     * complete (see above in gus_dmaout_intr()).\n\t\t     *\n\t\t     * When output is already in progress and we have\n\t\t     * no more GUS buffers to use for DMA, the DMA\n\t\t     * output routines do not call the upper layer.\n\t\t     * Instead, we call the DMA completion routine\n\t\t     * here, after the voice interrupts indicating\n\t\t     * that it's finished with a buffer.\n\t\t     *\n\t\t     * However, don't call anything here if the DMA\n\t\t     * output flag is set, (which shouldn't happen)\n\t\t     * because we'll squish somebody else's DMA if\n\t\t     * that's the case.  When DMA is done, it will\n\t\t     * call back if there is a spare buffer.\n\t\t     */\n\t\t    if (sc->sc_dmaoutintr && !(sc->sc_flags & GUS_LOCKED)) {\n\t\t\tif (sc->sc_dmaoutintr == stereo_dmaintr)\n\t\t\t    printf(\"gusdmaout botch?\\n\");\n\t\t\telse {\n\t\t\t    /* clean out to avoid double calls */\n\t\t\t    void (*pfunc) __P((void *)) = sc->sc_dmaoutintr;\n\t\t\t    void *arg = sc->sc_outarg;\n\n\t\t\t    sc->sc_outarg = 0;\n\t\t\t    sc->sc_dmaoutintr = 0;\n\t\t\t    (*pfunc)(arg);\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t\t/*\n\t\t * Ignore other interrupts for now\n\t\t */\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int gus_stops;",
      "int gus_falsestops;",
      "int gus_continues;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "arg"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__P",
          "args": [
            "(void *)"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"gusdmaout botch?\\n\""
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gus_stop_voice",
          "args": [
            "sc",
            "GUS_VOICE_RIGHT",
            "0"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "gus_stop_voice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "1435-1472",
          "snippet": "void\ngus_stop_voice(sc, voice, intrs_too)\n\tstruct gus_softc *sc;\n\tint voice;\n\tint intrs_too;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\n\tsc->sc_voc[voice].voccntl |= GUSMASK_VOICE_STOPPED |\n\t\tGUSMASK_STOP_VOICE;\n\tif (intrs_too) {\n\t  sc->sc_voc[voice].voccntl &= ~(GUSMASK_VOICE_IRQ);\n\t  /* no more DMA to do */\n\t  sc->sc_flags &= ~GUS_PLAYING;\n\t}\n\tDMAPRINTF((\"gusintr voice notplaying=%x\\n\", sc->sc_flags));\n\n\tguspoke(iot, ioh2, 0L, 0);\n\n\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, (unsigned char) voice);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_VOLUME);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].voccntl);\n\tdelay(100);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_VOLUME);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].voccntl);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_HIGH);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_LOW);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ngus_stop_voice(sc, voice, intrs_too)\n\tstruct gus_softc *sc;\n\tint voice;\n\tint intrs_too;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\n\tsc->sc_voc[voice].voccntl |= GUSMASK_VOICE_STOPPED |\n\t\tGUSMASK_STOP_VOICE;\n\tif (intrs_too) {\n\t  sc->sc_voc[voice].voccntl &= ~(GUSMASK_VOICE_IRQ);\n\t  /* no more DMA to do */\n\t  sc->sc_flags &= ~GUS_PLAYING;\n\t}\n\tDMAPRINTF((\"gusintr voice notplaying=%x\\n\", sc->sc_flags));\n\n\tguspoke(iot, ioh2, 0L, 0);\n\n\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, (unsigned char) voice);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_VOLUME);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].voccntl);\n\tdelay(100);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_VOLUME);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].voccntl);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_HIGH);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_LOW);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "gus_continue_playing",
          "args": [
            "sc",
            "voice"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "gus_continue_playing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "1162-1257",
          "snippet": "int\ngus_continue_playing(sc, voice)\n\tstruct gus_softc *sc;\n\tint voice;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\n\t/*\n\t * stop this voice from interrupting while we work.\n\t */\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].voccntl & ~(GUSMASK_VOICE_IRQ));\n\n\t/* \n\t * update playbuf to point to the buffer the hardware just started\n\t * playing\n\t */\n\tsc->sc_playbuf = ++sc->sc_playbuf % sc->sc_nbufs;\n    \n\t/*\n\t * account for buffer just finished\n\t */\n\tif (--sc->sc_bufcnt == 0) {\n\t\tDPRINTF((\"gus: bufcnt 0 on continuing voice?\\n\"));\n\t}\n\tif (sc->sc_playbuf == sc->sc_dmabuf && (sc->sc_flags & GUS_LOCKED)) {\n\t\tprintf(\"%s: continue into active dmabuf?\\n\", sc->sc_dev.dv_xname);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Select the end of the buffer based on the currently active\n\t * buffer, [plus extra contiguous buffers (if ready)].\n\t */\n\n\t/* \n\t * set endpoint at end of buffer we just started playing.\n\t *\n\t * The total gets -1 because end addrs are one less than you might\n\t * think (the end_addr is the address of the last sample to play)\n\t */\n\tgus_set_endaddr(sc, voice, GUS_MEM_OFFSET +\n\t\t\tsc->sc_chanblocksize * (sc->sc_playbuf + 1) - 1);\n\n\tif (sc->sc_bufcnt < 2) {\n\t\t/*\n\t\t * Clear out the loop and roll flags, and rotate the currently\n\t\t * playing buffer.  That way, if we don't manage to get more\n\t\t * data before this buffer finishes, we'll just stop.\n\t\t */\n\t\tsc->sc_voc[voice].voccntl &= ~GUSMASK_LOOP_ENABLE;\n\t\tsc->sc_voc[voice].volcntl &= ~GUSMASK_VOICE_ROLL;\n\t\tplaystats[playcntr].vaction = 0;\n\t} else {\n\t\t/*\n\t\t * We have some buffers to play.  set LOOP if we're on the\n\t\t * last buffer in the ring, otherwise set ROLL.\n\t\t */\n\t\tif (sc->sc_playbuf == sc->sc_nbufs - 1) {\n\t\t\tsc->sc_voc[voice].voccntl |= GUSMASK_LOOP_ENABLE;\n\t\t\tsc->sc_voc[voice].volcntl &= ~GUSMASK_VOICE_ROLL;\n\t\t\tplaystats[playcntr].vaction = 1;\n\t\t} else {\n\t\t\tsc->sc_voc[voice].voccntl &= ~GUSMASK_LOOP_ENABLE;\n\t\t\tsc->sc_voc[voice].volcntl |= GUSMASK_VOICE_ROLL;\n\t\t\tplaystats[playcntr].vaction = 2;\n\t\t}\n\t}\n#ifdef GUSPLAYDEBUG\n\tif (gusstats) {\n\t\tmicrotime(&playstats[playcntr].tv);\n\t\tplaystats[playcntr].curaddr = gus_get_curaddr(sc, voice);\n\n\t\tplaystats[playcntr].voccntl = sc->sc_voc[voice].voccntl;\n\t\tplaystats[playcntr].volcntl = sc->sc_voc[voice].volcntl;\n\t\tplaystats[playcntr].endaddr = sc->sc_voc[voice].end_addr;\n\t\tplaystats[playcntr].playbuf = sc->sc_playbuf;\n\t\tplaystats[playcntr].dmabuf = sc->sc_dmabuf;\n\t\tplaystats[playcntr].bufcnt = sc->sc_bufcnt;\n\t\tplaycntr = ++playcntr % NDMARECS;\n\t}\n#endif\n\n\t/*\n\t * (re-)set voice parameters.  This will reenable interrupts from this\n\t * voice.\n\t */\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].voccntl);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].volcntl);\n\treturn 0;\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define NDMARECS 2048",
            "#define GUSPLAYDEBUG\t/*XXX*/"
          ],
          "globals_used": [
            "struct playcont {\n\tstruct timeval tv;\n\tu_int playbuf;\n\tu_int dmabuf;\n\tu_char bufcnt;\n\tu_char vaction;\n\tu_char voccntl;\n\tu_char volcntl;\n\tu_long curaddr;\n\tu_long endaddr;\n} playstats[NDMARECS];",
            "int playcntr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define NDMARECS 2048\n#define GUSPLAYDEBUG\t/*XXX*/\n\nstruct playcont {\n\tstruct timeval tv;\n\tu_int playbuf;\n\tu_int dmabuf;\n\tu_char bufcnt;\n\tu_char vaction;\n\tu_char voccntl;\n\tu_char volcntl;\n\tu_long curaddr;\n\tu_long endaddr;\n} playstats[NDMARECS];\nint playcntr;\n\nint\ngus_continue_playing(sc, voice)\n\tstruct gus_softc *sc;\n\tint voice;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\n\t/*\n\t * stop this voice from interrupting while we work.\n\t */\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].voccntl & ~(GUSMASK_VOICE_IRQ));\n\n\t/* \n\t * update playbuf to point to the buffer the hardware just started\n\t * playing\n\t */\n\tsc->sc_playbuf = ++sc->sc_playbuf % sc->sc_nbufs;\n    \n\t/*\n\t * account for buffer just finished\n\t */\n\tif (--sc->sc_bufcnt == 0) {\n\t\tDPRINTF((\"gus: bufcnt 0 on continuing voice?\\n\"));\n\t}\n\tif (sc->sc_playbuf == sc->sc_dmabuf && (sc->sc_flags & GUS_LOCKED)) {\n\t\tprintf(\"%s: continue into active dmabuf?\\n\", sc->sc_dev.dv_xname);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Select the end of the buffer based on the currently active\n\t * buffer, [plus extra contiguous buffers (if ready)].\n\t */\n\n\t/* \n\t * set endpoint at end of buffer we just started playing.\n\t *\n\t * The total gets -1 because end addrs are one less than you might\n\t * think (the end_addr is the address of the last sample to play)\n\t */\n\tgus_set_endaddr(sc, voice, GUS_MEM_OFFSET +\n\t\t\tsc->sc_chanblocksize * (sc->sc_playbuf + 1) - 1);\n\n\tif (sc->sc_bufcnt < 2) {\n\t\t/*\n\t\t * Clear out the loop and roll flags, and rotate the currently\n\t\t * playing buffer.  That way, if we don't manage to get more\n\t\t * data before this buffer finishes, we'll just stop.\n\t\t */\n\t\tsc->sc_voc[voice].voccntl &= ~GUSMASK_LOOP_ENABLE;\n\t\tsc->sc_voc[voice].volcntl &= ~GUSMASK_VOICE_ROLL;\n\t\tplaystats[playcntr].vaction = 0;\n\t} else {\n\t\t/*\n\t\t * We have some buffers to play.  set LOOP if we're on the\n\t\t * last buffer in the ring, otherwise set ROLL.\n\t\t */\n\t\tif (sc->sc_playbuf == sc->sc_nbufs - 1) {\n\t\t\tsc->sc_voc[voice].voccntl |= GUSMASK_LOOP_ENABLE;\n\t\t\tsc->sc_voc[voice].volcntl &= ~GUSMASK_VOICE_ROLL;\n\t\t\tplaystats[playcntr].vaction = 1;\n\t\t} else {\n\t\t\tsc->sc_voc[voice].voccntl &= ~GUSMASK_LOOP_ENABLE;\n\t\t\tsc->sc_voc[voice].volcntl |= GUSMASK_VOICE_ROLL;\n\t\t\tplaystats[playcntr].vaction = 2;\n\t\t}\n\t}\n#ifdef GUSPLAYDEBUG\n\tif (gusstats) {\n\t\tmicrotime(&playstats[playcntr].tv);\n\t\tplaystats[playcntr].curaddr = gus_get_curaddr(sc, voice);\n\n\t\tplaystats[playcntr].voccntl = sc->sc_voc[voice].voccntl;\n\t\tplaystats[playcntr].volcntl = sc->sc_voc[voice].volcntl;\n\t\tplaystats[playcntr].endaddr = sc->sc_voc[voice].end_addr;\n\t\tplaystats[playcntr].playbuf = sc->sc_playbuf;\n\t\tplaystats[playcntr].dmabuf = sc->sc_dmabuf;\n\t\tplaystats[playcntr].bufcnt = sc->sc_bufcnt;\n\t\tplaycntr = ++playcntr % NDMARECS;\n\t}\n#endif\n\n\t/*\n\t * (re-)set voice parameters.  This will reenable interrupts from this\n\t * voice.\n\t */\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].voccntl);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].volcntl);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"%s: negative bufcnt in stopped voice\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Debugger",
          "args": [],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gus_start_playing",
          "args": [
            "sc",
            "sc->sc_playbuf"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "gus_start_playing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "1082-1160",
          "snippet": "void\ngus_start_playing(sc, bufno)\n\tstruct gus_softc *sc;\n\tint bufno;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\t/*\n\t * Start the voices playing, with buffer BUFNO.\n\t */\n\n\t/*\n\t * Loop or roll if we have buffers ready.\n\t */\n\n\tif (sc->sc_bufcnt == 1) {\n\t\tsc->sc_voc[GUS_VOICE_LEFT].voccntl &= ~(GUSMASK_LOOP_ENABLE);\n\t\tsc->sc_voc[GUS_VOICE_LEFT].volcntl &= ~(GUSMASK_VOICE_ROLL);\n\t} else {\n\t\tif (bufno == sc->sc_nbufs - 1) {\n\t\t\tsc->sc_voc[GUS_VOICE_LEFT].voccntl |= GUSMASK_LOOP_ENABLE;\n\t\t\tsc->sc_voc[GUS_VOICE_LEFT].volcntl &= ~(GUSMASK_VOICE_ROLL);\n\t\t} else {\n\t\t\tsc->sc_voc[GUS_VOICE_LEFT].voccntl &= ~GUSMASK_LOOP_ENABLE;\n\t\t\tsc->sc_voc[GUS_VOICE_LEFT].volcntl |= GUSMASK_VOICE_ROLL;\n\t\t}\n\t}\n\n\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, GUS_VOICE_LEFT);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_LEFT].voccntl);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_LEFT].volcntl);\n\n\tsc->sc_voc[GUS_VOICE_LEFT].current_addr =\n\t\tGUS_MEM_OFFSET + sc->sc_chanblocksize * bufno;\n\tsc->sc_voc[GUS_VOICE_LEFT].end_addr =\n\t\tsc->sc_voc[GUS_VOICE_LEFT].current_addr + sc->sc_chanblocksize - 1;\n\tsc->sc_voc[GUS_VOICE_RIGHT].current_addr =\n\t\tsc->sc_voc[GUS_VOICE_LEFT].current_addr + \n\t\t(gus_dostereo && sc->sc_channels == 2 ? GUS_LEFT_RIGHT_OFFSET : 0);\n\t/*\n\t * set up right channel to just loop forever, no interrupts,\n\t * starting at the buffer we just filled.  We'll feed it data\n\t * at the same time as left channel.\n\t */\n\tsc->sc_voc[GUS_VOICE_RIGHT].voccntl |= GUSMASK_LOOP_ENABLE;\n\tsc->sc_voc[GUS_VOICE_RIGHT].volcntl &= ~(GUSMASK_VOICE_ROLL);\n\n#ifdef GUSPLAYDEBUG\n\tif (gusstats) {\n\t\tmicrotime(&playstats[playcntr].tv);\n\t\tplaystats[playcntr].curaddr = sc->sc_voc[GUS_VOICE_LEFT].current_addr;\n\n\t\tplaystats[playcntr].voccntl = sc->sc_voc[GUS_VOICE_LEFT].voccntl;\n\t\tplaystats[playcntr].volcntl = sc->sc_voc[GUS_VOICE_LEFT].volcntl;\n\t\tplaystats[playcntr].endaddr = sc->sc_voc[GUS_VOICE_LEFT].end_addr;\n\t\tplaystats[playcntr].playbuf = bufno;\n\t\tplaystats[playcntr].dmabuf = sc->sc_dmabuf;\n\t\tplaystats[playcntr].bufcnt = sc->sc_bufcnt;\n\t\tplaystats[playcntr].vaction = 5;\n\t\tplaycntr = ++playcntr % NDMARECS;\n\t}\n#endif\n\n\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, GUS_VOICE_RIGHT);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_RIGHT].voccntl);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_RIGHT].volcntl);\n\n\tgus_start_voice(sc, GUS_VOICE_RIGHT, 0);\n\tgus_start_voice(sc, GUS_VOICE_LEFT, 1);\n\tif (sc->sc_playbuf == -1)\n\t\t/* mark start of playing */\n\t\tsc->sc_playbuf = bufno;\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define NDMARECS 2048",
            "#define GUSPLAYDEBUG\t/*XXX*/"
          ],
          "globals_used": [
            "int\tgus_dostereo = 1;",
            "struct playcont {\n\tstruct timeval tv;\n\tu_int playbuf;\n\tu_int dmabuf;\n\tu_char bufcnt;\n\tu_char vaction;\n\tu_char voccntl;\n\tu_char volcntl;\n\tu_long curaddr;\n\tu_long endaddr;\n} playstats[NDMARECS];",
            "int playcntr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define NDMARECS 2048\n#define GUSPLAYDEBUG\t/*XXX*/\n\nint\tgus_dostereo = 1;\nstruct playcont {\n\tstruct timeval tv;\n\tu_int playbuf;\n\tu_int dmabuf;\n\tu_char bufcnt;\n\tu_char vaction;\n\tu_char voccntl;\n\tu_char volcntl;\n\tu_long curaddr;\n\tu_long endaddr;\n} playstats[NDMARECS];\nint playcntr;\n\nvoid\ngus_start_playing(sc, bufno)\n\tstruct gus_softc *sc;\n\tint bufno;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\t/*\n\t * Start the voices playing, with buffer BUFNO.\n\t */\n\n\t/*\n\t * Loop or roll if we have buffers ready.\n\t */\n\n\tif (sc->sc_bufcnt == 1) {\n\t\tsc->sc_voc[GUS_VOICE_LEFT].voccntl &= ~(GUSMASK_LOOP_ENABLE);\n\t\tsc->sc_voc[GUS_VOICE_LEFT].volcntl &= ~(GUSMASK_VOICE_ROLL);\n\t} else {\n\t\tif (bufno == sc->sc_nbufs - 1) {\n\t\t\tsc->sc_voc[GUS_VOICE_LEFT].voccntl |= GUSMASK_LOOP_ENABLE;\n\t\t\tsc->sc_voc[GUS_VOICE_LEFT].volcntl &= ~(GUSMASK_VOICE_ROLL);\n\t\t} else {\n\t\t\tsc->sc_voc[GUS_VOICE_LEFT].voccntl &= ~GUSMASK_LOOP_ENABLE;\n\t\t\tsc->sc_voc[GUS_VOICE_LEFT].volcntl |= GUSMASK_VOICE_ROLL;\n\t\t}\n\t}\n\n\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, GUS_VOICE_LEFT);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_LEFT].voccntl);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_LEFT].volcntl);\n\n\tsc->sc_voc[GUS_VOICE_LEFT].current_addr =\n\t\tGUS_MEM_OFFSET + sc->sc_chanblocksize * bufno;\n\tsc->sc_voc[GUS_VOICE_LEFT].end_addr =\n\t\tsc->sc_voc[GUS_VOICE_LEFT].current_addr + sc->sc_chanblocksize - 1;\n\tsc->sc_voc[GUS_VOICE_RIGHT].current_addr =\n\t\tsc->sc_voc[GUS_VOICE_LEFT].current_addr + \n\t\t(gus_dostereo && sc->sc_channels == 2 ? GUS_LEFT_RIGHT_OFFSET : 0);\n\t/*\n\t * set up right channel to just loop forever, no interrupts,\n\t * starting at the buffer we just filled.  We'll feed it data\n\t * at the same time as left channel.\n\t */\n\tsc->sc_voc[GUS_VOICE_RIGHT].voccntl |= GUSMASK_LOOP_ENABLE;\n\tsc->sc_voc[GUS_VOICE_RIGHT].volcntl &= ~(GUSMASK_VOICE_ROLL);\n\n#ifdef GUSPLAYDEBUG\n\tif (gusstats) {\n\t\tmicrotime(&playstats[playcntr].tv);\n\t\tplaystats[playcntr].curaddr = sc->sc_voc[GUS_VOICE_LEFT].current_addr;\n\n\t\tplaystats[playcntr].voccntl = sc->sc_voc[GUS_VOICE_LEFT].voccntl;\n\t\tplaystats[playcntr].volcntl = sc->sc_voc[GUS_VOICE_LEFT].volcntl;\n\t\tplaystats[playcntr].endaddr = sc->sc_voc[GUS_VOICE_LEFT].end_addr;\n\t\tplaystats[playcntr].playbuf = bufno;\n\t\tplaystats[playcntr].dmabuf = sc->sc_dmabuf;\n\t\tplaystats[playcntr].bufcnt = sc->sc_bufcnt;\n\t\tplaystats[playcntr].vaction = 5;\n\t\tplaycntr = ++playcntr % NDMARECS;\n\t}\n#endif\n\n\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, GUS_VOICE_RIGHT);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_RIGHT].voccntl);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_RIGHT].volcntl);\n\n\tgus_start_voice(sc, GUS_VOICE_RIGHT, 0);\n\tgus_start_voice(sc, GUS_VOICE_LEFT, 1);\n\tif (sc->sc_playbuf == -1)\n\t\t/* mark start of playing */\n\t\tsc->sc_playbuf = bufno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DMAPRINTF",
          "args": [
            "(\"%s: spurious voice %d stop?\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, voice)"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_VOICE_CNTL+0x80"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_IRQ_STATUS"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint gus_stops;\nint gus_falsestops;\nint gus_continues;\n\nint\ngus_voice_intr(sc)\n\tstruct gus_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tint ignore = 0, voice, rval = 0;\n\tunsigned char intr, status;\n\n\t/*\n\t * The point of this may not be obvious at first.  A voice can\n\t * interrupt more than once; according to the GUS SDK we are supposed\n\t * to ignore multiple interrupts for the same voice.\n\t */\n\n\twhile(1) {\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_IRQ_STATUS);\n\t\tintr = bus_space_read_1(iot, ioh2, GUS_DATA_HIGH);\n\n\t\tif ((intr & (GUSMASK_WIRQ_VOLUME | GUSMASK_WIRQ_VOICE))\n\t\t\t== (GUSMASK_WIRQ_VOLUME | GUSMASK_WIRQ_VOICE))\n\t\t\t/*\n\t\t\t * No more interrupts, time to return\n\t\t\t */\n\t\t \treturn rval;\n\n\t\tif ((intr & GUSMASK_WIRQ_VOICE) == 0) {\n\n\t\t    /*\n\t\t     * We've got a voice interrupt.  Ignore previous\n\t\t     * interrupts by the same voice.\n\t\t     */\n\n\t\t    rval = 1;\n\t\t    voice = intr & GUSMASK_WIRQ_VOICEMASK;\n\n\t\t    if ((1 << voice) & ignore)\n\t\t\tbreak;\n\n\t\t    ignore |= 1 << voice;\n\n\t\t    /*\n\t\t     * If the voice is stopped, then force it to stop\n\t\t     * (this stops it from continuously generating IRQs)\n\t\t     */\n\n\t\t    SELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL+0x80);\n\t\t    status = bus_space_read_1(iot, ioh2, GUS_DATA_HIGH);\n\t\t    if (status & GUSMASK_VOICE_STOPPED) {\n\t\t\tif (voice != GUS_VOICE_LEFT) {\n\t\t\t    DMAPRINTF((\"%s: spurious voice %d stop?\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, voice));\n\t\t\t    gus_stop_voice(sc, voice, 0);\n\t\t\t    continue;\n\t\t\t}\n\t\t\tgus_stop_voice(sc, voice, 1);\n\t\t\t/* also kill right voice */\n\t\t\tgus_stop_voice(sc, GUS_VOICE_RIGHT, 0);\n\t\t\tsc->sc_bufcnt--; /* it finished a buffer */\n\t\t\tif (sc->sc_bufcnt > 0) {\n\t\t\t    /*\n\t\t\t     * probably a race to get here: the voice\n\t\t\t     * stopped while the DMA code was just trying to\n\t\t\t     * get the next buffer in place. \n\t\t\t     * Start the voice again.\n\t\t\t     */\n\t\t\t    printf(\"%s: stopped voice not drained? (%x)\\n\",\n\t\t\t\t   sc->sc_dev.dv_xname, sc->sc_bufcnt);\n\t\t\t    gus_falsestops++;\n\n\t\t\t    sc->sc_playbuf = ++sc->sc_playbuf % sc->sc_nbufs;\n\t\t\t    gus_start_playing(sc, sc->sc_playbuf);\n\t\t\t} else if (sc->sc_bufcnt < 0) {\n#ifdef DDB\n\t\t\t    printf(\"%s: negative bufcnt in stopped voice\\n\",\n\t\t\t\t   sc->sc_dev.dv_xname);\n\t\t\t    Debugger();\n#else\n\t\t\t    panic(\"%s: negative bufcnt in stopped voice\",\n\t\t\t\t  sc->sc_dev.dv_xname);\n#endif\n\t\t\t} else {\n\t\t\t    sc->sc_playbuf = -1; /* none are active */\n\t\t\t    gus_stops++;\n\t\t\t}\n\t\t\t/* fall through to callback and admit another\n\t\t\t   buffer.... */\n\t\t    } else if (sc->sc_bufcnt != 0) {\n\t\t\t/*\n\t\t\t * This should always be taken if the voice\n\t\t\t * is not stopped.\n\t\t\t */\n\t\t\tgus_continues++;\n\t\t\tif (gus_continue_playing(sc, voice)) {\n\t\t\t\t/*\n\t\t\t\t * we shouldn't have continued--active DMA\n\t\t\t\t * is in the way in the ring, for\n\t\t\t\t * some as-yet undebugged reason.\n\t\t\t\t */\n\t\t\t\tgus_stop_voice(sc, GUS_VOICE_LEFT, 1);\n\t\t\t\t/* also kill right voice */\n\t\t\t\tgus_stop_voice(sc, GUS_VOICE_RIGHT, 0);\n\t\t\t\tsc->sc_playbuf = -1;\n\t\t\t\tgus_stops++;\n\t\t\t}\n\t\t    }\n\t\t    /*\n\t\t     * call the upper level to send on down another\n\t\t     * block. We do admission rate control as follows:\n\t\t     *\n\t\t     * When starting up output (in the first N\n\t\t     * blocks), call the upper layer after the DMA is\n\t\t     * complete (see above in gus_dmaout_intr()).\n\t\t     *\n\t\t     * When output is already in progress and we have\n\t\t     * no more GUS buffers to use for DMA, the DMA\n\t\t     * output routines do not call the upper layer.\n\t\t     * Instead, we call the DMA completion routine\n\t\t     * here, after the voice interrupts indicating\n\t\t     * that it's finished with a buffer.\n\t\t     *\n\t\t     * However, don't call anything here if the DMA\n\t\t     * output flag is set, (which shouldn't happen)\n\t\t     * because we'll squish somebody else's DMA if\n\t\t     * that's the case.  When DMA is done, it will\n\t\t     * call back if there is a spare buffer.\n\t\t     */\n\t\t    if (sc->sc_dmaoutintr && !(sc->sc_flags & GUS_LOCKED)) {\n\t\t\tif (sc->sc_dmaoutintr == stereo_dmaintr)\n\t\t\t    printf(\"gusdmaout botch?\\n\");\n\t\t\telse {\n\t\t\t    /* clean out to avoid double calls */\n\t\t\t    void (*pfunc) __P((void *)) = sc->sc_dmaoutintr;\n\t\t\t    void *arg = sc->sc_outarg;\n\n\t\t\t    sc->sc_outarg = 0;\n\t\t\t    sc->sc_dmaoutintr = 0;\n\t\t\t    (*pfunc)(arg);\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t\t/*\n\t\t * Ignore other interrupts for now\n\t\t */\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "gus_dmaout_dointr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "779-927",
    "snippet": "void\ngus_dmaout_dointr(sc)\n\tstruct gus_softc *sc;\n{\n \tbus_space_tag_t iot = sc->sc_iot;\n \tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\n\t/* sc->sc_dmaoutcnt - 1 because DMA controller counts from zero?. */\n \tisa_dmadone(sc->sc_dev.dv_parent, sc->sc_drq);\n\tsc->sc_flags &= ~GUS_DMAOUT_ACTIVE;  /* pending DMA is done */\n \tDMAPRINTF((\"gus_dmaout_dointr %d @ %p\\n\", sc->sc_dmaoutcnt,\n\t\t   sc->sc_dmaoutaddr));\n\n\t/*\n\t * to prevent clicking, we need to copy last sample\n\t * from last buffer to scratch area just before beginning of\n\t * buffer.  However, if we're doing formats that are converted by\n\t * the card during the DMA process, we need to pick up the converted\n\t * byte rather than the one we have in memory.\n\t */\n\tif (sc->sc_dmabuf == sc->sc_nbufs - 1) {\n\t  int i;\n\t  switch (sc->sc_encoding) {\n\t  case AUDIO_ENCODING_SLINEAR_LE:\n\t  case AUDIO_ENCODING_SLINEAR_BE:\n\t    if (sc->sc_precision == 8)\n\t      goto byte;\n\t    /* we have the native format */\n\t    for (i = 1; i <= 2; i++)\n\t      guspoke(iot, ioh2, sc->sc_gusaddr -\n\t\t      (sc->sc_nbufs - 1) * sc->sc_chanblocksize - i,\n\t\t      sc->sc_dmaoutaddr[sc->sc_dmaoutcnt-i]);\n\t    break;\n\t  case AUDIO_ENCODING_ULINEAR_LE:\n\t  case AUDIO_ENCODING_ULINEAR_BE:\n\t    guspoke(iot, ioh2, sc->sc_gusaddr -\n\t\t    (sc->sc_nbufs - 1) * sc->sc_chanblocksize - 2,\n\t\t    guspeek(iot, ioh2,\n\t\t\t    sc->sc_gusaddr + sc->sc_chanblocksize - 2));\n\t  case AUDIO_ENCODING_ALAW:\n\t  case AUDIO_ENCODING_ULAW:\n\t  byte:\n\t    /* we need to fetch the translated byte, then stuff it. */\n\t    guspoke(iot, ioh2, sc->sc_gusaddr -\n\t\t    (sc->sc_nbufs - 1) * sc->sc_chanblocksize - 1,\n\t\t    guspeek(iot, ioh2,\n\t\t\t    sc->sc_gusaddr + sc->sc_chanblocksize - 1));\n\t    break;\n\t  }\n\t}\n\t/*\n\t * If this is the first half of stereo, \"ignore\" this one\n\t * and copy out the second half.\n\t */\n\tif (sc->sc_dmaoutintr == stereo_dmaintr) {\n\t    (*sc->sc_dmaoutintr)(sc->sc_outarg);\n\t    return;\n\t}\n\t/*\n\t * If the voice is stopped, then start it.  Reset the loop\n\t * and roll bits.  Call the audio layer routine, since if\n\t * we're starting a stopped voice, that means that the next\n\t * buffer can be filled\n\t */\n\n\tsc->sc_flags &= ~GUS_LOCKED;\n\tif (sc->sc_voc[GUS_VOICE_LEFT].voccntl &\n\t    GUSMASK_VOICE_STOPPED) {\n\t    if (sc->sc_flags & GUS_PLAYING) {\n\t\tprintf(\"%s: playing yet stopped?\\n\", sc->sc_dev.dv_xname);\n\t    }\n\t    sc->sc_bufcnt++; /* another yet to be played */\n\t    gus_start_playing(sc, sc->sc_dmabuf);\n\t    gus_restart++;\n\t} else {\n\t    /*\n\t     * set the sound action based on which buffer we\n\t     * just transferred.  If we just transferred buffer 0\n\t     * we want the sound to loop when it gets to the nth\n\t     * buffer; if we just transferred\n\t     * any other buffer, we want the sound to roll over\n\t     * at least one more time.  The voice interrupt\n\t     * handlers will take care of accounting &\n\t     * setting control bits if it's not caught up to us\n\t     * yet.\n\t     */\n\t    if (++sc->sc_bufcnt == 2) {\n\t\t/*\n\t\t * XXX \n\t\t * If we're too slow in reaction here,\n\t\t * the voice could be just approaching the\n\t\t * end of its run.  It should be set to stop,\n\t\t * so these adjustments might not DTRT.\n\t\t */\n\t\tif (sc->sc_dmabuf == 0 &&\n\t\t    sc->sc_playbuf == sc->sc_nbufs - 1) {\n\t\t    /* player is just at the last buf, we're at the\n\t\t       first.  Turn on looping, turn off rolling. */\n\t\t    sc->sc_voc[GUS_VOICE_LEFT].voccntl |= GUSMASK_LOOP_ENABLE;\n\t\t    sc->sc_voc[GUS_VOICE_LEFT].volcntl &= ~GUSMASK_VOICE_ROLL;\n\t\t    playstats[playcntr].vaction = 3;\n\t\t} else {\n\t\t    /* player is at previous buf:\n\t\t       turn on rolling, turn off looping */\n\t\t    sc->sc_voc[GUS_VOICE_LEFT].voccntl &= ~GUSMASK_LOOP_ENABLE;\n\t\t    sc->sc_voc[GUS_VOICE_LEFT].volcntl |= GUSMASK_VOICE_ROLL;\n\t\t    playstats[playcntr].vaction = 4;\n\t\t}\n#ifdef GUSPLAYDEBUG\n\t\tif (gusstats) {\n\t\t  microtime(&playstats[playcntr].tv);\n\t\t  playstats[playcntr].endaddr = sc->sc_voc[GUS_VOICE_LEFT].end_addr;\n\t\t  playstats[playcntr].voccntl = sc->sc_voc[GUS_VOICE_LEFT].voccntl;\n\t\t  playstats[playcntr].volcntl = sc->sc_voc[GUS_VOICE_LEFT].volcntl;\n\t\t  playstats[playcntr].playbuf = sc->sc_playbuf;\n\t\t  playstats[playcntr].dmabuf = sc->sc_dmabuf;\n\t\t  playstats[playcntr].bufcnt = sc->sc_bufcnt;\n\t\t  playstats[playcntr].curaddr = gus_get_curaddr(sc, GUS_VOICE_LEFT);\n\t\t  playcntr = ++playcntr % NDMARECS;\n\t\t}\n#endif\n\t\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, GUS_VOICE_LEFT);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\t\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_LEFT].voccntl);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_CONTROL);\n\t\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_LEFT].volcntl);\n\t    }\n\t}\n\tgus_bufcnt[sc->sc_bufcnt-1]++;\n\t/*\n\t * flip to the next DMA buffer\n\t */\n\n\tsc->sc_dmabuf = ++sc->sc_dmabuf % sc->sc_nbufs; \n\t/*\n\t * See comments below about DMA admission control strategy.\n\t * We can call the upper level here if we have an\n\t * idle buffer (not currently playing) to DMA into.\n\t */\n\tif (sc->sc_dmaoutintr && sc->sc_bufcnt < sc->sc_nbufs) {\n\t    /* clean out to prevent double calls */\n\t    void (*pfunc) __P((void *)) = sc->sc_dmaoutintr;\n\t    void *arg = sc->sc_outarg;\n\n\t    sc->sc_outarg = 0;\n\t    sc->sc_dmaoutintr = 0;\n\t    (*pfunc)(arg);\n\t}\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define NDMARECS 2048",
      "#define GUSPLAYDEBUG\t/*XXX*/"
    ],
    "globals_used": [
      "int gus_bufcnt[GUS_MEM_FOR_BUFFERS / GUS_BUFFER_MULTIPLE];",
      "int gus_restart;",
      "struct playcont {\n\tstruct timeval tv;\n\tu_int playbuf;\n\tu_int dmabuf;\n\tu_char bufcnt;\n\tu_char vaction;\n\tu_char voccntl;\n\tu_char volcntl;\n\tu_long curaddr;\n\tu_long endaddr;\n} playstats[NDMARECS];",
      "int playcntr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "arg"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__P",
          "args": [
            "(void *)"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "sc->sc_voc[GUS_VOICE_LEFT].volcntl"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_VOLUME_CONTROL"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "sc->sc_voc[GUS_VOICE_LEFT].voccntl"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_VOICE_CNTL"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_VOICE_SELECT",
            "GUS_VOICE_LEFT"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gus_get_curaddr",
          "args": [
            "sc",
            "GUS_VOICE_LEFT"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "gus_get_curaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "1949-1971",
          "snippet": "u_long\ngus_get_curaddr(sc, voice)\n\tstruct gus_softc *sc;\n\tint voice;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tu_long addr;\n\n\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, (unsigned char) voice);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_HIGH|GUSREG_READ);\n\taddr = (bus_space_read_2(iot, ioh2, GUS_DATA_LOW) & 0x1fff) << 7;\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_LOW|GUSREG_READ);\n\taddr |= (bus_space_read_2(iot, ioh2, GUS_DATA_LOW) >> 9L) & 0x7f;\n\n\tif (sc->sc_voc[voice].voccntl & GUSMASK_DATA_SIZE16)\n\t    addr = (addr & 0xc0000) | ((addr & 0x1ffff) << 1); /* undo 16-bit change */\n\tDPRINTF((\"gus voice %d curaddr %ld end_addr %ld\\n\",\n\t\t voice, addr, sc->sc_voc[voice].end_addr));\n\t/* XXX sanity check the address? */\n\n\treturn(addr);\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nu_long\ngus_get_curaddr(sc, voice)\n\tstruct gus_softc *sc;\n\tint voice;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tu_long addr;\n\n\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, (unsigned char) voice);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_HIGH|GUSREG_READ);\n\taddr = (bus_space_read_2(iot, ioh2, GUS_DATA_LOW) & 0x1fff) << 7;\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_LOW|GUSREG_READ);\n\taddr |= (bus_space_read_2(iot, ioh2, GUS_DATA_LOW) >> 9L) & 0x7f;\n\n\tif (sc->sc_voc[voice].voccntl & GUSMASK_DATA_SIZE16)\n\t    addr = (addr & 0xc0000) | ((addr & 0x1ffff) << 1); /* undo 16-bit change */\n\tDPRINTF((\"gus voice %d curaddr %ld end_addr %ld\\n\",\n\t\t voice, addr, sc->sc_voc[voice].end_addr));\n\t/* XXX sanity check the address? */\n\n\treturn(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "microtime",
          "args": [
            "&playstats[playcntr].tv"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gus_start_playing",
          "args": [
            "sc",
            "sc->sc_dmabuf"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "gus_start_playing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "1082-1160",
          "snippet": "void\ngus_start_playing(sc, bufno)\n\tstruct gus_softc *sc;\n\tint bufno;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\t/*\n\t * Start the voices playing, with buffer BUFNO.\n\t */\n\n\t/*\n\t * Loop or roll if we have buffers ready.\n\t */\n\n\tif (sc->sc_bufcnt == 1) {\n\t\tsc->sc_voc[GUS_VOICE_LEFT].voccntl &= ~(GUSMASK_LOOP_ENABLE);\n\t\tsc->sc_voc[GUS_VOICE_LEFT].volcntl &= ~(GUSMASK_VOICE_ROLL);\n\t} else {\n\t\tif (bufno == sc->sc_nbufs - 1) {\n\t\t\tsc->sc_voc[GUS_VOICE_LEFT].voccntl |= GUSMASK_LOOP_ENABLE;\n\t\t\tsc->sc_voc[GUS_VOICE_LEFT].volcntl &= ~(GUSMASK_VOICE_ROLL);\n\t\t} else {\n\t\t\tsc->sc_voc[GUS_VOICE_LEFT].voccntl &= ~GUSMASK_LOOP_ENABLE;\n\t\t\tsc->sc_voc[GUS_VOICE_LEFT].volcntl |= GUSMASK_VOICE_ROLL;\n\t\t}\n\t}\n\n\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, GUS_VOICE_LEFT);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_LEFT].voccntl);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_LEFT].volcntl);\n\n\tsc->sc_voc[GUS_VOICE_LEFT].current_addr =\n\t\tGUS_MEM_OFFSET + sc->sc_chanblocksize * bufno;\n\tsc->sc_voc[GUS_VOICE_LEFT].end_addr =\n\t\tsc->sc_voc[GUS_VOICE_LEFT].current_addr + sc->sc_chanblocksize - 1;\n\tsc->sc_voc[GUS_VOICE_RIGHT].current_addr =\n\t\tsc->sc_voc[GUS_VOICE_LEFT].current_addr + \n\t\t(gus_dostereo && sc->sc_channels == 2 ? GUS_LEFT_RIGHT_OFFSET : 0);\n\t/*\n\t * set up right channel to just loop forever, no interrupts,\n\t * starting at the buffer we just filled.  We'll feed it data\n\t * at the same time as left channel.\n\t */\n\tsc->sc_voc[GUS_VOICE_RIGHT].voccntl |= GUSMASK_LOOP_ENABLE;\n\tsc->sc_voc[GUS_VOICE_RIGHT].volcntl &= ~(GUSMASK_VOICE_ROLL);\n\n#ifdef GUSPLAYDEBUG\n\tif (gusstats) {\n\t\tmicrotime(&playstats[playcntr].tv);\n\t\tplaystats[playcntr].curaddr = sc->sc_voc[GUS_VOICE_LEFT].current_addr;\n\n\t\tplaystats[playcntr].voccntl = sc->sc_voc[GUS_VOICE_LEFT].voccntl;\n\t\tplaystats[playcntr].volcntl = sc->sc_voc[GUS_VOICE_LEFT].volcntl;\n\t\tplaystats[playcntr].endaddr = sc->sc_voc[GUS_VOICE_LEFT].end_addr;\n\t\tplaystats[playcntr].playbuf = bufno;\n\t\tplaystats[playcntr].dmabuf = sc->sc_dmabuf;\n\t\tplaystats[playcntr].bufcnt = sc->sc_bufcnt;\n\t\tplaystats[playcntr].vaction = 5;\n\t\tplaycntr = ++playcntr % NDMARECS;\n\t}\n#endif\n\n\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, GUS_VOICE_RIGHT);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_RIGHT].voccntl);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_RIGHT].volcntl);\n\n\tgus_start_voice(sc, GUS_VOICE_RIGHT, 0);\n\tgus_start_voice(sc, GUS_VOICE_LEFT, 1);\n\tif (sc->sc_playbuf == -1)\n\t\t/* mark start of playing */\n\t\tsc->sc_playbuf = bufno;\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define NDMARECS 2048",
            "#define GUSPLAYDEBUG\t/*XXX*/"
          ],
          "globals_used": [
            "int\tgus_dostereo = 1;",
            "struct playcont {\n\tstruct timeval tv;\n\tu_int playbuf;\n\tu_int dmabuf;\n\tu_char bufcnt;\n\tu_char vaction;\n\tu_char voccntl;\n\tu_char volcntl;\n\tu_long curaddr;\n\tu_long endaddr;\n} playstats[NDMARECS];",
            "int playcntr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define NDMARECS 2048\n#define GUSPLAYDEBUG\t/*XXX*/\n\nint\tgus_dostereo = 1;\nstruct playcont {\n\tstruct timeval tv;\n\tu_int playbuf;\n\tu_int dmabuf;\n\tu_char bufcnt;\n\tu_char vaction;\n\tu_char voccntl;\n\tu_char volcntl;\n\tu_long curaddr;\n\tu_long endaddr;\n} playstats[NDMARECS];\nint playcntr;\n\nvoid\ngus_start_playing(sc, bufno)\n\tstruct gus_softc *sc;\n\tint bufno;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\t/*\n\t * Start the voices playing, with buffer BUFNO.\n\t */\n\n\t/*\n\t * Loop or roll if we have buffers ready.\n\t */\n\n\tif (sc->sc_bufcnt == 1) {\n\t\tsc->sc_voc[GUS_VOICE_LEFT].voccntl &= ~(GUSMASK_LOOP_ENABLE);\n\t\tsc->sc_voc[GUS_VOICE_LEFT].volcntl &= ~(GUSMASK_VOICE_ROLL);\n\t} else {\n\t\tif (bufno == sc->sc_nbufs - 1) {\n\t\t\tsc->sc_voc[GUS_VOICE_LEFT].voccntl |= GUSMASK_LOOP_ENABLE;\n\t\t\tsc->sc_voc[GUS_VOICE_LEFT].volcntl &= ~(GUSMASK_VOICE_ROLL);\n\t\t} else {\n\t\t\tsc->sc_voc[GUS_VOICE_LEFT].voccntl &= ~GUSMASK_LOOP_ENABLE;\n\t\t\tsc->sc_voc[GUS_VOICE_LEFT].volcntl |= GUSMASK_VOICE_ROLL;\n\t\t}\n\t}\n\n\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, GUS_VOICE_LEFT);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_LEFT].voccntl);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_LEFT].volcntl);\n\n\tsc->sc_voc[GUS_VOICE_LEFT].current_addr =\n\t\tGUS_MEM_OFFSET + sc->sc_chanblocksize * bufno;\n\tsc->sc_voc[GUS_VOICE_LEFT].end_addr =\n\t\tsc->sc_voc[GUS_VOICE_LEFT].current_addr + sc->sc_chanblocksize - 1;\n\tsc->sc_voc[GUS_VOICE_RIGHT].current_addr =\n\t\tsc->sc_voc[GUS_VOICE_LEFT].current_addr + \n\t\t(gus_dostereo && sc->sc_channels == 2 ? GUS_LEFT_RIGHT_OFFSET : 0);\n\t/*\n\t * set up right channel to just loop forever, no interrupts,\n\t * starting at the buffer we just filled.  We'll feed it data\n\t * at the same time as left channel.\n\t */\n\tsc->sc_voc[GUS_VOICE_RIGHT].voccntl |= GUSMASK_LOOP_ENABLE;\n\tsc->sc_voc[GUS_VOICE_RIGHT].volcntl &= ~(GUSMASK_VOICE_ROLL);\n\n#ifdef GUSPLAYDEBUG\n\tif (gusstats) {\n\t\tmicrotime(&playstats[playcntr].tv);\n\t\tplaystats[playcntr].curaddr = sc->sc_voc[GUS_VOICE_LEFT].current_addr;\n\n\t\tplaystats[playcntr].voccntl = sc->sc_voc[GUS_VOICE_LEFT].voccntl;\n\t\tplaystats[playcntr].volcntl = sc->sc_voc[GUS_VOICE_LEFT].volcntl;\n\t\tplaystats[playcntr].endaddr = sc->sc_voc[GUS_VOICE_LEFT].end_addr;\n\t\tplaystats[playcntr].playbuf = bufno;\n\t\tplaystats[playcntr].dmabuf = sc->sc_dmabuf;\n\t\tplaystats[playcntr].bufcnt = sc->sc_bufcnt;\n\t\tplaystats[playcntr].vaction = 5;\n\t\tplaycntr = ++playcntr % NDMARECS;\n\t}\n#endif\n\n\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, GUS_VOICE_RIGHT);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_RIGHT].voccntl);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_RIGHT].volcntl);\n\n\tgus_start_voice(sc, GUS_VOICE_RIGHT, 0);\n\tgus_start_voice(sc, GUS_VOICE_LEFT, 1);\n\tif (sc->sc_playbuf == -1)\n\t\t/* mark start of playing */\n\t\tsc->sc_playbuf = bufno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: playing yet stopped?\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc->sc_outarg"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "guspoke",
          "args": [
            "iot",
            "ioh2",
            "sc->sc_gusaddr -\n\t\t    (sc->sc_nbufs - 1) * sc->sc_chanblocksize - 1",
            "guspeek(iot, ioh2,\n\t\t\t    sc->sc_gusaddr + sc->sc_chanblocksize - 1)"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "guspoke",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "1997-2019",
          "snippet": "void\nguspoke(iot, ioh2, address, value)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh2;\n\tlong address;\n\tunsigned char value;\n{\n\n\t/*\n\t * Select the DRAM address\n\t */\n\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_LOW);\n \tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, (unsigned int) (address & 0xffff));\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_HIGH);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, (unsigned char) ((address >> 16) & 0xff));\n\n\t/*\n\t * Actually write the data\n\t */\n\n\tbus_space_write_1(iot, ioh2, GUS_DRAM_DATA, value);\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nguspoke(iot, ioh2, address, value)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh2;\n\tlong address;\n\tunsigned char value;\n{\n\n\t/*\n\t * Select the DRAM address\n\t */\n\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_LOW);\n \tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, (unsigned int) (address & 0xffff));\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_HIGH);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, (unsigned char) ((address >> 16) & 0xff));\n\n\t/*\n\t * Actually write the data\n\t */\n\n\tbus_space_write_1(iot, ioh2, GUS_DRAM_DATA, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "guspeek",
          "args": [
            "iot",
            "ioh2",
            "sc->sc_gusaddr + sc->sc_chanblocksize - 1"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "guspeek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "2025-2046",
          "snippet": "unsigned char\nguspeek(iot, ioh2, address)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh2;\n\tu_long address;\n{\n\n\t/*\n\t * Select the DRAM address\n\t */\n\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_LOW);\n \tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, (unsigned int) (address & 0xffff));\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_HIGH);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, (unsigned char) ((address >> 16) & 0xff));\n\n\t/*\n\t * Read in the data from the board\n\t */\n\n\treturn (unsigned char) bus_space_read_1(iot, ioh2, GUS_DRAM_DATA);\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nunsigned char\nguspeek(iot, ioh2, address)\n\tbus_space_tag_t iot;\n\tbus_space_handle_t ioh2;\n\tu_long address;\n{\n\n\t/*\n\t * Select the DRAM address\n\t */\n\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_LOW);\n \tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, (unsigned int) (address & 0xffff));\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_HIGH);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, (unsigned char) ((address >> 16) & 0xff));\n\n\t/*\n\t * Read in the data from the board\n\t */\n\n\treturn (unsigned char) bus_space_read_1(iot, ioh2, GUS_DRAM_DATA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DMAPRINTF",
          "args": [
            "(\"gus_dmaout_dointr %d @ %p\\n\", sc->sc_dmaoutcnt,\n\t\t   sc->sc_dmaoutaddr)"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isa_dmadone",
          "args": [
            "sc->sc_dev.dv_parent",
            "sc->sc_drq"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "isa_dmadone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/isadma.c",
          "lines": "513-540",
          "snippet": "void\nisa_dmadone(isadev, chan)\n\tstruct device *isadev;\n\tint chan;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tbus_dmamap_t dmam;\n\n\tif (chan < 0 || chan > 7) {\n\t\tpanic(\"isa_dmadone: %s: bogus drq %d\", sc->sc_dev.dv_xname,\n\t\t    chan);\n\t}\n\n\tdmam = sc->sc_dmamaps[chan];\n\n\tisa_dmamask(sc, chan);\n\n\tif (isa_dmafinished(isadev, chan) == 0)\n\t\tprintf(\"%s: isa_dmadone: channel %d not finished\\n\",\n\t\t    sc->sc_dev.dv_xname, chan);\n\n\tbus_dmamap_sync(sc->sc_dmat, dmam,\n\t    (sc->sc_dmareads & (1 << chan)) ? BUS_DMASYNC_POSTREAD :\n\t    BUS_DMASYNC_POSTWRITE);\n\n\tbus_dmamap_unload(sc->sc_dmat, dmam);\n\tsc->sc_dmareads &= ~(1 << chan);\n}",
          "includes": [
            "#include <sys/malloc.h>",
            "#include <dev/isa/isadmareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void isa_dmamask",
            "void *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;",
            "int chan;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/malloc.h>\n#include <dev/isa/isadmareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic inline void isa_dmamask;\nvoid *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;\nint chan;\n\nvoid\nisa_dmadone(isadev, chan)\n\tstruct device *isadev;\n\tint chan;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\tbus_dmamap_t dmam;\n\n\tif (chan < 0 || chan > 7) {\n\t\tpanic(\"isa_dmadone: %s: bogus drq %d\", sc->sc_dev.dv_xname,\n\t\t    chan);\n\t}\n\n\tdmam = sc->sc_dmamaps[chan];\n\n\tisa_dmamask(sc, chan);\n\n\tif (isa_dmafinished(isadev, chan) == 0)\n\t\tprintf(\"%s: isa_dmadone: channel %d not finished\\n\",\n\t\t    sc->sc_dev.dv_xname, chan);\n\n\tbus_dmamap_sync(sc->sc_dmat, dmam,\n\t    (sc->sc_dmareads & (1 << chan)) ? BUS_DMASYNC_POSTREAD :\n\t    BUS_DMASYNC_POSTWRITE);\n\n\tbus_dmamap_unload(sc->sc_dmat, dmam);\n\tsc->sc_dmareads &= ~(1 << chan);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define NDMARECS 2048\n#define GUSPLAYDEBUG\t/*XXX*/\n\nint gus_bufcnt[GUS_MEM_FOR_BUFFERS / GUS_BUFFER_MULTIPLE];\nint gus_restart;\nstruct playcont {\n\tstruct timeval tv;\n\tu_int playbuf;\n\tu_int dmabuf;\n\tu_char bufcnt;\n\tu_char vaction;\n\tu_char voccntl;\n\tu_char volcntl;\n\tu_long curaddr;\n\tu_long endaddr;\n} playstats[NDMARECS];\nint playcntr;\n\nvoid\ngus_dmaout_dointr(sc)\n\tstruct gus_softc *sc;\n{\n \tbus_space_tag_t iot = sc->sc_iot;\n \tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\n\t/* sc->sc_dmaoutcnt - 1 because DMA controller counts from zero?. */\n \tisa_dmadone(sc->sc_dev.dv_parent, sc->sc_drq);\n\tsc->sc_flags &= ~GUS_DMAOUT_ACTIVE;  /* pending DMA is done */\n \tDMAPRINTF((\"gus_dmaout_dointr %d @ %p\\n\", sc->sc_dmaoutcnt,\n\t\t   sc->sc_dmaoutaddr));\n\n\t/*\n\t * to prevent clicking, we need to copy last sample\n\t * from last buffer to scratch area just before beginning of\n\t * buffer.  However, if we're doing formats that are converted by\n\t * the card during the DMA process, we need to pick up the converted\n\t * byte rather than the one we have in memory.\n\t */\n\tif (sc->sc_dmabuf == sc->sc_nbufs - 1) {\n\t  int i;\n\t  switch (sc->sc_encoding) {\n\t  case AUDIO_ENCODING_SLINEAR_LE:\n\t  case AUDIO_ENCODING_SLINEAR_BE:\n\t    if (sc->sc_precision == 8)\n\t      goto byte;\n\t    /* we have the native format */\n\t    for (i = 1; i <= 2; i++)\n\t      guspoke(iot, ioh2, sc->sc_gusaddr -\n\t\t      (sc->sc_nbufs - 1) * sc->sc_chanblocksize - i,\n\t\t      sc->sc_dmaoutaddr[sc->sc_dmaoutcnt-i]);\n\t    break;\n\t  case AUDIO_ENCODING_ULINEAR_LE:\n\t  case AUDIO_ENCODING_ULINEAR_BE:\n\t    guspoke(iot, ioh2, sc->sc_gusaddr -\n\t\t    (sc->sc_nbufs - 1) * sc->sc_chanblocksize - 2,\n\t\t    guspeek(iot, ioh2,\n\t\t\t    sc->sc_gusaddr + sc->sc_chanblocksize - 2));\n\t  case AUDIO_ENCODING_ALAW:\n\t  case AUDIO_ENCODING_ULAW:\n\t  byte:\n\t    /* we need to fetch the translated byte, then stuff it. */\n\t    guspoke(iot, ioh2, sc->sc_gusaddr -\n\t\t    (sc->sc_nbufs - 1) * sc->sc_chanblocksize - 1,\n\t\t    guspeek(iot, ioh2,\n\t\t\t    sc->sc_gusaddr + sc->sc_chanblocksize - 1));\n\t    break;\n\t  }\n\t}\n\t/*\n\t * If this is the first half of stereo, \"ignore\" this one\n\t * and copy out the second half.\n\t */\n\tif (sc->sc_dmaoutintr == stereo_dmaintr) {\n\t    (*sc->sc_dmaoutintr)(sc->sc_outarg);\n\t    return;\n\t}\n\t/*\n\t * If the voice is stopped, then start it.  Reset the loop\n\t * and roll bits.  Call the audio layer routine, since if\n\t * we're starting a stopped voice, that means that the next\n\t * buffer can be filled\n\t */\n\n\tsc->sc_flags &= ~GUS_LOCKED;\n\tif (sc->sc_voc[GUS_VOICE_LEFT].voccntl &\n\t    GUSMASK_VOICE_STOPPED) {\n\t    if (sc->sc_flags & GUS_PLAYING) {\n\t\tprintf(\"%s: playing yet stopped?\\n\", sc->sc_dev.dv_xname);\n\t    }\n\t    sc->sc_bufcnt++; /* another yet to be played */\n\t    gus_start_playing(sc, sc->sc_dmabuf);\n\t    gus_restart++;\n\t} else {\n\t    /*\n\t     * set the sound action based on which buffer we\n\t     * just transferred.  If we just transferred buffer 0\n\t     * we want the sound to loop when it gets to the nth\n\t     * buffer; if we just transferred\n\t     * any other buffer, we want the sound to roll over\n\t     * at least one more time.  The voice interrupt\n\t     * handlers will take care of accounting &\n\t     * setting control bits if it's not caught up to us\n\t     * yet.\n\t     */\n\t    if (++sc->sc_bufcnt == 2) {\n\t\t/*\n\t\t * XXX \n\t\t * If we're too slow in reaction here,\n\t\t * the voice could be just approaching the\n\t\t * end of its run.  It should be set to stop,\n\t\t * so these adjustments might not DTRT.\n\t\t */\n\t\tif (sc->sc_dmabuf == 0 &&\n\t\t    sc->sc_playbuf == sc->sc_nbufs - 1) {\n\t\t    /* player is just at the last buf, we're at the\n\t\t       first.  Turn on looping, turn off rolling. */\n\t\t    sc->sc_voc[GUS_VOICE_LEFT].voccntl |= GUSMASK_LOOP_ENABLE;\n\t\t    sc->sc_voc[GUS_VOICE_LEFT].volcntl &= ~GUSMASK_VOICE_ROLL;\n\t\t    playstats[playcntr].vaction = 3;\n\t\t} else {\n\t\t    /* player is at previous buf:\n\t\t       turn on rolling, turn off looping */\n\t\t    sc->sc_voc[GUS_VOICE_LEFT].voccntl &= ~GUSMASK_LOOP_ENABLE;\n\t\t    sc->sc_voc[GUS_VOICE_LEFT].volcntl |= GUSMASK_VOICE_ROLL;\n\t\t    playstats[playcntr].vaction = 4;\n\t\t}\n#ifdef GUSPLAYDEBUG\n\t\tif (gusstats) {\n\t\t  microtime(&playstats[playcntr].tv);\n\t\t  playstats[playcntr].endaddr = sc->sc_voc[GUS_VOICE_LEFT].end_addr;\n\t\t  playstats[playcntr].voccntl = sc->sc_voc[GUS_VOICE_LEFT].voccntl;\n\t\t  playstats[playcntr].volcntl = sc->sc_voc[GUS_VOICE_LEFT].volcntl;\n\t\t  playstats[playcntr].playbuf = sc->sc_playbuf;\n\t\t  playstats[playcntr].dmabuf = sc->sc_dmabuf;\n\t\t  playstats[playcntr].bufcnt = sc->sc_bufcnt;\n\t\t  playstats[playcntr].curaddr = gus_get_curaddr(sc, GUS_VOICE_LEFT);\n\t\t  playcntr = ++playcntr % NDMARECS;\n\t\t}\n#endif\n\t\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, GUS_VOICE_LEFT);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\t\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_LEFT].voccntl);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_CONTROL);\n\t\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_LEFT].volcntl);\n\t    }\n\t}\n\tgus_bufcnt[sc->sc_bufcnt-1]++;\n\t/*\n\t * flip to the next DMA buffer\n\t */\n\n\tsc->sc_dmabuf = ++sc->sc_dmabuf % sc->sc_nbufs; \n\t/*\n\t * See comments below about DMA admission control strategy.\n\t * We can call the upper level here if we have an\n\t * idle buffer (not currently playing) to DMA into.\n\t */\n\tif (sc->sc_dmaoutintr && sc->sc_bufcnt < sc->sc_nbufs) {\n\t    /* clean out to prevent double calls */\n\t    void (*pfunc) __P((void *)) = sc->sc_dmaoutintr;\n\t    void *arg = sc->sc_outarg;\n\n\t    sc->sc_outarg = 0;\n\t    sc->sc_dmaoutintr = 0;\n\t    (*pfunc)(arg);\n\t}\n}"
  },
  {
    "function_name": "gus_dmaout_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "758-777",
    "snippet": "int\ngus_dmaout_intr(sc)\n\tstruct gus_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\n\t/*\n\t * If we got a DMA transfer complete from the GUS DRAM, then deal\n\t * with it.\n\t */\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);\n \tif (bus_space_read_1(iot, ioh2, GUS_DATA_HIGH) & GUSMASK_DMA_IRQPEND) {\n\t    untimeout(gus_dmaout_timeout, sc);\n\t    gus_dmaout_dointr(sc);\n\t    return 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gus_dmaout_dointr",
          "args": [
            "sc"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "gus_dmaout_dointr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "779-927",
          "snippet": "void\ngus_dmaout_dointr(sc)\n\tstruct gus_softc *sc;\n{\n \tbus_space_tag_t iot = sc->sc_iot;\n \tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\n\t/* sc->sc_dmaoutcnt - 1 because DMA controller counts from zero?. */\n \tisa_dmadone(sc->sc_dev.dv_parent, sc->sc_drq);\n\tsc->sc_flags &= ~GUS_DMAOUT_ACTIVE;  /* pending DMA is done */\n \tDMAPRINTF((\"gus_dmaout_dointr %d @ %p\\n\", sc->sc_dmaoutcnt,\n\t\t   sc->sc_dmaoutaddr));\n\n\t/*\n\t * to prevent clicking, we need to copy last sample\n\t * from last buffer to scratch area just before beginning of\n\t * buffer.  However, if we're doing formats that are converted by\n\t * the card during the DMA process, we need to pick up the converted\n\t * byte rather than the one we have in memory.\n\t */\n\tif (sc->sc_dmabuf == sc->sc_nbufs - 1) {\n\t  int i;\n\t  switch (sc->sc_encoding) {\n\t  case AUDIO_ENCODING_SLINEAR_LE:\n\t  case AUDIO_ENCODING_SLINEAR_BE:\n\t    if (sc->sc_precision == 8)\n\t      goto byte;\n\t    /* we have the native format */\n\t    for (i = 1; i <= 2; i++)\n\t      guspoke(iot, ioh2, sc->sc_gusaddr -\n\t\t      (sc->sc_nbufs - 1) * sc->sc_chanblocksize - i,\n\t\t      sc->sc_dmaoutaddr[sc->sc_dmaoutcnt-i]);\n\t    break;\n\t  case AUDIO_ENCODING_ULINEAR_LE:\n\t  case AUDIO_ENCODING_ULINEAR_BE:\n\t    guspoke(iot, ioh2, sc->sc_gusaddr -\n\t\t    (sc->sc_nbufs - 1) * sc->sc_chanblocksize - 2,\n\t\t    guspeek(iot, ioh2,\n\t\t\t    sc->sc_gusaddr + sc->sc_chanblocksize - 2));\n\t  case AUDIO_ENCODING_ALAW:\n\t  case AUDIO_ENCODING_ULAW:\n\t  byte:\n\t    /* we need to fetch the translated byte, then stuff it. */\n\t    guspoke(iot, ioh2, sc->sc_gusaddr -\n\t\t    (sc->sc_nbufs - 1) * sc->sc_chanblocksize - 1,\n\t\t    guspeek(iot, ioh2,\n\t\t\t    sc->sc_gusaddr + sc->sc_chanblocksize - 1));\n\t    break;\n\t  }\n\t}\n\t/*\n\t * If this is the first half of stereo, \"ignore\" this one\n\t * and copy out the second half.\n\t */\n\tif (sc->sc_dmaoutintr == stereo_dmaintr) {\n\t    (*sc->sc_dmaoutintr)(sc->sc_outarg);\n\t    return;\n\t}\n\t/*\n\t * If the voice is stopped, then start it.  Reset the loop\n\t * and roll bits.  Call the audio layer routine, since if\n\t * we're starting a stopped voice, that means that the next\n\t * buffer can be filled\n\t */\n\n\tsc->sc_flags &= ~GUS_LOCKED;\n\tif (sc->sc_voc[GUS_VOICE_LEFT].voccntl &\n\t    GUSMASK_VOICE_STOPPED) {\n\t    if (sc->sc_flags & GUS_PLAYING) {\n\t\tprintf(\"%s: playing yet stopped?\\n\", sc->sc_dev.dv_xname);\n\t    }\n\t    sc->sc_bufcnt++; /* another yet to be played */\n\t    gus_start_playing(sc, sc->sc_dmabuf);\n\t    gus_restart++;\n\t} else {\n\t    /*\n\t     * set the sound action based on which buffer we\n\t     * just transferred.  If we just transferred buffer 0\n\t     * we want the sound to loop when it gets to the nth\n\t     * buffer; if we just transferred\n\t     * any other buffer, we want the sound to roll over\n\t     * at least one more time.  The voice interrupt\n\t     * handlers will take care of accounting &\n\t     * setting control bits if it's not caught up to us\n\t     * yet.\n\t     */\n\t    if (++sc->sc_bufcnt == 2) {\n\t\t/*\n\t\t * XXX \n\t\t * If we're too slow in reaction here,\n\t\t * the voice could be just approaching the\n\t\t * end of its run.  It should be set to stop,\n\t\t * so these adjustments might not DTRT.\n\t\t */\n\t\tif (sc->sc_dmabuf == 0 &&\n\t\t    sc->sc_playbuf == sc->sc_nbufs - 1) {\n\t\t    /* player is just at the last buf, we're at the\n\t\t       first.  Turn on looping, turn off rolling. */\n\t\t    sc->sc_voc[GUS_VOICE_LEFT].voccntl |= GUSMASK_LOOP_ENABLE;\n\t\t    sc->sc_voc[GUS_VOICE_LEFT].volcntl &= ~GUSMASK_VOICE_ROLL;\n\t\t    playstats[playcntr].vaction = 3;\n\t\t} else {\n\t\t    /* player is at previous buf:\n\t\t       turn on rolling, turn off looping */\n\t\t    sc->sc_voc[GUS_VOICE_LEFT].voccntl &= ~GUSMASK_LOOP_ENABLE;\n\t\t    sc->sc_voc[GUS_VOICE_LEFT].volcntl |= GUSMASK_VOICE_ROLL;\n\t\t    playstats[playcntr].vaction = 4;\n\t\t}\n#ifdef GUSPLAYDEBUG\n\t\tif (gusstats) {\n\t\t  microtime(&playstats[playcntr].tv);\n\t\t  playstats[playcntr].endaddr = sc->sc_voc[GUS_VOICE_LEFT].end_addr;\n\t\t  playstats[playcntr].voccntl = sc->sc_voc[GUS_VOICE_LEFT].voccntl;\n\t\t  playstats[playcntr].volcntl = sc->sc_voc[GUS_VOICE_LEFT].volcntl;\n\t\t  playstats[playcntr].playbuf = sc->sc_playbuf;\n\t\t  playstats[playcntr].dmabuf = sc->sc_dmabuf;\n\t\t  playstats[playcntr].bufcnt = sc->sc_bufcnt;\n\t\t  playstats[playcntr].curaddr = gus_get_curaddr(sc, GUS_VOICE_LEFT);\n\t\t  playcntr = ++playcntr % NDMARECS;\n\t\t}\n#endif\n\t\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, GUS_VOICE_LEFT);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\t\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_LEFT].voccntl);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_CONTROL);\n\t\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_LEFT].volcntl);\n\t    }\n\t}\n\tgus_bufcnt[sc->sc_bufcnt-1]++;\n\t/*\n\t * flip to the next DMA buffer\n\t */\n\n\tsc->sc_dmabuf = ++sc->sc_dmabuf % sc->sc_nbufs; \n\t/*\n\t * See comments below about DMA admission control strategy.\n\t * We can call the upper level here if we have an\n\t * idle buffer (not currently playing) to DMA into.\n\t */\n\tif (sc->sc_dmaoutintr && sc->sc_bufcnt < sc->sc_nbufs) {\n\t    /* clean out to prevent double calls */\n\t    void (*pfunc) __P((void *)) = sc->sc_dmaoutintr;\n\t    void *arg = sc->sc_outarg;\n\n\t    sc->sc_outarg = 0;\n\t    sc->sc_dmaoutintr = 0;\n\t    (*pfunc)(arg);\n\t}\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define NDMARECS 2048",
            "#define GUSPLAYDEBUG\t/*XXX*/"
          ],
          "globals_used": [
            "int gus_bufcnt[GUS_MEM_FOR_BUFFERS / GUS_BUFFER_MULTIPLE];",
            "int gus_restart;",
            "struct playcont {\n\tstruct timeval tv;\n\tu_int playbuf;\n\tu_int dmabuf;\n\tu_char bufcnt;\n\tu_char vaction;\n\tu_char voccntl;\n\tu_char volcntl;\n\tu_long curaddr;\n\tu_long endaddr;\n} playstats[NDMARECS];",
            "int playcntr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define NDMARECS 2048\n#define GUSPLAYDEBUG\t/*XXX*/\n\nint gus_bufcnt[GUS_MEM_FOR_BUFFERS / GUS_BUFFER_MULTIPLE];\nint gus_restart;\nstruct playcont {\n\tstruct timeval tv;\n\tu_int playbuf;\n\tu_int dmabuf;\n\tu_char bufcnt;\n\tu_char vaction;\n\tu_char voccntl;\n\tu_char volcntl;\n\tu_long curaddr;\n\tu_long endaddr;\n} playstats[NDMARECS];\nint playcntr;\n\nvoid\ngus_dmaout_dointr(sc)\n\tstruct gus_softc *sc;\n{\n \tbus_space_tag_t iot = sc->sc_iot;\n \tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\n\t/* sc->sc_dmaoutcnt - 1 because DMA controller counts from zero?. */\n \tisa_dmadone(sc->sc_dev.dv_parent, sc->sc_drq);\n\tsc->sc_flags &= ~GUS_DMAOUT_ACTIVE;  /* pending DMA is done */\n \tDMAPRINTF((\"gus_dmaout_dointr %d @ %p\\n\", sc->sc_dmaoutcnt,\n\t\t   sc->sc_dmaoutaddr));\n\n\t/*\n\t * to prevent clicking, we need to copy last sample\n\t * from last buffer to scratch area just before beginning of\n\t * buffer.  However, if we're doing formats that are converted by\n\t * the card during the DMA process, we need to pick up the converted\n\t * byte rather than the one we have in memory.\n\t */\n\tif (sc->sc_dmabuf == sc->sc_nbufs - 1) {\n\t  int i;\n\t  switch (sc->sc_encoding) {\n\t  case AUDIO_ENCODING_SLINEAR_LE:\n\t  case AUDIO_ENCODING_SLINEAR_BE:\n\t    if (sc->sc_precision == 8)\n\t      goto byte;\n\t    /* we have the native format */\n\t    for (i = 1; i <= 2; i++)\n\t      guspoke(iot, ioh2, sc->sc_gusaddr -\n\t\t      (sc->sc_nbufs - 1) * sc->sc_chanblocksize - i,\n\t\t      sc->sc_dmaoutaddr[sc->sc_dmaoutcnt-i]);\n\t    break;\n\t  case AUDIO_ENCODING_ULINEAR_LE:\n\t  case AUDIO_ENCODING_ULINEAR_BE:\n\t    guspoke(iot, ioh2, sc->sc_gusaddr -\n\t\t    (sc->sc_nbufs - 1) * sc->sc_chanblocksize - 2,\n\t\t    guspeek(iot, ioh2,\n\t\t\t    sc->sc_gusaddr + sc->sc_chanblocksize - 2));\n\t  case AUDIO_ENCODING_ALAW:\n\t  case AUDIO_ENCODING_ULAW:\n\t  byte:\n\t    /* we need to fetch the translated byte, then stuff it. */\n\t    guspoke(iot, ioh2, sc->sc_gusaddr -\n\t\t    (sc->sc_nbufs - 1) * sc->sc_chanblocksize - 1,\n\t\t    guspeek(iot, ioh2,\n\t\t\t    sc->sc_gusaddr + sc->sc_chanblocksize - 1));\n\t    break;\n\t  }\n\t}\n\t/*\n\t * If this is the first half of stereo, \"ignore\" this one\n\t * and copy out the second half.\n\t */\n\tif (sc->sc_dmaoutintr == stereo_dmaintr) {\n\t    (*sc->sc_dmaoutintr)(sc->sc_outarg);\n\t    return;\n\t}\n\t/*\n\t * If the voice is stopped, then start it.  Reset the loop\n\t * and roll bits.  Call the audio layer routine, since if\n\t * we're starting a stopped voice, that means that the next\n\t * buffer can be filled\n\t */\n\n\tsc->sc_flags &= ~GUS_LOCKED;\n\tif (sc->sc_voc[GUS_VOICE_LEFT].voccntl &\n\t    GUSMASK_VOICE_STOPPED) {\n\t    if (sc->sc_flags & GUS_PLAYING) {\n\t\tprintf(\"%s: playing yet stopped?\\n\", sc->sc_dev.dv_xname);\n\t    }\n\t    sc->sc_bufcnt++; /* another yet to be played */\n\t    gus_start_playing(sc, sc->sc_dmabuf);\n\t    gus_restart++;\n\t} else {\n\t    /*\n\t     * set the sound action based on which buffer we\n\t     * just transferred.  If we just transferred buffer 0\n\t     * we want the sound to loop when it gets to the nth\n\t     * buffer; if we just transferred\n\t     * any other buffer, we want the sound to roll over\n\t     * at least one more time.  The voice interrupt\n\t     * handlers will take care of accounting &\n\t     * setting control bits if it's not caught up to us\n\t     * yet.\n\t     */\n\t    if (++sc->sc_bufcnt == 2) {\n\t\t/*\n\t\t * XXX \n\t\t * If we're too slow in reaction here,\n\t\t * the voice could be just approaching the\n\t\t * end of its run.  It should be set to stop,\n\t\t * so these adjustments might not DTRT.\n\t\t */\n\t\tif (sc->sc_dmabuf == 0 &&\n\t\t    sc->sc_playbuf == sc->sc_nbufs - 1) {\n\t\t    /* player is just at the last buf, we're at the\n\t\t       first.  Turn on looping, turn off rolling. */\n\t\t    sc->sc_voc[GUS_VOICE_LEFT].voccntl |= GUSMASK_LOOP_ENABLE;\n\t\t    sc->sc_voc[GUS_VOICE_LEFT].volcntl &= ~GUSMASK_VOICE_ROLL;\n\t\t    playstats[playcntr].vaction = 3;\n\t\t} else {\n\t\t    /* player is at previous buf:\n\t\t       turn on rolling, turn off looping */\n\t\t    sc->sc_voc[GUS_VOICE_LEFT].voccntl &= ~GUSMASK_LOOP_ENABLE;\n\t\t    sc->sc_voc[GUS_VOICE_LEFT].volcntl |= GUSMASK_VOICE_ROLL;\n\t\t    playstats[playcntr].vaction = 4;\n\t\t}\n#ifdef GUSPLAYDEBUG\n\t\tif (gusstats) {\n\t\t  microtime(&playstats[playcntr].tv);\n\t\t  playstats[playcntr].endaddr = sc->sc_voc[GUS_VOICE_LEFT].end_addr;\n\t\t  playstats[playcntr].voccntl = sc->sc_voc[GUS_VOICE_LEFT].voccntl;\n\t\t  playstats[playcntr].volcntl = sc->sc_voc[GUS_VOICE_LEFT].volcntl;\n\t\t  playstats[playcntr].playbuf = sc->sc_playbuf;\n\t\t  playstats[playcntr].dmabuf = sc->sc_dmabuf;\n\t\t  playstats[playcntr].bufcnt = sc->sc_bufcnt;\n\t\t  playstats[playcntr].curaddr = gus_get_curaddr(sc, GUS_VOICE_LEFT);\n\t\t  playcntr = ++playcntr % NDMARECS;\n\t\t}\n#endif\n\t\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, GUS_VOICE_LEFT);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\t\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_LEFT].voccntl);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_CONTROL);\n\t\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_LEFT].volcntl);\n\t    }\n\t}\n\tgus_bufcnt[sc->sc_bufcnt-1]++;\n\t/*\n\t * flip to the next DMA buffer\n\t */\n\n\tsc->sc_dmabuf = ++sc->sc_dmabuf % sc->sc_nbufs; \n\t/*\n\t * See comments below about DMA admission control strategy.\n\t * We can call the upper level here if we have an\n\t * idle buffer (not currently playing) to DMA into.\n\t */\n\tif (sc->sc_dmaoutintr && sc->sc_bufcnt < sc->sc_nbufs) {\n\t    /* clean out to prevent double calls */\n\t    void (*pfunc) __P((void *)) = sc->sc_dmaoutintr;\n\t    void *arg = sc->sc_outarg;\n\n\t    sc->sc_outarg = 0;\n\t    sc->sc_dmaoutintr = 0;\n\t    (*pfunc)(arg);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "gus_dmaout_timeout",
            "sc"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_DMA_CONTROL"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngus_dmaout_intr(sc)\n\tstruct gus_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\n\t/*\n\t * If we got a DMA transfer complete from the GUS DRAM, then deal\n\t * with it.\n\t */\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);\n \tif (bus_space_read_1(iot, ioh2, GUS_DATA_HIGH) & GUSMASK_DMA_IRQPEND) {\n\t    untimeout(gus_dmaout_timeout, sc);\n\t    gus_dmaout_dointr(sc);\n\t    return 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "gus_dmaout_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "725-750",
    "snippet": "void\ngus_dmaout_timeout(arg)\n \tvoid *arg;\n{\n \tstruct gus_softc *sc = arg;\n \tbus_space_tag_t iot = sc->sc_iot;\n \tbus_space_handle_t ioh2 = sc->sc_ioh2;\n \tint s;\n\n \tprintf(\"%s: dmaout timeout\\n\", sc->sc_dev.dv_xname);\n \t/*\n \t * Stop any DMA.\n \t */\n\n \ts = splgus();\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0);\n \t\n#if 0\n \t/* XXX we will dmadone below? */\n \tisa_dmaabort(sc->sc_dev.dv_parent, sc->sc_drq);\n#endif\n \t\n \tgus_dmaout_dointr(sc);\n \tsplx(s);\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gus_dmaout_dointr",
          "args": [
            "sc"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "gus_dmaout_dointr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "779-927",
          "snippet": "void\ngus_dmaout_dointr(sc)\n\tstruct gus_softc *sc;\n{\n \tbus_space_tag_t iot = sc->sc_iot;\n \tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\n\t/* sc->sc_dmaoutcnt - 1 because DMA controller counts from zero?. */\n \tisa_dmadone(sc->sc_dev.dv_parent, sc->sc_drq);\n\tsc->sc_flags &= ~GUS_DMAOUT_ACTIVE;  /* pending DMA is done */\n \tDMAPRINTF((\"gus_dmaout_dointr %d @ %p\\n\", sc->sc_dmaoutcnt,\n\t\t   sc->sc_dmaoutaddr));\n\n\t/*\n\t * to prevent clicking, we need to copy last sample\n\t * from last buffer to scratch area just before beginning of\n\t * buffer.  However, if we're doing formats that are converted by\n\t * the card during the DMA process, we need to pick up the converted\n\t * byte rather than the one we have in memory.\n\t */\n\tif (sc->sc_dmabuf == sc->sc_nbufs - 1) {\n\t  int i;\n\t  switch (sc->sc_encoding) {\n\t  case AUDIO_ENCODING_SLINEAR_LE:\n\t  case AUDIO_ENCODING_SLINEAR_BE:\n\t    if (sc->sc_precision == 8)\n\t      goto byte;\n\t    /* we have the native format */\n\t    for (i = 1; i <= 2; i++)\n\t      guspoke(iot, ioh2, sc->sc_gusaddr -\n\t\t      (sc->sc_nbufs - 1) * sc->sc_chanblocksize - i,\n\t\t      sc->sc_dmaoutaddr[sc->sc_dmaoutcnt-i]);\n\t    break;\n\t  case AUDIO_ENCODING_ULINEAR_LE:\n\t  case AUDIO_ENCODING_ULINEAR_BE:\n\t    guspoke(iot, ioh2, sc->sc_gusaddr -\n\t\t    (sc->sc_nbufs - 1) * sc->sc_chanblocksize - 2,\n\t\t    guspeek(iot, ioh2,\n\t\t\t    sc->sc_gusaddr + sc->sc_chanblocksize - 2));\n\t  case AUDIO_ENCODING_ALAW:\n\t  case AUDIO_ENCODING_ULAW:\n\t  byte:\n\t    /* we need to fetch the translated byte, then stuff it. */\n\t    guspoke(iot, ioh2, sc->sc_gusaddr -\n\t\t    (sc->sc_nbufs - 1) * sc->sc_chanblocksize - 1,\n\t\t    guspeek(iot, ioh2,\n\t\t\t    sc->sc_gusaddr + sc->sc_chanblocksize - 1));\n\t    break;\n\t  }\n\t}\n\t/*\n\t * If this is the first half of stereo, \"ignore\" this one\n\t * and copy out the second half.\n\t */\n\tif (sc->sc_dmaoutintr == stereo_dmaintr) {\n\t    (*sc->sc_dmaoutintr)(sc->sc_outarg);\n\t    return;\n\t}\n\t/*\n\t * If the voice is stopped, then start it.  Reset the loop\n\t * and roll bits.  Call the audio layer routine, since if\n\t * we're starting a stopped voice, that means that the next\n\t * buffer can be filled\n\t */\n\n\tsc->sc_flags &= ~GUS_LOCKED;\n\tif (sc->sc_voc[GUS_VOICE_LEFT].voccntl &\n\t    GUSMASK_VOICE_STOPPED) {\n\t    if (sc->sc_flags & GUS_PLAYING) {\n\t\tprintf(\"%s: playing yet stopped?\\n\", sc->sc_dev.dv_xname);\n\t    }\n\t    sc->sc_bufcnt++; /* another yet to be played */\n\t    gus_start_playing(sc, sc->sc_dmabuf);\n\t    gus_restart++;\n\t} else {\n\t    /*\n\t     * set the sound action based on which buffer we\n\t     * just transferred.  If we just transferred buffer 0\n\t     * we want the sound to loop when it gets to the nth\n\t     * buffer; if we just transferred\n\t     * any other buffer, we want the sound to roll over\n\t     * at least one more time.  The voice interrupt\n\t     * handlers will take care of accounting &\n\t     * setting control bits if it's not caught up to us\n\t     * yet.\n\t     */\n\t    if (++sc->sc_bufcnt == 2) {\n\t\t/*\n\t\t * XXX \n\t\t * If we're too slow in reaction here,\n\t\t * the voice could be just approaching the\n\t\t * end of its run.  It should be set to stop,\n\t\t * so these adjustments might not DTRT.\n\t\t */\n\t\tif (sc->sc_dmabuf == 0 &&\n\t\t    sc->sc_playbuf == sc->sc_nbufs - 1) {\n\t\t    /* player is just at the last buf, we're at the\n\t\t       first.  Turn on looping, turn off rolling. */\n\t\t    sc->sc_voc[GUS_VOICE_LEFT].voccntl |= GUSMASK_LOOP_ENABLE;\n\t\t    sc->sc_voc[GUS_VOICE_LEFT].volcntl &= ~GUSMASK_VOICE_ROLL;\n\t\t    playstats[playcntr].vaction = 3;\n\t\t} else {\n\t\t    /* player is at previous buf:\n\t\t       turn on rolling, turn off looping */\n\t\t    sc->sc_voc[GUS_VOICE_LEFT].voccntl &= ~GUSMASK_LOOP_ENABLE;\n\t\t    sc->sc_voc[GUS_VOICE_LEFT].volcntl |= GUSMASK_VOICE_ROLL;\n\t\t    playstats[playcntr].vaction = 4;\n\t\t}\n#ifdef GUSPLAYDEBUG\n\t\tif (gusstats) {\n\t\t  microtime(&playstats[playcntr].tv);\n\t\t  playstats[playcntr].endaddr = sc->sc_voc[GUS_VOICE_LEFT].end_addr;\n\t\t  playstats[playcntr].voccntl = sc->sc_voc[GUS_VOICE_LEFT].voccntl;\n\t\t  playstats[playcntr].volcntl = sc->sc_voc[GUS_VOICE_LEFT].volcntl;\n\t\t  playstats[playcntr].playbuf = sc->sc_playbuf;\n\t\t  playstats[playcntr].dmabuf = sc->sc_dmabuf;\n\t\t  playstats[playcntr].bufcnt = sc->sc_bufcnt;\n\t\t  playstats[playcntr].curaddr = gus_get_curaddr(sc, GUS_VOICE_LEFT);\n\t\t  playcntr = ++playcntr % NDMARECS;\n\t\t}\n#endif\n\t\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, GUS_VOICE_LEFT);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\t\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_LEFT].voccntl);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_CONTROL);\n\t\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_LEFT].volcntl);\n\t    }\n\t}\n\tgus_bufcnt[sc->sc_bufcnt-1]++;\n\t/*\n\t * flip to the next DMA buffer\n\t */\n\n\tsc->sc_dmabuf = ++sc->sc_dmabuf % sc->sc_nbufs; \n\t/*\n\t * See comments below about DMA admission control strategy.\n\t * We can call the upper level here if we have an\n\t * idle buffer (not currently playing) to DMA into.\n\t */\n\tif (sc->sc_dmaoutintr && sc->sc_bufcnt < sc->sc_nbufs) {\n\t    /* clean out to prevent double calls */\n\t    void (*pfunc) __P((void *)) = sc->sc_dmaoutintr;\n\t    void *arg = sc->sc_outarg;\n\n\t    sc->sc_outarg = 0;\n\t    sc->sc_dmaoutintr = 0;\n\t    (*pfunc)(arg);\n\t}\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define NDMARECS 2048",
            "#define GUSPLAYDEBUG\t/*XXX*/"
          ],
          "globals_used": [
            "int gus_bufcnt[GUS_MEM_FOR_BUFFERS / GUS_BUFFER_MULTIPLE];",
            "int gus_restart;",
            "struct playcont {\n\tstruct timeval tv;\n\tu_int playbuf;\n\tu_int dmabuf;\n\tu_char bufcnt;\n\tu_char vaction;\n\tu_char voccntl;\n\tu_char volcntl;\n\tu_long curaddr;\n\tu_long endaddr;\n} playstats[NDMARECS];",
            "int playcntr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define NDMARECS 2048\n#define GUSPLAYDEBUG\t/*XXX*/\n\nint gus_bufcnt[GUS_MEM_FOR_BUFFERS / GUS_BUFFER_MULTIPLE];\nint gus_restart;\nstruct playcont {\n\tstruct timeval tv;\n\tu_int playbuf;\n\tu_int dmabuf;\n\tu_char bufcnt;\n\tu_char vaction;\n\tu_char voccntl;\n\tu_char volcntl;\n\tu_long curaddr;\n\tu_long endaddr;\n} playstats[NDMARECS];\nint playcntr;\n\nvoid\ngus_dmaout_dointr(sc)\n\tstruct gus_softc *sc;\n{\n \tbus_space_tag_t iot = sc->sc_iot;\n \tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\n\t/* sc->sc_dmaoutcnt - 1 because DMA controller counts from zero?. */\n \tisa_dmadone(sc->sc_dev.dv_parent, sc->sc_drq);\n\tsc->sc_flags &= ~GUS_DMAOUT_ACTIVE;  /* pending DMA is done */\n \tDMAPRINTF((\"gus_dmaout_dointr %d @ %p\\n\", sc->sc_dmaoutcnt,\n\t\t   sc->sc_dmaoutaddr));\n\n\t/*\n\t * to prevent clicking, we need to copy last sample\n\t * from last buffer to scratch area just before beginning of\n\t * buffer.  However, if we're doing formats that are converted by\n\t * the card during the DMA process, we need to pick up the converted\n\t * byte rather than the one we have in memory.\n\t */\n\tif (sc->sc_dmabuf == sc->sc_nbufs - 1) {\n\t  int i;\n\t  switch (sc->sc_encoding) {\n\t  case AUDIO_ENCODING_SLINEAR_LE:\n\t  case AUDIO_ENCODING_SLINEAR_BE:\n\t    if (sc->sc_precision == 8)\n\t      goto byte;\n\t    /* we have the native format */\n\t    for (i = 1; i <= 2; i++)\n\t      guspoke(iot, ioh2, sc->sc_gusaddr -\n\t\t      (sc->sc_nbufs - 1) * sc->sc_chanblocksize - i,\n\t\t      sc->sc_dmaoutaddr[sc->sc_dmaoutcnt-i]);\n\t    break;\n\t  case AUDIO_ENCODING_ULINEAR_LE:\n\t  case AUDIO_ENCODING_ULINEAR_BE:\n\t    guspoke(iot, ioh2, sc->sc_gusaddr -\n\t\t    (sc->sc_nbufs - 1) * sc->sc_chanblocksize - 2,\n\t\t    guspeek(iot, ioh2,\n\t\t\t    sc->sc_gusaddr + sc->sc_chanblocksize - 2));\n\t  case AUDIO_ENCODING_ALAW:\n\t  case AUDIO_ENCODING_ULAW:\n\t  byte:\n\t    /* we need to fetch the translated byte, then stuff it. */\n\t    guspoke(iot, ioh2, sc->sc_gusaddr -\n\t\t    (sc->sc_nbufs - 1) * sc->sc_chanblocksize - 1,\n\t\t    guspeek(iot, ioh2,\n\t\t\t    sc->sc_gusaddr + sc->sc_chanblocksize - 1));\n\t    break;\n\t  }\n\t}\n\t/*\n\t * If this is the first half of stereo, \"ignore\" this one\n\t * and copy out the second half.\n\t */\n\tif (sc->sc_dmaoutintr == stereo_dmaintr) {\n\t    (*sc->sc_dmaoutintr)(sc->sc_outarg);\n\t    return;\n\t}\n\t/*\n\t * If the voice is stopped, then start it.  Reset the loop\n\t * and roll bits.  Call the audio layer routine, since if\n\t * we're starting a stopped voice, that means that the next\n\t * buffer can be filled\n\t */\n\n\tsc->sc_flags &= ~GUS_LOCKED;\n\tif (sc->sc_voc[GUS_VOICE_LEFT].voccntl &\n\t    GUSMASK_VOICE_STOPPED) {\n\t    if (sc->sc_flags & GUS_PLAYING) {\n\t\tprintf(\"%s: playing yet stopped?\\n\", sc->sc_dev.dv_xname);\n\t    }\n\t    sc->sc_bufcnt++; /* another yet to be played */\n\t    gus_start_playing(sc, sc->sc_dmabuf);\n\t    gus_restart++;\n\t} else {\n\t    /*\n\t     * set the sound action based on which buffer we\n\t     * just transferred.  If we just transferred buffer 0\n\t     * we want the sound to loop when it gets to the nth\n\t     * buffer; if we just transferred\n\t     * any other buffer, we want the sound to roll over\n\t     * at least one more time.  The voice interrupt\n\t     * handlers will take care of accounting &\n\t     * setting control bits if it's not caught up to us\n\t     * yet.\n\t     */\n\t    if (++sc->sc_bufcnt == 2) {\n\t\t/*\n\t\t * XXX \n\t\t * If we're too slow in reaction here,\n\t\t * the voice could be just approaching the\n\t\t * end of its run.  It should be set to stop,\n\t\t * so these adjustments might not DTRT.\n\t\t */\n\t\tif (sc->sc_dmabuf == 0 &&\n\t\t    sc->sc_playbuf == sc->sc_nbufs - 1) {\n\t\t    /* player is just at the last buf, we're at the\n\t\t       first.  Turn on looping, turn off rolling. */\n\t\t    sc->sc_voc[GUS_VOICE_LEFT].voccntl |= GUSMASK_LOOP_ENABLE;\n\t\t    sc->sc_voc[GUS_VOICE_LEFT].volcntl &= ~GUSMASK_VOICE_ROLL;\n\t\t    playstats[playcntr].vaction = 3;\n\t\t} else {\n\t\t    /* player is at previous buf:\n\t\t       turn on rolling, turn off looping */\n\t\t    sc->sc_voc[GUS_VOICE_LEFT].voccntl &= ~GUSMASK_LOOP_ENABLE;\n\t\t    sc->sc_voc[GUS_VOICE_LEFT].volcntl |= GUSMASK_VOICE_ROLL;\n\t\t    playstats[playcntr].vaction = 4;\n\t\t}\n#ifdef GUSPLAYDEBUG\n\t\tif (gusstats) {\n\t\t  microtime(&playstats[playcntr].tv);\n\t\t  playstats[playcntr].endaddr = sc->sc_voc[GUS_VOICE_LEFT].end_addr;\n\t\t  playstats[playcntr].voccntl = sc->sc_voc[GUS_VOICE_LEFT].voccntl;\n\t\t  playstats[playcntr].volcntl = sc->sc_voc[GUS_VOICE_LEFT].volcntl;\n\t\t  playstats[playcntr].playbuf = sc->sc_playbuf;\n\t\t  playstats[playcntr].dmabuf = sc->sc_dmabuf;\n\t\t  playstats[playcntr].bufcnt = sc->sc_bufcnt;\n\t\t  playstats[playcntr].curaddr = gus_get_curaddr(sc, GUS_VOICE_LEFT);\n\t\t  playcntr = ++playcntr % NDMARECS;\n\t\t}\n#endif\n\t\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, GUS_VOICE_LEFT);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\t\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_LEFT].voccntl);\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_CONTROL);\n\t\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_LEFT].volcntl);\n\t    }\n\t}\n\tgus_bufcnt[sc->sc_bufcnt-1]++;\n\t/*\n\t * flip to the next DMA buffer\n\t */\n\n\tsc->sc_dmabuf = ++sc->sc_dmabuf % sc->sc_nbufs; \n\t/*\n\t * See comments below about DMA admission control strategy.\n\t * We can call the upper level here if we have an\n\t * idle buffer (not currently playing) to DMA into.\n\t */\n\tif (sc->sc_dmaoutintr && sc->sc_bufcnt < sc->sc_nbufs) {\n\t    /* clean out to prevent double calls */\n\t    void (*pfunc) __P((void *)) = sc->sc_dmaoutintr;\n\t    void *arg = sc->sc_outarg;\n\n\t    sc->sc_outarg = 0;\n\t    sc->sc_dmaoutintr = 0;\n\t    (*pfunc)(arg);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "isa_dmaabort",
          "args": [
            "sc->sc_dev.dv_parent",
            "sc->sc_drq"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "isa_dmaabort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/isadma.c",
          "lines": "424-439",
          "snippet": "void\nisa_dmaabort(isadev, chan)\n\tstruct device *isadev;\n\tint chan;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\n\tif (chan < 0 || chan > 7) {\n\t\tpanic(\"isa_dmaabort: %s: bogus drq %d\", sc->sc_dev.dv_xname,\n\t\t    chan);\n\t}\n\n\tisa_dmamask(sc, chan);\n\tbus_dmamap_unload(sc->sc_dmat, sc->sc_dmamaps[chan]);\n\tsc->sc_dmareads &= ~(1 << chan);\n}",
          "includes": [
            "#include <sys/malloc.h>",
            "#include <dev/isa/isadmareg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/isa/isareg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void isa_dmamask",
            "void *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;",
            "int chan;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/malloc.h>\n#include <dev/isa/isadmareg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/isa/isareg.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic inline void isa_dmamask;\nvoid *\nisa_malloc(isadev, chan, size, pool, flags)\n\tstruct device *isadev;\nint chan;\n\nvoid\nisa_dmaabort(isadev, chan)\n\tstruct device *isadev;\n\tint chan;\n{\n\tstruct isa_softc *sc = (struct isa_softc *)isadev;\n\n\tif (chan < 0 || chan > 7) {\n\t\tpanic(\"isa_dmaabort: %s: bogus drq %d\", sc->sc_dev.dv_xname,\n\t\t    chan);\n\t}\n\n\tisa_dmamask(sc, chan);\n\tbus_dmamap_unload(sc->sc_dmat, sc->sc_dmamaps[chan]);\n\tsc->sc_dmareads &= ~(1 << chan);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_write_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH",
            "0"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_DMA_CONTROL"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splgus",
          "args": [],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: dmaout timeout\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ngus_dmaout_timeout(arg)\n \tvoid *arg;\n{\n \tstruct gus_softc *sc = arg;\n \tbus_space_tag_t iot = sc->sc_iot;\n \tbus_space_handle_t ioh2 = sc->sc_ioh2;\n \tint s;\n\n \tprintf(\"%s: dmaout timeout\\n\", sc->sc_dev.dv_xname);\n \t/*\n \t * Stop any DMA.\n \t */\n\n \ts = splgus();\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0);\n \t\n#if 0\n \t/* XXX we will dmadone below? */\n \tisa_dmaabort(sc->sc_dev.dv_parent, sc->sc_drq);\n#endif\n \t\n \tgus_dmaout_dointr(sc);\n \tsplx(s);\n}"
  },
  {
    "function_name": "gusintr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "661-703",
    "snippet": "int\ngusintr(arg)\n\tvoid *arg;\n{\n\tstruct gus_softc *sc = arg;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh1 = sc->sc_ioh1;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tunsigned char intr;\n\n\tint retval = 0;\n\n\tDPRINTF((\"gusintr\\n\"));\n#ifdef DIAGNOSTIC\n\tgusintrcnt++;\n#endif\n\tif (HAS_CODEC(sc))\n\t\tretval = ad1848_intr(&sc->sc_codec);\n\tif ((intr = bus_space_read_1(iot, ioh1, GUS_IRQ_STATUS)) & GUSMASK_IRQ_DMATC) {\n\t\tDMAPRINTF((\"gusintr dma flags=%x\\n\", sc->sc_flags));\n#ifdef DIAGNOSTIC\n\t\tgusdmaintrcnt++;\n#endif\n\t\tretval += gus_dmaout_intr(sc);\n\t\tif (sc->sc_flags & GUS_DMAIN_ACTIVE) {\n\t\t    SELECT_GUS_REG(iot, ioh2, GUSREG_SAMPLE_CONTROL);\n\t\t    intr = bus_space_read_1(iot, ioh2, GUS_DATA_HIGH);\n\t\t    if (intr & GUSMASK_SAMPLE_DMATC) {\n\t\t\tretval += gus_dmain_intr(sc);\n\t\t    }\n\t\t}\n\t}\n\tif (intr & (GUSMASK_IRQ_VOICE | GUSMASK_IRQ_VOLUME)) {\n\t\tDMAPRINTF((\"gusintr voice flags=%x\\n\", sc->sc_flags));\n#ifdef DIAGNOSTIC\n\t\tgusvocintrcnt++;\n#endif\n\t\tretval += gus_voice_intr(sc);\n\t}\n\tif (retval)\n\t\treturn 1;\n\treturn retval;\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gus_voice_intr",
          "args": [
            "sc"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "gus_voice_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "933-1080",
          "snippet": "int\ngus_voice_intr(sc)\n\tstruct gus_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tint ignore = 0, voice, rval = 0;\n\tunsigned char intr, status;\n\n\t/*\n\t * The point of this may not be obvious at first.  A voice can\n\t * interrupt more than once; according to the GUS SDK we are supposed\n\t * to ignore multiple interrupts for the same voice.\n\t */\n\n\twhile(1) {\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_IRQ_STATUS);\n\t\tintr = bus_space_read_1(iot, ioh2, GUS_DATA_HIGH);\n\n\t\tif ((intr & (GUSMASK_WIRQ_VOLUME | GUSMASK_WIRQ_VOICE))\n\t\t\t== (GUSMASK_WIRQ_VOLUME | GUSMASK_WIRQ_VOICE))\n\t\t\t/*\n\t\t\t * No more interrupts, time to return\n\t\t\t */\n\t\t \treturn rval;\n\n\t\tif ((intr & GUSMASK_WIRQ_VOICE) == 0) {\n\n\t\t    /*\n\t\t     * We've got a voice interrupt.  Ignore previous\n\t\t     * interrupts by the same voice.\n\t\t     */\n\n\t\t    rval = 1;\n\t\t    voice = intr & GUSMASK_WIRQ_VOICEMASK;\n\n\t\t    if ((1 << voice) & ignore)\n\t\t\tbreak;\n\n\t\t    ignore |= 1 << voice;\n\n\t\t    /*\n\t\t     * If the voice is stopped, then force it to stop\n\t\t     * (this stops it from continuously generating IRQs)\n\t\t     */\n\n\t\t    SELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL+0x80);\n\t\t    status = bus_space_read_1(iot, ioh2, GUS_DATA_HIGH);\n\t\t    if (status & GUSMASK_VOICE_STOPPED) {\n\t\t\tif (voice != GUS_VOICE_LEFT) {\n\t\t\t    DMAPRINTF((\"%s: spurious voice %d stop?\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, voice));\n\t\t\t    gus_stop_voice(sc, voice, 0);\n\t\t\t    continue;\n\t\t\t}\n\t\t\tgus_stop_voice(sc, voice, 1);\n\t\t\t/* also kill right voice */\n\t\t\tgus_stop_voice(sc, GUS_VOICE_RIGHT, 0);\n\t\t\tsc->sc_bufcnt--; /* it finished a buffer */\n\t\t\tif (sc->sc_bufcnt > 0) {\n\t\t\t    /*\n\t\t\t     * probably a race to get here: the voice\n\t\t\t     * stopped while the DMA code was just trying to\n\t\t\t     * get the next buffer in place. \n\t\t\t     * Start the voice again.\n\t\t\t     */\n\t\t\t    printf(\"%s: stopped voice not drained? (%x)\\n\",\n\t\t\t\t   sc->sc_dev.dv_xname, sc->sc_bufcnt);\n\t\t\t    gus_falsestops++;\n\n\t\t\t    sc->sc_playbuf = ++sc->sc_playbuf % sc->sc_nbufs;\n\t\t\t    gus_start_playing(sc, sc->sc_playbuf);\n\t\t\t} else if (sc->sc_bufcnt < 0) {\n#ifdef DDB\n\t\t\t    printf(\"%s: negative bufcnt in stopped voice\\n\",\n\t\t\t\t   sc->sc_dev.dv_xname);\n\t\t\t    Debugger();\n#else\n\t\t\t    panic(\"%s: negative bufcnt in stopped voice\",\n\t\t\t\t  sc->sc_dev.dv_xname);\n#endif\n\t\t\t} else {\n\t\t\t    sc->sc_playbuf = -1; /* none are active */\n\t\t\t    gus_stops++;\n\t\t\t}\n\t\t\t/* fall through to callback and admit another\n\t\t\t   buffer.... */\n\t\t    } else if (sc->sc_bufcnt != 0) {\n\t\t\t/*\n\t\t\t * This should always be taken if the voice\n\t\t\t * is not stopped.\n\t\t\t */\n\t\t\tgus_continues++;\n\t\t\tif (gus_continue_playing(sc, voice)) {\n\t\t\t\t/*\n\t\t\t\t * we shouldn't have continued--active DMA\n\t\t\t\t * is in the way in the ring, for\n\t\t\t\t * some as-yet undebugged reason.\n\t\t\t\t */\n\t\t\t\tgus_stop_voice(sc, GUS_VOICE_LEFT, 1);\n\t\t\t\t/* also kill right voice */\n\t\t\t\tgus_stop_voice(sc, GUS_VOICE_RIGHT, 0);\n\t\t\t\tsc->sc_playbuf = -1;\n\t\t\t\tgus_stops++;\n\t\t\t}\n\t\t    }\n\t\t    /*\n\t\t     * call the upper level to send on down another\n\t\t     * block. We do admission rate control as follows:\n\t\t     *\n\t\t     * When starting up output (in the first N\n\t\t     * blocks), call the upper layer after the DMA is\n\t\t     * complete (see above in gus_dmaout_intr()).\n\t\t     *\n\t\t     * When output is already in progress and we have\n\t\t     * no more GUS buffers to use for DMA, the DMA\n\t\t     * output routines do not call the upper layer.\n\t\t     * Instead, we call the DMA completion routine\n\t\t     * here, after the voice interrupts indicating\n\t\t     * that it's finished with a buffer.\n\t\t     *\n\t\t     * However, don't call anything here if the DMA\n\t\t     * output flag is set, (which shouldn't happen)\n\t\t     * because we'll squish somebody else's DMA if\n\t\t     * that's the case.  When DMA is done, it will\n\t\t     * call back if there is a spare buffer.\n\t\t     */\n\t\t    if (sc->sc_dmaoutintr && !(sc->sc_flags & GUS_LOCKED)) {\n\t\t\tif (sc->sc_dmaoutintr == stereo_dmaintr)\n\t\t\t    printf(\"gusdmaout botch?\\n\");\n\t\t\telse {\n\t\t\t    /* clean out to avoid double calls */\n\t\t\t    void (*pfunc) __P((void *)) = sc->sc_dmaoutintr;\n\t\t\t    void *arg = sc->sc_outarg;\n\n\t\t\t    sc->sc_outarg = 0;\n\t\t\t    sc->sc_dmaoutintr = 0;\n\t\t\t    (*pfunc)(arg);\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t\t/*\n\t\t * Ignore other interrupts for now\n\t\t */\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int gus_stops;",
            "int gus_falsestops;",
            "int gus_continues;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint gus_stops;\nint gus_falsestops;\nint gus_continues;\n\nint\ngus_voice_intr(sc)\n\tstruct gus_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tint ignore = 0, voice, rval = 0;\n\tunsigned char intr, status;\n\n\t/*\n\t * The point of this may not be obvious at first.  A voice can\n\t * interrupt more than once; according to the GUS SDK we are supposed\n\t * to ignore multiple interrupts for the same voice.\n\t */\n\n\twhile(1) {\n\t\tSELECT_GUS_REG(iot, ioh2, GUSREG_IRQ_STATUS);\n\t\tintr = bus_space_read_1(iot, ioh2, GUS_DATA_HIGH);\n\n\t\tif ((intr & (GUSMASK_WIRQ_VOLUME | GUSMASK_WIRQ_VOICE))\n\t\t\t== (GUSMASK_WIRQ_VOLUME | GUSMASK_WIRQ_VOICE))\n\t\t\t/*\n\t\t\t * No more interrupts, time to return\n\t\t\t */\n\t\t \treturn rval;\n\n\t\tif ((intr & GUSMASK_WIRQ_VOICE) == 0) {\n\n\t\t    /*\n\t\t     * We've got a voice interrupt.  Ignore previous\n\t\t     * interrupts by the same voice.\n\t\t     */\n\n\t\t    rval = 1;\n\t\t    voice = intr & GUSMASK_WIRQ_VOICEMASK;\n\n\t\t    if ((1 << voice) & ignore)\n\t\t\tbreak;\n\n\t\t    ignore |= 1 << voice;\n\n\t\t    /*\n\t\t     * If the voice is stopped, then force it to stop\n\t\t     * (this stops it from continuously generating IRQs)\n\t\t     */\n\n\t\t    SELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL+0x80);\n\t\t    status = bus_space_read_1(iot, ioh2, GUS_DATA_HIGH);\n\t\t    if (status & GUSMASK_VOICE_STOPPED) {\n\t\t\tif (voice != GUS_VOICE_LEFT) {\n\t\t\t    DMAPRINTF((\"%s: spurious voice %d stop?\\n\",\n\t\t\t\t       sc->sc_dev.dv_xname, voice));\n\t\t\t    gus_stop_voice(sc, voice, 0);\n\t\t\t    continue;\n\t\t\t}\n\t\t\tgus_stop_voice(sc, voice, 1);\n\t\t\t/* also kill right voice */\n\t\t\tgus_stop_voice(sc, GUS_VOICE_RIGHT, 0);\n\t\t\tsc->sc_bufcnt--; /* it finished a buffer */\n\t\t\tif (sc->sc_bufcnt > 0) {\n\t\t\t    /*\n\t\t\t     * probably a race to get here: the voice\n\t\t\t     * stopped while the DMA code was just trying to\n\t\t\t     * get the next buffer in place. \n\t\t\t     * Start the voice again.\n\t\t\t     */\n\t\t\t    printf(\"%s: stopped voice not drained? (%x)\\n\",\n\t\t\t\t   sc->sc_dev.dv_xname, sc->sc_bufcnt);\n\t\t\t    gus_falsestops++;\n\n\t\t\t    sc->sc_playbuf = ++sc->sc_playbuf % sc->sc_nbufs;\n\t\t\t    gus_start_playing(sc, sc->sc_playbuf);\n\t\t\t} else if (sc->sc_bufcnt < 0) {\n#ifdef DDB\n\t\t\t    printf(\"%s: negative bufcnt in stopped voice\\n\",\n\t\t\t\t   sc->sc_dev.dv_xname);\n\t\t\t    Debugger();\n#else\n\t\t\t    panic(\"%s: negative bufcnt in stopped voice\",\n\t\t\t\t  sc->sc_dev.dv_xname);\n#endif\n\t\t\t} else {\n\t\t\t    sc->sc_playbuf = -1; /* none are active */\n\t\t\t    gus_stops++;\n\t\t\t}\n\t\t\t/* fall through to callback and admit another\n\t\t\t   buffer.... */\n\t\t    } else if (sc->sc_bufcnt != 0) {\n\t\t\t/*\n\t\t\t * This should always be taken if the voice\n\t\t\t * is not stopped.\n\t\t\t */\n\t\t\tgus_continues++;\n\t\t\tif (gus_continue_playing(sc, voice)) {\n\t\t\t\t/*\n\t\t\t\t * we shouldn't have continued--active DMA\n\t\t\t\t * is in the way in the ring, for\n\t\t\t\t * some as-yet undebugged reason.\n\t\t\t\t */\n\t\t\t\tgus_stop_voice(sc, GUS_VOICE_LEFT, 1);\n\t\t\t\t/* also kill right voice */\n\t\t\t\tgus_stop_voice(sc, GUS_VOICE_RIGHT, 0);\n\t\t\t\tsc->sc_playbuf = -1;\n\t\t\t\tgus_stops++;\n\t\t\t}\n\t\t    }\n\t\t    /*\n\t\t     * call the upper level to send on down another\n\t\t     * block. We do admission rate control as follows:\n\t\t     *\n\t\t     * When starting up output (in the first N\n\t\t     * blocks), call the upper layer after the DMA is\n\t\t     * complete (see above in gus_dmaout_intr()).\n\t\t     *\n\t\t     * When output is already in progress and we have\n\t\t     * no more GUS buffers to use for DMA, the DMA\n\t\t     * output routines do not call the upper layer.\n\t\t     * Instead, we call the DMA completion routine\n\t\t     * here, after the voice interrupts indicating\n\t\t     * that it's finished with a buffer.\n\t\t     *\n\t\t     * However, don't call anything here if the DMA\n\t\t     * output flag is set, (which shouldn't happen)\n\t\t     * because we'll squish somebody else's DMA if\n\t\t     * that's the case.  When DMA is done, it will\n\t\t     * call back if there is a spare buffer.\n\t\t     */\n\t\t    if (sc->sc_dmaoutintr && !(sc->sc_flags & GUS_LOCKED)) {\n\t\t\tif (sc->sc_dmaoutintr == stereo_dmaintr)\n\t\t\t    printf(\"gusdmaout botch?\\n\");\n\t\t\telse {\n\t\t\t    /* clean out to avoid double calls */\n\t\t\t    void (*pfunc) __P((void *)) = sc->sc_dmaoutintr;\n\t\t\t    void *arg = sc->sc_outarg;\n\n\t\t\t    sc->sc_outarg = 0;\n\t\t\t    sc->sc_dmaoutintr = 0;\n\t\t\t    (*pfunc)(arg);\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t\t/*\n\t\t * Ignore other interrupts for now\n\t\t */\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DMAPRINTF",
          "args": [
            "(\"gusintr voice flags=%x\\n\", sc->sc_flags)"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gus_dmain_intr",
          "args": [
            "sc"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "gus_dmain_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "2333-2359",
          "snippet": "int\ngus_dmain_intr(sc)\n\tstruct gus_softc *sc;\n{\n        void (*callback) __P((void *));\n\tvoid *arg;\n\n\tDMAPRINTF((\"gus_dmain_intr called\\n\"));\n\tif (sc->sc_dmainintr) {\n \t    isa_dmadone(sc->sc_dev.dv_parent, sc->sc_recdrq);\n\t    callback = sc->sc_dmainintr;\n\t    arg = sc->sc_inarg;\n\n\t    sc->sc_dmainaddr = 0;\n\t    sc->sc_dmaincnt = 0;\n\t    sc->sc_dmainintr = 0;\n\t    sc->sc_inarg = 0;\n\n\t    sc->sc_flags &= ~GUS_DMAIN_ACTIVE;\n\t    DMAPRINTF((\"calling dmain_intr callback %p(%p)\\n\", callback, arg));\n\t    (*callback)(arg);\n\t    return 1;\n\t} else {\n\t    DMAPRINTF((\"gus_dmain_intr false?\\n\"));\n\t    return 0;\t\t\t/* XXX ??? */\n\t}\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngus_dmain_intr(sc)\n\tstruct gus_softc *sc;\n{\n        void (*callback) __P((void *));\n\tvoid *arg;\n\n\tDMAPRINTF((\"gus_dmain_intr called\\n\"));\n\tif (sc->sc_dmainintr) {\n \t    isa_dmadone(sc->sc_dev.dv_parent, sc->sc_recdrq);\n\t    callback = sc->sc_dmainintr;\n\t    arg = sc->sc_inarg;\n\n\t    sc->sc_dmainaddr = 0;\n\t    sc->sc_dmaincnt = 0;\n\t    sc->sc_dmainintr = 0;\n\t    sc->sc_inarg = 0;\n\n\t    sc->sc_flags &= ~GUS_DMAIN_ACTIVE;\n\t    DMAPRINTF((\"calling dmain_intr callback %p(%p)\\n\", callback, arg));\n\t    (*callback)(arg);\n\t    return 1;\n\t} else {\n\t    DMAPRINTF((\"gus_dmain_intr false?\\n\"));\n\t    return 0;\t\t\t/* XXX ??? */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh2",
            "GUS_DATA_HIGH"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_GUS_REG",
          "args": [
            "iot",
            "ioh2",
            "GUSREG_SAMPLE_CONTROL"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gus_dmaout_intr",
          "args": [
            "sc"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "gus_dmaout_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "758-777",
          "snippet": "int\ngus_dmaout_intr(sc)\n\tstruct gus_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\n\t/*\n\t * If we got a DMA transfer complete from the GUS DRAM, then deal\n\t * with it.\n\t */\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);\n \tif (bus_space_read_1(iot, ioh2, GUS_DATA_HIGH) & GUSMASK_DMA_IRQPEND) {\n\t    untimeout(gus_dmaout_timeout, sc);\n\t    gus_dmaout_dointr(sc);\n\t    return 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngus_dmaout_intr(sc)\n\tstruct gus_softc *sc;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\n\t/*\n\t * If we got a DMA transfer complete from the GUS DRAM, then deal\n\t * with it.\n\t */\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);\n \tif (bus_space_read_1(iot, ioh2, GUS_DATA_HIGH) & GUSMASK_DMA_IRQPEND) {\n\t    untimeout(gus_dmaout_timeout, sc);\n\t    gus_dmaout_dointr(sc);\n\t    return 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DMAPRINTF",
          "args": [
            "(\"gusintr dma flags=%x\\n\", sc->sc_flags)"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "iot",
            "ioh1",
            "GUS_IRQ_STATUS"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ad1848_intr",
          "args": [
            "&sc->sc_codec"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "1607-1640",
          "snippet": "int\nad1848_intr(arg)\n\tvoid *arg;\n{\n    struct ad1848_softc *sc = arg;\n    int retval = 0;\n    u_char status;\n    \n    /* Get intr status */\n    status = ADREAD(sc, AD1848_STATUS);\n    \n#ifdef AUDIO_DEBUG\n    if (ad1848debug > 1)\n\tprintf(\"ad1848_intr: intr=%p status=%x\\n\", sc->sc_intr, status);\n#endif\n    sc->sc_locked = 0;\n    sc->sc_interrupts++;\n    \n    /* Handle interrupt */\n    if (sc->sc_intr && (status & INTERRUPT_STATUS)) {\n\t/* ACK DMA read because it may be in a bounce buffer */\n\t/* XXX Do write to mask DMA ? */\n\tif ((sc->sc_dma_flags & DMAMODE_READ) && sc->sc_recrun == NOTRUNNING)\n\t    isa_dmadone(sc->sc_isa, sc->sc_recdrq);\n\t(*sc->sc_intr)(sc->sc_arg);\n\tretval = 1;\n    }\n\n    /* clear interrupt */\n    if (status & INTERRUPT_STATUS)\n\tADWRITE(sc, AD1848_STATUS, 0);\n\n    return(retval);\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nad1848_intr(arg)\n\tvoid *arg;\n{\n    struct ad1848_softc *sc = arg;\n    int retval = 0;\n    u_char status;\n    \n    /* Get intr status */\n    status = ADREAD(sc, AD1848_STATUS);\n    \n#ifdef AUDIO_DEBUG\n    if (ad1848debug > 1)\n\tprintf(\"ad1848_intr: intr=%p status=%x\\n\", sc->sc_intr, status);\n#endif\n    sc->sc_locked = 0;\n    sc->sc_interrupts++;\n    \n    /* Handle interrupt */\n    if (sc->sc_intr && (status & INTERRUPT_STATUS)) {\n\t/* ACK DMA read because it may be in a bounce buffer */\n\t/* XXX Do write to mask DMA ? */\n\tif ((sc->sc_dma_flags & DMAMODE_READ) && sc->sc_recrun == NOTRUNNING)\n\t    isa_dmadone(sc->sc_isa, sc->sc_recdrq);\n\t(*sc->sc_intr)(sc->sc_arg);\n\tretval = 1;\n    }\n\n    /* clear interrupt */\n    if (status & INTERRUPT_STATUS)\n\tADWRITE(sc, AD1848_STATUS, 0);\n\n    return(retval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HAS_CODEC",
          "args": [
            "sc"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"gusintr\\n\")"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngusintr(arg)\n\tvoid *arg;\n{\n\tstruct gus_softc *sc = arg;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh1 = sc->sc_ioh1;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tunsigned char intr;\n\n\tint retval = 0;\n\n\tDPRINTF((\"gusintr\\n\"));\n#ifdef DIAGNOSTIC\n\tgusintrcnt++;\n#endif\n\tif (HAS_CODEC(sc))\n\t\tretval = ad1848_intr(&sc->sc_codec);\n\tif ((intr = bus_space_read_1(iot, ioh1, GUS_IRQ_STATUS)) & GUSMASK_IRQ_DMATC) {\n\t\tDMAPRINTF((\"gusintr dma flags=%x\\n\", sc->sc_flags));\n#ifdef DIAGNOSTIC\n\t\tgusdmaintrcnt++;\n#endif\n\t\tretval += gus_dmaout_intr(sc);\n\t\tif (sc->sc_flags & GUS_DMAIN_ACTIVE) {\n\t\t    SELECT_GUS_REG(iot, ioh2, GUSREG_SAMPLE_CONTROL);\n\t\t    intr = bus_space_read_1(iot, ioh2, GUS_DATA_HIGH);\n\t\t    if (intr & GUSMASK_SAMPLE_DMATC) {\n\t\t\tretval += gus_dmain_intr(sc);\n\t\t    }\n\t\t}\n\t}\n\tif (intr & (GUSMASK_IRQ_VOICE | GUSMASK_IRQ_VOLUME)) {\n\t\tDMAPRINTF((\"gusintr voice flags=%x\\n\", sc->sc_flags));\n#ifdef DIAGNOSTIC\n\t\tgusvocintrcnt++;\n#endif\n\t\tretval += gus_voice_intr(sc);\n\t}\n\tif (retval)\n\t\treturn 1;\n\treturn retval;\n}"
  },
  {
    "function_name": "gusclose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "622-648",
    "snippet": "void\ngusclose(addr)\n\tvoid *addr;\n{\n\tstruct gus_softc *sc = addr;\n\n        DPRINTF((\"gus_close: sc=%p\\n\", sc));\n\n\n/*\tif (sc->sc_flags & GUS_DMAOUT_ACTIVE) */ {\n\t\tgus_halt_out_dma(sc);\n\t}\n/*\tif (sc->sc_flags & GUS_DMAIN_ACTIVE) */ {\n\t\tgus_halt_in_dma(sc);\n\t}\n\tsc->sc_flags &= ~(GUS_OPEN|GUS_LOCKED|GUS_DMAOUT_ACTIVE|GUS_DMAIN_ACTIVE);\n\n\tif (sc->sc_deintr_buf) {\n\t\tFREE(sc->sc_deintr_buf, M_DEVBUF);\n\t\tsc->sc_deintr_buf = NULL;\n\t}\n\t/* turn off speaker, etc. */\n\n\t/* make sure the voices shut up: */\n\tgus_stop_voice(sc, GUS_VOICE_LEFT, 1);\n\tgus_stop_voice(sc, GUS_VOICE_RIGHT, 0);\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gus_stop_voice",
          "args": [
            "sc",
            "GUS_VOICE_RIGHT",
            "0"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "gus_stop_voice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "1435-1472",
          "snippet": "void\ngus_stop_voice(sc, voice, intrs_too)\n\tstruct gus_softc *sc;\n\tint voice;\n\tint intrs_too;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\n\tsc->sc_voc[voice].voccntl |= GUSMASK_VOICE_STOPPED |\n\t\tGUSMASK_STOP_VOICE;\n\tif (intrs_too) {\n\t  sc->sc_voc[voice].voccntl &= ~(GUSMASK_VOICE_IRQ);\n\t  /* no more DMA to do */\n\t  sc->sc_flags &= ~GUS_PLAYING;\n\t}\n\tDMAPRINTF((\"gusintr voice notplaying=%x\\n\", sc->sc_flags));\n\n\tguspoke(iot, ioh2, 0L, 0);\n\n\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, (unsigned char) voice);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_VOLUME);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].voccntl);\n\tdelay(100);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_VOLUME);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].voccntl);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_HIGH);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_LOW);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ngus_stop_voice(sc, voice, intrs_too)\n\tstruct gus_softc *sc;\n\tint voice;\n\tint intrs_too;\n{\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\n\tsc->sc_voc[voice].voccntl |= GUSMASK_VOICE_STOPPED |\n\t\tGUSMASK_STOP_VOICE;\n\tif (intrs_too) {\n\t  sc->sc_voc[voice].voccntl &= ~(GUSMASK_VOICE_IRQ);\n\t  /* no more DMA to do */\n\t  sc->sc_flags &= ~GUS_PLAYING;\n\t}\n\tDMAPRINTF((\"gusintr voice notplaying=%x\\n\", sc->sc_flags));\n\n\tguspoke(iot, ioh2, 0L, 0);\n\n\tbus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, (unsigned char) voice);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_VOLUME);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].voccntl);\n\tdelay(100);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_VOLUME);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].voccntl);\n\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_HIGH);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\tSELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_LOW);\n\tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "FREE",
          "args": [
            "sc->sc_deintr_buf",
            "M_DEVBUF"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gus_halt_in_dma",
          "args": [
            "sc"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "gus_halt_in_dma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "2417-2442",
          "snippet": "int\ngus_halt_in_dma(addr)\n\tvoid * addr;\n{\n \tstruct gus_softc *sc = addr;\n \tbus_space_tag_t iot = sc->sc_iot;\n \tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tDMAPRINTF((\"gus_halt_in_dma called\\n\"));\n\n\t/*\n\t * Make sure the GUS _isn't_ setup for DMA\n\t */\n\n  \tSELECT_GUS_REG(iot, ioh2, GUSREG_SAMPLE_CONTROL);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH,\n \t     bus_space_read_1(iot, ioh2, GUS_DATA_HIGH) & ~(GUSMASK_SAMPLE_START|GUSMASK_SAMPLE_IRQ));\n  \n \tisa_dmaabort(sc->sc_dev.dv_parent, sc->sc_recdrq);\n\tsc->sc_flags &= ~GUS_DMAIN_ACTIVE;\n\tsc->sc_dmainintr = 0;\n\tsc->sc_inarg = 0;\n\tsc->sc_dmainaddr = 0;\n\tsc->sc_dmaincnt = 0;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngus_halt_in_dma(addr)\n\tvoid * addr;\n{\n \tstruct gus_softc *sc = addr;\n \tbus_space_tag_t iot = sc->sc_iot;\n \tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\tDMAPRINTF((\"gus_halt_in_dma called\\n\"));\n\n\t/*\n\t * Make sure the GUS _isn't_ setup for DMA\n\t */\n\n  \tSELECT_GUS_REG(iot, ioh2, GUSREG_SAMPLE_CONTROL);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH,\n \t     bus_space_read_1(iot, ioh2, GUS_DATA_HIGH) & ~(GUSMASK_SAMPLE_START|GUSMASK_SAMPLE_IRQ));\n  \n \tisa_dmaabort(sc->sc_dev.dv_parent, sc->sc_recdrq);\n\tsc->sc_flags &= ~GUS_DMAIN_ACTIVE;\n\tsc->sc_dmainintr = 0;\n\tsc->sc_inarg = 0;\n\tsc->sc_dmainaddr = 0;\n\tsc->sc_dmaincnt = 0;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gus_halt_out_dma",
          "args": [
            "sc"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "gus_halt_out_dma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "2381-2412",
          "snippet": "int\ngus_halt_out_dma(addr)\n\tvoid * addr;\n{\n \tstruct gus_softc *sc = addr;\n \tbus_space_tag_t iot = sc->sc_iot;\n \tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\n\tDMAPRINTF((\"gus_halt_out_dma called\\n\"));\n\t/*\n\t * Make sure the GUS _isn't_ setup for DMA\n\t */\n\n  \tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0);\n\n\tuntimeout(gus_dmaout_timeout, sc);\n \tisa_dmaabort(sc->sc_dev.dv_parent, sc->sc_drq);\n\tsc->sc_flags &= ~(GUS_DMAOUT_ACTIVE|GUS_LOCKED);\n\tsc->sc_dmaoutintr = 0;\n\tsc->sc_outarg = 0;\n\tsc->sc_dmaoutaddr = 0;\n\tsc->sc_dmaoutcnt = 0;\n\tsc->sc_dmabuf = 0;\n\tsc->sc_bufcnt = 0;\n\tsc->sc_playbuf = -1;\n\t/* also stop playing */\n\tgus_stop_voice(sc, GUS_VOICE_LEFT, 1);\n\tgus_stop_voice(sc, GUS_VOICE_RIGHT, 0);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngus_halt_out_dma(addr)\n\tvoid * addr;\n{\n \tstruct gus_softc *sc = addr;\n \tbus_space_tag_t iot = sc->sc_iot;\n \tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\n\tDMAPRINTF((\"gus_halt_out_dma called\\n\"));\n\t/*\n\t * Make sure the GUS _isn't_ setup for DMA\n\t */\n\n  \tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);\n \tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0);\n\n\tuntimeout(gus_dmaout_timeout, sc);\n \tisa_dmaabort(sc->sc_dev.dv_parent, sc->sc_drq);\n\tsc->sc_flags &= ~(GUS_DMAOUT_ACTIVE|GUS_LOCKED);\n\tsc->sc_dmaoutintr = 0;\n\tsc->sc_outarg = 0;\n\tsc->sc_dmaoutaddr = 0;\n\tsc->sc_dmaoutcnt = 0;\n\tsc->sc_dmabuf = 0;\n\tsc->sc_bufcnt = 0;\n\tsc->sc_playbuf = -1;\n\t/* also stop playing */\n\tgus_stop_voice(sc, GUS_VOICE_LEFT, 1);\n\tgus_stop_voice(sc, GUS_VOICE_RIGHT, 0);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"gus_close: sc=%p\\n\", sc)"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ngusclose(addr)\n\tvoid *addr;\n{\n\tstruct gus_softc *sc = addr;\n\n        DPRINTF((\"gus_close: sc=%p\\n\", sc));\n\n\n/*\tif (sc->sc_flags & GUS_DMAOUT_ACTIVE) */ {\n\t\tgus_halt_out_dma(sc);\n\t}\n/*\tif (sc->sc_flags & GUS_DMAIN_ACTIVE) */ {\n\t\tgus_halt_in_dma(sc);\n\t}\n\tsc->sc_flags &= ~(GUS_OPEN|GUS_LOCKED|GUS_DMAOUT_ACTIVE|GUS_DMAIN_ACTIVE);\n\n\tif (sc->sc_deintr_buf) {\n\t\tFREE(sc->sc_deintr_buf, M_DEVBUF);\n\t\tsc->sc_deintr_buf = NULL;\n\t}\n\t/* turn off speaker, etc. */\n\n\t/* make sure the voices shut up: */\n\tgus_stop_voice(sc, GUS_VOICE_LEFT, 1);\n\tgus_stop_voice(sc, GUS_VOICE_RIGHT, 0);\n}"
  },
  {
    "function_name": "gusmax_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "605-617",
    "snippet": "void\ngusmax_close(addr)\n\tvoid *addr;\n{\n\tstruct ad1848_softc *ac = addr;\n\tstruct gus_softc *sc = ac->parent;\n#if 0\n\tac->mute[AD1848_AUX1_CHANNEL] = MUTE_ALL;\n\tad1848_mute_channel(ac, MUTE_ALL); /* turn off DAC output */\n#endif\n\tad1848_close(ac);\n\tgusclose(sc);\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gusclose",
          "args": [
            "sc"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "gusclose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "622-648",
          "snippet": "void\ngusclose(addr)\n\tvoid *addr;\n{\n\tstruct gus_softc *sc = addr;\n\n        DPRINTF((\"gus_close: sc=%p\\n\", sc));\n\n\n/*\tif (sc->sc_flags & GUS_DMAOUT_ACTIVE) */ {\n\t\tgus_halt_out_dma(sc);\n\t}\n/*\tif (sc->sc_flags & GUS_DMAIN_ACTIVE) */ {\n\t\tgus_halt_in_dma(sc);\n\t}\n\tsc->sc_flags &= ~(GUS_OPEN|GUS_LOCKED|GUS_DMAOUT_ACTIVE|GUS_DMAIN_ACTIVE);\n\n\tif (sc->sc_deintr_buf) {\n\t\tFREE(sc->sc_deintr_buf, M_DEVBUF);\n\t\tsc->sc_deintr_buf = NULL;\n\t}\n\t/* turn off speaker, etc. */\n\n\t/* make sure the voices shut up: */\n\tgus_stop_voice(sc, GUS_VOICE_LEFT, 1);\n\tgus_stop_voice(sc, GUS_VOICE_RIGHT, 0);\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ngusclose(addr)\n\tvoid *addr;\n{\n\tstruct gus_softc *sc = addr;\n\n        DPRINTF((\"gus_close: sc=%p\\n\", sc));\n\n\n/*\tif (sc->sc_flags & GUS_DMAOUT_ACTIVE) */ {\n\t\tgus_halt_out_dma(sc);\n\t}\n/*\tif (sc->sc_flags & GUS_DMAIN_ACTIVE) */ {\n\t\tgus_halt_in_dma(sc);\n\t}\n\tsc->sc_flags &= ~(GUS_OPEN|GUS_LOCKED|GUS_DMAOUT_ACTIVE|GUS_DMAIN_ACTIVE);\n\n\tif (sc->sc_deintr_buf) {\n\t\tFREE(sc->sc_deintr_buf, M_DEVBUF);\n\t\tsc->sc_deintr_buf = NULL;\n\t}\n\t/* turn off speaker, etc. */\n\n\t/* make sure the voices shut up: */\n\tgus_stop_voice(sc, GUS_VOICE_LEFT, 1);\n\tgus_stop_voice(sc, GUS_VOICE_RIGHT, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad1848_close",
          "args": [
            "ac"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "1193-1228",
          "snippet": "void\nad1848_close(addr)\n    void *addr;\n{\n    struct ad1848_softc *sc = addr;\n    u_char r;\n    \n    sc->sc_intr = 0;\n\n    DPRINTF((\"ad1848_close: stop DMA\\n\"));\n    if (sc->sc_playrun != NOTRUNNING) {\n\tisa_dmaabort(sc->sc_isa, sc->sc_drq);\n\tsc->sc_playrun = NOTRUNNING;\n    }\n    if (sc->sc_recrun != NOTRUNNING) {\n\tisa_dmaabort(sc->sc_isa, sc->sc_recdrq);\n\tsc->sc_recrun = NOTRUNNING;\n    }\n    ad_write(sc, SP_LOWER_BASE_COUNT, (u_char)0);\n    ad_write(sc, SP_UPPER_BASE_COUNT, (u_char)0);\n\n    /* Disable interrupts */\n    DPRINTF((\"ad1848_close: disable intrs\\n\"));\n    ad_write(sc, SP_PIN_CONTROL, \n\t     ad_read(sc, SP_PIN_CONTROL) & ~INTERRUPT_ENABLE);\n\n    DPRINTF((\"ad1848_close: disable capture and playback\\n\"));\n    r = ad_read(sc, SP_INTERFACE_CONFIG);\n    r &= ~(CAPTURE_ENABLE|PLAYBACK_ENABLE);\n    ad_write(sc, SP_INTERFACE_CONFIG, r);\n\n#ifdef AUDIO_DEBUG\n    if (ad1848debug)\n\tad1848_dump_regs(sc);\n#endif\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ad_read",
            "static void ad_write",
            "void *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\nstatic void ad_write;\nvoid *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;\n\nvoid\nad1848_close(addr)\n    void *addr;\n{\n    struct ad1848_softc *sc = addr;\n    u_char r;\n    \n    sc->sc_intr = 0;\n\n    DPRINTF((\"ad1848_close: stop DMA\\n\"));\n    if (sc->sc_playrun != NOTRUNNING) {\n\tisa_dmaabort(sc->sc_isa, sc->sc_drq);\n\tsc->sc_playrun = NOTRUNNING;\n    }\n    if (sc->sc_recrun != NOTRUNNING) {\n\tisa_dmaabort(sc->sc_isa, sc->sc_recdrq);\n\tsc->sc_recrun = NOTRUNNING;\n    }\n    ad_write(sc, SP_LOWER_BASE_COUNT, (u_char)0);\n    ad_write(sc, SP_UPPER_BASE_COUNT, (u_char)0);\n\n    /* Disable interrupts */\n    DPRINTF((\"ad1848_close: disable intrs\\n\"));\n    ad_write(sc, SP_PIN_CONTROL, \n\t     ad_read(sc, SP_PIN_CONTROL) & ~INTERRUPT_ENABLE);\n\n    DPRINTF((\"ad1848_close: disable capture and playback\\n\"));\n    r = ad_read(sc, SP_INTERFACE_CONFIG);\n    r &= ~(CAPTURE_ENABLE|PLAYBACK_ENABLE);\n    ad_write(sc, SP_INTERFACE_CONFIG, r);\n\n#ifdef AUDIO_DEBUG\n    if (ad1848debug)\n\tad1848_dump_regs(sc);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad1848_mute_channel",
          "args": [
            "ac",
            "MUTE_ALL"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_mute_channel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "607-640",
          "snippet": "void \nad1848_mute_channel(sc, device, mute) \n\tstruct ad1848_softc *sc;\n\tint device;\n\tint mute;\n{\n  u_char reg;\n\n  reg = ad_read(sc, mixer_channel_info[device].left_reg);\n\n  if (mute & MUTE_LEFT) {\n    if (device == AD1848_MONITOR_CHANNEL)\n        ad_write(sc, mixer_channel_info[device].left_reg, reg & 0xFE);\n    else\n        ad_write(sc, mixer_channel_info[device].left_reg, reg | 0x80);\n  } else if (!(sc->mute[device] & MUTE_LEFT)) {\n    if (device == AD1848_MONITOR_CHANNEL)\n        ad_write(sc, mixer_channel_info[device].left_reg, reg | 0x01);\n    else\n        ad_write(sc, mixer_channel_info[device].left_reg, reg & ~0x80);\n  }\n\n  if (!mixer_channel_info[device].right_reg) {\n    return;\n  }\n\n  reg = ad_read(sc, mixer_channel_info[device].right_reg);\n\n  if (mute & MUTE_RIGHT)\n    ad_write(sc, mixer_channel_info[device].right_reg, reg | 0x80);\n  else if (!(sc->mute[device] & MUTE_RIGHT)) {\n    ad_write(sc, mixer_channel_info[device].right_reg, reg & ~0x80);\n  }\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ad_read",
            "static void ad_write",
            "struct ad1848_mixerinfo {\n  int  left_reg;\n  int  right_reg;\n  int  atten_bits;\n  int  atten_mask;\n} mixer_channel_info[] = \n{ { SP_LEFT_AUX2_CONTROL, SP_RIGHT_AUX2_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_AUX1_CONTROL, SP_RIGHT_AUX1_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_OUTPUT_CONTROL, SP_RIGHT_OUTPUT_CONTROL, \n    OUTPUT_ATTEN_BITS, OUTPUT_ATTEN_MASK }, \n  { CS_LEFT_LINE_CONTROL, CS_RIGHT_LINE_CONTROL, LINE_INPUT_ATTEN_BITS,\n    LINE_INPUT_ATTEN_MASK },\n  { CS_MONO_IO_CONTROL, 0, MONO_INPUT_ATTEN_BITS, MONO_INPUT_ATTEN_MASK },\n  { SP_DIGITAL_MIX, 0, OUTPUT_ATTEN_BITS, MIX_ATTEN_MASK }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\nstatic void ad_write;\nstruct ad1848_mixerinfo {\n  int  left_reg;\n  int  right_reg;\n  int  atten_bits;\n  int  atten_mask;\n} mixer_channel_info[] = \n{ { SP_LEFT_AUX2_CONTROL, SP_RIGHT_AUX2_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_AUX1_CONTROL, SP_RIGHT_AUX1_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_OUTPUT_CONTROL, SP_RIGHT_OUTPUT_CONTROL, \n    OUTPUT_ATTEN_BITS, OUTPUT_ATTEN_MASK }, \n  { CS_LEFT_LINE_CONTROL, CS_RIGHT_LINE_CONTROL, LINE_INPUT_ATTEN_BITS,\n    LINE_INPUT_ATTEN_MASK },\n  { CS_MONO_IO_CONTROL, 0, MONO_INPUT_ATTEN_BITS, MONO_INPUT_ATTEN_MASK },\n  { SP_DIGITAL_MIX, 0, OUTPUT_ATTEN_BITS, MIX_ATTEN_MASK }\n};\n\nvoid \nad1848_mute_channel(sc, device, mute) \n\tstruct ad1848_softc *sc;\n\tint device;\n\tint mute;\n{\n  u_char reg;\n\n  reg = ad_read(sc, mixer_channel_info[device].left_reg);\n\n  if (mute & MUTE_LEFT) {\n    if (device == AD1848_MONITOR_CHANNEL)\n        ad_write(sc, mixer_channel_info[device].left_reg, reg & 0xFE);\n    else\n        ad_write(sc, mixer_channel_info[device].left_reg, reg | 0x80);\n  } else if (!(sc->mute[device] & MUTE_LEFT)) {\n    if (device == AD1848_MONITOR_CHANNEL)\n        ad_write(sc, mixer_channel_info[device].left_reg, reg | 0x01);\n    else\n        ad_write(sc, mixer_channel_info[device].left_reg, reg & ~0x80);\n  }\n\n  if (!mixer_channel_info[device].right_reg) {\n    return;\n  }\n\n  reg = ad_read(sc, mixer_channel_info[device].right_reg);\n\n  if (mute & MUTE_RIGHT)\n    ad_write(sc, mixer_channel_info[device].right_reg, reg | 0x80);\n  else if (!(sc->mute[device] & MUTE_RIGHT)) {\n    ad_write(sc, mixer_channel_info[device].right_reg, reg & ~0x80);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ngusmax_close(addr)\n\tvoid *addr;\n{\n\tstruct ad1848_softc *ac = addr;\n\tstruct gus_softc *sc = ac->parent;\n#if 0\n\tac->mute[AD1848_AUX1_CHANNEL] = MUTE_ALL;\n\tad1848_mute_channel(ac, MUTE_ALL); /* turn off DAC output */\n#endif\n\tad1848_close(ac);\n\tgusclose(sc);\n}"
  },
  {
    "function_name": "gus_dma_output",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "521-603",
    "snippet": "int\ngus_dma_output(addr, buf, size, intr, arg)\n\tvoid * addr;\n\tvoid *buf;\n\tint size;\n\tvoid (*intr) __P((void *));\n\tvoid *arg;\n{\n\tstruct gus_softc *sc = addr;\n\tu_char *buffer = buf;\n\tu_long boarddma;\n\tint flags;\n\n\tDMAPRINTF((\"gus_dma_output %d @ %p\\n\", size, buf));\n\n\tif (size != sc->sc_blocksize) {\n\t    DPRINTF((\"gus_dma_output reqsize %d not sc_blocksize %d\\n\",\n\t\t     size, sc->sc_blocksize));\n\t    return EINVAL;\n\t}\n\n\tflags = GUSMASK_DMA_WRITE;\n\tif (sc->sc_precision == 16)\n\t    flags |= GUSMASK_DMA_DATA_SIZE; \n\tif (sc->sc_encoding == AUDIO_ENCODING_ULAW ||\n\t    sc->sc_encoding == AUDIO_ENCODING_ALAW ||\n\t    sc->sc_encoding == AUDIO_ENCODING_ULINEAR_BE ||\n\t    sc->sc_encoding == AUDIO_ENCODING_ULINEAR_LE)\n\t    flags |= GUSMASK_DMA_INVBIT;\n\n\tif (sc->sc_channels == 2) {\n\t\tif (sc->sc_precision == 16) {\n\t\t\tif (size & 3) {\n\t\t\t\tDPRINTF((\"gus_dma_output: unpaired 16bit samples\"));\n\t\t\t\tsize &= 3;\n\t\t\t}\n\t\t} else if (size & 1) {\n\t\t\tDPRINTF((\"gus_dma_output: unpaired samples\"));\n\t\t\tsize &= 1;\n\t\t}\n\t\tif (size == 0)\n\t\t\treturn 0;\n\n\t\tgus_deinterleave(sc, (void *)buffer, size);\n\n\t\tsize >>= 1;\n\n \t\tboarddma = size * sc->sc_dmabuf + GUS_MEM_OFFSET;\n\n\t\tsc->sc_stereo.intr = intr;\n\t\tsc->sc_stereo.arg = arg;\n\t\tsc->sc_stereo.size = size;\n\t\tsc->sc_stereo.dmabuf = boarddma + GUS_LEFT_RIGHT_OFFSET;\n\t\tsc->sc_stereo.buffer = buffer + size;\n\t\tsc->sc_stereo.flags = flags;\n\t\tif (gus_dostereo) {\n\t\t  intr = stereo_dmaintr;\n\t\t  arg = sc;\n\t\t}\n\t} else\n\t\tboarddma = size * sc->sc_dmabuf + GUS_MEM_OFFSET;\n\n\n\tsc->sc_flags |= GUS_LOCKED;\n\tsc->sc_dmaoutintr = intr;\n\tsc->sc_outarg = arg;\n\n#ifdef GUSPLAYDEBUG\n\tif (gusstats) {\n\t  microtime(&dmarecords[dmarecord_index].tv);\n\t  dmarecords[dmarecord_index].gusaddr = boarddma;\n\t  dmarecords[dmarecord_index].bsdaddr = buffer;\n\t  dmarecords[dmarecord_index].count = size;\n\t  dmarecords[dmarecord_index].channel = 0;\n\t  dmarecords[dmarecord_index].direction = 1;\n\t  dmarecord_index = ++dmarecord_index % NDMARECS;\n\t}\n#endif\n\n\tgusdmaout(sc, flags, boarddma, (caddr_t) buffer, size);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define NDMARECS 2048",
      "#define GUSPLAYDEBUG\t/*XXX*/"
    ],
    "globals_used": [
      "int\tgus_dostereo = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gusdmaout",
          "args": [
            "sc",
            "flags",
            "boarddma",
            "(caddr_t) buffer",
            "size"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "gusdmaout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "1263-1331",
          "snippet": "void\ngusdmaout(sc, flags, gusaddr, buffaddr, length)\n\tstruct gus_softc *sc;\n\tint flags, length;\n\tu_long gusaddr;\n\tcaddr_t buffaddr;\n{\n\tunsigned char c = (unsigned char) flags;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\n\tDMAPRINTF((\"gusdmaout flags=%x scflags=%x\\n\", flags, sc->sc_flags));\n\n\tsc->sc_gusaddr = gusaddr;\n\n\t/*\n\t * If we're using a 16 bit DMA channel, we have to jump through some\n\t * extra hoops; this includes translating the DRAM address a bit\n\t */\n\n\tif (sc->sc_drq >= 4) {\n\t\tc |= GUSMASK_DMA_WIDTH;\n\t\tgusaddr = convert_to_16bit(gusaddr);\n\t}\n\n\t/*\n\t * Add flag bits that we always set - fast DMA, enable IRQ\n\t */\n\n\tc |= GUSMASK_DMA_ENABLE | GUSMASK_DMA_R0 | GUSMASK_DMA_IRQ;\n\n\t/*\n\t * Make sure the GUS _isn't_ setup for DMA\n\t */\n\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0);\n\n\t/*\n\t * Tell the PC DMA controller to start doing DMA\n\t */\n\n\tsc->sc_dmaoutaddr = (u_char *) buffaddr;\n\tsc->sc_dmaoutcnt = length;\n \tisa_dmastart(sc->sc_dev.dv_parent, sc->sc_drq, buffaddr, length,\n \t    NULL, DMAMODE_WRITE, BUS_DMA_NOWAIT);\n\n\t/*\n\t * Set up DMA address - use the upper 16 bits ONLY\n\t */\n\n\tsc->sc_flags |= GUS_DMAOUT_ACTIVE;\n\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_START);\n \tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, (int) (gusaddr >> 4));\n\n \t/*\n \t * Tell the GUS to start doing DMA\n \t */\n\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, c);\n\n\t/*\n\t * XXX If we don't finish in one second, give up...\n\t */\n\tuntimeout(gus_dmaout_timeout, sc); /* flush old one, if there is one */\n\ttimeout(gus_dmaout_timeout, sc, hz);\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ngusdmaout(sc, flags, gusaddr, buffaddr, length)\n\tstruct gus_softc *sc;\n\tint flags, length;\n\tu_long gusaddr;\n\tcaddr_t buffaddr;\n{\n\tunsigned char c = (unsigned char) flags;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\n\tDMAPRINTF((\"gusdmaout flags=%x scflags=%x\\n\", flags, sc->sc_flags));\n\n\tsc->sc_gusaddr = gusaddr;\n\n\t/*\n\t * If we're using a 16 bit DMA channel, we have to jump through some\n\t * extra hoops; this includes translating the DRAM address a bit\n\t */\n\n\tif (sc->sc_drq >= 4) {\n\t\tc |= GUSMASK_DMA_WIDTH;\n\t\tgusaddr = convert_to_16bit(gusaddr);\n\t}\n\n\t/*\n\t * Add flag bits that we always set - fast DMA, enable IRQ\n\t */\n\n\tc |= GUSMASK_DMA_ENABLE | GUSMASK_DMA_R0 | GUSMASK_DMA_IRQ;\n\n\t/*\n\t * Make sure the GUS _isn't_ setup for DMA\n\t */\n\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0);\n\n\t/*\n\t * Tell the PC DMA controller to start doing DMA\n\t */\n\n\tsc->sc_dmaoutaddr = (u_char *) buffaddr;\n\tsc->sc_dmaoutcnt = length;\n \tisa_dmastart(sc->sc_dev.dv_parent, sc->sc_drq, buffaddr, length,\n \t    NULL, DMAMODE_WRITE, BUS_DMA_NOWAIT);\n\n\t/*\n\t * Set up DMA address - use the upper 16 bits ONLY\n\t */\n\n\tsc->sc_flags |= GUS_DMAOUT_ACTIVE;\n\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_START);\n \tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, (int) (gusaddr >> 4));\n\n \t/*\n \t * Tell the GUS to start doing DMA\n \t */\n\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, c);\n\n\t/*\n\t * XXX If we don't finish in one second, give up...\n\t */\n\tuntimeout(gus_dmaout_timeout, sc); /* flush old one, if there is one */\n\ttimeout(gus_dmaout_timeout, sc, hz);\n}"
        }
      },
      {
        "call_info": {
          "callee": "microtime",
          "args": [
            "&dmarecords[dmarecord_index].tv"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gus_deinterleave",
          "args": [
            "sc",
            "(void *)buffer",
            "size"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "gus_deinterleave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "407-457",
          "snippet": "void\ngus_deinterleave(sc, buf, size)\n\tstruct gus_softc *sc;\n\tvoid *buf;\n\tint size;\n{\n\t/* deinterleave the stereo data.  We can use sc->sc_deintr_buf\n\t   for scratch space. */\n\tint i;\n\n\tif (size > sc->sc_blocksize) {\n\t\tprintf(\"gus: deinterleave %d > %d\\n\", size, sc->sc_blocksize);\n\t\treturn;\n\t} else if (size < sc->sc_blocksize) {\n\t\tDPRINTF((\"gus: deinterleave %d < %d\\n\", size, sc->sc_blocksize));\n\t}\n\n\t/*\n\t * size is in bytes.\n\t */\n\tif (sc->sc_precision == 16) {\n\t\tu_short *dei = sc->sc_deintr_buf;\n\t\tu_short *sbuf = buf;\n\t\tsize >>= 1;\t\t/* bytecnt to shortcnt */\n\t\t/* copy 2nd of each pair of samples to the staging area, while\n\t\t   compacting the 1st of each pair into the original area. */\n\t\tfor (i = 0; i < size/2-1; i++)  {\n\t\t\tdei[i] = sbuf[i*2+1];\n\t\t\tsbuf[i+1] = sbuf[i*2+2];\n\t\t}\n\t\t/*\n\t\t * this has copied one less sample than half of the\n\t\t * buffer.  The first sample of the 1st stream was\n\t\t * already in place and didn't need copying.\n\t\t * Therefore, we've moved all of the 1st stream's\n\t\t * samples into place.  We have one sample from 2nd\n\t\t * stream in the last slot of original area, not\n\t\t * copied to the staging area (But we don't need to!).\n\t\t * Copy the remainder of the original stream into place.\n\t\t */\n\t\tbcopy(dei, &sbuf[size/2], i * sizeof(short));\n\t} else {\n\t\tu_char *dei = sc->sc_deintr_buf;\n\t\tu_char *sbuf = buf;\n\t\tfor (i = 0; i < size/2-1; i++)  {\n\t\t\tdei[i] = sbuf[i*2+1];\n\t\t\tsbuf[i+1] = sbuf[i*2+2];\n\t\t}\n\t\tbcopy(dei, &sbuf[size/2], i);\n\t}\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ngus_deinterleave(sc, buf, size)\n\tstruct gus_softc *sc;\n\tvoid *buf;\n\tint size;\n{\n\t/* deinterleave the stereo data.  We can use sc->sc_deintr_buf\n\t   for scratch space. */\n\tint i;\n\n\tif (size > sc->sc_blocksize) {\n\t\tprintf(\"gus: deinterleave %d > %d\\n\", size, sc->sc_blocksize);\n\t\treturn;\n\t} else if (size < sc->sc_blocksize) {\n\t\tDPRINTF((\"gus: deinterleave %d < %d\\n\", size, sc->sc_blocksize));\n\t}\n\n\t/*\n\t * size is in bytes.\n\t */\n\tif (sc->sc_precision == 16) {\n\t\tu_short *dei = sc->sc_deintr_buf;\n\t\tu_short *sbuf = buf;\n\t\tsize >>= 1;\t\t/* bytecnt to shortcnt */\n\t\t/* copy 2nd of each pair of samples to the staging area, while\n\t\t   compacting the 1st of each pair into the original area. */\n\t\tfor (i = 0; i < size/2-1; i++)  {\n\t\t\tdei[i] = sbuf[i*2+1];\n\t\t\tsbuf[i+1] = sbuf[i*2+2];\n\t\t}\n\t\t/*\n\t\t * this has copied one less sample than half of the\n\t\t * buffer.  The first sample of the 1st stream was\n\t\t * already in place and didn't need copying.\n\t\t * Therefore, we've moved all of the 1st stream's\n\t\t * samples into place.  We have one sample from 2nd\n\t\t * stream in the last slot of original area, not\n\t\t * copied to the staging area (But we don't need to!).\n\t\t * Copy the remainder of the original stream into place.\n\t\t */\n\t\tbcopy(dei, &sbuf[size/2], i * sizeof(short));\n\t} else {\n\t\tu_char *dei = sc->sc_deintr_buf;\n\t\tu_char *sbuf = buf;\n\t\tfor (i = 0; i < size/2-1; i++)  {\n\t\t\tdei[i] = sbuf[i*2+1];\n\t\t\tsbuf[i+1] = sbuf[i*2+2];\n\t\t}\n\t\tbcopy(dei, &sbuf[size/2], i);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"gus_dma_output: unpaired samples\")"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"gus_dma_output: unpaired 16bit samples\")"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"gus_dma_output reqsize %d not sc_blocksize %d\\n\",\n\t\t     size, sc->sc_blocksize)"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMAPRINTF",
          "args": [
            "(\"gus_dma_output %d @ %p\\n\", size, buf)"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define NDMARECS 2048\n#define GUSPLAYDEBUG\t/*XXX*/\n\nint\tgus_dostereo = 1;\n\nint\ngus_dma_output(addr, buf, size, intr, arg)\n\tvoid * addr;\n\tvoid *buf;\n\tint size;\n\tvoid (*intr) __P((void *));\n\tvoid *arg;\n{\n\tstruct gus_softc *sc = addr;\n\tu_char *buffer = buf;\n\tu_long boarddma;\n\tint flags;\n\n\tDMAPRINTF((\"gus_dma_output %d @ %p\\n\", size, buf));\n\n\tif (size != sc->sc_blocksize) {\n\t    DPRINTF((\"gus_dma_output reqsize %d not sc_blocksize %d\\n\",\n\t\t     size, sc->sc_blocksize));\n\t    return EINVAL;\n\t}\n\n\tflags = GUSMASK_DMA_WRITE;\n\tif (sc->sc_precision == 16)\n\t    flags |= GUSMASK_DMA_DATA_SIZE; \n\tif (sc->sc_encoding == AUDIO_ENCODING_ULAW ||\n\t    sc->sc_encoding == AUDIO_ENCODING_ALAW ||\n\t    sc->sc_encoding == AUDIO_ENCODING_ULINEAR_BE ||\n\t    sc->sc_encoding == AUDIO_ENCODING_ULINEAR_LE)\n\t    flags |= GUSMASK_DMA_INVBIT;\n\n\tif (sc->sc_channels == 2) {\n\t\tif (sc->sc_precision == 16) {\n\t\t\tif (size & 3) {\n\t\t\t\tDPRINTF((\"gus_dma_output: unpaired 16bit samples\"));\n\t\t\t\tsize &= 3;\n\t\t\t}\n\t\t} else if (size & 1) {\n\t\t\tDPRINTF((\"gus_dma_output: unpaired samples\"));\n\t\t\tsize &= 1;\n\t\t}\n\t\tif (size == 0)\n\t\t\treturn 0;\n\n\t\tgus_deinterleave(sc, (void *)buffer, size);\n\n\t\tsize >>= 1;\n\n \t\tboarddma = size * sc->sc_dmabuf + GUS_MEM_OFFSET;\n\n\t\tsc->sc_stereo.intr = intr;\n\t\tsc->sc_stereo.arg = arg;\n\t\tsc->sc_stereo.size = size;\n\t\tsc->sc_stereo.dmabuf = boarddma + GUS_LEFT_RIGHT_OFFSET;\n\t\tsc->sc_stereo.buffer = buffer + size;\n\t\tsc->sc_stereo.flags = flags;\n\t\tif (gus_dostereo) {\n\t\t  intr = stereo_dmaintr;\n\t\t  arg = sc;\n\t\t}\n\t} else\n\t\tboarddma = size * sc->sc_dmabuf + GUS_MEM_OFFSET;\n\n\n\tsc->sc_flags |= GUS_LOCKED;\n\tsc->sc_dmaoutintr = intr;\n\tsc->sc_outarg = arg;\n\n#ifdef GUSPLAYDEBUG\n\tif (gusstats) {\n\t  microtime(&dmarecords[dmarecord_index].tv);\n\t  dmarecords[dmarecord_index].gusaddr = boarddma;\n\t  dmarecords[dmarecord_index].bsdaddr = buffer;\n\t  dmarecords[dmarecord_index].count = size;\n\t  dmarecords[dmarecord_index].channel = 0;\n\t  dmarecords[dmarecord_index].direction = 1;\n\t  dmarecord_index = ++dmarecord_index % NDMARECS;\n\t}\n#endif\n\n\tgusdmaout(sc, flags, boarddma, (caddr_t) buffer, size);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "stereo_dmaintr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "478-514",
    "snippet": "void\nstereo_dmaintr(arg)\n\tvoid *arg;\n{\n    struct gus_softc *sc = arg;\n    struct stereo_dma_intr *sa = &sc->sc_stereo;\n\n    DMAPRINTF((\"stereo_dmaintr\"));\n\n    /*\n     * Put other half in its place, then call the real interrupt routine :)\n     */\n\n    sc->sc_dmaoutintr = sa->intr;\n    sc->sc_outarg = sa->arg;\n\n#ifdef GUSPLAYDEBUG\n    if (gusstats) {\n      microtime(&dmarecords[dmarecord_index].tv);\n      dmarecords[dmarecord_index].gusaddr = sa->dmabuf;\n      dmarecords[dmarecord_index].bsdaddr = sa->buffer;\n      dmarecords[dmarecord_index].count = sa->size;\n      dmarecords[dmarecord_index].channel = 1;\n      dmarecords[dmarecord_index].direction = 1;\n      dmarecord_index = ++dmarecord_index % NDMARECS;\n    }\n#endif\n\n    gusdmaout(sc, sa->flags, sa->dmabuf, (caddr_t) sa->buffer, sa->size);\n\n    sa->flags = 0;\n    sa->dmabuf = 0;\n    sa->buffer = 0;\n    sa->size = 0;\n    sa->intr = 0;\n    sa->arg = 0;\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define NDMARECS 2048",
      "#define GUSPLAYDEBUG\t/*XXX*/"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gusdmaout",
          "args": [
            "sc",
            "sa->flags",
            "sa->dmabuf",
            "(caddr_t) sa->buffer",
            "sa->size"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "gusdmaout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "1263-1331",
          "snippet": "void\ngusdmaout(sc, flags, gusaddr, buffaddr, length)\n\tstruct gus_softc *sc;\n\tint flags, length;\n\tu_long gusaddr;\n\tcaddr_t buffaddr;\n{\n\tunsigned char c = (unsigned char) flags;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\n\tDMAPRINTF((\"gusdmaout flags=%x scflags=%x\\n\", flags, sc->sc_flags));\n\n\tsc->sc_gusaddr = gusaddr;\n\n\t/*\n\t * If we're using a 16 bit DMA channel, we have to jump through some\n\t * extra hoops; this includes translating the DRAM address a bit\n\t */\n\n\tif (sc->sc_drq >= 4) {\n\t\tc |= GUSMASK_DMA_WIDTH;\n\t\tgusaddr = convert_to_16bit(gusaddr);\n\t}\n\n\t/*\n\t * Add flag bits that we always set - fast DMA, enable IRQ\n\t */\n\n\tc |= GUSMASK_DMA_ENABLE | GUSMASK_DMA_R0 | GUSMASK_DMA_IRQ;\n\n\t/*\n\t * Make sure the GUS _isn't_ setup for DMA\n\t */\n\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0);\n\n\t/*\n\t * Tell the PC DMA controller to start doing DMA\n\t */\n\n\tsc->sc_dmaoutaddr = (u_char *) buffaddr;\n\tsc->sc_dmaoutcnt = length;\n \tisa_dmastart(sc->sc_dev.dv_parent, sc->sc_drq, buffaddr, length,\n \t    NULL, DMAMODE_WRITE, BUS_DMA_NOWAIT);\n\n\t/*\n\t * Set up DMA address - use the upper 16 bits ONLY\n\t */\n\n\tsc->sc_flags |= GUS_DMAOUT_ACTIVE;\n\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_START);\n \tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, (int) (gusaddr >> 4));\n\n \t/*\n \t * Tell the GUS to start doing DMA\n \t */\n\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, c);\n\n\t/*\n\t * XXX If we don't finish in one second, give up...\n\t */\n\tuntimeout(gus_dmaout_timeout, sc); /* flush old one, if there is one */\n\ttimeout(gus_dmaout_timeout, sc, hz);\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ngusdmaout(sc, flags, gusaddr, buffaddr, length)\n\tstruct gus_softc *sc;\n\tint flags, length;\n\tu_long gusaddr;\n\tcaddr_t buffaddr;\n{\n\tunsigned char c = (unsigned char) flags;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh2 = sc->sc_ioh2;\n\n\tDMAPRINTF((\"gusdmaout flags=%x scflags=%x\\n\", flags, sc->sc_flags));\n\n\tsc->sc_gusaddr = gusaddr;\n\n\t/*\n\t * If we're using a 16 bit DMA channel, we have to jump through some\n\t * extra hoops; this includes translating the DRAM address a bit\n\t */\n\n\tif (sc->sc_drq >= 4) {\n\t\tc |= GUSMASK_DMA_WIDTH;\n\t\tgusaddr = convert_to_16bit(gusaddr);\n\t}\n\n\t/*\n\t * Add flag bits that we always set - fast DMA, enable IRQ\n\t */\n\n\tc |= GUSMASK_DMA_ENABLE | GUSMASK_DMA_R0 | GUSMASK_DMA_IRQ;\n\n\t/*\n\t * Make sure the GUS _isn't_ setup for DMA\n\t */\n\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0);\n\n\t/*\n\t * Tell the PC DMA controller to start doing DMA\n\t */\n\n\tsc->sc_dmaoutaddr = (u_char *) buffaddr;\n\tsc->sc_dmaoutcnt = length;\n \tisa_dmastart(sc->sc_dev.dv_parent, sc->sc_drq, buffaddr, length,\n \t    NULL, DMAMODE_WRITE, BUS_DMA_NOWAIT);\n\n\t/*\n\t * Set up DMA address - use the upper 16 bits ONLY\n\t */\n\n\tsc->sc_flags |= GUS_DMAOUT_ACTIVE;\n\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_START);\n \tbus_space_write_2(iot, ioh2, GUS_DATA_LOW, (int) (gusaddr >> 4));\n\n \t/*\n \t * Tell the GUS to start doing DMA\n \t */\n\n \tSELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);\n\tbus_space_write_1(iot, ioh2, GUS_DATA_HIGH, c);\n\n\t/*\n\t * XXX If we don't finish in one second, give up...\n\t */\n\tuntimeout(gus_dmaout_timeout, sc); /* flush old one, if there is one */\n\ttimeout(gus_dmaout_timeout, sc, hz);\n}"
        }
      },
      {
        "call_info": {
          "callee": "microtime",
          "args": [
            "&dmarecords[dmarecord_index].tv"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DMAPRINTF",
          "args": [
            "(\"stereo_dmaintr\")"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define NDMARECS 2048\n#define GUSPLAYDEBUG\t/*XXX*/\n\nvoid\nstereo_dmaintr(arg)\n\tvoid *arg;\n{\n    struct gus_softc *sc = arg;\n    struct stereo_dma_intr *sa = &sc->sc_stereo;\n\n    DMAPRINTF((\"stereo_dmaintr\"));\n\n    /*\n     * Put other half in its place, then call the real interrupt routine :)\n     */\n\n    sc->sc_dmaoutintr = sa->intr;\n    sc->sc_outarg = sa->arg;\n\n#ifdef GUSPLAYDEBUG\n    if (gusstats) {\n      microtime(&dmarecords[dmarecord_index].tv);\n      dmarecords[dmarecord_index].gusaddr = sa->dmabuf;\n      dmarecords[dmarecord_index].bsdaddr = sa->buffer;\n      dmarecords[dmarecord_index].count = sa->size;\n      dmarecords[dmarecord_index].channel = 1;\n      dmarecords[dmarecord_index].direction = 1;\n      dmarecord_index = ++dmarecord_index % NDMARECS;\n    }\n#endif\n\n    gusdmaout(sc, sa->flags, sa->dmabuf, (caddr_t) sa->buffer, sa->size);\n\n    sa->flags = 0;\n    sa->dmabuf = 0;\n    sa->buffer = 0;\n    sa->size = 0;\n    sa->intr = 0;\n    sa->arg = 0;\n}"
  },
  {
    "function_name": "gusmax_dma_output",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "463-473",
    "snippet": "int\ngusmax_dma_output(addr, buf, size, intr, arg)\n\tvoid * addr;\n\tvoid *buf;\n\tint size;\n\tvoid (*intr) __P((void *));\n\tvoid *arg;\n{\n\tstruct ad1848_softc *ac = addr;\n\treturn gus_dma_output(ac->parent, buf, size, intr, arg);\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gus_dma_output",
          "args": [
            "ac->parent",
            "buf",
            "size",
            "intr",
            "arg"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "gus_dma_output",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "521-603",
          "snippet": "int\ngus_dma_output(addr, buf, size, intr, arg)\n\tvoid * addr;\n\tvoid *buf;\n\tint size;\n\tvoid (*intr) __P((void *));\n\tvoid *arg;\n{\n\tstruct gus_softc *sc = addr;\n\tu_char *buffer = buf;\n\tu_long boarddma;\n\tint flags;\n\n\tDMAPRINTF((\"gus_dma_output %d @ %p\\n\", size, buf));\n\n\tif (size != sc->sc_blocksize) {\n\t    DPRINTF((\"gus_dma_output reqsize %d not sc_blocksize %d\\n\",\n\t\t     size, sc->sc_blocksize));\n\t    return EINVAL;\n\t}\n\n\tflags = GUSMASK_DMA_WRITE;\n\tif (sc->sc_precision == 16)\n\t    flags |= GUSMASK_DMA_DATA_SIZE; \n\tif (sc->sc_encoding == AUDIO_ENCODING_ULAW ||\n\t    sc->sc_encoding == AUDIO_ENCODING_ALAW ||\n\t    sc->sc_encoding == AUDIO_ENCODING_ULINEAR_BE ||\n\t    sc->sc_encoding == AUDIO_ENCODING_ULINEAR_LE)\n\t    flags |= GUSMASK_DMA_INVBIT;\n\n\tif (sc->sc_channels == 2) {\n\t\tif (sc->sc_precision == 16) {\n\t\t\tif (size & 3) {\n\t\t\t\tDPRINTF((\"gus_dma_output: unpaired 16bit samples\"));\n\t\t\t\tsize &= 3;\n\t\t\t}\n\t\t} else if (size & 1) {\n\t\t\tDPRINTF((\"gus_dma_output: unpaired samples\"));\n\t\t\tsize &= 1;\n\t\t}\n\t\tif (size == 0)\n\t\t\treturn 0;\n\n\t\tgus_deinterleave(sc, (void *)buffer, size);\n\n\t\tsize >>= 1;\n\n \t\tboarddma = size * sc->sc_dmabuf + GUS_MEM_OFFSET;\n\n\t\tsc->sc_stereo.intr = intr;\n\t\tsc->sc_stereo.arg = arg;\n\t\tsc->sc_stereo.size = size;\n\t\tsc->sc_stereo.dmabuf = boarddma + GUS_LEFT_RIGHT_OFFSET;\n\t\tsc->sc_stereo.buffer = buffer + size;\n\t\tsc->sc_stereo.flags = flags;\n\t\tif (gus_dostereo) {\n\t\t  intr = stereo_dmaintr;\n\t\t  arg = sc;\n\t\t}\n\t} else\n\t\tboarddma = size * sc->sc_dmabuf + GUS_MEM_OFFSET;\n\n\n\tsc->sc_flags |= GUS_LOCKED;\n\tsc->sc_dmaoutintr = intr;\n\tsc->sc_outarg = arg;\n\n#ifdef GUSPLAYDEBUG\n\tif (gusstats) {\n\t  microtime(&dmarecords[dmarecord_index].tv);\n\t  dmarecords[dmarecord_index].gusaddr = boarddma;\n\t  dmarecords[dmarecord_index].bsdaddr = buffer;\n\t  dmarecords[dmarecord_index].count = size;\n\t  dmarecords[dmarecord_index].channel = 0;\n\t  dmarecords[dmarecord_index].direction = 1;\n\t  dmarecord_index = ++dmarecord_index % NDMARECS;\n\t}\n#endif\n\n\tgusdmaout(sc, flags, boarddma, (caddr_t) buffer, size);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define NDMARECS 2048",
            "#define GUSPLAYDEBUG\t/*XXX*/"
          ],
          "globals_used": [
            "int\tgus_dostereo = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define NDMARECS 2048\n#define GUSPLAYDEBUG\t/*XXX*/\n\nint\tgus_dostereo = 1;\n\nint\ngus_dma_output(addr, buf, size, intr, arg)\n\tvoid * addr;\n\tvoid *buf;\n\tint size;\n\tvoid (*intr) __P((void *));\n\tvoid *arg;\n{\n\tstruct gus_softc *sc = addr;\n\tu_char *buffer = buf;\n\tu_long boarddma;\n\tint flags;\n\n\tDMAPRINTF((\"gus_dma_output %d @ %p\\n\", size, buf));\n\n\tif (size != sc->sc_blocksize) {\n\t    DPRINTF((\"gus_dma_output reqsize %d not sc_blocksize %d\\n\",\n\t\t     size, sc->sc_blocksize));\n\t    return EINVAL;\n\t}\n\n\tflags = GUSMASK_DMA_WRITE;\n\tif (sc->sc_precision == 16)\n\t    flags |= GUSMASK_DMA_DATA_SIZE; \n\tif (sc->sc_encoding == AUDIO_ENCODING_ULAW ||\n\t    sc->sc_encoding == AUDIO_ENCODING_ALAW ||\n\t    sc->sc_encoding == AUDIO_ENCODING_ULINEAR_BE ||\n\t    sc->sc_encoding == AUDIO_ENCODING_ULINEAR_LE)\n\t    flags |= GUSMASK_DMA_INVBIT;\n\n\tif (sc->sc_channels == 2) {\n\t\tif (sc->sc_precision == 16) {\n\t\t\tif (size & 3) {\n\t\t\t\tDPRINTF((\"gus_dma_output: unpaired 16bit samples\"));\n\t\t\t\tsize &= 3;\n\t\t\t}\n\t\t} else if (size & 1) {\n\t\t\tDPRINTF((\"gus_dma_output: unpaired samples\"));\n\t\t\tsize &= 1;\n\t\t}\n\t\tif (size == 0)\n\t\t\treturn 0;\n\n\t\tgus_deinterleave(sc, (void *)buffer, size);\n\n\t\tsize >>= 1;\n\n \t\tboarddma = size * sc->sc_dmabuf + GUS_MEM_OFFSET;\n\n\t\tsc->sc_stereo.intr = intr;\n\t\tsc->sc_stereo.arg = arg;\n\t\tsc->sc_stereo.size = size;\n\t\tsc->sc_stereo.dmabuf = boarddma + GUS_LEFT_RIGHT_OFFSET;\n\t\tsc->sc_stereo.buffer = buffer + size;\n\t\tsc->sc_stereo.flags = flags;\n\t\tif (gus_dostereo) {\n\t\t  intr = stereo_dmaintr;\n\t\t  arg = sc;\n\t\t}\n\t} else\n\t\tboarddma = size * sc->sc_dmabuf + GUS_MEM_OFFSET;\n\n\n\tsc->sc_flags |= GUS_LOCKED;\n\tsc->sc_dmaoutintr = intr;\n\tsc->sc_outarg = arg;\n\n#ifdef GUSPLAYDEBUG\n\tif (gusstats) {\n\t  microtime(&dmarecords[dmarecord_index].tv);\n\t  dmarecords[dmarecord_index].gusaddr = boarddma;\n\t  dmarecords[dmarecord_index].bsdaddr = buffer;\n\t  dmarecords[dmarecord_index].count = size;\n\t  dmarecords[dmarecord_index].channel = 0;\n\t  dmarecords[dmarecord_index].direction = 1;\n\t  dmarecord_index = ++dmarecord_index % NDMARECS;\n\t}\n#endif\n\n\tgusdmaout(sc, flags, boarddma, (caddr_t) buffer, size);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngusmax_dma_output(addr, buf, size, intr, arg)\n\tvoid * addr;\n\tvoid *buf;\n\tint size;\n\tvoid (*intr) __P((void *));\n\tvoid *arg;\n{\n\tstruct ad1848_softc *ac = addr;\n\treturn gus_dma_output(ac->parent, buf, size, intr, arg);\n}"
  },
  {
    "function_name": "gus_deinterleave",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "407-457",
    "snippet": "void\ngus_deinterleave(sc, buf, size)\n\tstruct gus_softc *sc;\n\tvoid *buf;\n\tint size;\n{\n\t/* deinterleave the stereo data.  We can use sc->sc_deintr_buf\n\t   for scratch space. */\n\tint i;\n\n\tif (size > sc->sc_blocksize) {\n\t\tprintf(\"gus: deinterleave %d > %d\\n\", size, sc->sc_blocksize);\n\t\treturn;\n\t} else if (size < sc->sc_blocksize) {\n\t\tDPRINTF((\"gus: deinterleave %d < %d\\n\", size, sc->sc_blocksize));\n\t}\n\n\t/*\n\t * size is in bytes.\n\t */\n\tif (sc->sc_precision == 16) {\n\t\tu_short *dei = sc->sc_deintr_buf;\n\t\tu_short *sbuf = buf;\n\t\tsize >>= 1;\t\t/* bytecnt to shortcnt */\n\t\t/* copy 2nd of each pair of samples to the staging area, while\n\t\t   compacting the 1st of each pair into the original area. */\n\t\tfor (i = 0; i < size/2-1; i++)  {\n\t\t\tdei[i] = sbuf[i*2+1];\n\t\t\tsbuf[i+1] = sbuf[i*2+2];\n\t\t}\n\t\t/*\n\t\t * this has copied one less sample than half of the\n\t\t * buffer.  The first sample of the 1st stream was\n\t\t * already in place and didn't need copying.\n\t\t * Therefore, we've moved all of the 1st stream's\n\t\t * samples into place.  We have one sample from 2nd\n\t\t * stream in the last slot of original area, not\n\t\t * copied to the staging area (But we don't need to!).\n\t\t * Copy the remainder of the original stream into place.\n\t\t */\n\t\tbcopy(dei, &sbuf[size/2], i * sizeof(short));\n\t} else {\n\t\tu_char *dei = sc->sc_deintr_buf;\n\t\tu_char *sbuf = buf;\n\t\tfor (i = 0; i < size/2-1; i++)  {\n\t\t\tdei[i] = sbuf[i*2+1];\n\t\t\tsbuf[i+1] = sbuf[i*2+2];\n\t\t}\n\t\tbcopy(dei, &sbuf[size/2], i);\n\t}\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "dei",
            "&sbuf[size/2]",
            "i"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"gus: deinterleave %d < %d\\n\", size, sc->sc_blocksize)"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"gus: deinterleave %d > %d\\n\"",
            "size",
            "sc->sc_blocksize"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ngus_deinterleave(sc, buf, size)\n\tstruct gus_softc *sc;\n\tvoid *buf;\n\tint size;\n{\n\t/* deinterleave the stereo data.  We can use sc->sc_deintr_buf\n\t   for scratch space. */\n\tint i;\n\n\tif (size > sc->sc_blocksize) {\n\t\tprintf(\"gus: deinterleave %d > %d\\n\", size, sc->sc_blocksize);\n\t\treturn;\n\t} else if (size < sc->sc_blocksize) {\n\t\tDPRINTF((\"gus: deinterleave %d < %d\\n\", size, sc->sc_blocksize));\n\t}\n\n\t/*\n\t * size is in bytes.\n\t */\n\tif (sc->sc_precision == 16) {\n\t\tu_short *dei = sc->sc_deintr_buf;\n\t\tu_short *sbuf = buf;\n\t\tsize >>= 1;\t\t/* bytecnt to shortcnt */\n\t\t/* copy 2nd of each pair of samples to the staging area, while\n\t\t   compacting the 1st of each pair into the original area. */\n\t\tfor (i = 0; i < size/2-1; i++)  {\n\t\t\tdei[i] = sbuf[i*2+1];\n\t\t\tsbuf[i+1] = sbuf[i*2+2];\n\t\t}\n\t\t/*\n\t\t * this has copied one less sample than half of the\n\t\t * buffer.  The first sample of the 1st stream was\n\t\t * already in place and didn't need copying.\n\t\t * Therefore, we've moved all of the 1st stream's\n\t\t * samples into place.  We have one sample from 2nd\n\t\t * stream in the last slot of original area, not\n\t\t * copied to the staging area (But we don't need to!).\n\t\t * Copy the remainder of the original stream into place.\n\t\t */\n\t\tbcopy(dei, &sbuf[size/2], i * sizeof(short));\n\t} else {\n\t\tu_char *dei = sc->sc_deintr_buf;\n\t\tu_char *sbuf = buf;\n\t\tfor (i = 0; i < size/2-1; i++)  {\n\t\t\tdei[i] = sbuf[i*2+1];\n\t\t\tsbuf[i+1] = sbuf[i*2+2];\n\t\t}\n\t\tbcopy(dei, &sbuf[size/2], i);\n\t}\n}"
  },
  {
    "function_name": "gusmaxopen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "398-405",
    "snippet": "int\ngusmaxopen(addr, flags)\n\tvoid *addr;\n\tint flags;\n{\n\tstruct ad1848_softc *ac = addr;\n\treturn gusopen(ac->parent, flags);\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gusopen",
          "args": [
            "ac->parent",
            "flags"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "gusopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "355-396",
          "snippet": "int\ngusopen(addr, flags)\n\tvoid *addr;\n\tint flags;\n{\n\tstruct gus_softc *sc = addr;\n\n\tDPRINTF((\"gusopen() called\\n\"));\n\n\tif (sc->sc_flags & GUS_OPEN)\n\t\treturn EBUSY;\n\n\t/*\n\t * Some initialization\n\t */\n\n\tsc->sc_flags |= GUS_OPEN;\n\tsc->sc_dmabuf = 0;\n\tsc->sc_playbuf = -1;\n\tsc->sc_bufcnt = 0;\n\tsc->sc_voc[GUS_VOICE_LEFT].start_addr = GUS_MEM_OFFSET - 1;\n\tsc->sc_voc[GUS_VOICE_LEFT].current_addr = GUS_MEM_OFFSET;\n\n\tif (HAS_CODEC(sc)) {\n\t\tad1848_open(&sc->sc_codec, flags);\n\t\tsc->sc_codec.mute[AD1848_AUX1_CHANNEL] = 0;\n\t\tad1848_mute_channel(&sc->sc_codec, AD1848_AUX1_CHANNEL, 0); /* turn on DAC output */\n\t\tif (flags & FREAD) {\n\t\t\tsc->sc_codec.mute[AD1848_MONO_CHANNEL] = 0;\n\t\t\tad1848_mute_channel(&sc->sc_codec, AD1848_MONO_CHANNEL, 0);\n\t\t}\n\t} else if (flags & FREAD) {\n\t\t/* enable/unmute the microphone */\n\t\tif (HAS_MIXER(sc)) {\n\t\t\tgusics_mic_mute(&sc->sc_mixer, 0);\n\t\t} else\n\t\t\tgus_mic_ctl(sc, SPKR_ON);\n\t}\n\tif (sc->sc_nbufs == 0)\n\t    gus_round_blocksize(sc, GUS_BUFFER_MULTIPLE); /* default blksiz */\n\treturn 0;\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngusopen(addr, flags)\n\tvoid *addr;\n\tint flags;\n{\n\tstruct gus_softc *sc = addr;\n\n\tDPRINTF((\"gusopen() called\\n\"));\n\n\tif (sc->sc_flags & GUS_OPEN)\n\t\treturn EBUSY;\n\n\t/*\n\t * Some initialization\n\t */\n\n\tsc->sc_flags |= GUS_OPEN;\n\tsc->sc_dmabuf = 0;\n\tsc->sc_playbuf = -1;\n\tsc->sc_bufcnt = 0;\n\tsc->sc_voc[GUS_VOICE_LEFT].start_addr = GUS_MEM_OFFSET - 1;\n\tsc->sc_voc[GUS_VOICE_LEFT].current_addr = GUS_MEM_OFFSET;\n\n\tif (HAS_CODEC(sc)) {\n\t\tad1848_open(&sc->sc_codec, flags);\n\t\tsc->sc_codec.mute[AD1848_AUX1_CHANNEL] = 0;\n\t\tad1848_mute_channel(&sc->sc_codec, AD1848_AUX1_CHANNEL, 0); /* turn on DAC output */\n\t\tif (flags & FREAD) {\n\t\t\tsc->sc_codec.mute[AD1848_MONO_CHANNEL] = 0;\n\t\t\tad1848_mute_channel(&sc->sc_codec, AD1848_MONO_CHANNEL, 0);\n\t\t}\n\t} else if (flags & FREAD) {\n\t\t/* enable/unmute the microphone */\n\t\tif (HAS_MIXER(sc)) {\n\t\t\tgusics_mic_mute(&sc->sc_mixer, 0);\n\t\t} else\n\t\t\tgus_mic_ctl(sc, SPKR_ON);\n\t}\n\tif (sc->sc_nbufs == 0)\n\t    gus_round_blocksize(sc, GUS_BUFFER_MULTIPLE); /* default blksiz */\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngusmaxopen(addr, flags)\n\tvoid *addr;\n\tint flags;\n{\n\tstruct ad1848_softc *ac = addr;\n\treturn gusopen(ac->parent, flags);\n}"
  },
  {
    "function_name": "gusopen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
    "lines": "355-396",
    "snippet": "int\ngusopen(addr, flags)\n\tvoid *addr;\n\tint flags;\n{\n\tstruct gus_softc *sc = addr;\n\n\tDPRINTF((\"gusopen() called\\n\"));\n\n\tif (sc->sc_flags & GUS_OPEN)\n\t\treturn EBUSY;\n\n\t/*\n\t * Some initialization\n\t */\n\n\tsc->sc_flags |= GUS_OPEN;\n\tsc->sc_dmabuf = 0;\n\tsc->sc_playbuf = -1;\n\tsc->sc_bufcnt = 0;\n\tsc->sc_voc[GUS_VOICE_LEFT].start_addr = GUS_MEM_OFFSET - 1;\n\tsc->sc_voc[GUS_VOICE_LEFT].current_addr = GUS_MEM_OFFSET;\n\n\tif (HAS_CODEC(sc)) {\n\t\tad1848_open(&sc->sc_codec, flags);\n\t\tsc->sc_codec.mute[AD1848_AUX1_CHANNEL] = 0;\n\t\tad1848_mute_channel(&sc->sc_codec, AD1848_AUX1_CHANNEL, 0); /* turn on DAC output */\n\t\tif (flags & FREAD) {\n\t\t\tsc->sc_codec.mute[AD1848_MONO_CHANNEL] = 0;\n\t\t\tad1848_mute_channel(&sc->sc_codec, AD1848_MONO_CHANNEL, 0);\n\t\t}\n\t} else if (flags & FREAD) {\n\t\t/* enable/unmute the microphone */\n\t\tif (HAS_MIXER(sc)) {\n\t\t\tgusics_mic_mute(&sc->sc_mixer, 0);\n\t\t} else\n\t\t\tgus_mic_ctl(sc, SPKR_ON);\n\t}\n\tif (sc->sc_nbufs == 0)\n\t    gus_round_blocksize(sc, GUS_BUFFER_MULTIPLE); /* default blksiz */\n\treturn 0;\n}",
    "includes": [
      "#include \"gusvar.h\"",
      "#include \"gusreg.h\"",
      "#include <dev/isa/cs4231var.h>",
      "#include <dev/isa/ad1848var.h>",
      "#include <dev/isa/ics2101var.h>",
      "#include <dev/ic/ad1848reg.h>",
      "#include <dev/ic/cs4231reg.h>",
      "#include <dev/ic/ics2101reg.h>",
      "#include <i386/isa/icu.h>",
      "#include <dev/isa/isadmavar.h>",
      "#include <dev/isa/isavar.h>",
      "#include <dev/auconv.h>",
      "#include <dev/mulaw.h>",
      "#include <dev/audio_if.h>",
      "#include <sys/audioio.h>",
      "#include <machine/cpufunc.h>",
      "#include <machine/bus.h>",
      "#include <machine/intr.h>",
      "#include <machine/cpu.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/buf.h>",
      "#include <sys/proc.h>",
      "#include <sys/device.h>",
      "#include <sys/syslog.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/errno.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gus_round_blocksize",
          "args": [
            "sc",
            "GUS_BUFFER_MULTIPLE"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "gus_round_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "1606-1640",
          "snippet": "int\ngus_round_blocksize(addr, blocksize)\n\tvoid * addr;\n\tint blocksize;\n{\n\tstruct gus_softc *sc = addr;\n\n\tDPRINTF((\"gus_round_blocksize called\\n\"));\n\n\tif ((sc->sc_encoding == AUDIO_ENCODING_ULAW ||\n\t     sc->sc_encoding == AUDIO_ENCODING_ALAW) && blocksize > 32768)\n\t\tblocksize = 32768;\n\telse if (blocksize > 65536)\n\t\tblocksize = 65536;\n\n\tif ((blocksize % GUS_BUFFER_MULTIPLE) != 0)\n\t\tblocksize = (blocksize / GUS_BUFFER_MULTIPLE + 1) *\n\t\t\tGUS_BUFFER_MULTIPLE;\n\n\t/* set up temporary buffer to hold the deinterleave, if necessary\n\t   for stereo output */\n\tif (sc->sc_deintr_buf) {\n\t\tFREE(sc->sc_deintr_buf, M_DEVBUF);\n\t\tsc->sc_deintr_buf = NULL;\n\t}\n\tMALLOC(sc->sc_deintr_buf, void *, blocksize>>1, M_DEVBUF, M_WAITOK);\n\n\tsc->sc_blocksize = blocksize;\n\t/* multi-buffering not quite working yet. */\n\tsc->sc_nbufs = /*GUS_MEM_FOR_BUFFERS / blocksize*/ 2;\n\n\tgus_set_chan_addrs(sc);\n\n\treturn blocksize;\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngus_round_blocksize(addr, blocksize)\n\tvoid * addr;\n\tint blocksize;\n{\n\tstruct gus_softc *sc = addr;\n\n\tDPRINTF((\"gus_round_blocksize called\\n\"));\n\n\tif ((sc->sc_encoding == AUDIO_ENCODING_ULAW ||\n\t     sc->sc_encoding == AUDIO_ENCODING_ALAW) && blocksize > 32768)\n\t\tblocksize = 32768;\n\telse if (blocksize > 65536)\n\t\tblocksize = 65536;\n\n\tif ((blocksize % GUS_BUFFER_MULTIPLE) != 0)\n\t\tblocksize = (blocksize / GUS_BUFFER_MULTIPLE + 1) *\n\t\t\tGUS_BUFFER_MULTIPLE;\n\n\t/* set up temporary buffer to hold the deinterleave, if necessary\n\t   for stereo output */\n\tif (sc->sc_deintr_buf) {\n\t\tFREE(sc->sc_deintr_buf, M_DEVBUF);\n\t\tsc->sc_deintr_buf = NULL;\n\t}\n\tMALLOC(sc->sc_deintr_buf, void *, blocksize>>1, M_DEVBUF, M_WAITOK);\n\n\tsc->sc_blocksize = blocksize;\n\t/* multi-buffering not quite working yet. */\n\tsc->sc_nbufs = /*GUS_MEM_FOR_BUFFERS / blocksize*/ 2;\n\n\tgus_set_chan_addrs(sc);\n\n\treturn blocksize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gus_mic_ctl",
          "args": [
            "sc",
            "SPKR_ON"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "gus_mic_ctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "1870-1892",
          "snippet": "int\ngus_mic_ctl(addr, newstate)\n\tvoid * addr;\n\tint newstate;\n{\n\tstruct gus_softc *sc = (struct gus_softc *) addr;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh1 = sc->sc_ioh1;\n\n\t/* Mic bit is normal: 1 enables, 0 disables */\n\tif ((newstate == SPKR_ON) &&\n\t    (sc->sc_mixcontrol & GUSMASK_MIC_IN) == 0) {\n\t\tsc->sc_mixcontrol |= GUSMASK_MIC_IN;\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t}\n\tif ((newstate == SPKR_OFF) &&\n\t    (sc->sc_mixcontrol & GUSMASK_MIC_IN)) {\n\t\tsc->sc_mixcontrol &= ~GUSMASK_MIC_IN;\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngus_mic_ctl(addr, newstate)\n\tvoid * addr;\n\tint newstate;\n{\n\tstruct gus_softc *sc = (struct gus_softc *) addr;\n\tbus_space_tag_t iot = sc->sc_iot;\n\tbus_space_handle_t ioh1 = sc->sc_ioh1;\n\n\t/* Mic bit is normal: 1 enables, 0 disables */\n\tif ((newstate == SPKR_ON) &&\n\t    (sc->sc_mixcontrol & GUSMASK_MIC_IN) == 0) {\n\t\tsc->sc_mixcontrol |= GUSMASK_MIC_IN;\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t}\n\tif ((newstate == SPKR_OFF) &&\n\t    (sc->sc_mixcontrol & GUSMASK_MIC_IN)) {\n\t\tsc->sc_mixcontrol &= ~GUSMASK_MIC_IN;\n\t\tbus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gusics_mic_mute",
          "args": [
            "&sc->sc_mixer",
            "0"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "gusics_mic_mute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/gus.c",
          "lines": "2638-2645",
          "snippet": "void\ngusics_mic_mute(ic, mute)\n\tstruct ics2101_softc *ic;\n\tint mute;\n{\n\tics2101_mix_mute(ic, GUSMIX_CHAN_MIC, ICSMIX_LEFT, mute);\n\tics2101_mix_mute(ic, GUSMIX_CHAN_MIC, ICSMIX_RIGHT, mute);\n}",
          "includes": [
            "#include \"gusvar.h\"",
            "#include \"gusreg.h\"",
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/isa/ics2101var.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ics2101reg.h>",
            "#include <i386/isa/icu.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <machine/cpufunc.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <machine/cpu.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ngusics_mic_mute(ic, mute)\n\tstruct ics2101_softc *ic;\n\tint mute;\n{\n\tics2101_mix_mute(ic, GUSMIX_CHAN_MIC, ICSMIX_LEFT, mute);\n\tics2101_mix_mute(ic, GUSMIX_CHAN_MIC, ICSMIX_RIGHT, mute);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HAS_MIXER",
          "args": [
            "sc"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ad1848_mute_channel",
          "args": [
            "&sc->sc_codec",
            "AD1848_MONO_CHANNEL",
            "0"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_mute_channel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "607-640",
          "snippet": "void \nad1848_mute_channel(sc, device, mute) \n\tstruct ad1848_softc *sc;\n\tint device;\n\tint mute;\n{\n  u_char reg;\n\n  reg = ad_read(sc, mixer_channel_info[device].left_reg);\n\n  if (mute & MUTE_LEFT) {\n    if (device == AD1848_MONITOR_CHANNEL)\n        ad_write(sc, mixer_channel_info[device].left_reg, reg & 0xFE);\n    else\n        ad_write(sc, mixer_channel_info[device].left_reg, reg | 0x80);\n  } else if (!(sc->mute[device] & MUTE_LEFT)) {\n    if (device == AD1848_MONITOR_CHANNEL)\n        ad_write(sc, mixer_channel_info[device].left_reg, reg | 0x01);\n    else\n        ad_write(sc, mixer_channel_info[device].left_reg, reg & ~0x80);\n  }\n\n  if (!mixer_channel_info[device].right_reg) {\n    return;\n  }\n\n  reg = ad_read(sc, mixer_channel_info[device].right_reg);\n\n  if (mute & MUTE_RIGHT)\n    ad_write(sc, mixer_channel_info[device].right_reg, reg | 0x80);\n  else if (!(sc->mute[device] & MUTE_RIGHT)) {\n    ad_write(sc, mixer_channel_info[device].right_reg, reg & ~0x80);\n  }\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ad_read",
            "static void ad_write",
            "struct ad1848_mixerinfo {\n  int  left_reg;\n  int  right_reg;\n  int  atten_bits;\n  int  atten_mask;\n} mixer_channel_info[] = \n{ { SP_LEFT_AUX2_CONTROL, SP_RIGHT_AUX2_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_AUX1_CONTROL, SP_RIGHT_AUX1_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_OUTPUT_CONTROL, SP_RIGHT_OUTPUT_CONTROL, \n    OUTPUT_ATTEN_BITS, OUTPUT_ATTEN_MASK }, \n  { CS_LEFT_LINE_CONTROL, CS_RIGHT_LINE_CONTROL, LINE_INPUT_ATTEN_BITS,\n    LINE_INPUT_ATTEN_MASK },\n  { CS_MONO_IO_CONTROL, 0, MONO_INPUT_ATTEN_BITS, MONO_INPUT_ATTEN_MASK },\n  { SP_DIGITAL_MIX, 0, OUTPUT_ATTEN_BITS, MIX_ATTEN_MASK }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\nstatic void ad_write;\nstruct ad1848_mixerinfo {\n  int  left_reg;\n  int  right_reg;\n  int  atten_bits;\n  int  atten_mask;\n} mixer_channel_info[] = \n{ { SP_LEFT_AUX2_CONTROL, SP_RIGHT_AUX2_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_AUX1_CONTROL, SP_RIGHT_AUX1_CONTROL, AUX_INPUT_ATTEN_BITS,\n    AUX_INPUT_ATTEN_MASK },\n  { SP_LEFT_OUTPUT_CONTROL, SP_RIGHT_OUTPUT_CONTROL, \n    OUTPUT_ATTEN_BITS, OUTPUT_ATTEN_MASK }, \n  { CS_LEFT_LINE_CONTROL, CS_RIGHT_LINE_CONTROL, LINE_INPUT_ATTEN_BITS,\n    LINE_INPUT_ATTEN_MASK },\n  { CS_MONO_IO_CONTROL, 0, MONO_INPUT_ATTEN_BITS, MONO_INPUT_ATTEN_MASK },\n  { SP_DIGITAL_MIX, 0, OUTPUT_ATTEN_BITS, MIX_ATTEN_MASK }\n};\n\nvoid \nad1848_mute_channel(sc, device, mute) \n\tstruct ad1848_softc *sc;\n\tint device;\n\tint mute;\n{\n  u_char reg;\n\n  reg = ad_read(sc, mixer_channel_info[device].left_reg);\n\n  if (mute & MUTE_LEFT) {\n    if (device == AD1848_MONITOR_CHANNEL)\n        ad_write(sc, mixer_channel_info[device].left_reg, reg & 0xFE);\n    else\n        ad_write(sc, mixer_channel_info[device].left_reg, reg | 0x80);\n  } else if (!(sc->mute[device] & MUTE_LEFT)) {\n    if (device == AD1848_MONITOR_CHANNEL)\n        ad_write(sc, mixer_channel_info[device].left_reg, reg | 0x01);\n    else\n        ad_write(sc, mixer_channel_info[device].left_reg, reg & ~0x80);\n  }\n\n  if (!mixer_channel_info[device].right_reg) {\n    return;\n  }\n\n  reg = ad_read(sc, mixer_channel_info[device].right_reg);\n\n  if (mute & MUTE_RIGHT)\n    ad_write(sc, mixer_channel_info[device].right_reg, reg | 0x80);\n  else if (!(sc->mute[device] & MUTE_RIGHT)) {\n    ad_write(sc, mixer_channel_info[device].right_reg, reg & ~0x80);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ad1848_open",
          "args": [
            "&sc->sc_codec",
            "flags"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "ad1848_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/isa/ad1848.c",
          "lines": "1165-1188",
          "snippet": "int\nad1848_open(addr, flags)\n    void *addr;\n    int flags;\n{\n    struct ad1848_softc *sc = addr;\n\n    DPRINTF((\"ad1848_open: sc=%p\\n\", sc));\n\n    sc->sc_intr = 0;\n    sc->sc_lastcc = -1;\n    sc->sc_locked = 0;\n\n    /* Enable interrupts */\n    DPRINTF((\"ad1848_open: enable intrs\\n\"));\n    ad_write(sc, SP_PIN_CONTROL, INTERRUPT_ENABLE|ad_read(sc, SP_PIN_CONTROL));\n\n#ifdef AUDIO_DEBUG\n    if (ad1848debug)\n\tad1848_dump_regs(sc);\n#endif\n\n    return 0;\n}",
          "includes": [
            "#include <dev/isa/cs4231var.h>",
            "#include <dev/isa/ad1848var.h>",
            "#include <dev/ic/cs4231reg.h>",
            "#include <dev/ic/ad1848reg.h>",
            "#include <dev/isa/isadmavar.h>",
            "#include <dev/isa/isavar.h>",
            "#include <dev/auconv.h>",
            "#include <dev/audio_if.h>",
            "#include <vm/vm.h>",
            "#include <sys/audioio.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <sys/buf.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ad_read",
            "static void ad_write",
            "void *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;",
            "int flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/audio_if.h>\n#include <vm/vm.h>\n#include <sys/audioio.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int ad_read;\nstatic void ad_write;\nvoid *\nad1848_malloc(addr, size, pool, flags)\n\tvoid *addr;\nint flags;\n\nint\nad1848_open(addr, flags)\n    void *addr;\n    int flags;\n{\n    struct ad1848_softc *sc = addr;\n\n    DPRINTF((\"ad1848_open: sc=%p\\n\", sc));\n\n    sc->sc_intr = 0;\n    sc->sc_lastcc = -1;\n    sc->sc_locked = 0;\n\n    /* Enable interrupts */\n    DPRINTF((\"ad1848_open: enable intrs\\n\"));\n    ad_write(sc, SP_PIN_CONTROL, INTERRUPT_ENABLE|ad_read(sc, SP_PIN_CONTROL));\n\n#ifdef AUDIO_DEBUG\n    if (ad1848debug)\n\tad1848_dump_regs(sc);\n#endif\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HAS_CODEC",
          "args": [
            "sc"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"gusopen() called\\n\")"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gusvar.h\"\n#include \"gusreg.h\"\n#include <dev/isa/cs4231var.h>\n#include <dev/isa/ad1848var.h>\n#include <dev/isa/ics2101var.h>\n#include <dev/ic/ad1848reg.h>\n#include <dev/ic/cs4231reg.h>\n#include <dev/ic/ics2101reg.h>\n#include <i386/isa/icu.h>\n#include <dev/isa/isadmavar.h>\n#include <dev/isa/isavar.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <machine/cpufunc.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <machine/cpu.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/buf.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ngusopen(addr, flags)\n\tvoid *addr;\n\tint flags;\n{\n\tstruct gus_softc *sc = addr;\n\n\tDPRINTF((\"gusopen() called\\n\"));\n\n\tif (sc->sc_flags & GUS_OPEN)\n\t\treturn EBUSY;\n\n\t/*\n\t * Some initialization\n\t */\n\n\tsc->sc_flags |= GUS_OPEN;\n\tsc->sc_dmabuf = 0;\n\tsc->sc_playbuf = -1;\n\tsc->sc_bufcnt = 0;\n\tsc->sc_voc[GUS_VOICE_LEFT].start_addr = GUS_MEM_OFFSET - 1;\n\tsc->sc_voc[GUS_VOICE_LEFT].current_addr = GUS_MEM_OFFSET;\n\n\tif (HAS_CODEC(sc)) {\n\t\tad1848_open(&sc->sc_codec, flags);\n\t\tsc->sc_codec.mute[AD1848_AUX1_CHANNEL] = 0;\n\t\tad1848_mute_channel(&sc->sc_codec, AD1848_AUX1_CHANNEL, 0); /* turn on DAC output */\n\t\tif (flags & FREAD) {\n\t\t\tsc->sc_codec.mute[AD1848_MONO_CHANNEL] = 0;\n\t\t\tad1848_mute_channel(&sc->sc_codec, AD1848_MONO_CHANNEL, 0);\n\t\t}\n\t} else if (flags & FREAD) {\n\t\t/* enable/unmute the microphone */\n\t\tif (HAS_MIXER(sc)) {\n\t\t\tgusics_mic_mute(&sc->sc_mixer, 0);\n\t\t} else\n\t\t\tgus_mic_ctl(sc, SPKR_ON);\n\t}\n\tif (sc->sc_nbufs == 0)\n\t    gus_round_blocksize(sc, GUS_BUFFER_MULTIPLE); /* default blksiz */\n\treturn 0;\n}"
  }
]