[
  {
    "function_name": "uriopoll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/urio.c",
    "lines": "582-589",
    "snippet": "int\nuriopoll(dev, events, p)\n\tdev_t dev;\n\tint events;\n\tstruct proc *p;\n{\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/urio.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/filio.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/usb/urio.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/filio.h>\n#include <sys/fcntl.h>\n#include <sys/conf.h>\n#include <sys/ioccom.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nuriopoll(dev, events, p)\n\tdev_t dev;\n\tint events;\n\tstruct proc *p;\n{\n\treturn (0);\n}"
  },
  {
    "function_name": "urioioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/urio.c",
    "lines": "482-580",
    "snippet": "int\nurioioctl(dev, cmd, addr, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t addr; \n\tint flag;\n\tstruct proc *p;\n{\n\tstruct urio_softc * sc;\n\tint unit = URIOUNIT(dev);\n\tstruct urio_command *rcmd;\n\tint requesttype, len;\n\tstruct iovec iov;\n\tstruct uio uio;\n\tusb_device_request_t req;\n\tusbd_status err;\n\tint req_flags = 0;\n\tu_int32_t req_actlen = 0;\n\tvoid *ptr = NULL;\n\tint error = 0;\n\n\tUSB_GET_SC(urio, unit, sc);\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\trcmd = (struct urio_command *)addr;\n\n\tswitch (cmd) {\n\tcase URIO_RECV_COMMAND:\n\t\trequesttype = rcmd->requesttype | UT_READ_VENDOR_DEVICE;\n\t\tbreak;\n\n\tcase URIO_SEND_COMMAND:\n\t\trequesttype = rcmd->requesttype | UT_WRITE_VENDOR_DEVICE;\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t\tbreak;\n\t}\n\n\tif (!(flag & FWRITE))\n\t\treturn (EPERM);\n\tlen = rcmd->length;\n\n\tDPRINTFN(1,(\"urio_ioctl: cmd=0x%08lx reqtype=0x%0x req=0x%0x \"\n\t\t    \"value=0x%0x index=0x%0x len=0x%0x\\n\", \n\t\t    cmd, requesttype, rcmd->request, rcmd->value,\n\t\t    rcmd->index, len));\n\n\t/* Send rio control message */\n\treq.bmRequestType = requesttype;\n\treq.bRequest = rcmd->request;\n\tUSETW(req.wValue, rcmd->value);\n\tUSETW(req.wIndex, rcmd->index);\n\tUSETW(req.wLength, len);\n\n\tif (len < 0 || len > 32767)\n\t\treturn (EINVAL);\n\tif (len != 0) {\n\t\tiov.iov_base = (caddr_t)rcmd->buffer;\n\t\tiov.iov_len = len;\n\t\tuio.uio_iov = &iov;\n\t\tuio.uio_iovcnt = 1;\n\t\tuio.uio_resid = len;\n\t\tuio.uio_offset = 0;\n\t\tuio.uio_segflg = UIO_USERSPACE;\n\t\tuio.uio_rw = req.bmRequestType & UT_READ ? \n\t\t\t     UIO_READ : UIO_WRITE;\n\t\tuio.uio_procp = p;\n\t\tptr = malloc(len, M_TEMP, M_WAITOK);\n\t\tif (uio.uio_rw == UIO_WRITE) {\n\t\t\terror = uiomove(ptr, len, &uio);\n\t\t\tif (error)\n\t\t\t\tgoto ret;\n\t\t}\n\t}\n\n\tsc->sc_refcnt++;\n\n\terr = usbd_do_request_flags(sc->sc_udev, &req, ptr, req_flags,\n\t\t\t\t    &req_actlen);\n\n\tif (--sc->sc_refcnt < 0)\n\t\tusb_detach_wakeup(USBDEV(sc->sc_dev));\n\n\tif (err) {\n\t\terror = EIO;\n\t} else {\n\t\tif (len != 0 && uio.uio_rw == UIO_READ)\n\t\t\terror = uiomove(ptr, len, &uio);\n\t}\n\nret:\n\tif (ptr != NULL)\n\t\tfree(ptr, M_TEMP);\n\treturn (error);\n}",
    "includes": [
      "#include <dev/usb/urio.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/filio.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ptr",
            "M_TEMP"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "uhci_free_std_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/uhci.c",
          "lines": "1504-1516",
          "snippet": "void\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}",
          "includes": [
            "#include <machine/clock.h>",
            "#include <dev/usb/uhcivar.h>",
            "#include <dev/usb/uhcireg.h>",
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/endian.h>",
            "#include <machine/bus.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <machine/cpu.h>",
            "#include <machine/bus_pio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/select.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "uhci_busreset __P((uhci_softc_t *));",
            "Static uhci_soft_td_t",
            "uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));",
            "uhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));",
            "uhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));",
            "uhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;",
            "uhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/clock.h>\n#include <dev/usb/uhcivar.h>\n#include <dev/usb/uhcireg.h>\n#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/endian.h>\n#include <machine/bus.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <machine/cpu.h>\n#include <machine/bus_pio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/select.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nuhci_busreset __P((uhci_softc_t *));\nStatic uhci_soft_td_t;\nuhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));\nuhci_free_std_chain __P((uhci_softc_t *, \n\t\t\t\t\t uhci_soft_td_t *, uhci_soft_td_t *));\nuhci_alloc_std_chain __P((struct uhci_pipe *,\n\t\t\t    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, \n\t\t\t    uhci_soft_td_t **, uhci_soft_td_t **));\nuhci_soft_td_t *\nuhci_alloc_std(sc)\n\tuhci_softc_t *sc;\nuhci_soft_qh_t *\nuhci_alloc_sqh(sc)\n\tuhci_softc_t *sc;\n\nvoid\nuhci_free_std_chain(sc, std, stdend)\n\tuhci_softc_t *sc;\n\tuhci_soft_td_t *std;\n\tuhci_soft_td_t *stdend;\n{\n\tuhci_soft_td_t *p;\n\n\tfor (; std != stdend; std = p) {\n\t\tp = std->link.std;\n\t\tuhci_free_std(sc, std);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "uiomove",
          "args": [
            "ptr",
            "len",
            "&uio"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_detach_wakeup",
          "args": [
            "USBDEV(sc->sc_dev)"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "usb_detach_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "548-554",
          "snippet": "void\nusb_detach_wakeup(dv)\n\tdevice_ptr_t dv;\n{\n\tDPRINTF((\"usb_detach_wakeup: for %s\\n\", USBDEVPTRNAME(dv)));\n\twakeup(dv);\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nusb_detach_wakeup(dv)\n\tdevice_ptr_t dv;\n{\n\tDPRINTF((\"usb_detach_wakeup: for %s\\n\", USBDEVPTRNAME(dv)));\n\twakeup(dv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEV",
          "args": [
            "sc->sc_dev"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_do_request_flags",
          "args": [
            "sc->sc_udev",
            "&req",
            "ptr",
            "req_flags",
            "&req_actlen"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_do_request_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "952-1033",
          "snippet": "usbd_status\nusbd_do_request_flags(dev, req, data, flags, actlen)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n\tu_int16_t flags;\n\tint *actlen;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n#ifdef DIAGNOSTIC\n#if defined(__i386__) && defined(__FreeBSD__)\n\tKASSERT(intr_nesting_level == 0,\n\t       \t(\"usbd_do_request: in interrupt context\"));\n#endif\n\tif (dev->bus->intr_context) {\n\t\tprintf(\"usbd_do_request: not in process context\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n#endif\n\n\txfer = usbd_alloc_xfer(dev);\n\tif (xfer == NULL)\n\t\treturn (USBD_NOMEM);\n\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,\n\t\t\t\t   data, UGETW(req->wLength), flags, 0);\n\terr = usbd_sync_transfer(xfer);\n#if defined(USB_DEBUG) || defined(DIAGNOSTIC)\n\tif (xfer->actlen > xfer->length)\n\t\tDPRINTF((\"usbd_do_request: overrun addr=%d type=0x%02x req=0x\"\n\t\t\t \"%02x val=%d index=%d rlen=%d length=%d actlen=%d\\n\",\n\t\t\t dev->address, xfer->request.bmRequestType,\n\t\t\t xfer->request.bRequest, UGETW(xfer->request.wValue),\n\t\t\t UGETW(xfer->request.wIndex), \n\t\t\t UGETW(xfer->request.wLength), \n\t\t\t xfer->length, xfer->actlen));\n#endif\n\tif (actlen != NULL)\n\t\t*actlen = xfer->actlen;\n\tif (err == USBD_STALLED) {\n\t\t/* \n\t\t * The control endpoint has stalled.  Control endpoints\n\t\t * should not halt, but some may do so anyway so clear\n\t\t * any halt condition.\n\t\t */\n\t\tusb_device_request_t treq;\n\t\tusb_status_t status;\n\t\tu_int16_t s;\n\t\tusbd_status nerr;\n\n\t\ttreq.bmRequestType = UT_READ_ENDPOINT;\n\t\ttreq.bRequest = UR_GET_STATUS;\n\t\tUSETW(treq.wValue, 0);\n\t\tUSETW(treq.wIndex, 0);\n\t\tUSETW(treq.wLength, sizeof(usb_status_t));\n\t\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT,\n\t\t\t\t\t   &treq, &status,sizeof(usb_status_t),\n\t\t\t\t\t   0, 0);\n\t\tnerr = usbd_sync_transfer(xfer);\n\t\tif (nerr)\n\t\t\tgoto bad;\n\t\ts = UGETW(status.wStatus);\n\t\tDPRINTF((\"usbd_do_request: status = 0x%04x\\n\", s));\n\t\tif (!(s & UES_HALT))\n\t\t\tgoto bad;\n\t\ttreq.bmRequestType = UT_WRITE_ENDPOINT;\n\t\ttreq.bRequest = UR_CLEAR_FEATURE;\n\t\tUSETW(treq.wValue, UF_ENDPOINT_HALT);\n\t\tUSETW(treq.wIndex, 0);\n\t\tUSETW(treq.wLength, 0);\n\t\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT,\n\t\t\t\t\t   &treq, &status, 0, 0, 0);\n\t\tnerr = usbd_sync_transfer(xfer);\n\t\tif (nerr)\n\t\t\tgoto bad;\n\t}\n\n bad:\n\tusbd_free_xfer(xfer);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "u_int8_t index;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;",
            "u_int8_t address;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nu_int8_t index;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\nu_int8_t address;\n\nusbd_status\nusbd_do_request_flags(dev, req, data, flags, actlen)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n\tu_int16_t flags;\n\tint *actlen;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n#ifdef DIAGNOSTIC\n#if defined(__i386__) && defined(__FreeBSD__)\n\tKASSERT(intr_nesting_level == 0,\n\t       \t(\"usbd_do_request: in interrupt context\"));\n#endif\n\tif (dev->bus->intr_context) {\n\t\tprintf(\"usbd_do_request: not in process context\\n\");\n\t\treturn (USBD_INVAL);\n\t}\n#endif\n\n\txfer = usbd_alloc_xfer(dev);\n\tif (xfer == NULL)\n\t\treturn (USBD_NOMEM);\n\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,\n\t\t\t\t   data, UGETW(req->wLength), flags, 0);\n\terr = usbd_sync_transfer(xfer);\n#if defined(USB_DEBUG) || defined(DIAGNOSTIC)\n\tif (xfer->actlen > xfer->length)\n\t\tDPRINTF((\"usbd_do_request: overrun addr=%d type=0x%02x req=0x\"\n\t\t\t \"%02x val=%d index=%d rlen=%d length=%d actlen=%d\\n\",\n\t\t\t dev->address, xfer->request.bmRequestType,\n\t\t\t xfer->request.bRequest, UGETW(xfer->request.wValue),\n\t\t\t UGETW(xfer->request.wIndex), \n\t\t\t UGETW(xfer->request.wLength), \n\t\t\t xfer->length, xfer->actlen));\n#endif\n\tif (actlen != NULL)\n\t\t*actlen = xfer->actlen;\n\tif (err == USBD_STALLED) {\n\t\t/* \n\t\t * The control endpoint has stalled.  Control endpoints\n\t\t * should not halt, but some may do so anyway so clear\n\t\t * any halt condition.\n\t\t */\n\t\tusb_device_request_t treq;\n\t\tusb_status_t status;\n\t\tu_int16_t s;\n\t\tusbd_status nerr;\n\n\t\ttreq.bmRequestType = UT_READ_ENDPOINT;\n\t\ttreq.bRequest = UR_GET_STATUS;\n\t\tUSETW(treq.wValue, 0);\n\t\tUSETW(treq.wIndex, 0);\n\t\tUSETW(treq.wLength, sizeof(usb_status_t));\n\t\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT,\n\t\t\t\t\t   &treq, &status,sizeof(usb_status_t),\n\t\t\t\t\t   0, 0);\n\t\tnerr = usbd_sync_transfer(xfer);\n\t\tif (nerr)\n\t\t\tgoto bad;\n\t\ts = UGETW(status.wStatus);\n\t\tDPRINTF((\"usbd_do_request: status = 0x%04x\\n\", s));\n\t\tif (!(s & UES_HALT))\n\t\t\tgoto bad;\n\t\ttreq.bmRequestType = UT_WRITE_ENDPOINT;\n\t\ttreq.bRequest = UR_CLEAR_FEATURE;\n\t\tUSETW(treq.wValue, UF_ENDPOINT_HALT);\n\t\tUSETW(treq.wIndex, 0);\n\t\tUSETW(treq.wLength, 0);\n\t\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT,\n\t\t\t\t\t   &treq, &status, 0, 0, 0);\n\t\tnerr = usbd_sync_transfer(xfer);\n\t\tif (nerr)\n\t\t\tgoto bad;\n\t}\n\n bad:\n\tusbd_free_xfer(xfer);\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uiomove",
          "args": [
            "ptr",
            "len",
            "&uio"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "len",
            "M_TEMP",
            "M_WAITOK"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wLength",
            "len"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wIndex",
            "rcmd->index"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wValue",
            "rcmd->value"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"urio_ioctl: cmd=0x%08lx reqtype=0x%0x req=0x%0x \"\n\t\t    \"value=0x%0x index=0x%0x len=0x%0x\\n\", \n\t\t    cmd, requesttype, rcmd->request, rcmd->value,\n\t\t    rcmd->index, len)"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USB_GET_SC",
          "args": [
            "urio",
            "unit",
            "sc"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "URIOUNIT",
          "args": [
            "dev"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/urio.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/filio.h>\n#include <sys/fcntl.h>\n#include <sys/conf.h>\n#include <sys/ioccom.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nurioioctl(dev, cmd, addr, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t addr; \n\tint flag;\n\tstruct proc *p;\n{\n\tstruct urio_softc * sc;\n\tint unit = URIOUNIT(dev);\n\tstruct urio_command *rcmd;\n\tint requesttype, len;\n\tstruct iovec iov;\n\tstruct uio uio;\n\tusb_device_request_t req;\n\tusbd_status err;\n\tint req_flags = 0;\n\tu_int32_t req_actlen = 0;\n\tvoid *ptr = NULL;\n\tint error = 0;\n\n\tUSB_GET_SC(urio, unit, sc);\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\trcmd = (struct urio_command *)addr;\n\n\tswitch (cmd) {\n\tcase URIO_RECV_COMMAND:\n\t\trequesttype = rcmd->requesttype | UT_READ_VENDOR_DEVICE;\n\t\tbreak;\n\n\tcase URIO_SEND_COMMAND:\n\t\trequesttype = rcmd->requesttype | UT_WRITE_VENDOR_DEVICE;\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t\tbreak;\n\t}\n\n\tif (!(flag & FWRITE))\n\t\treturn (EPERM);\n\tlen = rcmd->length;\n\n\tDPRINTFN(1,(\"urio_ioctl: cmd=0x%08lx reqtype=0x%0x req=0x%0x \"\n\t\t    \"value=0x%0x index=0x%0x len=0x%0x\\n\", \n\t\t    cmd, requesttype, rcmd->request, rcmd->value,\n\t\t    rcmd->index, len));\n\n\t/* Send rio control message */\n\treq.bmRequestType = requesttype;\n\treq.bRequest = rcmd->request;\n\tUSETW(req.wValue, rcmd->value);\n\tUSETW(req.wIndex, rcmd->index);\n\tUSETW(req.wLength, len);\n\n\tif (len < 0 || len > 32767)\n\t\treturn (EINVAL);\n\tif (len != 0) {\n\t\tiov.iov_base = (caddr_t)rcmd->buffer;\n\t\tiov.iov_len = len;\n\t\tuio.uio_iov = &iov;\n\t\tuio.uio_iovcnt = 1;\n\t\tuio.uio_resid = len;\n\t\tuio.uio_offset = 0;\n\t\tuio.uio_segflg = UIO_USERSPACE;\n\t\tuio.uio_rw = req.bmRequestType & UT_READ ? \n\t\t\t     UIO_READ : UIO_WRITE;\n\t\tuio.uio_procp = p;\n\t\tptr = malloc(len, M_TEMP, M_WAITOK);\n\t\tif (uio.uio_rw == UIO_WRITE) {\n\t\t\terror = uiomove(ptr, len, &uio);\n\t\t\tif (error)\n\t\t\t\tgoto ret;\n\t\t}\n\t}\n\n\tsc->sc_refcnt++;\n\n\terr = usbd_do_request_flags(sc->sc_udev, &req, ptr, req_flags,\n\t\t\t\t    &req_actlen);\n\n\tif (--sc->sc_refcnt < 0)\n\t\tusb_detach_wakeup(USBDEV(sc->sc_dev));\n\n\tif (err) {\n\t\terror = EIO;\n\t} else {\n\t\tif (len != 0 && uio.uio_rw == UIO_READ)\n\t\t\terror = uiomove(ptr, len, &uio);\n\t}\n\nret:\n\tif (ptr != NULL)\n\t\tfree(ptr, M_TEMP);\n\treturn (error);\n}"
  },
  {
    "function_name": "uriowrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/urio.c",
    "lines": "417-479",
    "snippet": "int\nuriowrite(dev, uio, flag)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flag;\n{\n\tstruct urio_softc *sc;\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\tvoid *bufp;\n\tu_int32_t n;\n\tint error = 0;\n\n\tUSB_GET_SC(urio, URIOUNIT(dev), sc);\n\n\tDPRINTFN(5, (\"uriowrite: unit=%d, len=%ld\\n\", URIOUNIT(dev), \n\t\t     (long)uio->uio_resid));\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\txfer = usbd_alloc_xfer(sc->sc_udev);\n\tif (xfer == NULL)\n\t\treturn (ENOMEM);\n\tbufp = usbd_alloc_buffer(xfer, URIO_BSIZE);\n\tif (bufp == NULL) {\n\t\tusbd_free_xfer(xfer);\n\t\treturn (ENOMEM);\n\t}\n\n\tsc->sc_refcnt++;\n\n\twhile ((n = min(URIO_BSIZE, uio->uio_resid)) != 0) {\n\t\terror = uiomove(bufp, n, uio);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tDPRINTFN(1, (\"uriowrite: transfer %d bytes\\n\", n));\n\n\t\terr = usbd_bulk_transfer(xfer, sc->sc_out_pipe, 0, \n\t\t\t  URIO_RW_TIMEOUT, bufp, &n, \"uriowr\");\n\t\tDPRINTFN(2, (\"uriowrite: err=%d\\n\", err));\n\t\tif (err) {\n\t\t\tif (err == USBD_INTERRUPTED)\n\t\t\t\terror = EINTR;\n\t\t\telse if (err == USBD_TIMEOUT)\n\t\t\t\terror = ETIMEDOUT;\n\t\t\telse\n\t\t\t\terror = EIO;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tusbd_free_xfer(xfer);\n\n\tif (--sc->sc_refcnt < 0)\n\t\tusb_detach_wakeup(USBDEV(sc->sc_dev));\n\n\tDPRINTFN(5, (\"uriowrite: done unit=%d, error=%d\\n\", URIOUNIT(dev), \n\t\t     error));\n\n\treturn (error);\n}",
    "includes": [
      "#include <dev/usb/urio.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/filio.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define URIO_RW_TIMEOUT 4000\t/* ms */",
      "#define\tURIO_BSIZE\t4096"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"uriowrite: done unit=%d, error=%d\\n\", URIOUNIT(dev), \n\t\t     error)"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "URIOUNIT",
          "args": [
            "dev"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usb_detach_wakeup",
          "args": [
            "USBDEV(sc->sc_dev)"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "usb_detach_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "548-554",
          "snippet": "void\nusb_detach_wakeup(dv)\n\tdevice_ptr_t dv;\n{\n\tDPRINTF((\"usb_detach_wakeup: for %s\\n\", USBDEVPTRNAME(dv)));\n\twakeup(dv);\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nusb_detach_wakeup(dv)\n\tdevice_ptr_t dv;\n{\n\tDPRINTF((\"usb_detach_wakeup: for %s\\n\", USBDEVPTRNAME(dv)));\n\twakeup(dv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEV",
          "args": [
            "sc->sc_dev"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_free_xfer",
          "args": [
            "xfer"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_free_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "403-418",
          "snippet": "usbd_status \nusbd_free_xfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(5,(\"usbd_free_xfer: %p\\n\", xfer));\n\tif (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))\n\t\tusbd_free_buffer(xfer);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&xfer->timeout_handle)) {\n\t\tcallout_stop(&xfer->timeout_handle);\n\t\tprintf(\"usbd_free_xfer: timout_handle pending\");\n\t}\n#endif\n\txfer->device->bus->methods->freex(xfer->device->bus, xfer);\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\n\nusbd_status \nusbd_free_xfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(5,(\"usbd_free_xfer: %p\\n\", xfer));\n\tif (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))\n\t\tusbd_free_buffer(xfer);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&xfer->timeout_handle)) {\n\t\tcallout_stop(&xfer->timeout_handle);\n\t\tprintf(\"usbd_free_xfer: timout_handle pending\");\n\t}\n#endif\n\txfer->device->bus->methods->freex(xfer->device->bus, xfer);\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "2",
            "(\"uriowrite: err=%d\\n\", err)"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_bulk_transfer",
          "args": [
            "xfer",
            "sc->sc_out_pipe",
            "0",
            "URIO_RW_TIMEOUT",
            "bufp",
            "&n",
            "\"uriowr\""
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_bulk_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "499-535",
          "snippet": "usbd_status\nusbd_bulk_transfer(xfer, pipe, flags, timeout, buf, size, lbl)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid *buf;\n\tu_int32_t *size;\n\tchar *lbl;\n{\n\tusbd_status err;\n\tint s, error;\n\n\tusbd_setup_xfer(xfer, pipe, 0, buf, *size,\n\t\t\tflags, timeout, usbd_bulk_transfer_cb);\n\tDPRINTFN(1, (\"usbd_bulk_transfer: start transfer %d bytes\\n\", *size));\n\ts = splusb();\t\t/* don't want callback until tsleep() */\n\terr = usbd_transfer(xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tsplx(s);\n\t\treturn (err);\n\t}\n\terror = tsleep((caddr_t)xfer, PZERO | PCATCH, lbl, 0);\n\tsplx(s);\n\tif (error) {\n\t\tDPRINTF((\"usbd_bulk_transfer: tsleep=%d\\n\", error));\n\t\tusbd_abort_pipe(pipe);\n\t\treturn (USBD_INTERRUPTED);\n\t}\n\tusbd_get_xfer_status(xfer, NULL, NULL, size, &err);\n\tDPRINTFN(1,(\"usbd_bulk_transfer: transferred %d\\n\", *size));\n\tif (err) {\n\t\tDPRINTF((\"usbd_bulk_transfer: error=%d\\n\", err));\n\t\tusbd_clear_endpoint_stall(pipe);\n\t}\n\treturn (err);\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_status\nusbd_bulk_transfer(xfer, pipe, flags, timeout, buf, size, lbl)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid *buf;\n\tu_int32_t *size;\n\tchar *lbl;\n{\n\tusbd_status err;\n\tint s, error;\n\n\tusbd_setup_xfer(xfer, pipe, 0, buf, *size,\n\t\t\tflags, timeout, usbd_bulk_transfer_cb);\n\tDPRINTFN(1, (\"usbd_bulk_transfer: start transfer %d bytes\\n\", *size));\n\ts = splusb();\t\t/* don't want callback until tsleep() */\n\terr = usbd_transfer(xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tsplx(s);\n\t\treturn (err);\n\t}\n\terror = tsleep((caddr_t)xfer, PZERO | PCATCH, lbl, 0);\n\tsplx(s);\n\tif (error) {\n\t\tDPRINTF((\"usbd_bulk_transfer: tsleep=%d\\n\", error));\n\t\tusbd_abort_pipe(pipe);\n\t\treturn (USBD_INTERRUPTED);\n\t}\n\tusbd_get_xfer_status(xfer, NULL, NULL, size, &err);\n\tDPRINTFN(1,(\"usbd_bulk_transfer: transferred %d\\n\", *size));\n\tif (err) {\n\t\tDPRINTF((\"usbd_bulk_transfer: error=%d\\n\", err));\n\t\tusbd_clear_endpoint_stall(pipe);\n\t}\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"uriowrite: transfer %d bytes\\n\", n)"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uiomove",
          "args": [
            "bufp",
            "n",
            "uio"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "URIO_BSIZE",
            "uio->uio_resid"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "umass_scsipi_minphys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
          "lines": "3240-3247",
          "snippet": "Static void\numass_scsipi_minphys(bp)\n\tstruct buf *bp;\n{\n\tif (bp->b_bcount > UMASS_MAX_TRANSFER_SIZE)\n\t\tbp->b_bcount = UMASS_MAX_TRANSFER_SIZE;\n\tminphys(bp);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/ata/atavar.h>\t/* XXX */",
            "#include <dev/scsipi/scsi_changer.h>",
            "#include <dev/scsipi/scsi_disk.h>",
            "#include <dev/scsipi/scsipi_disk.h>",
            "#include <dev/scsipi/atapiconf.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <sys/scsiio.h>",
            "#include <cam/cam_periph.h>",
            "#include <sys/devicestat.h>",
            "#include <cam/scsi/scsi_da.h>",
            "#include <cam/scsi/scsi_all.h>",
            "#include <cam/cam_xpt_sim.h>",
            "#include <cam/cam_sim.h>",
            "#include <cam/cam_ccb.h>",
            "#include <cam/cam.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/clock.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"atapibus.h\""
          ],
          "macros_used": [
            "#define UMASS_MAX_TRANSFER_SIZE\tMAXBSIZE",
            "#define UMASS_MAX_TRANSFER_SIZE\t\t65536"
          ],
          "globals_used": [
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "Static void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UMASS_MAX_TRANSFER_SIZE\tMAXBSIZE\n#define UMASS_MAX_TRANSFER_SIZE\t\t65536\n\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\n\nStatic void\numass_scsipi_minphys(bp)\n\tstruct buf *bp;\n{\n\tif (bp->b_bcount > UMASS_MAX_TRANSFER_SIZE)\n\t\tbp->b_bcount = UMASS_MAX_TRANSFER_SIZE;\n\tminphys(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_alloc_buffer",
          "args": [
            "xfer",
            "URIO_BSIZE"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_alloc_xfer",
          "args": [
            "sc->sc_udev"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_alloc_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "388-401",
          "snippet": "usbd_xfer_handle \nusbd_alloc_xfer(dev)\n\tusbd_device_handle dev;\n{\n\tusbd_xfer_handle xfer;\n\n\txfer = dev->bus->methods->allocx(dev->bus);\n\tif (xfer == NULL)\n\t\treturn (NULL);\n\txfer->device = dev;\n\tusb_callout_init(xfer->timeout_handle);\n\tDPRINTFN(5,(\"usbd_alloc_xfer() = %p\\n\", xfer));\n\treturn (xfer);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_xfer_handle \nusbd_alloc_xfer(dev)\n\tusbd_device_handle dev;\n{\n\tusbd_xfer_handle xfer;\n\n\txfer = dev->bus->methods->allocx(dev->bus);\n\tif (xfer == NULL)\n\t\treturn (NULL);\n\txfer->device = dev;\n\tusb_callout_init(xfer->timeout_handle);\n\tDPRINTFN(5,(\"usbd_alloc_xfer() = %p\\n\", xfer));\n\treturn (xfer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"uriowrite: unit=%d, len=%ld\\n\", URIOUNIT(dev), \n\t\t     (long)uio->uio_resid)"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "URIOUNIT",
          "args": [
            "dev"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USB_GET_SC",
          "args": [
            "urio",
            "URIOUNIT(dev)",
            "sc"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "URIOUNIT",
          "args": [
            "dev"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/urio.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/filio.h>\n#include <sys/fcntl.h>\n#include <sys/conf.h>\n#include <sys/ioccom.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define URIO_RW_TIMEOUT 4000\t/* ms */\n#define\tURIO_BSIZE\t4096\n\nint\nuriowrite(dev, uio, flag)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flag;\n{\n\tstruct urio_softc *sc;\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\tvoid *bufp;\n\tu_int32_t n;\n\tint error = 0;\n\n\tUSB_GET_SC(urio, URIOUNIT(dev), sc);\n\n\tDPRINTFN(5, (\"uriowrite: unit=%d, len=%ld\\n\", URIOUNIT(dev), \n\t\t     (long)uio->uio_resid));\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\txfer = usbd_alloc_xfer(sc->sc_udev);\n\tif (xfer == NULL)\n\t\treturn (ENOMEM);\n\tbufp = usbd_alloc_buffer(xfer, URIO_BSIZE);\n\tif (bufp == NULL) {\n\t\tusbd_free_xfer(xfer);\n\t\treturn (ENOMEM);\n\t}\n\n\tsc->sc_refcnt++;\n\n\twhile ((n = min(URIO_BSIZE, uio->uio_resid)) != 0) {\n\t\terror = uiomove(bufp, n, uio);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tDPRINTFN(1, (\"uriowrite: transfer %d bytes\\n\", n));\n\n\t\terr = usbd_bulk_transfer(xfer, sc->sc_out_pipe, 0, \n\t\t\t  URIO_RW_TIMEOUT, bufp, &n, \"uriowr\");\n\t\tDPRINTFN(2, (\"uriowrite: err=%d\\n\", err));\n\t\tif (err) {\n\t\t\tif (err == USBD_INTERRUPTED)\n\t\t\t\terror = EINTR;\n\t\t\telse if (err == USBD_TIMEOUT)\n\t\t\t\terror = ETIMEDOUT;\n\t\t\telse\n\t\t\t\terror = EIO;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tusbd_free_xfer(xfer);\n\n\tif (--sc->sc_refcnt < 0)\n\t\tusb_detach_wakeup(USBDEV(sc->sc_dev));\n\n\tDPRINTFN(5, (\"uriowrite: done unit=%d, error=%d\\n\", URIOUNIT(dev), \n\t\t     error));\n\n\treturn (error);\n}"
  },
  {
    "function_name": "urioread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/urio.c",
    "lines": "357-415",
    "snippet": "int\nurioread(dev, uio, flag)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flag;\n{\n\tstruct urio_softc *sc;\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\tvoid *bufp;\n\tu_int32_t n, tn;\n\tint error = 0;\n\n\tUSB_GET_SC(urio, URIOUNIT(dev), sc);\n\n\tDPRINTFN(5, (\"urioread: %d\\n\", URIOUNIT(dev)));\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\txfer = usbd_alloc_xfer(sc->sc_udev);\n\tif (xfer == NULL)\n\t\treturn (ENOMEM);\n\tbufp = usbd_alloc_buffer(xfer, URIO_BSIZE);\n\tif (bufp == NULL) {\n\t\tusbd_free_xfer(xfer);\n\t\treturn (ENOMEM);\n\t}\n\n\tsc->sc_refcnt++;\n\n\twhile ((n = min(URIO_BSIZE, uio->uio_resid)) != 0) {\n\t\tDPRINTFN(1, (\"urioread: start transfer %d bytes\\n\", n));\n\t\ttn = n;\n\t\terr = usbd_bulk_transfer(xfer, sc->sc_in_pipe, 0,\n\t\t\t  URIO_RW_TIMEOUT, bufp, &tn, \"uriors\");\n\t\tif (err) {\n\t\t\tif (err == USBD_INTERRUPTED)\n\t\t\t\terror = EINTR;\n\t\t\telse if (err == USBD_TIMEOUT)\n\t\t\t\terror = ETIMEDOUT;\n\t\t\telse\n\t\t\t\terror = EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tDPRINTFN(1, (\"urioread: got %d bytes\\n\", tn));\n\n\t\terror = uiomove(bufp, tn, uio);\n\t\tif (error || tn < n)\n\t\t\tbreak;\n\t}\n\tusbd_free_xfer(xfer);\n\n\tif (--sc->sc_refcnt < 0)\n\t\tusb_detach_wakeup(USBDEV(sc->sc_dev));\n\n\treturn (error);\n}",
    "includes": [
      "#include <dev/usb/urio.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/filio.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define URIO_RW_TIMEOUT 4000\t/* ms */",
      "#define\tURIO_BSIZE\t4096"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "usb_detach_wakeup",
          "args": [
            "USBDEV(sc->sc_dev)"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "usb_detach_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "548-554",
          "snippet": "void\nusb_detach_wakeup(dv)\n\tdevice_ptr_t dv;\n{\n\tDPRINTF((\"usb_detach_wakeup: for %s\\n\", USBDEVPTRNAME(dv)));\n\twakeup(dv);\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nusb_detach_wakeup(dv)\n\tdevice_ptr_t dv;\n{\n\tDPRINTF((\"usb_detach_wakeup: for %s\\n\", USBDEVPTRNAME(dv)));\n\twakeup(dv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEV",
          "args": [
            "sc->sc_dev"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_free_xfer",
          "args": [
            "xfer"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_free_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "403-418",
          "snippet": "usbd_status \nusbd_free_xfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(5,(\"usbd_free_xfer: %p\\n\", xfer));\n\tif (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))\n\t\tusbd_free_buffer(xfer);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&xfer->timeout_handle)) {\n\t\tcallout_stop(&xfer->timeout_handle);\n\t\tprintf(\"usbd_free_xfer: timout_handle pending\");\n\t}\n#endif\n\txfer->device->bus->methods->freex(xfer->device->bus, xfer);\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\n\nusbd_status \nusbd_free_xfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(5,(\"usbd_free_xfer: %p\\n\", xfer));\n\tif (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))\n\t\tusbd_free_buffer(xfer);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&xfer->timeout_handle)) {\n\t\tcallout_stop(&xfer->timeout_handle);\n\t\tprintf(\"usbd_free_xfer: timout_handle pending\");\n\t}\n#endif\n\txfer->device->bus->methods->freex(xfer->device->bus, xfer);\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uiomove",
          "args": [
            "bufp",
            "tn",
            "uio"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"urioread: got %d bytes\\n\", tn)"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_bulk_transfer",
          "args": [
            "xfer",
            "sc->sc_in_pipe",
            "0",
            "URIO_RW_TIMEOUT",
            "bufp",
            "&tn",
            "\"uriors\""
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_bulk_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "499-535",
          "snippet": "usbd_status\nusbd_bulk_transfer(xfer, pipe, flags, timeout, buf, size, lbl)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid *buf;\n\tu_int32_t *size;\n\tchar *lbl;\n{\n\tusbd_status err;\n\tint s, error;\n\n\tusbd_setup_xfer(xfer, pipe, 0, buf, *size,\n\t\t\tflags, timeout, usbd_bulk_transfer_cb);\n\tDPRINTFN(1, (\"usbd_bulk_transfer: start transfer %d bytes\\n\", *size));\n\ts = splusb();\t\t/* don't want callback until tsleep() */\n\terr = usbd_transfer(xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tsplx(s);\n\t\treturn (err);\n\t}\n\terror = tsleep((caddr_t)xfer, PZERO | PCATCH, lbl, 0);\n\tsplx(s);\n\tif (error) {\n\t\tDPRINTF((\"usbd_bulk_transfer: tsleep=%d\\n\", error));\n\t\tusbd_abort_pipe(pipe);\n\t\treturn (USBD_INTERRUPTED);\n\t}\n\tusbd_get_xfer_status(xfer, NULL, NULL, size, &err);\n\tDPRINTFN(1,(\"usbd_bulk_transfer: transferred %d\\n\", *size));\n\tif (err) {\n\t\tDPRINTF((\"usbd_bulk_transfer: error=%d\\n\", err));\n\t\tusbd_clear_endpoint_stall(pipe);\n\t}\n\treturn (err);\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_status\nusbd_bulk_transfer(xfer, pipe, flags, timeout, buf, size, lbl)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid *buf;\n\tu_int32_t *size;\n\tchar *lbl;\n{\n\tusbd_status err;\n\tint s, error;\n\n\tusbd_setup_xfer(xfer, pipe, 0, buf, *size,\n\t\t\tflags, timeout, usbd_bulk_transfer_cb);\n\tDPRINTFN(1, (\"usbd_bulk_transfer: start transfer %d bytes\\n\", *size));\n\ts = splusb();\t\t/* don't want callback until tsleep() */\n\terr = usbd_transfer(xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tsplx(s);\n\t\treturn (err);\n\t}\n\terror = tsleep((caddr_t)xfer, PZERO | PCATCH, lbl, 0);\n\tsplx(s);\n\tif (error) {\n\t\tDPRINTF((\"usbd_bulk_transfer: tsleep=%d\\n\", error));\n\t\tusbd_abort_pipe(pipe);\n\t\treturn (USBD_INTERRUPTED);\n\t}\n\tusbd_get_xfer_status(xfer, NULL, NULL, size, &err);\n\tDPRINTFN(1,(\"usbd_bulk_transfer: transferred %d\\n\", *size));\n\tif (err) {\n\t\tDPRINTF((\"usbd_bulk_transfer: error=%d\\n\", err));\n\t\tusbd_clear_endpoint_stall(pipe);\n\t}\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"urioread: start transfer %d bytes\\n\", n)"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "URIO_BSIZE",
            "uio->uio_resid"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "umass_scsipi_minphys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
          "lines": "3240-3247",
          "snippet": "Static void\numass_scsipi_minphys(bp)\n\tstruct buf *bp;\n{\n\tif (bp->b_bcount > UMASS_MAX_TRANSFER_SIZE)\n\t\tbp->b_bcount = UMASS_MAX_TRANSFER_SIZE;\n\tminphys(bp);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/ata/atavar.h>\t/* XXX */",
            "#include <dev/scsipi/scsi_changer.h>",
            "#include <dev/scsipi/scsi_disk.h>",
            "#include <dev/scsipi/scsipi_disk.h>",
            "#include <dev/scsipi/atapiconf.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <sys/scsiio.h>",
            "#include <cam/cam_periph.h>",
            "#include <sys/devicestat.h>",
            "#include <cam/scsi/scsi_da.h>",
            "#include <cam/scsi/scsi_all.h>",
            "#include <cam/cam_xpt_sim.h>",
            "#include <cam/cam_sim.h>",
            "#include <cam/cam_ccb.h>",
            "#include <cam/cam.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/clock.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"atapibus.h\""
          ],
          "macros_used": [
            "#define UMASS_MAX_TRANSFER_SIZE\tMAXBSIZE",
            "#define UMASS_MAX_TRANSFER_SIZE\t\t65536"
          ],
          "globals_used": [
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "Static void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UMASS_MAX_TRANSFER_SIZE\tMAXBSIZE\n#define UMASS_MAX_TRANSFER_SIZE\t\t65536\n\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\n\nStatic void\numass_scsipi_minphys(bp)\n\tstruct buf *bp;\n{\n\tif (bp->b_bcount > UMASS_MAX_TRANSFER_SIZE)\n\t\tbp->b_bcount = UMASS_MAX_TRANSFER_SIZE;\n\tminphys(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_alloc_buffer",
          "args": [
            "xfer",
            "URIO_BSIZE"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_alloc_xfer",
          "args": [
            "sc->sc_udev"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_alloc_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "388-401",
          "snippet": "usbd_xfer_handle \nusbd_alloc_xfer(dev)\n\tusbd_device_handle dev;\n{\n\tusbd_xfer_handle xfer;\n\n\txfer = dev->bus->methods->allocx(dev->bus);\n\tif (xfer == NULL)\n\t\treturn (NULL);\n\txfer->device = dev;\n\tusb_callout_init(xfer->timeout_handle);\n\tDPRINTFN(5,(\"usbd_alloc_xfer() = %p\\n\", xfer));\n\treturn (xfer);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_xfer_handle \nusbd_alloc_xfer(dev)\n\tusbd_device_handle dev;\n{\n\tusbd_xfer_handle xfer;\n\n\txfer = dev->bus->methods->allocx(dev->bus);\n\tif (xfer == NULL)\n\t\treturn (NULL);\n\txfer->device = dev;\n\tusb_callout_init(xfer->timeout_handle);\n\tDPRINTFN(5,(\"usbd_alloc_xfer() = %p\\n\", xfer));\n\treturn (xfer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"urioread: %d\\n\", URIOUNIT(dev))"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "URIOUNIT",
          "args": [
            "dev"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USB_GET_SC",
          "args": [
            "urio",
            "URIOUNIT(dev)",
            "sc"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "URIOUNIT",
          "args": [
            "dev"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/urio.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/filio.h>\n#include <sys/fcntl.h>\n#include <sys/conf.h>\n#include <sys/ioccom.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define URIO_RW_TIMEOUT 4000\t/* ms */\n#define\tURIO_BSIZE\t4096\n\nint\nurioread(dev, uio, flag)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flag;\n{\n\tstruct urio_softc *sc;\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\tvoid *bufp;\n\tu_int32_t n, tn;\n\tint error = 0;\n\n\tUSB_GET_SC(urio, URIOUNIT(dev), sc);\n\n\tDPRINTFN(5, (\"urioread: %d\\n\", URIOUNIT(dev)));\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\txfer = usbd_alloc_xfer(sc->sc_udev);\n\tif (xfer == NULL)\n\t\treturn (ENOMEM);\n\tbufp = usbd_alloc_buffer(xfer, URIO_BSIZE);\n\tif (bufp == NULL) {\n\t\tusbd_free_xfer(xfer);\n\t\treturn (ENOMEM);\n\t}\n\n\tsc->sc_refcnt++;\n\n\twhile ((n = min(URIO_BSIZE, uio->uio_resid)) != 0) {\n\t\tDPRINTFN(1, (\"urioread: start transfer %d bytes\\n\", n));\n\t\ttn = n;\n\t\terr = usbd_bulk_transfer(xfer, sc->sc_in_pipe, 0,\n\t\t\t  URIO_RW_TIMEOUT, bufp, &tn, \"uriors\");\n\t\tif (err) {\n\t\t\tif (err == USBD_INTERRUPTED)\n\t\t\t\terror = EINTR;\n\t\t\telse if (err == USBD_TIMEOUT)\n\t\t\t\terror = ETIMEDOUT;\n\t\t\telse\n\t\t\t\terror = EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tDPRINTFN(1, (\"urioread: got %d bytes\\n\", tn));\n\n\t\terror = uiomove(bufp, tn, uio);\n\t\tif (error || tn < n)\n\t\t\tbreak;\n\t}\n\tusbd_free_xfer(xfer);\n\n\tif (--sc->sc_refcnt < 0)\n\t\tusb_detach_wakeup(USBDEV(sc->sc_dev));\n\n\treturn (error);\n}"
  },
  {
    "function_name": "urioclose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/urio.c",
    "lines": "330-355",
    "snippet": "int\nurioclose(dev, flag, mode, p)\n\tdev_t dev;\n\tint flag;\n\tint mode;\n\tstruct proc *p;\n{\n\tstruct urio_softc *sc;\n\tUSB_GET_SC(urio, URIOUNIT(dev), sc);\n\n\tDPRINTFN(5, (\"urioclose: flag=%d, mode=%d, unit=%d\\n\",\n\t\t     flag, mode, URIOUNIT(dev)));\n\n\tif (sc->sc_in_pipe != NULL) {\n\t\tusbd_abort_pipe(sc->sc_in_pipe);\n\t\tusbd_close_pipe(sc->sc_in_pipe);\n\t\tsc->sc_in_pipe = NULL;\n\t}\n\tif (sc->sc_out_pipe != NULL) {\n\t\tusbd_abort_pipe(sc->sc_out_pipe);\n\t\tusbd_close_pipe(sc->sc_out_pipe);\n\t\tsc->sc_out_pipe = NULL;\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/urio.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/filio.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_close_pipe",
          "args": [
            "sc->sc_out_pipe"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_close_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "224-252",
          "snippet": "usbd_status\nusbd_close_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\n\tif (--pipe->refcnt != 0)\n\t\treturn (USBD_NORMAL_COMPLETION);\n\tif (SIMPLEQ_FIRST(&pipe->queue) != 0)\n\t\treturn (USBD_PENDING_REQUESTS);\n\tLIST_REMOVE(pipe, next);\n\tpipe->endpoint->refcnt--;\n\tpipe->methods->close(pipe);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&pipe->abort_handle)) {\n\t\tcallout_stop(&pipe->abort_handle);\n\t\tprintf(\"usbd_close_pipe: abort_handle pending\");\n\t}\n#endif\n\tif (pipe->intrxfer != NULL)\n\t\tusbd_free_xfer(pipe->intrxfer);\n\tfree(pipe, M_USB);\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusbd_close_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\n\tif (--pipe->refcnt != 0)\n\t\treturn (USBD_NORMAL_COMPLETION);\n\tif (SIMPLEQ_FIRST(&pipe->queue) != 0)\n\t\treturn (USBD_PENDING_REQUESTS);\n\tLIST_REMOVE(pipe, next);\n\tpipe->endpoint->refcnt--;\n\tpipe->methods->close(pipe);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&pipe->abort_handle)) {\n\t\tcallout_stop(&pipe->abort_handle);\n\t\tprintf(\"usbd_close_pipe: abort_handle pending\");\n\t}\n#endif\n\tif (pipe->intrxfer != NULL)\n\t\tusbd_free_xfer(pipe->intrxfer);\n\tfree(pipe, M_USB);\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_abort_pipe",
          "args": [
            "sc->sc_out_pipe"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_abort_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "560-577",
          "snippet": "usbd_status \nusbd_abort_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_status err;\n\tint s;\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\ts = splusb();\n\terr = usbd_ar_pipe(pipe);\n\tsplx(s);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status \nusbd_abort_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n\tusbd_status err;\n\tint s;\n\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\ts = splusb();\n\terr = usbd_ar_pipe(pipe);\n\tsplx(s);\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"urioclose: flag=%d, mode=%d, unit=%d\\n\",\n\t\t     flag, mode, URIOUNIT(dev))"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "URIOUNIT",
          "args": [
            "dev"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USB_GET_SC",
          "args": [
            "urio",
            "URIOUNIT(dev)",
            "sc"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "URIOUNIT",
          "args": [
            "dev"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/urio.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/filio.h>\n#include <sys/fcntl.h>\n#include <sys/conf.h>\n#include <sys/ioccom.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nurioclose(dev, flag, mode, p)\n\tdev_t dev;\n\tint flag;\n\tint mode;\n\tstruct proc *p;\n{\n\tstruct urio_softc *sc;\n\tUSB_GET_SC(urio, URIOUNIT(dev), sc);\n\n\tDPRINTFN(5, (\"urioclose: flag=%d, mode=%d, unit=%d\\n\",\n\t\t     flag, mode, URIOUNIT(dev)));\n\n\tif (sc->sc_in_pipe != NULL) {\n\t\tusbd_abort_pipe(sc->sc_in_pipe);\n\t\tusbd_close_pipe(sc->sc_in_pipe);\n\t\tsc->sc_in_pipe = NULL;\n\t}\n\tif (sc->sc_out_pipe != NULL) {\n\t\tusbd_abort_pipe(sc->sc_out_pipe);\n\t\tusbd_close_pipe(sc->sc_out_pipe);\n\t\tsc->sc_out_pipe = NULL;\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "urioopen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/urio.c",
    "lines": "293-328",
    "snippet": "int\nurioopen(dev, flag, mode, p)\n\tdev_t dev;\n\tint flag;\n\tint mode;\n\tstruct proc *p;\n{\n\tstruct urio_softc *sc;\n\tusbd_status err;\n\n\tUSB_GET_SC_OPEN(urio, URIOUNIT(dev), sc);\n\n\tDPRINTFN(5, (\"urioopen: flag=%d, mode=%d, unit=%d\\n\", \n\t\t     flag, mode, URIOUNIT(dev)));\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\tif (sc->sc_in_pipe != NULL)\n\t\treturn (EBUSY);\n\n\tif ((flag & (FWRITE|FREAD)) != (FWRITE|FREAD))\n\t\treturn (EACCES);\n\n\terr = usbd_open_pipe(sc->sc_iface, sc->sc_in_addr, 0, &sc->sc_in_pipe);\n\tif (err)\n\t\treturn (EIO);\n\terr = usbd_open_pipe(sc->sc_iface, sc->sc_out_addr,0,&sc->sc_out_pipe);\n\tif (err) {\n\t\tusbd_close_pipe(sc->sc_in_pipe);\n\t\tsc->sc_in_pipe = NULL;\n\t\treturn (EIO);\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/urio.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/filio.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_close_pipe",
          "args": [
            "sc->sc_in_pipe"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_close_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "224-252",
          "snippet": "usbd_status\nusbd_close_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\n\tif (--pipe->refcnt != 0)\n\t\treturn (USBD_NORMAL_COMPLETION);\n\tif (SIMPLEQ_FIRST(&pipe->queue) != 0)\n\t\treturn (USBD_PENDING_REQUESTS);\n\tLIST_REMOVE(pipe, next);\n\tpipe->endpoint->refcnt--;\n\tpipe->methods->close(pipe);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&pipe->abort_handle)) {\n\t\tcallout_stop(&pipe->abort_handle);\n\t\tprintf(\"usbd_close_pipe: abort_handle pending\");\n\t}\n#endif\n\tif (pipe->intrxfer != NULL)\n\t\tusbd_free_xfer(pipe->intrxfer);\n\tfree(pipe, M_USB);\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusbd_close_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\n\tif (--pipe->refcnt != 0)\n\t\treturn (USBD_NORMAL_COMPLETION);\n\tif (SIMPLEQ_FIRST(&pipe->queue) != 0)\n\t\treturn (USBD_PENDING_REQUESTS);\n\tLIST_REMOVE(pipe, next);\n\tpipe->endpoint->refcnt--;\n\tpipe->methods->close(pipe);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&pipe->abort_handle)) {\n\t\tcallout_stop(&pipe->abort_handle);\n\t\tprintf(\"usbd_close_pipe: abort_handle pending\");\n\t}\n#endif\n\tif (pipe->intrxfer != NULL)\n\t\tusbd_free_xfer(pipe->intrxfer);\n\tfree(pipe, M_USB);\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_open_pipe",
          "args": [
            "sc->sc_iface",
            "sc->sc_out_addr",
            "0",
            "&sc->sc_out_pipe"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_open_pipe_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "177-222",
          "snippet": "usbd_status \nusbd_open_pipe_intr(iface, address, flags, pipe, priv, buffer, len, cb, ival)\n\tusbd_interface_handle iface;\n\tu_int8_t address;\n\tu_int8_t flags;\n\tusbd_pipe_handle *pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t len;\n\tusbd_callback cb;\n\tint ival;\n{\n\tusbd_status err;\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle ipipe;\n\n\tDPRINTFN(3,(\"usbd_open_pipe_intr: address=0x%x flags=0x%x len=%d\\n\",\n\t\t    address, flags, len));\n\n\terr = usbd_open_pipe_ival(iface, address, USBD_EXCLUSIVE_USE, \n\t\t\t\t  &ipipe, ival);\n\tif (err)\n\t\treturn (err);\n\txfer = usbd_alloc_xfer(iface->device);\n\tif (xfer == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad1;\n\t}\n\tusbd_setup_xfer(xfer, ipipe, priv, buffer, len, flags,\n\t    USBD_NO_TIMEOUT, cb);\n\tipipe->intrxfer = xfer;\n\tipipe->repeat = 1;\n\terr = usbd_transfer(xfer);\n\t*pipe = ipipe;\n\tif (err != USBD_IN_PROGRESS)\n\t\tgoto bad2;\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad2:\n\tipipe->intrxfer = NULL;\n\tipipe->repeat = 0;\n\tusbd_free_xfer(xfer);\n bad1:\n\tusbd_close_pipe(ipipe);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
            "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;",
            "u_int8_t address;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\nu_int8_t address;\n\nusbd_status \nusbd_open_pipe_intr(iface, address, flags, pipe, priv, buffer, len, cb, ival)\n\tusbd_interface_handle iface;\n\tu_int8_t address;\n\tu_int8_t flags;\n\tusbd_pipe_handle *pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t len;\n\tusbd_callback cb;\n\tint ival;\n{\n\tusbd_status err;\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle ipipe;\n\n\tDPRINTFN(3,(\"usbd_open_pipe_intr: address=0x%x flags=0x%x len=%d\\n\",\n\t\t    address, flags, len));\n\n\terr = usbd_open_pipe_ival(iface, address, USBD_EXCLUSIVE_USE, \n\t\t\t\t  &ipipe, ival);\n\tif (err)\n\t\treturn (err);\n\txfer = usbd_alloc_xfer(iface->device);\n\tif (xfer == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad1;\n\t}\n\tusbd_setup_xfer(xfer, ipipe, priv, buffer, len, flags,\n\t    USBD_NO_TIMEOUT, cb);\n\tipipe->intrxfer = xfer;\n\tipipe->repeat = 1;\n\terr = usbd_transfer(xfer);\n\t*pipe = ipipe;\n\tif (err != USBD_IN_PROGRESS)\n\t\tgoto bad2;\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad2:\n\tipipe->intrxfer = NULL;\n\tipipe->repeat = 0;\n\tusbd_free_xfer(xfer);\n bad1:\n\tusbd_close_pipe(ipipe);\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "5",
            "(\"urioopen: flag=%d, mode=%d, unit=%d\\n\", \n\t\t     flag, mode, URIOUNIT(dev))"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "URIOUNIT",
          "args": [
            "dev"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USB_GET_SC_OPEN",
          "args": [
            "urio",
            "URIOUNIT(dev)",
            "sc"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "URIOUNIT",
          "args": [
            "dev"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/urio.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/filio.h>\n#include <sys/fcntl.h>\n#include <sys/conf.h>\n#include <sys/ioccom.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nurioopen(dev, flag, mode, p)\n\tdev_t dev;\n\tint flag;\n\tint mode;\n\tstruct proc *p;\n{\n\tstruct urio_softc *sc;\n\tusbd_status err;\n\n\tUSB_GET_SC_OPEN(urio, URIOUNIT(dev), sc);\n\n\tDPRINTFN(5, (\"urioopen: flag=%d, mode=%d, unit=%d\\n\", \n\t\t     flag, mode, URIOUNIT(dev)));\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\tif (sc->sc_in_pipe != NULL)\n\t\treturn (EBUSY);\n\n\tif ((flag & (FWRITE|FREAD)) != (FWRITE|FREAD))\n\t\treturn (EACCES);\n\n\terr = usbd_open_pipe(sc->sc_iface, sc->sc_in_addr, 0, &sc->sc_in_pipe);\n\tif (err)\n\t\treturn (EIO);\n\terr = usbd_open_pipe(sc->sc_iface, sc->sc_out_addr,0,&sc->sc_out_pipe);\n\tif (err) {\n\t\tusbd_close_pipe(sc->sc_in_pipe);\n\t\tsc->sc_in_pipe = NULL;\n\t\treturn (EIO);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "urio_activate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/urio.c",
    "lines": "273-290",
    "snippet": "int\nurio_activate(self, act)\n\tdevice_ptr_t self;\n\tenum devact act;\n{\n\tstruct urio_softc *sc = (struct urio_softc *)self;\n\n\tswitch (act) {\n\tcase DVACT_ACTIVATE:\n\t\treturn (EOPNOTSUPP);\n\t\tbreak;\n\n\tcase DVACT_DEACTIVATE:\n\t\tsc->sc_dying = 1;\n\t\tbreak;\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/urio.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/poll.h>",
      "#include <sys/vnode.h>",
      "#include <sys/proc.h>",
      "#include <sys/select.h>",
      "#include <sys/file.h>",
      "#include <sys/conf.h>",
      "#include <sys/filio.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/conf.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/usb/urio.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/poll.h>\n#include <sys/vnode.h>\n#include <sys/proc.h>\n#include <sys/select.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/filio.h>\n#include <sys/fcntl.h>\n#include <sys/conf.h>\n#include <sys/ioccom.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nurio_activate(self, act)\n\tdevice_ptr_t self;\n\tenum devact act;\n{\n\tstruct urio_softc *sc = (struct urio_softc *)self;\n\n\tswitch (act) {\n\tcase DVACT_ACTIVATE:\n\t\treturn (EOPNOTSUPP);\n\t\tbreak;\n\n\tcase DVACT_DEACTIVATE:\n\t\tsc->sc_dying = 1;\n\t\tbreak;\n\t}\n\treturn (0);\n}"
  }
]