[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncrstat.c",
    "lines": "1477-1631",
    "snippet": "void main(argc, argv)\n\tint argc;\n\tchar **argv;\n{\n\textern char *optarg;\n\textern int optind;\n\tint\tusage=0;\n\tchar * charp;\n\tint ch, getopt(),atoi();\n\tint i,step;\n\n\tprog = *argv;\n\twhile ((ch = getopt(argc, argv, \"M:N:u:f:t:l:p:s:k:d:vwhin:?\")) != -1)\n\tswitch((char)ch) {\n\tcase 'M':\n\t\tif (kvm_isopen) {\n\t\t\tfprintf (stderr,\n\t\t\t\t\"%s: -M: kernel file already open.\\n\",\n\t\t\t\tprog);\n\t\t\texit (1);\n\t\t};\n\t\tkmemf = optarg;\n\t\tbreak;\n\tcase 'N':\n\t\tif (kvm_isopen) {\n\t\t\tfprintf (stderr,\n\t\t\t\t\"%s: -N: symbol table already open.\\n\",\n\t\t\t\tprog);\n\t\t\texit (1);\n\t\t};\n\t\tvmunix = optarg;\n\t\tbreak;\n\tcase 'f':\n\t\tfprintf (stderr,\n\t\t\t\"%s: -f: option not yet implemented.\\n\",\n\t\t\tprog);\n\t\texit (1);\n\f\n        case 'u':\n\t\ti = strtoul (optarg, &charp, 0);\n\t\tif (!*optarg || *charp || (i<0)) {\n\t\t\tfprintf (stderr,\n\t\t\t\t\"%s: bad unit number \\\"%s\\\".\\n\",\n\t\t\t\tprog, optarg);\n\t\t\texit (1);\n\t\t}\n\t\tncr_unit = i;\n\t\tbreak;\n\tcase 't':\n\t\ti = strtoul (optarg, &charp, 0);\n\t\tif (!*optarg || *charp || (i<0) || (i>=MAX_TARGET)) {\n\t\t\tfprintf (stderr,\n\t\t\t\t\"%s: bad target number \\\"%s\\\" (valid range: 0-%d).\\n\",\n\t\t\t\tprog, optarg, MAX_TARGET-1);\n\t\t\texit (1);\n\t\t}\n\t\ttarget_mask |= 1ul << i;\n\t\tbreak;\n\tcase 'n':\n\t\topen_kvm(O_RDONLY);\n\t\ti = strtoul (optarg, &charp, 0);\n\t\tprintf (\"addr %d (0x%x) has label %s.\\n\",\n\t\t\ti,i,sn(i));\n\t\tbreak;\n\tcase 'l':\n\t\ti = strtoul (optarg, &charp, 0);\n\t\tif (!*optarg || *charp || (i<0) || (i>=MAX_LUN)) {\n\t\t\tfprintf (stderr,\n\t\t\t\t\"%s: bad logic unit number \\\"%s\\\" (valid range: 0-%d).\\n\",\n\t\t\t\tprog, optarg, MAX_LUN);\n\t\t\texit (1);\n\t\t}\n\t\tglobal_lun_mask |= 1ul << i;\n\t\tbreak;\n\tcase 'p':\n\t\ti = strtoul (optarg, &charp, 0);\n\t\tif (!*optarg || *charp || (i<1) || (i>60)) {\n\t\t\tfprintf (stderr,\n\t\t\t\t\"%s: bad interval \\\"%s\\\".\\n\",\n\t\t\t\tprog, optarg);\n\t\t\texit (1);\n\t\t}\n\t\tinterval = i;\n\t\tdo_profile();\n\t\tbreak;\n\n        case 'w':\n\t\twizard=1;\n\t\tbreak;\n\tcase 'v':\n\t\tverbose++;\n\t\tbreak;\n\tcase 'i':\n\t\tdo_info();\n\t\tbreak;\n\f\n\tcase 's':\n\t\tdo_set(optarg);\n\t\tbreak;\n\tcase 'd':\n\t\tdo_debug(optarg);\n\t\tbreak;\n\tcase 'k':\n\t\tdo_kill(optarg);\n\t\tbreak;\n\tcase 'h':\n\tcase '?':\n\t\tusage++;\n\t\tbreak;\n\tdefault:(void)fprintf(stderr,\n\t\t\"%s: illegal option \\\"%c\\\".\\n\", prog, ch);\n\t\tusage++;\n\t}\n\n\targv += optind;\n\targc -= optind;\n\n\tif (argc) printf (\"%s: rest of line starting with \\\"%s\\\" ignored.\\n\",\n\t\tprog, *argv);\n\n\tif (verbose&&!kvm_isopen) usage++;\n\tif (usage) {\n\t\tfprintf (stderr,\n\t\"Usage:\\n\"\n\t\"\\n\"\n\t\"%s [-M$] [-N$] {-f$} {-t#} {-l#} [-hivw?] [-d$] [-s$] [-k] [[-p] <time>]\\n\"\n\t\"\\n\"\n\t\"-t <#>             select target number\\n\"\n\t\"-l <#>             select lun number\\n\"\n\t\"-i                 get info\\n\"\n\t\"-v                 verbose\\n\"\n\t\"-p <seconds>       performance data\\n\"\n\t\"\\n\"\n\t\"Wizards only (proceed on your own risk):\\n\"\n\t\"-n <#>             get the name for address #\\n\"\n\t\"-w                 wizard mode\\n\"\n\t\"-d <options>       debug info\\n\"\n\t\"-d?                list debug options\\n\"\n\t\"-s <param=value>   set parameter\\n\"\n\t\"-s?                list parameters\\n\"\n\t\"-k <torture>       torture driver by simulating errors\\n\"\n\t\"-k?                list tortures\\n\"\n\t\"-M <kernelimage>   (default: %s)\\n\"\n\t\"-N <symboltable>   (default: %s)\\n\"\n\t, prog, _PATH_KMEM, _PATH_UNIX);\n\t\tif (verbose) fprintf (stderr, ident);\n\t\texit (1);\n\t}\n\n\tif (!kvm_isopen) {\n\t\tdo_info();\n\t\tdo_profile();\n\t};\n\texit (0);\n}",
    "includes": [
      "#include <dev/pci/ncr.c>",
      "#include <kvm.h>",
      "#include <limits.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <nlist.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern void  exit();",
      "char\t*prog;",
      "u_long\tverbose;",
      "u_long  wizard;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_profile",
          "args": [],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_info",
          "args": [],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "ident"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Usage:\\n\"\n\t\"\\n\"\n\t\"%s [-M$] [-N$] {-f$} {-t#} {-l#} [-hivw?] [-d$] [-s$] [-k] [[-p] <time>]\\n\"\n\t\"\\n\"\n\t\"-t <#>             select target number\\n\"\n\t\"-l <#>             select lun number\\n\"\n\t\"-i                 get info\\n\"\n\t\"-v                 verbose\\n\"\n\t\"-p <seconds>       performance data\\n\"\n\t\"\\n\"\n\t\"Wizards only (proceed on your own risk):\\n\"\n\t\"-n <#>             get the name for address #\\n\"\n\t\"-w                 wizard mode\\n\"\n\t\"-d <options>       debug info\\n\"\n\t\"-d?                list debug options\\n\"\n\t\"-s <param=value>   set parameter\\n\"\n\t\"-s?                list parameters\\n\"\n\t\"-k <torture>       torture driver by simulating errors\\n\"\n\t\"-k?                list tortures\\n\"\n\t\"-M <kernelimage>   (default: %s)\\n\"\n\t\"-N <symboltable>   (default: %s)\\n\"",
            "prog",
            "_PATH_KMEM",
            "_PATH_UNIX"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: rest of line starting with \\\"%s\\\" ignored.\\n\"",
            "prog",
            "*argv"
          ],
          "line": 1594
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: illegal option \\\"%c\\\".\\n\"",
            "prog",
            "ch"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_kill",
          "args": [
            "optarg"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_debug",
          "args": [
            "optarg"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_set",
          "args": [
            "optarg"
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "do_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncrstat.c",
          "lines": "680-808",
          "snippet": "void do_set (char * arg)\n{\n\tstruct usrcmd user;\n\tu_long addr;\n\tint i;\n\n\topen_kvm(O_RDWR);\n\taddr = ncr_base + offsetof (struct ncb, user);\n\n\tfor (i=3; i; i--) {\n\t\tif (!KVM_READ (\n\t\t\t(addr),\n\t\t\t&user,\n\t\t\tsizeof (user))) {\n\t\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\t\texit (1);\n\t\t}\n\t\tif (!user.cmd) break;\n\t\tsleep (1);\n\t}\n\tif (user.cmd) {\n\t\tfprintf (stderr, \"%s: ncb.user busy.\\n\", prog);\n\t\texit (1);\n\t};\n\n\tuser.target = target_mask;\n\tuser.lun    = lun_mask;\n\tuser.data   = 0;\n\tuser.cmd    = 0;\n\n\tif (!strcmp(arg, \"?\")) { printf (\n\"async:         disable synchronous transfers.\\n\"\n\"sync=value:    set the maximal synchronous transfer rate (MHz).\\n\"\n\"fast:          set FAST SCSI-2.\\n\"\n\"\\n\"\n\"wide=value:    set the bus width (0=8bit 1=16bit).\\n\"\n\"\\n\"\n\"tags=value:    use this number of tags.\\n\"\n\"orderedtag:    use ordered tags only.\\n\"\n\"simpletag:     use simple tags only.\\n\"\n\"orderedwrite:  use simple tags for read, else ordered tags.\\n\"\n\"\\n\"\n\"debug=value:   set debug mode.\\n\"\n\"\\n\");\n\t\treturn;\n\t};\n\f\n\tif (!strcmp(arg, \"async\")) {\n\t\tuser.data = 255;\n\t\tuser.cmd  = UC_SETSYNC;\n\t};\n\n\tif (!strcmp(arg, \"fast\")) {\n\t\tuser.data = 25;\n\t\tuser.cmd  = UC_SETSYNC;\n\t};\n\n\tif (!strncmp(arg, \"sync=\", 5)) {\n\t\tfloat f = strtod (arg+5, NULL);\n\t\tif (f>=4.0 && f<=10.0) {\n\t\t\tuser.data = 250.0 / f;\n\t\t\tuser.cmd  = UC_SETSYNC;\n\t\t};\n\t};\n\n\tif (!strncmp(arg, \"wide=\", 5)) {\n\t\tu_char t = strtoul (arg+5, (char**)0, 0);\n\t\tif (t<=1) {\n\t\t\tuser.data = t;\n\t\t\tuser.cmd  = UC_SETWIDE;\n\t\t};\n\t};\n\n\tif (!strncmp(arg, \"tags=\", 5)) {\n\t\tu_char t = strtoul (arg+5, (char**)0, 0);\n\t\tif (t<=SCSI_NCR_MAX_TAGS) {\n\t\t\tuser.data = t;\n\t\t\tuser.cmd  = UC_SETTAGS;\n\t\t};\n\t};\n\n\tif (!strncmp(arg, \"flags=\", 6)) {\n\t\tu_char t = strtoul (arg+6, (char**)0, 0);\n\t\tif (t<=0xff) {\n\t\t\tuser.data = t;\n\t\t\tuser.cmd  = UC_SETFLAG;\n\t\t};\n\t};\n\n\tif (!strncmp(arg, \"debug=\", 6)) {\n\t\tuser.data = strtoul (arg+6, (char**)0, 0);\n\t\tuser.cmd  = UC_SETDEBUG;\n\t};\n\n\tif (!strcmp(arg, \"orderedtag\")) {\n\t\tuser.data = M_ORDERED_TAG;\n\t\tuser.cmd  = UC_SETORDER;\n\t};\n\n\tif (!strcmp(arg, \"simpletag\")) {\n\t\tuser.data = M_SIMPLE_TAG;\n\t\tuser.cmd  = UC_SETORDER;\n\t};\n\f\n\tif (!strcmp(arg, \"orderedwrite\")) {\n\t\tuser.data = 0;\n\t\tuser.cmd  = UC_SETORDER;\n\t};\n\n\tif (user.cmd) {\n\t\topenkernelwritefile();\n\n\t\tif (lseek (kernelwritefile, addr, 0) != addr) {\n\t\t\tfprintf (stderr, \"%s: %s: %s\\n\",\n\t\t\t\tprog, kernelwritefilename, strerror(errno));\n\t\t\texit (1);\n\t\t}\n\t\tif (write (kernelwritefile, &user, sizeof (user)) < 0) {\n\t\t\tfprintf (stderr, \"%s: %s: %s\\n\",\n\t\t\t\tprog, kernelwritefilename, strerror(errno));\n\t\t\texit (1);\n\t\t}\n\n\t\treturn;\n\t};\n\n\tfprintf (stderr, \"%s: do_set \\\"%s\\\" not (yet) implemented.\\n\",\n\t\tprog, arg);\n}",
          "includes": [
            "#include <dev/pci/ncr.c>",
            "#include <kvm.h>",
            "#include <limits.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <nlist.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void  exit();",
            "char\t*prog;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ncr.c>\n#include <kvm.h>\n#include <limits.h>\n#include <paths.h>\n#include <errno.h>\n#include <stdio.h>\n#include <nlist.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/file.h>\n\nextern void  exit();\nchar\t*prog;\n\nvoid do_set (char * arg)\n{\n\tstruct usrcmd user;\n\tu_long addr;\n\tint i;\n\n\topen_kvm(O_RDWR);\n\taddr = ncr_base + offsetof (struct ncb, user);\n\n\tfor (i=3; i; i--) {\n\t\tif (!KVM_READ (\n\t\t\t(addr),\n\t\t\t&user,\n\t\t\tsizeof (user))) {\n\t\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\t\texit (1);\n\t\t}\n\t\tif (!user.cmd) break;\n\t\tsleep (1);\n\t}\n\tif (user.cmd) {\n\t\tfprintf (stderr, \"%s: ncb.user busy.\\n\", prog);\n\t\texit (1);\n\t};\n\n\tuser.target = target_mask;\n\tuser.lun    = lun_mask;\n\tuser.data   = 0;\n\tuser.cmd    = 0;\n\n\tif (!strcmp(arg, \"?\")) { printf (\n\"async:         disable synchronous transfers.\\n\"\n\"sync=value:    set the maximal synchronous transfer rate (MHz).\\n\"\n\"fast:          set FAST SCSI-2.\\n\"\n\"\\n\"\n\"wide=value:    set the bus width (0=8bit 1=16bit).\\n\"\n\"\\n\"\n\"tags=value:    use this number of tags.\\n\"\n\"orderedtag:    use ordered tags only.\\n\"\n\"simpletag:     use simple tags only.\\n\"\n\"orderedwrite:  use simple tags for read, else ordered tags.\\n\"\n\"\\n\"\n\"debug=value:   set debug mode.\\n\"\n\"\\n\");\n\t\treturn;\n\t};\n\f\n\tif (!strcmp(arg, \"async\")) {\n\t\tuser.data = 255;\n\t\tuser.cmd  = UC_SETSYNC;\n\t};\n\n\tif (!strcmp(arg, \"fast\")) {\n\t\tuser.data = 25;\n\t\tuser.cmd  = UC_SETSYNC;\n\t};\n\n\tif (!strncmp(arg, \"sync=\", 5)) {\n\t\tfloat f = strtod (arg+5, NULL);\n\t\tif (f>=4.0 && f<=10.0) {\n\t\t\tuser.data = 250.0 / f;\n\t\t\tuser.cmd  = UC_SETSYNC;\n\t\t};\n\t};\n\n\tif (!strncmp(arg, \"wide=\", 5)) {\n\t\tu_char t = strtoul (arg+5, (char**)0, 0);\n\t\tif (t<=1) {\n\t\t\tuser.data = t;\n\t\t\tuser.cmd  = UC_SETWIDE;\n\t\t};\n\t};\n\n\tif (!strncmp(arg, \"tags=\", 5)) {\n\t\tu_char t = strtoul (arg+5, (char**)0, 0);\n\t\tif (t<=SCSI_NCR_MAX_TAGS) {\n\t\t\tuser.data = t;\n\t\t\tuser.cmd  = UC_SETTAGS;\n\t\t};\n\t};\n\n\tif (!strncmp(arg, \"flags=\", 6)) {\n\t\tu_char t = strtoul (arg+6, (char**)0, 0);\n\t\tif (t<=0xff) {\n\t\t\tuser.data = t;\n\t\t\tuser.cmd  = UC_SETFLAG;\n\t\t};\n\t};\n\n\tif (!strncmp(arg, \"debug=\", 6)) {\n\t\tuser.data = strtoul (arg+6, (char**)0, 0);\n\t\tuser.cmd  = UC_SETDEBUG;\n\t};\n\n\tif (!strcmp(arg, \"orderedtag\")) {\n\t\tuser.data = M_ORDERED_TAG;\n\t\tuser.cmd  = UC_SETORDER;\n\t};\n\n\tif (!strcmp(arg, \"simpletag\")) {\n\t\tuser.data = M_SIMPLE_TAG;\n\t\tuser.cmd  = UC_SETORDER;\n\t};\n\f\n\tif (!strcmp(arg, \"orderedwrite\")) {\n\t\tuser.data = 0;\n\t\tuser.cmd  = UC_SETORDER;\n\t};\n\n\tif (user.cmd) {\n\t\topenkernelwritefile();\n\n\t\tif (lseek (kernelwritefile, addr, 0) != addr) {\n\t\t\tfprintf (stderr, \"%s: %s: %s\\n\",\n\t\t\t\tprog, kernelwritefilename, strerror(errno));\n\t\t\texit (1);\n\t\t}\n\t\tif (write (kernelwritefile, &user, sizeof (user)) < 0) {\n\t\t\tfprintf (stderr, \"%s: %s: %s\\n\",\n\t\t\t\tprog, kernelwritefilename, strerror(errno));\n\t\t\texit (1);\n\t\t}\n\n\t\treturn;\n\t};\n\n\tfprintf (stderr, \"%s: do_set \\\"%s\\\" not (yet) implemented.\\n\",\n\t\tprog, arg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_info",
          "args": [],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_profile",
          "args": [],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: bad interval \\\"%s\\\".\\n\"",
            "prog",
            "optarg"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "optarg",
            "&charp",
            "0"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: bad logic unit number \\\"%s\\\" (valid range: 0-%d).\\n\"",
            "prog",
            "optarg",
            "MAX_LUN"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "optarg",
            "&charp",
            "0"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sn",
          "args": [
            "i"
          ],
          "line": 1539
        },
        "resolved": true,
        "details": {
          "function_name": "sn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncrstat.c",
          "lines": "883-946",
          "snippet": "static const char * sn (u_long a)\n{\n\tstatic\tchar buffer[100];\n\n\tconst char * s=\"\";\n\tu_long d,m;\n\n\ta -= ncr.p_script;\n\tm = sizeof (struct script);\n\n\tif ((d=a-offsetof(struct script, start))<m) m=d, s=\"<start>\";\n\tif ((d=a-offsetof(struct script, start1))<m) m=d, s=\"<start1>\";\n\tif ((d=a-offsetof(struct script, startpos))<m) m=d, s=\"<startpos>\";\n\tif ((d=a-offsetof(struct script, tryloop))<m) m=d, s=\"<tryloop>\";\n\tif ((d=a-offsetof(struct script, trysel))<m) m=d, s=\"<trysel>\";\n\tif ((d=a-offsetof(struct script, skip))<m) m=d, s=\"<skip>\";\n\tif ((d=a-offsetof(struct script, skip2))<m) m=d, s=\"<skip2>\";\n\tif ((d=a-offsetof(struct script, idle))<m) m=d, s=\"<idle>\";\n\tif ((d=a-offsetof(struct script, select))<m) m=d, s=\"<select>\";\n\tif ((d=a-offsetof(struct script, prepare))<m) m=d, s=\"<prepare>\";\n\tif ((d=a-offsetof(struct script, loadpos))<m) m=d, s=\"<loadpos>\";\n\tif ((d=a-offsetof(struct script, prepare2))<m) m=d, s=\"<prepare2>\";\n\tif ((d=a-offsetof(struct script, setmsg))<m) m=d, s=\"<setmsg>\";\n\tif ((d=a-offsetof(struct script, clrack))<m) m=d, s=\"<clrack>\";\n\tif ((d=a-offsetof(struct script, dispatch))<m) m=d, s=\"<dispatch>\";\n\tif ((d=a-offsetof(struct script, checkatn))<m) m=d, s=\"<checkatn>\";\n\tif ((d=a-offsetof(struct script, command))<m) m=d, s=\"<command>\";\n\tif ((d=a-offsetof(struct script, status))<m) m=d, s=\"<status>\";\n\tif ((d=a-offsetof(struct script, msg_in))<m) m=d, s=\"<msg_in>\";\n\tif ((d=a-offsetof(struct script, msg_bad))<m) m=d, s=\"<msg_bad>\";\n\tif ((d=a-offsetof(struct script, msg_parity))<m) m=d, s=\"<msg_parity>\";\n\tif ((d=a-offsetof(struct script, msg_reject))<m) m=d, s=\"<msg_reject>\";\n\tif ((d=a-offsetof(struct script, msg_extended))<m) m=d, s=\"<msg_extended>\";\n\tif ((d=a-offsetof(struct script, msg_sdtr))<m) m=d, s=\"<msg_sdtr>\";\n\tif ((d=a-offsetof(struct script, complete))<m) m=d, s=\"<complete>\";\n\tif ((d=a-offsetof(struct script, cleanup))<m) m=d, s=\"<cleanup>\";\n\tif ((d=a-offsetof(struct script, cleanup0))<m) m=d, s=\"<cleanup>\";\n\tif ((d=a-offsetof(struct script, signal))<m) m=d, s=\"<signal>\";\n\tif ((d=a-offsetof(struct script, save_dp))<m) m=d, s=\"<save_dp>\";\n\tif ((d=a-offsetof(struct script, restore_dp))<m) m=d, s=\"<restore_dp>\";\n\tif ((d=a-offsetof(struct script, disconnect))<m) m=d, s=\"<disconnect>\";\n\tif ((d=a-offsetof(struct script, msg_out))<m) m=d, s=\"<msg_out>\";\n\tif ((d=a-offsetof(struct script, msg_out_done))<m) m=d, s=\"<msg_out_done>\";\n\tif ((d=a-offsetof(struct script, msg_out_abort))<m) m=d, s=\"<msg_out_abort>\";\n\tif ((d=a-offsetof(struct script, getcc))<m) m=d, s=\"<getcc>\";\n\tif ((d=a-offsetof(struct script, getcc1))<m) m=d, s=\"<getcc1>\";\n\tif ((d=a-offsetof(struct script, getcc2))<m) m=d, s=\"<getcc2>\";\n\tif ((d=a-offsetof(struct script, badgetcc))<m) m=d, s=\"<badgetcc>\";\n\tif ((d=a-offsetof(struct script, reselect))<m) m=d, s=\"<reselect>\";\n\tif ((d=a-offsetof(struct script, reselect2))<m) m=d, s=\"<reselect2>\";\n\tif ((d=a-offsetof(struct script, resel_tmp))<m) m=d, s=\"<resel_tmp>\";\n\tif ((d=a-offsetof(struct script, resel_lun))<m) m=d, s=\"<resel_lun>\";\n\tif ((d=a-offsetof(struct script, resel_tag))<m) m=d, s=\"<resel_tag>\";\n\tif ((d=a-offsetof(struct script, data_in))<m) m=d, s=\"<data_in>\";\n\tif ((d=a-offsetof(struct script, data_out))<m) m=d, s=\"<data_out>\";\n\tif ((d=a-offsetof(struct script, no_data))<m) m=d, s=\"<no_data>\";\n\tif ((d=a-offsetof(struct script, aborttag))<m) m=d, s=\"<aborttag>\";\n\tif ((d=a-offsetof(struct script, abort))<m) m=d, s=\"<abort>\";\n\n\tif (!*s) return s;\n\n\tsprintf (buffer, \"%s:%d%c\", s, m/4, 0);\n\treturn (buffer);\n}",
          "includes": [
            "#include <dev/pci/ncr.c>",
            "#include <kvm.h>",
            "#include <limits.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <nlist.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ncr.c>\n#include <kvm.h>\n#include <limits.h>\n#include <paths.h>\n#include <errno.h>\n#include <stdio.h>\n#include <nlist.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/file.h>\n\nstatic const char * sn (u_long a)\n{\n\tstatic\tchar buffer[100];\n\n\tconst char * s=\"\";\n\tu_long d,m;\n\n\ta -= ncr.p_script;\n\tm = sizeof (struct script);\n\n\tif ((d=a-offsetof(struct script, start))<m) m=d, s=\"<start>\";\n\tif ((d=a-offsetof(struct script, start1))<m) m=d, s=\"<start1>\";\n\tif ((d=a-offsetof(struct script, startpos))<m) m=d, s=\"<startpos>\";\n\tif ((d=a-offsetof(struct script, tryloop))<m) m=d, s=\"<tryloop>\";\n\tif ((d=a-offsetof(struct script, trysel))<m) m=d, s=\"<trysel>\";\n\tif ((d=a-offsetof(struct script, skip))<m) m=d, s=\"<skip>\";\n\tif ((d=a-offsetof(struct script, skip2))<m) m=d, s=\"<skip2>\";\n\tif ((d=a-offsetof(struct script, idle))<m) m=d, s=\"<idle>\";\n\tif ((d=a-offsetof(struct script, select))<m) m=d, s=\"<select>\";\n\tif ((d=a-offsetof(struct script, prepare))<m) m=d, s=\"<prepare>\";\n\tif ((d=a-offsetof(struct script, loadpos))<m) m=d, s=\"<loadpos>\";\n\tif ((d=a-offsetof(struct script, prepare2))<m) m=d, s=\"<prepare2>\";\n\tif ((d=a-offsetof(struct script, setmsg))<m) m=d, s=\"<setmsg>\";\n\tif ((d=a-offsetof(struct script, clrack))<m) m=d, s=\"<clrack>\";\n\tif ((d=a-offsetof(struct script, dispatch))<m) m=d, s=\"<dispatch>\";\n\tif ((d=a-offsetof(struct script, checkatn))<m) m=d, s=\"<checkatn>\";\n\tif ((d=a-offsetof(struct script, command))<m) m=d, s=\"<command>\";\n\tif ((d=a-offsetof(struct script, status))<m) m=d, s=\"<status>\";\n\tif ((d=a-offsetof(struct script, msg_in))<m) m=d, s=\"<msg_in>\";\n\tif ((d=a-offsetof(struct script, msg_bad))<m) m=d, s=\"<msg_bad>\";\n\tif ((d=a-offsetof(struct script, msg_parity))<m) m=d, s=\"<msg_parity>\";\n\tif ((d=a-offsetof(struct script, msg_reject))<m) m=d, s=\"<msg_reject>\";\n\tif ((d=a-offsetof(struct script, msg_extended))<m) m=d, s=\"<msg_extended>\";\n\tif ((d=a-offsetof(struct script, msg_sdtr))<m) m=d, s=\"<msg_sdtr>\";\n\tif ((d=a-offsetof(struct script, complete))<m) m=d, s=\"<complete>\";\n\tif ((d=a-offsetof(struct script, cleanup))<m) m=d, s=\"<cleanup>\";\n\tif ((d=a-offsetof(struct script, cleanup0))<m) m=d, s=\"<cleanup>\";\n\tif ((d=a-offsetof(struct script, signal))<m) m=d, s=\"<signal>\";\n\tif ((d=a-offsetof(struct script, save_dp))<m) m=d, s=\"<save_dp>\";\n\tif ((d=a-offsetof(struct script, restore_dp))<m) m=d, s=\"<restore_dp>\";\n\tif ((d=a-offsetof(struct script, disconnect))<m) m=d, s=\"<disconnect>\";\n\tif ((d=a-offsetof(struct script, msg_out))<m) m=d, s=\"<msg_out>\";\n\tif ((d=a-offsetof(struct script, msg_out_done))<m) m=d, s=\"<msg_out_done>\";\n\tif ((d=a-offsetof(struct script, msg_out_abort))<m) m=d, s=\"<msg_out_abort>\";\n\tif ((d=a-offsetof(struct script, getcc))<m) m=d, s=\"<getcc>\";\n\tif ((d=a-offsetof(struct script, getcc1))<m) m=d, s=\"<getcc1>\";\n\tif ((d=a-offsetof(struct script, getcc2))<m) m=d, s=\"<getcc2>\";\n\tif ((d=a-offsetof(struct script, badgetcc))<m) m=d, s=\"<badgetcc>\";\n\tif ((d=a-offsetof(struct script, reselect))<m) m=d, s=\"<reselect>\";\n\tif ((d=a-offsetof(struct script, reselect2))<m) m=d, s=\"<reselect2>\";\n\tif ((d=a-offsetof(struct script, resel_tmp))<m) m=d, s=\"<resel_tmp>\";\n\tif ((d=a-offsetof(struct script, resel_lun))<m) m=d, s=\"<resel_lun>\";\n\tif ((d=a-offsetof(struct script, resel_tag))<m) m=d, s=\"<resel_tag>\";\n\tif ((d=a-offsetof(struct script, data_in))<m) m=d, s=\"<data_in>\";\n\tif ((d=a-offsetof(struct script, data_out))<m) m=d, s=\"<data_out>\";\n\tif ((d=a-offsetof(struct script, no_data))<m) m=d, s=\"<no_data>\";\n\tif ((d=a-offsetof(struct script, aborttag))<m) m=d, s=\"<aborttag>\";\n\tif ((d=a-offsetof(struct script, abort))<m) m=d, s=\"<abort>\";\n\n\tif (!*s) return s;\n\n\tsprintf (buffer, \"%s:%d%c\", s, m/4, 0);\n\treturn (buffer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "optarg",
            "&charp",
            "0"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open_kvm",
          "args": [
            "O_RDONLY"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "open_kvm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncrstat.c",
          "lines": "174-295",
          "snippet": "void open_kvm(int flags)\n{\n\tint i;\n\tu_long\tkernel_version;\n#if defined(__NetBSD__) || defined(__OpenBSD__) || (__FreeBSD__ >= 2)\n\tchar \terrbuf[_POSIX2_LINE_MAX];\n#endif\n\n\tif (kvm_isopen) return;\n\n#if defined(__NetBSD__) || defined(__OpenBSD__) || (__FreeBSD__ >= 2)\n\tkvm = kvm_openfiles(vmunix, kmemf, NULL, flags, errbuf);\n\tif (kvm == NULL) {\n\t\tfprintf(stderr, \"%s: kvm_openfiles: %s\\n\", prog, errbuf);\n\t\texit(1);\n\t}\n#else\n\tif (kvm_openfiles(vmunix, kmemf, NULL) == -1) {\n\t\tfprintf(stderr, \"%s: kvm_openfiles: %s\\n\", prog, kvm_geterr());\n\t\texit(1);\n\t}\n#endif\n\n\tif (!KVM_NLIST(nl)) {\n\t\tfprintf(stderr, \"%s: no symbols in \\\"%s\\\".\\n\",\n\t\t\tprog, vmunix);\n\t\texit (2);\n\t};\n\n\tfor (i=0; nl[i].n_name; i++)\n\t\tif (nl[i].n_type == 0) {\n\t\t\tfprintf(stderr, \"%s: no symbol \\\"%s\\\" in \\\"%s\\\".\\n\",\n\t\t\t\tprog, nl[i].n_name, vmunix);\n\t\t\texit(1);\n\t\t}\n\n\tif (!KVM_READ (\n\t\tnl[N_NCR_VERSION].n_value,\n\t\t&kernel_version,\n\t\tsizeof (kernel_version))) {\n\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\texit (1);\n\t};\n\n\tif (kernel_version != ncr_version){\n\t\tfprintf (stderr, \"%s: incompatible with kernel. Rebuild!\\n\",\n\t\t\tprog);\n\t\texit (1);\n\t};\n\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\n\tif (!KVM_READ (\n\t\tnl[N_NCRCD].n_value,\n\t\t&ncr_cd,\n\t\tsizeof (ncr_cd))) {\n\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\texit (1);\n\t};\n\n\tif (ncr_unit >= ncr_cd.cd_ndevs){\n\t\tfprintf (stderr, \"%s: bad unit number (valid range: 0-%d).\\n\",\n\t\t\tprog, ncr_cd.cd_ndevs-1);\n\t\texit (1);\n\t};\n\n\tif (!KVM_READ (\n\t\tncr_cd.cd_devs+4*ncr_unit,\n\t\t&ncr_base,\n\t\tsizeof (ncr_base))) {\n\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\texit (1);\n\t};\n\n\tif (!ncr_base) {\n\t\tfprintf (stderr,\n\t\t\"%s: control structure not allocated (not found in autoconfig?)\\n\", prog);\n\t\texit (1);\n\t};\n\n#else /* !(__NetBSD__ || __OpenBSD__) */\n\n\tif (!KVM_READ (\n\t\tnl[N_NNCR].n_value,\n\t\t&ncr_units,\n\t\tsizeof (ncr_units))) {\n\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\texit (1);\n\t};\n\n\tif (ncr_unit >= ncr_units){\n\t\tfprintf (stderr, \"%s: bad unit number (valid range: 0-%d).\\n\",\n\t\t\tprog, ncr_units-1);\n\t\texit (1);\n\t};\n\f\n\tif (!KVM_READ (\n\t\tnl[N_NCRP].n_value+4*ncr_unit,\n\t\t&ncr_base,\n\t\tsizeof (ncr_base))) {\n\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\texit (1);\n\t};\n\n\tif (!ncr_base) {\n\t\tfprintf (stderr,\n\t\t\"%s: control structure not allocated (not found in autoconfig?)\\n\", prog);\n\t\texit (1);\n\t};\n\n#endif /* !(__NetBSD__ || __OpenBSD__) */\n\n\tread_ncr();\n\n\tif (!ncr.vaddr) {\n\t\tfprintf (stderr,\n\t\t\"%s: 53c810 not mapped (not found in autoconfig?)\\n\", prog);\n\t\texit (1);\n\t};\n\n\tkvm_isopen = 1;\n}",
          "includes": [
            "#include <dev/pci/ncr.c>",
            "#include <kvm.h>",
            "#include <limits.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <nlist.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>"
          ],
          "macros_used": [
            "#define\tN_NNCR\t2",
            "#define\tN_NCRP\t1",
            "#define\tN_NCRCD\t1",
            "#define\tN_NCR_VERSION\t0"
          ],
          "globals_used": [
            "extern void  exit();",
            "char\t*prog;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ncr.c>\n#include <kvm.h>\n#include <limits.h>\n#include <paths.h>\n#include <errno.h>\n#include <stdio.h>\n#include <nlist.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/file.h>\n\n#define\tN_NNCR\t2\n#define\tN_NCRP\t1\n#define\tN_NCRCD\t1\n#define\tN_NCR_VERSION\t0\n\nextern void  exit();\nchar\t*prog;\n\nvoid open_kvm(int flags)\n{\n\tint i;\n\tu_long\tkernel_version;\n#if defined(__NetBSD__) || defined(__OpenBSD__) || (__FreeBSD__ >= 2)\n\tchar \terrbuf[_POSIX2_LINE_MAX];\n#endif\n\n\tif (kvm_isopen) return;\n\n#if defined(__NetBSD__) || defined(__OpenBSD__) || (__FreeBSD__ >= 2)\n\tkvm = kvm_openfiles(vmunix, kmemf, NULL, flags, errbuf);\n\tif (kvm == NULL) {\n\t\tfprintf(stderr, \"%s: kvm_openfiles: %s\\n\", prog, errbuf);\n\t\texit(1);\n\t}\n#else\n\tif (kvm_openfiles(vmunix, kmemf, NULL) == -1) {\n\t\tfprintf(stderr, \"%s: kvm_openfiles: %s\\n\", prog, kvm_geterr());\n\t\texit(1);\n\t}\n#endif\n\n\tif (!KVM_NLIST(nl)) {\n\t\tfprintf(stderr, \"%s: no symbols in \\\"%s\\\".\\n\",\n\t\t\tprog, vmunix);\n\t\texit (2);\n\t};\n\n\tfor (i=0; nl[i].n_name; i++)\n\t\tif (nl[i].n_type == 0) {\n\t\t\tfprintf(stderr, \"%s: no symbol \\\"%s\\\" in \\\"%s\\\".\\n\",\n\t\t\t\tprog, nl[i].n_name, vmunix);\n\t\t\texit(1);\n\t\t}\n\n\tif (!KVM_READ (\n\t\tnl[N_NCR_VERSION].n_value,\n\t\t&kernel_version,\n\t\tsizeof (kernel_version))) {\n\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\texit (1);\n\t};\n\n\tif (kernel_version != ncr_version){\n\t\tfprintf (stderr, \"%s: incompatible with kernel. Rebuild!\\n\",\n\t\t\tprog);\n\t\texit (1);\n\t};\n\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\n\tif (!KVM_READ (\n\t\tnl[N_NCRCD].n_value,\n\t\t&ncr_cd,\n\t\tsizeof (ncr_cd))) {\n\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\texit (1);\n\t};\n\n\tif (ncr_unit >= ncr_cd.cd_ndevs){\n\t\tfprintf (stderr, \"%s: bad unit number (valid range: 0-%d).\\n\",\n\t\t\tprog, ncr_cd.cd_ndevs-1);\n\t\texit (1);\n\t};\n\n\tif (!KVM_READ (\n\t\tncr_cd.cd_devs+4*ncr_unit,\n\t\t&ncr_base,\n\t\tsizeof (ncr_base))) {\n\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\texit (1);\n\t};\n\n\tif (!ncr_base) {\n\t\tfprintf (stderr,\n\t\t\"%s: control structure not allocated (not found in autoconfig?)\\n\", prog);\n\t\texit (1);\n\t};\n\n#else /* !(__NetBSD__ || __OpenBSD__) */\n\n\tif (!KVM_READ (\n\t\tnl[N_NNCR].n_value,\n\t\t&ncr_units,\n\t\tsizeof (ncr_units))) {\n\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\texit (1);\n\t};\n\n\tif (ncr_unit >= ncr_units){\n\t\tfprintf (stderr, \"%s: bad unit number (valid range: 0-%d).\\n\",\n\t\t\tprog, ncr_units-1);\n\t\texit (1);\n\t};\n\f\n\tif (!KVM_READ (\n\t\tnl[N_NCRP].n_value+4*ncr_unit,\n\t\t&ncr_base,\n\t\tsizeof (ncr_base))) {\n\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\texit (1);\n\t};\n\n\tif (!ncr_base) {\n\t\tfprintf (stderr,\n\t\t\"%s: control structure not allocated (not found in autoconfig?)\\n\", prog);\n\t\texit (1);\n\t};\n\n#endif /* !(__NetBSD__ || __OpenBSD__) */\n\n\tread_ncr();\n\n\tif (!ncr.vaddr) {\n\t\tfprintf (stderr,\n\t\t\"%s: 53c810 not mapped (not found in autoconfig?)\\n\", prog);\n\t\texit (1);\n\t};\n\n\tkvm_isopen = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: bad target number \\\"%s\\\" (valid range: 0-%d).\\n\"",
            "prog",
            "optarg",
            "MAX_TARGET-1"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "optarg",
            "&charp",
            "0"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: bad unit number \\\"%s\\\".\\n\"",
            "prog",
            "optarg"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "optarg",
            "&charp",
            "0"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: -f: option not yet implemented.\\n\"",
            "prog"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: -N: symbol table already open.\\n\"",
            "prog"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: -M: kernel file already open.\\n\"",
            "prog"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getopt",
          "args": [
            "argc",
            "argv",
            "\"M:N:u:f:t:l:p:s:k:d:vwhin:?\""
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/ncr.c>\n#include <kvm.h>\n#include <limits.h>\n#include <paths.h>\n#include <errno.h>\n#include <stdio.h>\n#include <nlist.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/file.h>\n\nextern void  exit();\nchar\t*prog;\nu_long\tverbose;\nu_long  wizard;\n\nvoid main(argc, argv)\n\tint argc;\n\tchar **argv;\n{\n\textern char *optarg;\n\textern int optind;\n\tint\tusage=0;\n\tchar * charp;\n\tint ch, getopt(),atoi();\n\tint i,step;\n\n\tprog = *argv;\n\twhile ((ch = getopt(argc, argv, \"M:N:u:f:t:l:p:s:k:d:vwhin:?\")) != -1)\n\tswitch((char)ch) {\n\tcase 'M':\n\t\tif (kvm_isopen) {\n\t\t\tfprintf (stderr,\n\t\t\t\t\"%s: -M: kernel file already open.\\n\",\n\t\t\t\tprog);\n\t\t\texit (1);\n\t\t};\n\t\tkmemf = optarg;\n\t\tbreak;\n\tcase 'N':\n\t\tif (kvm_isopen) {\n\t\t\tfprintf (stderr,\n\t\t\t\t\"%s: -N: symbol table already open.\\n\",\n\t\t\t\tprog);\n\t\t\texit (1);\n\t\t};\n\t\tvmunix = optarg;\n\t\tbreak;\n\tcase 'f':\n\t\tfprintf (stderr,\n\t\t\t\"%s: -f: option not yet implemented.\\n\",\n\t\t\tprog);\n\t\texit (1);\n\f\n        case 'u':\n\t\ti = strtoul (optarg, &charp, 0);\n\t\tif (!*optarg || *charp || (i<0)) {\n\t\t\tfprintf (stderr,\n\t\t\t\t\"%s: bad unit number \\\"%s\\\".\\n\",\n\t\t\t\tprog, optarg);\n\t\t\texit (1);\n\t\t}\n\t\tncr_unit = i;\n\t\tbreak;\n\tcase 't':\n\t\ti = strtoul (optarg, &charp, 0);\n\t\tif (!*optarg || *charp || (i<0) || (i>=MAX_TARGET)) {\n\t\t\tfprintf (stderr,\n\t\t\t\t\"%s: bad target number \\\"%s\\\" (valid range: 0-%d).\\n\",\n\t\t\t\tprog, optarg, MAX_TARGET-1);\n\t\t\texit (1);\n\t\t}\n\t\ttarget_mask |= 1ul << i;\n\t\tbreak;\n\tcase 'n':\n\t\topen_kvm(O_RDONLY);\n\t\ti = strtoul (optarg, &charp, 0);\n\t\tprintf (\"addr %d (0x%x) has label %s.\\n\",\n\t\t\ti,i,sn(i));\n\t\tbreak;\n\tcase 'l':\n\t\ti = strtoul (optarg, &charp, 0);\n\t\tif (!*optarg || *charp || (i<0) || (i>=MAX_LUN)) {\n\t\t\tfprintf (stderr,\n\t\t\t\t\"%s: bad logic unit number \\\"%s\\\" (valid range: 0-%d).\\n\",\n\t\t\t\tprog, optarg, MAX_LUN);\n\t\t\texit (1);\n\t\t}\n\t\tglobal_lun_mask |= 1ul << i;\n\t\tbreak;\n\tcase 'p':\n\t\ti = strtoul (optarg, &charp, 0);\n\t\tif (!*optarg || *charp || (i<1) || (i>60)) {\n\t\t\tfprintf (stderr,\n\t\t\t\t\"%s: bad interval \\\"%s\\\".\\n\",\n\t\t\t\tprog, optarg);\n\t\t\texit (1);\n\t\t}\n\t\tinterval = i;\n\t\tdo_profile();\n\t\tbreak;\n\n        case 'w':\n\t\twizard=1;\n\t\tbreak;\n\tcase 'v':\n\t\tverbose++;\n\t\tbreak;\n\tcase 'i':\n\t\tdo_info();\n\t\tbreak;\n\f\n\tcase 's':\n\t\tdo_set(optarg);\n\t\tbreak;\n\tcase 'd':\n\t\tdo_debug(optarg);\n\t\tbreak;\n\tcase 'k':\n\t\tdo_kill(optarg);\n\t\tbreak;\n\tcase 'h':\n\tcase '?':\n\t\tusage++;\n\t\tbreak;\n\tdefault:(void)fprintf(stderr,\n\t\t\"%s: illegal option \\\"%c\\\".\\n\", prog, ch);\n\t\tusage++;\n\t}\n\n\targv += optind;\n\targc -= optind;\n\n\tif (argc) printf (\"%s: rest of line starting with \\\"%s\\\" ignored.\\n\",\n\t\tprog, *argv);\n\n\tif (verbose&&!kvm_isopen) usage++;\n\tif (usage) {\n\t\tfprintf (stderr,\n\t\"Usage:\\n\"\n\t\"\\n\"\n\t\"%s [-M$] [-N$] {-f$} {-t#} {-l#} [-hivw?] [-d$] [-s$] [-k] [[-p] <time>]\\n\"\n\t\"\\n\"\n\t\"-t <#>             select target number\\n\"\n\t\"-l <#>             select lun number\\n\"\n\t\"-i                 get info\\n\"\n\t\"-v                 verbose\\n\"\n\t\"-p <seconds>       performance data\\n\"\n\t\"\\n\"\n\t\"Wizards only (proceed on your own risk):\\n\"\n\t\"-n <#>             get the name for address #\\n\"\n\t\"-w                 wizard mode\\n\"\n\t\"-d <options>       debug info\\n\"\n\t\"-d?                list debug options\\n\"\n\t\"-s <param=value>   set parameter\\n\"\n\t\"-s?                list parameters\\n\"\n\t\"-k <torture>       torture driver by simulating errors\\n\"\n\t\"-k?                list tortures\\n\"\n\t\"-M <kernelimage>   (default: %s)\\n\"\n\t\"-N <symboltable>   (default: %s)\\n\"\n\t, prog, _PATH_KMEM, _PATH_UNIX);\n\t\tif (verbose) fprintf (stderr, ident);\n\t\texit (1);\n\t}\n\n\tif (!kvm_isopen) {\n\t\tdo_info();\n\t\tdo_profile();\n\t};\n\texit (0);\n}"
  },
  {
    "function_name": "dump_ncr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncrstat.c",
    "lines": "1305-1418",
    "snippet": "static void dump_ncr (void)\n{\n\tu_long tp;\n\tint i;\n\n\tprintf (\"----------------------\\n\");\n\tprintf (\"struct ncb @ %x:\\n\", ncr_base);\n\tprintf (\"----------------------\\n\");\n\n\tdump_link (\"    jump_tcb\", &ncr.jump_tcb);\n\tprintf    (\"    register: @ %x (p=%x)\\n\", ncr.vaddr, ncr.paddr);\n\n\tif (strchr (debug_opt, 'r')) {\n\t\tstruct ncr_reg reg;\n\n\t\tif (!KVM_READ (\n\t\t\tncr.vaddr,\n\t\t\t&reg,\n\t\t\tsizeof (reg))) {\n\t\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\t\texit (1);\n\t\t};\n\t\t\n\t\tprintf (\"\\n\");\n\t\tdump_reg (&reg);\n\t};\n\n\tprintf    (\"      script: @ %x (p=%x)\\n\", ncr.script, ncr.p_script);\n\n\tprintf (\"hostscsiaddr: %d\\n\", ncr.myaddr);\n\tprintf (\"    ns_async: %d ns\\n\", ncr.ns_async);\n\tprintf (\"    ns_sync : %d ns\\n\", ncr.ns_sync);\n\tprintf (\"      scntl3: 0x%02x\\n\", ncr.rv_scntl3);\n\tprintf (\"\\n\");\n\n\t/* sc_link not dumped */\n\n\tif (strchr (debug_opt, 'u')) {\n\t\tprintf (\"     usercmd: cmd=%x data=%x target=%x lun=%x\\n\",\n\t\t\tncr.user.cmd,\n\t\t\tncr.user.data,\n\t\t\tncr.user.target,\n\t\t\tncr.user.lun);\n\t};\n\f\n\tprintf (\"     actccbs: %d\\n\", ncr.actccbs);\n\n\tif (strchr (debug_opt, 'q')) {\n\n\t\tu_long\tstartpos;\n\n\t\tif (!KVM_READ (\n\t\t\t((u_long)ncr.script\n\t\t\t\t+offsetof(struct script, startpos)),\n\t\t\t&startpos,\n\t\t\tsizeof (startpos))) {\n\t\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\t\texit (1);\n\t\t};\n\t\t\n\t\tprintf (\"    startpos: %x\\n\", startpos);\n\t\tprintf (\"        slot: %d\\n\", (startpos-\n\t\t\t(ncr.p_script+offsetof(struct script, tryloop)))/20);\n\t\tprintf (\"    squeuput: %d\\n\", ncr.squeueput);\n\t\tfor (i=0; i<MAX_START; i++)\n\t\t\tprintf (\"%12d: %08x %s\\n\", i,\n\t\t\tncr.squeue[i], sn(ncr.squeue[i]));\n\n\t\tprintf (\"\\n\");\n\t};\n\n\tprintf (\"       ticks: %d ms\\n\", ncr.ticks * 10);\n\tprintf (\"   heartbeat: %s\", ctime ((time_t*)&ncr.heartbeat));\n\tprintf (\"    lasttime: %s\", ctime ((time_t*)&ncr.lasttime));\n#if !defined(__NetBSD__) && !defined(__OpenBSD__)\n\tprintf (\"imask/mcount: %x / %d\\n\", ncr.imask, ncr.mcount);\n#endif\n\tprintf (\"\\n\");\n\n\tif (strchr (debug_opt, 'd') && ncr.regtime.tv_sec) {\n\t\tprintf (\"     regdump: %s\", ctime (&ncr.regtime.tv_sec));\n\t\tdump_reg (&ncr.regdump);\n\t};\n\n\tif (strchr (debug_opt, 'p')) {\n\t\tprintf (\"\\n\");\n\t\tdump_profile (\"     profile\", &ncr.profile);\n\t};\n\n\tif (strchr (debug_opt, 'h')) {\n\t\tprintf (\"\\n\");\n\t\tdump_head ( &ncr.header);\n\t};\n\n\tif (strchr (debug_opt, 'c')) {\n\t\tdump_ccb  (&ncr.ccb, ncr_base + offsetof (struct ncb, ccb));\n\t};\n\f\n\tif (strchr (debug_opt, 'm')) {\n\t\tprintf (\"      msgout:\"); printm (ncr.msgout,0); printf (\"\\n\");\n\t\tprintf (\"      msg in:\"); printm (ncr.msgin,0);  printf (\"\\n\");\n\t\tprintf (\"\\n\");\n\t};\n\n\tif (strchr (debug_opt, 't')) {\n\t\tstruct tcb * tip;\n\t\tfor (i=0;i<MAX_TARGET;i++) {\n\t\t\ttip = &ncr.target[i];\n\t\t\tif (!tip->jump_tcb.l_cmd) continue;\n\t\t\tprintf (\"target #%d:\\n\", i);\n\t\t\tdump_tip (tip);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <dev/pci/ncr.c>",
      "#include <kvm.h>",
      "#include <limits.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <nlist.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern void  exit();",
      "char\t*prog;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_tip",
          "args": [
            "tip"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "dump_tip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncrstat.c",
          "lines": "1261-1293",
          "snippet": "static void dump_tip (struct tcb * tip)\n{\n\tint i;\n\tu_long lp;\n\n\tprintf (\"----------------------\\n\");\n\tprintf (\"struct tcb:\\n\");\n\tprintf (\"----------------------\\n\");\n\n\tprintf (\"   transfers:%10d.\\n\", tip->transfers);\n\tprintf (\"       bytes:%10d.\\n\", tip->bytes    );\n\tprintf (\" user limits: usrsync=%d  usrwide=%d  usrtags=%d.\\n\",\n\t\t\ttip->usrsync, tip->usrwide, tip->usrtags);\n\tprintf (\"        sync: minsync=%d, maxoffs=%d, period=%d ns, sval=%x.\\n\",\n\t\t\ttip->minsync, tip->maxoffs, tip->period, tip->sval);\n\tprintf (\"\twide: widedone=%d, wval=%x.\\n\",\n\t\t\ttip->widedone, tip->wval);\n\n\tprintf   (\"     hold_cp: %x\\n\", tip->hold_cp);\n\tdump_link (\"    jump_tcb\", &tip->jump_tcb);\n\tdump_link (\"    call_lun\", &tip->call_lun);\n\tdump_link (\"    jump_lcb\", &tip->jump_lcb);\n\tif (tip->hold_cp) printf (\"     hold_cp: @ %x\\n\", tip->hold_cp);\n\tprintf (\"\\n\");\n\n\tif (strchr (debug_opt, 'l')) {\n\t\tfor (i=0;i<MAX_LUN;i++) {\n\t\t\tlp= (u_long) tip->lp[i];\n\t\t\tprintf (\"logic unit #%d:\\n\", i);\n\t\t\tif (lp) dump_lcb (lp);\n\t\t};\n\t}\n}",
          "includes": [
            "#include <dev/pci/ncr.c>",
            "#include <kvm.h>",
            "#include <limits.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <nlist.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ncr.c>\n#include <kvm.h>\n#include <limits.h>\n#include <paths.h>\n#include <errno.h>\n#include <stdio.h>\n#include <nlist.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/file.h>\n\nstatic void dump_tip (struct tcb * tip)\n{\n\tint i;\n\tu_long lp;\n\n\tprintf (\"----------------------\\n\");\n\tprintf (\"struct tcb:\\n\");\n\tprintf (\"----------------------\\n\");\n\n\tprintf (\"   transfers:%10d.\\n\", tip->transfers);\n\tprintf (\"       bytes:%10d.\\n\", tip->bytes    );\n\tprintf (\" user limits: usrsync=%d  usrwide=%d  usrtags=%d.\\n\",\n\t\t\ttip->usrsync, tip->usrwide, tip->usrtags);\n\tprintf (\"        sync: minsync=%d, maxoffs=%d, period=%d ns, sval=%x.\\n\",\n\t\t\ttip->minsync, tip->maxoffs, tip->period, tip->sval);\n\tprintf (\"\twide: widedone=%d, wval=%x.\\n\",\n\t\t\ttip->widedone, tip->wval);\n\n\tprintf   (\"     hold_cp: %x\\n\", tip->hold_cp);\n\tdump_link (\"    jump_tcb\", &tip->jump_tcb);\n\tdump_link (\"    call_lun\", &tip->call_lun);\n\tdump_link (\"    jump_lcb\", &tip->jump_lcb);\n\tif (tip->hold_cp) printf (\"     hold_cp: @ %x\\n\", tip->hold_cp);\n\tprintf (\"\\n\");\n\n\tif (strchr (debug_opt, 'l')) {\n\t\tfor (i=0;i<MAX_LUN;i++) {\n\t\t\tlp= (u_long) tip->lp[i];\n\t\t\tprintf (\"logic unit #%d:\\n\", i);\n\t\t\tif (lp) dump_lcb (lp);\n\t\t};\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"target #%d:\\n\"",
            "i"
          ],
          "line": 1414
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "debug_opt",
            "'t'"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printm",
          "args": [
            "ncr.msgin",
            "0"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "printm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncrstat.c",
          "lines": "957-971",
          "snippet": "static void printm (u_char * msg, int len)\n{\n\tu_char l;\n\tdo {\n\t\tif (*msg==M_EXTENDED)\n\t\t\tl=msg[1]+2;\n\t\telse if ((*msg & 0xf0)==0x20)\n\t\t\tl=2;\n\t\telse l=1;\n\t\tlen-=l;\n\n\t\tprintf (\" %x\",*msg++);\n\t\twhile (--l>0) printf (\"-%x\",*msg++);\n\t} while (len>0);\n}",
          "includes": [
            "#include <dev/pci/ncr.c>",
            "#include <kvm.h>",
            "#include <limits.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <nlist.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ncr.c>\n#include <kvm.h>\n#include <limits.h>\n#include <paths.h>\n#include <errno.h>\n#include <stdio.h>\n#include <nlist.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/file.h>\n\nstatic void printm (u_char * msg, int len)\n{\n\tu_char l;\n\tdo {\n\t\tif (*msg==M_EXTENDED)\n\t\t\tl=msg[1]+2;\n\t\telse if ((*msg & 0xf0)==0x20)\n\t\t\tl=2;\n\t\telse l=1;\n\t\tlen-=l;\n\n\t\tprintf (\" %x\",*msg++);\n\t\twhile (--l>0) printf (\"-%x\",*msg++);\n\t} while (len>0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "debug_opt",
            "'m'"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_ccb",
          "args": [
            "&ncr.ccb",
            "ncr_base + offsetof (struct ncb, ccb)"
          ],
          "line": 1400
        },
        "resolved": true,
        "details": {
          "function_name": "dump_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncrstat.c",
          "lines": "1153-1198",
          "snippet": "void dump_ccb (struct ccb * cp, u_long base)\n{\n\tprintf (\"----------------------\\n\");\n\tprintf (\"struct ccb @ %08x:\\n\", base);\n\tprintf (\"----------------------\\n\");\n\n\tdump_link (\"        next\", &cp->jump_ccb);\n\tdump_link (\"        call\", &cp->call_tmp);\n\n\tdump_head (&cp->phys.header);\n\n\tif (strchr (debug_opt, 's')) {\n\t\tdump_table(\" smsg\", &cp->phys.smsg,   1);\n\t\tdump_table(\"smsg2\", &cp->phys.smsg2,  1);\n\t\tdump_table(\"  cmd\", &cp->phys.cmd,    1);\n\t\tdump_table(\" data\", &cp->phys.data[0],MAX_SCATTER);\n\t\tdump_table(\"sense\", &cp->phys.sense,  1);\n\t};\n\n\tif (strchr (debug_opt, 'a')) {\n\t\tint i;\n\t\tfor (i=0; i<8; i++)\n\t\t\tprintf (\"    patch[%d]: %08x\\n\", i, cp->patch[i]);\n\t};\n\n\tif (strchr (debug_opt, 'x')) {\n\t\tprintf (\"        xfer: -- dump not yet implemented.\\n\");\n\t};\n\n\tif (strchr (debug_opt, 'm')) {\n\t\tprintf (\"        smsg:\");\n\t\tprintm (cp->scsi_smsg, cp->phys.smsg.size);\n\t\tprintf (\"\\n\");\n\t\tprintf (\"       smsg2:\");\n\t\tprintm (cp->scsi_smsg2, cp->phys.smsg2.size);\n\t\tprintf (\"\\n\");\n\t};\n\n\tprintf (\"       magic: %x\\n\", cp->magic);\n\tif (cp->tlimit)\n\tprintf (\"  timeout at: %s\", ctime((time_t*)&cp->tlimit));\n\tprintf (\"    link_ccb: %08x\\n\", (u_long) cp->link_ccb);\n\tprintf (\"    next_ccb: %08x\\n\", (u_long) cp->next_ccb);\n\tprintf (\"         tag: %d\\n\", cp->tag);\n\tprintf (\"\\n\");\n}",
          "includes": [
            "#include <dev/pci/ncr.c>",
            "#include <kvm.h>",
            "#include <limits.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <nlist.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ncr.c>\n#include <kvm.h>\n#include <limits.h>\n#include <paths.h>\n#include <errno.h>\n#include <stdio.h>\n#include <nlist.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/file.h>\n\nvoid dump_ccb (struct ccb * cp, u_long base)\n{\n\tprintf (\"----------------------\\n\");\n\tprintf (\"struct ccb @ %08x:\\n\", base);\n\tprintf (\"----------------------\\n\");\n\n\tdump_link (\"        next\", &cp->jump_ccb);\n\tdump_link (\"        call\", &cp->call_tmp);\n\n\tdump_head (&cp->phys.header);\n\n\tif (strchr (debug_opt, 's')) {\n\t\tdump_table(\" smsg\", &cp->phys.smsg,   1);\n\t\tdump_table(\"smsg2\", &cp->phys.smsg2,  1);\n\t\tdump_table(\"  cmd\", &cp->phys.cmd,    1);\n\t\tdump_table(\" data\", &cp->phys.data[0],MAX_SCATTER);\n\t\tdump_table(\"sense\", &cp->phys.sense,  1);\n\t};\n\n\tif (strchr (debug_opt, 'a')) {\n\t\tint i;\n\t\tfor (i=0; i<8; i++)\n\t\t\tprintf (\"    patch[%d]: %08x\\n\", i, cp->patch[i]);\n\t};\n\n\tif (strchr (debug_opt, 'x')) {\n\t\tprintf (\"        xfer: -- dump not yet implemented.\\n\");\n\t};\n\n\tif (strchr (debug_opt, 'm')) {\n\t\tprintf (\"        smsg:\");\n\t\tprintm (cp->scsi_smsg, cp->phys.smsg.size);\n\t\tprintf (\"\\n\");\n\t\tprintf (\"       smsg2:\");\n\t\tprintm (cp->scsi_smsg2, cp->phys.smsg2.size);\n\t\tprintf (\"\\n\");\n\t};\n\n\tprintf (\"       magic: %x\\n\", cp->magic);\n\tif (cp->tlimit)\n\tprintf (\"  timeout at: %s\", ctime((time_t*)&cp->tlimit));\n\tprintf (\"    link_ccb: %08x\\n\", (u_long) cp->link_ccb);\n\tprintf (\"    next_ccb: %08x\\n\", (u_long) cp->next_ccb);\n\tprintf (\"         tag: %d\\n\", cp->tag);\n\tprintf (\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "debug_opt",
            "'c'"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_head",
          "args": [
            "&ncr.header"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "debug_opt",
            "'h'"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_profile",
          "args": [
            "\"     profile\"",
            "&ncr.profile"
          ],
          "line": 1391
        },
        "resolved": true,
        "details": {
          "function_name": "dump_profile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncrstat.c",
          "lines": "1017-1030",
          "snippet": "void dump_profile (const char* name, struct profile * p)\n{\n\tprintf (\"%s: %10d transfers.\\n\"        ,name,p->num_trans);\n\tprintf (\"%s: %10d bytes transferred.\\n\",name,p->num_bytes);\n\tprintf (\"%s: %10d disconnects.\\n\"      ,name,p->num_disc);\n\tprintf (\"%s: %10d short transfers.\\n\"  ,name,p->num_break);\n\tprintf (\"%s: %10d interrupts.\\n\"       ,name,p->num_int);\n\tprintf (\"%s: %10d on the fly ints.\\n\"  ,name,p->num_fly);\n\tprintf (\"%s: %10d ms setup time.\\n\"    ,name,p->ms_setup);\n\tprintf (\"%s: %10d ms data transfer.\\n\" ,name,p->ms_data);\n\tprintf (\"%s: %10d ms disconnected.\\n\"  ,name,p->ms_disc);\n\tprintf (\"%s: %10d ms postprocessing.\\n\",name,p->ms_post);\n\tprintf (\"\\n\");\n}",
          "includes": [
            "#include <dev/pci/ncr.c>",
            "#include <kvm.h>",
            "#include <limits.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <nlist.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ncr.c>\n#include <kvm.h>\n#include <limits.h>\n#include <paths.h>\n#include <errno.h>\n#include <stdio.h>\n#include <nlist.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/file.h>\n\nvoid dump_profile (const char* name, struct profile * p)\n{\n\tprintf (\"%s: %10d transfers.\\n\"        ,name,p->num_trans);\n\tprintf (\"%s: %10d bytes transferred.\\n\",name,p->num_bytes);\n\tprintf (\"%s: %10d disconnects.\\n\"      ,name,p->num_disc);\n\tprintf (\"%s: %10d short transfers.\\n\"  ,name,p->num_break);\n\tprintf (\"%s: %10d interrupts.\\n\"       ,name,p->num_int);\n\tprintf (\"%s: %10d on the fly ints.\\n\"  ,name,p->num_fly);\n\tprintf (\"%s: %10d ms setup time.\\n\"    ,name,p->ms_setup);\n\tprintf (\"%s: %10d ms data transfer.\\n\" ,name,p->ms_data);\n\tprintf (\"%s: %10d ms disconnected.\\n\"  ,name,p->ms_disc);\n\tprintf (\"%s: %10d ms postprocessing.\\n\",name,p->ms_post);\n\tprintf (\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "debug_opt",
            "'p'"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_reg",
          "args": [
            "&ncr.regdump"
          ],
          "line": 1386
        },
        "resolved": true,
        "details": {
          "function_name": "dump_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncrstat.c",
          "lines": "1041-1112",
          "snippet": "static void dump_reg(struct ncr_reg * rp)\n{\n\tu_char *reg = (u_char*) rp;\n#define l(i)  (reg[i]+(reg[i+1]<<8ul)+(reg[i+2]<<16ul)+(reg[i+3]<<24ul))\n\tint ad;\n\n\tchar*(phasename[8])={\"DATA-OUT\",\"DATA-IN\",\"COMMAND\",\"STATUS\",\n\t\t\t\t\"ILG-OUT\",\"ILG-IN\",\"MESSAGE-OUT\",\"MESSAGE-IN\"};\n\tfor (ad=0x00;ad<0x80;ad++) {\n\t\tswitch (ad % 16) {\n\n\t\tcase 0:\n\t\t\tprintf (\"        %02x:\\t\",ad);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tprintf (\" :  \");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf (\" \");\n\t\t};\n\t\tprintf (\"%02x\", reg[ad]);\n\t\tif (ad % 16 == 15) printf (\"\\n\");\n\t};\n\tprintf (\"\\n\");\n\tprintf (\"        DSP  %08x %-20s  CMD %08x DSPS %08x %s\\n\",\n\t\tl(0x2c),sn(l(0x2c)),l(0x24),l(0x30), sn(l(0x30)));\n\tprintf (\"        TEMP %08x %-20s  DSA %08x\\n\",\n\t\tl(0x1c),sn(l(0x1c)),l(0x10)); \n\tprintf (\"\\n\");\n\tprintf (\"        Busstatus: \");\n\tif ((reg[0x0b]>>7)&1) printf (\" Req\");\n\tif ((reg[0x0b]>>6)&1) printf (\" Ack\");\n\tif ((reg[0x0b]>>5)&1) printf (\" Bsy\");\n\tif ((reg[0x0b]>>4)&1) printf (\" Sel\");\n\tif ((reg[0x0b]>>3)&1) printf (\" Atn\");\n\tprintf (\" %s\\n\", phasename[reg[0x0b]&7]);\n\f\n        printf (\"        Dmastatus: \");\n\tif ((reg[0x0c]>>7)&1) printf (\" FifoEmpty\");\n\tif ((reg[0x0c]>>6)&1) printf (\" MasterParityError\");\n\tif ((reg[0x0c]>>5)&1) printf (\" BusFault\");\n\tif ((reg[0x0c]>>4)&1) printf (\" Aborted\");\n\tif ((reg[0x0c]>>3)&1) printf (\" SingleStep\");\n\tif ((reg[0x0c]>>2)&1) printf (\" Interrupt\");\n\tif ((reg[0x0c]>>0)&1) printf (\" IllegalInstruction\");\n\tprintf (\"\\n\");\n\tprintf (\"        Intstatus: \");\n\tif ((reg[0x14]>>7)&1) printf (\" Abort\");\n\tif ((reg[0x14]>>6)&1) printf (\" SoftwareReset\");\n\tif ((reg[0x14]>>5)&1) printf (\" SignalProcess\");\n\tif ((reg[0x14]>>4)&1) printf (\" Semaphore\");\n\tif ((reg[0x14]>>3)&1) printf (\" Connected\");\n\tif ((reg[0x14]>>2)&1) printf (\" IntOnTheFly\");\n\tif ((reg[0x14]>>1)&1) printf (\" SCSI-Interrupt\");\n\tif ((reg[0x14]>>0)&1) printf (\" DMA-Interrupt\");\n\tprintf (\"\\n\");\n\tprintf (\"        ScsiIstat: \");\n\tif ((reg[0x42]>>7)&1) printf (\" PhaseMismatch\");\n\tif ((reg[0x42]>>6)&1) printf (\" Complete\");\n\tif ((reg[0x42]>>5)&1) printf (\" Selected\");\n\tif ((reg[0x42]>>4)&1) printf (\" Reselected\");\n\tif ((reg[0x42]>>3)&1) printf (\" GrossError\");\n\tif ((reg[0x42]>>2)&1) printf (\" UnexpectedDisconnect\");\n\tif ((reg[0x42]>>1)&1) printf (\" ScsiReset\");\n\tif ((reg[0x42]>>0)&1) printf (\" ParityError\");\n\tif ((reg[0x43]>>2)&1) printf (\" SelectionTimeout\");\n\tif ((reg[0x43]>>1)&1) printf (\" TimerExpired\");\n\tif ((reg[0x43]>>0)&1) printf (\" HandshakeTimeout\");\n\tprintf (\"\\n\");\n\tprintf (\"        ID=%d  DEST-ID=%d  RESEL-ID=%d\\n\", reg[4]&7, reg[6]&7, reg[0xa]&7);\n\tprintf (\"\\n\");\n}",
          "includes": [
            "#include <dev/pci/ncr.c>",
            "#include <kvm.h>",
            "#include <limits.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <nlist.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ncr.c>\n#include <kvm.h>\n#include <limits.h>\n#include <paths.h>\n#include <errno.h>\n#include <stdio.h>\n#include <nlist.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/file.h>\n\nstatic void dump_reg(struct ncr_reg * rp)\n{\n\tu_char *reg = (u_char*) rp;\n#define l(i)  (reg[i]+(reg[i+1]<<8ul)+(reg[i+2]<<16ul)+(reg[i+3]<<24ul))\n\tint ad;\n\n\tchar*(phasename[8])={\"DATA-OUT\",\"DATA-IN\",\"COMMAND\",\"STATUS\",\n\t\t\t\t\"ILG-OUT\",\"ILG-IN\",\"MESSAGE-OUT\",\"MESSAGE-IN\"};\n\tfor (ad=0x00;ad<0x80;ad++) {\n\t\tswitch (ad % 16) {\n\n\t\tcase 0:\n\t\t\tprintf (\"        %02x:\\t\",ad);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tprintf (\" :  \");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf (\" \");\n\t\t};\n\t\tprintf (\"%02x\", reg[ad]);\n\t\tif (ad % 16 == 15) printf (\"\\n\");\n\t};\n\tprintf (\"\\n\");\n\tprintf (\"        DSP  %08x %-20s  CMD %08x DSPS %08x %s\\n\",\n\t\tl(0x2c),sn(l(0x2c)),l(0x24),l(0x30), sn(l(0x30)));\n\tprintf (\"        TEMP %08x %-20s  DSA %08x\\n\",\n\t\tl(0x1c),sn(l(0x1c)),l(0x10)); \n\tprintf (\"\\n\");\n\tprintf (\"        Busstatus: \");\n\tif ((reg[0x0b]>>7)&1) printf (\" Req\");\n\tif ((reg[0x0b]>>6)&1) printf (\" Ack\");\n\tif ((reg[0x0b]>>5)&1) printf (\" Bsy\");\n\tif ((reg[0x0b]>>4)&1) printf (\" Sel\");\n\tif ((reg[0x0b]>>3)&1) printf (\" Atn\");\n\tprintf (\" %s\\n\", phasename[reg[0x0b]&7]);\n\f\n        printf (\"        Dmastatus: \");\n\tif ((reg[0x0c]>>7)&1) printf (\" FifoEmpty\");\n\tif ((reg[0x0c]>>6)&1) printf (\" MasterParityError\");\n\tif ((reg[0x0c]>>5)&1) printf (\" BusFault\");\n\tif ((reg[0x0c]>>4)&1) printf (\" Aborted\");\n\tif ((reg[0x0c]>>3)&1) printf (\" SingleStep\");\n\tif ((reg[0x0c]>>2)&1) printf (\" Interrupt\");\n\tif ((reg[0x0c]>>0)&1) printf (\" IllegalInstruction\");\n\tprintf (\"\\n\");\n\tprintf (\"        Intstatus: \");\n\tif ((reg[0x14]>>7)&1) printf (\" Abort\");\n\tif ((reg[0x14]>>6)&1) printf (\" SoftwareReset\");\n\tif ((reg[0x14]>>5)&1) printf (\" SignalProcess\");\n\tif ((reg[0x14]>>4)&1) printf (\" Semaphore\");\n\tif ((reg[0x14]>>3)&1) printf (\" Connected\");\n\tif ((reg[0x14]>>2)&1) printf (\" IntOnTheFly\");\n\tif ((reg[0x14]>>1)&1) printf (\" SCSI-Interrupt\");\n\tif ((reg[0x14]>>0)&1) printf (\" DMA-Interrupt\");\n\tprintf (\"\\n\");\n\tprintf (\"        ScsiIstat: \");\n\tif ((reg[0x42]>>7)&1) printf (\" PhaseMismatch\");\n\tif ((reg[0x42]>>6)&1) printf (\" Complete\");\n\tif ((reg[0x42]>>5)&1) printf (\" Selected\");\n\tif ((reg[0x42]>>4)&1) printf (\" Reselected\");\n\tif ((reg[0x42]>>3)&1) printf (\" GrossError\");\n\tif ((reg[0x42]>>2)&1) printf (\" UnexpectedDisconnect\");\n\tif ((reg[0x42]>>1)&1) printf (\" ScsiReset\");\n\tif ((reg[0x42]>>0)&1) printf (\" ParityError\");\n\tif ((reg[0x43]>>2)&1) printf (\" SelectionTimeout\");\n\tif ((reg[0x43]>>1)&1) printf (\" TimerExpired\");\n\tif ((reg[0x43]>>0)&1) printf (\" HandshakeTimeout\");\n\tprintf (\"\\n\");\n\tprintf (\"        ID=%d  DEST-ID=%d  RESEL-ID=%d\\n\", reg[4]&7, reg[6]&7, reg[0xa]&7);\n\tprintf (\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctime",
          "args": [
            "&ncr.regtime.tv_sec"
          ],
          "line": 1385
        },
        "resolved": true,
        "details": {
          "function_name": "wdctimeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "952-980",
          "snippet": "void\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [
            "static void  __wdcerror"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nstatic void  __wdcerror;\n\nvoid\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "debug_opt",
            "'d'"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sn",
          "args": [
            "ncr.squeue[i]"
          ],
          "line": 1371
        },
        "resolved": true,
        "details": {
          "function_name": "sn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncrstat.c",
          "lines": "883-946",
          "snippet": "static const char * sn (u_long a)\n{\n\tstatic\tchar buffer[100];\n\n\tconst char * s=\"\";\n\tu_long d,m;\n\n\ta -= ncr.p_script;\n\tm = sizeof (struct script);\n\n\tif ((d=a-offsetof(struct script, start))<m) m=d, s=\"<start>\";\n\tif ((d=a-offsetof(struct script, start1))<m) m=d, s=\"<start1>\";\n\tif ((d=a-offsetof(struct script, startpos))<m) m=d, s=\"<startpos>\";\n\tif ((d=a-offsetof(struct script, tryloop))<m) m=d, s=\"<tryloop>\";\n\tif ((d=a-offsetof(struct script, trysel))<m) m=d, s=\"<trysel>\";\n\tif ((d=a-offsetof(struct script, skip))<m) m=d, s=\"<skip>\";\n\tif ((d=a-offsetof(struct script, skip2))<m) m=d, s=\"<skip2>\";\n\tif ((d=a-offsetof(struct script, idle))<m) m=d, s=\"<idle>\";\n\tif ((d=a-offsetof(struct script, select))<m) m=d, s=\"<select>\";\n\tif ((d=a-offsetof(struct script, prepare))<m) m=d, s=\"<prepare>\";\n\tif ((d=a-offsetof(struct script, loadpos))<m) m=d, s=\"<loadpos>\";\n\tif ((d=a-offsetof(struct script, prepare2))<m) m=d, s=\"<prepare2>\";\n\tif ((d=a-offsetof(struct script, setmsg))<m) m=d, s=\"<setmsg>\";\n\tif ((d=a-offsetof(struct script, clrack))<m) m=d, s=\"<clrack>\";\n\tif ((d=a-offsetof(struct script, dispatch))<m) m=d, s=\"<dispatch>\";\n\tif ((d=a-offsetof(struct script, checkatn))<m) m=d, s=\"<checkatn>\";\n\tif ((d=a-offsetof(struct script, command))<m) m=d, s=\"<command>\";\n\tif ((d=a-offsetof(struct script, status))<m) m=d, s=\"<status>\";\n\tif ((d=a-offsetof(struct script, msg_in))<m) m=d, s=\"<msg_in>\";\n\tif ((d=a-offsetof(struct script, msg_bad))<m) m=d, s=\"<msg_bad>\";\n\tif ((d=a-offsetof(struct script, msg_parity))<m) m=d, s=\"<msg_parity>\";\n\tif ((d=a-offsetof(struct script, msg_reject))<m) m=d, s=\"<msg_reject>\";\n\tif ((d=a-offsetof(struct script, msg_extended))<m) m=d, s=\"<msg_extended>\";\n\tif ((d=a-offsetof(struct script, msg_sdtr))<m) m=d, s=\"<msg_sdtr>\";\n\tif ((d=a-offsetof(struct script, complete))<m) m=d, s=\"<complete>\";\n\tif ((d=a-offsetof(struct script, cleanup))<m) m=d, s=\"<cleanup>\";\n\tif ((d=a-offsetof(struct script, cleanup0))<m) m=d, s=\"<cleanup>\";\n\tif ((d=a-offsetof(struct script, signal))<m) m=d, s=\"<signal>\";\n\tif ((d=a-offsetof(struct script, save_dp))<m) m=d, s=\"<save_dp>\";\n\tif ((d=a-offsetof(struct script, restore_dp))<m) m=d, s=\"<restore_dp>\";\n\tif ((d=a-offsetof(struct script, disconnect))<m) m=d, s=\"<disconnect>\";\n\tif ((d=a-offsetof(struct script, msg_out))<m) m=d, s=\"<msg_out>\";\n\tif ((d=a-offsetof(struct script, msg_out_done))<m) m=d, s=\"<msg_out_done>\";\n\tif ((d=a-offsetof(struct script, msg_out_abort))<m) m=d, s=\"<msg_out_abort>\";\n\tif ((d=a-offsetof(struct script, getcc))<m) m=d, s=\"<getcc>\";\n\tif ((d=a-offsetof(struct script, getcc1))<m) m=d, s=\"<getcc1>\";\n\tif ((d=a-offsetof(struct script, getcc2))<m) m=d, s=\"<getcc2>\";\n\tif ((d=a-offsetof(struct script, badgetcc))<m) m=d, s=\"<badgetcc>\";\n\tif ((d=a-offsetof(struct script, reselect))<m) m=d, s=\"<reselect>\";\n\tif ((d=a-offsetof(struct script, reselect2))<m) m=d, s=\"<reselect2>\";\n\tif ((d=a-offsetof(struct script, resel_tmp))<m) m=d, s=\"<resel_tmp>\";\n\tif ((d=a-offsetof(struct script, resel_lun))<m) m=d, s=\"<resel_lun>\";\n\tif ((d=a-offsetof(struct script, resel_tag))<m) m=d, s=\"<resel_tag>\";\n\tif ((d=a-offsetof(struct script, data_in))<m) m=d, s=\"<data_in>\";\n\tif ((d=a-offsetof(struct script, data_out))<m) m=d, s=\"<data_out>\";\n\tif ((d=a-offsetof(struct script, no_data))<m) m=d, s=\"<no_data>\";\n\tif ((d=a-offsetof(struct script, aborttag))<m) m=d, s=\"<aborttag>\";\n\tif ((d=a-offsetof(struct script, abort))<m) m=d, s=\"<abort>\";\n\n\tif (!*s) return s;\n\n\tsprintf (buffer, \"%s:%d%c\", s, m/4, 0);\n\treturn (buffer);\n}",
          "includes": [
            "#include <dev/pci/ncr.c>",
            "#include <kvm.h>",
            "#include <limits.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <nlist.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ncr.c>\n#include <kvm.h>\n#include <limits.h>\n#include <paths.h>\n#include <errno.h>\n#include <stdio.h>\n#include <nlist.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/file.h>\n\nstatic const char * sn (u_long a)\n{\n\tstatic\tchar buffer[100];\n\n\tconst char * s=\"\";\n\tu_long d,m;\n\n\ta -= ncr.p_script;\n\tm = sizeof (struct script);\n\n\tif ((d=a-offsetof(struct script, start))<m) m=d, s=\"<start>\";\n\tif ((d=a-offsetof(struct script, start1))<m) m=d, s=\"<start1>\";\n\tif ((d=a-offsetof(struct script, startpos))<m) m=d, s=\"<startpos>\";\n\tif ((d=a-offsetof(struct script, tryloop))<m) m=d, s=\"<tryloop>\";\n\tif ((d=a-offsetof(struct script, trysel))<m) m=d, s=\"<trysel>\";\n\tif ((d=a-offsetof(struct script, skip))<m) m=d, s=\"<skip>\";\n\tif ((d=a-offsetof(struct script, skip2))<m) m=d, s=\"<skip2>\";\n\tif ((d=a-offsetof(struct script, idle))<m) m=d, s=\"<idle>\";\n\tif ((d=a-offsetof(struct script, select))<m) m=d, s=\"<select>\";\n\tif ((d=a-offsetof(struct script, prepare))<m) m=d, s=\"<prepare>\";\n\tif ((d=a-offsetof(struct script, loadpos))<m) m=d, s=\"<loadpos>\";\n\tif ((d=a-offsetof(struct script, prepare2))<m) m=d, s=\"<prepare2>\";\n\tif ((d=a-offsetof(struct script, setmsg))<m) m=d, s=\"<setmsg>\";\n\tif ((d=a-offsetof(struct script, clrack))<m) m=d, s=\"<clrack>\";\n\tif ((d=a-offsetof(struct script, dispatch))<m) m=d, s=\"<dispatch>\";\n\tif ((d=a-offsetof(struct script, checkatn))<m) m=d, s=\"<checkatn>\";\n\tif ((d=a-offsetof(struct script, command))<m) m=d, s=\"<command>\";\n\tif ((d=a-offsetof(struct script, status))<m) m=d, s=\"<status>\";\n\tif ((d=a-offsetof(struct script, msg_in))<m) m=d, s=\"<msg_in>\";\n\tif ((d=a-offsetof(struct script, msg_bad))<m) m=d, s=\"<msg_bad>\";\n\tif ((d=a-offsetof(struct script, msg_parity))<m) m=d, s=\"<msg_parity>\";\n\tif ((d=a-offsetof(struct script, msg_reject))<m) m=d, s=\"<msg_reject>\";\n\tif ((d=a-offsetof(struct script, msg_extended))<m) m=d, s=\"<msg_extended>\";\n\tif ((d=a-offsetof(struct script, msg_sdtr))<m) m=d, s=\"<msg_sdtr>\";\n\tif ((d=a-offsetof(struct script, complete))<m) m=d, s=\"<complete>\";\n\tif ((d=a-offsetof(struct script, cleanup))<m) m=d, s=\"<cleanup>\";\n\tif ((d=a-offsetof(struct script, cleanup0))<m) m=d, s=\"<cleanup>\";\n\tif ((d=a-offsetof(struct script, signal))<m) m=d, s=\"<signal>\";\n\tif ((d=a-offsetof(struct script, save_dp))<m) m=d, s=\"<save_dp>\";\n\tif ((d=a-offsetof(struct script, restore_dp))<m) m=d, s=\"<restore_dp>\";\n\tif ((d=a-offsetof(struct script, disconnect))<m) m=d, s=\"<disconnect>\";\n\tif ((d=a-offsetof(struct script, msg_out))<m) m=d, s=\"<msg_out>\";\n\tif ((d=a-offsetof(struct script, msg_out_done))<m) m=d, s=\"<msg_out_done>\";\n\tif ((d=a-offsetof(struct script, msg_out_abort))<m) m=d, s=\"<msg_out_abort>\";\n\tif ((d=a-offsetof(struct script, getcc))<m) m=d, s=\"<getcc>\";\n\tif ((d=a-offsetof(struct script, getcc1))<m) m=d, s=\"<getcc1>\";\n\tif ((d=a-offsetof(struct script, getcc2))<m) m=d, s=\"<getcc2>\";\n\tif ((d=a-offsetof(struct script, badgetcc))<m) m=d, s=\"<badgetcc>\";\n\tif ((d=a-offsetof(struct script, reselect))<m) m=d, s=\"<reselect>\";\n\tif ((d=a-offsetof(struct script, reselect2))<m) m=d, s=\"<reselect2>\";\n\tif ((d=a-offsetof(struct script, resel_tmp))<m) m=d, s=\"<resel_tmp>\";\n\tif ((d=a-offsetof(struct script, resel_lun))<m) m=d, s=\"<resel_lun>\";\n\tif ((d=a-offsetof(struct script, resel_tag))<m) m=d, s=\"<resel_tag>\";\n\tif ((d=a-offsetof(struct script, data_in))<m) m=d, s=\"<data_in>\";\n\tif ((d=a-offsetof(struct script, data_out))<m) m=d, s=\"<data_out>\";\n\tif ((d=a-offsetof(struct script, no_data))<m) m=d, s=\"<no_data>\";\n\tif ((d=a-offsetof(struct script, aborttag))<m) m=d, s=\"<aborttag>\";\n\tif ((d=a-offsetof(struct script, abort))<m) m=d, s=\"<abort>\";\n\n\tif (!*s) return s;\n\n\tsprintf (buffer, \"%s:%d%c\", s, m/4, 0);\n\treturn (buffer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: bad kvm read.\\n\"",
            "prog"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_READ",
          "args": [
            "((u_long)ncr.script\n\t\t\t\t+offsetof(struct script, startpos))",
            "&startpos",
            "sizeof (startpos)"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "debug_opt",
            "'q'"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "debug_opt",
            "'u'"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: bad kvm read.\\n\"",
            "prog"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_READ",
          "args": [
            "ncr.vaddr",
            "&reg",
            "sizeof (reg)"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "debug_opt",
            "'r'"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_link",
          "args": [
            "\"    jump_tcb\"",
            "&ncr.jump_tcb"
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "dump_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncrstat.c",
          "lines": "982-986",
          "snippet": "void dump_link (const char* name, struct link * link)\n{\n\tprintf (\"%s: cmd=%08x pa=%08x %s\\n\",\n\tname, link->l_cmd, link->l_paddr, sn(link->l_paddr));\n}",
          "includes": [
            "#include <dev/pci/ncr.c>",
            "#include <kvm.h>",
            "#include <limits.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <nlist.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ncr.c>\n#include <kvm.h>\n#include <limits.h>\n#include <paths.h>\n#include <errno.h>\n#include <stdio.h>\n#include <nlist.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/file.h>\n\nvoid dump_link (const char* name, struct link * link)\n{\n\tprintf (\"%s: cmd=%08x pa=%08x %s\\n\",\n\tname, link->l_cmd, link->l_paddr, sn(link->l_paddr));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/ncr.c>\n#include <kvm.h>\n#include <limits.h>\n#include <paths.h>\n#include <errno.h>\n#include <stdio.h>\n#include <nlist.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/file.h>\n\nextern void  exit();\nchar\t*prog;\n\nstatic void dump_ncr (void)\n{\n\tu_long tp;\n\tint i;\n\n\tprintf (\"----------------------\\n\");\n\tprintf (\"struct ncb @ %x:\\n\", ncr_base);\n\tprintf (\"----------------------\\n\");\n\n\tdump_link (\"    jump_tcb\", &ncr.jump_tcb);\n\tprintf    (\"    register: @ %x (p=%x)\\n\", ncr.vaddr, ncr.paddr);\n\n\tif (strchr (debug_opt, 'r')) {\n\t\tstruct ncr_reg reg;\n\n\t\tif (!KVM_READ (\n\t\t\tncr.vaddr,\n\t\t\t&reg,\n\t\t\tsizeof (reg))) {\n\t\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\t\texit (1);\n\t\t};\n\t\t\n\t\tprintf (\"\\n\");\n\t\tdump_reg (&reg);\n\t};\n\n\tprintf    (\"      script: @ %x (p=%x)\\n\", ncr.script, ncr.p_script);\n\n\tprintf (\"hostscsiaddr: %d\\n\", ncr.myaddr);\n\tprintf (\"    ns_async: %d ns\\n\", ncr.ns_async);\n\tprintf (\"    ns_sync : %d ns\\n\", ncr.ns_sync);\n\tprintf (\"      scntl3: 0x%02x\\n\", ncr.rv_scntl3);\n\tprintf (\"\\n\");\n\n\t/* sc_link not dumped */\n\n\tif (strchr (debug_opt, 'u')) {\n\t\tprintf (\"     usercmd: cmd=%x data=%x target=%x lun=%x\\n\",\n\t\t\tncr.user.cmd,\n\t\t\tncr.user.data,\n\t\t\tncr.user.target,\n\t\t\tncr.user.lun);\n\t};\n\f\n\tprintf (\"     actccbs: %d\\n\", ncr.actccbs);\n\n\tif (strchr (debug_opt, 'q')) {\n\n\t\tu_long\tstartpos;\n\n\t\tif (!KVM_READ (\n\t\t\t((u_long)ncr.script\n\t\t\t\t+offsetof(struct script, startpos)),\n\t\t\t&startpos,\n\t\t\tsizeof (startpos))) {\n\t\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\t\texit (1);\n\t\t};\n\t\t\n\t\tprintf (\"    startpos: %x\\n\", startpos);\n\t\tprintf (\"        slot: %d\\n\", (startpos-\n\t\t\t(ncr.p_script+offsetof(struct script, tryloop)))/20);\n\t\tprintf (\"    squeuput: %d\\n\", ncr.squeueput);\n\t\tfor (i=0; i<MAX_START; i++)\n\t\t\tprintf (\"%12d: %08x %s\\n\", i,\n\t\t\tncr.squeue[i], sn(ncr.squeue[i]));\n\n\t\tprintf (\"\\n\");\n\t};\n\n\tprintf (\"       ticks: %d ms\\n\", ncr.ticks * 10);\n\tprintf (\"   heartbeat: %s\", ctime ((time_t*)&ncr.heartbeat));\n\tprintf (\"    lasttime: %s\", ctime ((time_t*)&ncr.lasttime));\n#if !defined(__NetBSD__) && !defined(__OpenBSD__)\n\tprintf (\"imask/mcount: %x / %d\\n\", ncr.imask, ncr.mcount);\n#endif\n\tprintf (\"\\n\");\n\n\tif (strchr (debug_opt, 'd') && ncr.regtime.tv_sec) {\n\t\tprintf (\"     regdump: %s\", ctime (&ncr.regtime.tv_sec));\n\t\tdump_reg (&ncr.regdump);\n\t};\n\n\tif (strchr (debug_opt, 'p')) {\n\t\tprintf (\"\\n\");\n\t\tdump_profile (\"     profile\", &ncr.profile);\n\t};\n\n\tif (strchr (debug_opt, 'h')) {\n\t\tprintf (\"\\n\");\n\t\tdump_head ( &ncr.header);\n\t};\n\n\tif (strchr (debug_opt, 'c')) {\n\t\tdump_ccb  (&ncr.ccb, ncr_base + offsetof (struct ncb, ccb));\n\t};\n\f\n\tif (strchr (debug_opt, 'm')) {\n\t\tprintf (\"      msgout:\"); printm (ncr.msgout,0); printf (\"\\n\");\n\t\tprintf (\"      msg in:\"); printm (ncr.msgin,0);  printf (\"\\n\");\n\t\tprintf (\"\\n\");\n\t};\n\n\tif (strchr (debug_opt, 't')) {\n\t\tstruct tcb * tip;\n\t\tfor (i=0;i<MAX_TARGET;i++) {\n\t\t\ttip = &ncr.target[i];\n\t\t\tif (!tip->jump_tcb.l_cmd) continue;\n\t\t\tprintf (\"target #%d:\\n\", i);\n\t\t\tdump_tip (tip);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "dump_tip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncrstat.c",
    "lines": "1261-1293",
    "snippet": "static void dump_tip (struct tcb * tip)\n{\n\tint i;\n\tu_long lp;\n\n\tprintf (\"----------------------\\n\");\n\tprintf (\"struct tcb:\\n\");\n\tprintf (\"----------------------\\n\");\n\n\tprintf (\"   transfers:%10d.\\n\", tip->transfers);\n\tprintf (\"       bytes:%10d.\\n\", tip->bytes    );\n\tprintf (\" user limits: usrsync=%d  usrwide=%d  usrtags=%d.\\n\",\n\t\t\ttip->usrsync, tip->usrwide, tip->usrtags);\n\tprintf (\"        sync: minsync=%d, maxoffs=%d, period=%d ns, sval=%x.\\n\",\n\t\t\ttip->minsync, tip->maxoffs, tip->period, tip->sval);\n\tprintf (\"\twide: widedone=%d, wval=%x.\\n\",\n\t\t\ttip->widedone, tip->wval);\n\n\tprintf   (\"     hold_cp: %x\\n\", tip->hold_cp);\n\tdump_link (\"    jump_tcb\", &tip->jump_tcb);\n\tdump_link (\"    call_lun\", &tip->call_lun);\n\tdump_link (\"    jump_lcb\", &tip->jump_lcb);\n\tif (tip->hold_cp) printf (\"     hold_cp: @ %x\\n\", tip->hold_cp);\n\tprintf (\"\\n\");\n\n\tif (strchr (debug_opt, 'l')) {\n\t\tfor (i=0;i<MAX_LUN;i++) {\n\t\t\tlp= (u_long) tip->lp[i];\n\t\t\tprintf (\"logic unit #%d:\\n\", i);\n\t\t\tif (lp) dump_lcb (lp);\n\t\t};\n\t}\n}",
    "includes": [
      "#include <dev/pci/ncr.c>",
      "#include <kvm.h>",
      "#include <limits.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <nlist.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_lcb",
          "args": [
            "lp"
          ],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "dump_lcb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncrstat.c",
          "lines": "1209-1250",
          "snippet": "static void dump_lcb (u_long base)\n{\n\tstruct lcb l;\n\tstruct ccb c;\n\tu_long cp,cn;\n\n\tprintf (\"----------------------\\n\");\n\tprintf (\"struct lcb @ %08x:\\n\", base);\n\tprintf (\"----------------------\\n\");\n\n\tif (!KVM_READ (\n\t\tbase,\n\t\t&l,\n\t\tsizeof (struct lcb))) {\n\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\texit (1);\n\t};\n\tprintf   (\"     reqccbs: %d\\n\", l.reqccbs);\n\tprintf   (\"     actccbs: %d\\n\", l.actccbs);\n\tprintf   (\"     reqlink: %d\\n\", l.reqlink);\n\tprintf   (\"     actlink: %d\\n\", l.actlink);\n\tprintf   (\"     usetags: %d\\n\", l.usetags);\n\tdump_link (\"    jump_lcb\", &l.jump_lcb);\n\tdump_link (\"    call_tag\", &l.call_tag);\n\tdump_link (\"    jump_ccb\", &l.jump_ccb);\n\tprintf (\"\\n\");\n\tcp = (u_long) l.next_ccb;\n\tcn = 0;\n\twhile (cp) {\n\t\tcn++;\n\t\tprintf (\"ccb #%d:\\n\", cn);\n\t\tif (!KVM_READ (\n\t\t\tcp,\n\t\t\t&c,\n\t\t\tsizeof (struct ccb))) {\n\t\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\t\texit (1);\n\t\t};\n\t\tdump_ccb (&c, cp);\n\t\tcp= (u_long) c.next_ccb;\n\t};\n}",
          "includes": [
            "#include <dev/pci/ncr.c>",
            "#include <kvm.h>",
            "#include <limits.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <nlist.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void  exit();",
            "char\t*prog;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ncr.c>\n#include <kvm.h>\n#include <limits.h>\n#include <paths.h>\n#include <errno.h>\n#include <stdio.h>\n#include <nlist.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/file.h>\n\nextern void  exit();\nchar\t*prog;\n\nstatic void dump_lcb (u_long base)\n{\n\tstruct lcb l;\n\tstruct ccb c;\n\tu_long cp,cn;\n\n\tprintf (\"----------------------\\n\");\n\tprintf (\"struct lcb @ %08x:\\n\", base);\n\tprintf (\"----------------------\\n\");\n\n\tif (!KVM_READ (\n\t\tbase,\n\t\t&l,\n\t\tsizeof (struct lcb))) {\n\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\texit (1);\n\t};\n\tprintf   (\"     reqccbs: %d\\n\", l.reqccbs);\n\tprintf   (\"     actccbs: %d\\n\", l.actccbs);\n\tprintf   (\"     reqlink: %d\\n\", l.reqlink);\n\tprintf   (\"     actlink: %d\\n\", l.actlink);\n\tprintf   (\"     usetags: %d\\n\", l.usetags);\n\tdump_link (\"    jump_lcb\", &l.jump_lcb);\n\tdump_link (\"    call_tag\", &l.call_tag);\n\tdump_link (\"    jump_ccb\", &l.jump_ccb);\n\tprintf (\"\\n\");\n\tcp = (u_long) l.next_ccb;\n\tcn = 0;\n\twhile (cp) {\n\t\tcn++;\n\t\tprintf (\"ccb #%d:\\n\", cn);\n\t\tif (!KVM_READ (\n\t\t\tcp,\n\t\t\t&c,\n\t\t\tsizeof (struct ccb))) {\n\t\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\t\texit (1);\n\t\t};\n\t\tdump_ccb (&c, cp);\n\t\tcp= (u_long) c.next_ccb;\n\t};\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"logic unit #%d:\\n\"",
            "i"
          ],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "debug_opt",
            "'l'"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_link",
          "args": [
            "\"    jump_lcb\"",
            "&tip->jump_lcb"
          ],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "dump_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncrstat.c",
          "lines": "982-986",
          "snippet": "void dump_link (const char* name, struct link * link)\n{\n\tprintf (\"%s: cmd=%08x pa=%08x %s\\n\",\n\tname, link->l_cmd, link->l_paddr, sn(link->l_paddr));\n}",
          "includes": [
            "#include <dev/pci/ncr.c>",
            "#include <kvm.h>",
            "#include <limits.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <nlist.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ncr.c>\n#include <kvm.h>\n#include <limits.h>\n#include <paths.h>\n#include <errno.h>\n#include <stdio.h>\n#include <nlist.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/file.h>\n\nvoid dump_link (const char* name, struct link * link)\n{\n\tprintf (\"%s: cmd=%08x pa=%08x %s\\n\",\n\tname, link->l_cmd, link->l_paddr, sn(link->l_paddr));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/ncr.c>\n#include <kvm.h>\n#include <limits.h>\n#include <paths.h>\n#include <errno.h>\n#include <stdio.h>\n#include <nlist.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/file.h>\n\nstatic void dump_tip (struct tcb * tip)\n{\n\tint i;\n\tu_long lp;\n\n\tprintf (\"----------------------\\n\");\n\tprintf (\"struct tcb:\\n\");\n\tprintf (\"----------------------\\n\");\n\n\tprintf (\"   transfers:%10d.\\n\", tip->transfers);\n\tprintf (\"       bytes:%10d.\\n\", tip->bytes    );\n\tprintf (\" user limits: usrsync=%d  usrwide=%d  usrtags=%d.\\n\",\n\t\t\ttip->usrsync, tip->usrwide, tip->usrtags);\n\tprintf (\"        sync: minsync=%d, maxoffs=%d, period=%d ns, sval=%x.\\n\",\n\t\t\ttip->minsync, tip->maxoffs, tip->period, tip->sval);\n\tprintf (\"\twide: widedone=%d, wval=%x.\\n\",\n\t\t\ttip->widedone, tip->wval);\n\n\tprintf   (\"     hold_cp: %x\\n\", tip->hold_cp);\n\tdump_link (\"    jump_tcb\", &tip->jump_tcb);\n\tdump_link (\"    call_lun\", &tip->call_lun);\n\tdump_link (\"    jump_lcb\", &tip->jump_lcb);\n\tif (tip->hold_cp) printf (\"     hold_cp: @ %x\\n\", tip->hold_cp);\n\tprintf (\"\\n\");\n\n\tif (strchr (debug_opt, 'l')) {\n\t\tfor (i=0;i<MAX_LUN;i++) {\n\t\t\tlp= (u_long) tip->lp[i];\n\t\t\tprintf (\"logic unit #%d:\\n\", i);\n\t\t\tif (lp) dump_lcb (lp);\n\t\t};\n\t}\n}"
  },
  {
    "function_name": "dump_lcb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncrstat.c",
    "lines": "1209-1250",
    "snippet": "static void dump_lcb (u_long base)\n{\n\tstruct lcb l;\n\tstruct ccb c;\n\tu_long cp,cn;\n\n\tprintf (\"----------------------\\n\");\n\tprintf (\"struct lcb @ %08x:\\n\", base);\n\tprintf (\"----------------------\\n\");\n\n\tif (!KVM_READ (\n\t\tbase,\n\t\t&l,\n\t\tsizeof (struct lcb))) {\n\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\texit (1);\n\t};\n\tprintf   (\"     reqccbs: %d\\n\", l.reqccbs);\n\tprintf   (\"     actccbs: %d\\n\", l.actccbs);\n\tprintf   (\"     reqlink: %d\\n\", l.reqlink);\n\tprintf   (\"     actlink: %d\\n\", l.actlink);\n\tprintf   (\"     usetags: %d\\n\", l.usetags);\n\tdump_link (\"    jump_lcb\", &l.jump_lcb);\n\tdump_link (\"    call_tag\", &l.call_tag);\n\tdump_link (\"    jump_ccb\", &l.jump_ccb);\n\tprintf (\"\\n\");\n\tcp = (u_long) l.next_ccb;\n\tcn = 0;\n\twhile (cp) {\n\t\tcn++;\n\t\tprintf (\"ccb #%d:\\n\", cn);\n\t\tif (!KVM_READ (\n\t\t\tcp,\n\t\t\t&c,\n\t\t\tsizeof (struct ccb))) {\n\t\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\t\texit (1);\n\t\t};\n\t\tdump_ccb (&c, cp);\n\t\tcp= (u_long) c.next_ccb;\n\t};\n}",
    "includes": [
      "#include <dev/pci/ncr.c>",
      "#include <kvm.h>",
      "#include <limits.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <nlist.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern void  exit();",
      "char\t*prog;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_ccb",
          "args": [
            "&c",
            "cp"
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "dump_ccb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncrstat.c",
          "lines": "1153-1198",
          "snippet": "void dump_ccb (struct ccb * cp, u_long base)\n{\n\tprintf (\"----------------------\\n\");\n\tprintf (\"struct ccb @ %08x:\\n\", base);\n\tprintf (\"----------------------\\n\");\n\n\tdump_link (\"        next\", &cp->jump_ccb);\n\tdump_link (\"        call\", &cp->call_tmp);\n\n\tdump_head (&cp->phys.header);\n\n\tif (strchr (debug_opt, 's')) {\n\t\tdump_table(\" smsg\", &cp->phys.smsg,   1);\n\t\tdump_table(\"smsg2\", &cp->phys.smsg2,  1);\n\t\tdump_table(\"  cmd\", &cp->phys.cmd,    1);\n\t\tdump_table(\" data\", &cp->phys.data[0],MAX_SCATTER);\n\t\tdump_table(\"sense\", &cp->phys.sense,  1);\n\t};\n\n\tif (strchr (debug_opt, 'a')) {\n\t\tint i;\n\t\tfor (i=0; i<8; i++)\n\t\t\tprintf (\"    patch[%d]: %08x\\n\", i, cp->patch[i]);\n\t};\n\n\tif (strchr (debug_opt, 'x')) {\n\t\tprintf (\"        xfer: -- dump not yet implemented.\\n\");\n\t};\n\n\tif (strchr (debug_opt, 'm')) {\n\t\tprintf (\"        smsg:\");\n\t\tprintm (cp->scsi_smsg, cp->phys.smsg.size);\n\t\tprintf (\"\\n\");\n\t\tprintf (\"       smsg2:\");\n\t\tprintm (cp->scsi_smsg2, cp->phys.smsg2.size);\n\t\tprintf (\"\\n\");\n\t};\n\n\tprintf (\"       magic: %x\\n\", cp->magic);\n\tif (cp->tlimit)\n\tprintf (\"  timeout at: %s\", ctime((time_t*)&cp->tlimit));\n\tprintf (\"    link_ccb: %08x\\n\", (u_long) cp->link_ccb);\n\tprintf (\"    next_ccb: %08x\\n\", (u_long) cp->next_ccb);\n\tprintf (\"         tag: %d\\n\", cp->tag);\n\tprintf (\"\\n\");\n}",
          "includes": [
            "#include <dev/pci/ncr.c>",
            "#include <kvm.h>",
            "#include <limits.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <nlist.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ncr.c>\n#include <kvm.h>\n#include <limits.h>\n#include <paths.h>\n#include <errno.h>\n#include <stdio.h>\n#include <nlist.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/file.h>\n\nvoid dump_ccb (struct ccb * cp, u_long base)\n{\n\tprintf (\"----------------------\\n\");\n\tprintf (\"struct ccb @ %08x:\\n\", base);\n\tprintf (\"----------------------\\n\");\n\n\tdump_link (\"        next\", &cp->jump_ccb);\n\tdump_link (\"        call\", &cp->call_tmp);\n\n\tdump_head (&cp->phys.header);\n\n\tif (strchr (debug_opt, 's')) {\n\t\tdump_table(\" smsg\", &cp->phys.smsg,   1);\n\t\tdump_table(\"smsg2\", &cp->phys.smsg2,  1);\n\t\tdump_table(\"  cmd\", &cp->phys.cmd,    1);\n\t\tdump_table(\" data\", &cp->phys.data[0],MAX_SCATTER);\n\t\tdump_table(\"sense\", &cp->phys.sense,  1);\n\t};\n\n\tif (strchr (debug_opt, 'a')) {\n\t\tint i;\n\t\tfor (i=0; i<8; i++)\n\t\t\tprintf (\"    patch[%d]: %08x\\n\", i, cp->patch[i]);\n\t};\n\n\tif (strchr (debug_opt, 'x')) {\n\t\tprintf (\"        xfer: -- dump not yet implemented.\\n\");\n\t};\n\n\tif (strchr (debug_opt, 'm')) {\n\t\tprintf (\"        smsg:\");\n\t\tprintm (cp->scsi_smsg, cp->phys.smsg.size);\n\t\tprintf (\"\\n\");\n\t\tprintf (\"       smsg2:\");\n\t\tprintm (cp->scsi_smsg2, cp->phys.smsg2.size);\n\t\tprintf (\"\\n\");\n\t};\n\n\tprintf (\"       magic: %x\\n\", cp->magic);\n\tif (cp->tlimit)\n\tprintf (\"  timeout at: %s\", ctime((time_t*)&cp->tlimit));\n\tprintf (\"    link_ccb: %08x\\n\", (u_long) cp->link_ccb);\n\tprintf (\"    next_ccb: %08x\\n\", (u_long) cp->next_ccb);\n\tprintf (\"         tag: %d\\n\", cp->tag);\n\tprintf (\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: bad kvm read.\\n\"",
            "prog"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_READ",
          "args": [
            "cp",
            "&c",
            "sizeof (struct ccb)"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ccb #%d:\\n\"",
            "cn"
          ],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_link",
          "args": [
            "\"    jump_ccb\"",
            "&l.jump_ccb"
          ],
          "line": 1233
        },
        "resolved": true,
        "details": {
          "function_name": "dump_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncrstat.c",
          "lines": "982-986",
          "snippet": "void dump_link (const char* name, struct link * link)\n{\n\tprintf (\"%s: cmd=%08x pa=%08x %s\\n\",\n\tname, link->l_cmd, link->l_paddr, sn(link->l_paddr));\n}",
          "includes": [
            "#include <dev/pci/ncr.c>",
            "#include <kvm.h>",
            "#include <limits.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <nlist.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ncr.c>\n#include <kvm.h>\n#include <limits.h>\n#include <paths.h>\n#include <errno.h>\n#include <stdio.h>\n#include <nlist.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/file.h>\n\nvoid dump_link (const char* name, struct link * link)\n{\n\tprintf (\"%s: cmd=%08x pa=%08x %s\\n\",\n\tname, link->l_cmd, link->l_paddr, sn(link->l_paddr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: bad kvm read.\\n\"",
            "prog"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_READ",
          "args": [
            "base",
            "&l",
            "sizeof (struct lcb)"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/ncr.c>\n#include <kvm.h>\n#include <limits.h>\n#include <paths.h>\n#include <errno.h>\n#include <stdio.h>\n#include <nlist.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/file.h>\n\nextern void  exit();\nchar\t*prog;\n\nstatic void dump_lcb (u_long base)\n{\n\tstruct lcb l;\n\tstruct ccb c;\n\tu_long cp,cn;\n\n\tprintf (\"----------------------\\n\");\n\tprintf (\"struct lcb @ %08x:\\n\", base);\n\tprintf (\"----------------------\\n\");\n\n\tif (!KVM_READ (\n\t\tbase,\n\t\t&l,\n\t\tsizeof (struct lcb))) {\n\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\texit (1);\n\t};\n\tprintf   (\"     reqccbs: %d\\n\", l.reqccbs);\n\tprintf   (\"     actccbs: %d\\n\", l.actccbs);\n\tprintf   (\"     reqlink: %d\\n\", l.reqlink);\n\tprintf   (\"     actlink: %d\\n\", l.actlink);\n\tprintf   (\"     usetags: %d\\n\", l.usetags);\n\tdump_link (\"    jump_lcb\", &l.jump_lcb);\n\tdump_link (\"    call_tag\", &l.call_tag);\n\tdump_link (\"    jump_ccb\", &l.jump_ccb);\n\tprintf (\"\\n\");\n\tcp = (u_long) l.next_ccb;\n\tcn = 0;\n\twhile (cp) {\n\t\tcn++;\n\t\tprintf (\"ccb #%d:\\n\", cn);\n\t\tif (!KVM_READ (\n\t\t\tcp,\n\t\t\t&c,\n\t\t\tsizeof (struct ccb))) {\n\t\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\t\texit (1);\n\t\t};\n\t\tdump_ccb (&c, cp);\n\t\tcp= (u_long) c.next_ccb;\n\t};\n}"
  },
  {
    "function_name": "dump_ccb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncrstat.c",
    "lines": "1153-1198",
    "snippet": "void dump_ccb (struct ccb * cp, u_long base)\n{\n\tprintf (\"----------------------\\n\");\n\tprintf (\"struct ccb @ %08x:\\n\", base);\n\tprintf (\"----------------------\\n\");\n\n\tdump_link (\"        next\", &cp->jump_ccb);\n\tdump_link (\"        call\", &cp->call_tmp);\n\n\tdump_head (&cp->phys.header);\n\n\tif (strchr (debug_opt, 's')) {\n\t\tdump_table(\" smsg\", &cp->phys.smsg,   1);\n\t\tdump_table(\"smsg2\", &cp->phys.smsg2,  1);\n\t\tdump_table(\"  cmd\", &cp->phys.cmd,    1);\n\t\tdump_table(\" data\", &cp->phys.data[0],MAX_SCATTER);\n\t\tdump_table(\"sense\", &cp->phys.sense,  1);\n\t};\n\n\tif (strchr (debug_opt, 'a')) {\n\t\tint i;\n\t\tfor (i=0; i<8; i++)\n\t\t\tprintf (\"    patch[%d]: %08x\\n\", i, cp->patch[i]);\n\t};\n\n\tif (strchr (debug_opt, 'x')) {\n\t\tprintf (\"        xfer: -- dump not yet implemented.\\n\");\n\t};\n\n\tif (strchr (debug_opt, 'm')) {\n\t\tprintf (\"        smsg:\");\n\t\tprintm (cp->scsi_smsg, cp->phys.smsg.size);\n\t\tprintf (\"\\n\");\n\t\tprintf (\"       smsg2:\");\n\t\tprintm (cp->scsi_smsg2, cp->phys.smsg2.size);\n\t\tprintf (\"\\n\");\n\t};\n\n\tprintf (\"       magic: %x\\n\", cp->magic);\n\tif (cp->tlimit)\n\tprintf (\"  timeout at: %s\", ctime((time_t*)&cp->tlimit));\n\tprintf (\"    link_ccb: %08x\\n\", (u_long) cp->link_ccb);\n\tprintf (\"    next_ccb: %08x\\n\", (u_long) cp->next_ccb);\n\tprintf (\"         tag: %d\\n\", cp->tag);\n\tprintf (\"\\n\");\n}",
    "includes": [
      "#include <dev/pci/ncr.c>",
      "#include <kvm.h>",
      "#include <limits.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <nlist.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctime",
          "args": [
            "(time_t*)&cp->tlimit"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "wdctimeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "952-980",
          "snippet": "void\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [
            "static void  __wdcerror"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nstatic void  __wdcerror;\n\nvoid\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printm",
          "args": [
            "cp->scsi_smsg2",
            "cp->phys.smsg2.size"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "printm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncrstat.c",
          "lines": "957-971",
          "snippet": "static void printm (u_char * msg, int len)\n{\n\tu_char l;\n\tdo {\n\t\tif (*msg==M_EXTENDED)\n\t\t\tl=msg[1]+2;\n\t\telse if ((*msg & 0xf0)==0x20)\n\t\t\tl=2;\n\t\telse l=1;\n\t\tlen-=l;\n\n\t\tprintf (\" %x\",*msg++);\n\t\twhile (--l>0) printf (\"-%x\",*msg++);\n\t} while (len>0);\n}",
          "includes": [
            "#include <dev/pci/ncr.c>",
            "#include <kvm.h>",
            "#include <limits.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <nlist.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ncr.c>\n#include <kvm.h>\n#include <limits.h>\n#include <paths.h>\n#include <errno.h>\n#include <stdio.h>\n#include <nlist.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/file.h>\n\nstatic void printm (u_char * msg, int len)\n{\n\tu_char l;\n\tdo {\n\t\tif (*msg==M_EXTENDED)\n\t\t\tl=msg[1]+2;\n\t\telse if ((*msg & 0xf0)==0x20)\n\t\t\tl=2;\n\t\telse l=1;\n\t\tlen-=l;\n\n\t\tprintf (\" %x\",*msg++);\n\t\twhile (--l>0) printf (\"-%x\",*msg++);\n\t} while (len>0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "debug_opt",
            "'m'"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "debug_opt",
            "'x'"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "debug_opt",
            "'a'"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_table",
          "args": [
            "\"sense\"",
            "&cp->phys.sense",
            "1"
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "dump_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncrstat.c",
          "lines": "973-980",
          "snippet": "void dump_table (const char * str, struct scr_tblmove * p, int l)\n{\n\tint i;\n\tfor (i=0;l>0;i++,p++,l--) if (p->size) {\n\tprintf (\"    %s[%d]: %5d @ 0x%08x\\n\",\n\t\tstr, i, p->size, p->addr);\n\t};\n}",
          "includes": [
            "#include <dev/pci/ncr.c>",
            "#include <kvm.h>",
            "#include <limits.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <nlist.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ncr.c>\n#include <kvm.h>\n#include <limits.h>\n#include <paths.h>\n#include <errno.h>\n#include <stdio.h>\n#include <nlist.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/file.h>\n\nvoid dump_table (const char * str, struct scr_tblmove * p, int l)\n{\n\tint i;\n\tfor (i=0;l>0;i++,p++,l--) if (p->size) {\n\tprintf (\"    %s[%d]: %5d @ 0x%08x\\n\",\n\t\tstr, i, p->size, p->addr);\n\t};\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "debug_opt",
            "'s'"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_head",
          "args": [
            "&cp->phys.header"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_link",
          "args": [
            "\"        call\"",
            "&cp->call_tmp"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "dump_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncrstat.c",
          "lines": "982-986",
          "snippet": "void dump_link (const char* name, struct link * link)\n{\n\tprintf (\"%s: cmd=%08x pa=%08x %s\\n\",\n\tname, link->l_cmd, link->l_paddr, sn(link->l_paddr));\n}",
          "includes": [
            "#include <dev/pci/ncr.c>",
            "#include <kvm.h>",
            "#include <limits.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <nlist.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ncr.c>\n#include <kvm.h>\n#include <limits.h>\n#include <paths.h>\n#include <errno.h>\n#include <stdio.h>\n#include <nlist.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/file.h>\n\nvoid dump_link (const char* name, struct link * link)\n{\n\tprintf (\"%s: cmd=%08x pa=%08x %s\\n\",\n\tname, link->l_cmd, link->l_paddr, sn(link->l_paddr));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/ncr.c>\n#include <kvm.h>\n#include <limits.h>\n#include <paths.h>\n#include <errno.h>\n#include <stdio.h>\n#include <nlist.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/file.h>\n\nvoid dump_ccb (struct ccb * cp, u_long base)\n{\n\tprintf (\"----------------------\\n\");\n\tprintf (\"struct ccb @ %08x:\\n\", base);\n\tprintf (\"----------------------\\n\");\n\n\tdump_link (\"        next\", &cp->jump_ccb);\n\tdump_link (\"        call\", &cp->call_tmp);\n\n\tdump_head (&cp->phys.header);\n\n\tif (strchr (debug_opt, 's')) {\n\t\tdump_table(\" smsg\", &cp->phys.smsg,   1);\n\t\tdump_table(\"smsg2\", &cp->phys.smsg2,  1);\n\t\tdump_table(\"  cmd\", &cp->phys.cmd,    1);\n\t\tdump_table(\" data\", &cp->phys.data[0],MAX_SCATTER);\n\t\tdump_table(\"sense\", &cp->phys.sense,  1);\n\t};\n\n\tif (strchr (debug_opt, 'a')) {\n\t\tint i;\n\t\tfor (i=0; i<8; i++)\n\t\t\tprintf (\"    patch[%d]: %08x\\n\", i, cp->patch[i]);\n\t};\n\n\tif (strchr (debug_opt, 'x')) {\n\t\tprintf (\"        xfer: -- dump not yet implemented.\\n\");\n\t};\n\n\tif (strchr (debug_opt, 'm')) {\n\t\tprintf (\"        smsg:\");\n\t\tprintm (cp->scsi_smsg, cp->phys.smsg.size);\n\t\tprintf (\"\\n\");\n\t\tprintf (\"       smsg2:\");\n\t\tprintm (cp->scsi_smsg2, cp->phys.smsg2.size);\n\t\tprintf (\"\\n\");\n\t};\n\n\tprintf (\"       magic: %x\\n\", cp->magic);\n\tif (cp->tlimit)\n\tprintf (\"  timeout at: %s\", ctime((time_t*)&cp->tlimit));\n\tprintf (\"    link_ccb: %08x\\n\", (u_long) cp->link_ccb);\n\tprintf (\"    next_ccb: %08x\\n\", (u_long) cp->next_ccb);\n\tprintf (\"         tag: %d\\n\", cp->tag);\n\tprintf (\"\\n\");\n}"
  },
  {
    "function_name": "dump_reg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncrstat.c",
    "lines": "1041-1112",
    "snippet": "static void dump_reg(struct ncr_reg * rp)\n{\n\tu_char *reg = (u_char*) rp;\n#define l(i)  (reg[i]+(reg[i+1]<<8ul)+(reg[i+2]<<16ul)+(reg[i+3]<<24ul))\n\tint ad;\n\n\tchar*(phasename[8])={\"DATA-OUT\",\"DATA-IN\",\"COMMAND\",\"STATUS\",\n\t\t\t\t\"ILG-OUT\",\"ILG-IN\",\"MESSAGE-OUT\",\"MESSAGE-IN\"};\n\tfor (ad=0x00;ad<0x80;ad++) {\n\t\tswitch (ad % 16) {\n\n\t\tcase 0:\n\t\t\tprintf (\"        %02x:\\t\",ad);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tprintf (\" :  \");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf (\" \");\n\t\t};\n\t\tprintf (\"%02x\", reg[ad]);\n\t\tif (ad % 16 == 15) printf (\"\\n\");\n\t};\n\tprintf (\"\\n\");\n\tprintf (\"        DSP  %08x %-20s  CMD %08x DSPS %08x %s\\n\",\n\t\tl(0x2c),sn(l(0x2c)),l(0x24),l(0x30), sn(l(0x30)));\n\tprintf (\"        TEMP %08x %-20s  DSA %08x\\n\",\n\t\tl(0x1c),sn(l(0x1c)),l(0x10)); \n\tprintf (\"\\n\");\n\tprintf (\"        Busstatus: \");\n\tif ((reg[0x0b]>>7)&1) printf (\" Req\");\n\tif ((reg[0x0b]>>6)&1) printf (\" Ack\");\n\tif ((reg[0x0b]>>5)&1) printf (\" Bsy\");\n\tif ((reg[0x0b]>>4)&1) printf (\" Sel\");\n\tif ((reg[0x0b]>>3)&1) printf (\" Atn\");\n\tprintf (\" %s\\n\", phasename[reg[0x0b]&7]);\n\f\n        printf (\"        Dmastatus: \");\n\tif ((reg[0x0c]>>7)&1) printf (\" FifoEmpty\");\n\tif ((reg[0x0c]>>6)&1) printf (\" MasterParityError\");\n\tif ((reg[0x0c]>>5)&1) printf (\" BusFault\");\n\tif ((reg[0x0c]>>4)&1) printf (\" Aborted\");\n\tif ((reg[0x0c]>>3)&1) printf (\" SingleStep\");\n\tif ((reg[0x0c]>>2)&1) printf (\" Interrupt\");\n\tif ((reg[0x0c]>>0)&1) printf (\" IllegalInstruction\");\n\tprintf (\"\\n\");\n\tprintf (\"        Intstatus: \");\n\tif ((reg[0x14]>>7)&1) printf (\" Abort\");\n\tif ((reg[0x14]>>6)&1) printf (\" SoftwareReset\");\n\tif ((reg[0x14]>>5)&1) printf (\" SignalProcess\");\n\tif ((reg[0x14]>>4)&1) printf (\" Semaphore\");\n\tif ((reg[0x14]>>3)&1) printf (\" Connected\");\n\tif ((reg[0x14]>>2)&1) printf (\" IntOnTheFly\");\n\tif ((reg[0x14]>>1)&1) printf (\" SCSI-Interrupt\");\n\tif ((reg[0x14]>>0)&1) printf (\" DMA-Interrupt\");\n\tprintf (\"\\n\");\n\tprintf (\"        ScsiIstat: \");\n\tif ((reg[0x42]>>7)&1) printf (\" PhaseMismatch\");\n\tif ((reg[0x42]>>6)&1) printf (\" Complete\");\n\tif ((reg[0x42]>>5)&1) printf (\" Selected\");\n\tif ((reg[0x42]>>4)&1) printf (\" Reselected\");\n\tif ((reg[0x42]>>3)&1) printf (\" GrossError\");\n\tif ((reg[0x42]>>2)&1) printf (\" UnexpectedDisconnect\");\n\tif ((reg[0x42]>>1)&1) printf (\" ScsiReset\");\n\tif ((reg[0x42]>>0)&1) printf (\" ParityError\");\n\tif ((reg[0x43]>>2)&1) printf (\" SelectionTimeout\");\n\tif ((reg[0x43]>>1)&1) printf (\" TimerExpired\");\n\tif ((reg[0x43]>>0)&1) printf (\" HandshakeTimeout\");\n\tprintf (\"\\n\");\n\tprintf (\"        ID=%d  DEST-ID=%d  RESEL-ID=%d\\n\", reg[4]&7, reg[6]&7, reg[0xa]&7);\n\tprintf (\"\\n\");\n}",
    "includes": [
      "#include <dev/pci/ncr.c>",
      "#include <kvm.h>",
      "#include <limits.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <nlist.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "l",
          "args": [
            "0x10"
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "dump_lcb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncrstat.c",
          "lines": "1209-1250",
          "snippet": "static void dump_lcb (u_long base)\n{\n\tstruct lcb l;\n\tstruct ccb c;\n\tu_long cp,cn;\n\n\tprintf (\"----------------------\\n\");\n\tprintf (\"struct lcb @ %08x:\\n\", base);\n\tprintf (\"----------------------\\n\");\n\n\tif (!KVM_READ (\n\t\tbase,\n\t\t&l,\n\t\tsizeof (struct lcb))) {\n\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\texit (1);\n\t};\n\tprintf   (\"     reqccbs: %d\\n\", l.reqccbs);\n\tprintf   (\"     actccbs: %d\\n\", l.actccbs);\n\tprintf   (\"     reqlink: %d\\n\", l.reqlink);\n\tprintf   (\"     actlink: %d\\n\", l.actlink);\n\tprintf   (\"     usetags: %d\\n\", l.usetags);\n\tdump_link (\"    jump_lcb\", &l.jump_lcb);\n\tdump_link (\"    call_tag\", &l.call_tag);\n\tdump_link (\"    jump_ccb\", &l.jump_ccb);\n\tprintf (\"\\n\");\n\tcp = (u_long) l.next_ccb;\n\tcn = 0;\n\twhile (cp) {\n\t\tcn++;\n\t\tprintf (\"ccb #%d:\\n\", cn);\n\t\tif (!KVM_READ (\n\t\t\tcp,\n\t\t\t&c,\n\t\t\tsizeof (struct ccb))) {\n\t\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\t\texit (1);\n\t\t};\n\t\tdump_ccb (&c, cp);\n\t\tcp= (u_long) c.next_ccb;\n\t};\n}",
          "includes": [
            "#include <dev/pci/ncr.c>",
            "#include <kvm.h>",
            "#include <limits.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <nlist.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void  exit();",
            "char\t*prog;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ncr.c>\n#include <kvm.h>\n#include <limits.h>\n#include <paths.h>\n#include <errno.h>\n#include <stdio.h>\n#include <nlist.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/file.h>\n\nextern void  exit();\nchar\t*prog;\n\nstatic void dump_lcb (u_long base)\n{\n\tstruct lcb l;\n\tstruct ccb c;\n\tu_long cp,cn;\n\n\tprintf (\"----------------------\\n\");\n\tprintf (\"struct lcb @ %08x:\\n\", base);\n\tprintf (\"----------------------\\n\");\n\n\tif (!KVM_READ (\n\t\tbase,\n\t\t&l,\n\t\tsizeof (struct lcb))) {\n\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\texit (1);\n\t};\n\tprintf   (\"     reqccbs: %d\\n\", l.reqccbs);\n\tprintf   (\"     actccbs: %d\\n\", l.actccbs);\n\tprintf   (\"     reqlink: %d\\n\", l.reqlink);\n\tprintf   (\"     actlink: %d\\n\", l.actlink);\n\tprintf   (\"     usetags: %d\\n\", l.usetags);\n\tdump_link (\"    jump_lcb\", &l.jump_lcb);\n\tdump_link (\"    call_tag\", &l.call_tag);\n\tdump_link (\"    jump_ccb\", &l.jump_ccb);\n\tprintf (\"\\n\");\n\tcp = (u_long) l.next_ccb;\n\tcn = 0;\n\twhile (cp) {\n\t\tcn++;\n\t\tprintf (\"ccb #%d:\\n\", cn);\n\t\tif (!KVM_READ (\n\t\t\tcp,\n\t\t\t&c,\n\t\t\tsizeof (struct ccb))) {\n\t\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\t\texit (1);\n\t\t};\n\t\tdump_ccb (&c, cp);\n\t\tcp= (u_long) c.next_ccb;\n\t};\n}"
        }
      },
      {
        "call_info": {
          "callee": "sn",
          "args": [
            "l(0x1c)"
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "sn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncrstat.c",
          "lines": "883-946",
          "snippet": "static const char * sn (u_long a)\n{\n\tstatic\tchar buffer[100];\n\n\tconst char * s=\"\";\n\tu_long d,m;\n\n\ta -= ncr.p_script;\n\tm = sizeof (struct script);\n\n\tif ((d=a-offsetof(struct script, start))<m) m=d, s=\"<start>\";\n\tif ((d=a-offsetof(struct script, start1))<m) m=d, s=\"<start1>\";\n\tif ((d=a-offsetof(struct script, startpos))<m) m=d, s=\"<startpos>\";\n\tif ((d=a-offsetof(struct script, tryloop))<m) m=d, s=\"<tryloop>\";\n\tif ((d=a-offsetof(struct script, trysel))<m) m=d, s=\"<trysel>\";\n\tif ((d=a-offsetof(struct script, skip))<m) m=d, s=\"<skip>\";\n\tif ((d=a-offsetof(struct script, skip2))<m) m=d, s=\"<skip2>\";\n\tif ((d=a-offsetof(struct script, idle))<m) m=d, s=\"<idle>\";\n\tif ((d=a-offsetof(struct script, select))<m) m=d, s=\"<select>\";\n\tif ((d=a-offsetof(struct script, prepare))<m) m=d, s=\"<prepare>\";\n\tif ((d=a-offsetof(struct script, loadpos))<m) m=d, s=\"<loadpos>\";\n\tif ((d=a-offsetof(struct script, prepare2))<m) m=d, s=\"<prepare2>\";\n\tif ((d=a-offsetof(struct script, setmsg))<m) m=d, s=\"<setmsg>\";\n\tif ((d=a-offsetof(struct script, clrack))<m) m=d, s=\"<clrack>\";\n\tif ((d=a-offsetof(struct script, dispatch))<m) m=d, s=\"<dispatch>\";\n\tif ((d=a-offsetof(struct script, checkatn))<m) m=d, s=\"<checkatn>\";\n\tif ((d=a-offsetof(struct script, command))<m) m=d, s=\"<command>\";\n\tif ((d=a-offsetof(struct script, status))<m) m=d, s=\"<status>\";\n\tif ((d=a-offsetof(struct script, msg_in))<m) m=d, s=\"<msg_in>\";\n\tif ((d=a-offsetof(struct script, msg_bad))<m) m=d, s=\"<msg_bad>\";\n\tif ((d=a-offsetof(struct script, msg_parity))<m) m=d, s=\"<msg_parity>\";\n\tif ((d=a-offsetof(struct script, msg_reject))<m) m=d, s=\"<msg_reject>\";\n\tif ((d=a-offsetof(struct script, msg_extended))<m) m=d, s=\"<msg_extended>\";\n\tif ((d=a-offsetof(struct script, msg_sdtr))<m) m=d, s=\"<msg_sdtr>\";\n\tif ((d=a-offsetof(struct script, complete))<m) m=d, s=\"<complete>\";\n\tif ((d=a-offsetof(struct script, cleanup))<m) m=d, s=\"<cleanup>\";\n\tif ((d=a-offsetof(struct script, cleanup0))<m) m=d, s=\"<cleanup>\";\n\tif ((d=a-offsetof(struct script, signal))<m) m=d, s=\"<signal>\";\n\tif ((d=a-offsetof(struct script, save_dp))<m) m=d, s=\"<save_dp>\";\n\tif ((d=a-offsetof(struct script, restore_dp))<m) m=d, s=\"<restore_dp>\";\n\tif ((d=a-offsetof(struct script, disconnect))<m) m=d, s=\"<disconnect>\";\n\tif ((d=a-offsetof(struct script, msg_out))<m) m=d, s=\"<msg_out>\";\n\tif ((d=a-offsetof(struct script, msg_out_done))<m) m=d, s=\"<msg_out_done>\";\n\tif ((d=a-offsetof(struct script, msg_out_abort))<m) m=d, s=\"<msg_out_abort>\";\n\tif ((d=a-offsetof(struct script, getcc))<m) m=d, s=\"<getcc>\";\n\tif ((d=a-offsetof(struct script, getcc1))<m) m=d, s=\"<getcc1>\";\n\tif ((d=a-offsetof(struct script, getcc2))<m) m=d, s=\"<getcc2>\";\n\tif ((d=a-offsetof(struct script, badgetcc))<m) m=d, s=\"<badgetcc>\";\n\tif ((d=a-offsetof(struct script, reselect))<m) m=d, s=\"<reselect>\";\n\tif ((d=a-offsetof(struct script, reselect2))<m) m=d, s=\"<reselect2>\";\n\tif ((d=a-offsetof(struct script, resel_tmp))<m) m=d, s=\"<resel_tmp>\";\n\tif ((d=a-offsetof(struct script, resel_lun))<m) m=d, s=\"<resel_lun>\";\n\tif ((d=a-offsetof(struct script, resel_tag))<m) m=d, s=\"<resel_tag>\";\n\tif ((d=a-offsetof(struct script, data_in))<m) m=d, s=\"<data_in>\";\n\tif ((d=a-offsetof(struct script, data_out))<m) m=d, s=\"<data_out>\";\n\tif ((d=a-offsetof(struct script, no_data))<m) m=d, s=\"<no_data>\";\n\tif ((d=a-offsetof(struct script, aborttag))<m) m=d, s=\"<aborttag>\";\n\tif ((d=a-offsetof(struct script, abort))<m) m=d, s=\"<abort>\";\n\n\tif (!*s) return s;\n\n\tsprintf (buffer, \"%s:%d%c\", s, m/4, 0);\n\treturn (buffer);\n}",
          "includes": [
            "#include <dev/pci/ncr.c>",
            "#include <kvm.h>",
            "#include <limits.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <nlist.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ncr.c>\n#include <kvm.h>\n#include <limits.h>\n#include <paths.h>\n#include <errno.h>\n#include <stdio.h>\n#include <nlist.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/file.h>\n\nstatic const char * sn (u_long a)\n{\n\tstatic\tchar buffer[100];\n\n\tconst char * s=\"\";\n\tu_long d,m;\n\n\ta -= ncr.p_script;\n\tm = sizeof (struct script);\n\n\tif ((d=a-offsetof(struct script, start))<m) m=d, s=\"<start>\";\n\tif ((d=a-offsetof(struct script, start1))<m) m=d, s=\"<start1>\";\n\tif ((d=a-offsetof(struct script, startpos))<m) m=d, s=\"<startpos>\";\n\tif ((d=a-offsetof(struct script, tryloop))<m) m=d, s=\"<tryloop>\";\n\tif ((d=a-offsetof(struct script, trysel))<m) m=d, s=\"<trysel>\";\n\tif ((d=a-offsetof(struct script, skip))<m) m=d, s=\"<skip>\";\n\tif ((d=a-offsetof(struct script, skip2))<m) m=d, s=\"<skip2>\";\n\tif ((d=a-offsetof(struct script, idle))<m) m=d, s=\"<idle>\";\n\tif ((d=a-offsetof(struct script, select))<m) m=d, s=\"<select>\";\n\tif ((d=a-offsetof(struct script, prepare))<m) m=d, s=\"<prepare>\";\n\tif ((d=a-offsetof(struct script, loadpos))<m) m=d, s=\"<loadpos>\";\n\tif ((d=a-offsetof(struct script, prepare2))<m) m=d, s=\"<prepare2>\";\n\tif ((d=a-offsetof(struct script, setmsg))<m) m=d, s=\"<setmsg>\";\n\tif ((d=a-offsetof(struct script, clrack))<m) m=d, s=\"<clrack>\";\n\tif ((d=a-offsetof(struct script, dispatch))<m) m=d, s=\"<dispatch>\";\n\tif ((d=a-offsetof(struct script, checkatn))<m) m=d, s=\"<checkatn>\";\n\tif ((d=a-offsetof(struct script, command))<m) m=d, s=\"<command>\";\n\tif ((d=a-offsetof(struct script, status))<m) m=d, s=\"<status>\";\n\tif ((d=a-offsetof(struct script, msg_in))<m) m=d, s=\"<msg_in>\";\n\tif ((d=a-offsetof(struct script, msg_bad))<m) m=d, s=\"<msg_bad>\";\n\tif ((d=a-offsetof(struct script, msg_parity))<m) m=d, s=\"<msg_parity>\";\n\tif ((d=a-offsetof(struct script, msg_reject))<m) m=d, s=\"<msg_reject>\";\n\tif ((d=a-offsetof(struct script, msg_extended))<m) m=d, s=\"<msg_extended>\";\n\tif ((d=a-offsetof(struct script, msg_sdtr))<m) m=d, s=\"<msg_sdtr>\";\n\tif ((d=a-offsetof(struct script, complete))<m) m=d, s=\"<complete>\";\n\tif ((d=a-offsetof(struct script, cleanup))<m) m=d, s=\"<cleanup>\";\n\tif ((d=a-offsetof(struct script, cleanup0))<m) m=d, s=\"<cleanup>\";\n\tif ((d=a-offsetof(struct script, signal))<m) m=d, s=\"<signal>\";\n\tif ((d=a-offsetof(struct script, save_dp))<m) m=d, s=\"<save_dp>\";\n\tif ((d=a-offsetof(struct script, restore_dp))<m) m=d, s=\"<restore_dp>\";\n\tif ((d=a-offsetof(struct script, disconnect))<m) m=d, s=\"<disconnect>\";\n\tif ((d=a-offsetof(struct script, msg_out))<m) m=d, s=\"<msg_out>\";\n\tif ((d=a-offsetof(struct script, msg_out_done))<m) m=d, s=\"<msg_out_done>\";\n\tif ((d=a-offsetof(struct script, msg_out_abort))<m) m=d, s=\"<msg_out_abort>\";\n\tif ((d=a-offsetof(struct script, getcc))<m) m=d, s=\"<getcc>\";\n\tif ((d=a-offsetof(struct script, getcc1))<m) m=d, s=\"<getcc1>\";\n\tif ((d=a-offsetof(struct script, getcc2))<m) m=d, s=\"<getcc2>\";\n\tif ((d=a-offsetof(struct script, badgetcc))<m) m=d, s=\"<badgetcc>\";\n\tif ((d=a-offsetof(struct script, reselect))<m) m=d, s=\"<reselect>\";\n\tif ((d=a-offsetof(struct script, reselect2))<m) m=d, s=\"<reselect2>\";\n\tif ((d=a-offsetof(struct script, resel_tmp))<m) m=d, s=\"<resel_tmp>\";\n\tif ((d=a-offsetof(struct script, resel_lun))<m) m=d, s=\"<resel_lun>\";\n\tif ((d=a-offsetof(struct script, resel_tag))<m) m=d, s=\"<resel_tag>\";\n\tif ((d=a-offsetof(struct script, data_in))<m) m=d, s=\"<data_in>\";\n\tif ((d=a-offsetof(struct script, data_out))<m) m=d, s=\"<data_out>\";\n\tif ((d=a-offsetof(struct script, no_data))<m) m=d, s=\"<no_data>\";\n\tif ((d=a-offsetof(struct script, aborttag))<m) m=d, s=\"<aborttag>\";\n\tif ((d=a-offsetof(struct script, abort))<m) m=d, s=\"<abort>\";\n\n\tif (!*s) return s;\n\n\tsprintf (buffer, \"%s:%d%c\", s, m/4, 0);\n\treturn (buffer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/ncr.c>\n#include <kvm.h>\n#include <limits.h>\n#include <paths.h>\n#include <errno.h>\n#include <stdio.h>\n#include <nlist.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/file.h>\n\nstatic void dump_reg(struct ncr_reg * rp)\n{\n\tu_char *reg = (u_char*) rp;\n#define l(i)  (reg[i]+(reg[i+1]<<8ul)+(reg[i+2]<<16ul)+(reg[i+3]<<24ul))\n\tint ad;\n\n\tchar*(phasename[8])={\"DATA-OUT\",\"DATA-IN\",\"COMMAND\",\"STATUS\",\n\t\t\t\t\"ILG-OUT\",\"ILG-IN\",\"MESSAGE-OUT\",\"MESSAGE-IN\"};\n\tfor (ad=0x00;ad<0x80;ad++) {\n\t\tswitch (ad % 16) {\n\n\t\tcase 0:\n\t\t\tprintf (\"        %02x:\\t\",ad);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tprintf (\" :  \");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf (\" \");\n\t\t};\n\t\tprintf (\"%02x\", reg[ad]);\n\t\tif (ad % 16 == 15) printf (\"\\n\");\n\t};\n\tprintf (\"\\n\");\n\tprintf (\"        DSP  %08x %-20s  CMD %08x DSPS %08x %s\\n\",\n\t\tl(0x2c),sn(l(0x2c)),l(0x24),l(0x30), sn(l(0x30)));\n\tprintf (\"        TEMP %08x %-20s  DSA %08x\\n\",\n\t\tl(0x1c),sn(l(0x1c)),l(0x10)); \n\tprintf (\"\\n\");\n\tprintf (\"        Busstatus: \");\n\tif ((reg[0x0b]>>7)&1) printf (\" Req\");\n\tif ((reg[0x0b]>>6)&1) printf (\" Ack\");\n\tif ((reg[0x0b]>>5)&1) printf (\" Bsy\");\n\tif ((reg[0x0b]>>4)&1) printf (\" Sel\");\n\tif ((reg[0x0b]>>3)&1) printf (\" Atn\");\n\tprintf (\" %s\\n\", phasename[reg[0x0b]&7]);\n\f\n        printf (\"        Dmastatus: \");\n\tif ((reg[0x0c]>>7)&1) printf (\" FifoEmpty\");\n\tif ((reg[0x0c]>>6)&1) printf (\" MasterParityError\");\n\tif ((reg[0x0c]>>5)&1) printf (\" BusFault\");\n\tif ((reg[0x0c]>>4)&1) printf (\" Aborted\");\n\tif ((reg[0x0c]>>3)&1) printf (\" SingleStep\");\n\tif ((reg[0x0c]>>2)&1) printf (\" Interrupt\");\n\tif ((reg[0x0c]>>0)&1) printf (\" IllegalInstruction\");\n\tprintf (\"\\n\");\n\tprintf (\"        Intstatus: \");\n\tif ((reg[0x14]>>7)&1) printf (\" Abort\");\n\tif ((reg[0x14]>>6)&1) printf (\" SoftwareReset\");\n\tif ((reg[0x14]>>5)&1) printf (\" SignalProcess\");\n\tif ((reg[0x14]>>4)&1) printf (\" Semaphore\");\n\tif ((reg[0x14]>>3)&1) printf (\" Connected\");\n\tif ((reg[0x14]>>2)&1) printf (\" IntOnTheFly\");\n\tif ((reg[0x14]>>1)&1) printf (\" SCSI-Interrupt\");\n\tif ((reg[0x14]>>0)&1) printf (\" DMA-Interrupt\");\n\tprintf (\"\\n\");\n\tprintf (\"        ScsiIstat: \");\n\tif ((reg[0x42]>>7)&1) printf (\" PhaseMismatch\");\n\tif ((reg[0x42]>>6)&1) printf (\" Complete\");\n\tif ((reg[0x42]>>5)&1) printf (\" Selected\");\n\tif ((reg[0x42]>>4)&1) printf (\" Reselected\");\n\tif ((reg[0x42]>>3)&1) printf (\" GrossError\");\n\tif ((reg[0x42]>>2)&1) printf (\" UnexpectedDisconnect\");\n\tif ((reg[0x42]>>1)&1) printf (\" ScsiReset\");\n\tif ((reg[0x42]>>0)&1) printf (\" ParityError\");\n\tif ((reg[0x43]>>2)&1) printf (\" SelectionTimeout\");\n\tif ((reg[0x43]>>1)&1) printf (\" TimerExpired\");\n\tif ((reg[0x43]>>0)&1) printf (\" HandshakeTimeout\");\n\tprintf (\"\\n\");\n\tprintf (\"        ID=%d  DEST-ID=%d  RESEL-ID=%d\\n\", reg[4]&7, reg[6]&7, reg[0xa]&7);\n\tprintf (\"\\n\");\n}"
  },
  {
    "function_name": "dump_profile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncrstat.c",
    "lines": "1017-1030",
    "snippet": "void dump_profile (const char* name, struct profile * p)\n{\n\tprintf (\"%s: %10d transfers.\\n\"        ,name,p->num_trans);\n\tprintf (\"%s: %10d bytes transferred.\\n\",name,p->num_bytes);\n\tprintf (\"%s: %10d disconnects.\\n\"      ,name,p->num_disc);\n\tprintf (\"%s: %10d short transfers.\\n\"  ,name,p->num_break);\n\tprintf (\"%s: %10d interrupts.\\n\"       ,name,p->num_int);\n\tprintf (\"%s: %10d on the fly ints.\\n\"  ,name,p->num_fly);\n\tprintf (\"%s: %10d ms setup time.\\n\"    ,name,p->ms_setup);\n\tprintf (\"%s: %10d ms data transfer.\\n\" ,name,p->ms_data);\n\tprintf (\"%s: %10d ms disconnected.\\n\"  ,name,p->ms_disc);\n\tprintf (\"%s: %10d ms postprocessing.\\n\",name,p->ms_post);\n\tprintf (\"\\n\");\n}",
    "includes": [
      "#include <dev/pci/ncr.c>",
      "#include <kvm.h>",
      "#include <limits.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <nlist.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/ncr.c>\n#include <kvm.h>\n#include <limits.h>\n#include <paths.h>\n#include <errno.h>\n#include <stdio.h>\n#include <nlist.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/file.h>\n\nvoid dump_profile (const char* name, struct profile * p)\n{\n\tprintf (\"%s: %10d transfers.\\n\"        ,name,p->num_trans);\n\tprintf (\"%s: %10d bytes transferred.\\n\",name,p->num_bytes);\n\tprintf (\"%s: %10d disconnects.\\n\"      ,name,p->num_disc);\n\tprintf (\"%s: %10d short transfers.\\n\"  ,name,p->num_break);\n\tprintf (\"%s: %10d interrupts.\\n\"       ,name,p->num_int);\n\tprintf (\"%s: %10d on the fly ints.\\n\"  ,name,p->num_fly);\n\tprintf (\"%s: %10d ms setup time.\\n\"    ,name,p->ms_setup);\n\tprintf (\"%s: %10d ms data transfer.\\n\" ,name,p->ms_data);\n\tprintf (\"%s: %10d ms disconnected.\\n\"  ,name,p->ms_disc);\n\tprintf (\"%s: %10d ms postprocessing.\\n\",name,p->ms_post);\n\tprintf (\"\\n\");\n}"
  },
  {
    "function_name": "dump_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncrstat.c",
    "lines": "982-986",
    "snippet": "void dump_link (const char* name, struct link * link)\n{\n\tprintf (\"%s: cmd=%08x pa=%08x %s\\n\",\n\tname, link->l_cmd, link->l_paddr, sn(link->l_paddr));\n}",
    "includes": [
      "#include <dev/pci/ncr.c>",
      "#include <kvm.h>",
      "#include <limits.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <nlist.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: cmd=%08x pa=%08x %s\\n\"",
            "name",
            "link->l_cmd",
            "link->l_paddr",
            "sn(link->l_paddr)"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sn",
          "args": [
            "link->l_paddr"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "sn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncrstat.c",
          "lines": "883-946",
          "snippet": "static const char * sn (u_long a)\n{\n\tstatic\tchar buffer[100];\n\n\tconst char * s=\"\";\n\tu_long d,m;\n\n\ta -= ncr.p_script;\n\tm = sizeof (struct script);\n\n\tif ((d=a-offsetof(struct script, start))<m) m=d, s=\"<start>\";\n\tif ((d=a-offsetof(struct script, start1))<m) m=d, s=\"<start1>\";\n\tif ((d=a-offsetof(struct script, startpos))<m) m=d, s=\"<startpos>\";\n\tif ((d=a-offsetof(struct script, tryloop))<m) m=d, s=\"<tryloop>\";\n\tif ((d=a-offsetof(struct script, trysel))<m) m=d, s=\"<trysel>\";\n\tif ((d=a-offsetof(struct script, skip))<m) m=d, s=\"<skip>\";\n\tif ((d=a-offsetof(struct script, skip2))<m) m=d, s=\"<skip2>\";\n\tif ((d=a-offsetof(struct script, idle))<m) m=d, s=\"<idle>\";\n\tif ((d=a-offsetof(struct script, select))<m) m=d, s=\"<select>\";\n\tif ((d=a-offsetof(struct script, prepare))<m) m=d, s=\"<prepare>\";\n\tif ((d=a-offsetof(struct script, loadpos))<m) m=d, s=\"<loadpos>\";\n\tif ((d=a-offsetof(struct script, prepare2))<m) m=d, s=\"<prepare2>\";\n\tif ((d=a-offsetof(struct script, setmsg))<m) m=d, s=\"<setmsg>\";\n\tif ((d=a-offsetof(struct script, clrack))<m) m=d, s=\"<clrack>\";\n\tif ((d=a-offsetof(struct script, dispatch))<m) m=d, s=\"<dispatch>\";\n\tif ((d=a-offsetof(struct script, checkatn))<m) m=d, s=\"<checkatn>\";\n\tif ((d=a-offsetof(struct script, command))<m) m=d, s=\"<command>\";\n\tif ((d=a-offsetof(struct script, status))<m) m=d, s=\"<status>\";\n\tif ((d=a-offsetof(struct script, msg_in))<m) m=d, s=\"<msg_in>\";\n\tif ((d=a-offsetof(struct script, msg_bad))<m) m=d, s=\"<msg_bad>\";\n\tif ((d=a-offsetof(struct script, msg_parity))<m) m=d, s=\"<msg_parity>\";\n\tif ((d=a-offsetof(struct script, msg_reject))<m) m=d, s=\"<msg_reject>\";\n\tif ((d=a-offsetof(struct script, msg_extended))<m) m=d, s=\"<msg_extended>\";\n\tif ((d=a-offsetof(struct script, msg_sdtr))<m) m=d, s=\"<msg_sdtr>\";\n\tif ((d=a-offsetof(struct script, complete))<m) m=d, s=\"<complete>\";\n\tif ((d=a-offsetof(struct script, cleanup))<m) m=d, s=\"<cleanup>\";\n\tif ((d=a-offsetof(struct script, cleanup0))<m) m=d, s=\"<cleanup>\";\n\tif ((d=a-offsetof(struct script, signal))<m) m=d, s=\"<signal>\";\n\tif ((d=a-offsetof(struct script, save_dp))<m) m=d, s=\"<save_dp>\";\n\tif ((d=a-offsetof(struct script, restore_dp))<m) m=d, s=\"<restore_dp>\";\n\tif ((d=a-offsetof(struct script, disconnect))<m) m=d, s=\"<disconnect>\";\n\tif ((d=a-offsetof(struct script, msg_out))<m) m=d, s=\"<msg_out>\";\n\tif ((d=a-offsetof(struct script, msg_out_done))<m) m=d, s=\"<msg_out_done>\";\n\tif ((d=a-offsetof(struct script, msg_out_abort))<m) m=d, s=\"<msg_out_abort>\";\n\tif ((d=a-offsetof(struct script, getcc))<m) m=d, s=\"<getcc>\";\n\tif ((d=a-offsetof(struct script, getcc1))<m) m=d, s=\"<getcc1>\";\n\tif ((d=a-offsetof(struct script, getcc2))<m) m=d, s=\"<getcc2>\";\n\tif ((d=a-offsetof(struct script, badgetcc))<m) m=d, s=\"<badgetcc>\";\n\tif ((d=a-offsetof(struct script, reselect))<m) m=d, s=\"<reselect>\";\n\tif ((d=a-offsetof(struct script, reselect2))<m) m=d, s=\"<reselect2>\";\n\tif ((d=a-offsetof(struct script, resel_tmp))<m) m=d, s=\"<resel_tmp>\";\n\tif ((d=a-offsetof(struct script, resel_lun))<m) m=d, s=\"<resel_lun>\";\n\tif ((d=a-offsetof(struct script, resel_tag))<m) m=d, s=\"<resel_tag>\";\n\tif ((d=a-offsetof(struct script, data_in))<m) m=d, s=\"<data_in>\";\n\tif ((d=a-offsetof(struct script, data_out))<m) m=d, s=\"<data_out>\";\n\tif ((d=a-offsetof(struct script, no_data))<m) m=d, s=\"<no_data>\";\n\tif ((d=a-offsetof(struct script, aborttag))<m) m=d, s=\"<aborttag>\";\n\tif ((d=a-offsetof(struct script, abort))<m) m=d, s=\"<abort>\";\n\n\tif (!*s) return s;\n\n\tsprintf (buffer, \"%s:%d%c\", s, m/4, 0);\n\treturn (buffer);\n}",
          "includes": [
            "#include <dev/pci/ncr.c>",
            "#include <kvm.h>",
            "#include <limits.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <nlist.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ncr.c>\n#include <kvm.h>\n#include <limits.h>\n#include <paths.h>\n#include <errno.h>\n#include <stdio.h>\n#include <nlist.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/file.h>\n\nstatic const char * sn (u_long a)\n{\n\tstatic\tchar buffer[100];\n\n\tconst char * s=\"\";\n\tu_long d,m;\n\n\ta -= ncr.p_script;\n\tm = sizeof (struct script);\n\n\tif ((d=a-offsetof(struct script, start))<m) m=d, s=\"<start>\";\n\tif ((d=a-offsetof(struct script, start1))<m) m=d, s=\"<start1>\";\n\tif ((d=a-offsetof(struct script, startpos))<m) m=d, s=\"<startpos>\";\n\tif ((d=a-offsetof(struct script, tryloop))<m) m=d, s=\"<tryloop>\";\n\tif ((d=a-offsetof(struct script, trysel))<m) m=d, s=\"<trysel>\";\n\tif ((d=a-offsetof(struct script, skip))<m) m=d, s=\"<skip>\";\n\tif ((d=a-offsetof(struct script, skip2))<m) m=d, s=\"<skip2>\";\n\tif ((d=a-offsetof(struct script, idle))<m) m=d, s=\"<idle>\";\n\tif ((d=a-offsetof(struct script, select))<m) m=d, s=\"<select>\";\n\tif ((d=a-offsetof(struct script, prepare))<m) m=d, s=\"<prepare>\";\n\tif ((d=a-offsetof(struct script, loadpos))<m) m=d, s=\"<loadpos>\";\n\tif ((d=a-offsetof(struct script, prepare2))<m) m=d, s=\"<prepare2>\";\n\tif ((d=a-offsetof(struct script, setmsg))<m) m=d, s=\"<setmsg>\";\n\tif ((d=a-offsetof(struct script, clrack))<m) m=d, s=\"<clrack>\";\n\tif ((d=a-offsetof(struct script, dispatch))<m) m=d, s=\"<dispatch>\";\n\tif ((d=a-offsetof(struct script, checkatn))<m) m=d, s=\"<checkatn>\";\n\tif ((d=a-offsetof(struct script, command))<m) m=d, s=\"<command>\";\n\tif ((d=a-offsetof(struct script, status))<m) m=d, s=\"<status>\";\n\tif ((d=a-offsetof(struct script, msg_in))<m) m=d, s=\"<msg_in>\";\n\tif ((d=a-offsetof(struct script, msg_bad))<m) m=d, s=\"<msg_bad>\";\n\tif ((d=a-offsetof(struct script, msg_parity))<m) m=d, s=\"<msg_parity>\";\n\tif ((d=a-offsetof(struct script, msg_reject))<m) m=d, s=\"<msg_reject>\";\n\tif ((d=a-offsetof(struct script, msg_extended))<m) m=d, s=\"<msg_extended>\";\n\tif ((d=a-offsetof(struct script, msg_sdtr))<m) m=d, s=\"<msg_sdtr>\";\n\tif ((d=a-offsetof(struct script, complete))<m) m=d, s=\"<complete>\";\n\tif ((d=a-offsetof(struct script, cleanup))<m) m=d, s=\"<cleanup>\";\n\tif ((d=a-offsetof(struct script, cleanup0))<m) m=d, s=\"<cleanup>\";\n\tif ((d=a-offsetof(struct script, signal))<m) m=d, s=\"<signal>\";\n\tif ((d=a-offsetof(struct script, save_dp))<m) m=d, s=\"<save_dp>\";\n\tif ((d=a-offsetof(struct script, restore_dp))<m) m=d, s=\"<restore_dp>\";\n\tif ((d=a-offsetof(struct script, disconnect))<m) m=d, s=\"<disconnect>\";\n\tif ((d=a-offsetof(struct script, msg_out))<m) m=d, s=\"<msg_out>\";\n\tif ((d=a-offsetof(struct script, msg_out_done))<m) m=d, s=\"<msg_out_done>\";\n\tif ((d=a-offsetof(struct script, msg_out_abort))<m) m=d, s=\"<msg_out_abort>\";\n\tif ((d=a-offsetof(struct script, getcc))<m) m=d, s=\"<getcc>\";\n\tif ((d=a-offsetof(struct script, getcc1))<m) m=d, s=\"<getcc1>\";\n\tif ((d=a-offsetof(struct script, getcc2))<m) m=d, s=\"<getcc2>\";\n\tif ((d=a-offsetof(struct script, badgetcc))<m) m=d, s=\"<badgetcc>\";\n\tif ((d=a-offsetof(struct script, reselect))<m) m=d, s=\"<reselect>\";\n\tif ((d=a-offsetof(struct script, reselect2))<m) m=d, s=\"<reselect2>\";\n\tif ((d=a-offsetof(struct script, resel_tmp))<m) m=d, s=\"<resel_tmp>\";\n\tif ((d=a-offsetof(struct script, resel_lun))<m) m=d, s=\"<resel_lun>\";\n\tif ((d=a-offsetof(struct script, resel_tag))<m) m=d, s=\"<resel_tag>\";\n\tif ((d=a-offsetof(struct script, data_in))<m) m=d, s=\"<data_in>\";\n\tif ((d=a-offsetof(struct script, data_out))<m) m=d, s=\"<data_out>\";\n\tif ((d=a-offsetof(struct script, no_data))<m) m=d, s=\"<no_data>\";\n\tif ((d=a-offsetof(struct script, aborttag))<m) m=d, s=\"<aborttag>\";\n\tif ((d=a-offsetof(struct script, abort))<m) m=d, s=\"<abort>\";\n\n\tif (!*s) return s;\n\n\tsprintf (buffer, \"%s:%d%c\", s, m/4, 0);\n\treturn (buffer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/ncr.c>\n#include <kvm.h>\n#include <limits.h>\n#include <paths.h>\n#include <errno.h>\n#include <stdio.h>\n#include <nlist.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/file.h>\n\nvoid dump_link (const char* name, struct link * link)\n{\n\tprintf (\"%s: cmd=%08x pa=%08x %s\\n\",\n\tname, link->l_cmd, link->l_paddr, sn(link->l_paddr));\n}"
  },
  {
    "function_name": "dump_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncrstat.c",
    "lines": "973-980",
    "snippet": "void dump_table (const char * str, struct scr_tblmove * p, int l)\n{\n\tint i;\n\tfor (i=0;l>0;i++,p++,l--) if (p->size) {\n\tprintf (\"    %s[%d]: %5d @ 0x%08x\\n\",\n\t\tstr, i, p->size, p->addr);\n\t};\n}",
    "includes": [
      "#include <dev/pci/ncr.c>",
      "#include <kvm.h>",
      "#include <limits.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <nlist.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"    %s[%d]: %5d @ 0x%08x\\n\"",
            "str",
            "i",
            "p->size",
            "p->addr"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/ncr.c>\n#include <kvm.h>\n#include <limits.h>\n#include <paths.h>\n#include <errno.h>\n#include <stdio.h>\n#include <nlist.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/file.h>\n\nvoid dump_table (const char * str, struct scr_tblmove * p, int l)\n{\n\tint i;\n\tfor (i=0;l>0;i++,p++,l--) if (p->size) {\n\tprintf (\"    %s[%d]: %5d @ 0x%08x\\n\",\n\t\tstr, i, p->size, p->addr);\n\t};\n}"
  },
  {
    "function_name": "printm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncrstat.c",
    "lines": "957-971",
    "snippet": "static void printm (u_char * msg, int len)\n{\n\tu_char l;\n\tdo {\n\t\tif (*msg==M_EXTENDED)\n\t\t\tl=msg[1]+2;\n\t\telse if ((*msg & 0xf0)==0x20)\n\t\t\tl=2;\n\t\telse l=1;\n\t\tlen-=l;\n\n\t\tprintf (\" %x\",*msg++);\n\t\twhile (--l>0) printf (\"-%x\",*msg++);\n\t} while (len>0);\n}",
    "includes": [
      "#include <dev/pci/ncr.c>",
      "#include <kvm.h>",
      "#include <limits.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <nlist.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"-%x\"",
            "*msg++"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/ncr.c>\n#include <kvm.h>\n#include <limits.h>\n#include <paths.h>\n#include <errno.h>\n#include <stdio.h>\n#include <nlist.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/file.h>\n\nstatic void printm (u_char * msg, int len)\n{\n\tu_char l;\n\tdo {\n\t\tif (*msg==M_EXTENDED)\n\t\t\tl=msg[1]+2;\n\t\telse if ((*msg & 0xf0)==0x20)\n\t\t\tl=2;\n\t\telse l=1;\n\t\tlen-=l;\n\n\t\tprintf (\" %x\",*msg++);\n\t\twhile (--l>0) printf (\"-%x\",*msg++);\n\t} while (len>0);\n}"
  },
  {
    "function_name": "sn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncrstat.c",
    "lines": "883-946",
    "snippet": "static const char * sn (u_long a)\n{\n\tstatic\tchar buffer[100];\n\n\tconst char * s=\"\";\n\tu_long d,m;\n\n\ta -= ncr.p_script;\n\tm = sizeof (struct script);\n\n\tif ((d=a-offsetof(struct script, start))<m) m=d, s=\"<start>\";\n\tif ((d=a-offsetof(struct script, start1))<m) m=d, s=\"<start1>\";\n\tif ((d=a-offsetof(struct script, startpos))<m) m=d, s=\"<startpos>\";\n\tif ((d=a-offsetof(struct script, tryloop))<m) m=d, s=\"<tryloop>\";\n\tif ((d=a-offsetof(struct script, trysel))<m) m=d, s=\"<trysel>\";\n\tif ((d=a-offsetof(struct script, skip))<m) m=d, s=\"<skip>\";\n\tif ((d=a-offsetof(struct script, skip2))<m) m=d, s=\"<skip2>\";\n\tif ((d=a-offsetof(struct script, idle))<m) m=d, s=\"<idle>\";\n\tif ((d=a-offsetof(struct script, select))<m) m=d, s=\"<select>\";\n\tif ((d=a-offsetof(struct script, prepare))<m) m=d, s=\"<prepare>\";\n\tif ((d=a-offsetof(struct script, loadpos))<m) m=d, s=\"<loadpos>\";\n\tif ((d=a-offsetof(struct script, prepare2))<m) m=d, s=\"<prepare2>\";\n\tif ((d=a-offsetof(struct script, setmsg))<m) m=d, s=\"<setmsg>\";\n\tif ((d=a-offsetof(struct script, clrack))<m) m=d, s=\"<clrack>\";\n\tif ((d=a-offsetof(struct script, dispatch))<m) m=d, s=\"<dispatch>\";\n\tif ((d=a-offsetof(struct script, checkatn))<m) m=d, s=\"<checkatn>\";\n\tif ((d=a-offsetof(struct script, command))<m) m=d, s=\"<command>\";\n\tif ((d=a-offsetof(struct script, status))<m) m=d, s=\"<status>\";\n\tif ((d=a-offsetof(struct script, msg_in))<m) m=d, s=\"<msg_in>\";\n\tif ((d=a-offsetof(struct script, msg_bad))<m) m=d, s=\"<msg_bad>\";\n\tif ((d=a-offsetof(struct script, msg_parity))<m) m=d, s=\"<msg_parity>\";\n\tif ((d=a-offsetof(struct script, msg_reject))<m) m=d, s=\"<msg_reject>\";\n\tif ((d=a-offsetof(struct script, msg_extended))<m) m=d, s=\"<msg_extended>\";\n\tif ((d=a-offsetof(struct script, msg_sdtr))<m) m=d, s=\"<msg_sdtr>\";\n\tif ((d=a-offsetof(struct script, complete))<m) m=d, s=\"<complete>\";\n\tif ((d=a-offsetof(struct script, cleanup))<m) m=d, s=\"<cleanup>\";\n\tif ((d=a-offsetof(struct script, cleanup0))<m) m=d, s=\"<cleanup>\";\n\tif ((d=a-offsetof(struct script, signal))<m) m=d, s=\"<signal>\";\n\tif ((d=a-offsetof(struct script, save_dp))<m) m=d, s=\"<save_dp>\";\n\tif ((d=a-offsetof(struct script, restore_dp))<m) m=d, s=\"<restore_dp>\";\n\tif ((d=a-offsetof(struct script, disconnect))<m) m=d, s=\"<disconnect>\";\n\tif ((d=a-offsetof(struct script, msg_out))<m) m=d, s=\"<msg_out>\";\n\tif ((d=a-offsetof(struct script, msg_out_done))<m) m=d, s=\"<msg_out_done>\";\n\tif ((d=a-offsetof(struct script, msg_out_abort))<m) m=d, s=\"<msg_out_abort>\";\n\tif ((d=a-offsetof(struct script, getcc))<m) m=d, s=\"<getcc>\";\n\tif ((d=a-offsetof(struct script, getcc1))<m) m=d, s=\"<getcc1>\";\n\tif ((d=a-offsetof(struct script, getcc2))<m) m=d, s=\"<getcc2>\";\n\tif ((d=a-offsetof(struct script, badgetcc))<m) m=d, s=\"<badgetcc>\";\n\tif ((d=a-offsetof(struct script, reselect))<m) m=d, s=\"<reselect>\";\n\tif ((d=a-offsetof(struct script, reselect2))<m) m=d, s=\"<reselect2>\";\n\tif ((d=a-offsetof(struct script, resel_tmp))<m) m=d, s=\"<resel_tmp>\";\n\tif ((d=a-offsetof(struct script, resel_lun))<m) m=d, s=\"<resel_lun>\";\n\tif ((d=a-offsetof(struct script, resel_tag))<m) m=d, s=\"<resel_tag>\";\n\tif ((d=a-offsetof(struct script, data_in))<m) m=d, s=\"<data_in>\";\n\tif ((d=a-offsetof(struct script, data_out))<m) m=d, s=\"<data_out>\";\n\tif ((d=a-offsetof(struct script, no_data))<m) m=d, s=\"<no_data>\";\n\tif ((d=a-offsetof(struct script, aborttag))<m) m=d, s=\"<aborttag>\";\n\tif ((d=a-offsetof(struct script, abort))<m) m=d, s=\"<abort>\";\n\n\tif (!*s) return s;\n\n\tsprintf (buffer, \"%s:%d%c\", s, m/4, 0);\n\treturn (buffer);\n}",
    "includes": [
      "#include <dev/pci/ncr.c>",
      "#include <kvm.h>",
      "#include <limits.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <nlist.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buffer",
            "\"%s:%d%c\"",
            "s",
            "m/4",
            "0"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/ncr.c>\n#include <kvm.h>\n#include <limits.h>\n#include <paths.h>\n#include <errno.h>\n#include <stdio.h>\n#include <nlist.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/file.h>\n\nstatic const char * sn (u_long a)\n{\n\tstatic\tchar buffer[100];\n\n\tconst char * s=\"\";\n\tu_long d,m;\n\n\ta -= ncr.p_script;\n\tm = sizeof (struct script);\n\n\tif ((d=a-offsetof(struct script, start))<m) m=d, s=\"<start>\";\n\tif ((d=a-offsetof(struct script, start1))<m) m=d, s=\"<start1>\";\n\tif ((d=a-offsetof(struct script, startpos))<m) m=d, s=\"<startpos>\";\n\tif ((d=a-offsetof(struct script, tryloop))<m) m=d, s=\"<tryloop>\";\n\tif ((d=a-offsetof(struct script, trysel))<m) m=d, s=\"<trysel>\";\n\tif ((d=a-offsetof(struct script, skip))<m) m=d, s=\"<skip>\";\n\tif ((d=a-offsetof(struct script, skip2))<m) m=d, s=\"<skip2>\";\n\tif ((d=a-offsetof(struct script, idle))<m) m=d, s=\"<idle>\";\n\tif ((d=a-offsetof(struct script, select))<m) m=d, s=\"<select>\";\n\tif ((d=a-offsetof(struct script, prepare))<m) m=d, s=\"<prepare>\";\n\tif ((d=a-offsetof(struct script, loadpos))<m) m=d, s=\"<loadpos>\";\n\tif ((d=a-offsetof(struct script, prepare2))<m) m=d, s=\"<prepare2>\";\n\tif ((d=a-offsetof(struct script, setmsg))<m) m=d, s=\"<setmsg>\";\n\tif ((d=a-offsetof(struct script, clrack))<m) m=d, s=\"<clrack>\";\n\tif ((d=a-offsetof(struct script, dispatch))<m) m=d, s=\"<dispatch>\";\n\tif ((d=a-offsetof(struct script, checkatn))<m) m=d, s=\"<checkatn>\";\n\tif ((d=a-offsetof(struct script, command))<m) m=d, s=\"<command>\";\n\tif ((d=a-offsetof(struct script, status))<m) m=d, s=\"<status>\";\n\tif ((d=a-offsetof(struct script, msg_in))<m) m=d, s=\"<msg_in>\";\n\tif ((d=a-offsetof(struct script, msg_bad))<m) m=d, s=\"<msg_bad>\";\n\tif ((d=a-offsetof(struct script, msg_parity))<m) m=d, s=\"<msg_parity>\";\n\tif ((d=a-offsetof(struct script, msg_reject))<m) m=d, s=\"<msg_reject>\";\n\tif ((d=a-offsetof(struct script, msg_extended))<m) m=d, s=\"<msg_extended>\";\n\tif ((d=a-offsetof(struct script, msg_sdtr))<m) m=d, s=\"<msg_sdtr>\";\n\tif ((d=a-offsetof(struct script, complete))<m) m=d, s=\"<complete>\";\n\tif ((d=a-offsetof(struct script, cleanup))<m) m=d, s=\"<cleanup>\";\n\tif ((d=a-offsetof(struct script, cleanup0))<m) m=d, s=\"<cleanup>\";\n\tif ((d=a-offsetof(struct script, signal))<m) m=d, s=\"<signal>\";\n\tif ((d=a-offsetof(struct script, save_dp))<m) m=d, s=\"<save_dp>\";\n\tif ((d=a-offsetof(struct script, restore_dp))<m) m=d, s=\"<restore_dp>\";\n\tif ((d=a-offsetof(struct script, disconnect))<m) m=d, s=\"<disconnect>\";\n\tif ((d=a-offsetof(struct script, msg_out))<m) m=d, s=\"<msg_out>\";\n\tif ((d=a-offsetof(struct script, msg_out_done))<m) m=d, s=\"<msg_out_done>\";\n\tif ((d=a-offsetof(struct script, msg_out_abort))<m) m=d, s=\"<msg_out_abort>\";\n\tif ((d=a-offsetof(struct script, getcc))<m) m=d, s=\"<getcc>\";\n\tif ((d=a-offsetof(struct script, getcc1))<m) m=d, s=\"<getcc1>\";\n\tif ((d=a-offsetof(struct script, getcc2))<m) m=d, s=\"<getcc2>\";\n\tif ((d=a-offsetof(struct script, badgetcc))<m) m=d, s=\"<badgetcc>\";\n\tif ((d=a-offsetof(struct script, reselect))<m) m=d, s=\"<reselect>\";\n\tif ((d=a-offsetof(struct script, reselect2))<m) m=d, s=\"<reselect2>\";\n\tif ((d=a-offsetof(struct script, resel_tmp))<m) m=d, s=\"<resel_tmp>\";\n\tif ((d=a-offsetof(struct script, resel_lun))<m) m=d, s=\"<resel_lun>\";\n\tif ((d=a-offsetof(struct script, resel_tag))<m) m=d, s=\"<resel_tag>\";\n\tif ((d=a-offsetof(struct script, data_in))<m) m=d, s=\"<data_in>\";\n\tif ((d=a-offsetof(struct script, data_out))<m) m=d, s=\"<data_out>\";\n\tif ((d=a-offsetof(struct script, no_data))<m) m=d, s=\"<no_data>\";\n\tif ((d=a-offsetof(struct script, aborttag))<m) m=d, s=\"<aborttag>\";\n\tif ((d=a-offsetof(struct script, abort))<m) m=d, s=\"<abort>\";\n\n\tif (!*s) return s;\n\n\tsprintf (buffer, \"%s:%d%c\", s, m/4, 0);\n\treturn (buffer);\n}"
  },
  {
    "function_name": "do_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncrstat.c",
    "lines": "680-808",
    "snippet": "void do_set (char * arg)\n{\n\tstruct usrcmd user;\n\tu_long addr;\n\tint i;\n\n\topen_kvm(O_RDWR);\n\taddr = ncr_base + offsetof (struct ncb, user);\n\n\tfor (i=3; i; i--) {\n\t\tif (!KVM_READ (\n\t\t\t(addr),\n\t\t\t&user,\n\t\t\tsizeof (user))) {\n\t\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\t\texit (1);\n\t\t}\n\t\tif (!user.cmd) break;\n\t\tsleep (1);\n\t}\n\tif (user.cmd) {\n\t\tfprintf (stderr, \"%s: ncb.user busy.\\n\", prog);\n\t\texit (1);\n\t};\n\n\tuser.target = target_mask;\n\tuser.lun    = lun_mask;\n\tuser.data   = 0;\n\tuser.cmd    = 0;\n\n\tif (!strcmp(arg, \"?\")) { printf (\n\"async:         disable synchronous transfers.\\n\"\n\"sync=value:    set the maximal synchronous transfer rate (MHz).\\n\"\n\"fast:          set FAST SCSI-2.\\n\"\n\"\\n\"\n\"wide=value:    set the bus width (0=8bit 1=16bit).\\n\"\n\"\\n\"\n\"tags=value:    use this number of tags.\\n\"\n\"orderedtag:    use ordered tags only.\\n\"\n\"simpletag:     use simple tags only.\\n\"\n\"orderedwrite:  use simple tags for read, else ordered tags.\\n\"\n\"\\n\"\n\"debug=value:   set debug mode.\\n\"\n\"\\n\");\n\t\treturn;\n\t};\n\f\n\tif (!strcmp(arg, \"async\")) {\n\t\tuser.data = 255;\n\t\tuser.cmd  = UC_SETSYNC;\n\t};\n\n\tif (!strcmp(arg, \"fast\")) {\n\t\tuser.data = 25;\n\t\tuser.cmd  = UC_SETSYNC;\n\t};\n\n\tif (!strncmp(arg, \"sync=\", 5)) {\n\t\tfloat f = strtod (arg+5, NULL);\n\t\tif (f>=4.0 && f<=10.0) {\n\t\t\tuser.data = 250.0 / f;\n\t\t\tuser.cmd  = UC_SETSYNC;\n\t\t};\n\t};\n\n\tif (!strncmp(arg, \"wide=\", 5)) {\n\t\tu_char t = strtoul (arg+5, (char**)0, 0);\n\t\tif (t<=1) {\n\t\t\tuser.data = t;\n\t\t\tuser.cmd  = UC_SETWIDE;\n\t\t};\n\t};\n\n\tif (!strncmp(arg, \"tags=\", 5)) {\n\t\tu_char t = strtoul (arg+5, (char**)0, 0);\n\t\tif (t<=SCSI_NCR_MAX_TAGS) {\n\t\t\tuser.data = t;\n\t\t\tuser.cmd  = UC_SETTAGS;\n\t\t};\n\t};\n\n\tif (!strncmp(arg, \"flags=\", 6)) {\n\t\tu_char t = strtoul (arg+6, (char**)0, 0);\n\t\tif (t<=0xff) {\n\t\t\tuser.data = t;\n\t\t\tuser.cmd  = UC_SETFLAG;\n\t\t};\n\t};\n\n\tif (!strncmp(arg, \"debug=\", 6)) {\n\t\tuser.data = strtoul (arg+6, (char**)0, 0);\n\t\tuser.cmd  = UC_SETDEBUG;\n\t};\n\n\tif (!strcmp(arg, \"orderedtag\")) {\n\t\tuser.data = M_ORDERED_TAG;\n\t\tuser.cmd  = UC_SETORDER;\n\t};\n\n\tif (!strcmp(arg, \"simpletag\")) {\n\t\tuser.data = M_SIMPLE_TAG;\n\t\tuser.cmd  = UC_SETORDER;\n\t};\n\f\n\tif (!strcmp(arg, \"orderedwrite\")) {\n\t\tuser.data = 0;\n\t\tuser.cmd  = UC_SETORDER;\n\t};\n\n\tif (user.cmd) {\n\t\topenkernelwritefile();\n\n\t\tif (lseek (kernelwritefile, addr, 0) != addr) {\n\t\t\tfprintf (stderr, \"%s: %s: %s\\n\",\n\t\t\t\tprog, kernelwritefilename, strerror(errno));\n\t\t\texit (1);\n\t\t}\n\t\tif (write (kernelwritefile, &user, sizeof (user)) < 0) {\n\t\t\tfprintf (stderr, \"%s: %s: %s\\n\",\n\t\t\t\tprog, kernelwritefilename, strerror(errno));\n\t\t\texit (1);\n\t\t}\n\n\t\treturn;\n\t};\n\n\tfprintf (stderr, \"%s: do_set \\\"%s\\\" not (yet) implemented.\\n\",\n\t\tprog, arg);\n}",
    "includes": [
      "#include <dev/pci/ncr.c>",
      "#include <kvm.h>",
      "#include <limits.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <nlist.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern void  exit();",
      "char\t*prog;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: do_set \\\"%s\\\" not (yet) implemented.\\n\"",
            "prog",
            "arg"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: %s: %s\\n\"",
            "prog",
            "kernelwritefilename",
            "strerror(errno)"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "kernelwritefile",
            "&user",
            "sizeof (user)"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "cmpci_reg_partial_write_4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/cmpci.c",
          "lines": "212-222",
          "snippet": "static __inline void\ncmpci_reg_partial_write_4(sc, no, shift, mask, val)\n\tstruct cmpci_softc *sc;\n\tint no, shift;\n\tuint32_t mask, val;\n{\n\tbus_space_write_4(sc->sc_iot, sc->sc_ioh, no,\n\t    (val<<shift) |\n\t    (bus_space_read_4(sc->sc_iot, sc->sc_ioh, no) & ~(mask<<shift)));\n\tdelay(10);\n}",
          "includes": [
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/cmpcivar.h>",
            "#include <dev/pci/cmpcireg.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline void cmpci_reg_partial_write_4",
            "struct cmpci_dmanode *\ncmpci_find_dmamem(sc, addr)\n\tstruct cmpci_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/intr.h>\n#include <machine/bus.h>\n#include <dev/pci/cmpcivar.h>\n#include <dev/pci/cmpcireg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline void cmpci_reg_partial_write_4;\nstruct cmpci_dmanode *\ncmpci_find_dmamem(sc, addr)\n\tstruct cmpci_softc *sc;\n\nstatic __inline void\ncmpci_reg_partial_write_4(sc, no, shift, mask, val)\n\tstruct cmpci_softc *sc;\n\tint no, shift;\n\tuint32_t mask, val;\n{\n\tbus_space_write_4(sc->sc_iot, sc->sc_ioh, no,\n\t    (val<<shift) |\n\t    (bus_space_read_4(sc->sc_iot, sc->sc_ioh, no) & ~(mask<<shift)));\n\tdelay(10);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: %s: %s\\n\"",
            "prog",
            "kernelwritefilename",
            "strerror(errno)"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lseek",
          "args": [
            "kernelwritefile",
            "addr",
            "0"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openkernelwritefile",
          "args": [],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "openkernelwritefile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncrstat.c",
          "lines": "630-640",
          "snippet": "void openkernelwritefile(void)\n{\n\tif (kernelwritefile) return;\n\n\tkernelwritefile = open (kernelwritefilename, O_WRONLY);\n\tif (kernelwritefile<3) {\n\t\tfprintf (stderr, \"%s: %s: %s\\n\",\n\t\t\tprog, kernelwritefilename, strerror(errno));\n\t\texit (1);\n\t};\n}",
          "includes": [
            "#include <dev/pci/ncr.c>",
            "#include <kvm.h>",
            "#include <limits.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <nlist.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void  exit();",
            "char\t*prog;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ncr.c>\n#include <kvm.h>\n#include <limits.h>\n#include <paths.h>\n#include <errno.h>\n#include <stdio.h>\n#include <nlist.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/file.h>\n\nextern void  exit();\nchar\t*prog;\n\nvoid openkernelwritefile(void)\n{\n\tif (kernelwritefile) return;\n\n\tkernelwritefile = open (kernelwritefilename, O_WRONLY);\n\tif (kernelwritefile<3) {\n\t\tfprintf (stderr, \"%s: %s: %s\\n\",\n\t\t\tprog, kernelwritefilename, strerror(errno));\n\t\texit (1);\n\t};\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"orderedwrite\""
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"simpletag\""
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"orderedtag\""
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "arg+6",
            "(char**)0",
            "0"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "arg",
            "\"debug=\"",
            "6"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "arg+6",
            "(char**)0",
            "0"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "arg",
            "\"flags=\"",
            "6"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "arg+5",
            "(char**)0",
            "0"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "arg",
            "\"tags=\"",
            "5"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "arg+5",
            "(char**)0",
            "0"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "arg",
            "\"wide=\"",
            "5"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtod",
          "args": [
            "arg+5",
            "NULL"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "arg",
            "\"sync=\"",
            "5"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"fast\""
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"async\""
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"async:         disable synchronous transfers.\\n\"\n\"sync=value:    set the maximal synchronous transfer rate (MHz).\\n\"\n\"fast:          set FAST SCSI-2.\\n\"\n\"\\n\"\n\"wide=value:    set the bus width (0=8bit 1=16bit).\\n\"\n\"\\n\"\n\"tags=value:    use this number of tags.\\n\"\n\"orderedtag:    use ordered tags only.\\n\"\n\"simpletag:     use simple tags only.\\n\"\n\"orderedwrite:  use simple tags for read, else ordered tags.\\n\"\n\"\\n\"\n\"debug=value:   set debug mode.\\n\"\n\"\\n\""
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arg",
            "\"?\""
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: ncb.user busy.\\n\"",
            "prog"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "1"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "audio_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "756-762",
          "snippet": "static __inline int\naudio_sleep(chan, label)\n\tint *chan;\n\tchar *label;\n{\n\treturn audio_sleep_timo(chan, label, 0);\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline int\naudio_sleep(chan, label)\n\tint *chan;\n\tchar *label;\n{\n\treturn audio_sleep_timo(chan, label, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: bad kvm read.\\n\"",
            "prog"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_READ",
          "args": [
            "(addr)",
            "&user",
            "sizeof (user)"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open_kvm",
          "args": [
            "O_RDWR"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "open_kvm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncrstat.c",
          "lines": "174-295",
          "snippet": "void open_kvm(int flags)\n{\n\tint i;\n\tu_long\tkernel_version;\n#if defined(__NetBSD__) || defined(__OpenBSD__) || (__FreeBSD__ >= 2)\n\tchar \terrbuf[_POSIX2_LINE_MAX];\n#endif\n\n\tif (kvm_isopen) return;\n\n#if defined(__NetBSD__) || defined(__OpenBSD__) || (__FreeBSD__ >= 2)\n\tkvm = kvm_openfiles(vmunix, kmemf, NULL, flags, errbuf);\n\tif (kvm == NULL) {\n\t\tfprintf(stderr, \"%s: kvm_openfiles: %s\\n\", prog, errbuf);\n\t\texit(1);\n\t}\n#else\n\tif (kvm_openfiles(vmunix, kmemf, NULL) == -1) {\n\t\tfprintf(stderr, \"%s: kvm_openfiles: %s\\n\", prog, kvm_geterr());\n\t\texit(1);\n\t}\n#endif\n\n\tif (!KVM_NLIST(nl)) {\n\t\tfprintf(stderr, \"%s: no symbols in \\\"%s\\\".\\n\",\n\t\t\tprog, vmunix);\n\t\texit (2);\n\t};\n\n\tfor (i=0; nl[i].n_name; i++)\n\t\tif (nl[i].n_type == 0) {\n\t\t\tfprintf(stderr, \"%s: no symbol \\\"%s\\\" in \\\"%s\\\".\\n\",\n\t\t\t\tprog, nl[i].n_name, vmunix);\n\t\t\texit(1);\n\t\t}\n\n\tif (!KVM_READ (\n\t\tnl[N_NCR_VERSION].n_value,\n\t\t&kernel_version,\n\t\tsizeof (kernel_version))) {\n\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\texit (1);\n\t};\n\n\tif (kernel_version != ncr_version){\n\t\tfprintf (stderr, \"%s: incompatible with kernel. Rebuild!\\n\",\n\t\t\tprog);\n\t\texit (1);\n\t};\n\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\n\tif (!KVM_READ (\n\t\tnl[N_NCRCD].n_value,\n\t\t&ncr_cd,\n\t\tsizeof (ncr_cd))) {\n\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\texit (1);\n\t};\n\n\tif (ncr_unit >= ncr_cd.cd_ndevs){\n\t\tfprintf (stderr, \"%s: bad unit number (valid range: 0-%d).\\n\",\n\t\t\tprog, ncr_cd.cd_ndevs-1);\n\t\texit (1);\n\t};\n\n\tif (!KVM_READ (\n\t\tncr_cd.cd_devs+4*ncr_unit,\n\t\t&ncr_base,\n\t\tsizeof (ncr_base))) {\n\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\texit (1);\n\t};\n\n\tif (!ncr_base) {\n\t\tfprintf (stderr,\n\t\t\"%s: control structure not allocated (not found in autoconfig?)\\n\", prog);\n\t\texit (1);\n\t};\n\n#else /* !(__NetBSD__ || __OpenBSD__) */\n\n\tif (!KVM_READ (\n\t\tnl[N_NNCR].n_value,\n\t\t&ncr_units,\n\t\tsizeof (ncr_units))) {\n\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\texit (1);\n\t};\n\n\tif (ncr_unit >= ncr_units){\n\t\tfprintf (stderr, \"%s: bad unit number (valid range: 0-%d).\\n\",\n\t\t\tprog, ncr_units-1);\n\t\texit (1);\n\t};\n\f\n\tif (!KVM_READ (\n\t\tnl[N_NCRP].n_value+4*ncr_unit,\n\t\t&ncr_base,\n\t\tsizeof (ncr_base))) {\n\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\texit (1);\n\t};\n\n\tif (!ncr_base) {\n\t\tfprintf (stderr,\n\t\t\"%s: control structure not allocated (not found in autoconfig?)\\n\", prog);\n\t\texit (1);\n\t};\n\n#endif /* !(__NetBSD__ || __OpenBSD__) */\n\n\tread_ncr();\n\n\tif (!ncr.vaddr) {\n\t\tfprintf (stderr,\n\t\t\"%s: 53c810 not mapped (not found in autoconfig?)\\n\", prog);\n\t\texit (1);\n\t};\n\n\tkvm_isopen = 1;\n}",
          "includes": [
            "#include <dev/pci/ncr.c>",
            "#include <kvm.h>",
            "#include <limits.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <nlist.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>"
          ],
          "macros_used": [
            "#define\tN_NNCR\t2",
            "#define\tN_NCRP\t1",
            "#define\tN_NCRCD\t1",
            "#define\tN_NCR_VERSION\t0"
          ],
          "globals_used": [
            "extern void  exit();",
            "char\t*prog;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ncr.c>\n#include <kvm.h>\n#include <limits.h>\n#include <paths.h>\n#include <errno.h>\n#include <stdio.h>\n#include <nlist.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/file.h>\n\n#define\tN_NNCR\t2\n#define\tN_NCRP\t1\n#define\tN_NCRCD\t1\n#define\tN_NCR_VERSION\t0\n\nextern void  exit();\nchar\t*prog;\n\nvoid open_kvm(int flags)\n{\n\tint i;\n\tu_long\tkernel_version;\n#if defined(__NetBSD__) || defined(__OpenBSD__) || (__FreeBSD__ >= 2)\n\tchar \terrbuf[_POSIX2_LINE_MAX];\n#endif\n\n\tif (kvm_isopen) return;\n\n#if defined(__NetBSD__) || defined(__OpenBSD__) || (__FreeBSD__ >= 2)\n\tkvm = kvm_openfiles(vmunix, kmemf, NULL, flags, errbuf);\n\tif (kvm == NULL) {\n\t\tfprintf(stderr, \"%s: kvm_openfiles: %s\\n\", prog, errbuf);\n\t\texit(1);\n\t}\n#else\n\tif (kvm_openfiles(vmunix, kmemf, NULL) == -1) {\n\t\tfprintf(stderr, \"%s: kvm_openfiles: %s\\n\", prog, kvm_geterr());\n\t\texit(1);\n\t}\n#endif\n\n\tif (!KVM_NLIST(nl)) {\n\t\tfprintf(stderr, \"%s: no symbols in \\\"%s\\\".\\n\",\n\t\t\tprog, vmunix);\n\t\texit (2);\n\t};\n\n\tfor (i=0; nl[i].n_name; i++)\n\t\tif (nl[i].n_type == 0) {\n\t\t\tfprintf(stderr, \"%s: no symbol \\\"%s\\\" in \\\"%s\\\".\\n\",\n\t\t\t\tprog, nl[i].n_name, vmunix);\n\t\t\texit(1);\n\t\t}\n\n\tif (!KVM_READ (\n\t\tnl[N_NCR_VERSION].n_value,\n\t\t&kernel_version,\n\t\tsizeof (kernel_version))) {\n\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\texit (1);\n\t};\n\n\tif (kernel_version != ncr_version){\n\t\tfprintf (stderr, \"%s: incompatible with kernel. Rebuild!\\n\",\n\t\t\tprog);\n\t\texit (1);\n\t};\n\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\n\tif (!KVM_READ (\n\t\tnl[N_NCRCD].n_value,\n\t\t&ncr_cd,\n\t\tsizeof (ncr_cd))) {\n\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\texit (1);\n\t};\n\n\tif (ncr_unit >= ncr_cd.cd_ndevs){\n\t\tfprintf (stderr, \"%s: bad unit number (valid range: 0-%d).\\n\",\n\t\t\tprog, ncr_cd.cd_ndevs-1);\n\t\texit (1);\n\t};\n\n\tif (!KVM_READ (\n\t\tncr_cd.cd_devs+4*ncr_unit,\n\t\t&ncr_base,\n\t\tsizeof (ncr_base))) {\n\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\texit (1);\n\t};\n\n\tif (!ncr_base) {\n\t\tfprintf (stderr,\n\t\t\"%s: control structure not allocated (not found in autoconfig?)\\n\", prog);\n\t\texit (1);\n\t};\n\n#else /* !(__NetBSD__ || __OpenBSD__) */\n\n\tif (!KVM_READ (\n\t\tnl[N_NNCR].n_value,\n\t\t&ncr_units,\n\t\tsizeof (ncr_units))) {\n\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\texit (1);\n\t};\n\n\tif (ncr_unit >= ncr_units){\n\t\tfprintf (stderr, \"%s: bad unit number (valid range: 0-%d).\\n\",\n\t\t\tprog, ncr_units-1);\n\t\texit (1);\n\t};\n\f\n\tif (!KVM_READ (\n\t\tnl[N_NCRP].n_value+4*ncr_unit,\n\t\t&ncr_base,\n\t\tsizeof (ncr_base))) {\n\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\texit (1);\n\t};\n\n\tif (!ncr_base) {\n\t\tfprintf (stderr,\n\t\t\"%s: control structure not allocated (not found in autoconfig?)\\n\", prog);\n\t\texit (1);\n\t};\n\n#endif /* !(__NetBSD__ || __OpenBSD__) */\n\n\tread_ncr();\n\n\tif (!ncr.vaddr) {\n\t\tfprintf (stderr,\n\t\t\"%s: 53c810 not mapped (not found in autoconfig?)\\n\", prog);\n\t\texit (1);\n\t};\n\n\tkvm_isopen = 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/ncr.c>\n#include <kvm.h>\n#include <limits.h>\n#include <paths.h>\n#include <errno.h>\n#include <stdio.h>\n#include <nlist.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/file.h>\n\nextern void  exit();\nchar\t*prog;\n\nvoid do_set (char * arg)\n{\n\tstruct usrcmd user;\n\tu_long addr;\n\tint i;\n\n\topen_kvm(O_RDWR);\n\taddr = ncr_base + offsetof (struct ncb, user);\n\n\tfor (i=3; i; i--) {\n\t\tif (!KVM_READ (\n\t\t\t(addr),\n\t\t\t&user,\n\t\t\tsizeof (user))) {\n\t\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\t\texit (1);\n\t\t}\n\t\tif (!user.cmd) break;\n\t\tsleep (1);\n\t}\n\tif (user.cmd) {\n\t\tfprintf (stderr, \"%s: ncb.user busy.\\n\", prog);\n\t\texit (1);\n\t};\n\n\tuser.target = target_mask;\n\tuser.lun    = lun_mask;\n\tuser.data   = 0;\n\tuser.cmd    = 0;\n\n\tif (!strcmp(arg, \"?\")) { printf (\n\"async:         disable synchronous transfers.\\n\"\n\"sync=value:    set the maximal synchronous transfer rate (MHz).\\n\"\n\"fast:          set FAST SCSI-2.\\n\"\n\"\\n\"\n\"wide=value:    set the bus width (0=8bit 1=16bit).\\n\"\n\"\\n\"\n\"tags=value:    use this number of tags.\\n\"\n\"orderedtag:    use ordered tags only.\\n\"\n\"simpletag:     use simple tags only.\\n\"\n\"orderedwrite:  use simple tags for read, else ordered tags.\\n\"\n\"\\n\"\n\"debug=value:   set debug mode.\\n\"\n\"\\n\");\n\t\treturn;\n\t};\n\f\n\tif (!strcmp(arg, \"async\")) {\n\t\tuser.data = 255;\n\t\tuser.cmd  = UC_SETSYNC;\n\t};\n\n\tif (!strcmp(arg, \"fast\")) {\n\t\tuser.data = 25;\n\t\tuser.cmd  = UC_SETSYNC;\n\t};\n\n\tif (!strncmp(arg, \"sync=\", 5)) {\n\t\tfloat f = strtod (arg+5, NULL);\n\t\tif (f>=4.0 && f<=10.0) {\n\t\t\tuser.data = 250.0 / f;\n\t\t\tuser.cmd  = UC_SETSYNC;\n\t\t};\n\t};\n\n\tif (!strncmp(arg, \"wide=\", 5)) {\n\t\tu_char t = strtoul (arg+5, (char**)0, 0);\n\t\tif (t<=1) {\n\t\t\tuser.data = t;\n\t\t\tuser.cmd  = UC_SETWIDE;\n\t\t};\n\t};\n\n\tif (!strncmp(arg, \"tags=\", 5)) {\n\t\tu_char t = strtoul (arg+5, (char**)0, 0);\n\t\tif (t<=SCSI_NCR_MAX_TAGS) {\n\t\t\tuser.data = t;\n\t\t\tuser.cmd  = UC_SETTAGS;\n\t\t};\n\t};\n\n\tif (!strncmp(arg, \"flags=\", 6)) {\n\t\tu_char t = strtoul (arg+6, (char**)0, 0);\n\t\tif (t<=0xff) {\n\t\t\tuser.data = t;\n\t\t\tuser.cmd  = UC_SETFLAG;\n\t\t};\n\t};\n\n\tif (!strncmp(arg, \"debug=\", 6)) {\n\t\tuser.data = strtoul (arg+6, (char**)0, 0);\n\t\tuser.cmd  = UC_SETDEBUG;\n\t};\n\n\tif (!strcmp(arg, \"orderedtag\")) {\n\t\tuser.data = M_ORDERED_TAG;\n\t\tuser.cmd  = UC_SETORDER;\n\t};\n\n\tif (!strcmp(arg, \"simpletag\")) {\n\t\tuser.data = M_SIMPLE_TAG;\n\t\tuser.cmd  = UC_SETORDER;\n\t};\n\f\n\tif (!strcmp(arg, \"orderedwrite\")) {\n\t\tuser.data = 0;\n\t\tuser.cmd  = UC_SETORDER;\n\t};\n\n\tif (user.cmd) {\n\t\topenkernelwritefile();\n\n\t\tif (lseek (kernelwritefile, addr, 0) != addr) {\n\t\t\tfprintf (stderr, \"%s: %s: %s\\n\",\n\t\t\t\tprog, kernelwritefilename, strerror(errno));\n\t\t\texit (1);\n\t\t}\n\t\tif (write (kernelwritefile, &user, sizeof (user)) < 0) {\n\t\t\tfprintf (stderr, \"%s: %s: %s\\n\",\n\t\t\t\tprog, kernelwritefilename, strerror(errno));\n\t\t\texit (1);\n\t\t}\n\n\t\treturn;\n\t};\n\n\tfprintf (stderr, \"%s: do_set \\\"%s\\\" not (yet) implemented.\\n\",\n\t\tprog, arg);\n}"
  },
  {
    "function_name": "in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncrstat.c",
    "lines": "658-669",
    "snippet": "u_char in (u_char reg)\n{\n\tu_char res;\n\tif (!KVM_READ (\n\t\t(ncr.vaddr + reg),\n\t\t&res,\n\t\t1)) {\n\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\texit (1);\n\t}\n\treturn (res);\n}",
    "includes": [
      "#include <dev/pci/ncr.c>",
      "#include <kvm.h>",
      "#include <limits.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <nlist.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern void  exit();",
      "char\t*prog;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: bad kvm read.\\n\"",
            "prog"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_READ",
          "args": [
            "(ncr.vaddr + reg)",
            "&res",
            "1"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/ncr.c>\n#include <kvm.h>\n#include <limits.h>\n#include <paths.h>\n#include <errno.h>\n#include <stdio.h>\n#include <nlist.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/file.h>\n\nextern void  exit();\nchar\t*prog;\n\nu_char in (u_char reg)\n{\n\tu_char res;\n\tif (!KVM_READ (\n\t\t(ncr.vaddr + reg),\n\t\t&res,\n\t\t1)) {\n\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\texit (1);\n\t}\n\treturn (res);\n}"
  },
  {
    "function_name": "out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncrstat.c",
    "lines": "642-656",
    "snippet": "void out (u_char reg, u_char val)\n{\n\tu_long addr = ncr.vaddr + reg;\n\topenkernelwritefile();\n\tif (lseek (kernelwritefile, addr, 0) != addr) {\n\t\tfprintf (stderr, \"%s: %s: %s\\n\",\n\t\t\tprog, kernelwritefilename, strerror(errno));\n\t\texit (1);\n\t}\n\tif (write (kernelwritefile, &val, 1) < 0) {\n\t\tfprintf (stderr, \"%s: %s: %s\\n\",\n\t\t\tprog, kernelwritefilename, strerror(errno));\n\t\texit (1);\n\t};\n}",
    "includes": [
      "#include <dev/pci/ncr.c>",
      "#include <kvm.h>",
      "#include <limits.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <nlist.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern void  exit();",
      "char\t*prog;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: %s: %s\\n\"",
            "prog",
            "kernelwritefilename",
            "strerror(errno)"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "kernelwritefile",
            "&val",
            "1"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "cmpci_reg_partial_write_4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/cmpci.c",
          "lines": "212-222",
          "snippet": "static __inline void\ncmpci_reg_partial_write_4(sc, no, shift, mask, val)\n\tstruct cmpci_softc *sc;\n\tint no, shift;\n\tuint32_t mask, val;\n{\n\tbus_space_write_4(sc->sc_iot, sc->sc_ioh, no,\n\t    (val<<shift) |\n\t    (bus_space_read_4(sc->sc_iot, sc->sc_ioh, no) & ~(mask<<shift)));\n\tdelay(10);\n}",
          "includes": [
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/cmpcivar.h>",
            "#include <dev/pci/cmpcireg.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline void cmpci_reg_partial_write_4",
            "struct cmpci_dmanode *\ncmpci_find_dmamem(sc, addr)\n\tstruct cmpci_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/intr.h>\n#include <machine/bus.h>\n#include <dev/pci/cmpcivar.h>\n#include <dev/pci/cmpcireg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic __inline void cmpci_reg_partial_write_4;\nstruct cmpci_dmanode *\ncmpci_find_dmamem(sc, addr)\n\tstruct cmpci_softc *sc;\n\nstatic __inline void\ncmpci_reg_partial_write_4(sc, no, shift, mask, val)\n\tstruct cmpci_softc *sc;\n\tint no, shift;\n\tuint32_t mask, val;\n{\n\tbus_space_write_4(sc->sc_iot, sc->sc_ioh, no,\n\t    (val<<shift) |\n\t    (bus_space_read_4(sc->sc_iot, sc->sc_ioh, no) & ~(mask<<shift)));\n\tdelay(10);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: %s: %s\\n\"",
            "prog",
            "kernelwritefilename",
            "strerror(errno)"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lseek",
          "args": [
            "kernelwritefile",
            "addr",
            "0"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openkernelwritefile",
          "args": [],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "openkernelwritefile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncrstat.c",
          "lines": "630-640",
          "snippet": "void openkernelwritefile(void)\n{\n\tif (kernelwritefile) return;\n\n\tkernelwritefile = open (kernelwritefilename, O_WRONLY);\n\tif (kernelwritefile<3) {\n\t\tfprintf (stderr, \"%s: %s: %s\\n\",\n\t\t\tprog, kernelwritefilename, strerror(errno));\n\t\texit (1);\n\t};\n}",
          "includes": [
            "#include <dev/pci/ncr.c>",
            "#include <kvm.h>",
            "#include <limits.h>",
            "#include <paths.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <nlist.h>",
            "#include <sys/device.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void  exit();",
            "char\t*prog;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ncr.c>\n#include <kvm.h>\n#include <limits.h>\n#include <paths.h>\n#include <errno.h>\n#include <stdio.h>\n#include <nlist.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/file.h>\n\nextern void  exit();\nchar\t*prog;\n\nvoid openkernelwritefile(void)\n{\n\tif (kernelwritefile) return;\n\n\tkernelwritefile = open (kernelwritefilename, O_WRONLY);\n\tif (kernelwritefile<3) {\n\t\tfprintf (stderr, \"%s: %s: %s\\n\",\n\t\t\tprog, kernelwritefilename, strerror(errno));\n\t\texit (1);\n\t};\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/ncr.c>\n#include <kvm.h>\n#include <limits.h>\n#include <paths.h>\n#include <errno.h>\n#include <stdio.h>\n#include <nlist.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/file.h>\n\nextern void  exit();\nchar\t*prog;\n\nvoid out (u_char reg, u_char val)\n{\n\tu_long addr = ncr.vaddr + reg;\n\topenkernelwritefile();\n\tif (lseek (kernelwritefile, addr, 0) != addr) {\n\t\tfprintf (stderr, \"%s: %s: %s\\n\",\n\t\t\tprog, kernelwritefilename, strerror(errno));\n\t\texit (1);\n\t}\n\tif (write (kernelwritefile, &val, 1) < 0) {\n\t\tfprintf (stderr, \"%s: %s: %s\\n\",\n\t\t\tprog, kernelwritefilename, strerror(errno));\n\t\texit (1);\n\t};\n}"
  },
  {
    "function_name": "openkernelwritefile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncrstat.c",
    "lines": "630-640",
    "snippet": "void openkernelwritefile(void)\n{\n\tif (kernelwritefile) return;\n\n\tkernelwritefile = open (kernelwritefilename, O_WRONLY);\n\tif (kernelwritefile<3) {\n\t\tfprintf (stderr, \"%s: %s: %s\\n\",\n\t\t\tprog, kernelwritefilename, strerror(errno));\n\t\texit (1);\n\t};\n}",
    "includes": [
      "#include <dev/pci/ncr.c>",
      "#include <kvm.h>",
      "#include <limits.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <nlist.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern void  exit();",
      "char\t*prog;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: %s: %s\\n\"",
            "prog",
            "kernelwritefilename",
            "strerror(errno)"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "kernelwritefilename",
            "O_WRONLY"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "cmpci_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/cmpci.c",
          "lines": "442-452",
          "snippet": "int\ncmpci_open(handle, flags)\n\tvoid *handle;\n\tint flags;\n{\n\tstruct cmpci_softc *sc = handle;\n\t(void)sc;\n\t(void)flags;\n\t\n\treturn 0;\n}",
          "includes": [
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <dev/pci/cmpcivar.h>",
            "#include <dev/pci/cmpcireg.h>",
            "#include <dev/auconv.h>",
            "#include <dev/mulaw.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/audioio.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <sys/proc.h>",
            "#include <sys/device.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int cmpci_open",
            "struct cmpci_dmanode *\ncmpci_find_dmamem(sc, addr)\n\tstruct cmpci_softc *sc;",
            "void *\ncmpci_malloc(handle, size, type, flags)\n\tvoid  *handle;",
            "int    type, flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/intr.h>\n#include <machine/bus.h>\n#include <dev/pci/cmpcivar.h>\n#include <dev/pci/cmpcireg.h>\n#include <dev/auconv.h>\n#include <dev/mulaw.h>\n#include <dev/audio_if.h>\n#include <sys/audioio.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcidevs.h>\n#include <sys/proc.h>\n#include <sys/device.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint cmpci_open;\nstruct cmpci_dmanode *\ncmpci_find_dmamem(sc, addr)\n\tstruct cmpci_softc *sc;\nvoid *\ncmpci_malloc(handle, size, type, flags)\n\tvoid  *handle;\nint    type, flags;\n\nint\ncmpci_open(handle, flags)\n\tvoid *handle;\n\tint flags;\n{\n\tstruct cmpci_softc *sc = handle;\n\t(void)sc;\n\t(void)flags;\n\t\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/ncr.c>\n#include <kvm.h>\n#include <limits.h>\n#include <paths.h>\n#include <errno.h>\n#include <stdio.h>\n#include <nlist.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/file.h>\n\nextern void  exit();\nchar\t*prog;\n\nvoid openkernelwritefile(void)\n{\n\tif (kernelwritefile) return;\n\n\tkernelwritefile = open (kernelwritefilename, O_WRONLY);\n\tif (kernelwritefile<3) {\n\t\tfprintf (stderr, \"%s: %s: %s\\n\",\n\t\t\tprog, kernelwritefilename, strerror(errno));\n\t\texit (1);\n\t};\n}"
  },
  {
    "function_name": "printc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncrstat.c",
    "lines": "317-323",
    "snippet": "void printc (u_char*p, int l)\n{\n\tfor (;l>0;l--) {\n\t\tchar c=*p++;\n\t\tprintf (\"%c\", c?c:'_');\n\t}\n}",
    "includes": [
      "#include <dev/pci/ncr.c>",
      "#include <kvm.h>",
      "#include <limits.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <nlist.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%c\"",
            "c?c:'_'"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/ncr.c>\n#include <kvm.h>\n#include <limits.h>\n#include <paths.h>\n#include <errno.h>\n#include <stdio.h>\n#include <nlist.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/file.h>\n\nvoid printc (u_char*p, int l)\n{\n\tfor (;l>0;l--) {\n\t\tchar c=*p++;\n\t\tprintf (\"%c\", c?c:'_');\n\t}\n}"
  },
  {
    "function_name": "set_lun_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncrstat.c",
    "lines": "308-315",
    "snippet": "void set_lun_mask(struct tcb * tp)\n{\n\tint l;\n\tlun_mask = global_lun_mask;\n\tif (lun_mask) return;\n\tfor (l=0; l<MAX_LUN; l++)\n\t\tif (tp->lp[l]) lun_mask |= (1<<l);\n}",
    "includes": [
      "#include <dev/pci/ncr.c>",
      "#include <kvm.h>",
      "#include <limits.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <nlist.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/pci/ncr.c>\n#include <kvm.h>\n#include <limits.h>\n#include <paths.h>\n#include <errno.h>\n#include <stdio.h>\n#include <nlist.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/file.h>\n\nvoid set_lun_mask(struct tcb * tp)\n{\n\tint l;\n\tlun_mask = global_lun_mask;\n\tif (lun_mask) return;\n\tfor (l=0; l<MAX_LUN; l++)\n\t\tif (tp->lp[l]) lun_mask |= (1<<l);\n}"
  },
  {
    "function_name": "set_target_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncrstat.c",
    "lines": "300-306",
    "snippet": "void set_target_mask(void)\n{\n\tint t;\n\tif (target_mask) return;\n\tfor (t=0; t<MAX_TARGET; t++)\n\t\tif (ncr.target[t].jump_tcb.l_cmd) target_mask |= (1<<t);\n}",
    "includes": [
      "#include <dev/pci/ncr.c>",
      "#include <kvm.h>",
      "#include <limits.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <nlist.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/pci/ncr.c>\n#include <kvm.h>\n#include <limits.h>\n#include <paths.h>\n#include <errno.h>\n#include <stdio.h>\n#include <nlist.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/file.h>\n\nvoid set_target_mask(void)\n{\n\tint t;\n\tif (target_mask) return;\n\tfor (t=0; t<MAX_TARGET; t++)\n\t\tif (ncr.target[t].jump_tcb.l_cmd) target_mask |= (1<<t);\n}"
  },
  {
    "function_name": "open_kvm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncrstat.c",
    "lines": "174-295",
    "snippet": "void open_kvm(int flags)\n{\n\tint i;\n\tu_long\tkernel_version;\n#if defined(__NetBSD__) || defined(__OpenBSD__) || (__FreeBSD__ >= 2)\n\tchar \terrbuf[_POSIX2_LINE_MAX];\n#endif\n\n\tif (kvm_isopen) return;\n\n#if defined(__NetBSD__) || defined(__OpenBSD__) || (__FreeBSD__ >= 2)\n\tkvm = kvm_openfiles(vmunix, kmemf, NULL, flags, errbuf);\n\tif (kvm == NULL) {\n\t\tfprintf(stderr, \"%s: kvm_openfiles: %s\\n\", prog, errbuf);\n\t\texit(1);\n\t}\n#else\n\tif (kvm_openfiles(vmunix, kmemf, NULL) == -1) {\n\t\tfprintf(stderr, \"%s: kvm_openfiles: %s\\n\", prog, kvm_geterr());\n\t\texit(1);\n\t}\n#endif\n\n\tif (!KVM_NLIST(nl)) {\n\t\tfprintf(stderr, \"%s: no symbols in \\\"%s\\\".\\n\",\n\t\t\tprog, vmunix);\n\t\texit (2);\n\t};\n\n\tfor (i=0; nl[i].n_name; i++)\n\t\tif (nl[i].n_type == 0) {\n\t\t\tfprintf(stderr, \"%s: no symbol \\\"%s\\\" in \\\"%s\\\".\\n\",\n\t\t\t\tprog, nl[i].n_name, vmunix);\n\t\t\texit(1);\n\t\t}\n\n\tif (!KVM_READ (\n\t\tnl[N_NCR_VERSION].n_value,\n\t\t&kernel_version,\n\t\tsizeof (kernel_version))) {\n\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\texit (1);\n\t};\n\n\tif (kernel_version != ncr_version){\n\t\tfprintf (stderr, \"%s: incompatible with kernel. Rebuild!\\n\",\n\t\t\tprog);\n\t\texit (1);\n\t};\n\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\n\tif (!KVM_READ (\n\t\tnl[N_NCRCD].n_value,\n\t\t&ncr_cd,\n\t\tsizeof (ncr_cd))) {\n\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\texit (1);\n\t};\n\n\tif (ncr_unit >= ncr_cd.cd_ndevs){\n\t\tfprintf (stderr, \"%s: bad unit number (valid range: 0-%d).\\n\",\n\t\t\tprog, ncr_cd.cd_ndevs-1);\n\t\texit (1);\n\t};\n\n\tif (!KVM_READ (\n\t\tncr_cd.cd_devs+4*ncr_unit,\n\t\t&ncr_base,\n\t\tsizeof (ncr_base))) {\n\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\texit (1);\n\t};\n\n\tif (!ncr_base) {\n\t\tfprintf (stderr,\n\t\t\"%s: control structure not allocated (not found in autoconfig?)\\n\", prog);\n\t\texit (1);\n\t};\n\n#else /* !(__NetBSD__ || __OpenBSD__) */\n\n\tif (!KVM_READ (\n\t\tnl[N_NNCR].n_value,\n\t\t&ncr_units,\n\t\tsizeof (ncr_units))) {\n\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\texit (1);\n\t};\n\n\tif (ncr_unit >= ncr_units){\n\t\tfprintf (stderr, \"%s: bad unit number (valid range: 0-%d).\\n\",\n\t\t\tprog, ncr_units-1);\n\t\texit (1);\n\t};\n\f\n\tif (!KVM_READ (\n\t\tnl[N_NCRP].n_value+4*ncr_unit,\n\t\t&ncr_base,\n\t\tsizeof (ncr_base))) {\n\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\texit (1);\n\t};\n\n\tif (!ncr_base) {\n\t\tfprintf (stderr,\n\t\t\"%s: control structure not allocated (not found in autoconfig?)\\n\", prog);\n\t\texit (1);\n\t};\n\n#endif /* !(__NetBSD__ || __OpenBSD__) */\n\n\tread_ncr();\n\n\tif (!ncr.vaddr) {\n\t\tfprintf (stderr,\n\t\t\"%s: 53c810 not mapped (not found in autoconfig?)\\n\", prog);\n\t\texit (1);\n\t};\n\n\tkvm_isopen = 1;\n}",
    "includes": [
      "#include <dev/pci/ncr.c>",
      "#include <kvm.h>",
      "#include <limits.h>",
      "#include <paths.h>",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <nlist.h>",
      "#include <sys/device.h>",
      "#include <sys/types.h>",
      "#include <sys/file.h>"
    ],
    "macros_used": [
      "#define\tN_NNCR\t2",
      "#define\tN_NCRP\t1",
      "#define\tN_NCRCD\t1",
      "#define\tN_NCR_VERSION\t0"
    ],
    "globals_used": [
      "extern void  exit();",
      "char\t*prog;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: 53c810 not mapped (not found in autoconfig?)\\n\"",
            "prog"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_ncr",
          "args": [],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: control structure not allocated (not found in autoconfig?)\\n\"",
            "prog"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: bad kvm read.\\n\"",
            "prog"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_READ",
          "args": [
            "nl[N_NCRP].n_value+4*ncr_unit",
            "&ncr_base",
            "sizeof (ncr_base)"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: bad unit number (valid range: 0-%d).\\n\"",
            "prog",
            "ncr_units-1"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: bad kvm read.\\n\"",
            "prog"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_READ",
          "args": [
            "nl[N_NNCR].n_value",
            "&ncr_units",
            "sizeof (ncr_units)"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: control structure not allocated (not found in autoconfig?)\\n\"",
            "prog"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: bad kvm read.\\n\"",
            "prog"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_READ",
          "args": [
            "ncr_cd.cd_devs+4*ncr_unit",
            "&ncr_base",
            "sizeof (ncr_base)"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: bad unit number (valid range: 0-%d).\\n\"",
            "prog",
            "ncr_cd.cd_ndevs-1"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: bad kvm read.\\n\"",
            "prog"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_READ",
          "args": [
            "nl[N_NCRCD].n_value",
            "&ncr_cd",
            "sizeof (ncr_cd)"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: incompatible with kernel. Rebuild!\\n\"",
            "prog"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: bad kvm read.\\n\"",
            "prog"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_READ",
          "args": [
            "nl[N_NCR_VERSION].n_value",
            "&kernel_version",
            "sizeof (kernel_version)"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: no symbol \\\"%s\\\" in \\\"%s\\\".\\n\"",
            "prog",
            "nl[i].n_name",
            "vmunix"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "2"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: no symbols in \\\"%s\\\".\\n\"",
            "prog",
            "vmunix"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_NLIST",
          "args": [
            "nl"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: kvm_openfiles: %s\\n\"",
            "prog",
            "kvm_geterr()"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_geterr",
          "args": [],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_openfiles",
          "args": [
            "vmunix",
            "kmemf",
            "NULL"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: kvm_openfiles: %s\\n\"",
            "prog",
            "errbuf"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_openfiles",
          "args": [
            "vmunix",
            "kmemf",
            "NULL",
            "flags",
            "errbuf"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/ncr.c>\n#include <kvm.h>\n#include <limits.h>\n#include <paths.h>\n#include <errno.h>\n#include <stdio.h>\n#include <nlist.h>\n#include <sys/device.h>\n#include <sys/types.h>\n#include <sys/file.h>\n\n#define\tN_NNCR\t2\n#define\tN_NCRP\t1\n#define\tN_NCRCD\t1\n#define\tN_NCR_VERSION\t0\n\nextern void  exit();\nchar\t*prog;\n\nvoid open_kvm(int flags)\n{\n\tint i;\n\tu_long\tkernel_version;\n#if defined(__NetBSD__) || defined(__OpenBSD__) || (__FreeBSD__ >= 2)\n\tchar \terrbuf[_POSIX2_LINE_MAX];\n#endif\n\n\tif (kvm_isopen) return;\n\n#if defined(__NetBSD__) || defined(__OpenBSD__) || (__FreeBSD__ >= 2)\n\tkvm = kvm_openfiles(vmunix, kmemf, NULL, flags, errbuf);\n\tif (kvm == NULL) {\n\t\tfprintf(stderr, \"%s: kvm_openfiles: %s\\n\", prog, errbuf);\n\t\texit(1);\n\t}\n#else\n\tif (kvm_openfiles(vmunix, kmemf, NULL) == -1) {\n\t\tfprintf(stderr, \"%s: kvm_openfiles: %s\\n\", prog, kvm_geterr());\n\t\texit(1);\n\t}\n#endif\n\n\tif (!KVM_NLIST(nl)) {\n\t\tfprintf(stderr, \"%s: no symbols in \\\"%s\\\".\\n\",\n\t\t\tprog, vmunix);\n\t\texit (2);\n\t};\n\n\tfor (i=0; nl[i].n_name; i++)\n\t\tif (nl[i].n_type == 0) {\n\t\t\tfprintf(stderr, \"%s: no symbol \\\"%s\\\" in \\\"%s\\\".\\n\",\n\t\t\t\tprog, nl[i].n_name, vmunix);\n\t\t\texit(1);\n\t\t}\n\n\tif (!KVM_READ (\n\t\tnl[N_NCR_VERSION].n_value,\n\t\t&kernel_version,\n\t\tsizeof (kernel_version))) {\n\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\texit (1);\n\t};\n\n\tif (kernel_version != ncr_version){\n\t\tfprintf (stderr, \"%s: incompatible with kernel. Rebuild!\\n\",\n\t\t\tprog);\n\t\texit (1);\n\t};\n\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\n\tif (!KVM_READ (\n\t\tnl[N_NCRCD].n_value,\n\t\t&ncr_cd,\n\t\tsizeof (ncr_cd))) {\n\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\texit (1);\n\t};\n\n\tif (ncr_unit >= ncr_cd.cd_ndevs){\n\t\tfprintf (stderr, \"%s: bad unit number (valid range: 0-%d).\\n\",\n\t\t\tprog, ncr_cd.cd_ndevs-1);\n\t\texit (1);\n\t};\n\n\tif (!KVM_READ (\n\t\tncr_cd.cd_devs+4*ncr_unit,\n\t\t&ncr_base,\n\t\tsizeof (ncr_base))) {\n\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\texit (1);\n\t};\n\n\tif (!ncr_base) {\n\t\tfprintf (stderr,\n\t\t\"%s: control structure not allocated (not found in autoconfig?)\\n\", prog);\n\t\texit (1);\n\t};\n\n#else /* !(__NetBSD__ || __OpenBSD__) */\n\n\tif (!KVM_READ (\n\t\tnl[N_NNCR].n_value,\n\t\t&ncr_units,\n\t\tsizeof (ncr_units))) {\n\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\texit (1);\n\t};\n\n\tif (ncr_unit >= ncr_units){\n\t\tfprintf (stderr, \"%s: bad unit number (valid range: 0-%d).\\n\",\n\t\t\tprog, ncr_units-1);\n\t\texit (1);\n\t};\n\f\n\tif (!KVM_READ (\n\t\tnl[N_NCRP].n_value+4*ncr_unit,\n\t\t&ncr_base,\n\t\tsizeof (ncr_base))) {\n\t\tfprintf (stderr, \"%s: bad kvm read.\\n\", prog);\n\t\texit (1);\n\t};\n\n\tif (!ncr_base) {\n\t\tfprintf (stderr,\n\t\t\"%s: control structure not allocated (not found in autoconfig?)\\n\", prog);\n\t\texit (1);\n\t};\n\n#endif /* !(__NetBSD__ || __OpenBSD__) */\n\n\tread_ncr();\n\n\tif (!ncr.vaddr) {\n\t\tfprintf (stderr,\n\t\t\"%s: 53c810 not mapped (not found in autoconfig?)\\n\", prog);\n\t\texit (1);\n\t};\n\n\tkvm_isopen = 1;\n}"
  }
]