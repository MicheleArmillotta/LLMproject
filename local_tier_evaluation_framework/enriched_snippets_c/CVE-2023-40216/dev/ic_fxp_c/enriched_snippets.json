[
  {
    "function_name": "fxp_mc_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
    "lines": "1495-1604",
    "snippet": "void\nfxp_mc_setup(sc)\n\tstruct fxp_softc *sc;\n{\n\tstruct fxp_cb_mcs *mcsp = sc->mcsp;\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tstruct ether_multistep step;\n\tstruct ether_multi *enm;\n\tint nmcasts;\n\n\t/*\n\t * If there are queued commands, we must wait until they are all\n\t * completed. If we are already waiting, then add a NOP command\n\t * with interrupt option so that we're notified when all commands\n\t * have been completed - fxp_start() ensures that no additional\n\t * TX commands will be added when need_mcsetup is true.\n\t */\n\tif (sc->tx_queued) {\n\t\tstruct fxp_cb_tx *txp;\n\n\t\t/*\n\t\t * need_mcsetup will be true if we are already waiting for the\n\t\t * NOP command to be completed (see below). In this case, bail.\n\t\t */\n\t\tif (sc->need_mcsetup)\n\t\t\treturn;\n\t\tsc->need_mcsetup = 1;\n\n\t\t/*\n\t\t * Add a NOP command with interrupt so that we are notified when all\n\t\t * TX commands have been processed.\n\t\t */\n\t\ttxp = sc->cbl_last->next;\n\t\ttxp->mb_head = NULL;\n\t\ttxp->cb_status = 0;\n\t\ttxp->cb_command = FXP_CB_COMMAND_NOP | FXP_CB_COMMAND_S | FXP_CB_COMMAND_I;\n\t\t/*\n\t\t * Advance the end of list forward.\n\t\t */\n\t\tsc->cbl_last->cb_command &= ~FXP_CB_COMMAND_S;\n\t\tsc->cbl_last = txp;\n\t\tsc->tx_queued++;\n\t\t/*\n\t\t * Issue a resume in case the CU has just suspended.\n\t\t */\n\t\tfxp_scb_wait(sc);\n\t\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_RESUME);\n\t\t/*\n\t\t * Set a 5 second timer just in case we don't hear from the\n\t\t * card again.\n\t\t */\n\t\tifp->if_timer = 5;\n\n\t\treturn;\n\t}\n\tsc->need_mcsetup = 0;\n\n\t/*\n\t * Initialize multicast setup descriptor.\n\t */\n\tmcsp->next = sc->cbl_base;\n\tmcsp->mb_head = NULL;\n\tmcsp->cb_status = 0;\n\tmcsp->cb_command = FXP_CB_COMMAND_MCAS | FXP_CB_COMMAND_S | FXP_CB_COMMAND_I;\n\tmcsp->link_addr = vtophys(&sc->cbl_base->cb_status);\n\n\tnmcasts = 0;\n\tif (!sc->all_mcasts) {\n\t\tETHER_FIRST_MULTI(step, &sc->arpcom, enm);\n\t\twhile (enm != NULL) {\n\t\t\tif (nmcasts >= MAXMCADDR) {\n\t\t\t\tsc->all_mcasts = 1;\n\t\t\t\tnmcasts = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Punt on ranges. */\n\t\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi,\n\t\t\t    sizeof(enm->enm_addrlo)) != 0) {\n\t\t\t\tsc->all_mcasts = 1;\n\t\t\t\tnmcasts = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbcopy(enm->enm_addrlo,\n\t\t\t    (void *) &sc->mcsp->mc_addr[nmcasts][0], 6);\n\t\t\tnmcasts++;\n\t\t\tETHER_NEXT_MULTI(step, enm);\n\t\t}\n\t}\n\tmcsp->mc_cnt = nmcasts * 6;\n\tsc->cbl_first = sc->cbl_last = (struct fxp_cb_tx *) mcsp;\n\tsc->tx_queued = 1;\n\n\t/*\n\t * Wait until command unit is not active. This should never\n\t * be the case when nothing is queued, but make sure anyway.\n\t */\n\twhile ((CSR_READ_1(sc, FXP_CSR_SCB_RUSCUS) >> 6) ==\n\t    FXP_SCB_CUS_ACTIVE) ;\n\n\t/*\n\t * Start the multicast setup command.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, vtophys(&mcsp->cb_status));\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\n\tifp->if_timer = 2;\n\treturn;\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/ic/fxpvar.h>",
      "#include <dev/ic/fxpreg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void fxp_scb_wait",
      "void fxp_start",
      "void fxp_mc_setup"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_1",
          "args": [
            "sc",
            "FXP_CSR_SCB_COMMAND",
            "FXP_SCB_COMMAND_CU_START"
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "FXP_CSR_SCB_GENERAL",
            "vtophys(&mcsp->cb_status)"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&mcsp->cb_status"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fxp_scb_wait",
          "args": [
            "sc"
          ],
          "line": 1598
        },
        "resolved": true,
        "details": {
          "function_name": "fxp_scb_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
          "lines": "237-244",
          "snippet": "static inline void\nfxp_scb_wait(sc)\n\tstruct fxp_softc *sc;\n{\n\tint i = 10000;\n\n\twhile (CSR_READ_1(sc, FXP_CSR_SCB_COMMAND) && --i);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/ic/fxpvar.h>",
            "#include <dev/ic/fxpreg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void fxp_scb_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic inline void fxp_scb_wait;\n\nstatic inline void\nfxp_scb_wait(sc)\n\tstruct fxp_softc *sc;\n{\n\tint i = 10000;\n\n\twhile (CSR_READ_1(sc, FXP_CSR_SCB_COMMAND) && --i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_READ_1",
          "args": [
            "sc",
            "FXP_CSR_SCB_RUSCUS"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ETHER_NEXT_MULTI",
          "args": [
            "step",
            "enm"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "enm->enm_addrlo",
            "(void *) &sc->mcsp->mc_addr[nmcasts][0]",
            "6"
          ],
          "line": 1578
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "enm->enm_addrlo",
            "enm->enm_addrhi",
            "sizeof(enm->enm_addrlo)"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ETHER_FIRST_MULTI",
          "args": [
            "step",
            "&sc->arpcom",
            "enm"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&sc->cbl_base->cb_status"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_1",
          "args": [
            "sc",
            "FXP_CSR_SCB_COMMAND",
            "FXP_SCB_COMMAND_CU_RESUME"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic inline void fxp_scb_wait;\nvoid fxp_start;\nvoid fxp_mc_setup;\n\nvoid\nfxp_mc_setup(sc)\n\tstruct fxp_softc *sc;\n{\n\tstruct fxp_cb_mcs *mcsp = sc->mcsp;\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tstruct ether_multistep step;\n\tstruct ether_multi *enm;\n\tint nmcasts;\n\n\t/*\n\t * If there are queued commands, we must wait until they are all\n\t * completed. If we are already waiting, then add a NOP command\n\t * with interrupt option so that we're notified when all commands\n\t * have been completed - fxp_start() ensures that no additional\n\t * TX commands will be added when need_mcsetup is true.\n\t */\n\tif (sc->tx_queued) {\n\t\tstruct fxp_cb_tx *txp;\n\n\t\t/*\n\t\t * need_mcsetup will be true if we are already waiting for the\n\t\t * NOP command to be completed (see below). In this case, bail.\n\t\t */\n\t\tif (sc->need_mcsetup)\n\t\t\treturn;\n\t\tsc->need_mcsetup = 1;\n\n\t\t/*\n\t\t * Add a NOP command with interrupt so that we are notified when all\n\t\t * TX commands have been processed.\n\t\t */\n\t\ttxp = sc->cbl_last->next;\n\t\ttxp->mb_head = NULL;\n\t\ttxp->cb_status = 0;\n\t\ttxp->cb_command = FXP_CB_COMMAND_NOP | FXP_CB_COMMAND_S | FXP_CB_COMMAND_I;\n\t\t/*\n\t\t * Advance the end of list forward.\n\t\t */\n\t\tsc->cbl_last->cb_command &= ~FXP_CB_COMMAND_S;\n\t\tsc->cbl_last = txp;\n\t\tsc->tx_queued++;\n\t\t/*\n\t\t * Issue a resume in case the CU has just suspended.\n\t\t */\n\t\tfxp_scb_wait(sc);\n\t\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_RESUME);\n\t\t/*\n\t\t * Set a 5 second timer just in case we don't hear from the\n\t\t * card again.\n\t\t */\n\t\tifp->if_timer = 5;\n\n\t\treturn;\n\t}\n\tsc->need_mcsetup = 0;\n\n\t/*\n\t * Initialize multicast setup descriptor.\n\t */\n\tmcsp->next = sc->cbl_base;\n\tmcsp->mb_head = NULL;\n\tmcsp->cb_status = 0;\n\tmcsp->cb_command = FXP_CB_COMMAND_MCAS | FXP_CB_COMMAND_S | FXP_CB_COMMAND_I;\n\tmcsp->link_addr = vtophys(&sc->cbl_base->cb_status);\n\n\tnmcasts = 0;\n\tif (!sc->all_mcasts) {\n\t\tETHER_FIRST_MULTI(step, &sc->arpcom, enm);\n\t\twhile (enm != NULL) {\n\t\t\tif (nmcasts >= MAXMCADDR) {\n\t\t\t\tsc->all_mcasts = 1;\n\t\t\t\tnmcasts = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Punt on ranges. */\n\t\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi,\n\t\t\t    sizeof(enm->enm_addrlo)) != 0) {\n\t\t\t\tsc->all_mcasts = 1;\n\t\t\t\tnmcasts = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbcopy(enm->enm_addrlo,\n\t\t\t    (void *) &sc->mcsp->mc_addr[nmcasts][0], 6);\n\t\t\tnmcasts++;\n\t\t\tETHER_NEXT_MULTI(step, enm);\n\t\t}\n\t}\n\tmcsp->mc_cnt = nmcasts * 6;\n\tsc->cbl_first = sc->cbl_last = (struct fxp_cb_tx *) mcsp;\n\tsc->tx_queued = 1;\n\n\t/*\n\t * Wait until command unit is not active. This should never\n\t * be the case when nothing is queued, but make sure anyway.\n\t */\n\twhile ((CSR_READ_1(sc, FXP_CSR_SCB_RUSCUS) >> 6) ==\n\t    FXP_SCB_CUS_ACTIVE) ;\n\n\t/*\n\t * Start the multicast setup command.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, vtophys(&mcsp->cb_status));\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\n\tifp->if_timer = 2;\n\treturn;\n}"
  },
  {
    "function_name": "fxp_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
    "lines": "1402-1479",
    "snippet": "int\nfxp_ioctl(ifp, command, data)\n\tstruct ifnet *ifp;\n\tu_long command;\n\tcaddr_t data;\n{\n\tstruct fxp_softc *sc = ifp->if_softc;\n\tstruct ifreq *ifr = (struct ifreq *)data;\n\tint s, error = 0;\n\n\ts = splimp();\n\n\tswitch (command) {\n\n\tcase SIOCSIFADDR:\n\tcase SIOCGIFADDR:\n\t\terror = ether_ioctl(ifp, command, data);\n\t\tbreak;\n\n\tcase SIOCSIFMTU:\n\t\tif (ifr->ifr_mtu > ETHERMTU || ifr->ifr_mtu < ETHERMIN) {\n\t\t\terror = EINVAL;\n\t\t} else if (ifp->if_mtu != ifr->ifr_mtu) {\n\t\t\tifp->if_mtu = ifr->ifr_mtu;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS:\n\t\tsc->all_mcasts = (ifp->if_flags & IFF_ALLMULTI) ? 1 : 0;\n\n\t\t/*\n\t\t * If interface is marked up and not running, then start it.\n\t\t * If it is marked down and running, stop it.\n\t\t * XXX If it's up then re-initialize it. This is so flags\n\t\t * such as IFF_PROMISC are handled.\n\t\t */\n\t\tif (ifp->if_flags & IFF_UP) {\n\t\t\tfxp_init(sc);\n\t\t} else {\n\t\t\tif (ifp->if_flags & IFF_RUNNING)\n\t\t\t\tfxp_stop(sc, 1);\n\t\t}\n\t\tbreak;\n\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\tsc->all_mcasts = (ifp->if_flags & IFF_ALLMULTI) ? 1 : 0;\n\t\terror = (command == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->arpcom) :\n\t\t    ether_delmulti(ifr, &sc->arpcom);\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware\n\t\t\t * filter accordingly.\n\t\t\t */\n\t\t\tif (!sc->all_mcasts)\n\t\t\t\tfxp_mc_setup(sc);\n\t\t\t/*\n\t\t\t * fxp_mc_setup() can turn on all_mcasts if we run\n\t\t\t * out of space, so check it again rather than else {}.\n\t\t\t */\n\t\t\tif (sc->all_mcasts)\n\t\t\t\tfxp_init(sc);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFMEDIA:\n\tcase SIOCGIFMEDIA:\n\t\terror = ifmedia_ioctl(ifp, ifr, &sc->sc_mii.mii_media, command);\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t}\n\t(void) splx(s);\n\treturn (error);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/ic/fxpvar.h>",
      "#include <dev/ic/fxpreg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define\tether_ioctl\tfxp_ether_ioctl"
    ],
    "globals_used": [
      "int fxp_ioctl",
      "void fxp_init",
      "void fxp_stop",
      "void fxp_mc_setup"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_ioctl",
          "args": [
            "ifp",
            "ifr",
            "&sc->sc_mii.mii_media",
            "command"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fxp_init",
          "args": [
            "sc"
          ],
          "line": 1464
        },
        "resolved": true,
        "details": {
          "function_name": "fxp_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
          "lines": "1075-1234",
          "snippet": "void\nfxp_init(xsc)\n\tvoid *xsc;\n{\n\tstruct fxp_softc *sc = xsc;\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tstruct fxp_cb_config *cbp;\n\tstruct fxp_cb_ias *cb_ias;\n\tstruct fxp_cb_tx *txp;\n\tint i, s, prm;\n\n\ts = splimp();\n\t/*\n\t * Cancel any pending I/O\n\t */\n\tfxp_stop(sc, 0);\n\n\tprm = (ifp->if_flags & IFF_PROMISC) ? 1 : 0;\n\n\t/*\n\t * Initialize base of CBL and RFA memory. Loading with zero\n\t * sets it up for regular linear addressing.\n\t */\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, 0);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_BASE);\n\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_RU_BASE);\n\n\t/*\n\t * Initialize base of dump-stats buffer.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, vtophys(sc->fxp_stats));\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_DUMP_ADR);\n\n\t/*\n\t * We temporarily use memory that contains the TxCB list to\n\t * construct the config CB. The TxCB list memory is rebuilt\n\t * later.\n\t */\n\tcbp = (struct fxp_cb_config *) sc->cbl_base;\n\n\t/*\n\t * This bcopy is kind of disgusting, but there are a bunch of must be\n\t * zero and must be one bits in this structure and this is the easiest\n\t * way to initialize them all to proper values.\n\t */\n\tbcopy(fxp_cb_config_template, (void *)&cbp->cb_status,\n\t\tsizeof(fxp_cb_config_template));\n\n\tcbp->cb_status =\t0;\n\tcbp->cb_command =\tFXP_CB_COMMAND_CONFIG | FXP_CB_COMMAND_EL;\n\tcbp->link_addr =\t-1;\t/* (no) next command */\n\tcbp->byte_count =\t22;\t/* (22) bytes to config */\n\tcbp->rx_fifo_limit =\t8;\t/* rx fifo threshold (32 bytes) */\n\tcbp->tx_fifo_limit =\t0;\t/* tx fifo threshold (0 bytes) */\n\tcbp->adaptive_ifs =\t0;\t/* (no) adaptive interframe spacing */\n\tcbp->rx_dma_bytecount =\t0;\t/* (no) rx DMA max */\n\tcbp->tx_dma_bytecount =\t0;\t/* (no) tx DMA max */\n\tcbp->dma_bce =\t\t0;\t/* (disable) dma max counters */\n\tcbp->late_scb =\t\t0;\t/* (don't) defer SCB update */\n\tcbp->tno_int =\t\t0;\t/* (disable) tx not okay interrupt */\n\tcbp->ci_int =\t\t1;\t/* interrupt on CU idle */\n\tcbp->save_bf =\t\tprm;\t/* save bad frames */\n\tcbp->disc_short_rx =\t!prm;\t/* discard short packets */\n\tcbp->underrun_retry =\t1;\t/* retry mode (1) on DMA underrun */\n\tcbp->mediatype =\t!sc->phy_10Mbps_only; /* interface mode */\n\tcbp->nsai =\t\t1;\t/* (don't) disable source addr insert */\n\tcbp->preamble_length =\t2;\t/* (7 byte) preamble */\n\tcbp->loopback =\t\t0;\t/* (don't) loopback */\n\tcbp->linear_priority =\t0;\t/* (normal CSMA/CD operation) */\n\tcbp->linear_pri_mode =\t0;\t/* (wait after xmit only) */\n\tcbp->interfrm_spacing =\t6;\t/* (96 bits of) interframe spacing */\n\tcbp->promiscuous =\tprm;\t/* promiscuous mode */\n\tcbp->bcast_disable =\t0;\t/* (don't) disable broadcasts */\n\tcbp->crscdt =\t\t0;\t/* (CRS only) */\n\tcbp->stripping =\t!prm;\t/* truncate rx packet to byte count */\n\tcbp->padding =\t\t1;\t/* (do) pad short tx packets */\n\tcbp->rcv_crc_xfer =\t0;\t/* (don't) xfer CRC to host */\n\tcbp->long_rx =\t\tsc->not_82557; /* (enable) long packets */\n\tcbp->force_fdx =\t0;\t/* (don't) force full duplex */\n\tcbp->fdx_pin_en =\t1;\t/* (enable) FDX# pin */\n\tcbp->multi_ia =\t\t0;\t/* (don't) accept multiple IAs */\n\tcbp->mc_all =\t\tsc->all_mcasts;/* accept all multicasts */\n\n\t/*\n\t * Start the config command/DMA.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, vtophys(&cbp->cb_status));\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\t/* ...and wait for it to complete. */\n\twhile (!(cbp->cb_status & FXP_CB_STATUS_C));\n\n\t/*\n\t * Now initialize the station address. Temporarily use the TxCB\n\t * memory area like we did above for the config CB.\n\t */\n\tcb_ias = (struct fxp_cb_ias *) sc->cbl_base;\n\tcb_ias->cb_status = 0;\n\tcb_ias->cb_command = FXP_CB_COMMAND_IAS | FXP_CB_COMMAND_EL;\n\tcb_ias->link_addr = -1;\n\tbcopy(sc->arpcom.ac_enaddr, (void *)cb_ias->macaddr,\n\t    sizeof(sc->arpcom.ac_enaddr));\n\n\t/*\n\t * Start the IAS (Individual Address Setup) command/DMA.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\t/* ...and wait for it to complete. */\n\twhile (!(cb_ias->cb_status & FXP_CB_STATUS_C));\n\n\t/*\n\t * Initialize transmit control block (TxCB) list.\n\t */\n\n\ttxp = sc->cbl_base;\n\tbzero(txp, sizeof(struct fxp_cb_tx) * FXP_NTXCB);\n\tfor (i = 0; i < FXP_NTXCB; i++) {\n\t\ttxp[i].cb_status = FXP_CB_STATUS_C | FXP_CB_STATUS_OK;\n\t\ttxp[i].cb_command = FXP_CB_COMMAND_NOP;\n\t\ttxp[i].link_addr = vtophys(&txp[(i + 1) & FXP_TXCB_MASK].cb_status);\n\t\ttxp[i].tbd_array_addr = vtophys(&txp[i].tbd[0]);\n\t\ttxp[i].next = &txp[(i + 1) & FXP_TXCB_MASK];\n\t}\n\t/*\n\t * Set the suspend flag on the first TxCB and start the control\n\t * unit. It will execute the NOP and then suspend.\n\t */\n\ttxp->cb_command = FXP_CB_COMMAND_NOP | FXP_CB_COMMAND_S;\n\tsc->cbl_first = sc->cbl_last = txp;\n\tsc->tx_queued = 1;\n\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\n\t/*\n\t * Initialize receiver buffer area - RFA.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL,\n\t    vtophys(sc->rfa_headm->m_ext.ext_buf) + RFA_ALIGNMENT_FUDGE);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_RU_START);\n\n\t/*\n\t * Set current media.\n\t */\n\tmii_mediachg(&sc->sc_mii);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tsplx(s);\n\n\t/*\n\t * Start stats updater.\n\t */\n\ttimeout(fxp_stats_update, sc, hz);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/ic/fxpvar.h>",
            "#include <dev/ic/fxpreg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define FXP_TXCB_MASK\t(FXP_NTXCB - 1)",
            "#define FXP_NTXCB\t128",
            "#define\tRFA_ALIGNMENT_FUDGE\t2"
          ],
          "globals_used": [
            "static u_char fxp_cb_config_template[] = {\n\t0x0, 0x0,\t\t/* cb_status */\n\t0x80, 0x2,\t\t/* cb_command */\n\t0xff, 0xff, 0xff, 0xff,\t/* link_addr */\n\t0x16,\t/*  0 */\n\t0x8,\t/*  1 */\n\t0x0,\t/*  2 */\n\t0x0,\t/*  3 */\n\t0x0,\t/*  4 */\n\t0x80,\t/*  5 */\n\t0xb2,\t/*  6 */\n\t0x3,\t/*  7 */\n\t0x1,\t/*  8 */\n\t0x0,\t/*  9 */\n\t0x26,\t/* 10 */\n\t0x0,\t/* 11 */\n\t0x60,\t/* 12 */\n\t0x0,\t/* 13 */\n\t0xf2,\t/* 14 */\n\t0x48,\t/* 15 */\n\t0x0,\t/* 16 */\n\t0x40,\t/* 17 */\n\t0xf3,\t/* 18 */\n\t0x0,\t/* 19 */\n\t0x3f,\t/* 20 */\n\t0x5\t/* 21 */\n};",
            "static inline void fxp_scb_wait",
            "void fxp_init",
            "void fxp_stop",
            "void fxp_stats_update"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define FXP_TXCB_MASK\t(FXP_NTXCB - 1)\n#define FXP_NTXCB\t128\n#define\tRFA_ALIGNMENT_FUDGE\t2\n\nstatic u_char fxp_cb_config_template[] = {\n\t0x0, 0x0,\t\t/* cb_status */\n\t0x80, 0x2,\t\t/* cb_command */\n\t0xff, 0xff, 0xff, 0xff,\t/* link_addr */\n\t0x16,\t/*  0 */\n\t0x8,\t/*  1 */\n\t0x0,\t/*  2 */\n\t0x0,\t/*  3 */\n\t0x0,\t/*  4 */\n\t0x80,\t/*  5 */\n\t0xb2,\t/*  6 */\n\t0x3,\t/*  7 */\n\t0x1,\t/*  8 */\n\t0x0,\t/*  9 */\n\t0x26,\t/* 10 */\n\t0x0,\t/* 11 */\n\t0x60,\t/* 12 */\n\t0x0,\t/* 13 */\n\t0xf2,\t/* 14 */\n\t0x48,\t/* 15 */\n\t0x0,\t/* 16 */\n\t0x40,\t/* 17 */\n\t0xf3,\t/* 18 */\n\t0x0,\t/* 19 */\n\t0x3f,\t/* 20 */\n\t0x5\t/* 21 */\n};\nstatic inline void fxp_scb_wait;\nvoid fxp_init;\nvoid fxp_stop;\nvoid fxp_stats_update;\n\nvoid\nfxp_init(xsc)\n\tvoid *xsc;\n{\n\tstruct fxp_softc *sc = xsc;\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tstruct fxp_cb_config *cbp;\n\tstruct fxp_cb_ias *cb_ias;\n\tstruct fxp_cb_tx *txp;\n\tint i, s, prm;\n\n\ts = splimp();\n\t/*\n\t * Cancel any pending I/O\n\t */\n\tfxp_stop(sc, 0);\n\n\tprm = (ifp->if_flags & IFF_PROMISC) ? 1 : 0;\n\n\t/*\n\t * Initialize base of CBL and RFA memory. Loading with zero\n\t * sets it up for regular linear addressing.\n\t */\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, 0);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_BASE);\n\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_RU_BASE);\n\n\t/*\n\t * Initialize base of dump-stats buffer.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, vtophys(sc->fxp_stats));\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_DUMP_ADR);\n\n\t/*\n\t * We temporarily use memory that contains the TxCB list to\n\t * construct the config CB. The TxCB list memory is rebuilt\n\t * later.\n\t */\n\tcbp = (struct fxp_cb_config *) sc->cbl_base;\n\n\t/*\n\t * This bcopy is kind of disgusting, but there are a bunch of must be\n\t * zero and must be one bits in this structure and this is the easiest\n\t * way to initialize them all to proper values.\n\t */\n\tbcopy(fxp_cb_config_template, (void *)&cbp->cb_status,\n\t\tsizeof(fxp_cb_config_template));\n\n\tcbp->cb_status =\t0;\n\tcbp->cb_command =\tFXP_CB_COMMAND_CONFIG | FXP_CB_COMMAND_EL;\n\tcbp->link_addr =\t-1;\t/* (no) next command */\n\tcbp->byte_count =\t22;\t/* (22) bytes to config */\n\tcbp->rx_fifo_limit =\t8;\t/* rx fifo threshold (32 bytes) */\n\tcbp->tx_fifo_limit =\t0;\t/* tx fifo threshold (0 bytes) */\n\tcbp->adaptive_ifs =\t0;\t/* (no) adaptive interframe spacing */\n\tcbp->rx_dma_bytecount =\t0;\t/* (no) rx DMA max */\n\tcbp->tx_dma_bytecount =\t0;\t/* (no) tx DMA max */\n\tcbp->dma_bce =\t\t0;\t/* (disable) dma max counters */\n\tcbp->late_scb =\t\t0;\t/* (don't) defer SCB update */\n\tcbp->tno_int =\t\t0;\t/* (disable) tx not okay interrupt */\n\tcbp->ci_int =\t\t1;\t/* interrupt on CU idle */\n\tcbp->save_bf =\t\tprm;\t/* save bad frames */\n\tcbp->disc_short_rx =\t!prm;\t/* discard short packets */\n\tcbp->underrun_retry =\t1;\t/* retry mode (1) on DMA underrun */\n\tcbp->mediatype =\t!sc->phy_10Mbps_only; /* interface mode */\n\tcbp->nsai =\t\t1;\t/* (don't) disable source addr insert */\n\tcbp->preamble_length =\t2;\t/* (7 byte) preamble */\n\tcbp->loopback =\t\t0;\t/* (don't) loopback */\n\tcbp->linear_priority =\t0;\t/* (normal CSMA/CD operation) */\n\tcbp->linear_pri_mode =\t0;\t/* (wait after xmit only) */\n\tcbp->interfrm_spacing =\t6;\t/* (96 bits of) interframe spacing */\n\tcbp->promiscuous =\tprm;\t/* promiscuous mode */\n\tcbp->bcast_disable =\t0;\t/* (don't) disable broadcasts */\n\tcbp->crscdt =\t\t0;\t/* (CRS only) */\n\tcbp->stripping =\t!prm;\t/* truncate rx packet to byte count */\n\tcbp->padding =\t\t1;\t/* (do) pad short tx packets */\n\tcbp->rcv_crc_xfer =\t0;\t/* (don't) xfer CRC to host */\n\tcbp->long_rx =\t\tsc->not_82557; /* (enable) long packets */\n\tcbp->force_fdx =\t0;\t/* (don't) force full duplex */\n\tcbp->fdx_pin_en =\t1;\t/* (enable) FDX# pin */\n\tcbp->multi_ia =\t\t0;\t/* (don't) accept multiple IAs */\n\tcbp->mc_all =\t\tsc->all_mcasts;/* accept all multicasts */\n\n\t/*\n\t * Start the config command/DMA.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, vtophys(&cbp->cb_status));\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\t/* ...and wait for it to complete. */\n\twhile (!(cbp->cb_status & FXP_CB_STATUS_C));\n\n\t/*\n\t * Now initialize the station address. Temporarily use the TxCB\n\t * memory area like we did above for the config CB.\n\t */\n\tcb_ias = (struct fxp_cb_ias *) sc->cbl_base;\n\tcb_ias->cb_status = 0;\n\tcb_ias->cb_command = FXP_CB_COMMAND_IAS | FXP_CB_COMMAND_EL;\n\tcb_ias->link_addr = -1;\n\tbcopy(sc->arpcom.ac_enaddr, (void *)cb_ias->macaddr,\n\t    sizeof(sc->arpcom.ac_enaddr));\n\n\t/*\n\t * Start the IAS (Individual Address Setup) command/DMA.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\t/* ...and wait for it to complete. */\n\twhile (!(cb_ias->cb_status & FXP_CB_STATUS_C));\n\n\t/*\n\t * Initialize transmit control block (TxCB) list.\n\t */\n\n\ttxp = sc->cbl_base;\n\tbzero(txp, sizeof(struct fxp_cb_tx) * FXP_NTXCB);\n\tfor (i = 0; i < FXP_NTXCB; i++) {\n\t\ttxp[i].cb_status = FXP_CB_STATUS_C | FXP_CB_STATUS_OK;\n\t\ttxp[i].cb_command = FXP_CB_COMMAND_NOP;\n\t\ttxp[i].link_addr = vtophys(&txp[(i + 1) & FXP_TXCB_MASK].cb_status);\n\t\ttxp[i].tbd_array_addr = vtophys(&txp[i].tbd[0]);\n\t\ttxp[i].next = &txp[(i + 1) & FXP_TXCB_MASK];\n\t}\n\t/*\n\t * Set the suspend flag on the first TxCB and start the control\n\t * unit. It will execute the NOP and then suspend.\n\t */\n\ttxp->cb_command = FXP_CB_COMMAND_NOP | FXP_CB_COMMAND_S;\n\tsc->cbl_first = sc->cbl_last = txp;\n\tsc->tx_queued = 1;\n\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\n\t/*\n\t * Initialize receiver buffer area - RFA.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL,\n\t    vtophys(sc->rfa_headm->m_ext.ext_buf) + RFA_ALIGNMENT_FUDGE);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_RU_START);\n\n\t/*\n\t * Set current media.\n\t */\n\tmii_mediachg(&sc->sc_mii);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tsplx(s);\n\n\t/*\n\t * Start stats updater.\n\t */\n\ttimeout(fxp_stats_update, sc, hz);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fxp_mc_setup",
          "args": [
            "sc"
          ],
          "line": 1458
        },
        "resolved": true,
        "details": {
          "function_name": "fxp_mc_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
          "lines": "1495-1604",
          "snippet": "void\nfxp_mc_setup(sc)\n\tstruct fxp_softc *sc;\n{\n\tstruct fxp_cb_mcs *mcsp = sc->mcsp;\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tstruct ether_multistep step;\n\tstruct ether_multi *enm;\n\tint nmcasts;\n\n\t/*\n\t * If there are queued commands, we must wait until they are all\n\t * completed. If we are already waiting, then add a NOP command\n\t * with interrupt option so that we're notified when all commands\n\t * have been completed - fxp_start() ensures that no additional\n\t * TX commands will be added when need_mcsetup is true.\n\t */\n\tif (sc->tx_queued) {\n\t\tstruct fxp_cb_tx *txp;\n\n\t\t/*\n\t\t * need_mcsetup will be true if we are already waiting for the\n\t\t * NOP command to be completed (see below). In this case, bail.\n\t\t */\n\t\tif (sc->need_mcsetup)\n\t\t\treturn;\n\t\tsc->need_mcsetup = 1;\n\n\t\t/*\n\t\t * Add a NOP command with interrupt so that we are notified when all\n\t\t * TX commands have been processed.\n\t\t */\n\t\ttxp = sc->cbl_last->next;\n\t\ttxp->mb_head = NULL;\n\t\ttxp->cb_status = 0;\n\t\ttxp->cb_command = FXP_CB_COMMAND_NOP | FXP_CB_COMMAND_S | FXP_CB_COMMAND_I;\n\t\t/*\n\t\t * Advance the end of list forward.\n\t\t */\n\t\tsc->cbl_last->cb_command &= ~FXP_CB_COMMAND_S;\n\t\tsc->cbl_last = txp;\n\t\tsc->tx_queued++;\n\t\t/*\n\t\t * Issue a resume in case the CU has just suspended.\n\t\t */\n\t\tfxp_scb_wait(sc);\n\t\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_RESUME);\n\t\t/*\n\t\t * Set a 5 second timer just in case we don't hear from the\n\t\t * card again.\n\t\t */\n\t\tifp->if_timer = 5;\n\n\t\treturn;\n\t}\n\tsc->need_mcsetup = 0;\n\n\t/*\n\t * Initialize multicast setup descriptor.\n\t */\n\tmcsp->next = sc->cbl_base;\n\tmcsp->mb_head = NULL;\n\tmcsp->cb_status = 0;\n\tmcsp->cb_command = FXP_CB_COMMAND_MCAS | FXP_CB_COMMAND_S | FXP_CB_COMMAND_I;\n\tmcsp->link_addr = vtophys(&sc->cbl_base->cb_status);\n\n\tnmcasts = 0;\n\tif (!sc->all_mcasts) {\n\t\tETHER_FIRST_MULTI(step, &sc->arpcom, enm);\n\t\twhile (enm != NULL) {\n\t\t\tif (nmcasts >= MAXMCADDR) {\n\t\t\t\tsc->all_mcasts = 1;\n\t\t\t\tnmcasts = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Punt on ranges. */\n\t\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi,\n\t\t\t    sizeof(enm->enm_addrlo)) != 0) {\n\t\t\t\tsc->all_mcasts = 1;\n\t\t\t\tnmcasts = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbcopy(enm->enm_addrlo,\n\t\t\t    (void *) &sc->mcsp->mc_addr[nmcasts][0], 6);\n\t\t\tnmcasts++;\n\t\t\tETHER_NEXT_MULTI(step, enm);\n\t\t}\n\t}\n\tmcsp->mc_cnt = nmcasts * 6;\n\tsc->cbl_first = sc->cbl_last = (struct fxp_cb_tx *) mcsp;\n\tsc->tx_queued = 1;\n\n\t/*\n\t * Wait until command unit is not active. This should never\n\t * be the case when nothing is queued, but make sure anyway.\n\t */\n\twhile ((CSR_READ_1(sc, FXP_CSR_SCB_RUSCUS) >> 6) ==\n\t    FXP_SCB_CUS_ACTIVE) ;\n\n\t/*\n\t * Start the multicast setup command.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, vtophys(&mcsp->cb_status));\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\n\tifp->if_timer = 2;\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/ic/fxpvar.h>",
            "#include <dev/ic/fxpreg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void fxp_scb_wait",
            "void fxp_start",
            "void fxp_mc_setup"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic inline void fxp_scb_wait;\nvoid fxp_start;\nvoid fxp_mc_setup;\n\nvoid\nfxp_mc_setup(sc)\n\tstruct fxp_softc *sc;\n{\n\tstruct fxp_cb_mcs *mcsp = sc->mcsp;\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tstruct ether_multistep step;\n\tstruct ether_multi *enm;\n\tint nmcasts;\n\n\t/*\n\t * If there are queued commands, we must wait until they are all\n\t * completed. If we are already waiting, then add a NOP command\n\t * with interrupt option so that we're notified when all commands\n\t * have been completed - fxp_start() ensures that no additional\n\t * TX commands will be added when need_mcsetup is true.\n\t */\n\tif (sc->tx_queued) {\n\t\tstruct fxp_cb_tx *txp;\n\n\t\t/*\n\t\t * need_mcsetup will be true if we are already waiting for the\n\t\t * NOP command to be completed (see below). In this case, bail.\n\t\t */\n\t\tif (sc->need_mcsetup)\n\t\t\treturn;\n\t\tsc->need_mcsetup = 1;\n\n\t\t/*\n\t\t * Add a NOP command with interrupt so that we are notified when all\n\t\t * TX commands have been processed.\n\t\t */\n\t\ttxp = sc->cbl_last->next;\n\t\ttxp->mb_head = NULL;\n\t\ttxp->cb_status = 0;\n\t\ttxp->cb_command = FXP_CB_COMMAND_NOP | FXP_CB_COMMAND_S | FXP_CB_COMMAND_I;\n\t\t/*\n\t\t * Advance the end of list forward.\n\t\t */\n\t\tsc->cbl_last->cb_command &= ~FXP_CB_COMMAND_S;\n\t\tsc->cbl_last = txp;\n\t\tsc->tx_queued++;\n\t\t/*\n\t\t * Issue a resume in case the CU has just suspended.\n\t\t */\n\t\tfxp_scb_wait(sc);\n\t\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_RESUME);\n\t\t/*\n\t\t * Set a 5 second timer just in case we don't hear from the\n\t\t * card again.\n\t\t */\n\t\tifp->if_timer = 5;\n\n\t\treturn;\n\t}\n\tsc->need_mcsetup = 0;\n\n\t/*\n\t * Initialize multicast setup descriptor.\n\t */\n\tmcsp->next = sc->cbl_base;\n\tmcsp->mb_head = NULL;\n\tmcsp->cb_status = 0;\n\tmcsp->cb_command = FXP_CB_COMMAND_MCAS | FXP_CB_COMMAND_S | FXP_CB_COMMAND_I;\n\tmcsp->link_addr = vtophys(&sc->cbl_base->cb_status);\n\n\tnmcasts = 0;\n\tif (!sc->all_mcasts) {\n\t\tETHER_FIRST_MULTI(step, &sc->arpcom, enm);\n\t\twhile (enm != NULL) {\n\t\t\tif (nmcasts >= MAXMCADDR) {\n\t\t\t\tsc->all_mcasts = 1;\n\t\t\t\tnmcasts = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Punt on ranges. */\n\t\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi,\n\t\t\t    sizeof(enm->enm_addrlo)) != 0) {\n\t\t\t\tsc->all_mcasts = 1;\n\t\t\t\tnmcasts = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbcopy(enm->enm_addrlo,\n\t\t\t    (void *) &sc->mcsp->mc_addr[nmcasts][0], 6);\n\t\t\tnmcasts++;\n\t\t\tETHER_NEXT_MULTI(step, enm);\n\t\t}\n\t}\n\tmcsp->mc_cnt = nmcasts * 6;\n\tsc->cbl_first = sc->cbl_last = (struct fxp_cb_tx *) mcsp;\n\tsc->tx_queued = 1;\n\n\t/*\n\t * Wait until command unit is not active. This should never\n\t * be the case when nothing is queued, but make sure anyway.\n\t */\n\twhile ((CSR_READ_1(sc, FXP_CSR_SCB_RUSCUS) >> 6) ==\n\t    FXP_SCB_CUS_ACTIVE) ;\n\n\t/*\n\t * Start the multicast setup command.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, vtophys(&mcsp->cb_status));\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\n\tifp->if_timer = 2;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_delmulti",
          "args": [
            "ifr",
            "&sc->arpcom"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_addmulti",
          "args": [
            "ifr",
            "&sc->arpcom"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fxp_stop",
          "args": [
            "sc",
            "1"
          ],
          "line": 1442
        },
        "resolved": true,
        "details": {
          "function_name": "fxp_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
          "lines": "998-1055",
          "snippet": "void\nfxp_stop(sc, drain)\n\tstruct fxp_softc *sc;\n\tint drain;\n{\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tstruct fxp_cb_tx *txp;\n\tint i;\n\n\t/*\n\t * Turn down interface (done early to avoid bad interactions\n\t * between panics, shutdown hooks, and the watchdog timer)\n\t */\n\tifp->if_timer = 0;\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\t/*\n\t * Cancel stats updater.\n\t */\n\tuntimeout(fxp_stats_update, sc);\n\n\t/*\n\t * Issue software reset\n\t */\n\tCSR_WRITE_4(sc, FXP_CSR_PORT, FXP_PORT_SELECTIVE_RESET);\n\tDELAY(10);\n\n\t/*\n\t * Release any xmit buffers.\n\t */\n\tfor (txp = sc->cbl_first; txp != NULL && txp->mb_head != NULL;\n\t    txp = txp->next) {\n\t\tm_freem(txp->mb_head);\n\t\ttxp->mb_head = NULL;\n\t}\n\tsc->tx_queued = 0;\n\n\tif (drain) {\n\t\t/*\n\t\t * Free all the receive buffers then reallocate/reinitialize\n\t\t */\n\t\tif (sc->rfa_headm != NULL)\n\t\t\tm_freem(sc->rfa_headm);\n\t\tsc->rfa_headm = NULL;\n\t\tsc->rfa_tailm = NULL;\n\t\tfor (i = 0; i < FXP_NRFABUFS; i++) {\n\t\t\tif (fxp_add_rfabuf(sc, NULL) != 0) {\n\t\t\t\t/*\n\t\t\t\t * This \"can't happen\" - we're at splimp()\n\t\t\t\t * and we just freed all the buffers we need\n\t\t\t\t * above.\n\t\t\t\t */\n\t\t\t\tpanic(\"fxp_stop: no buffers!\");\n\t\t\t}\n\t\t}\n\t}\n\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/ic/fxpvar.h>",
            "#include <dev/ic/fxpreg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define FXP_NRFABUFS\t64"
          ],
          "globals_used": [
            "void fxp_stop",
            "int fxp_add_rfabuf",
            "void fxp_stats_update"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define FXP_NRFABUFS\t64\n\nvoid fxp_stop;\nint fxp_add_rfabuf;\nvoid fxp_stats_update;\n\nvoid\nfxp_stop(sc, drain)\n\tstruct fxp_softc *sc;\n\tint drain;\n{\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tstruct fxp_cb_tx *txp;\n\tint i;\n\n\t/*\n\t * Turn down interface (done early to avoid bad interactions\n\t * between panics, shutdown hooks, and the watchdog timer)\n\t */\n\tifp->if_timer = 0;\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\t/*\n\t * Cancel stats updater.\n\t */\n\tuntimeout(fxp_stats_update, sc);\n\n\t/*\n\t * Issue software reset\n\t */\n\tCSR_WRITE_4(sc, FXP_CSR_PORT, FXP_PORT_SELECTIVE_RESET);\n\tDELAY(10);\n\n\t/*\n\t * Release any xmit buffers.\n\t */\n\tfor (txp = sc->cbl_first; txp != NULL && txp->mb_head != NULL;\n\t    txp = txp->next) {\n\t\tm_freem(txp->mb_head);\n\t\ttxp->mb_head = NULL;\n\t}\n\tsc->tx_queued = 0;\n\n\tif (drain) {\n\t\t/*\n\t\t * Free all the receive buffers then reallocate/reinitialize\n\t\t */\n\t\tif (sc->rfa_headm != NULL)\n\t\t\tm_freem(sc->rfa_headm);\n\t\tsc->rfa_headm = NULL;\n\t\tsc->rfa_tailm = NULL;\n\t\tfor (i = 0; i < FXP_NRFABUFS; i++) {\n\t\t\tif (fxp_add_rfabuf(sc, NULL) != 0) {\n\t\t\t\t/*\n\t\t\t\t * This \"can't happen\" - we're at splimp()\n\t\t\t\t * and we just freed all the buffers we need\n\t\t\t\t * above.\n\t\t\t\t */\n\t\t\t\tpanic(\"fxp_stop: no buffers!\");\n\t\t\t}\n\t\t}\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_ioctl",
          "args": [
            "ifp",
            "command",
            "data"
          ],
          "line": 1418
        },
        "resolved": true,
        "details": {
          "function_name": "fxp_ether_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
          "lines": "301-348",
          "snippet": "int\nfxp_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tstruct fxp_softc *sc = ifp->if_softc;\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tfxp_init(sc);\n\t\t\tarp_ifinit(&sc->arpcom, ifa);\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t    {\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t /* Set new address. */\n\t\t\t fxp_init(sc);\n\t\t\t break;\n\t\t    }\n#endif\n\t\tdefault:\n\t\t\tfxp_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/ic/fxpvar.h>",
            "#include <dev/ic/fxpreg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void fxp_init",
            "int\tfxp_ether_ioctl"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid fxp_init;\nint\tfxp_ether_ioctl;\n\nint\nfxp_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tstruct fxp_softc *sc = ifp->if_softc;\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tfxp_init(sc);\n\t\t\tarp_ifinit(&sc->arpcom, ifa);\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t    {\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t /* Set new address. */\n\t\t\t fxp_init(sc);\n\t\t\t break;\n\t\t    }\n#endif\n\t\tdefault:\n\t\t\tfxp_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tether_ioctl\tfxp_ether_ioctl\n\nint fxp_ioctl;\nvoid fxp_init;\nvoid fxp_stop;\nvoid fxp_mc_setup;\n\nint\nfxp_ioctl(ifp, command, data)\n\tstruct ifnet *ifp;\n\tu_long command;\n\tcaddr_t data;\n{\n\tstruct fxp_softc *sc = ifp->if_softc;\n\tstruct ifreq *ifr = (struct ifreq *)data;\n\tint s, error = 0;\n\n\ts = splimp();\n\n\tswitch (command) {\n\n\tcase SIOCSIFADDR:\n\tcase SIOCGIFADDR:\n\t\terror = ether_ioctl(ifp, command, data);\n\t\tbreak;\n\n\tcase SIOCSIFMTU:\n\t\tif (ifr->ifr_mtu > ETHERMTU || ifr->ifr_mtu < ETHERMIN) {\n\t\t\terror = EINVAL;\n\t\t} else if (ifp->if_mtu != ifr->ifr_mtu) {\n\t\t\tifp->if_mtu = ifr->ifr_mtu;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS:\n\t\tsc->all_mcasts = (ifp->if_flags & IFF_ALLMULTI) ? 1 : 0;\n\n\t\t/*\n\t\t * If interface is marked up and not running, then start it.\n\t\t * If it is marked down and running, stop it.\n\t\t * XXX If it's up then re-initialize it. This is so flags\n\t\t * such as IFF_PROMISC are handled.\n\t\t */\n\t\tif (ifp->if_flags & IFF_UP) {\n\t\t\tfxp_init(sc);\n\t\t} else {\n\t\t\tif (ifp->if_flags & IFF_RUNNING)\n\t\t\t\tfxp_stop(sc, 1);\n\t\t}\n\t\tbreak;\n\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\t\tsc->all_mcasts = (ifp->if_flags & IFF_ALLMULTI) ? 1 : 0;\n\t\terror = (command == SIOCADDMULTI) ?\n\t\t    ether_addmulti(ifr, &sc->arpcom) :\n\t\t    ether_delmulti(ifr, &sc->arpcom);\n\t\tif (error == ENETRESET) {\n\t\t\t/*\n\t\t\t * Multicast list has changed; set the hardware\n\t\t\t * filter accordingly.\n\t\t\t */\n\t\t\tif (!sc->all_mcasts)\n\t\t\t\tfxp_mc_setup(sc);\n\t\t\t/*\n\t\t\t * fxp_mc_setup() can turn on all_mcasts if we run\n\t\t\t * out of space, so check it again rather than else {}.\n\t\t\t */\n\t\t\tif (sc->all_mcasts)\n\t\t\t\tfxp_init(sc);\n\t\t\terror = 0;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFMEDIA:\n\tcase SIOCGIFMEDIA:\n\t\terror = ifmedia_ioctl(ifp, ifr, &sc->sc_mii.mii_media, command);\n\t\tbreak;\n\n\tdefault:\n\t\terror = EINVAL;\n\t}\n\t(void) splx(s);\n\treturn (error);\n}"
  },
  {
    "function_name": "fxp_mdi_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
    "lines": "1380-1400",
    "snippet": "void\nfxp_mdi_write(self, phy, reg, value)\n\tstruct device *self;\n\tint phy;\n\tint reg;\n\tint value;\n{\n\tstruct fxp_softc *sc = (struct fxp_softc *)self;\n\tint count = 10000;\n\n\tCSR_WRITE_4(sc, FXP_CSR_MDICONTROL,\n\t    (FXP_MDI_WRITE << 26) | (reg << 16) | (phy << 21) |\n\t    (value & 0xffff));\n\n\twhile((CSR_READ_4(sc, FXP_CSR_MDICONTROL) & 0x10000000) == 0 &&\n\t    count--)\n\t\tDELAY(10);\n\n\tif (count <= 0)\n\t\tprintf(\"%s: fxp_mdi_write: timed out\\n\", sc->sc_dev.dv_xname);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/ic/fxpvar.h>",
      "#include <dev/ic/fxpreg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void fxp_mdi_write"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: fxp_mdi_write: timed out\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "FXP_CSR_MDICONTROL"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "FXP_CSR_MDICONTROL",
            "(FXP_MDI_WRITE << 26) | (reg << 16) | (phy << 21) |\n\t    (value & 0xffff)"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid fxp_mdi_write;\n\nvoid\nfxp_mdi_write(self, phy, reg, value)\n\tstruct device *self;\n\tint phy;\n\tint reg;\n\tint value;\n{\n\tstruct fxp_softc *sc = (struct fxp_softc *)self;\n\tint count = 10000;\n\n\tCSR_WRITE_4(sc, FXP_CSR_MDICONTROL,\n\t    (FXP_MDI_WRITE << 26) | (reg << 16) | (phy << 21) |\n\t    (value & 0xffff));\n\n\twhile((CSR_READ_4(sc, FXP_CSR_MDICONTROL) & 0x10000000) == 0 &&\n\t    count--)\n\t\tDELAY(10);\n\n\tif (count <= 0)\n\t\tprintf(\"%s: fxp_mdi_write: timed out\\n\", sc->sc_dev.dv_xname);\n}"
  },
  {
    "function_name": "fxp_statchg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
    "lines": "1372-1378",
    "snippet": "void\nfxp_statchg(self)\n\tstruct device *self;\n{\n\n\t/* XXX Update ifp->if_baudrate */\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/ic/fxpvar.h>",
      "#include <dev/ic/fxpreg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void fxp_statchg"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid fxp_statchg;\n\nvoid\nfxp_statchg(self)\n\tstruct device *self;\n{\n\n\t/* XXX Update ifp->if_baudrate */\n}"
  },
  {
    "function_name": "fxp_mdi_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
    "lines": "1349-1370",
    "snippet": "volatile int\nfxp_mdi_read(self, phy, reg)\n\tstruct device *self;\n\tint phy;\n\tint reg;\n{\n\tstruct fxp_softc *sc = (struct fxp_softc *)self;\n\tint count = 10000;\n\tint value;\n\n\tCSR_WRITE_4(sc, FXP_CSR_MDICONTROL,\n\t    (FXP_MDI_READ << 26) | (reg << 16) | (phy << 21));\n\n\twhile (((value = CSR_READ_4(sc, FXP_CSR_MDICONTROL)) & 0x10000000) == 0\n\t    && count--)\n\t\tDELAY(10);\n\n\tif (count <= 0)\n\t\tprintf(\"%s: fxp_mdi_read: timed out\\n\", sc->sc_dev.dv_xname);\n\n\treturn (value & 0xffff);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/ic/fxpvar.h>",
      "#include <dev/ic/fxpreg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int fxp_mdi_read"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: fxp_mdi_read: timed out\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1367
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_4",
          "args": [
            "sc",
            "FXP_CSR_MDICONTROL"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "FXP_CSR_MDICONTROL",
            "(FXP_MDI_READ << 26) | (reg << 16) | (phy << 21)"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint fxp_mdi_read;\n\nvolatile int\nfxp_mdi_read(self, phy, reg)\n\tstruct device *self;\n\tint phy;\n\tint reg;\n{\n\tstruct fxp_softc *sc = (struct fxp_softc *)self;\n\tint count = 10000;\n\tint value;\n\n\tCSR_WRITE_4(sc, FXP_CSR_MDICONTROL,\n\t    (FXP_MDI_READ << 26) | (reg << 16) | (phy << 21));\n\n\twhile (((value = CSR_READ_4(sc, FXP_CSR_MDICONTROL)) & 0x10000000) == 0\n\t    && count--)\n\t\tDELAY(10);\n\n\tif (count <= 0)\n\t\tprintf(\"%s: fxp_mdi_read: timed out\\n\", sc->sc_dev.dv_xname);\n\n\treturn (value & 0xffff);\n}"
  },
  {
    "function_name": "fxp_add_rfabuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
    "lines": "1272-1347",
    "snippet": "int\nfxp_add_rfabuf(sc, oldm)\n\tstruct fxp_softc *sc;\n\tstruct mbuf *oldm;\n{\n\tu_int32_t v;\n\tstruct mbuf *m;\n\tu_int8_t *rfap;\n\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\tif (m != NULL) {\n\t\tMCLGET(m, M_DONTWAIT);\n\t\tif ((m->m_flags & M_EXT) == 0) {\n\t\t\tm_freem(m);\n\t\t\tif (oldm == NULL)\n\t\t\t\treturn 1;\n\t\t\tm = oldm;\n\t\t\tm->m_data = m->m_ext.ext_buf;\n\t\t}\n\t} else {\n\t\tif (oldm == NULL)\n\t\t\treturn 1;\n\t\tm = oldm;\n\t\tm->m_data = m->m_ext.ext_buf;\n\t}\n\n\t/*\n\t * Move the data pointer up so that the incoming data packet\n\t * will be 32-bit aligned.\n\t */\n\tm->m_data += RFA_ALIGNMENT_FUDGE;\n\n\t/*\n\t * Get a pointer to the base of the mbuf cluster and move\n\t * data start past it.\n\t */\n\trfap = m->m_data;\n\tm->m_data += sizeof(struct fxp_rfa);\n\t*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, size)) =\n\t    MCLBYTES - sizeof(struct fxp_rfa) - RFA_ALIGNMENT_FUDGE;\n\n\t/*\n\t * Initialize the rest of the RFA.  Note that since the RFA\n\t * is misaligned, we cannot store values directly.  Instead,\n\t * we use an optimized, inline copy.\n\t */\n\t*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, rfa_status)) = 0;\n\t*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, rfa_control)) =\n\t    FXP_RFA_CONTROL_EL;\n\t*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, actual_size)) = 0;\n\n\tv = -1;\n\tfxp_lwcopy(&v,\n\t    (u_int32_t *)(rfap + offsetof(struct fxp_rfa, link_addr)));\n\tfxp_lwcopy(&v,\n\t    (u_int32_t *)(rfap + offsetof(struct fxp_rfa, rbd_addr)));\n\n\t/*\n\t * If there are other buffers already on the list, attach this\n\t * one to the end by fixing up the tail to point to this one.\n\t */\n\tif (sc->rfa_headm != NULL) {\n\t\tsc->rfa_tailm->m_next = m;\n\t\tv = vtophys(rfap);\n\t\trfap = sc->rfa_tailm->m_ext.ext_buf + RFA_ALIGNMENT_FUDGE;\n\t\tfxp_lwcopy(&v,\n\t\t    (u_int32_t *)(rfap + offsetof(struct fxp_rfa, link_addr)));\n\t\t*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, rfa_control)) &=\n\t\t    ~FXP_RFA_CONTROL_EL;\n\t} else {\n\t\tsc->rfa_headm = m;\n\t}\n\tsc->rfa_tailm = m;\n\n\treturn (m == oldm);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/ic/fxpvar.h>",
      "#include <dev/ic/fxpreg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define\tRFA_ALIGNMENT_FUDGE\t2"
    ],
    "globals_used": [
      "static __inline void fxp_lwcopy",
      "int fxp_add_rfabuf"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fxp_lwcopy",
          "args": [
            "&v",
            "(u_int32_t *)(rfap + offsetof(struct fxp_rfa, link_addr))"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "fxp_lwcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
          "lines": "122-131",
          "snippet": "static __inline void\nfxp_lwcopy(src, dst)\n\tvolatile u_int32_t *src, *dst;\n{\n\tvolatile u_int16_t *a = (u_int16_t *)src;\n\tvolatile u_int16_t *b = (u_int16_t *)dst;\n\n\tb[0] = a[0];\n\tb[1] = a[1];\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/ic/fxpvar.h>",
            "#include <dev/ic/fxpreg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline void fxp_lwcopy"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic __inline void fxp_lwcopy;\n\nstatic __inline void\nfxp_lwcopy(src, dst)\n\tvolatile u_int32_t *src, *dst;\n{\n\tvolatile u_int16_t *a = (u_int16_t *)src;\n\tvolatile u_int16_t *b = (u_int16_t *)dst;\n\n\tb[0] = a[0];\n\tb[1] = a[1];\n}"
        }
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "rfap"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCLGET",
          "args": [
            "m",
            "M_DONTWAIT"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGETHDR",
          "args": [
            "m",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tRFA_ALIGNMENT_FUDGE\t2\n\nstatic __inline void fxp_lwcopy;\nint fxp_add_rfabuf;\n\nint\nfxp_add_rfabuf(sc, oldm)\n\tstruct fxp_softc *sc;\n\tstruct mbuf *oldm;\n{\n\tu_int32_t v;\n\tstruct mbuf *m;\n\tu_int8_t *rfap;\n\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\tif (m != NULL) {\n\t\tMCLGET(m, M_DONTWAIT);\n\t\tif ((m->m_flags & M_EXT) == 0) {\n\t\t\tm_freem(m);\n\t\t\tif (oldm == NULL)\n\t\t\t\treturn 1;\n\t\t\tm = oldm;\n\t\t\tm->m_data = m->m_ext.ext_buf;\n\t\t}\n\t} else {\n\t\tif (oldm == NULL)\n\t\t\treturn 1;\n\t\tm = oldm;\n\t\tm->m_data = m->m_ext.ext_buf;\n\t}\n\n\t/*\n\t * Move the data pointer up so that the incoming data packet\n\t * will be 32-bit aligned.\n\t */\n\tm->m_data += RFA_ALIGNMENT_FUDGE;\n\n\t/*\n\t * Get a pointer to the base of the mbuf cluster and move\n\t * data start past it.\n\t */\n\trfap = m->m_data;\n\tm->m_data += sizeof(struct fxp_rfa);\n\t*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, size)) =\n\t    MCLBYTES - sizeof(struct fxp_rfa) - RFA_ALIGNMENT_FUDGE;\n\n\t/*\n\t * Initialize the rest of the RFA.  Note that since the RFA\n\t * is misaligned, we cannot store values directly.  Instead,\n\t * we use an optimized, inline copy.\n\t */\n\t*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, rfa_status)) = 0;\n\t*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, rfa_control)) =\n\t    FXP_RFA_CONTROL_EL;\n\t*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, actual_size)) = 0;\n\n\tv = -1;\n\tfxp_lwcopy(&v,\n\t    (u_int32_t *)(rfap + offsetof(struct fxp_rfa, link_addr)));\n\tfxp_lwcopy(&v,\n\t    (u_int32_t *)(rfap + offsetof(struct fxp_rfa, rbd_addr)));\n\n\t/*\n\t * If there are other buffers already on the list, attach this\n\t * one to the end by fixing up the tail to point to this one.\n\t */\n\tif (sc->rfa_headm != NULL) {\n\t\tsc->rfa_tailm->m_next = m;\n\t\tv = vtophys(rfap);\n\t\trfap = sc->rfa_tailm->m_ext.ext_buf + RFA_ALIGNMENT_FUDGE;\n\t\tfxp_lwcopy(&v,\n\t\t    (u_int32_t *)(rfap + offsetof(struct fxp_rfa, link_addr)));\n\t\t*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, rfa_control)) &=\n\t\t    ~FXP_RFA_CONTROL_EL;\n\t} else {\n\t\tsc->rfa_headm = m;\n\t}\n\tsc->rfa_tailm = m;\n\n\treturn (m == oldm);\n}"
  },
  {
    "function_name": "fxp_mediastatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
    "lines": "1252-1262",
    "snippet": "void\nfxp_mediastatus(ifp, ifmr)\n\tstruct ifnet *ifp;\n\tstruct ifmediareq *ifmr;\n{\n\tstruct fxp_softc *sc = ifp->if_softc;\n\n\tmii_pollstat(&sc->sc_mii);\n\tifmr->ifm_status = sc->sc_mii.mii_media_status;\n\tifmr->ifm_active = sc->sc_mii.mii_media_active;\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/ic/fxpvar.h>",
      "#include <dev/ic/fxpreg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void fxp_mediastatus"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mii_pollstat",
          "args": [
            "&sc->sc_mii"
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "mii_pollstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/mii.c",
          "lines": "206-218",
          "snippet": "void\nmii_pollstat(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\n\tmii->mii_media_status = 0;\n\tmii->mii_media_active = IFM_NONE;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list))\n\t\t(void) (*child->mii_service)(child, mii, MII_POLLSTAT);\n}",
          "includes": [
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nvoid\nmii_pollstat(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\n\tmii->mii_media_status = 0;\n\tmii->mii_media_active = IFM_NONE;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list))\n\t\t(void) (*child->mii_service)(child, mii, MII_POLLSTAT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid fxp_mediastatus;\n\nvoid\nfxp_mediastatus(ifp, ifmr)\n\tstruct ifnet *ifp;\n\tstruct ifmediareq *ifmr;\n{\n\tstruct fxp_softc *sc = ifp->if_softc;\n\n\tmii_pollstat(&sc->sc_mii);\n\tifmr->ifm_status = sc->sc_mii.mii_media_status;\n\tifmr->ifm_active = sc->sc_mii.mii_media_active;\n}"
  },
  {
    "function_name": "fxp_mediachange",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
    "lines": "1239-1247",
    "snippet": "int\nfxp_mediachange(ifp)\n\tstruct ifnet *ifp;\n{\n\n\tif (ifp->if_flags & IFF_UP)\n\t\tfxp_init(ifp->if_softc);\n\treturn (0);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/ic/fxpvar.h>",
      "#include <dev/ic/fxpreg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int fxp_mediachange",
      "void fxp_init"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fxp_init",
          "args": [
            "ifp->if_softc"
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "fxp_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
          "lines": "1075-1234",
          "snippet": "void\nfxp_init(xsc)\n\tvoid *xsc;\n{\n\tstruct fxp_softc *sc = xsc;\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tstruct fxp_cb_config *cbp;\n\tstruct fxp_cb_ias *cb_ias;\n\tstruct fxp_cb_tx *txp;\n\tint i, s, prm;\n\n\ts = splimp();\n\t/*\n\t * Cancel any pending I/O\n\t */\n\tfxp_stop(sc, 0);\n\n\tprm = (ifp->if_flags & IFF_PROMISC) ? 1 : 0;\n\n\t/*\n\t * Initialize base of CBL and RFA memory. Loading with zero\n\t * sets it up for regular linear addressing.\n\t */\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, 0);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_BASE);\n\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_RU_BASE);\n\n\t/*\n\t * Initialize base of dump-stats buffer.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, vtophys(sc->fxp_stats));\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_DUMP_ADR);\n\n\t/*\n\t * We temporarily use memory that contains the TxCB list to\n\t * construct the config CB. The TxCB list memory is rebuilt\n\t * later.\n\t */\n\tcbp = (struct fxp_cb_config *) sc->cbl_base;\n\n\t/*\n\t * This bcopy is kind of disgusting, but there are a bunch of must be\n\t * zero and must be one bits in this structure and this is the easiest\n\t * way to initialize them all to proper values.\n\t */\n\tbcopy(fxp_cb_config_template, (void *)&cbp->cb_status,\n\t\tsizeof(fxp_cb_config_template));\n\n\tcbp->cb_status =\t0;\n\tcbp->cb_command =\tFXP_CB_COMMAND_CONFIG | FXP_CB_COMMAND_EL;\n\tcbp->link_addr =\t-1;\t/* (no) next command */\n\tcbp->byte_count =\t22;\t/* (22) bytes to config */\n\tcbp->rx_fifo_limit =\t8;\t/* rx fifo threshold (32 bytes) */\n\tcbp->tx_fifo_limit =\t0;\t/* tx fifo threshold (0 bytes) */\n\tcbp->adaptive_ifs =\t0;\t/* (no) adaptive interframe spacing */\n\tcbp->rx_dma_bytecount =\t0;\t/* (no) rx DMA max */\n\tcbp->tx_dma_bytecount =\t0;\t/* (no) tx DMA max */\n\tcbp->dma_bce =\t\t0;\t/* (disable) dma max counters */\n\tcbp->late_scb =\t\t0;\t/* (don't) defer SCB update */\n\tcbp->tno_int =\t\t0;\t/* (disable) tx not okay interrupt */\n\tcbp->ci_int =\t\t1;\t/* interrupt on CU idle */\n\tcbp->save_bf =\t\tprm;\t/* save bad frames */\n\tcbp->disc_short_rx =\t!prm;\t/* discard short packets */\n\tcbp->underrun_retry =\t1;\t/* retry mode (1) on DMA underrun */\n\tcbp->mediatype =\t!sc->phy_10Mbps_only; /* interface mode */\n\tcbp->nsai =\t\t1;\t/* (don't) disable source addr insert */\n\tcbp->preamble_length =\t2;\t/* (7 byte) preamble */\n\tcbp->loopback =\t\t0;\t/* (don't) loopback */\n\tcbp->linear_priority =\t0;\t/* (normal CSMA/CD operation) */\n\tcbp->linear_pri_mode =\t0;\t/* (wait after xmit only) */\n\tcbp->interfrm_spacing =\t6;\t/* (96 bits of) interframe spacing */\n\tcbp->promiscuous =\tprm;\t/* promiscuous mode */\n\tcbp->bcast_disable =\t0;\t/* (don't) disable broadcasts */\n\tcbp->crscdt =\t\t0;\t/* (CRS only) */\n\tcbp->stripping =\t!prm;\t/* truncate rx packet to byte count */\n\tcbp->padding =\t\t1;\t/* (do) pad short tx packets */\n\tcbp->rcv_crc_xfer =\t0;\t/* (don't) xfer CRC to host */\n\tcbp->long_rx =\t\tsc->not_82557; /* (enable) long packets */\n\tcbp->force_fdx =\t0;\t/* (don't) force full duplex */\n\tcbp->fdx_pin_en =\t1;\t/* (enable) FDX# pin */\n\tcbp->multi_ia =\t\t0;\t/* (don't) accept multiple IAs */\n\tcbp->mc_all =\t\tsc->all_mcasts;/* accept all multicasts */\n\n\t/*\n\t * Start the config command/DMA.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, vtophys(&cbp->cb_status));\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\t/* ...and wait for it to complete. */\n\twhile (!(cbp->cb_status & FXP_CB_STATUS_C));\n\n\t/*\n\t * Now initialize the station address. Temporarily use the TxCB\n\t * memory area like we did above for the config CB.\n\t */\n\tcb_ias = (struct fxp_cb_ias *) sc->cbl_base;\n\tcb_ias->cb_status = 0;\n\tcb_ias->cb_command = FXP_CB_COMMAND_IAS | FXP_CB_COMMAND_EL;\n\tcb_ias->link_addr = -1;\n\tbcopy(sc->arpcom.ac_enaddr, (void *)cb_ias->macaddr,\n\t    sizeof(sc->arpcom.ac_enaddr));\n\n\t/*\n\t * Start the IAS (Individual Address Setup) command/DMA.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\t/* ...and wait for it to complete. */\n\twhile (!(cb_ias->cb_status & FXP_CB_STATUS_C));\n\n\t/*\n\t * Initialize transmit control block (TxCB) list.\n\t */\n\n\ttxp = sc->cbl_base;\n\tbzero(txp, sizeof(struct fxp_cb_tx) * FXP_NTXCB);\n\tfor (i = 0; i < FXP_NTXCB; i++) {\n\t\ttxp[i].cb_status = FXP_CB_STATUS_C | FXP_CB_STATUS_OK;\n\t\ttxp[i].cb_command = FXP_CB_COMMAND_NOP;\n\t\ttxp[i].link_addr = vtophys(&txp[(i + 1) & FXP_TXCB_MASK].cb_status);\n\t\ttxp[i].tbd_array_addr = vtophys(&txp[i].tbd[0]);\n\t\ttxp[i].next = &txp[(i + 1) & FXP_TXCB_MASK];\n\t}\n\t/*\n\t * Set the suspend flag on the first TxCB and start the control\n\t * unit. It will execute the NOP and then suspend.\n\t */\n\ttxp->cb_command = FXP_CB_COMMAND_NOP | FXP_CB_COMMAND_S;\n\tsc->cbl_first = sc->cbl_last = txp;\n\tsc->tx_queued = 1;\n\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\n\t/*\n\t * Initialize receiver buffer area - RFA.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL,\n\t    vtophys(sc->rfa_headm->m_ext.ext_buf) + RFA_ALIGNMENT_FUDGE);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_RU_START);\n\n\t/*\n\t * Set current media.\n\t */\n\tmii_mediachg(&sc->sc_mii);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tsplx(s);\n\n\t/*\n\t * Start stats updater.\n\t */\n\ttimeout(fxp_stats_update, sc, hz);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/ic/fxpvar.h>",
            "#include <dev/ic/fxpreg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define FXP_TXCB_MASK\t(FXP_NTXCB - 1)",
            "#define FXP_NTXCB\t128",
            "#define\tRFA_ALIGNMENT_FUDGE\t2"
          ],
          "globals_used": [
            "static u_char fxp_cb_config_template[] = {\n\t0x0, 0x0,\t\t/* cb_status */\n\t0x80, 0x2,\t\t/* cb_command */\n\t0xff, 0xff, 0xff, 0xff,\t/* link_addr */\n\t0x16,\t/*  0 */\n\t0x8,\t/*  1 */\n\t0x0,\t/*  2 */\n\t0x0,\t/*  3 */\n\t0x0,\t/*  4 */\n\t0x80,\t/*  5 */\n\t0xb2,\t/*  6 */\n\t0x3,\t/*  7 */\n\t0x1,\t/*  8 */\n\t0x0,\t/*  9 */\n\t0x26,\t/* 10 */\n\t0x0,\t/* 11 */\n\t0x60,\t/* 12 */\n\t0x0,\t/* 13 */\n\t0xf2,\t/* 14 */\n\t0x48,\t/* 15 */\n\t0x0,\t/* 16 */\n\t0x40,\t/* 17 */\n\t0xf3,\t/* 18 */\n\t0x0,\t/* 19 */\n\t0x3f,\t/* 20 */\n\t0x5\t/* 21 */\n};",
            "static inline void fxp_scb_wait",
            "void fxp_init",
            "void fxp_stop",
            "void fxp_stats_update"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define FXP_TXCB_MASK\t(FXP_NTXCB - 1)\n#define FXP_NTXCB\t128\n#define\tRFA_ALIGNMENT_FUDGE\t2\n\nstatic u_char fxp_cb_config_template[] = {\n\t0x0, 0x0,\t\t/* cb_status */\n\t0x80, 0x2,\t\t/* cb_command */\n\t0xff, 0xff, 0xff, 0xff,\t/* link_addr */\n\t0x16,\t/*  0 */\n\t0x8,\t/*  1 */\n\t0x0,\t/*  2 */\n\t0x0,\t/*  3 */\n\t0x0,\t/*  4 */\n\t0x80,\t/*  5 */\n\t0xb2,\t/*  6 */\n\t0x3,\t/*  7 */\n\t0x1,\t/*  8 */\n\t0x0,\t/*  9 */\n\t0x26,\t/* 10 */\n\t0x0,\t/* 11 */\n\t0x60,\t/* 12 */\n\t0x0,\t/* 13 */\n\t0xf2,\t/* 14 */\n\t0x48,\t/* 15 */\n\t0x0,\t/* 16 */\n\t0x40,\t/* 17 */\n\t0xf3,\t/* 18 */\n\t0x0,\t/* 19 */\n\t0x3f,\t/* 20 */\n\t0x5\t/* 21 */\n};\nstatic inline void fxp_scb_wait;\nvoid fxp_init;\nvoid fxp_stop;\nvoid fxp_stats_update;\n\nvoid\nfxp_init(xsc)\n\tvoid *xsc;\n{\n\tstruct fxp_softc *sc = xsc;\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tstruct fxp_cb_config *cbp;\n\tstruct fxp_cb_ias *cb_ias;\n\tstruct fxp_cb_tx *txp;\n\tint i, s, prm;\n\n\ts = splimp();\n\t/*\n\t * Cancel any pending I/O\n\t */\n\tfxp_stop(sc, 0);\n\n\tprm = (ifp->if_flags & IFF_PROMISC) ? 1 : 0;\n\n\t/*\n\t * Initialize base of CBL and RFA memory. Loading with zero\n\t * sets it up for regular linear addressing.\n\t */\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, 0);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_BASE);\n\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_RU_BASE);\n\n\t/*\n\t * Initialize base of dump-stats buffer.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, vtophys(sc->fxp_stats));\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_DUMP_ADR);\n\n\t/*\n\t * We temporarily use memory that contains the TxCB list to\n\t * construct the config CB. The TxCB list memory is rebuilt\n\t * later.\n\t */\n\tcbp = (struct fxp_cb_config *) sc->cbl_base;\n\n\t/*\n\t * This bcopy is kind of disgusting, but there are a bunch of must be\n\t * zero and must be one bits in this structure and this is the easiest\n\t * way to initialize them all to proper values.\n\t */\n\tbcopy(fxp_cb_config_template, (void *)&cbp->cb_status,\n\t\tsizeof(fxp_cb_config_template));\n\n\tcbp->cb_status =\t0;\n\tcbp->cb_command =\tFXP_CB_COMMAND_CONFIG | FXP_CB_COMMAND_EL;\n\tcbp->link_addr =\t-1;\t/* (no) next command */\n\tcbp->byte_count =\t22;\t/* (22) bytes to config */\n\tcbp->rx_fifo_limit =\t8;\t/* rx fifo threshold (32 bytes) */\n\tcbp->tx_fifo_limit =\t0;\t/* tx fifo threshold (0 bytes) */\n\tcbp->adaptive_ifs =\t0;\t/* (no) adaptive interframe spacing */\n\tcbp->rx_dma_bytecount =\t0;\t/* (no) rx DMA max */\n\tcbp->tx_dma_bytecount =\t0;\t/* (no) tx DMA max */\n\tcbp->dma_bce =\t\t0;\t/* (disable) dma max counters */\n\tcbp->late_scb =\t\t0;\t/* (don't) defer SCB update */\n\tcbp->tno_int =\t\t0;\t/* (disable) tx not okay interrupt */\n\tcbp->ci_int =\t\t1;\t/* interrupt on CU idle */\n\tcbp->save_bf =\t\tprm;\t/* save bad frames */\n\tcbp->disc_short_rx =\t!prm;\t/* discard short packets */\n\tcbp->underrun_retry =\t1;\t/* retry mode (1) on DMA underrun */\n\tcbp->mediatype =\t!sc->phy_10Mbps_only; /* interface mode */\n\tcbp->nsai =\t\t1;\t/* (don't) disable source addr insert */\n\tcbp->preamble_length =\t2;\t/* (7 byte) preamble */\n\tcbp->loopback =\t\t0;\t/* (don't) loopback */\n\tcbp->linear_priority =\t0;\t/* (normal CSMA/CD operation) */\n\tcbp->linear_pri_mode =\t0;\t/* (wait after xmit only) */\n\tcbp->interfrm_spacing =\t6;\t/* (96 bits of) interframe spacing */\n\tcbp->promiscuous =\tprm;\t/* promiscuous mode */\n\tcbp->bcast_disable =\t0;\t/* (don't) disable broadcasts */\n\tcbp->crscdt =\t\t0;\t/* (CRS only) */\n\tcbp->stripping =\t!prm;\t/* truncate rx packet to byte count */\n\tcbp->padding =\t\t1;\t/* (do) pad short tx packets */\n\tcbp->rcv_crc_xfer =\t0;\t/* (don't) xfer CRC to host */\n\tcbp->long_rx =\t\tsc->not_82557; /* (enable) long packets */\n\tcbp->force_fdx =\t0;\t/* (don't) force full duplex */\n\tcbp->fdx_pin_en =\t1;\t/* (enable) FDX# pin */\n\tcbp->multi_ia =\t\t0;\t/* (don't) accept multiple IAs */\n\tcbp->mc_all =\t\tsc->all_mcasts;/* accept all multicasts */\n\n\t/*\n\t * Start the config command/DMA.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, vtophys(&cbp->cb_status));\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\t/* ...and wait for it to complete. */\n\twhile (!(cbp->cb_status & FXP_CB_STATUS_C));\n\n\t/*\n\t * Now initialize the station address. Temporarily use the TxCB\n\t * memory area like we did above for the config CB.\n\t */\n\tcb_ias = (struct fxp_cb_ias *) sc->cbl_base;\n\tcb_ias->cb_status = 0;\n\tcb_ias->cb_command = FXP_CB_COMMAND_IAS | FXP_CB_COMMAND_EL;\n\tcb_ias->link_addr = -1;\n\tbcopy(sc->arpcom.ac_enaddr, (void *)cb_ias->macaddr,\n\t    sizeof(sc->arpcom.ac_enaddr));\n\n\t/*\n\t * Start the IAS (Individual Address Setup) command/DMA.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\t/* ...and wait for it to complete. */\n\twhile (!(cb_ias->cb_status & FXP_CB_STATUS_C));\n\n\t/*\n\t * Initialize transmit control block (TxCB) list.\n\t */\n\n\ttxp = sc->cbl_base;\n\tbzero(txp, sizeof(struct fxp_cb_tx) * FXP_NTXCB);\n\tfor (i = 0; i < FXP_NTXCB; i++) {\n\t\ttxp[i].cb_status = FXP_CB_STATUS_C | FXP_CB_STATUS_OK;\n\t\ttxp[i].cb_command = FXP_CB_COMMAND_NOP;\n\t\ttxp[i].link_addr = vtophys(&txp[(i + 1) & FXP_TXCB_MASK].cb_status);\n\t\ttxp[i].tbd_array_addr = vtophys(&txp[i].tbd[0]);\n\t\ttxp[i].next = &txp[(i + 1) & FXP_TXCB_MASK];\n\t}\n\t/*\n\t * Set the suspend flag on the first TxCB and start the control\n\t * unit. It will execute the NOP and then suspend.\n\t */\n\ttxp->cb_command = FXP_CB_COMMAND_NOP | FXP_CB_COMMAND_S;\n\tsc->cbl_first = sc->cbl_last = txp;\n\tsc->tx_queued = 1;\n\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\n\t/*\n\t * Initialize receiver buffer area - RFA.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL,\n\t    vtophys(sc->rfa_headm->m_ext.ext_buf) + RFA_ALIGNMENT_FUDGE);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_RU_START);\n\n\t/*\n\t * Set current media.\n\t */\n\tmii_mediachg(&sc->sc_mii);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tsplx(s);\n\n\t/*\n\t * Start stats updater.\n\t */\n\ttimeout(fxp_stats_update, sc, hz);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nint fxp_mediachange;\nvoid fxp_init;\n\nint\nfxp_mediachange(ifp)\n\tstruct ifnet *ifp;\n{\n\n\tif (ifp->if_flags & IFF_UP)\n\t\tfxp_init(ifp->if_softc);\n\treturn (0);\n}"
  },
  {
    "function_name": "fxp_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
    "lines": "1075-1234",
    "snippet": "void\nfxp_init(xsc)\n\tvoid *xsc;\n{\n\tstruct fxp_softc *sc = xsc;\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tstruct fxp_cb_config *cbp;\n\tstruct fxp_cb_ias *cb_ias;\n\tstruct fxp_cb_tx *txp;\n\tint i, s, prm;\n\n\ts = splimp();\n\t/*\n\t * Cancel any pending I/O\n\t */\n\tfxp_stop(sc, 0);\n\n\tprm = (ifp->if_flags & IFF_PROMISC) ? 1 : 0;\n\n\t/*\n\t * Initialize base of CBL and RFA memory. Loading with zero\n\t * sets it up for regular linear addressing.\n\t */\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, 0);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_BASE);\n\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_RU_BASE);\n\n\t/*\n\t * Initialize base of dump-stats buffer.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, vtophys(sc->fxp_stats));\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_DUMP_ADR);\n\n\t/*\n\t * We temporarily use memory that contains the TxCB list to\n\t * construct the config CB. The TxCB list memory is rebuilt\n\t * later.\n\t */\n\tcbp = (struct fxp_cb_config *) sc->cbl_base;\n\n\t/*\n\t * This bcopy is kind of disgusting, but there are a bunch of must be\n\t * zero and must be one bits in this structure and this is the easiest\n\t * way to initialize them all to proper values.\n\t */\n\tbcopy(fxp_cb_config_template, (void *)&cbp->cb_status,\n\t\tsizeof(fxp_cb_config_template));\n\n\tcbp->cb_status =\t0;\n\tcbp->cb_command =\tFXP_CB_COMMAND_CONFIG | FXP_CB_COMMAND_EL;\n\tcbp->link_addr =\t-1;\t/* (no) next command */\n\tcbp->byte_count =\t22;\t/* (22) bytes to config */\n\tcbp->rx_fifo_limit =\t8;\t/* rx fifo threshold (32 bytes) */\n\tcbp->tx_fifo_limit =\t0;\t/* tx fifo threshold (0 bytes) */\n\tcbp->adaptive_ifs =\t0;\t/* (no) adaptive interframe spacing */\n\tcbp->rx_dma_bytecount =\t0;\t/* (no) rx DMA max */\n\tcbp->tx_dma_bytecount =\t0;\t/* (no) tx DMA max */\n\tcbp->dma_bce =\t\t0;\t/* (disable) dma max counters */\n\tcbp->late_scb =\t\t0;\t/* (don't) defer SCB update */\n\tcbp->tno_int =\t\t0;\t/* (disable) tx not okay interrupt */\n\tcbp->ci_int =\t\t1;\t/* interrupt on CU idle */\n\tcbp->save_bf =\t\tprm;\t/* save bad frames */\n\tcbp->disc_short_rx =\t!prm;\t/* discard short packets */\n\tcbp->underrun_retry =\t1;\t/* retry mode (1) on DMA underrun */\n\tcbp->mediatype =\t!sc->phy_10Mbps_only; /* interface mode */\n\tcbp->nsai =\t\t1;\t/* (don't) disable source addr insert */\n\tcbp->preamble_length =\t2;\t/* (7 byte) preamble */\n\tcbp->loopback =\t\t0;\t/* (don't) loopback */\n\tcbp->linear_priority =\t0;\t/* (normal CSMA/CD operation) */\n\tcbp->linear_pri_mode =\t0;\t/* (wait after xmit only) */\n\tcbp->interfrm_spacing =\t6;\t/* (96 bits of) interframe spacing */\n\tcbp->promiscuous =\tprm;\t/* promiscuous mode */\n\tcbp->bcast_disable =\t0;\t/* (don't) disable broadcasts */\n\tcbp->crscdt =\t\t0;\t/* (CRS only) */\n\tcbp->stripping =\t!prm;\t/* truncate rx packet to byte count */\n\tcbp->padding =\t\t1;\t/* (do) pad short tx packets */\n\tcbp->rcv_crc_xfer =\t0;\t/* (don't) xfer CRC to host */\n\tcbp->long_rx =\t\tsc->not_82557; /* (enable) long packets */\n\tcbp->force_fdx =\t0;\t/* (don't) force full duplex */\n\tcbp->fdx_pin_en =\t1;\t/* (enable) FDX# pin */\n\tcbp->multi_ia =\t\t0;\t/* (don't) accept multiple IAs */\n\tcbp->mc_all =\t\tsc->all_mcasts;/* accept all multicasts */\n\n\t/*\n\t * Start the config command/DMA.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, vtophys(&cbp->cb_status));\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\t/* ...and wait for it to complete. */\n\twhile (!(cbp->cb_status & FXP_CB_STATUS_C));\n\n\t/*\n\t * Now initialize the station address. Temporarily use the TxCB\n\t * memory area like we did above for the config CB.\n\t */\n\tcb_ias = (struct fxp_cb_ias *) sc->cbl_base;\n\tcb_ias->cb_status = 0;\n\tcb_ias->cb_command = FXP_CB_COMMAND_IAS | FXP_CB_COMMAND_EL;\n\tcb_ias->link_addr = -1;\n\tbcopy(sc->arpcom.ac_enaddr, (void *)cb_ias->macaddr,\n\t    sizeof(sc->arpcom.ac_enaddr));\n\n\t/*\n\t * Start the IAS (Individual Address Setup) command/DMA.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\t/* ...and wait for it to complete. */\n\twhile (!(cb_ias->cb_status & FXP_CB_STATUS_C));\n\n\t/*\n\t * Initialize transmit control block (TxCB) list.\n\t */\n\n\ttxp = sc->cbl_base;\n\tbzero(txp, sizeof(struct fxp_cb_tx) * FXP_NTXCB);\n\tfor (i = 0; i < FXP_NTXCB; i++) {\n\t\ttxp[i].cb_status = FXP_CB_STATUS_C | FXP_CB_STATUS_OK;\n\t\ttxp[i].cb_command = FXP_CB_COMMAND_NOP;\n\t\ttxp[i].link_addr = vtophys(&txp[(i + 1) & FXP_TXCB_MASK].cb_status);\n\t\ttxp[i].tbd_array_addr = vtophys(&txp[i].tbd[0]);\n\t\ttxp[i].next = &txp[(i + 1) & FXP_TXCB_MASK];\n\t}\n\t/*\n\t * Set the suspend flag on the first TxCB and start the control\n\t * unit. It will execute the NOP and then suspend.\n\t */\n\ttxp->cb_command = FXP_CB_COMMAND_NOP | FXP_CB_COMMAND_S;\n\tsc->cbl_first = sc->cbl_last = txp;\n\tsc->tx_queued = 1;\n\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\n\t/*\n\t * Initialize receiver buffer area - RFA.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL,\n\t    vtophys(sc->rfa_headm->m_ext.ext_buf) + RFA_ALIGNMENT_FUDGE);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_RU_START);\n\n\t/*\n\t * Set current media.\n\t */\n\tmii_mediachg(&sc->sc_mii);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tsplx(s);\n\n\t/*\n\t * Start stats updater.\n\t */\n\ttimeout(fxp_stats_update, sc, hz);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/ic/fxpvar.h>",
      "#include <dev/ic/fxpreg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define FXP_TXCB_MASK\t(FXP_NTXCB - 1)",
      "#define FXP_NTXCB\t128",
      "#define\tRFA_ALIGNMENT_FUDGE\t2"
    ],
    "globals_used": [
      "static u_char fxp_cb_config_template[] = {\n\t0x0, 0x0,\t\t/* cb_status */\n\t0x80, 0x2,\t\t/* cb_command */\n\t0xff, 0xff, 0xff, 0xff,\t/* link_addr */\n\t0x16,\t/*  0 */\n\t0x8,\t/*  1 */\n\t0x0,\t/*  2 */\n\t0x0,\t/*  3 */\n\t0x0,\t/*  4 */\n\t0x80,\t/*  5 */\n\t0xb2,\t/*  6 */\n\t0x3,\t/*  7 */\n\t0x1,\t/*  8 */\n\t0x0,\t/*  9 */\n\t0x26,\t/* 10 */\n\t0x0,\t/* 11 */\n\t0x60,\t/* 12 */\n\t0x0,\t/* 13 */\n\t0xf2,\t/* 14 */\n\t0x48,\t/* 15 */\n\t0x0,\t/* 16 */\n\t0x40,\t/* 17 */\n\t0xf3,\t/* 18 */\n\t0x0,\t/* 19 */\n\t0x3f,\t/* 20 */\n\t0x5\t/* 21 */\n};",
      "static inline void fxp_scb_wait",
      "void fxp_init",
      "void fxp_stop",
      "void fxp_stats_update"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "fxp_stats_update",
            "sc",
            "hz"
          ],
          "line": 1233
        },
        "resolved": true,
        "details": {
          "function_name": "wdctimeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "952-980",
          "snippet": "void\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [
            "static void  __wdcerror"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nstatic void  __wdcerror;\n\nvoid\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mii_mediachg",
          "args": [
            "&sc->sc_mii"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "mii_mediachg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/mii.c",
          "lines": "170-187",
          "snippet": "int\nmii_mediachg(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\tint rv;\n\n\tmii->mii_media_status = 0;\n\tmii->mii_media_active = IFM_NONE;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list)) {\n\t\trv = (*child->mii_service)(child, mii, MII_MEDIACHG);\n\t\tif (rv)\n\t\t\treturn (rv);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nint\nmii_mediachg(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\tint rv;\n\n\tmii->mii_media_status = 0;\n\tmii->mii_media_active = IFM_NONE;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list)) {\n\t\trv = (*child->mii_service)(child, mii, MII_MEDIACHG);\n\t\tif (rv)\n\t\t\treturn (rv);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_1",
          "args": [
            "sc",
            "FXP_CSR_SCB_COMMAND",
            "FXP_SCB_COMMAND_RU_START"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "FXP_CSR_SCB_GENERAL",
            "vtophys(sc->rfa_headm->m_ext.ext_buf) + RFA_ALIGNMENT_FUDGE"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "sc->rfa_headm->m_ext.ext_buf"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fxp_scb_wait",
          "args": [
            "sc"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "fxp_scb_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
          "lines": "237-244",
          "snippet": "static inline void\nfxp_scb_wait(sc)\n\tstruct fxp_softc *sc;\n{\n\tint i = 10000;\n\n\twhile (CSR_READ_1(sc, FXP_CSR_SCB_COMMAND) && --i);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/ic/fxpvar.h>",
            "#include <dev/ic/fxpreg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void fxp_scb_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic inline void fxp_scb_wait;\n\nstatic inline void\nfxp_scb_wait(sc)\n\tstruct fxp_softc *sc;\n{\n\tint i = 10000;\n\n\twhile (CSR_READ_1(sc, FXP_CSR_SCB_COMMAND) && --i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_1",
          "args": [
            "sc",
            "FXP_CSR_SCB_COMMAND",
            "FXP_SCB_COMMAND_CU_START"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&txp[i].tbd[0]"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&txp[(i + 1) & FXP_TXCB_MASK].cb_status"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "txp",
            "sizeof(struct fxp_cb_tx) * FXP_NTXCB"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_1",
          "args": [
            "sc",
            "FXP_CSR_SCB_COMMAND",
            "FXP_SCB_COMMAND_CU_START"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "sc->arpcom.ac_enaddr",
            "(void *)cb_ias->macaddr",
            "sizeof(sc->arpcom.ac_enaddr)"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_1",
          "args": [
            "sc",
            "FXP_CSR_SCB_COMMAND",
            "FXP_SCB_COMMAND_CU_START"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "FXP_CSR_SCB_GENERAL",
            "vtophys(&cbp->cb_status)"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "&cbp->cb_status"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_1",
          "args": [
            "sc",
            "FXP_CSR_SCB_COMMAND",
            "FXP_SCB_COMMAND_CU_DUMP_ADR"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "FXP_CSR_SCB_GENERAL",
            "vtophys(sc->fxp_stats)"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "sc->fxp_stats"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_1",
          "args": [
            "sc",
            "FXP_CSR_SCB_COMMAND",
            "FXP_SCB_COMMAND_RU_BASE"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_1",
          "args": [
            "sc",
            "FXP_CSR_SCB_COMMAND",
            "FXP_SCB_COMMAND_CU_BASE"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "FXP_CSR_SCB_GENERAL",
            "0"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fxp_stop",
          "args": [
            "sc",
            "0"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "fxp_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
          "lines": "998-1055",
          "snippet": "void\nfxp_stop(sc, drain)\n\tstruct fxp_softc *sc;\n\tint drain;\n{\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tstruct fxp_cb_tx *txp;\n\tint i;\n\n\t/*\n\t * Turn down interface (done early to avoid bad interactions\n\t * between panics, shutdown hooks, and the watchdog timer)\n\t */\n\tifp->if_timer = 0;\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\t/*\n\t * Cancel stats updater.\n\t */\n\tuntimeout(fxp_stats_update, sc);\n\n\t/*\n\t * Issue software reset\n\t */\n\tCSR_WRITE_4(sc, FXP_CSR_PORT, FXP_PORT_SELECTIVE_RESET);\n\tDELAY(10);\n\n\t/*\n\t * Release any xmit buffers.\n\t */\n\tfor (txp = sc->cbl_first; txp != NULL && txp->mb_head != NULL;\n\t    txp = txp->next) {\n\t\tm_freem(txp->mb_head);\n\t\ttxp->mb_head = NULL;\n\t}\n\tsc->tx_queued = 0;\n\n\tif (drain) {\n\t\t/*\n\t\t * Free all the receive buffers then reallocate/reinitialize\n\t\t */\n\t\tif (sc->rfa_headm != NULL)\n\t\t\tm_freem(sc->rfa_headm);\n\t\tsc->rfa_headm = NULL;\n\t\tsc->rfa_tailm = NULL;\n\t\tfor (i = 0; i < FXP_NRFABUFS; i++) {\n\t\t\tif (fxp_add_rfabuf(sc, NULL) != 0) {\n\t\t\t\t/*\n\t\t\t\t * This \"can't happen\" - we're at splimp()\n\t\t\t\t * and we just freed all the buffers we need\n\t\t\t\t * above.\n\t\t\t\t */\n\t\t\t\tpanic(\"fxp_stop: no buffers!\");\n\t\t\t}\n\t\t}\n\t}\n\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/ic/fxpvar.h>",
            "#include <dev/ic/fxpreg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define FXP_NRFABUFS\t64"
          ],
          "globals_used": [
            "void fxp_stop",
            "int fxp_add_rfabuf",
            "void fxp_stats_update"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define FXP_NRFABUFS\t64\n\nvoid fxp_stop;\nint fxp_add_rfabuf;\nvoid fxp_stats_update;\n\nvoid\nfxp_stop(sc, drain)\n\tstruct fxp_softc *sc;\n\tint drain;\n{\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tstruct fxp_cb_tx *txp;\n\tint i;\n\n\t/*\n\t * Turn down interface (done early to avoid bad interactions\n\t * between panics, shutdown hooks, and the watchdog timer)\n\t */\n\tifp->if_timer = 0;\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\t/*\n\t * Cancel stats updater.\n\t */\n\tuntimeout(fxp_stats_update, sc);\n\n\t/*\n\t * Issue software reset\n\t */\n\tCSR_WRITE_4(sc, FXP_CSR_PORT, FXP_PORT_SELECTIVE_RESET);\n\tDELAY(10);\n\n\t/*\n\t * Release any xmit buffers.\n\t */\n\tfor (txp = sc->cbl_first; txp != NULL && txp->mb_head != NULL;\n\t    txp = txp->next) {\n\t\tm_freem(txp->mb_head);\n\t\ttxp->mb_head = NULL;\n\t}\n\tsc->tx_queued = 0;\n\n\tif (drain) {\n\t\t/*\n\t\t * Free all the receive buffers then reallocate/reinitialize\n\t\t */\n\t\tif (sc->rfa_headm != NULL)\n\t\t\tm_freem(sc->rfa_headm);\n\t\tsc->rfa_headm = NULL;\n\t\tsc->rfa_tailm = NULL;\n\t\tfor (i = 0; i < FXP_NRFABUFS; i++) {\n\t\t\tif (fxp_add_rfabuf(sc, NULL) != 0) {\n\t\t\t\t/*\n\t\t\t\t * This \"can't happen\" - we're at splimp()\n\t\t\t\t * and we just freed all the buffers we need\n\t\t\t\t * above.\n\t\t\t\t */\n\t\t\t\tpanic(\"fxp_stop: no buffers!\");\n\t\t\t}\n\t\t}\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define FXP_TXCB_MASK\t(FXP_NTXCB - 1)\n#define FXP_NTXCB\t128\n#define\tRFA_ALIGNMENT_FUDGE\t2\n\nstatic u_char fxp_cb_config_template[] = {\n\t0x0, 0x0,\t\t/* cb_status */\n\t0x80, 0x2,\t\t/* cb_command */\n\t0xff, 0xff, 0xff, 0xff,\t/* link_addr */\n\t0x16,\t/*  0 */\n\t0x8,\t/*  1 */\n\t0x0,\t/*  2 */\n\t0x0,\t/*  3 */\n\t0x0,\t/*  4 */\n\t0x80,\t/*  5 */\n\t0xb2,\t/*  6 */\n\t0x3,\t/*  7 */\n\t0x1,\t/*  8 */\n\t0x0,\t/*  9 */\n\t0x26,\t/* 10 */\n\t0x0,\t/* 11 */\n\t0x60,\t/* 12 */\n\t0x0,\t/* 13 */\n\t0xf2,\t/* 14 */\n\t0x48,\t/* 15 */\n\t0x0,\t/* 16 */\n\t0x40,\t/* 17 */\n\t0xf3,\t/* 18 */\n\t0x0,\t/* 19 */\n\t0x3f,\t/* 20 */\n\t0x5\t/* 21 */\n};\nstatic inline void fxp_scb_wait;\nvoid fxp_init;\nvoid fxp_stop;\nvoid fxp_stats_update;\n\nvoid\nfxp_init(xsc)\n\tvoid *xsc;\n{\n\tstruct fxp_softc *sc = xsc;\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tstruct fxp_cb_config *cbp;\n\tstruct fxp_cb_ias *cb_ias;\n\tstruct fxp_cb_tx *txp;\n\tint i, s, prm;\n\n\ts = splimp();\n\t/*\n\t * Cancel any pending I/O\n\t */\n\tfxp_stop(sc, 0);\n\n\tprm = (ifp->if_flags & IFF_PROMISC) ? 1 : 0;\n\n\t/*\n\t * Initialize base of CBL and RFA memory. Loading with zero\n\t * sets it up for regular linear addressing.\n\t */\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, 0);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_BASE);\n\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_RU_BASE);\n\n\t/*\n\t * Initialize base of dump-stats buffer.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, vtophys(sc->fxp_stats));\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_DUMP_ADR);\n\n\t/*\n\t * We temporarily use memory that contains the TxCB list to\n\t * construct the config CB. The TxCB list memory is rebuilt\n\t * later.\n\t */\n\tcbp = (struct fxp_cb_config *) sc->cbl_base;\n\n\t/*\n\t * This bcopy is kind of disgusting, but there are a bunch of must be\n\t * zero and must be one bits in this structure and this is the easiest\n\t * way to initialize them all to proper values.\n\t */\n\tbcopy(fxp_cb_config_template, (void *)&cbp->cb_status,\n\t\tsizeof(fxp_cb_config_template));\n\n\tcbp->cb_status =\t0;\n\tcbp->cb_command =\tFXP_CB_COMMAND_CONFIG | FXP_CB_COMMAND_EL;\n\tcbp->link_addr =\t-1;\t/* (no) next command */\n\tcbp->byte_count =\t22;\t/* (22) bytes to config */\n\tcbp->rx_fifo_limit =\t8;\t/* rx fifo threshold (32 bytes) */\n\tcbp->tx_fifo_limit =\t0;\t/* tx fifo threshold (0 bytes) */\n\tcbp->adaptive_ifs =\t0;\t/* (no) adaptive interframe spacing */\n\tcbp->rx_dma_bytecount =\t0;\t/* (no) rx DMA max */\n\tcbp->tx_dma_bytecount =\t0;\t/* (no) tx DMA max */\n\tcbp->dma_bce =\t\t0;\t/* (disable) dma max counters */\n\tcbp->late_scb =\t\t0;\t/* (don't) defer SCB update */\n\tcbp->tno_int =\t\t0;\t/* (disable) tx not okay interrupt */\n\tcbp->ci_int =\t\t1;\t/* interrupt on CU idle */\n\tcbp->save_bf =\t\tprm;\t/* save bad frames */\n\tcbp->disc_short_rx =\t!prm;\t/* discard short packets */\n\tcbp->underrun_retry =\t1;\t/* retry mode (1) on DMA underrun */\n\tcbp->mediatype =\t!sc->phy_10Mbps_only; /* interface mode */\n\tcbp->nsai =\t\t1;\t/* (don't) disable source addr insert */\n\tcbp->preamble_length =\t2;\t/* (7 byte) preamble */\n\tcbp->loopback =\t\t0;\t/* (don't) loopback */\n\tcbp->linear_priority =\t0;\t/* (normal CSMA/CD operation) */\n\tcbp->linear_pri_mode =\t0;\t/* (wait after xmit only) */\n\tcbp->interfrm_spacing =\t6;\t/* (96 bits of) interframe spacing */\n\tcbp->promiscuous =\tprm;\t/* promiscuous mode */\n\tcbp->bcast_disable =\t0;\t/* (don't) disable broadcasts */\n\tcbp->crscdt =\t\t0;\t/* (CRS only) */\n\tcbp->stripping =\t!prm;\t/* truncate rx packet to byte count */\n\tcbp->padding =\t\t1;\t/* (do) pad short tx packets */\n\tcbp->rcv_crc_xfer =\t0;\t/* (don't) xfer CRC to host */\n\tcbp->long_rx =\t\tsc->not_82557; /* (enable) long packets */\n\tcbp->force_fdx =\t0;\t/* (don't) force full duplex */\n\tcbp->fdx_pin_en =\t1;\t/* (enable) FDX# pin */\n\tcbp->multi_ia =\t\t0;\t/* (don't) accept multiple IAs */\n\tcbp->mc_all =\t\tsc->all_mcasts;/* accept all multicasts */\n\n\t/*\n\t * Start the config command/DMA.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, vtophys(&cbp->cb_status));\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\t/* ...and wait for it to complete. */\n\twhile (!(cbp->cb_status & FXP_CB_STATUS_C));\n\n\t/*\n\t * Now initialize the station address. Temporarily use the TxCB\n\t * memory area like we did above for the config CB.\n\t */\n\tcb_ias = (struct fxp_cb_ias *) sc->cbl_base;\n\tcb_ias->cb_status = 0;\n\tcb_ias->cb_command = FXP_CB_COMMAND_IAS | FXP_CB_COMMAND_EL;\n\tcb_ias->link_addr = -1;\n\tbcopy(sc->arpcom.ac_enaddr, (void *)cb_ias->macaddr,\n\t    sizeof(sc->arpcom.ac_enaddr));\n\n\t/*\n\t * Start the IAS (Individual Address Setup) command/DMA.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\t/* ...and wait for it to complete. */\n\twhile (!(cb_ias->cb_status & FXP_CB_STATUS_C));\n\n\t/*\n\t * Initialize transmit control block (TxCB) list.\n\t */\n\n\ttxp = sc->cbl_base;\n\tbzero(txp, sizeof(struct fxp_cb_tx) * FXP_NTXCB);\n\tfor (i = 0; i < FXP_NTXCB; i++) {\n\t\ttxp[i].cb_status = FXP_CB_STATUS_C | FXP_CB_STATUS_OK;\n\t\ttxp[i].cb_command = FXP_CB_COMMAND_NOP;\n\t\ttxp[i].link_addr = vtophys(&txp[(i + 1) & FXP_TXCB_MASK].cb_status);\n\t\ttxp[i].tbd_array_addr = vtophys(&txp[i].tbd[0]);\n\t\ttxp[i].next = &txp[(i + 1) & FXP_TXCB_MASK];\n\t}\n\t/*\n\t * Set the suspend flag on the first TxCB and start the control\n\t * unit. It will execute the NOP and then suspend.\n\t */\n\ttxp->cb_command = FXP_CB_COMMAND_NOP | FXP_CB_COMMAND_S;\n\tsc->cbl_first = sc->cbl_last = txp;\n\tsc->tx_queued = 1;\n\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\n\t/*\n\t * Initialize receiver buffer area - RFA.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL,\n\t    vtophys(sc->rfa_headm->m_ext.ext_buf) + RFA_ALIGNMENT_FUDGE);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_RU_START);\n\n\t/*\n\t * Set current media.\n\t */\n\tmii_mediachg(&sc->sc_mii);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tsplx(s);\n\n\t/*\n\t * Start stats updater.\n\t */\n\ttimeout(fxp_stats_update, sc, hz);\n}"
  },
  {
    "function_name": "fxp_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
    "lines": "1063-1073",
    "snippet": "void\nfxp_watchdog(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct fxp_softc *sc = ifp->if_softc;\n\n\tlog(LOG_ERR, \"%s: device timeout\\n\", sc->sc_dev.dv_xname);\n\tifp->if_oerrors++;\n\n\tfxp_init(sc);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/ic/fxpvar.h>",
      "#include <dev/ic/fxpreg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void fxp_init",
      "void fxp_watchdog"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fxp_init",
          "args": [
            "sc"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "fxp_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
          "lines": "1075-1234",
          "snippet": "void\nfxp_init(xsc)\n\tvoid *xsc;\n{\n\tstruct fxp_softc *sc = xsc;\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tstruct fxp_cb_config *cbp;\n\tstruct fxp_cb_ias *cb_ias;\n\tstruct fxp_cb_tx *txp;\n\tint i, s, prm;\n\n\ts = splimp();\n\t/*\n\t * Cancel any pending I/O\n\t */\n\tfxp_stop(sc, 0);\n\n\tprm = (ifp->if_flags & IFF_PROMISC) ? 1 : 0;\n\n\t/*\n\t * Initialize base of CBL and RFA memory. Loading with zero\n\t * sets it up for regular linear addressing.\n\t */\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, 0);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_BASE);\n\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_RU_BASE);\n\n\t/*\n\t * Initialize base of dump-stats buffer.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, vtophys(sc->fxp_stats));\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_DUMP_ADR);\n\n\t/*\n\t * We temporarily use memory that contains the TxCB list to\n\t * construct the config CB. The TxCB list memory is rebuilt\n\t * later.\n\t */\n\tcbp = (struct fxp_cb_config *) sc->cbl_base;\n\n\t/*\n\t * This bcopy is kind of disgusting, but there are a bunch of must be\n\t * zero and must be one bits in this structure and this is the easiest\n\t * way to initialize them all to proper values.\n\t */\n\tbcopy(fxp_cb_config_template, (void *)&cbp->cb_status,\n\t\tsizeof(fxp_cb_config_template));\n\n\tcbp->cb_status =\t0;\n\tcbp->cb_command =\tFXP_CB_COMMAND_CONFIG | FXP_CB_COMMAND_EL;\n\tcbp->link_addr =\t-1;\t/* (no) next command */\n\tcbp->byte_count =\t22;\t/* (22) bytes to config */\n\tcbp->rx_fifo_limit =\t8;\t/* rx fifo threshold (32 bytes) */\n\tcbp->tx_fifo_limit =\t0;\t/* tx fifo threshold (0 bytes) */\n\tcbp->adaptive_ifs =\t0;\t/* (no) adaptive interframe spacing */\n\tcbp->rx_dma_bytecount =\t0;\t/* (no) rx DMA max */\n\tcbp->tx_dma_bytecount =\t0;\t/* (no) tx DMA max */\n\tcbp->dma_bce =\t\t0;\t/* (disable) dma max counters */\n\tcbp->late_scb =\t\t0;\t/* (don't) defer SCB update */\n\tcbp->tno_int =\t\t0;\t/* (disable) tx not okay interrupt */\n\tcbp->ci_int =\t\t1;\t/* interrupt on CU idle */\n\tcbp->save_bf =\t\tprm;\t/* save bad frames */\n\tcbp->disc_short_rx =\t!prm;\t/* discard short packets */\n\tcbp->underrun_retry =\t1;\t/* retry mode (1) on DMA underrun */\n\tcbp->mediatype =\t!sc->phy_10Mbps_only; /* interface mode */\n\tcbp->nsai =\t\t1;\t/* (don't) disable source addr insert */\n\tcbp->preamble_length =\t2;\t/* (7 byte) preamble */\n\tcbp->loopback =\t\t0;\t/* (don't) loopback */\n\tcbp->linear_priority =\t0;\t/* (normal CSMA/CD operation) */\n\tcbp->linear_pri_mode =\t0;\t/* (wait after xmit only) */\n\tcbp->interfrm_spacing =\t6;\t/* (96 bits of) interframe spacing */\n\tcbp->promiscuous =\tprm;\t/* promiscuous mode */\n\tcbp->bcast_disable =\t0;\t/* (don't) disable broadcasts */\n\tcbp->crscdt =\t\t0;\t/* (CRS only) */\n\tcbp->stripping =\t!prm;\t/* truncate rx packet to byte count */\n\tcbp->padding =\t\t1;\t/* (do) pad short tx packets */\n\tcbp->rcv_crc_xfer =\t0;\t/* (don't) xfer CRC to host */\n\tcbp->long_rx =\t\tsc->not_82557; /* (enable) long packets */\n\tcbp->force_fdx =\t0;\t/* (don't) force full duplex */\n\tcbp->fdx_pin_en =\t1;\t/* (enable) FDX# pin */\n\tcbp->multi_ia =\t\t0;\t/* (don't) accept multiple IAs */\n\tcbp->mc_all =\t\tsc->all_mcasts;/* accept all multicasts */\n\n\t/*\n\t * Start the config command/DMA.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, vtophys(&cbp->cb_status));\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\t/* ...and wait for it to complete. */\n\twhile (!(cbp->cb_status & FXP_CB_STATUS_C));\n\n\t/*\n\t * Now initialize the station address. Temporarily use the TxCB\n\t * memory area like we did above for the config CB.\n\t */\n\tcb_ias = (struct fxp_cb_ias *) sc->cbl_base;\n\tcb_ias->cb_status = 0;\n\tcb_ias->cb_command = FXP_CB_COMMAND_IAS | FXP_CB_COMMAND_EL;\n\tcb_ias->link_addr = -1;\n\tbcopy(sc->arpcom.ac_enaddr, (void *)cb_ias->macaddr,\n\t    sizeof(sc->arpcom.ac_enaddr));\n\n\t/*\n\t * Start the IAS (Individual Address Setup) command/DMA.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\t/* ...and wait for it to complete. */\n\twhile (!(cb_ias->cb_status & FXP_CB_STATUS_C));\n\n\t/*\n\t * Initialize transmit control block (TxCB) list.\n\t */\n\n\ttxp = sc->cbl_base;\n\tbzero(txp, sizeof(struct fxp_cb_tx) * FXP_NTXCB);\n\tfor (i = 0; i < FXP_NTXCB; i++) {\n\t\ttxp[i].cb_status = FXP_CB_STATUS_C | FXP_CB_STATUS_OK;\n\t\ttxp[i].cb_command = FXP_CB_COMMAND_NOP;\n\t\ttxp[i].link_addr = vtophys(&txp[(i + 1) & FXP_TXCB_MASK].cb_status);\n\t\ttxp[i].tbd_array_addr = vtophys(&txp[i].tbd[0]);\n\t\ttxp[i].next = &txp[(i + 1) & FXP_TXCB_MASK];\n\t}\n\t/*\n\t * Set the suspend flag on the first TxCB and start the control\n\t * unit. It will execute the NOP and then suspend.\n\t */\n\ttxp->cb_command = FXP_CB_COMMAND_NOP | FXP_CB_COMMAND_S;\n\tsc->cbl_first = sc->cbl_last = txp;\n\tsc->tx_queued = 1;\n\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\n\t/*\n\t * Initialize receiver buffer area - RFA.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL,\n\t    vtophys(sc->rfa_headm->m_ext.ext_buf) + RFA_ALIGNMENT_FUDGE);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_RU_START);\n\n\t/*\n\t * Set current media.\n\t */\n\tmii_mediachg(&sc->sc_mii);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tsplx(s);\n\n\t/*\n\t * Start stats updater.\n\t */\n\ttimeout(fxp_stats_update, sc, hz);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/ic/fxpvar.h>",
            "#include <dev/ic/fxpreg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define FXP_TXCB_MASK\t(FXP_NTXCB - 1)",
            "#define FXP_NTXCB\t128",
            "#define\tRFA_ALIGNMENT_FUDGE\t2"
          ],
          "globals_used": [
            "static u_char fxp_cb_config_template[] = {\n\t0x0, 0x0,\t\t/* cb_status */\n\t0x80, 0x2,\t\t/* cb_command */\n\t0xff, 0xff, 0xff, 0xff,\t/* link_addr */\n\t0x16,\t/*  0 */\n\t0x8,\t/*  1 */\n\t0x0,\t/*  2 */\n\t0x0,\t/*  3 */\n\t0x0,\t/*  4 */\n\t0x80,\t/*  5 */\n\t0xb2,\t/*  6 */\n\t0x3,\t/*  7 */\n\t0x1,\t/*  8 */\n\t0x0,\t/*  9 */\n\t0x26,\t/* 10 */\n\t0x0,\t/* 11 */\n\t0x60,\t/* 12 */\n\t0x0,\t/* 13 */\n\t0xf2,\t/* 14 */\n\t0x48,\t/* 15 */\n\t0x0,\t/* 16 */\n\t0x40,\t/* 17 */\n\t0xf3,\t/* 18 */\n\t0x0,\t/* 19 */\n\t0x3f,\t/* 20 */\n\t0x5\t/* 21 */\n};",
            "static inline void fxp_scb_wait",
            "void fxp_init",
            "void fxp_stop",
            "void fxp_stats_update"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define FXP_TXCB_MASK\t(FXP_NTXCB - 1)\n#define FXP_NTXCB\t128\n#define\tRFA_ALIGNMENT_FUDGE\t2\n\nstatic u_char fxp_cb_config_template[] = {\n\t0x0, 0x0,\t\t/* cb_status */\n\t0x80, 0x2,\t\t/* cb_command */\n\t0xff, 0xff, 0xff, 0xff,\t/* link_addr */\n\t0x16,\t/*  0 */\n\t0x8,\t/*  1 */\n\t0x0,\t/*  2 */\n\t0x0,\t/*  3 */\n\t0x0,\t/*  4 */\n\t0x80,\t/*  5 */\n\t0xb2,\t/*  6 */\n\t0x3,\t/*  7 */\n\t0x1,\t/*  8 */\n\t0x0,\t/*  9 */\n\t0x26,\t/* 10 */\n\t0x0,\t/* 11 */\n\t0x60,\t/* 12 */\n\t0x0,\t/* 13 */\n\t0xf2,\t/* 14 */\n\t0x48,\t/* 15 */\n\t0x0,\t/* 16 */\n\t0x40,\t/* 17 */\n\t0xf3,\t/* 18 */\n\t0x0,\t/* 19 */\n\t0x3f,\t/* 20 */\n\t0x5\t/* 21 */\n};\nstatic inline void fxp_scb_wait;\nvoid fxp_init;\nvoid fxp_stop;\nvoid fxp_stats_update;\n\nvoid\nfxp_init(xsc)\n\tvoid *xsc;\n{\n\tstruct fxp_softc *sc = xsc;\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tstruct fxp_cb_config *cbp;\n\tstruct fxp_cb_ias *cb_ias;\n\tstruct fxp_cb_tx *txp;\n\tint i, s, prm;\n\n\ts = splimp();\n\t/*\n\t * Cancel any pending I/O\n\t */\n\tfxp_stop(sc, 0);\n\n\tprm = (ifp->if_flags & IFF_PROMISC) ? 1 : 0;\n\n\t/*\n\t * Initialize base of CBL and RFA memory. Loading with zero\n\t * sets it up for regular linear addressing.\n\t */\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, 0);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_BASE);\n\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_RU_BASE);\n\n\t/*\n\t * Initialize base of dump-stats buffer.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, vtophys(sc->fxp_stats));\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_DUMP_ADR);\n\n\t/*\n\t * We temporarily use memory that contains the TxCB list to\n\t * construct the config CB. The TxCB list memory is rebuilt\n\t * later.\n\t */\n\tcbp = (struct fxp_cb_config *) sc->cbl_base;\n\n\t/*\n\t * This bcopy is kind of disgusting, but there are a bunch of must be\n\t * zero and must be one bits in this structure and this is the easiest\n\t * way to initialize them all to proper values.\n\t */\n\tbcopy(fxp_cb_config_template, (void *)&cbp->cb_status,\n\t\tsizeof(fxp_cb_config_template));\n\n\tcbp->cb_status =\t0;\n\tcbp->cb_command =\tFXP_CB_COMMAND_CONFIG | FXP_CB_COMMAND_EL;\n\tcbp->link_addr =\t-1;\t/* (no) next command */\n\tcbp->byte_count =\t22;\t/* (22) bytes to config */\n\tcbp->rx_fifo_limit =\t8;\t/* rx fifo threshold (32 bytes) */\n\tcbp->tx_fifo_limit =\t0;\t/* tx fifo threshold (0 bytes) */\n\tcbp->adaptive_ifs =\t0;\t/* (no) adaptive interframe spacing */\n\tcbp->rx_dma_bytecount =\t0;\t/* (no) rx DMA max */\n\tcbp->tx_dma_bytecount =\t0;\t/* (no) tx DMA max */\n\tcbp->dma_bce =\t\t0;\t/* (disable) dma max counters */\n\tcbp->late_scb =\t\t0;\t/* (don't) defer SCB update */\n\tcbp->tno_int =\t\t0;\t/* (disable) tx not okay interrupt */\n\tcbp->ci_int =\t\t1;\t/* interrupt on CU idle */\n\tcbp->save_bf =\t\tprm;\t/* save bad frames */\n\tcbp->disc_short_rx =\t!prm;\t/* discard short packets */\n\tcbp->underrun_retry =\t1;\t/* retry mode (1) on DMA underrun */\n\tcbp->mediatype =\t!sc->phy_10Mbps_only; /* interface mode */\n\tcbp->nsai =\t\t1;\t/* (don't) disable source addr insert */\n\tcbp->preamble_length =\t2;\t/* (7 byte) preamble */\n\tcbp->loopback =\t\t0;\t/* (don't) loopback */\n\tcbp->linear_priority =\t0;\t/* (normal CSMA/CD operation) */\n\tcbp->linear_pri_mode =\t0;\t/* (wait after xmit only) */\n\tcbp->interfrm_spacing =\t6;\t/* (96 bits of) interframe spacing */\n\tcbp->promiscuous =\tprm;\t/* promiscuous mode */\n\tcbp->bcast_disable =\t0;\t/* (don't) disable broadcasts */\n\tcbp->crscdt =\t\t0;\t/* (CRS only) */\n\tcbp->stripping =\t!prm;\t/* truncate rx packet to byte count */\n\tcbp->padding =\t\t1;\t/* (do) pad short tx packets */\n\tcbp->rcv_crc_xfer =\t0;\t/* (don't) xfer CRC to host */\n\tcbp->long_rx =\t\tsc->not_82557; /* (enable) long packets */\n\tcbp->force_fdx =\t0;\t/* (don't) force full duplex */\n\tcbp->fdx_pin_en =\t1;\t/* (enable) FDX# pin */\n\tcbp->multi_ia =\t\t0;\t/* (don't) accept multiple IAs */\n\tcbp->mc_all =\t\tsc->all_mcasts;/* accept all multicasts */\n\n\t/*\n\t * Start the config command/DMA.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, vtophys(&cbp->cb_status));\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\t/* ...and wait for it to complete. */\n\twhile (!(cbp->cb_status & FXP_CB_STATUS_C));\n\n\t/*\n\t * Now initialize the station address. Temporarily use the TxCB\n\t * memory area like we did above for the config CB.\n\t */\n\tcb_ias = (struct fxp_cb_ias *) sc->cbl_base;\n\tcb_ias->cb_status = 0;\n\tcb_ias->cb_command = FXP_CB_COMMAND_IAS | FXP_CB_COMMAND_EL;\n\tcb_ias->link_addr = -1;\n\tbcopy(sc->arpcom.ac_enaddr, (void *)cb_ias->macaddr,\n\t    sizeof(sc->arpcom.ac_enaddr));\n\n\t/*\n\t * Start the IAS (Individual Address Setup) command/DMA.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\t/* ...and wait for it to complete. */\n\twhile (!(cb_ias->cb_status & FXP_CB_STATUS_C));\n\n\t/*\n\t * Initialize transmit control block (TxCB) list.\n\t */\n\n\ttxp = sc->cbl_base;\n\tbzero(txp, sizeof(struct fxp_cb_tx) * FXP_NTXCB);\n\tfor (i = 0; i < FXP_NTXCB; i++) {\n\t\ttxp[i].cb_status = FXP_CB_STATUS_C | FXP_CB_STATUS_OK;\n\t\ttxp[i].cb_command = FXP_CB_COMMAND_NOP;\n\t\ttxp[i].link_addr = vtophys(&txp[(i + 1) & FXP_TXCB_MASK].cb_status);\n\t\ttxp[i].tbd_array_addr = vtophys(&txp[i].tbd[0]);\n\t\ttxp[i].next = &txp[(i + 1) & FXP_TXCB_MASK];\n\t}\n\t/*\n\t * Set the suspend flag on the first TxCB and start the control\n\t * unit. It will execute the NOP and then suspend.\n\t */\n\ttxp->cb_command = FXP_CB_COMMAND_NOP | FXP_CB_COMMAND_S;\n\tsc->cbl_first = sc->cbl_last = txp;\n\tsc->tx_queued = 1;\n\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\n\t/*\n\t * Initialize receiver buffer area - RFA.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL,\n\t    vtophys(sc->rfa_headm->m_ext.ext_buf) + RFA_ALIGNMENT_FUDGE);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_RU_START);\n\n\t/*\n\t * Set current media.\n\t */\n\tmii_mediachg(&sc->sc_mii);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tsplx(s);\n\n\t/*\n\t * Start stats updater.\n\t */\n\ttimeout(fxp_stats_update, sc, hz);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_ERR",
            "\"%s: device timeout\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1387-1401",
          "snippet": "int\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid fxp_init;\nvoid fxp_watchdog;\n\nvoid\nfxp_watchdog(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct fxp_softc *sc = ifp->if_softc;\n\n\tlog(LOG_ERR, \"%s: device timeout\\n\", sc->sc_dev.dv_xname);\n\tifp->if_oerrors++;\n\n\tfxp_init(sc);\n}"
  },
  {
    "function_name": "fxp_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
    "lines": "998-1055",
    "snippet": "void\nfxp_stop(sc, drain)\n\tstruct fxp_softc *sc;\n\tint drain;\n{\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tstruct fxp_cb_tx *txp;\n\tint i;\n\n\t/*\n\t * Turn down interface (done early to avoid bad interactions\n\t * between panics, shutdown hooks, and the watchdog timer)\n\t */\n\tifp->if_timer = 0;\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\t/*\n\t * Cancel stats updater.\n\t */\n\tuntimeout(fxp_stats_update, sc);\n\n\t/*\n\t * Issue software reset\n\t */\n\tCSR_WRITE_4(sc, FXP_CSR_PORT, FXP_PORT_SELECTIVE_RESET);\n\tDELAY(10);\n\n\t/*\n\t * Release any xmit buffers.\n\t */\n\tfor (txp = sc->cbl_first; txp != NULL && txp->mb_head != NULL;\n\t    txp = txp->next) {\n\t\tm_freem(txp->mb_head);\n\t\ttxp->mb_head = NULL;\n\t}\n\tsc->tx_queued = 0;\n\n\tif (drain) {\n\t\t/*\n\t\t * Free all the receive buffers then reallocate/reinitialize\n\t\t */\n\t\tif (sc->rfa_headm != NULL)\n\t\t\tm_freem(sc->rfa_headm);\n\t\tsc->rfa_headm = NULL;\n\t\tsc->rfa_tailm = NULL;\n\t\tfor (i = 0; i < FXP_NRFABUFS; i++) {\n\t\t\tif (fxp_add_rfabuf(sc, NULL) != 0) {\n\t\t\t\t/*\n\t\t\t\t * This \"can't happen\" - we're at splimp()\n\t\t\t\t * and we just freed all the buffers we need\n\t\t\t\t * above.\n\t\t\t\t */\n\t\t\t\tpanic(\"fxp_stop: no buffers!\");\n\t\t\t}\n\t\t}\n\t}\n\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/ic/fxpvar.h>",
      "#include <dev/ic/fxpreg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define FXP_NRFABUFS\t64"
    ],
    "globals_used": [
      "void fxp_stop",
      "int fxp_add_rfabuf",
      "void fxp_stats_update"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"fxp_stop: no buffers!\""
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fxp_add_rfabuf",
          "args": [
            "sc",
            "NULL"
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "fxp_add_rfabuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
          "lines": "1272-1347",
          "snippet": "int\nfxp_add_rfabuf(sc, oldm)\n\tstruct fxp_softc *sc;\n\tstruct mbuf *oldm;\n{\n\tu_int32_t v;\n\tstruct mbuf *m;\n\tu_int8_t *rfap;\n\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\tif (m != NULL) {\n\t\tMCLGET(m, M_DONTWAIT);\n\t\tif ((m->m_flags & M_EXT) == 0) {\n\t\t\tm_freem(m);\n\t\t\tif (oldm == NULL)\n\t\t\t\treturn 1;\n\t\t\tm = oldm;\n\t\t\tm->m_data = m->m_ext.ext_buf;\n\t\t}\n\t} else {\n\t\tif (oldm == NULL)\n\t\t\treturn 1;\n\t\tm = oldm;\n\t\tm->m_data = m->m_ext.ext_buf;\n\t}\n\n\t/*\n\t * Move the data pointer up so that the incoming data packet\n\t * will be 32-bit aligned.\n\t */\n\tm->m_data += RFA_ALIGNMENT_FUDGE;\n\n\t/*\n\t * Get a pointer to the base of the mbuf cluster and move\n\t * data start past it.\n\t */\n\trfap = m->m_data;\n\tm->m_data += sizeof(struct fxp_rfa);\n\t*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, size)) =\n\t    MCLBYTES - sizeof(struct fxp_rfa) - RFA_ALIGNMENT_FUDGE;\n\n\t/*\n\t * Initialize the rest of the RFA.  Note that since the RFA\n\t * is misaligned, we cannot store values directly.  Instead,\n\t * we use an optimized, inline copy.\n\t */\n\t*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, rfa_status)) = 0;\n\t*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, rfa_control)) =\n\t    FXP_RFA_CONTROL_EL;\n\t*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, actual_size)) = 0;\n\n\tv = -1;\n\tfxp_lwcopy(&v,\n\t    (u_int32_t *)(rfap + offsetof(struct fxp_rfa, link_addr)));\n\tfxp_lwcopy(&v,\n\t    (u_int32_t *)(rfap + offsetof(struct fxp_rfa, rbd_addr)));\n\n\t/*\n\t * If there are other buffers already on the list, attach this\n\t * one to the end by fixing up the tail to point to this one.\n\t */\n\tif (sc->rfa_headm != NULL) {\n\t\tsc->rfa_tailm->m_next = m;\n\t\tv = vtophys(rfap);\n\t\trfap = sc->rfa_tailm->m_ext.ext_buf + RFA_ALIGNMENT_FUDGE;\n\t\tfxp_lwcopy(&v,\n\t\t    (u_int32_t *)(rfap + offsetof(struct fxp_rfa, link_addr)));\n\t\t*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, rfa_control)) &=\n\t\t    ~FXP_RFA_CONTROL_EL;\n\t} else {\n\t\tsc->rfa_headm = m;\n\t}\n\tsc->rfa_tailm = m;\n\n\treturn (m == oldm);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/ic/fxpvar.h>",
            "#include <dev/ic/fxpreg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tRFA_ALIGNMENT_FUDGE\t2"
          ],
          "globals_used": [
            "static __inline void fxp_lwcopy",
            "int fxp_add_rfabuf"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tRFA_ALIGNMENT_FUDGE\t2\n\nstatic __inline void fxp_lwcopy;\nint fxp_add_rfabuf;\n\nint\nfxp_add_rfabuf(sc, oldm)\n\tstruct fxp_softc *sc;\n\tstruct mbuf *oldm;\n{\n\tu_int32_t v;\n\tstruct mbuf *m;\n\tu_int8_t *rfap;\n\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\tif (m != NULL) {\n\t\tMCLGET(m, M_DONTWAIT);\n\t\tif ((m->m_flags & M_EXT) == 0) {\n\t\t\tm_freem(m);\n\t\t\tif (oldm == NULL)\n\t\t\t\treturn 1;\n\t\t\tm = oldm;\n\t\t\tm->m_data = m->m_ext.ext_buf;\n\t\t}\n\t} else {\n\t\tif (oldm == NULL)\n\t\t\treturn 1;\n\t\tm = oldm;\n\t\tm->m_data = m->m_ext.ext_buf;\n\t}\n\n\t/*\n\t * Move the data pointer up so that the incoming data packet\n\t * will be 32-bit aligned.\n\t */\n\tm->m_data += RFA_ALIGNMENT_FUDGE;\n\n\t/*\n\t * Get a pointer to the base of the mbuf cluster and move\n\t * data start past it.\n\t */\n\trfap = m->m_data;\n\tm->m_data += sizeof(struct fxp_rfa);\n\t*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, size)) =\n\t    MCLBYTES - sizeof(struct fxp_rfa) - RFA_ALIGNMENT_FUDGE;\n\n\t/*\n\t * Initialize the rest of the RFA.  Note that since the RFA\n\t * is misaligned, we cannot store values directly.  Instead,\n\t * we use an optimized, inline copy.\n\t */\n\t*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, rfa_status)) = 0;\n\t*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, rfa_control)) =\n\t    FXP_RFA_CONTROL_EL;\n\t*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, actual_size)) = 0;\n\n\tv = -1;\n\tfxp_lwcopy(&v,\n\t    (u_int32_t *)(rfap + offsetof(struct fxp_rfa, link_addr)));\n\tfxp_lwcopy(&v,\n\t    (u_int32_t *)(rfap + offsetof(struct fxp_rfa, rbd_addr)));\n\n\t/*\n\t * If there are other buffers already on the list, attach this\n\t * one to the end by fixing up the tail to point to this one.\n\t */\n\tif (sc->rfa_headm != NULL) {\n\t\tsc->rfa_tailm->m_next = m;\n\t\tv = vtophys(rfap);\n\t\trfap = sc->rfa_tailm->m_ext.ext_buf + RFA_ALIGNMENT_FUDGE;\n\t\tfxp_lwcopy(&v,\n\t\t    (u_int32_t *)(rfap + offsetof(struct fxp_rfa, link_addr)));\n\t\t*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, rfa_control)) &=\n\t\t    ~FXP_RFA_CONTROL_EL;\n\t} else {\n\t\tsc->rfa_headm = m;\n\t}\n\tsc->rfa_tailm = m;\n\n\treturn (m == oldm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "sc->rfa_headm"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "txp->mb_head"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "FXP_CSR_PORT",
            "FXP_PORT_SELECTIVE_RESET"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "fxp_stats_update",
            "sc"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define FXP_NRFABUFS\t64\n\nvoid fxp_stop;\nint fxp_add_rfabuf;\nvoid fxp_stats_update;\n\nvoid\nfxp_stop(sc, drain)\n\tstruct fxp_softc *sc;\n\tint drain;\n{\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tstruct fxp_cb_tx *txp;\n\tint i;\n\n\t/*\n\t * Turn down interface (done early to avoid bad interactions\n\t * between panics, shutdown hooks, and the watchdog timer)\n\t */\n\tifp->if_timer = 0;\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\t/*\n\t * Cancel stats updater.\n\t */\n\tuntimeout(fxp_stats_update, sc);\n\n\t/*\n\t * Issue software reset\n\t */\n\tCSR_WRITE_4(sc, FXP_CSR_PORT, FXP_PORT_SELECTIVE_RESET);\n\tDELAY(10);\n\n\t/*\n\t * Release any xmit buffers.\n\t */\n\tfor (txp = sc->cbl_first; txp != NULL && txp->mb_head != NULL;\n\t    txp = txp->next) {\n\t\tm_freem(txp->mb_head);\n\t\ttxp->mb_head = NULL;\n\t}\n\tsc->tx_queued = 0;\n\n\tif (drain) {\n\t\t/*\n\t\t * Free all the receive buffers then reallocate/reinitialize\n\t\t */\n\t\tif (sc->rfa_headm != NULL)\n\t\t\tm_freem(sc->rfa_headm);\n\t\tsc->rfa_headm = NULL;\n\t\tsc->rfa_tailm = NULL;\n\t\tfor (i = 0; i < FXP_NRFABUFS; i++) {\n\t\t\tif (fxp_add_rfabuf(sc, NULL) != 0) {\n\t\t\t\t/*\n\t\t\t\t * This \"can't happen\" - we're at splimp()\n\t\t\t\t * and we just freed all the buffers we need\n\t\t\t\t * above.\n\t\t\t\t */\n\t\t\t\tpanic(\"fxp_stop: no buffers!\");\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "function_name": "fxp_stats_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
    "lines": "911-992",
    "snippet": "void\nfxp_stats_update(arg)\n\tvoid *arg;\n{\n\tstruct fxp_softc *sc = arg;\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tstruct fxp_stats *sp = sc->fxp_stats;\n\tint s;\n\n\tifp->if_opackets += sp->tx_good;\n\tifp->if_collisions += sp->tx_total_collisions;\n\tif (sp->rx_good) {\n\t\tifp->if_ipackets += sp->rx_good;\n\t\tsc->rx_idle_secs = 0;\n\t} else {\n\t\tsc->rx_idle_secs++;\n\t}\n\tifp->if_ierrors +=\n\t    sp->rx_crc_errors +\n\t    sp->rx_alignment_errors +\n\t    sp->rx_rnr_errors +\n\t    sp->rx_overrun_errors;\n\t/*\n\t * If any transmit underruns occured, bump up the transmit\n\t * threshold by another 512 bytes (64 * 8).\n\t */\n\tif (sp->tx_underruns) {\n\t\tifp->if_oerrors += sp->tx_underruns;\n\t\tif (tx_threshold < 192)\n\t\t\ttx_threshold += 64;\n\t}\n\ts = splimp();\n\t/*\n\t * If we haven't received any packets in FXP_MAC_RX_IDLE seconds,\n\t * then assume the receiver has locked up and attempt to clear\n\t * the condition by reprogramming the multicast filter. This is\n\t * a work-around for a bug in the 82557 where the receiver locks\n\t * up if it gets certain types of garbage in the syncronization\n\t * bits prior to the packet header. This bug is supposed to only\n\t * occur in 10Mbps mode, but has been seen to occur in 100Mbps\n\t * mode as well (perhaps due to a 10/100 speed transition).\n\t */\n\tif (sc->rx_idle_secs > FXP_MAX_RX_IDLE) {\n\t\tsc->rx_idle_secs = 0;\n\t\tfxp_mc_setup(sc);\n\t}\n\t/*\n\t * If there is no pending command, start another stats\n\t * dump. Otherwise punt for now.\n\t */\n\tif (CSR_READ_1(sc, FXP_CSR_SCB_COMMAND) == 0) {\n\t\t/*\n\t\t * Start another stats dump.\n\t\t */\n\t\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND,\n\t\t    FXP_SCB_COMMAND_CU_DUMPRESET);\n\t} else {\n\t\t/*\n\t\t * A previous command is still waiting to be accepted.\n\t\t * Just zero our copy of the stats and wait for the\n\t\t * next timer event to update them.\n\t\t */\n\t\tsp->tx_good = 0;\n\t\tsp->tx_underruns = 0;\n\t\tsp->tx_total_collisions = 0;\n\n\t\tsp->rx_good = 0;\n\t\tsp->rx_crc_errors = 0;\n\t\tsp->rx_alignment_errors = 0;\n\t\tsp->rx_rnr_errors = 0;\n\t\tsp->rx_overrun_errors = 0;\n\t}\n\n\t/* Tick the MII clock. */\n\tmii_tick(&sc->sc_mii);\n\n\tsplx(s);\n\t/*\n\t * Schedule another timeout one second from now.\n\t */\n\ttimeout(fxp_stats_update, sc, hz);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/ic/fxpvar.h>",
      "#include <dev/ic/fxpreg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define FXP_MAX_RX_IDLE\t15"
    ],
    "globals_used": [
      "void fxp_stats_update",
      "void fxp_mc_setup",
      "static int tx_threshold = 64;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "fxp_stats_update",
            "sc",
            "hz"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "wdctimeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "952-980",
          "snippet": "void\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define DEBUG_FUNCS  0x08"
          ],
          "globals_used": [
            "static void  __wdcerror"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define DEBUG_FUNCS  0x08\n\nstatic void  __wdcerror;\n\nvoid\nwdctimeout(arg)\n\tvoid *arg;\n{\n\tstruct channel_softc *chp = (struct channel_softc *)arg;\n\tstruct wdc_xfer *xfer = chp->ch_queue->sc_xfer.tqh_first;\n\tint s;\n\n\tWDCDEBUG_PRINT((\"wdctimeout\\n\"), DEBUG_FUNCS);\n\n\ts = splbio();\n\tif ((chp->ch_flags & WDCF_IRQ_WAIT) != 0) {\n\t\t__wdcerror(chp, \"timeout\");\n\t\tprintf(\"\\ttype: %s\\n\", (xfer->c_flags & C_ATAPI) ?\n\t\t    \"atapi\":\"ata\");\n\t\tprintf(\"\\tc_bcount: %d\\n\", xfer->c_bcount);\n\t\tprintf(\"\\tc_skip: %d\\n\", xfer->c_skip);\n\t\t/*\n\t\t * Call the interrupt routine. If we just missed and interrupt,\n\t\t * it will do what's needed. Else, it will take the needed\n\t\t * action (reset the device).\n\t\t */\n\t\txfer->c_flags |= C_TIMEOU;\n\t\tchp->ch_flags &= ~WDCF_IRQ_WAIT;\n\t\txfer->c_intr(chp, xfer, 1);\n\t} else\n\t\t__wdcerror(chp, \"missing untimeout\");\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mii_tick",
          "args": [
            "&sc->sc_mii"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "mii_tick",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/mii.c",
          "lines": "192-201",
          "snippet": "void\nmii_tick(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list))\n\t\t(void) (*child->mii_service)(child, mii, MII_TICK);\n}",
          "includes": [
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nvoid\nmii_tick(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list))\n\t\t(void) (*child->mii_service)(child, mii, MII_TICK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_1",
          "args": [
            "sc",
            "FXP_CSR_SCB_COMMAND",
            "FXP_SCB_COMMAND_CU_DUMPRESET"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_1",
          "args": [
            "sc",
            "FXP_CSR_SCB_COMMAND"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fxp_mc_setup",
          "args": [
            "sc"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "fxp_mc_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
          "lines": "1495-1604",
          "snippet": "void\nfxp_mc_setup(sc)\n\tstruct fxp_softc *sc;\n{\n\tstruct fxp_cb_mcs *mcsp = sc->mcsp;\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tstruct ether_multistep step;\n\tstruct ether_multi *enm;\n\tint nmcasts;\n\n\t/*\n\t * If there are queued commands, we must wait until they are all\n\t * completed. If we are already waiting, then add a NOP command\n\t * with interrupt option so that we're notified when all commands\n\t * have been completed - fxp_start() ensures that no additional\n\t * TX commands will be added when need_mcsetup is true.\n\t */\n\tif (sc->tx_queued) {\n\t\tstruct fxp_cb_tx *txp;\n\n\t\t/*\n\t\t * need_mcsetup will be true if we are already waiting for the\n\t\t * NOP command to be completed (see below). In this case, bail.\n\t\t */\n\t\tif (sc->need_mcsetup)\n\t\t\treturn;\n\t\tsc->need_mcsetup = 1;\n\n\t\t/*\n\t\t * Add a NOP command with interrupt so that we are notified when all\n\t\t * TX commands have been processed.\n\t\t */\n\t\ttxp = sc->cbl_last->next;\n\t\ttxp->mb_head = NULL;\n\t\ttxp->cb_status = 0;\n\t\ttxp->cb_command = FXP_CB_COMMAND_NOP | FXP_CB_COMMAND_S | FXP_CB_COMMAND_I;\n\t\t/*\n\t\t * Advance the end of list forward.\n\t\t */\n\t\tsc->cbl_last->cb_command &= ~FXP_CB_COMMAND_S;\n\t\tsc->cbl_last = txp;\n\t\tsc->tx_queued++;\n\t\t/*\n\t\t * Issue a resume in case the CU has just suspended.\n\t\t */\n\t\tfxp_scb_wait(sc);\n\t\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_RESUME);\n\t\t/*\n\t\t * Set a 5 second timer just in case we don't hear from the\n\t\t * card again.\n\t\t */\n\t\tifp->if_timer = 5;\n\n\t\treturn;\n\t}\n\tsc->need_mcsetup = 0;\n\n\t/*\n\t * Initialize multicast setup descriptor.\n\t */\n\tmcsp->next = sc->cbl_base;\n\tmcsp->mb_head = NULL;\n\tmcsp->cb_status = 0;\n\tmcsp->cb_command = FXP_CB_COMMAND_MCAS | FXP_CB_COMMAND_S | FXP_CB_COMMAND_I;\n\tmcsp->link_addr = vtophys(&sc->cbl_base->cb_status);\n\n\tnmcasts = 0;\n\tif (!sc->all_mcasts) {\n\t\tETHER_FIRST_MULTI(step, &sc->arpcom, enm);\n\t\twhile (enm != NULL) {\n\t\t\tif (nmcasts >= MAXMCADDR) {\n\t\t\t\tsc->all_mcasts = 1;\n\t\t\t\tnmcasts = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Punt on ranges. */\n\t\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi,\n\t\t\t    sizeof(enm->enm_addrlo)) != 0) {\n\t\t\t\tsc->all_mcasts = 1;\n\t\t\t\tnmcasts = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbcopy(enm->enm_addrlo,\n\t\t\t    (void *) &sc->mcsp->mc_addr[nmcasts][0], 6);\n\t\t\tnmcasts++;\n\t\t\tETHER_NEXT_MULTI(step, enm);\n\t\t}\n\t}\n\tmcsp->mc_cnt = nmcasts * 6;\n\tsc->cbl_first = sc->cbl_last = (struct fxp_cb_tx *) mcsp;\n\tsc->tx_queued = 1;\n\n\t/*\n\t * Wait until command unit is not active. This should never\n\t * be the case when nothing is queued, but make sure anyway.\n\t */\n\twhile ((CSR_READ_1(sc, FXP_CSR_SCB_RUSCUS) >> 6) ==\n\t    FXP_SCB_CUS_ACTIVE) ;\n\n\t/*\n\t * Start the multicast setup command.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, vtophys(&mcsp->cb_status));\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\n\tifp->if_timer = 2;\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/ic/fxpvar.h>",
            "#include <dev/ic/fxpreg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void fxp_scb_wait",
            "void fxp_start",
            "void fxp_mc_setup"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic inline void fxp_scb_wait;\nvoid fxp_start;\nvoid fxp_mc_setup;\n\nvoid\nfxp_mc_setup(sc)\n\tstruct fxp_softc *sc;\n{\n\tstruct fxp_cb_mcs *mcsp = sc->mcsp;\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tstruct ether_multistep step;\n\tstruct ether_multi *enm;\n\tint nmcasts;\n\n\t/*\n\t * If there are queued commands, we must wait until they are all\n\t * completed. If we are already waiting, then add a NOP command\n\t * with interrupt option so that we're notified when all commands\n\t * have been completed - fxp_start() ensures that no additional\n\t * TX commands will be added when need_mcsetup is true.\n\t */\n\tif (sc->tx_queued) {\n\t\tstruct fxp_cb_tx *txp;\n\n\t\t/*\n\t\t * need_mcsetup will be true if we are already waiting for the\n\t\t * NOP command to be completed (see below). In this case, bail.\n\t\t */\n\t\tif (sc->need_mcsetup)\n\t\t\treturn;\n\t\tsc->need_mcsetup = 1;\n\n\t\t/*\n\t\t * Add a NOP command with interrupt so that we are notified when all\n\t\t * TX commands have been processed.\n\t\t */\n\t\ttxp = sc->cbl_last->next;\n\t\ttxp->mb_head = NULL;\n\t\ttxp->cb_status = 0;\n\t\ttxp->cb_command = FXP_CB_COMMAND_NOP | FXP_CB_COMMAND_S | FXP_CB_COMMAND_I;\n\t\t/*\n\t\t * Advance the end of list forward.\n\t\t */\n\t\tsc->cbl_last->cb_command &= ~FXP_CB_COMMAND_S;\n\t\tsc->cbl_last = txp;\n\t\tsc->tx_queued++;\n\t\t/*\n\t\t * Issue a resume in case the CU has just suspended.\n\t\t */\n\t\tfxp_scb_wait(sc);\n\t\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_RESUME);\n\t\t/*\n\t\t * Set a 5 second timer just in case we don't hear from the\n\t\t * card again.\n\t\t */\n\t\tifp->if_timer = 5;\n\n\t\treturn;\n\t}\n\tsc->need_mcsetup = 0;\n\n\t/*\n\t * Initialize multicast setup descriptor.\n\t */\n\tmcsp->next = sc->cbl_base;\n\tmcsp->mb_head = NULL;\n\tmcsp->cb_status = 0;\n\tmcsp->cb_command = FXP_CB_COMMAND_MCAS | FXP_CB_COMMAND_S | FXP_CB_COMMAND_I;\n\tmcsp->link_addr = vtophys(&sc->cbl_base->cb_status);\n\n\tnmcasts = 0;\n\tif (!sc->all_mcasts) {\n\t\tETHER_FIRST_MULTI(step, &sc->arpcom, enm);\n\t\twhile (enm != NULL) {\n\t\t\tif (nmcasts >= MAXMCADDR) {\n\t\t\t\tsc->all_mcasts = 1;\n\t\t\t\tnmcasts = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Punt on ranges. */\n\t\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi,\n\t\t\t    sizeof(enm->enm_addrlo)) != 0) {\n\t\t\t\tsc->all_mcasts = 1;\n\t\t\t\tnmcasts = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbcopy(enm->enm_addrlo,\n\t\t\t    (void *) &sc->mcsp->mc_addr[nmcasts][0], 6);\n\t\t\tnmcasts++;\n\t\t\tETHER_NEXT_MULTI(step, enm);\n\t\t}\n\t}\n\tmcsp->mc_cnt = nmcasts * 6;\n\tsc->cbl_first = sc->cbl_last = (struct fxp_cb_tx *) mcsp;\n\tsc->tx_queued = 1;\n\n\t/*\n\t * Wait until command unit is not active. This should never\n\t * be the case when nothing is queued, but make sure anyway.\n\t */\n\twhile ((CSR_READ_1(sc, FXP_CSR_SCB_RUSCUS) >> 6) ==\n\t    FXP_SCB_CUS_ACTIVE) ;\n\n\t/*\n\t * Start the multicast setup command.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, vtophys(&mcsp->cb_status));\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\n\tifp->if_timer = 2;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define FXP_MAX_RX_IDLE\t15\n\nvoid fxp_stats_update;\nvoid fxp_mc_setup;\nstatic int tx_threshold = 64;\n\nvoid\nfxp_stats_update(arg)\n\tvoid *arg;\n{\n\tstruct fxp_softc *sc = arg;\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tstruct fxp_stats *sp = sc->fxp_stats;\n\tint s;\n\n\tifp->if_opackets += sp->tx_good;\n\tifp->if_collisions += sp->tx_total_collisions;\n\tif (sp->rx_good) {\n\t\tifp->if_ipackets += sp->rx_good;\n\t\tsc->rx_idle_secs = 0;\n\t} else {\n\t\tsc->rx_idle_secs++;\n\t}\n\tifp->if_ierrors +=\n\t    sp->rx_crc_errors +\n\t    sp->rx_alignment_errors +\n\t    sp->rx_rnr_errors +\n\t    sp->rx_overrun_errors;\n\t/*\n\t * If any transmit underruns occured, bump up the transmit\n\t * threshold by another 512 bytes (64 * 8).\n\t */\n\tif (sp->tx_underruns) {\n\t\tifp->if_oerrors += sp->tx_underruns;\n\t\tif (tx_threshold < 192)\n\t\t\ttx_threshold += 64;\n\t}\n\ts = splimp();\n\t/*\n\t * If we haven't received any packets in FXP_MAC_RX_IDLE seconds,\n\t * then assume the receiver has locked up and attempt to clear\n\t * the condition by reprogramming the multicast filter. This is\n\t * a work-around for a bug in the 82557 where the receiver locks\n\t * up if it gets certain types of garbage in the syncronization\n\t * bits prior to the packet header. This bug is supposed to only\n\t * occur in 10Mbps mode, but has been seen to occur in 100Mbps\n\t * mode as well (perhaps due to a 10/100 speed transition).\n\t */\n\tif (sc->rx_idle_secs > FXP_MAX_RX_IDLE) {\n\t\tsc->rx_idle_secs = 0;\n\t\tfxp_mc_setup(sc);\n\t}\n\t/*\n\t * If there is no pending command, start another stats\n\t * dump. Otherwise punt for now.\n\t */\n\tif (CSR_READ_1(sc, FXP_CSR_SCB_COMMAND) == 0) {\n\t\t/*\n\t\t * Start another stats dump.\n\t\t */\n\t\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND,\n\t\t    FXP_SCB_COMMAND_CU_DUMPRESET);\n\t} else {\n\t\t/*\n\t\t * A previous command is still waiting to be accepted.\n\t\t * Just zero our copy of the stats and wait for the\n\t\t * next timer event to update them.\n\t\t */\n\t\tsp->tx_good = 0;\n\t\tsp->tx_underruns = 0;\n\t\tsp->tx_total_collisions = 0;\n\n\t\tsp->rx_good = 0;\n\t\tsp->rx_crc_errors = 0;\n\t\tsp->rx_alignment_errors = 0;\n\t\tsp->rx_rnr_errors = 0;\n\t\tsp->rx_overrun_errors = 0;\n\t}\n\n\t/* Tick the MII clock. */\n\tmii_tick(&sc->sc_mii);\n\n\tsplx(s);\n\t/*\n\t * Schedule another timeout one second from now.\n\t */\n\ttimeout(fxp_stats_update, sc, hz);\n}"
  },
  {
    "function_name": "fxp_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
    "lines": "775-898",
    "snippet": "int\nfxp_intr(arg)\n\tvoid *arg;\n{\n\tstruct fxp_softc *sc = arg;\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tu_int8_t statack;\n\tint claimed = 0;\n\n\t/*\n\t * If the interface isn't running, don't try to\n\t * service the interrupt.. just ack it and bail.\n\t */\n\tif ((ifp->if_flags & IFF_RUNNING) == 0) {\n\t\tstatack = CSR_READ_1(sc, FXP_CSR_SCB_STATACK);\n\t\tif (statack) {\n\t\t\tclaimed = 1;\n\t\t\tCSR_WRITE_1(sc, FXP_CSR_SCB_STATACK, statack);\n\t\t}\n\t\treturn claimed;\n\t}\n\n\twhile ((statack = CSR_READ_1(sc, FXP_CSR_SCB_STATACK)) != 0) {\n\t\tclaimed = 1;\n\t\t/*\n\t\t * First ACK all the interrupts in this pass.\n\t\t */\n\t\tCSR_WRITE_1(sc, FXP_CSR_SCB_STATACK, statack);\n\n\t\t/*\n\t\t * Free any finished transmit mbuf chains.\n\t\t */\n\t\tif (statack & FXP_SCB_STATACK_CXTNO) {\n\t\t\tstruct fxp_cb_tx *txp;\n\n\t\t\tfor (txp = sc->cbl_first; sc->tx_queued &&\n\t\t\t    (txp->cb_status & FXP_CB_STATUS_C) != 0;\n\t\t\t    txp = txp->next) {\n\t\t\t\tif (txp->mb_head != NULL) {\n\t\t\t\t\tm_freem(txp->mb_head);\n\t\t\t\t\ttxp->mb_head = NULL;\n\t\t\t\t}\n\t\t\t\tsc->tx_queued--;\n\t\t\t}\n\t\t\tsc->cbl_first = txp;\n\t\t\tifp->if_timer = 0;\n\t\t\tif (sc->tx_queued == 0) {\n\t\t\t\tif (sc->need_mcsetup)\n\t\t\t\t\tfxp_mc_setup(sc);\n\t\t\t}\n\t\t\t/*\n\t\t\t * Try to start more packets transmitting.\n\t\t\t */\n\t\t\tif (ifp->if_snd.ifq_head != NULL)\n\t\t\t\tfxp_start(ifp);\n\t\t}\n\t\t/*\n\t\t * Process receiver interrupts. If a no-resource (RNR)\n\t\t * condition exists, get whatever packets we can and\n\t\t * re-start the receiver.\n\t\t */\n\t\tif (statack & (FXP_SCB_STATACK_FR | FXP_SCB_STATACK_RNR)) {\n\t\t\tstruct mbuf *m;\n\t\t\tu_int8_t *rfap;\nrcvloop:\n\t\t\tm = sc->rfa_headm;\n\t\t\trfap = m->m_ext.ext_buf + RFA_ALIGNMENT_FUDGE;\n\n\t\t\tif (*(u_int16_t *)(rfap +\n\t\t\t    offsetof(struct fxp_rfa, rfa_status)) &\n\t\t\t    FXP_RFA_STATUS_C) {\n\t\t\t\t/*\n\t\t\t\t * Remove first packet from the chain.\n\t\t\t\t */\n\t\t\t\tsc->rfa_headm = m->m_next;\n\t\t\t\tm->m_next = NULL;\n\n\t\t\t\t/*\n\t\t\t\t * Add a new buffer to the receive chain.\n\t\t\t\t * If this fails, the old buffer is recycled\n\t\t\t\t * instead.\n\t\t\t\t */\n\t\t\t\tif (fxp_add_rfabuf(sc, m) == 0) {\n\t\t\t\t\tstruct ether_header *eh;\n\t\t\t\t\tu_int16_t total_len;\n\n\t\t\t\t\ttotal_len = *(u_int16_t *)(rfap +\n\t\t\t\t\t    offsetof(struct fxp_rfa,\n\t\t\t\t\t    actual_size)) &\n\t\t\t\t\t    (MCLBYTES - 1);\n\t\t\t\t\tif (total_len <\n\t\t\t\t\t    sizeof(struct ether_header)) {\n\t\t\t\t\t\tm_freem(m);\n\t\t\t\t\t\tgoto rcvloop;\n\t\t\t\t\t}\n\t\t\t\t\tm->m_pkthdr.rcvif = ifp;\n\t\t\t\t\tm->m_pkthdr.len = m->m_len =\n\t\t\t\t\t    total_len -\n\t\t\t\t\t    sizeof(struct ether_header);\n\t\t\t\t\teh = mtod(m, struct ether_header *);\n#if NBPFILTER > 0\n\t\t\t\t\tif (ifp->if_bpf)\n\t\t\t\t\t\tbpf_tap(ifp->if_bpf,\n\t\t\t\t\t\t    mtod(m, caddr_t),\n\t\t\t\t\t\t    total_len); \n#endif /* NBPFILTER > 0 */\n\t\t\t\t\tm->m_data +=\n\t\t\t\t\t    sizeof(struct ether_header);\n\t\t\t\t\tether_input(ifp, eh, m);\n\t\t\t\t}\n\t\t\t\tgoto rcvloop;\n\t\t\t}\n\t\t\tif (statack & FXP_SCB_STATACK_RNR) {\n\t\t\t\tfxp_scb_wait(sc);\n\t\t\t\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL,\n\t\t\t\t    vtophys(sc->rfa_headm->m_ext.ext_buf) +\n\t\t\t\t\tRFA_ALIGNMENT_FUDGE);\n\t\t\t\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND,\n\t\t\t\t    FXP_SCB_COMMAND_RU_START);\n\t\t\t}\n\t\t}\n\t}\n\treturn (claimed);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/ic/fxpvar.h>",
      "#include <dev/ic/fxpreg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define\tRFA_ALIGNMENT_FUDGE\t2"
    ],
    "globals_used": [
      "static inline void fxp_scb_wait",
      "void fxp_start",
      "int fxp_add_rfabuf",
      "void fxp_mc_setup"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_1",
          "args": [
            "sc",
            "FXP_CSR_SCB_COMMAND",
            "FXP_SCB_COMMAND_RU_START"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "FXP_CSR_SCB_GENERAL",
            "vtophys(sc->rfa_headm->m_ext.ext_buf) +\n\t\t\t\t\tRFA_ALIGNMENT_FUDGE"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "sc->rfa_headm->m_ext.ext_buf"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fxp_scb_wait",
          "args": [
            "sc"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "fxp_scb_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
          "lines": "237-244",
          "snippet": "static inline void\nfxp_scb_wait(sc)\n\tstruct fxp_softc *sc;\n{\n\tint i = 10000;\n\n\twhile (CSR_READ_1(sc, FXP_CSR_SCB_COMMAND) && --i);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/ic/fxpvar.h>",
            "#include <dev/ic/fxpreg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void fxp_scb_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic inline void fxp_scb_wait;\n\nstatic inline void\nfxp_scb_wait(sc)\n\tstruct fxp_softc *sc;\n{\n\tint i = 10000;\n\n\twhile (CSR_READ_1(sc, FXP_CSR_SCB_COMMAND) && --i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_input",
          "args": [
            "ifp",
            "eh",
            "m"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_tap",
          "args": [
            "ifp->if_bpf",
            "mtod(m, caddr_t)",
            "total_len"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "caddr_t"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "structether_header*"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fxp_add_rfabuf",
          "args": [
            "sc",
            "m"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "fxp_add_rfabuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
          "lines": "1272-1347",
          "snippet": "int\nfxp_add_rfabuf(sc, oldm)\n\tstruct fxp_softc *sc;\n\tstruct mbuf *oldm;\n{\n\tu_int32_t v;\n\tstruct mbuf *m;\n\tu_int8_t *rfap;\n\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\tif (m != NULL) {\n\t\tMCLGET(m, M_DONTWAIT);\n\t\tif ((m->m_flags & M_EXT) == 0) {\n\t\t\tm_freem(m);\n\t\t\tif (oldm == NULL)\n\t\t\t\treturn 1;\n\t\t\tm = oldm;\n\t\t\tm->m_data = m->m_ext.ext_buf;\n\t\t}\n\t} else {\n\t\tif (oldm == NULL)\n\t\t\treturn 1;\n\t\tm = oldm;\n\t\tm->m_data = m->m_ext.ext_buf;\n\t}\n\n\t/*\n\t * Move the data pointer up so that the incoming data packet\n\t * will be 32-bit aligned.\n\t */\n\tm->m_data += RFA_ALIGNMENT_FUDGE;\n\n\t/*\n\t * Get a pointer to the base of the mbuf cluster and move\n\t * data start past it.\n\t */\n\trfap = m->m_data;\n\tm->m_data += sizeof(struct fxp_rfa);\n\t*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, size)) =\n\t    MCLBYTES - sizeof(struct fxp_rfa) - RFA_ALIGNMENT_FUDGE;\n\n\t/*\n\t * Initialize the rest of the RFA.  Note that since the RFA\n\t * is misaligned, we cannot store values directly.  Instead,\n\t * we use an optimized, inline copy.\n\t */\n\t*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, rfa_status)) = 0;\n\t*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, rfa_control)) =\n\t    FXP_RFA_CONTROL_EL;\n\t*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, actual_size)) = 0;\n\n\tv = -1;\n\tfxp_lwcopy(&v,\n\t    (u_int32_t *)(rfap + offsetof(struct fxp_rfa, link_addr)));\n\tfxp_lwcopy(&v,\n\t    (u_int32_t *)(rfap + offsetof(struct fxp_rfa, rbd_addr)));\n\n\t/*\n\t * If there are other buffers already on the list, attach this\n\t * one to the end by fixing up the tail to point to this one.\n\t */\n\tif (sc->rfa_headm != NULL) {\n\t\tsc->rfa_tailm->m_next = m;\n\t\tv = vtophys(rfap);\n\t\trfap = sc->rfa_tailm->m_ext.ext_buf + RFA_ALIGNMENT_FUDGE;\n\t\tfxp_lwcopy(&v,\n\t\t    (u_int32_t *)(rfap + offsetof(struct fxp_rfa, link_addr)));\n\t\t*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, rfa_control)) &=\n\t\t    ~FXP_RFA_CONTROL_EL;\n\t} else {\n\t\tsc->rfa_headm = m;\n\t}\n\tsc->rfa_tailm = m;\n\n\treturn (m == oldm);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/ic/fxpvar.h>",
            "#include <dev/ic/fxpreg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tRFA_ALIGNMENT_FUDGE\t2"
          ],
          "globals_used": [
            "static __inline void fxp_lwcopy",
            "int fxp_add_rfabuf"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tRFA_ALIGNMENT_FUDGE\t2\n\nstatic __inline void fxp_lwcopy;\nint fxp_add_rfabuf;\n\nint\nfxp_add_rfabuf(sc, oldm)\n\tstruct fxp_softc *sc;\n\tstruct mbuf *oldm;\n{\n\tu_int32_t v;\n\tstruct mbuf *m;\n\tu_int8_t *rfap;\n\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\tif (m != NULL) {\n\t\tMCLGET(m, M_DONTWAIT);\n\t\tif ((m->m_flags & M_EXT) == 0) {\n\t\t\tm_freem(m);\n\t\t\tif (oldm == NULL)\n\t\t\t\treturn 1;\n\t\t\tm = oldm;\n\t\t\tm->m_data = m->m_ext.ext_buf;\n\t\t}\n\t} else {\n\t\tif (oldm == NULL)\n\t\t\treturn 1;\n\t\tm = oldm;\n\t\tm->m_data = m->m_ext.ext_buf;\n\t}\n\n\t/*\n\t * Move the data pointer up so that the incoming data packet\n\t * will be 32-bit aligned.\n\t */\n\tm->m_data += RFA_ALIGNMENT_FUDGE;\n\n\t/*\n\t * Get a pointer to the base of the mbuf cluster and move\n\t * data start past it.\n\t */\n\trfap = m->m_data;\n\tm->m_data += sizeof(struct fxp_rfa);\n\t*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, size)) =\n\t    MCLBYTES - sizeof(struct fxp_rfa) - RFA_ALIGNMENT_FUDGE;\n\n\t/*\n\t * Initialize the rest of the RFA.  Note that since the RFA\n\t * is misaligned, we cannot store values directly.  Instead,\n\t * we use an optimized, inline copy.\n\t */\n\t*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, rfa_status)) = 0;\n\t*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, rfa_control)) =\n\t    FXP_RFA_CONTROL_EL;\n\t*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, actual_size)) = 0;\n\n\tv = -1;\n\tfxp_lwcopy(&v,\n\t    (u_int32_t *)(rfap + offsetof(struct fxp_rfa, link_addr)));\n\tfxp_lwcopy(&v,\n\t    (u_int32_t *)(rfap + offsetof(struct fxp_rfa, rbd_addr)));\n\n\t/*\n\t * If there are other buffers already on the list, attach this\n\t * one to the end by fixing up the tail to point to this one.\n\t */\n\tif (sc->rfa_headm != NULL) {\n\t\tsc->rfa_tailm->m_next = m;\n\t\tv = vtophys(rfap);\n\t\trfap = sc->rfa_tailm->m_ext.ext_buf + RFA_ALIGNMENT_FUDGE;\n\t\tfxp_lwcopy(&v,\n\t\t    (u_int32_t *)(rfap + offsetof(struct fxp_rfa, link_addr)));\n\t\t*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, rfa_control)) &=\n\t\t    ~FXP_RFA_CONTROL_EL;\n\t} else {\n\t\tsc->rfa_headm = m;\n\t}\n\tsc->rfa_tailm = m;\n\n\treturn (m == oldm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fxp_start",
          "args": [
            "ifp"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "fxp_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
          "lines": "639-770",
          "snippet": "void\nfxp_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct fxp_softc *sc = ifp->if_softc;\n\tstruct fxp_cb_tx *txp;\n\n\t/*\n\t * See if we need to suspend xmit until the multicast filter\n\t * has been reprogrammed (which can only be done at the head\n\t * of the command chain).\n\t */\n\tif (sc->need_mcsetup)\n\t\treturn;\n\n\ttxp = NULL;\n\n\t/*\n\t * We're finished if there is nothing more to add to the list or if\n\t * we're all filled up with buffers to transmit.\n\t * NOTE: One TxCB is reserved to guarantee that fxp_mc_setup() can add\n\t *       a NOP command when needed.\n\t */\n\twhile (ifp->if_snd.ifq_head != NULL && sc->tx_queued < FXP_NTXCB - 1) {\n\t\tstruct mbuf *m, *mb_head;\n\t\tint segment;\n\n\t\t/*\n\t\t * Grab a packet to transmit.\n\t\t */\n\t\tIF_DEQUEUE(&ifp->if_snd, mb_head);\n\n\t\t/*\n\t\t * Get pointer to next available tx desc.\n\t\t */\n\t\ttxp = sc->cbl_last->next;\n\n\t\t/*\n\t\t * Go through each of the mbufs in the chain and initialize\n\t\t * the transmit buffer descriptors with the physical address\n\t\t * and size of the mbuf.\n\t\t */\ntbdinit:\n\t\tfor (m = mb_head, segment = 0; m != NULL; m = m->m_next) {\n\t\t\tif (m->m_len != 0) {\n\t\t\t\tif (segment == FXP_NTXSEG)\n\t\t\t\t\tbreak;\n\t\t\t\ttxp->tbd[segment].tb_addr =\n\t\t\t\t    vtophys(mtod(m, vm_offset_t));\n\t\t\t\ttxp->tbd[segment].tb_size = m->m_len;\n\t\t\t\tsegment++;\n\t\t\t}\n\t\t}\n\t\tif (m != NULL) {\n\t\t\tstruct mbuf *mn;\n\n\t\t\t/*\n\t\t\t * We ran out of segments. We have to recopy this mbuf\n\t\t\t * chain first. Bail out if we can't get the new buffers.\n\t\t\t */\n\t\t\tMGETHDR(mn, M_DONTWAIT, MT_DATA);\n\t\t\tif (mn == NULL) {\n\t\t\t\tm_freem(mb_head);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (mb_head->m_pkthdr.len > MHLEN) {\n\t\t\t\tMCLGET(mn, M_DONTWAIT);\n\t\t\t\tif ((mn->m_flags & M_EXT) == 0) {\n\t\t\t\t\tm_freem(mn);\n\t\t\t\t\tm_freem(mb_head);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tm_copydata(mb_head, 0, mb_head->m_pkthdr.len,\n\t\t\t    mtod(mn, caddr_t));\n\t\t\tmn->m_pkthdr.len = mn->m_len = mb_head->m_pkthdr.len;\n\t\t\tm_freem(mb_head);\n\t\t\tmb_head = mn;\n\t\t\tgoto tbdinit;\n\t\t}\n\n\t\ttxp->tbd_number = segment;\n\t\ttxp->mb_head = mb_head;\n\t\ttxp->cb_status = 0;\n\t\tif (sc->tx_queued != FXP_CXINT_THRESH - 1) {\n\t\t\ttxp->cb_command =\n\t\t\t    FXP_CB_COMMAND_XMIT | FXP_CB_COMMAND_SF | FXP_CB_COMMAND_S;\n\t\t} else {\n\t\t\ttxp->cb_command =\n\t\t\t    FXP_CB_COMMAND_XMIT | FXP_CB_COMMAND_SF | FXP_CB_COMMAND_S | FXP_CB_COMMAND_I;\n\t\t\t/*\n\t\t\t * Set a 5 second timer just in case we don't hear from the\n\t\t\t * card again.\n\t\t\t */\n\t\t\tifp->if_timer = 5;\n\t\t}\n\t\ttxp->tx_threshold = tx_threshold;\n\t\n\t\t/*\n\t\t * Advance the end of list forward.\n\t\t */\n\t\tsc->cbl_last->cb_command &= ~FXP_CB_COMMAND_S;\n\t\tsc->cbl_last = txp;\n\n\t\t/*\n\t\t * Advance the beginning of the list forward if there are\n\t\t * no other packets queued (when nothing is queued, cbl_first\n\t\t * sits on the last TxCB that was sent out).\n\t\t */\n\t\tif (sc->tx_queued == 0)\n\t\t\tsc->cbl_first = txp;\n\n\t\tsc->tx_queued++;\n\n#if NBPFILTER > 0\n\t\t/*\n\t\t * Pass packet to bpf if there is a listener.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, mb_head);\n#endif\n\t}\n\n\t/*\n\t * We're finished. If we added to the list, issue a RESUME to get DMA\n\t * going again if suspended.\n\t */\n\tif (txp != NULL) {\n\t\tfxp_scb_wait(sc);\n\t\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_RESUME);\n\t}\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/ic/fxpvar.h>",
            "#include <dev/ic/fxpreg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define FXP_CXINT_THRESH 120",
            "#define FXP_NTXCB\t128"
          ],
          "globals_used": [
            "static inline void fxp_scb_wait",
            "void fxp_start",
            "void fxp_mc_setup",
            "static int tx_threshold = 64;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define FXP_CXINT_THRESH 120\n#define FXP_NTXCB\t128\n\nstatic inline void fxp_scb_wait;\nvoid fxp_start;\nvoid fxp_mc_setup;\nstatic int tx_threshold = 64;\n\nvoid\nfxp_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct fxp_softc *sc = ifp->if_softc;\n\tstruct fxp_cb_tx *txp;\n\n\t/*\n\t * See if we need to suspend xmit until the multicast filter\n\t * has been reprogrammed (which can only be done at the head\n\t * of the command chain).\n\t */\n\tif (sc->need_mcsetup)\n\t\treturn;\n\n\ttxp = NULL;\n\n\t/*\n\t * We're finished if there is nothing more to add to the list or if\n\t * we're all filled up with buffers to transmit.\n\t * NOTE: One TxCB is reserved to guarantee that fxp_mc_setup() can add\n\t *       a NOP command when needed.\n\t */\n\twhile (ifp->if_snd.ifq_head != NULL && sc->tx_queued < FXP_NTXCB - 1) {\n\t\tstruct mbuf *m, *mb_head;\n\t\tint segment;\n\n\t\t/*\n\t\t * Grab a packet to transmit.\n\t\t */\n\t\tIF_DEQUEUE(&ifp->if_snd, mb_head);\n\n\t\t/*\n\t\t * Get pointer to next available tx desc.\n\t\t */\n\t\ttxp = sc->cbl_last->next;\n\n\t\t/*\n\t\t * Go through each of the mbufs in the chain and initialize\n\t\t * the transmit buffer descriptors with the physical address\n\t\t * and size of the mbuf.\n\t\t */\ntbdinit:\n\t\tfor (m = mb_head, segment = 0; m != NULL; m = m->m_next) {\n\t\t\tif (m->m_len != 0) {\n\t\t\t\tif (segment == FXP_NTXSEG)\n\t\t\t\t\tbreak;\n\t\t\t\ttxp->tbd[segment].tb_addr =\n\t\t\t\t    vtophys(mtod(m, vm_offset_t));\n\t\t\t\ttxp->tbd[segment].tb_size = m->m_len;\n\t\t\t\tsegment++;\n\t\t\t}\n\t\t}\n\t\tif (m != NULL) {\n\t\t\tstruct mbuf *mn;\n\n\t\t\t/*\n\t\t\t * We ran out of segments. We have to recopy this mbuf\n\t\t\t * chain first. Bail out if we can't get the new buffers.\n\t\t\t */\n\t\t\tMGETHDR(mn, M_DONTWAIT, MT_DATA);\n\t\t\tif (mn == NULL) {\n\t\t\t\tm_freem(mb_head);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (mb_head->m_pkthdr.len > MHLEN) {\n\t\t\t\tMCLGET(mn, M_DONTWAIT);\n\t\t\t\tif ((mn->m_flags & M_EXT) == 0) {\n\t\t\t\t\tm_freem(mn);\n\t\t\t\t\tm_freem(mb_head);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tm_copydata(mb_head, 0, mb_head->m_pkthdr.len,\n\t\t\t    mtod(mn, caddr_t));\n\t\t\tmn->m_pkthdr.len = mn->m_len = mb_head->m_pkthdr.len;\n\t\t\tm_freem(mb_head);\n\t\t\tmb_head = mn;\n\t\t\tgoto tbdinit;\n\t\t}\n\n\t\ttxp->tbd_number = segment;\n\t\ttxp->mb_head = mb_head;\n\t\ttxp->cb_status = 0;\n\t\tif (sc->tx_queued != FXP_CXINT_THRESH - 1) {\n\t\t\ttxp->cb_command =\n\t\t\t    FXP_CB_COMMAND_XMIT | FXP_CB_COMMAND_SF | FXP_CB_COMMAND_S;\n\t\t} else {\n\t\t\ttxp->cb_command =\n\t\t\t    FXP_CB_COMMAND_XMIT | FXP_CB_COMMAND_SF | FXP_CB_COMMAND_S | FXP_CB_COMMAND_I;\n\t\t\t/*\n\t\t\t * Set a 5 second timer just in case we don't hear from the\n\t\t\t * card again.\n\t\t\t */\n\t\t\tifp->if_timer = 5;\n\t\t}\n\t\ttxp->tx_threshold = tx_threshold;\n\t\n\t\t/*\n\t\t * Advance the end of list forward.\n\t\t */\n\t\tsc->cbl_last->cb_command &= ~FXP_CB_COMMAND_S;\n\t\tsc->cbl_last = txp;\n\n\t\t/*\n\t\t * Advance the beginning of the list forward if there are\n\t\t * no other packets queued (when nothing is queued, cbl_first\n\t\t * sits on the last TxCB that was sent out).\n\t\t */\n\t\tif (sc->tx_queued == 0)\n\t\t\tsc->cbl_first = txp;\n\n\t\tsc->tx_queued++;\n\n#if NBPFILTER > 0\n\t\t/*\n\t\t * Pass packet to bpf if there is a listener.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, mb_head);\n#endif\n\t}\n\n\t/*\n\t * We're finished. If we added to the list, issue a RESUME to get DMA\n\t * going again if suspended.\n\t */\n\tif (txp != NULL) {\n\t\tfxp_scb_wait(sc);\n\t\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_RESUME);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fxp_mc_setup",
          "args": [
            "sc"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "fxp_mc_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
          "lines": "1495-1604",
          "snippet": "void\nfxp_mc_setup(sc)\n\tstruct fxp_softc *sc;\n{\n\tstruct fxp_cb_mcs *mcsp = sc->mcsp;\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tstruct ether_multistep step;\n\tstruct ether_multi *enm;\n\tint nmcasts;\n\n\t/*\n\t * If there are queued commands, we must wait until they are all\n\t * completed. If we are already waiting, then add a NOP command\n\t * with interrupt option so that we're notified when all commands\n\t * have been completed - fxp_start() ensures that no additional\n\t * TX commands will be added when need_mcsetup is true.\n\t */\n\tif (sc->tx_queued) {\n\t\tstruct fxp_cb_tx *txp;\n\n\t\t/*\n\t\t * need_mcsetup will be true if we are already waiting for the\n\t\t * NOP command to be completed (see below). In this case, bail.\n\t\t */\n\t\tif (sc->need_mcsetup)\n\t\t\treturn;\n\t\tsc->need_mcsetup = 1;\n\n\t\t/*\n\t\t * Add a NOP command with interrupt so that we are notified when all\n\t\t * TX commands have been processed.\n\t\t */\n\t\ttxp = sc->cbl_last->next;\n\t\ttxp->mb_head = NULL;\n\t\ttxp->cb_status = 0;\n\t\ttxp->cb_command = FXP_CB_COMMAND_NOP | FXP_CB_COMMAND_S | FXP_CB_COMMAND_I;\n\t\t/*\n\t\t * Advance the end of list forward.\n\t\t */\n\t\tsc->cbl_last->cb_command &= ~FXP_CB_COMMAND_S;\n\t\tsc->cbl_last = txp;\n\t\tsc->tx_queued++;\n\t\t/*\n\t\t * Issue a resume in case the CU has just suspended.\n\t\t */\n\t\tfxp_scb_wait(sc);\n\t\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_RESUME);\n\t\t/*\n\t\t * Set a 5 second timer just in case we don't hear from the\n\t\t * card again.\n\t\t */\n\t\tifp->if_timer = 5;\n\n\t\treturn;\n\t}\n\tsc->need_mcsetup = 0;\n\n\t/*\n\t * Initialize multicast setup descriptor.\n\t */\n\tmcsp->next = sc->cbl_base;\n\tmcsp->mb_head = NULL;\n\tmcsp->cb_status = 0;\n\tmcsp->cb_command = FXP_CB_COMMAND_MCAS | FXP_CB_COMMAND_S | FXP_CB_COMMAND_I;\n\tmcsp->link_addr = vtophys(&sc->cbl_base->cb_status);\n\n\tnmcasts = 0;\n\tif (!sc->all_mcasts) {\n\t\tETHER_FIRST_MULTI(step, &sc->arpcom, enm);\n\t\twhile (enm != NULL) {\n\t\t\tif (nmcasts >= MAXMCADDR) {\n\t\t\t\tsc->all_mcasts = 1;\n\t\t\t\tnmcasts = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Punt on ranges. */\n\t\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi,\n\t\t\t    sizeof(enm->enm_addrlo)) != 0) {\n\t\t\t\tsc->all_mcasts = 1;\n\t\t\t\tnmcasts = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbcopy(enm->enm_addrlo,\n\t\t\t    (void *) &sc->mcsp->mc_addr[nmcasts][0], 6);\n\t\t\tnmcasts++;\n\t\t\tETHER_NEXT_MULTI(step, enm);\n\t\t}\n\t}\n\tmcsp->mc_cnt = nmcasts * 6;\n\tsc->cbl_first = sc->cbl_last = (struct fxp_cb_tx *) mcsp;\n\tsc->tx_queued = 1;\n\n\t/*\n\t * Wait until command unit is not active. This should never\n\t * be the case when nothing is queued, but make sure anyway.\n\t */\n\twhile ((CSR_READ_1(sc, FXP_CSR_SCB_RUSCUS) >> 6) ==\n\t    FXP_SCB_CUS_ACTIVE) ;\n\n\t/*\n\t * Start the multicast setup command.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, vtophys(&mcsp->cb_status));\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\n\tifp->if_timer = 2;\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/ic/fxpvar.h>",
            "#include <dev/ic/fxpreg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void fxp_scb_wait",
            "void fxp_start",
            "void fxp_mc_setup"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic inline void fxp_scb_wait;\nvoid fxp_start;\nvoid fxp_mc_setup;\n\nvoid\nfxp_mc_setup(sc)\n\tstruct fxp_softc *sc;\n{\n\tstruct fxp_cb_mcs *mcsp = sc->mcsp;\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tstruct ether_multistep step;\n\tstruct ether_multi *enm;\n\tint nmcasts;\n\n\t/*\n\t * If there are queued commands, we must wait until they are all\n\t * completed. If we are already waiting, then add a NOP command\n\t * with interrupt option so that we're notified when all commands\n\t * have been completed - fxp_start() ensures that no additional\n\t * TX commands will be added when need_mcsetup is true.\n\t */\n\tif (sc->tx_queued) {\n\t\tstruct fxp_cb_tx *txp;\n\n\t\t/*\n\t\t * need_mcsetup will be true if we are already waiting for the\n\t\t * NOP command to be completed (see below). In this case, bail.\n\t\t */\n\t\tif (sc->need_mcsetup)\n\t\t\treturn;\n\t\tsc->need_mcsetup = 1;\n\n\t\t/*\n\t\t * Add a NOP command with interrupt so that we are notified when all\n\t\t * TX commands have been processed.\n\t\t */\n\t\ttxp = sc->cbl_last->next;\n\t\ttxp->mb_head = NULL;\n\t\ttxp->cb_status = 0;\n\t\ttxp->cb_command = FXP_CB_COMMAND_NOP | FXP_CB_COMMAND_S | FXP_CB_COMMAND_I;\n\t\t/*\n\t\t * Advance the end of list forward.\n\t\t */\n\t\tsc->cbl_last->cb_command &= ~FXP_CB_COMMAND_S;\n\t\tsc->cbl_last = txp;\n\t\tsc->tx_queued++;\n\t\t/*\n\t\t * Issue a resume in case the CU has just suspended.\n\t\t */\n\t\tfxp_scb_wait(sc);\n\t\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_RESUME);\n\t\t/*\n\t\t * Set a 5 second timer just in case we don't hear from the\n\t\t * card again.\n\t\t */\n\t\tifp->if_timer = 5;\n\n\t\treturn;\n\t}\n\tsc->need_mcsetup = 0;\n\n\t/*\n\t * Initialize multicast setup descriptor.\n\t */\n\tmcsp->next = sc->cbl_base;\n\tmcsp->mb_head = NULL;\n\tmcsp->cb_status = 0;\n\tmcsp->cb_command = FXP_CB_COMMAND_MCAS | FXP_CB_COMMAND_S | FXP_CB_COMMAND_I;\n\tmcsp->link_addr = vtophys(&sc->cbl_base->cb_status);\n\n\tnmcasts = 0;\n\tif (!sc->all_mcasts) {\n\t\tETHER_FIRST_MULTI(step, &sc->arpcom, enm);\n\t\twhile (enm != NULL) {\n\t\t\tif (nmcasts >= MAXMCADDR) {\n\t\t\t\tsc->all_mcasts = 1;\n\t\t\t\tnmcasts = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Punt on ranges. */\n\t\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi,\n\t\t\t    sizeof(enm->enm_addrlo)) != 0) {\n\t\t\t\tsc->all_mcasts = 1;\n\t\t\t\tnmcasts = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbcopy(enm->enm_addrlo,\n\t\t\t    (void *) &sc->mcsp->mc_addr[nmcasts][0], 6);\n\t\t\tnmcasts++;\n\t\t\tETHER_NEXT_MULTI(step, enm);\n\t\t}\n\t}\n\tmcsp->mc_cnt = nmcasts * 6;\n\tsc->cbl_first = sc->cbl_last = (struct fxp_cb_tx *) mcsp;\n\tsc->tx_queued = 1;\n\n\t/*\n\t * Wait until command unit is not active. This should never\n\t * be the case when nothing is queued, but make sure anyway.\n\t */\n\twhile ((CSR_READ_1(sc, FXP_CSR_SCB_RUSCUS) >> 6) ==\n\t    FXP_SCB_CUS_ACTIVE) ;\n\n\t/*\n\t * Start the multicast setup command.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, vtophys(&mcsp->cb_status));\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\n\tifp->if_timer = 2;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "txp->mb_head"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_1",
          "args": [
            "sc",
            "FXP_CSR_SCB_STATACK",
            "statack"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_1",
          "args": [
            "sc",
            "FXP_CSR_SCB_STATACK"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_1",
          "args": [
            "sc",
            "FXP_CSR_SCB_STATACK",
            "statack"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_1",
          "args": [
            "sc",
            "FXP_CSR_SCB_STATACK"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tRFA_ALIGNMENT_FUDGE\t2\n\nstatic inline void fxp_scb_wait;\nvoid fxp_start;\nint fxp_add_rfabuf;\nvoid fxp_mc_setup;\n\nint\nfxp_intr(arg)\n\tvoid *arg;\n{\n\tstruct fxp_softc *sc = arg;\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tu_int8_t statack;\n\tint claimed = 0;\n\n\t/*\n\t * If the interface isn't running, don't try to\n\t * service the interrupt.. just ack it and bail.\n\t */\n\tif ((ifp->if_flags & IFF_RUNNING) == 0) {\n\t\tstatack = CSR_READ_1(sc, FXP_CSR_SCB_STATACK);\n\t\tif (statack) {\n\t\t\tclaimed = 1;\n\t\t\tCSR_WRITE_1(sc, FXP_CSR_SCB_STATACK, statack);\n\t\t}\n\t\treturn claimed;\n\t}\n\n\twhile ((statack = CSR_READ_1(sc, FXP_CSR_SCB_STATACK)) != 0) {\n\t\tclaimed = 1;\n\t\t/*\n\t\t * First ACK all the interrupts in this pass.\n\t\t */\n\t\tCSR_WRITE_1(sc, FXP_CSR_SCB_STATACK, statack);\n\n\t\t/*\n\t\t * Free any finished transmit mbuf chains.\n\t\t */\n\t\tif (statack & FXP_SCB_STATACK_CXTNO) {\n\t\t\tstruct fxp_cb_tx *txp;\n\n\t\t\tfor (txp = sc->cbl_first; sc->tx_queued &&\n\t\t\t    (txp->cb_status & FXP_CB_STATUS_C) != 0;\n\t\t\t    txp = txp->next) {\n\t\t\t\tif (txp->mb_head != NULL) {\n\t\t\t\t\tm_freem(txp->mb_head);\n\t\t\t\t\ttxp->mb_head = NULL;\n\t\t\t\t}\n\t\t\t\tsc->tx_queued--;\n\t\t\t}\n\t\t\tsc->cbl_first = txp;\n\t\t\tifp->if_timer = 0;\n\t\t\tif (sc->tx_queued == 0) {\n\t\t\t\tif (sc->need_mcsetup)\n\t\t\t\t\tfxp_mc_setup(sc);\n\t\t\t}\n\t\t\t/*\n\t\t\t * Try to start more packets transmitting.\n\t\t\t */\n\t\t\tif (ifp->if_snd.ifq_head != NULL)\n\t\t\t\tfxp_start(ifp);\n\t\t}\n\t\t/*\n\t\t * Process receiver interrupts. If a no-resource (RNR)\n\t\t * condition exists, get whatever packets we can and\n\t\t * re-start the receiver.\n\t\t */\n\t\tif (statack & (FXP_SCB_STATACK_FR | FXP_SCB_STATACK_RNR)) {\n\t\t\tstruct mbuf *m;\n\t\t\tu_int8_t *rfap;\nrcvloop:\n\t\t\tm = sc->rfa_headm;\n\t\t\trfap = m->m_ext.ext_buf + RFA_ALIGNMENT_FUDGE;\n\n\t\t\tif (*(u_int16_t *)(rfap +\n\t\t\t    offsetof(struct fxp_rfa, rfa_status)) &\n\t\t\t    FXP_RFA_STATUS_C) {\n\t\t\t\t/*\n\t\t\t\t * Remove first packet from the chain.\n\t\t\t\t */\n\t\t\t\tsc->rfa_headm = m->m_next;\n\t\t\t\tm->m_next = NULL;\n\n\t\t\t\t/*\n\t\t\t\t * Add a new buffer to the receive chain.\n\t\t\t\t * If this fails, the old buffer is recycled\n\t\t\t\t * instead.\n\t\t\t\t */\n\t\t\t\tif (fxp_add_rfabuf(sc, m) == 0) {\n\t\t\t\t\tstruct ether_header *eh;\n\t\t\t\t\tu_int16_t total_len;\n\n\t\t\t\t\ttotal_len = *(u_int16_t *)(rfap +\n\t\t\t\t\t    offsetof(struct fxp_rfa,\n\t\t\t\t\t    actual_size)) &\n\t\t\t\t\t    (MCLBYTES - 1);\n\t\t\t\t\tif (total_len <\n\t\t\t\t\t    sizeof(struct ether_header)) {\n\t\t\t\t\t\tm_freem(m);\n\t\t\t\t\t\tgoto rcvloop;\n\t\t\t\t\t}\n\t\t\t\t\tm->m_pkthdr.rcvif = ifp;\n\t\t\t\t\tm->m_pkthdr.len = m->m_len =\n\t\t\t\t\t    total_len -\n\t\t\t\t\t    sizeof(struct ether_header);\n\t\t\t\t\teh = mtod(m, struct ether_header *);\n#if NBPFILTER > 0\n\t\t\t\t\tif (ifp->if_bpf)\n\t\t\t\t\t\tbpf_tap(ifp->if_bpf,\n\t\t\t\t\t\t    mtod(m, caddr_t),\n\t\t\t\t\t\t    total_len); \n#endif /* NBPFILTER > 0 */\n\t\t\t\t\tm->m_data +=\n\t\t\t\t\t    sizeof(struct ether_header);\n\t\t\t\t\tether_input(ifp, eh, m);\n\t\t\t\t}\n\t\t\t\tgoto rcvloop;\n\t\t\t}\n\t\t\tif (statack & FXP_SCB_STATACK_RNR) {\n\t\t\t\tfxp_scb_wait(sc);\n\t\t\t\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL,\n\t\t\t\t    vtophys(sc->rfa_headm->m_ext.ext_buf) +\n\t\t\t\t\tRFA_ALIGNMENT_FUDGE);\n\t\t\t\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND,\n\t\t\t\t    FXP_SCB_COMMAND_RU_START);\n\t\t\t}\n\t\t}\n\t}\n\treturn (claimed);\n}"
  },
  {
    "function_name": "fxp_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
    "lines": "639-770",
    "snippet": "void\nfxp_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct fxp_softc *sc = ifp->if_softc;\n\tstruct fxp_cb_tx *txp;\n\n\t/*\n\t * See if we need to suspend xmit until the multicast filter\n\t * has been reprogrammed (which can only be done at the head\n\t * of the command chain).\n\t */\n\tif (sc->need_mcsetup)\n\t\treturn;\n\n\ttxp = NULL;\n\n\t/*\n\t * We're finished if there is nothing more to add to the list or if\n\t * we're all filled up with buffers to transmit.\n\t * NOTE: One TxCB is reserved to guarantee that fxp_mc_setup() can add\n\t *       a NOP command when needed.\n\t */\n\twhile (ifp->if_snd.ifq_head != NULL && sc->tx_queued < FXP_NTXCB - 1) {\n\t\tstruct mbuf *m, *mb_head;\n\t\tint segment;\n\n\t\t/*\n\t\t * Grab a packet to transmit.\n\t\t */\n\t\tIF_DEQUEUE(&ifp->if_snd, mb_head);\n\n\t\t/*\n\t\t * Get pointer to next available tx desc.\n\t\t */\n\t\ttxp = sc->cbl_last->next;\n\n\t\t/*\n\t\t * Go through each of the mbufs in the chain and initialize\n\t\t * the transmit buffer descriptors with the physical address\n\t\t * and size of the mbuf.\n\t\t */\ntbdinit:\n\t\tfor (m = mb_head, segment = 0; m != NULL; m = m->m_next) {\n\t\t\tif (m->m_len != 0) {\n\t\t\t\tif (segment == FXP_NTXSEG)\n\t\t\t\t\tbreak;\n\t\t\t\ttxp->tbd[segment].tb_addr =\n\t\t\t\t    vtophys(mtod(m, vm_offset_t));\n\t\t\t\ttxp->tbd[segment].tb_size = m->m_len;\n\t\t\t\tsegment++;\n\t\t\t}\n\t\t}\n\t\tif (m != NULL) {\n\t\t\tstruct mbuf *mn;\n\n\t\t\t/*\n\t\t\t * We ran out of segments. We have to recopy this mbuf\n\t\t\t * chain first. Bail out if we can't get the new buffers.\n\t\t\t */\n\t\t\tMGETHDR(mn, M_DONTWAIT, MT_DATA);\n\t\t\tif (mn == NULL) {\n\t\t\t\tm_freem(mb_head);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (mb_head->m_pkthdr.len > MHLEN) {\n\t\t\t\tMCLGET(mn, M_DONTWAIT);\n\t\t\t\tif ((mn->m_flags & M_EXT) == 0) {\n\t\t\t\t\tm_freem(mn);\n\t\t\t\t\tm_freem(mb_head);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tm_copydata(mb_head, 0, mb_head->m_pkthdr.len,\n\t\t\t    mtod(mn, caddr_t));\n\t\t\tmn->m_pkthdr.len = mn->m_len = mb_head->m_pkthdr.len;\n\t\t\tm_freem(mb_head);\n\t\t\tmb_head = mn;\n\t\t\tgoto tbdinit;\n\t\t}\n\n\t\ttxp->tbd_number = segment;\n\t\ttxp->mb_head = mb_head;\n\t\ttxp->cb_status = 0;\n\t\tif (sc->tx_queued != FXP_CXINT_THRESH - 1) {\n\t\t\ttxp->cb_command =\n\t\t\t    FXP_CB_COMMAND_XMIT | FXP_CB_COMMAND_SF | FXP_CB_COMMAND_S;\n\t\t} else {\n\t\t\ttxp->cb_command =\n\t\t\t    FXP_CB_COMMAND_XMIT | FXP_CB_COMMAND_SF | FXP_CB_COMMAND_S | FXP_CB_COMMAND_I;\n\t\t\t/*\n\t\t\t * Set a 5 second timer just in case we don't hear from the\n\t\t\t * card again.\n\t\t\t */\n\t\t\tifp->if_timer = 5;\n\t\t}\n\t\ttxp->tx_threshold = tx_threshold;\n\t\n\t\t/*\n\t\t * Advance the end of list forward.\n\t\t */\n\t\tsc->cbl_last->cb_command &= ~FXP_CB_COMMAND_S;\n\t\tsc->cbl_last = txp;\n\n\t\t/*\n\t\t * Advance the beginning of the list forward if there are\n\t\t * no other packets queued (when nothing is queued, cbl_first\n\t\t * sits on the last TxCB that was sent out).\n\t\t */\n\t\tif (sc->tx_queued == 0)\n\t\t\tsc->cbl_first = txp;\n\n\t\tsc->tx_queued++;\n\n#if NBPFILTER > 0\n\t\t/*\n\t\t * Pass packet to bpf if there is a listener.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, mb_head);\n#endif\n\t}\n\n\t/*\n\t * We're finished. If we added to the list, issue a RESUME to get DMA\n\t * going again if suspended.\n\t */\n\tif (txp != NULL) {\n\t\tfxp_scb_wait(sc);\n\t\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_RESUME);\n\t}\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/ic/fxpvar.h>",
      "#include <dev/ic/fxpreg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define FXP_CXINT_THRESH 120",
      "#define FXP_NTXCB\t128"
    ],
    "globals_used": [
      "static inline void fxp_scb_wait",
      "void fxp_start",
      "void fxp_mc_setup",
      "static int tx_threshold = 64;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_WRITE_1",
          "args": [
            "sc",
            "FXP_CSR_SCB_COMMAND",
            "FXP_SCB_COMMAND_CU_RESUME"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fxp_scb_wait",
          "args": [
            "sc"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "fxp_scb_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
          "lines": "237-244",
          "snippet": "static inline void\nfxp_scb_wait(sc)\n\tstruct fxp_softc *sc;\n{\n\tint i = 10000;\n\n\twhile (CSR_READ_1(sc, FXP_CSR_SCB_COMMAND) && --i);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/ic/fxpvar.h>",
            "#include <dev/ic/fxpreg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void fxp_scb_wait"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic inline void fxp_scb_wait;\n\nstatic inline void\nfxp_scb_wait(sc)\n\tstruct fxp_softc *sc;\n{\n\tint i = 10000;\n\n\twhile (CSR_READ_1(sc, FXP_CSR_SCB_COMMAND) && --i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_mtap",
          "args": [
            "ifp->if_bpf",
            "mb_head"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "mb_head"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_copydata",
          "args": [
            "mb_head",
            "0",
            "mb_head->m_pkthdr.len",
            "mtod(mn, caddr_t)"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "mn",
            "caddr_t"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "mb_head"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "mn"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCLGET",
          "args": [
            "mn",
            "M_DONTWAIT"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "mb_head"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGETHDR",
          "args": [
            "mn",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtophys",
          "args": [
            "mtod(m, vm_offset_t)"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "vm_offset_t"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&ifp->if_snd",
            "mb_head"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define FXP_CXINT_THRESH 120\n#define FXP_NTXCB\t128\n\nstatic inline void fxp_scb_wait;\nvoid fxp_start;\nvoid fxp_mc_setup;\nstatic int tx_threshold = 64;\n\nvoid\nfxp_start(ifp)\n\tstruct ifnet *ifp;\n{\n\tstruct fxp_softc *sc = ifp->if_softc;\n\tstruct fxp_cb_tx *txp;\n\n\t/*\n\t * See if we need to suspend xmit until the multicast filter\n\t * has been reprogrammed (which can only be done at the head\n\t * of the command chain).\n\t */\n\tif (sc->need_mcsetup)\n\t\treturn;\n\n\ttxp = NULL;\n\n\t/*\n\t * We're finished if there is nothing more to add to the list or if\n\t * we're all filled up with buffers to transmit.\n\t * NOTE: One TxCB is reserved to guarantee that fxp_mc_setup() can add\n\t *       a NOP command when needed.\n\t */\n\twhile (ifp->if_snd.ifq_head != NULL && sc->tx_queued < FXP_NTXCB - 1) {\n\t\tstruct mbuf *m, *mb_head;\n\t\tint segment;\n\n\t\t/*\n\t\t * Grab a packet to transmit.\n\t\t */\n\t\tIF_DEQUEUE(&ifp->if_snd, mb_head);\n\n\t\t/*\n\t\t * Get pointer to next available tx desc.\n\t\t */\n\t\ttxp = sc->cbl_last->next;\n\n\t\t/*\n\t\t * Go through each of the mbufs in the chain and initialize\n\t\t * the transmit buffer descriptors with the physical address\n\t\t * and size of the mbuf.\n\t\t */\ntbdinit:\n\t\tfor (m = mb_head, segment = 0; m != NULL; m = m->m_next) {\n\t\t\tif (m->m_len != 0) {\n\t\t\t\tif (segment == FXP_NTXSEG)\n\t\t\t\t\tbreak;\n\t\t\t\ttxp->tbd[segment].tb_addr =\n\t\t\t\t    vtophys(mtod(m, vm_offset_t));\n\t\t\t\ttxp->tbd[segment].tb_size = m->m_len;\n\t\t\t\tsegment++;\n\t\t\t}\n\t\t}\n\t\tif (m != NULL) {\n\t\t\tstruct mbuf *mn;\n\n\t\t\t/*\n\t\t\t * We ran out of segments. We have to recopy this mbuf\n\t\t\t * chain first. Bail out if we can't get the new buffers.\n\t\t\t */\n\t\t\tMGETHDR(mn, M_DONTWAIT, MT_DATA);\n\t\t\tif (mn == NULL) {\n\t\t\t\tm_freem(mb_head);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (mb_head->m_pkthdr.len > MHLEN) {\n\t\t\t\tMCLGET(mn, M_DONTWAIT);\n\t\t\t\tif ((mn->m_flags & M_EXT) == 0) {\n\t\t\t\t\tm_freem(mn);\n\t\t\t\t\tm_freem(mb_head);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tm_copydata(mb_head, 0, mb_head->m_pkthdr.len,\n\t\t\t    mtod(mn, caddr_t));\n\t\t\tmn->m_pkthdr.len = mn->m_len = mb_head->m_pkthdr.len;\n\t\t\tm_freem(mb_head);\n\t\t\tmb_head = mn;\n\t\t\tgoto tbdinit;\n\t\t}\n\n\t\ttxp->tbd_number = segment;\n\t\ttxp->mb_head = mb_head;\n\t\ttxp->cb_status = 0;\n\t\tif (sc->tx_queued != FXP_CXINT_THRESH - 1) {\n\t\t\ttxp->cb_command =\n\t\t\t    FXP_CB_COMMAND_XMIT | FXP_CB_COMMAND_SF | FXP_CB_COMMAND_S;\n\t\t} else {\n\t\t\ttxp->cb_command =\n\t\t\t    FXP_CB_COMMAND_XMIT | FXP_CB_COMMAND_SF | FXP_CB_COMMAND_S | FXP_CB_COMMAND_I;\n\t\t\t/*\n\t\t\t * Set a 5 second timer just in case we don't hear from the\n\t\t\t * card again.\n\t\t\t */\n\t\t\tifp->if_timer = 5;\n\t\t}\n\t\ttxp->tx_threshold = tx_threshold;\n\t\n\t\t/*\n\t\t * Advance the end of list forward.\n\t\t */\n\t\tsc->cbl_last->cb_command &= ~FXP_CB_COMMAND_S;\n\t\tsc->cbl_last = txp;\n\n\t\t/*\n\t\t * Advance the beginning of the list forward if there are\n\t\t * no other packets queued (when nothing is queued, cbl_first\n\t\t * sits on the last TxCB that was sent out).\n\t\t */\n\t\tif (sc->tx_queued == 0)\n\t\t\tsc->cbl_first = txp;\n\n\t\tsc->tx_queued++;\n\n#if NBPFILTER > 0\n\t\t/*\n\t\t * Pass packet to bpf if there is a listener.\n\t\t */\n\t\tif (ifp->if_bpf)\n\t\t\tbpf_mtap(ifp->if_bpf, mb_head);\n#endif\n\t}\n\n\t/*\n\t * We're finished. If we added to the list, issue a RESUME to get DMA\n\t * going again if suspended.\n\t */\n\tif (txp != NULL) {\n\t\tfxp_scb_wait(sc);\n\t\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_RESUME);\n\t}\n}"
  },
  {
    "function_name": "fxp_read_eeprom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
    "lines": "572-634",
    "snippet": "void\nfxp_read_eeprom(sc, data, offset, words)\n\tstruct fxp_softc *sc;\n\tu_short *data;\n\tint offset;\n\tint words;\n{\n\tu_int16_t reg;\n\tint i, x;\n\n\tfor (i = 0; i < words; i++) {\n\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, FXP_EEPROM_EECS);\n\t\t/*\n\t\t * Shift in read opcode.\n\t\t */\n\t\tfor (x = 3; x > 0; x--) {\n\t\t\tif (FXP_EEPROM_OPC_READ & (1 << (x - 1))) {\n\t\t\t\treg = FXP_EEPROM_EECS | FXP_EEPROM_EEDI;\n\t\t\t} else {\n\t\t\t\treg = FXP_EEPROM_EECS;\n\t\t\t}\n\t\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);\n\t\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL,\n\t\t\t    reg | FXP_EEPROM_EESK);\n\t\t\tDELAY(1);\n\t\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);\n\t\t\tDELAY(1);\n\t\t}\n\t\t/*\n\t\t * Shift in address.\n\t\t */\n\t\tfor (x = sc->eeprom_size; x > 0; x--) {\n\t\t\tif ((i + offset) & (1 << (x - 1))) {\n\t\t\t\treg = FXP_EEPROM_EECS | FXP_EEPROM_EEDI;\n\t\t\t} else {\n\t\t\t\treg = FXP_EEPROM_EECS;\n\t\t\t}\n\t\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);\n\t\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL,\n\t\t\t    reg | FXP_EEPROM_EESK);\n\t\t\tDELAY(1);\n\t\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);\n\t\t\tDELAY(1);\n\t\t}\n\t\treg = FXP_EEPROM_EECS;\n\t\tdata[i] = 0;\n\t\t/*\n\t\t * Shift out data.\n\t\t */\n\t\tfor (x = 16; x > 0; x--) {\n\t\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL,\n\t\t\t    reg | FXP_EEPROM_EESK);\n\t\t\tDELAY(1);\n\t\t\tif (CSR_READ_2(sc, FXP_CSR_EEPROMCONTROL) &\n\t\t\t    FXP_EEPROM_EEDO)\n\t\t\t\tdata[i] |= (1 << (x - 1));\n\t\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);\n\t\t\tDELAY(1);\n\t\t}\n\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, 0);\n\t\tDELAY(1);\n\t}\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/ic/fxpvar.h>",
      "#include <dev/ic/fxpreg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void fxp_read_eeprom"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "FXP_CSR_EEPROMCONTROL",
            "0"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "FXP_CSR_EEPROMCONTROL",
            "reg"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "FXP_CSR_EEPROMCONTROL"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "FXP_CSR_EEPROMCONTROL",
            "reg | FXP_EEPROM_EESK"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "FXP_CSR_EEPROMCONTROL",
            "reg"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "FXP_CSR_EEPROMCONTROL",
            "reg | FXP_EEPROM_EESK"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "FXP_CSR_EEPROMCONTROL",
            "reg"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "FXP_CSR_EEPROMCONTROL",
            "reg"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "FXP_CSR_EEPROMCONTROL",
            "reg | FXP_EEPROM_EESK"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "FXP_CSR_EEPROMCONTROL",
            "reg"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "FXP_CSR_EEPROMCONTROL",
            "FXP_EEPROM_EECS"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid fxp_read_eeprom;\n\nvoid\nfxp_read_eeprom(sc, data, offset, words)\n\tstruct fxp_softc *sc;\n\tu_short *data;\n\tint offset;\n\tint words;\n{\n\tu_int16_t reg;\n\tint i, x;\n\n\tfor (i = 0; i < words; i++) {\n\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, FXP_EEPROM_EECS);\n\t\t/*\n\t\t * Shift in read opcode.\n\t\t */\n\t\tfor (x = 3; x > 0; x--) {\n\t\t\tif (FXP_EEPROM_OPC_READ & (1 << (x - 1))) {\n\t\t\t\treg = FXP_EEPROM_EECS | FXP_EEPROM_EEDI;\n\t\t\t} else {\n\t\t\t\treg = FXP_EEPROM_EECS;\n\t\t\t}\n\t\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);\n\t\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL,\n\t\t\t    reg | FXP_EEPROM_EESK);\n\t\t\tDELAY(1);\n\t\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);\n\t\t\tDELAY(1);\n\t\t}\n\t\t/*\n\t\t * Shift in address.\n\t\t */\n\t\tfor (x = sc->eeprom_size; x > 0; x--) {\n\t\t\tif ((i + offset) & (1 << (x - 1))) {\n\t\t\t\treg = FXP_EEPROM_EECS | FXP_EEPROM_EEDI;\n\t\t\t} else {\n\t\t\t\treg = FXP_EEPROM_EECS;\n\t\t\t}\n\t\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);\n\t\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL,\n\t\t\t    reg | FXP_EEPROM_EESK);\n\t\t\tDELAY(1);\n\t\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);\n\t\t\tDELAY(1);\n\t\t}\n\t\treg = FXP_EEPROM_EECS;\n\t\tdata[i] = 0;\n\t\t/*\n\t\t * Shift out data.\n\t\t */\n\t\tfor (x = 16; x > 0; x--) {\n\t\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL,\n\t\t\t    reg | FXP_EEPROM_EESK);\n\t\t\tDELAY(1);\n\t\t\tif (CSR_READ_2(sc, FXP_CSR_EEPROMCONTROL) &\n\t\t\t    FXP_EEPROM_EEDO)\n\t\t\t\tdata[i] |= (1 << (x - 1));\n\t\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);\n\t\t\tDELAY(1);\n\t\t}\n\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, 0);\n\t\tDELAY(1);\n\t}\n}"
  },
  {
    "function_name": "fxp_autosize_eeprom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
    "lines": "523-564",
    "snippet": "void\nfxp_autosize_eeprom(sc)\n\tstruct fxp_softc *sc;\n{\n\tu_int16_t reg;\n\tint x;\n\n\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, FXP_EEPROM_EECS);\n\t/*\n\t * Shift in read opcode.\n\t */\n\tfor (x = 3; x > 0; x--) {\n\t\tif (FXP_EEPROM_OPC_READ & (1 << (x - 1))) {\n\t\t\treg = FXP_EEPROM_EECS | FXP_EEPROM_EEDI;\n\t\t} else {\n\t\t\treg = FXP_EEPROM_EECS;\n\t\t}\n\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);\n\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL,\n\t\t    reg | FXP_EEPROM_EESK);\n\t\tDELAY(1);\n\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);\n\t\tDELAY(1);\n\t}\n\t/*\n\t * Shift in address.\n\t * Wait for the dummy zero following a correct address shift.\n\t */\n\tfor (x = 1; x <= 8; x++) {\n\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, FXP_EEPROM_EECS);\n\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL,\n\t\t\tFXP_EEPROM_EECS | FXP_EEPROM_EESK);\n\t\tDELAY(1);\n\t\tif ((CSR_READ_2(sc, FXP_CSR_EEPROMCONTROL) & FXP_EEPROM_EEDO) == 0)\n\t\t\tbreak;\n\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, FXP_EEPROM_EECS);\n\t\tDELAY(1);\n\t}\n\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, 0);\n\tDELAY(1);\n\tsc->eeprom_size = x;\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/ic/fxpvar.h>",
      "#include <dev/ic/fxpreg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void fxp_autosize_eeprom"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "FXP_CSR_EEPROMCONTROL",
            "0"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "FXP_CSR_EEPROMCONTROL",
            "FXP_EEPROM_EECS"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_READ_2",
          "args": [
            "sc",
            "FXP_CSR_EEPROMCONTROL"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "FXP_CSR_EEPROMCONTROL",
            "FXP_EEPROM_EECS | FXP_EEPROM_EESK"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "FXP_CSR_EEPROMCONTROL",
            "FXP_EEPROM_EECS"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "FXP_CSR_EEPROMCONTROL",
            "reg"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "FXP_CSR_EEPROMCONTROL",
            "reg | FXP_EEPROM_EESK"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "FXP_CSR_EEPROMCONTROL",
            "reg"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_2",
          "args": [
            "sc",
            "FXP_CSR_EEPROMCONTROL",
            "FXP_EEPROM_EECS"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid fxp_autosize_eeprom;\n\nvoid\nfxp_autosize_eeprom(sc)\n\tstruct fxp_softc *sc;\n{\n\tu_int16_t reg;\n\tint x;\n\n\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, FXP_EEPROM_EECS);\n\t/*\n\t * Shift in read opcode.\n\t */\n\tfor (x = 3; x > 0; x--) {\n\t\tif (FXP_EEPROM_OPC_READ & (1 << (x - 1))) {\n\t\t\treg = FXP_EEPROM_EECS | FXP_EEPROM_EEDI;\n\t\t} else {\n\t\t\treg = FXP_EEPROM_EECS;\n\t\t}\n\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);\n\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL,\n\t\t    reg | FXP_EEPROM_EESK);\n\t\tDELAY(1);\n\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);\n\t\tDELAY(1);\n\t}\n\t/*\n\t * Shift in address.\n\t * Wait for the dummy zero following a correct address shift.\n\t */\n\tfor (x = 1; x <= 8; x++) {\n\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, FXP_EEPROM_EECS);\n\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL,\n\t\t\tFXP_EEPROM_EECS | FXP_EEPROM_EESK);\n\t\tDELAY(1);\n\t\tif ((CSR_READ_2(sc, FXP_CSR_EEPROMCONTROL) & FXP_EEPROM_EEDO) == 0)\n\t\t\tbreak;\n\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, FXP_EEPROM_EECS);\n\t\tDELAY(1);\n\t}\n\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, 0);\n\tDELAY(1);\n\tsc->eeprom_size = x;\n}"
  },
  {
    "function_name": "fxp_attach_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
    "lines": "357-493",
    "snippet": "int\nfxp_attach_common(sc, enaddr, intrstr)\n\tstruct fxp_softc *sc;\n\tu_int8_t *enaddr;\n\tconst char *intrstr;\n{\n\tstruct ifnet *ifp;\n\tu_int16_t data;\n\tint i;\n\n\t/*\n\t * Reset to a stable state.\n\t */\n\tCSR_WRITE_4(sc, FXP_CSR_PORT, FXP_PORT_SELECTIVE_RESET);\n\tDELAY(10);\n\n\tsc->cbl_base = malloc(sizeof(struct fxp_cb_tx) * FXP_NTXCB,\n\t    M_DEVBUF, M_NOWAIT);\n\tif (sc->cbl_base == NULL)\n\t\tgoto fail;\n\n\tsc->fxp_stats = malloc(sizeof(struct fxp_stats), M_DEVBUF, M_NOWAIT);\n\tif (sc->fxp_stats == NULL)\n\t\tgoto fail;\n\tbzero(sc->fxp_stats, sizeof(struct fxp_stats));\n\n\tsc->mcsp = malloc(sizeof(struct fxp_cb_mcs), M_DEVBUF, M_NOWAIT);\n\tif (sc->mcsp == NULL)\n\t\tgoto fail;\n\n\t/*\n\t * Pre-allocate our receive buffers.\n\t */\n\tfor (i = 0; i < FXP_NRFABUFS; i++) {\n\t\tif (fxp_add_rfabuf(sc, NULL) != 0) {\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t/*\n\t * Find out how large of an SEEPROM we have.\n\t */\n\tfxp_autosize_eeprom(sc);\n\n\t/*\n\t * Get info about the primary PHY\n\t */\n\tfxp_read_eeprom(sc, (u_int16_t *)&data, 6, 1);\n\tsc->phy_primary_addr = data & 0xff;\n\tsc->phy_primary_device = (data >> 8) & 0x3f;\n\tsc->phy_10Mbps_only = data >> 15;\n\n\t/*\n\t * Read MAC address.\n\t */\n\tfxp_read_eeprom(sc, (u_int16_t *)enaddr, 0, 3);\n\n\tifp = &sc->arpcom.ac_if;\n\tbcopy(enaddr, sc->arpcom.ac_enaddr, ETHER_ADDR_LEN);\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;\n\tifp->if_ioctl = fxp_ioctl;\n\tifp->if_start = fxp_start;\n\tifp->if_watchdog = fxp_watchdog;\n\n\tprintf(\": %s, address %s\\n\", intrstr,\n\t    ether_sprintf(sc->arpcom.ac_enaddr));\n\n\t/*\n\t * Initialize our media structures and probe the MII.\n\t */\n\tsc->sc_mii.mii_ifp = ifp;\n\tsc->sc_mii.mii_readreg = fxp_mdi_read;\n\tsc->sc_mii.mii_writereg = fxp_mdi_write;\n\tsc->sc_mii.mii_statchg = fxp_statchg;\n\tifmedia_init(&sc->sc_mii.mii_media, 0, fxp_mediachange,\n\t    fxp_mediastatus);\n\tmii_phy_probe(&sc->sc_dev, &sc->sc_mii, 0xffffffff);\n\t/* If no phy found, just use auto mode */\n\tif (LIST_FIRST(&sc->sc_mii.mii_phys) == NULL) {\n\t\tifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER|IFM_MANUAL,\n\t\t    0, NULL);\n\t\tprintf(\"%s: no phy found, using manual mode\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t}\n\n\tif (ifmedia_match(&sc->sc_mii.mii_media, IFM_ETHER|IFM_MANUAL, 0))\n\t\tifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_MANUAL);\n\telse if (ifmedia_match(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO, 0))\n\t\tifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO);\n\telse\n\t\tifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_10_T);\n\n\t/*\n\t * Attach the interface.\n\t */\n\tif_attach(ifp);\n\t/*\n\t * Let the system queue as many packets as we have available\n\t * TX descriptors.\n\t */\n\tifp->if_snd.ifq_maxlen = FXP_NTXCB - 1;\n\tether_ifattach(ifp);\n#if NBPFILTER > 0\n\tbpfattach(&sc->arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,\n\t    sizeof(struct ether_header));\n#endif\n\n\t/*\n\t * Add shutdown hook so that DMA is disabled prior to reboot. Not\n\t * doing do could allow DMA to corrupt kernel memory during the\n\t * reboot before the driver initializes.\n\t */\n\tshutdownhook_establish(fxp_shutdown, sc);\n\n\t/*\n\t * Add suspend hook, for similiar reasons..\n\t */\n\tpowerhook_establish(fxp_power, sc);\n\n\treturn (0);\n\n fail:\n\tprintf(\"%s: Failed to malloc memory\\n\", sc->sc_dev.dv_xname);\n\tif (sc->cbl_base)\n\t\tfree(sc->cbl_base, M_DEVBUF);\n\tif (sc->fxp_stats)\n\t\tfree(sc->fxp_stats, M_DEVBUF);\n\tif (sc->mcsp)\n\t\tfree(sc->mcsp, M_DEVBUF);\n\t/* frees entire chain */\n\tif (sc->rfa_headm)\n\t\tm_freem(sc->rfa_headm);\n\n\treturn (ENOMEM);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/ic/fxpvar.h>",
      "#include <dev/ic/fxpreg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [
      "#define FXP_NRFABUFS\t64",
      "#define FXP_NTXCB\t128"
    ],
    "globals_used": [
      "int fxp_mediachange",
      "void fxp_mediastatus",
      "void fxp_start",
      "int fxp_ioctl",
      "void fxp_watchdog",
      "int fxp_add_rfabuf",
      "int fxp_mdi_read",
      "void fxp_mdi_write",
      "void fxp_autosize_eeprom",
      "void fxp_statchg",
      "void fxp_read_eeprom",
      "void\tfxp_shutdown",
      "void\tfxp_power"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "sc->rfa_headm"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "sc->mcsp",
            "M_DEVBUF"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "wdc_free_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/wdc.c",
          "lines": "1617-1633",
          "snippet": "void\nwdc_free_xfer(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct wdc_softc *wdc = chp->wdc;\n\tint s;\n\n\tif (wdc->cap & WDC_CAPABILITY_HWLOCK)\n\t\t(*wdc->free_hw)(chp);\n\ts = splbio();\n\tchp->ch_flags &= ~WDCF_ACTIVE;\n\tTAILQ_REMOVE(&chp->ch_queue->sc_xfer, xfer, c_xferchain);\n\txfer->c_flags &= ~C_INUSE;\n\tLIST_INSERT_HEAD(&xfer_free_list, xfer, free_list);\n\tsplx(s);\n}",
          "includes": [
            "#include \"atapiscsi.h\"",
            "#include <dev/ic/wdcvar.h>",
            "#include <dev/ic/wdcreg.h>",
            "#include <dev/ata/atareg.h>",
            "#include <dev/ata/atavar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <vm/vm.h>",
            "#include <sys/proc.h>",
            "#include <sys/syslog.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atapiscsi.h\"\n#include <dev/ic/wdcvar.h>\n#include <dev/ic/wdcreg.h>\n#include <dev/ata/atareg.h>\n#include <dev/ata/atavar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <vm/vm.h>\n#include <sys/proc.h>\n#include <sys/syslog.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nwdc_free_xfer(chp, xfer)\n\tstruct channel_softc *chp;\n\tstruct wdc_xfer *xfer;\n{\n\tstruct wdc_softc *wdc = chp->wdc;\n\tint s;\n\n\tif (wdc->cap & WDC_CAPABILITY_HWLOCK)\n\t\t(*wdc->free_hw)(chp);\n\ts = splbio();\n\tchp->ch_flags &= ~WDCF_ACTIVE;\n\tTAILQ_REMOVE(&chp->ch_queue->sc_xfer, xfer, c_xferchain);\n\txfer->c_flags &= ~C_INUSE;\n\tLIST_INSERT_HEAD(&xfer_free_list, xfer, free_list);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: Failed to malloc memory\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "powerhook_establish",
          "args": [
            "fxp_power",
            "sc"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shutdownhook_establish",
          "args": [
            "fxp_shutdown",
            "sc"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpfattach",
          "args": [
            "&sc->arpcom.ac_if.if_bpf",
            "ifp",
            "DLT_EN10MB",
            "sizeof(struct ether_header)"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_ifattach",
          "args": [
            "ifp"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_attach",
          "args": [
            "ifp"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_set",
          "args": [
            "&sc->sc_mii.mii_media",
            "IFM_ETHER|IFM_10_T"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_set",
          "args": [
            "&sc->sc_mii.mii_media",
            "IFM_ETHER|IFM_AUTO"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_match",
          "args": [
            "&sc->sc_mii.mii_media",
            "IFM_ETHER|IFM_AUTO",
            "0"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_set",
          "args": [
            "&sc->sc_mii.mii_media",
            "IFM_ETHER|IFM_MANUAL"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_match",
          "args": [
            "&sc->sc_mii.mii_media",
            "IFM_ETHER|IFM_MANUAL",
            "0"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->sc_mii.mii_media",
            "IFM_ETHER|IFM_MANUAL",
            "0",
            "NULL"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_FIRST",
          "args": [
            "&sc->sc_mii.mii_phys"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mii_phy_probe",
          "args": [
            "&sc->sc_dev",
            "&sc->sc_mii",
            "0xffffffff"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "mii_phy_probe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/mii.c",
          "lines": "68-122",
          "snippet": "void\nmii_phy_probe(parent, mii, capmask)\n\tstruct device *parent;\n\tstruct mii_data *mii;\n\tint capmask;\n{\n\tstruct mii_attach_args ma;\n\tstruct mii_softc *child;\n\n\tLIST_INIT(&mii->mii_phys);\n\n\tfor (ma.mii_phyno = 0; ma.mii_phyno < MII_NPHY; ma.mii_phyno++) {\n\t\t/*\n\t\t * Check to see if there is a PHY at this address.  If\n\t\t * the register contains garbage, assume no.\n\t\t */\n\t\tma.mii_id1 = (*mii->mii_readreg)(parent, ma.mii_phyno,\n\t\t    MII_PHYIDR1);\n\t\tma.mii_id2 = (*mii->mii_readreg)(parent, ma.mii_phyno,\n\t\t    MII_PHYIDR2);\n\t\tif ((ma.mii_id1 == 0 || ma.mii_id1 == 0xffff) &&\n\t\t    (ma.mii_id2 == 0 || ma.mii_id2 == 0xffff)) {\n\t\t\t/*\n\t\t\t * ARGH!!  3Com internal PHYs report 0/0 in their\n\t\t\t * ID registers!  If we spot this, check to see\n\t\t\t * if the BMSR has reasonable data in it.\n\t\t\t * And if that wasn't enough there are PHYs\n\t\t\t * reporting 0xffff/0xffff too.\n\t\t\t */\n\t\t\tif ((MII_OUI(ma.mii_id1, ma.mii_id2) == 0 &&\n\t\t\t    MII_MODEL(ma.mii_id2) == 0) ||\n\t\t\t    (MII_OUI(ma.mii_id1, ma.mii_id2) == 0x3fffff &&\n\t\t\t    MII_MODEL(ma.mii_id2) == 0x3f)) {\n\t\t\t\tint bmsr = (*mii->mii_readreg)(parent,\n\t\t\t\t    ma.mii_phyno, MII_BMSR);\n\t\t\t\tif (bmsr == 0 || bmsr == 0xffff ||\n\t\t\t\t    (bmsr & BMSR_MEDIAMASK) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tma.mii_data = mii;\n\t\tma.mii_capmask = capmask;\n\n\t\tif ((child = (struct mii_softc *)config_found_sm(parent, &ma,\n\t\t    mii_print, mii_submatch)) != NULL) {\n\t\t\t/*\n\t\t\t * Link it up in the parent's MII data.\n\t\t\t */\n\t\t\tLIST_INSERT_HEAD(&mii->mii_phys, child, mii_list);\n\t\t\tmii->mii_instance++;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int\tmii_print",
            "int\tmii_submatch"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nint\tmii_print;\nint\tmii_submatch;\n\nvoid\nmii_phy_probe(parent, mii, capmask)\n\tstruct device *parent;\n\tstruct mii_data *mii;\n\tint capmask;\n{\n\tstruct mii_attach_args ma;\n\tstruct mii_softc *child;\n\n\tLIST_INIT(&mii->mii_phys);\n\n\tfor (ma.mii_phyno = 0; ma.mii_phyno < MII_NPHY; ma.mii_phyno++) {\n\t\t/*\n\t\t * Check to see if there is a PHY at this address.  If\n\t\t * the register contains garbage, assume no.\n\t\t */\n\t\tma.mii_id1 = (*mii->mii_readreg)(parent, ma.mii_phyno,\n\t\t    MII_PHYIDR1);\n\t\tma.mii_id2 = (*mii->mii_readreg)(parent, ma.mii_phyno,\n\t\t    MII_PHYIDR2);\n\t\tif ((ma.mii_id1 == 0 || ma.mii_id1 == 0xffff) &&\n\t\t    (ma.mii_id2 == 0 || ma.mii_id2 == 0xffff)) {\n\t\t\t/*\n\t\t\t * ARGH!!  3Com internal PHYs report 0/0 in their\n\t\t\t * ID registers!  If we spot this, check to see\n\t\t\t * if the BMSR has reasonable data in it.\n\t\t\t * And if that wasn't enough there are PHYs\n\t\t\t * reporting 0xffff/0xffff too.\n\t\t\t */\n\t\t\tif ((MII_OUI(ma.mii_id1, ma.mii_id2) == 0 &&\n\t\t\t    MII_MODEL(ma.mii_id2) == 0) ||\n\t\t\t    (MII_OUI(ma.mii_id1, ma.mii_id2) == 0x3fffff &&\n\t\t\t    MII_MODEL(ma.mii_id2) == 0x3f)) {\n\t\t\t\tint bmsr = (*mii->mii_readreg)(parent,\n\t\t\t\t    ma.mii_phyno, MII_BMSR);\n\t\t\t\tif (bmsr == 0 || bmsr == 0xffff ||\n\t\t\t\t    (bmsr & BMSR_MEDIAMASK) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tma.mii_data = mii;\n\t\tma.mii_capmask = capmask;\n\n\t\tif ((child = (struct mii_softc *)config_found_sm(parent, &ma,\n\t\t    mii_print, mii_submatch)) != NULL) {\n\t\t\t/*\n\t\t\t * Link it up in the parent's MII data.\n\t\t\t */\n\t\t\tLIST_INSERT_HEAD(&mii->mii_phys, child, mii_list);\n\t\t\tmii->mii_instance++;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ifmedia_init",
          "args": [
            "&sc->sc_mii.mii_media",
            "0",
            "fxp_mediachange",
            "fxp_mediastatus"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_sprintf",
          "args": [
            "sc->arpcom.ac_enaddr"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "sc->sc_dev.dv_xname",
            "ifp->if_xname",
            "IFNAMSIZ"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fxp_read_eeprom",
          "args": [
            "sc",
            "(u_int16_t *)enaddr",
            "0",
            "3"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "fxp_read_eeprom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
          "lines": "572-634",
          "snippet": "void\nfxp_read_eeprom(sc, data, offset, words)\n\tstruct fxp_softc *sc;\n\tu_short *data;\n\tint offset;\n\tint words;\n{\n\tu_int16_t reg;\n\tint i, x;\n\n\tfor (i = 0; i < words; i++) {\n\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, FXP_EEPROM_EECS);\n\t\t/*\n\t\t * Shift in read opcode.\n\t\t */\n\t\tfor (x = 3; x > 0; x--) {\n\t\t\tif (FXP_EEPROM_OPC_READ & (1 << (x - 1))) {\n\t\t\t\treg = FXP_EEPROM_EECS | FXP_EEPROM_EEDI;\n\t\t\t} else {\n\t\t\t\treg = FXP_EEPROM_EECS;\n\t\t\t}\n\t\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);\n\t\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL,\n\t\t\t    reg | FXP_EEPROM_EESK);\n\t\t\tDELAY(1);\n\t\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);\n\t\t\tDELAY(1);\n\t\t}\n\t\t/*\n\t\t * Shift in address.\n\t\t */\n\t\tfor (x = sc->eeprom_size; x > 0; x--) {\n\t\t\tif ((i + offset) & (1 << (x - 1))) {\n\t\t\t\treg = FXP_EEPROM_EECS | FXP_EEPROM_EEDI;\n\t\t\t} else {\n\t\t\t\treg = FXP_EEPROM_EECS;\n\t\t\t}\n\t\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);\n\t\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL,\n\t\t\t    reg | FXP_EEPROM_EESK);\n\t\t\tDELAY(1);\n\t\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);\n\t\t\tDELAY(1);\n\t\t}\n\t\treg = FXP_EEPROM_EECS;\n\t\tdata[i] = 0;\n\t\t/*\n\t\t * Shift out data.\n\t\t */\n\t\tfor (x = 16; x > 0; x--) {\n\t\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL,\n\t\t\t    reg | FXP_EEPROM_EESK);\n\t\t\tDELAY(1);\n\t\t\tif (CSR_READ_2(sc, FXP_CSR_EEPROMCONTROL) &\n\t\t\t    FXP_EEPROM_EEDO)\n\t\t\t\tdata[i] |= (1 << (x - 1));\n\t\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);\n\t\t\tDELAY(1);\n\t\t}\n\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, 0);\n\t\tDELAY(1);\n\t}\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/ic/fxpvar.h>",
            "#include <dev/ic/fxpreg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void fxp_read_eeprom"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid fxp_read_eeprom;\n\nvoid\nfxp_read_eeprom(sc, data, offset, words)\n\tstruct fxp_softc *sc;\n\tu_short *data;\n\tint offset;\n\tint words;\n{\n\tu_int16_t reg;\n\tint i, x;\n\n\tfor (i = 0; i < words; i++) {\n\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, FXP_EEPROM_EECS);\n\t\t/*\n\t\t * Shift in read opcode.\n\t\t */\n\t\tfor (x = 3; x > 0; x--) {\n\t\t\tif (FXP_EEPROM_OPC_READ & (1 << (x - 1))) {\n\t\t\t\treg = FXP_EEPROM_EECS | FXP_EEPROM_EEDI;\n\t\t\t} else {\n\t\t\t\treg = FXP_EEPROM_EECS;\n\t\t\t}\n\t\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);\n\t\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL,\n\t\t\t    reg | FXP_EEPROM_EESK);\n\t\t\tDELAY(1);\n\t\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);\n\t\t\tDELAY(1);\n\t\t}\n\t\t/*\n\t\t * Shift in address.\n\t\t */\n\t\tfor (x = sc->eeprom_size; x > 0; x--) {\n\t\t\tif ((i + offset) & (1 << (x - 1))) {\n\t\t\t\treg = FXP_EEPROM_EECS | FXP_EEPROM_EEDI;\n\t\t\t} else {\n\t\t\t\treg = FXP_EEPROM_EECS;\n\t\t\t}\n\t\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);\n\t\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL,\n\t\t\t    reg | FXP_EEPROM_EESK);\n\t\t\tDELAY(1);\n\t\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);\n\t\t\tDELAY(1);\n\t\t}\n\t\treg = FXP_EEPROM_EECS;\n\t\tdata[i] = 0;\n\t\t/*\n\t\t * Shift out data.\n\t\t */\n\t\tfor (x = 16; x > 0; x--) {\n\t\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL,\n\t\t\t    reg | FXP_EEPROM_EESK);\n\t\t\tDELAY(1);\n\t\t\tif (CSR_READ_2(sc, FXP_CSR_EEPROMCONTROL) &\n\t\t\t    FXP_EEPROM_EEDO)\n\t\t\t\tdata[i] |= (1 << (x - 1));\n\t\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);\n\t\t\tDELAY(1);\n\t\t}\n\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, 0);\n\t\tDELAY(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fxp_autosize_eeprom",
          "args": [
            "sc"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "fxp_autosize_eeprom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
          "lines": "523-564",
          "snippet": "void\nfxp_autosize_eeprom(sc)\n\tstruct fxp_softc *sc;\n{\n\tu_int16_t reg;\n\tint x;\n\n\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, FXP_EEPROM_EECS);\n\t/*\n\t * Shift in read opcode.\n\t */\n\tfor (x = 3; x > 0; x--) {\n\t\tif (FXP_EEPROM_OPC_READ & (1 << (x - 1))) {\n\t\t\treg = FXP_EEPROM_EECS | FXP_EEPROM_EEDI;\n\t\t} else {\n\t\t\treg = FXP_EEPROM_EECS;\n\t\t}\n\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);\n\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL,\n\t\t    reg | FXP_EEPROM_EESK);\n\t\tDELAY(1);\n\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);\n\t\tDELAY(1);\n\t}\n\t/*\n\t * Shift in address.\n\t * Wait for the dummy zero following a correct address shift.\n\t */\n\tfor (x = 1; x <= 8; x++) {\n\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, FXP_EEPROM_EECS);\n\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL,\n\t\t\tFXP_EEPROM_EECS | FXP_EEPROM_EESK);\n\t\tDELAY(1);\n\t\tif ((CSR_READ_2(sc, FXP_CSR_EEPROMCONTROL) & FXP_EEPROM_EEDO) == 0)\n\t\t\tbreak;\n\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, FXP_EEPROM_EECS);\n\t\tDELAY(1);\n\t}\n\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, 0);\n\tDELAY(1);\n\tsc->eeprom_size = x;\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/ic/fxpvar.h>",
            "#include <dev/ic/fxpreg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void fxp_autosize_eeprom"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid fxp_autosize_eeprom;\n\nvoid\nfxp_autosize_eeprom(sc)\n\tstruct fxp_softc *sc;\n{\n\tu_int16_t reg;\n\tint x;\n\n\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, FXP_EEPROM_EECS);\n\t/*\n\t * Shift in read opcode.\n\t */\n\tfor (x = 3; x > 0; x--) {\n\t\tif (FXP_EEPROM_OPC_READ & (1 << (x - 1))) {\n\t\t\treg = FXP_EEPROM_EECS | FXP_EEPROM_EEDI;\n\t\t} else {\n\t\t\treg = FXP_EEPROM_EECS;\n\t\t}\n\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);\n\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL,\n\t\t    reg | FXP_EEPROM_EESK);\n\t\tDELAY(1);\n\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);\n\t\tDELAY(1);\n\t}\n\t/*\n\t * Shift in address.\n\t * Wait for the dummy zero following a correct address shift.\n\t */\n\tfor (x = 1; x <= 8; x++) {\n\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, FXP_EEPROM_EECS);\n\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL,\n\t\t\tFXP_EEPROM_EECS | FXP_EEPROM_EESK);\n\t\tDELAY(1);\n\t\tif ((CSR_READ_2(sc, FXP_CSR_EEPROMCONTROL) & FXP_EEPROM_EEDO) == 0)\n\t\t\tbreak;\n\t\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, FXP_EEPROM_EECS);\n\t\tDELAY(1);\n\t}\n\tCSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, 0);\n\tDELAY(1);\n\tsc->eeprom_size = x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fxp_add_rfabuf",
          "args": [
            "sc",
            "NULL"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "fxp_add_rfabuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
          "lines": "1272-1347",
          "snippet": "int\nfxp_add_rfabuf(sc, oldm)\n\tstruct fxp_softc *sc;\n\tstruct mbuf *oldm;\n{\n\tu_int32_t v;\n\tstruct mbuf *m;\n\tu_int8_t *rfap;\n\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\tif (m != NULL) {\n\t\tMCLGET(m, M_DONTWAIT);\n\t\tif ((m->m_flags & M_EXT) == 0) {\n\t\t\tm_freem(m);\n\t\t\tif (oldm == NULL)\n\t\t\t\treturn 1;\n\t\t\tm = oldm;\n\t\t\tm->m_data = m->m_ext.ext_buf;\n\t\t}\n\t} else {\n\t\tif (oldm == NULL)\n\t\t\treturn 1;\n\t\tm = oldm;\n\t\tm->m_data = m->m_ext.ext_buf;\n\t}\n\n\t/*\n\t * Move the data pointer up so that the incoming data packet\n\t * will be 32-bit aligned.\n\t */\n\tm->m_data += RFA_ALIGNMENT_FUDGE;\n\n\t/*\n\t * Get a pointer to the base of the mbuf cluster and move\n\t * data start past it.\n\t */\n\trfap = m->m_data;\n\tm->m_data += sizeof(struct fxp_rfa);\n\t*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, size)) =\n\t    MCLBYTES - sizeof(struct fxp_rfa) - RFA_ALIGNMENT_FUDGE;\n\n\t/*\n\t * Initialize the rest of the RFA.  Note that since the RFA\n\t * is misaligned, we cannot store values directly.  Instead,\n\t * we use an optimized, inline copy.\n\t */\n\t*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, rfa_status)) = 0;\n\t*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, rfa_control)) =\n\t    FXP_RFA_CONTROL_EL;\n\t*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, actual_size)) = 0;\n\n\tv = -1;\n\tfxp_lwcopy(&v,\n\t    (u_int32_t *)(rfap + offsetof(struct fxp_rfa, link_addr)));\n\tfxp_lwcopy(&v,\n\t    (u_int32_t *)(rfap + offsetof(struct fxp_rfa, rbd_addr)));\n\n\t/*\n\t * If there are other buffers already on the list, attach this\n\t * one to the end by fixing up the tail to point to this one.\n\t */\n\tif (sc->rfa_headm != NULL) {\n\t\tsc->rfa_tailm->m_next = m;\n\t\tv = vtophys(rfap);\n\t\trfap = sc->rfa_tailm->m_ext.ext_buf + RFA_ALIGNMENT_FUDGE;\n\t\tfxp_lwcopy(&v,\n\t\t    (u_int32_t *)(rfap + offsetof(struct fxp_rfa, link_addr)));\n\t\t*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, rfa_control)) &=\n\t\t    ~FXP_RFA_CONTROL_EL;\n\t} else {\n\t\tsc->rfa_headm = m;\n\t}\n\tsc->rfa_tailm = m;\n\n\treturn (m == oldm);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/ic/fxpvar.h>",
            "#include <dev/ic/fxpreg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tRFA_ALIGNMENT_FUDGE\t2"
          ],
          "globals_used": [
            "static __inline void fxp_lwcopy",
            "int fxp_add_rfabuf"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define\tRFA_ALIGNMENT_FUDGE\t2\n\nstatic __inline void fxp_lwcopy;\nint fxp_add_rfabuf;\n\nint\nfxp_add_rfabuf(sc, oldm)\n\tstruct fxp_softc *sc;\n\tstruct mbuf *oldm;\n{\n\tu_int32_t v;\n\tstruct mbuf *m;\n\tu_int8_t *rfap;\n\n\tMGETHDR(m, M_DONTWAIT, MT_DATA);\n\tif (m != NULL) {\n\t\tMCLGET(m, M_DONTWAIT);\n\t\tif ((m->m_flags & M_EXT) == 0) {\n\t\t\tm_freem(m);\n\t\t\tif (oldm == NULL)\n\t\t\t\treturn 1;\n\t\t\tm = oldm;\n\t\t\tm->m_data = m->m_ext.ext_buf;\n\t\t}\n\t} else {\n\t\tif (oldm == NULL)\n\t\t\treturn 1;\n\t\tm = oldm;\n\t\tm->m_data = m->m_ext.ext_buf;\n\t}\n\n\t/*\n\t * Move the data pointer up so that the incoming data packet\n\t * will be 32-bit aligned.\n\t */\n\tm->m_data += RFA_ALIGNMENT_FUDGE;\n\n\t/*\n\t * Get a pointer to the base of the mbuf cluster and move\n\t * data start past it.\n\t */\n\trfap = m->m_data;\n\tm->m_data += sizeof(struct fxp_rfa);\n\t*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, size)) =\n\t    MCLBYTES - sizeof(struct fxp_rfa) - RFA_ALIGNMENT_FUDGE;\n\n\t/*\n\t * Initialize the rest of the RFA.  Note that since the RFA\n\t * is misaligned, we cannot store values directly.  Instead,\n\t * we use an optimized, inline copy.\n\t */\n\t*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, rfa_status)) = 0;\n\t*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, rfa_control)) =\n\t    FXP_RFA_CONTROL_EL;\n\t*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, actual_size)) = 0;\n\n\tv = -1;\n\tfxp_lwcopy(&v,\n\t    (u_int32_t *)(rfap + offsetof(struct fxp_rfa, link_addr)));\n\tfxp_lwcopy(&v,\n\t    (u_int32_t *)(rfap + offsetof(struct fxp_rfa, rbd_addr)));\n\n\t/*\n\t * If there are other buffers already on the list, attach this\n\t * one to the end by fixing up the tail to point to this one.\n\t */\n\tif (sc->rfa_headm != NULL) {\n\t\tsc->rfa_tailm->m_next = m;\n\t\tv = vtophys(rfap);\n\t\trfap = sc->rfa_tailm->m_ext.ext_buf + RFA_ALIGNMENT_FUDGE;\n\t\tfxp_lwcopy(&v,\n\t\t    (u_int32_t *)(rfap + offsetof(struct fxp_rfa, link_addr)));\n\t\t*(u_int16_t *)(rfap + offsetof(struct fxp_rfa, rfa_control)) &=\n\t\t    ~FXP_RFA_CONTROL_EL;\n\t} else {\n\t\tsc->rfa_headm = m;\n\t}\n\tsc->rfa_tailm = m;\n\n\treturn (m == oldm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct fxp_cb_mcs)",
            "M_DEVBUF",
            "M_NOWAIT"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "sc->fxp_stats",
            "sizeof(struct fxp_stats)"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSR_WRITE_4",
          "args": [
            "sc",
            "FXP_CSR_PORT",
            "FXP_PORT_SELECTIVE_RESET"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define FXP_NRFABUFS\t64\n#define FXP_NTXCB\t128\n\nint fxp_mediachange;\nvoid fxp_mediastatus;\nvoid fxp_start;\nint fxp_ioctl;\nvoid fxp_watchdog;\nint fxp_add_rfabuf;\nint fxp_mdi_read;\nvoid fxp_mdi_write;\nvoid fxp_autosize_eeprom;\nvoid fxp_statchg;\nvoid fxp_read_eeprom;\nvoid\tfxp_shutdown;\nvoid\tfxp_power;\n\nint\nfxp_attach_common(sc, enaddr, intrstr)\n\tstruct fxp_softc *sc;\n\tu_int8_t *enaddr;\n\tconst char *intrstr;\n{\n\tstruct ifnet *ifp;\n\tu_int16_t data;\n\tint i;\n\n\t/*\n\t * Reset to a stable state.\n\t */\n\tCSR_WRITE_4(sc, FXP_CSR_PORT, FXP_PORT_SELECTIVE_RESET);\n\tDELAY(10);\n\n\tsc->cbl_base = malloc(sizeof(struct fxp_cb_tx) * FXP_NTXCB,\n\t    M_DEVBUF, M_NOWAIT);\n\tif (sc->cbl_base == NULL)\n\t\tgoto fail;\n\n\tsc->fxp_stats = malloc(sizeof(struct fxp_stats), M_DEVBUF, M_NOWAIT);\n\tif (sc->fxp_stats == NULL)\n\t\tgoto fail;\n\tbzero(sc->fxp_stats, sizeof(struct fxp_stats));\n\n\tsc->mcsp = malloc(sizeof(struct fxp_cb_mcs), M_DEVBUF, M_NOWAIT);\n\tif (sc->mcsp == NULL)\n\t\tgoto fail;\n\n\t/*\n\t * Pre-allocate our receive buffers.\n\t */\n\tfor (i = 0; i < FXP_NRFABUFS; i++) {\n\t\tif (fxp_add_rfabuf(sc, NULL) != 0) {\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t/*\n\t * Find out how large of an SEEPROM we have.\n\t */\n\tfxp_autosize_eeprom(sc);\n\n\t/*\n\t * Get info about the primary PHY\n\t */\n\tfxp_read_eeprom(sc, (u_int16_t *)&data, 6, 1);\n\tsc->phy_primary_addr = data & 0xff;\n\tsc->phy_primary_device = (data >> 8) & 0x3f;\n\tsc->phy_10Mbps_only = data >> 15;\n\n\t/*\n\t * Read MAC address.\n\t */\n\tfxp_read_eeprom(sc, (u_int16_t *)enaddr, 0, 3);\n\n\tifp = &sc->arpcom.ac_if;\n\tbcopy(enaddr, sc->arpcom.ac_enaddr, ETHER_ADDR_LEN);\n\tbcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);\n\tifp->if_softc = sc;\n\tifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;\n\tifp->if_ioctl = fxp_ioctl;\n\tifp->if_start = fxp_start;\n\tifp->if_watchdog = fxp_watchdog;\n\n\tprintf(\": %s, address %s\\n\", intrstr,\n\t    ether_sprintf(sc->arpcom.ac_enaddr));\n\n\t/*\n\t * Initialize our media structures and probe the MII.\n\t */\n\tsc->sc_mii.mii_ifp = ifp;\n\tsc->sc_mii.mii_readreg = fxp_mdi_read;\n\tsc->sc_mii.mii_writereg = fxp_mdi_write;\n\tsc->sc_mii.mii_statchg = fxp_statchg;\n\tifmedia_init(&sc->sc_mii.mii_media, 0, fxp_mediachange,\n\t    fxp_mediastatus);\n\tmii_phy_probe(&sc->sc_dev, &sc->sc_mii, 0xffffffff);\n\t/* If no phy found, just use auto mode */\n\tif (LIST_FIRST(&sc->sc_mii.mii_phys) == NULL) {\n\t\tifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER|IFM_MANUAL,\n\t\t    0, NULL);\n\t\tprintf(\"%s: no phy found, using manual mode\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t}\n\n\tif (ifmedia_match(&sc->sc_mii.mii_media, IFM_ETHER|IFM_MANUAL, 0))\n\t\tifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_MANUAL);\n\telse if (ifmedia_match(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO, 0))\n\t\tifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO);\n\telse\n\t\tifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_10_T);\n\n\t/*\n\t * Attach the interface.\n\t */\n\tif_attach(ifp);\n\t/*\n\t * Let the system queue as many packets as we have available\n\t * TX descriptors.\n\t */\n\tifp->if_snd.ifq_maxlen = FXP_NTXCB - 1;\n\tether_ifattach(ifp);\n#if NBPFILTER > 0\n\tbpfattach(&sc->arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,\n\t    sizeof(struct ether_header));\n#endif\n\n\t/*\n\t * Add shutdown hook so that DMA is disabled prior to reboot. Not\n\t * doing do could allow DMA to corrupt kernel memory during the\n\t * reboot before the driver initializes.\n\t */\n\tshutdownhook_establish(fxp_shutdown, sc);\n\n\t/*\n\t * Add suspend hook, for similiar reasons..\n\t */\n\tpowerhook_establish(fxp_power, sc);\n\n\treturn (0);\n\n fail:\n\tprintf(\"%s: Failed to malloc memory\\n\", sc->sc_dev.dv_xname);\n\tif (sc->cbl_base)\n\t\tfree(sc->cbl_base, M_DEVBUF);\n\tif (sc->fxp_stats)\n\t\tfree(sc->fxp_stats, M_DEVBUF);\n\tif (sc->mcsp)\n\t\tfree(sc->mcsp, M_DEVBUF);\n\t/* frees entire chain */\n\tif (sc->rfa_headm)\n\t\tm_freem(sc->rfa_headm);\n\n\treturn (ENOMEM);\n}"
  },
  {
    "function_name": "fxp_ether_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
    "lines": "301-348",
    "snippet": "int\nfxp_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tstruct fxp_softc *sc = ifp->if_softc;\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tfxp_init(sc);\n\t\t\tarp_ifinit(&sc->arpcom, ifa);\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t    {\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t /* Set new address. */\n\t\t\t fxp_init(sc);\n\t\t\t break;\n\t\t    }\n#endif\n\t\tdefault:\n\t\t\tfxp_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/ic/fxpvar.h>",
      "#include <dev/ic/fxpreg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void fxp_init",
      "int\tfxp_ether_ioctl"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fxp_init",
          "args": [
            "sc"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "fxp_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
          "lines": "1075-1234",
          "snippet": "void\nfxp_init(xsc)\n\tvoid *xsc;\n{\n\tstruct fxp_softc *sc = xsc;\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tstruct fxp_cb_config *cbp;\n\tstruct fxp_cb_ias *cb_ias;\n\tstruct fxp_cb_tx *txp;\n\tint i, s, prm;\n\n\ts = splimp();\n\t/*\n\t * Cancel any pending I/O\n\t */\n\tfxp_stop(sc, 0);\n\n\tprm = (ifp->if_flags & IFF_PROMISC) ? 1 : 0;\n\n\t/*\n\t * Initialize base of CBL and RFA memory. Loading with zero\n\t * sets it up for regular linear addressing.\n\t */\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, 0);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_BASE);\n\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_RU_BASE);\n\n\t/*\n\t * Initialize base of dump-stats buffer.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, vtophys(sc->fxp_stats));\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_DUMP_ADR);\n\n\t/*\n\t * We temporarily use memory that contains the TxCB list to\n\t * construct the config CB. The TxCB list memory is rebuilt\n\t * later.\n\t */\n\tcbp = (struct fxp_cb_config *) sc->cbl_base;\n\n\t/*\n\t * This bcopy is kind of disgusting, but there are a bunch of must be\n\t * zero and must be one bits in this structure and this is the easiest\n\t * way to initialize them all to proper values.\n\t */\n\tbcopy(fxp_cb_config_template, (void *)&cbp->cb_status,\n\t\tsizeof(fxp_cb_config_template));\n\n\tcbp->cb_status =\t0;\n\tcbp->cb_command =\tFXP_CB_COMMAND_CONFIG | FXP_CB_COMMAND_EL;\n\tcbp->link_addr =\t-1;\t/* (no) next command */\n\tcbp->byte_count =\t22;\t/* (22) bytes to config */\n\tcbp->rx_fifo_limit =\t8;\t/* rx fifo threshold (32 bytes) */\n\tcbp->tx_fifo_limit =\t0;\t/* tx fifo threshold (0 bytes) */\n\tcbp->adaptive_ifs =\t0;\t/* (no) adaptive interframe spacing */\n\tcbp->rx_dma_bytecount =\t0;\t/* (no) rx DMA max */\n\tcbp->tx_dma_bytecount =\t0;\t/* (no) tx DMA max */\n\tcbp->dma_bce =\t\t0;\t/* (disable) dma max counters */\n\tcbp->late_scb =\t\t0;\t/* (don't) defer SCB update */\n\tcbp->tno_int =\t\t0;\t/* (disable) tx not okay interrupt */\n\tcbp->ci_int =\t\t1;\t/* interrupt on CU idle */\n\tcbp->save_bf =\t\tprm;\t/* save bad frames */\n\tcbp->disc_short_rx =\t!prm;\t/* discard short packets */\n\tcbp->underrun_retry =\t1;\t/* retry mode (1) on DMA underrun */\n\tcbp->mediatype =\t!sc->phy_10Mbps_only; /* interface mode */\n\tcbp->nsai =\t\t1;\t/* (don't) disable source addr insert */\n\tcbp->preamble_length =\t2;\t/* (7 byte) preamble */\n\tcbp->loopback =\t\t0;\t/* (don't) loopback */\n\tcbp->linear_priority =\t0;\t/* (normal CSMA/CD operation) */\n\tcbp->linear_pri_mode =\t0;\t/* (wait after xmit only) */\n\tcbp->interfrm_spacing =\t6;\t/* (96 bits of) interframe spacing */\n\tcbp->promiscuous =\tprm;\t/* promiscuous mode */\n\tcbp->bcast_disable =\t0;\t/* (don't) disable broadcasts */\n\tcbp->crscdt =\t\t0;\t/* (CRS only) */\n\tcbp->stripping =\t!prm;\t/* truncate rx packet to byte count */\n\tcbp->padding =\t\t1;\t/* (do) pad short tx packets */\n\tcbp->rcv_crc_xfer =\t0;\t/* (don't) xfer CRC to host */\n\tcbp->long_rx =\t\tsc->not_82557; /* (enable) long packets */\n\tcbp->force_fdx =\t0;\t/* (don't) force full duplex */\n\tcbp->fdx_pin_en =\t1;\t/* (enable) FDX# pin */\n\tcbp->multi_ia =\t\t0;\t/* (don't) accept multiple IAs */\n\tcbp->mc_all =\t\tsc->all_mcasts;/* accept all multicasts */\n\n\t/*\n\t * Start the config command/DMA.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, vtophys(&cbp->cb_status));\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\t/* ...and wait for it to complete. */\n\twhile (!(cbp->cb_status & FXP_CB_STATUS_C));\n\n\t/*\n\t * Now initialize the station address. Temporarily use the TxCB\n\t * memory area like we did above for the config CB.\n\t */\n\tcb_ias = (struct fxp_cb_ias *) sc->cbl_base;\n\tcb_ias->cb_status = 0;\n\tcb_ias->cb_command = FXP_CB_COMMAND_IAS | FXP_CB_COMMAND_EL;\n\tcb_ias->link_addr = -1;\n\tbcopy(sc->arpcom.ac_enaddr, (void *)cb_ias->macaddr,\n\t    sizeof(sc->arpcom.ac_enaddr));\n\n\t/*\n\t * Start the IAS (Individual Address Setup) command/DMA.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\t/* ...and wait for it to complete. */\n\twhile (!(cb_ias->cb_status & FXP_CB_STATUS_C));\n\n\t/*\n\t * Initialize transmit control block (TxCB) list.\n\t */\n\n\ttxp = sc->cbl_base;\n\tbzero(txp, sizeof(struct fxp_cb_tx) * FXP_NTXCB);\n\tfor (i = 0; i < FXP_NTXCB; i++) {\n\t\ttxp[i].cb_status = FXP_CB_STATUS_C | FXP_CB_STATUS_OK;\n\t\ttxp[i].cb_command = FXP_CB_COMMAND_NOP;\n\t\ttxp[i].link_addr = vtophys(&txp[(i + 1) & FXP_TXCB_MASK].cb_status);\n\t\ttxp[i].tbd_array_addr = vtophys(&txp[i].tbd[0]);\n\t\ttxp[i].next = &txp[(i + 1) & FXP_TXCB_MASK];\n\t}\n\t/*\n\t * Set the suspend flag on the first TxCB and start the control\n\t * unit. It will execute the NOP and then suspend.\n\t */\n\ttxp->cb_command = FXP_CB_COMMAND_NOP | FXP_CB_COMMAND_S;\n\tsc->cbl_first = sc->cbl_last = txp;\n\tsc->tx_queued = 1;\n\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\n\t/*\n\t * Initialize receiver buffer area - RFA.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL,\n\t    vtophys(sc->rfa_headm->m_ext.ext_buf) + RFA_ALIGNMENT_FUDGE);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_RU_START);\n\n\t/*\n\t * Set current media.\n\t */\n\tmii_mediachg(&sc->sc_mii);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tsplx(s);\n\n\t/*\n\t * Start stats updater.\n\t */\n\ttimeout(fxp_stats_update, sc, hz);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/ic/fxpvar.h>",
            "#include <dev/ic/fxpreg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define FXP_TXCB_MASK\t(FXP_NTXCB - 1)",
            "#define FXP_NTXCB\t128",
            "#define\tRFA_ALIGNMENT_FUDGE\t2"
          ],
          "globals_used": [
            "static u_char fxp_cb_config_template[] = {\n\t0x0, 0x0,\t\t/* cb_status */\n\t0x80, 0x2,\t\t/* cb_command */\n\t0xff, 0xff, 0xff, 0xff,\t/* link_addr */\n\t0x16,\t/*  0 */\n\t0x8,\t/*  1 */\n\t0x0,\t/*  2 */\n\t0x0,\t/*  3 */\n\t0x0,\t/*  4 */\n\t0x80,\t/*  5 */\n\t0xb2,\t/*  6 */\n\t0x3,\t/*  7 */\n\t0x1,\t/*  8 */\n\t0x0,\t/*  9 */\n\t0x26,\t/* 10 */\n\t0x0,\t/* 11 */\n\t0x60,\t/* 12 */\n\t0x0,\t/* 13 */\n\t0xf2,\t/* 14 */\n\t0x48,\t/* 15 */\n\t0x0,\t/* 16 */\n\t0x40,\t/* 17 */\n\t0xf3,\t/* 18 */\n\t0x0,\t/* 19 */\n\t0x3f,\t/* 20 */\n\t0x5\t/* 21 */\n};",
            "static inline void fxp_scb_wait",
            "void fxp_init",
            "void fxp_stop",
            "void fxp_stats_update"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define FXP_TXCB_MASK\t(FXP_NTXCB - 1)\n#define FXP_NTXCB\t128\n#define\tRFA_ALIGNMENT_FUDGE\t2\n\nstatic u_char fxp_cb_config_template[] = {\n\t0x0, 0x0,\t\t/* cb_status */\n\t0x80, 0x2,\t\t/* cb_command */\n\t0xff, 0xff, 0xff, 0xff,\t/* link_addr */\n\t0x16,\t/*  0 */\n\t0x8,\t/*  1 */\n\t0x0,\t/*  2 */\n\t0x0,\t/*  3 */\n\t0x0,\t/*  4 */\n\t0x80,\t/*  5 */\n\t0xb2,\t/*  6 */\n\t0x3,\t/*  7 */\n\t0x1,\t/*  8 */\n\t0x0,\t/*  9 */\n\t0x26,\t/* 10 */\n\t0x0,\t/* 11 */\n\t0x60,\t/* 12 */\n\t0x0,\t/* 13 */\n\t0xf2,\t/* 14 */\n\t0x48,\t/* 15 */\n\t0x0,\t/* 16 */\n\t0x40,\t/* 17 */\n\t0xf3,\t/* 18 */\n\t0x0,\t/* 19 */\n\t0x3f,\t/* 20 */\n\t0x5\t/* 21 */\n};\nstatic inline void fxp_scb_wait;\nvoid fxp_init;\nvoid fxp_stop;\nvoid fxp_stats_update;\n\nvoid\nfxp_init(xsc)\n\tvoid *xsc;\n{\n\tstruct fxp_softc *sc = xsc;\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tstruct fxp_cb_config *cbp;\n\tstruct fxp_cb_ias *cb_ias;\n\tstruct fxp_cb_tx *txp;\n\tint i, s, prm;\n\n\ts = splimp();\n\t/*\n\t * Cancel any pending I/O\n\t */\n\tfxp_stop(sc, 0);\n\n\tprm = (ifp->if_flags & IFF_PROMISC) ? 1 : 0;\n\n\t/*\n\t * Initialize base of CBL and RFA memory. Loading with zero\n\t * sets it up for regular linear addressing.\n\t */\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, 0);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_BASE);\n\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_RU_BASE);\n\n\t/*\n\t * Initialize base of dump-stats buffer.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, vtophys(sc->fxp_stats));\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_DUMP_ADR);\n\n\t/*\n\t * We temporarily use memory that contains the TxCB list to\n\t * construct the config CB. The TxCB list memory is rebuilt\n\t * later.\n\t */\n\tcbp = (struct fxp_cb_config *) sc->cbl_base;\n\n\t/*\n\t * This bcopy is kind of disgusting, but there are a bunch of must be\n\t * zero and must be one bits in this structure and this is the easiest\n\t * way to initialize them all to proper values.\n\t */\n\tbcopy(fxp_cb_config_template, (void *)&cbp->cb_status,\n\t\tsizeof(fxp_cb_config_template));\n\n\tcbp->cb_status =\t0;\n\tcbp->cb_command =\tFXP_CB_COMMAND_CONFIG | FXP_CB_COMMAND_EL;\n\tcbp->link_addr =\t-1;\t/* (no) next command */\n\tcbp->byte_count =\t22;\t/* (22) bytes to config */\n\tcbp->rx_fifo_limit =\t8;\t/* rx fifo threshold (32 bytes) */\n\tcbp->tx_fifo_limit =\t0;\t/* tx fifo threshold (0 bytes) */\n\tcbp->adaptive_ifs =\t0;\t/* (no) adaptive interframe spacing */\n\tcbp->rx_dma_bytecount =\t0;\t/* (no) rx DMA max */\n\tcbp->tx_dma_bytecount =\t0;\t/* (no) tx DMA max */\n\tcbp->dma_bce =\t\t0;\t/* (disable) dma max counters */\n\tcbp->late_scb =\t\t0;\t/* (don't) defer SCB update */\n\tcbp->tno_int =\t\t0;\t/* (disable) tx not okay interrupt */\n\tcbp->ci_int =\t\t1;\t/* interrupt on CU idle */\n\tcbp->save_bf =\t\tprm;\t/* save bad frames */\n\tcbp->disc_short_rx =\t!prm;\t/* discard short packets */\n\tcbp->underrun_retry =\t1;\t/* retry mode (1) on DMA underrun */\n\tcbp->mediatype =\t!sc->phy_10Mbps_only; /* interface mode */\n\tcbp->nsai =\t\t1;\t/* (don't) disable source addr insert */\n\tcbp->preamble_length =\t2;\t/* (7 byte) preamble */\n\tcbp->loopback =\t\t0;\t/* (don't) loopback */\n\tcbp->linear_priority =\t0;\t/* (normal CSMA/CD operation) */\n\tcbp->linear_pri_mode =\t0;\t/* (wait after xmit only) */\n\tcbp->interfrm_spacing =\t6;\t/* (96 bits of) interframe spacing */\n\tcbp->promiscuous =\tprm;\t/* promiscuous mode */\n\tcbp->bcast_disable =\t0;\t/* (don't) disable broadcasts */\n\tcbp->crscdt =\t\t0;\t/* (CRS only) */\n\tcbp->stripping =\t!prm;\t/* truncate rx packet to byte count */\n\tcbp->padding =\t\t1;\t/* (do) pad short tx packets */\n\tcbp->rcv_crc_xfer =\t0;\t/* (don't) xfer CRC to host */\n\tcbp->long_rx =\t\tsc->not_82557; /* (enable) long packets */\n\tcbp->force_fdx =\t0;\t/* (don't) force full duplex */\n\tcbp->fdx_pin_en =\t1;\t/* (enable) FDX# pin */\n\tcbp->multi_ia =\t\t0;\t/* (don't) accept multiple IAs */\n\tcbp->mc_all =\t\tsc->all_mcasts;/* accept all multicasts */\n\n\t/*\n\t * Start the config command/DMA.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, vtophys(&cbp->cb_status));\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\t/* ...and wait for it to complete. */\n\twhile (!(cbp->cb_status & FXP_CB_STATUS_C));\n\n\t/*\n\t * Now initialize the station address. Temporarily use the TxCB\n\t * memory area like we did above for the config CB.\n\t */\n\tcb_ias = (struct fxp_cb_ias *) sc->cbl_base;\n\tcb_ias->cb_status = 0;\n\tcb_ias->cb_command = FXP_CB_COMMAND_IAS | FXP_CB_COMMAND_EL;\n\tcb_ias->link_addr = -1;\n\tbcopy(sc->arpcom.ac_enaddr, (void *)cb_ias->macaddr,\n\t    sizeof(sc->arpcom.ac_enaddr));\n\n\t/*\n\t * Start the IAS (Individual Address Setup) command/DMA.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\t/* ...and wait for it to complete. */\n\twhile (!(cb_ias->cb_status & FXP_CB_STATUS_C));\n\n\t/*\n\t * Initialize transmit control block (TxCB) list.\n\t */\n\n\ttxp = sc->cbl_base;\n\tbzero(txp, sizeof(struct fxp_cb_tx) * FXP_NTXCB);\n\tfor (i = 0; i < FXP_NTXCB; i++) {\n\t\ttxp[i].cb_status = FXP_CB_STATUS_C | FXP_CB_STATUS_OK;\n\t\ttxp[i].cb_command = FXP_CB_COMMAND_NOP;\n\t\ttxp[i].link_addr = vtophys(&txp[(i + 1) & FXP_TXCB_MASK].cb_status);\n\t\ttxp[i].tbd_array_addr = vtophys(&txp[i].tbd[0]);\n\t\ttxp[i].next = &txp[(i + 1) & FXP_TXCB_MASK];\n\t}\n\t/*\n\t * Set the suspend flag on the first TxCB and start the control\n\t * unit. It will execute the NOP and then suspend.\n\t */\n\ttxp->cb_command = FXP_CB_COMMAND_NOP | FXP_CB_COMMAND_S;\n\tsc->cbl_first = sc->cbl_last = txp;\n\tsc->tx_queued = 1;\n\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\n\t/*\n\t * Initialize receiver buffer area - RFA.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL,\n\t    vtophys(sc->rfa_headm->m_ext.ext_buf) + RFA_ALIGNMENT_FUDGE);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_RU_START);\n\n\t/*\n\t * Set current media.\n\t */\n\tmii_mediachg(&sc->sc_mii);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tsplx(s);\n\n\t/*\n\t * Start stats updater.\n\t */\n\ttimeout(fxp_stats_update, sc, hz);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "ina->x_host.c_host",
            "LLADDR(ifp->if_sadl)",
            "ifp->if_addrlen"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "LLADDR",
          "args": [
            "ifp->if_sadl"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LLADDR",
          "args": [
            "ifp->if_sadl"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_nullhost",
          "args": [
            "*ina"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IA_SNS",
          "args": [
            "ifa"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arp_ifinit",
          "args": [
            "&sc->arpcom",
            "ifa"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "arp_ifinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_devar.h",
          "lines": "929-936",
          "snippet": "static void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}",
          "includes": [
            "#include <sys/devconf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/devconf.h>\n\nstatic void\narp_ifinit(\n    struct arpcom *ac,\n    struct ifaddr *ifa)\n{\n    ac->ac_ipaddr = IA_SIN(ifa)->sin_addr;\n    arpwhohas(ac, &ac->ac_ipaddr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid fxp_init;\nint\tfxp_ether_ioctl;\n\nint\nfxp_ether_ioctl(ifp, cmd, data)\n\tstruct ifnet *ifp;\n\tu_long cmd;\n\tcaddr_t data;\n{\n\tstruct ifaddr *ifa = (struct ifaddr *) data;\n\tstruct fxp_softc *sc = ifp->if_softc;\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tifp->if_flags |= IFF_UP;\n\n\t\tswitch (ifa->ifa_addr->sa_family) {\n#ifdef INET\n\t\tcase AF_INET:\n\t\t\tfxp_init(sc);\n\t\t\tarp_ifinit(&sc->arpcom, ifa);\n\t\t\tbreak;\n#endif\n#ifdef NS\n\t\tcase AF_NS:\n\t\t    {\n\t\t\t register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;\n\n\t\t\t if (ns_nullhost(*ina))\n\t\t\t\tina->x_host = *(union ns_host *)\n\t\t\t\t    LLADDR(ifp->if_sadl);\n\t\t\t else\n\t\t\t\tbcopy(ina->x_host.c_host, LLADDR(ifp->if_sadl),\n\t\t\t\t    ifp->if_addrlen);\n\t\t\t /* Set new address. */\n\t\t\t fxp_init(sc);\n\t\t\t break;\n\t\t    }\n#endif\n\t\tdefault:\n\t\t\tfxp_init(sc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn (EINVAL);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "fxp_power",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
    "lines": "281-299",
    "snippet": "void\nfxp_power(why, arg)\n\tint why;\n\tvoid *arg;\n{\n\tstruct fxp_softc *sc = arg;\n\tstruct ifnet *ifp;\n\tint s;\n\n\ts = splnet();\n\tif (why != PWR_RESUME)\n\t\tfxp_stop(sc, 0);\n\telse {\n\t\tifp = &sc->arpcom.ac_if;\n\t\tif (ifp->if_flags & IFF_UP)\n\t\t\tfxp_init(sc);\n\t}\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/ic/fxpvar.h>",
      "#include <dev/ic/fxpreg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void fxp_init",
      "void fxp_stop",
      "void\tfxp_power"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fxp_init",
          "args": [
            "sc"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "fxp_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
          "lines": "1075-1234",
          "snippet": "void\nfxp_init(xsc)\n\tvoid *xsc;\n{\n\tstruct fxp_softc *sc = xsc;\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tstruct fxp_cb_config *cbp;\n\tstruct fxp_cb_ias *cb_ias;\n\tstruct fxp_cb_tx *txp;\n\tint i, s, prm;\n\n\ts = splimp();\n\t/*\n\t * Cancel any pending I/O\n\t */\n\tfxp_stop(sc, 0);\n\n\tprm = (ifp->if_flags & IFF_PROMISC) ? 1 : 0;\n\n\t/*\n\t * Initialize base of CBL and RFA memory. Loading with zero\n\t * sets it up for regular linear addressing.\n\t */\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, 0);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_BASE);\n\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_RU_BASE);\n\n\t/*\n\t * Initialize base of dump-stats buffer.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, vtophys(sc->fxp_stats));\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_DUMP_ADR);\n\n\t/*\n\t * We temporarily use memory that contains the TxCB list to\n\t * construct the config CB. The TxCB list memory is rebuilt\n\t * later.\n\t */\n\tcbp = (struct fxp_cb_config *) sc->cbl_base;\n\n\t/*\n\t * This bcopy is kind of disgusting, but there are a bunch of must be\n\t * zero and must be one bits in this structure and this is the easiest\n\t * way to initialize them all to proper values.\n\t */\n\tbcopy(fxp_cb_config_template, (void *)&cbp->cb_status,\n\t\tsizeof(fxp_cb_config_template));\n\n\tcbp->cb_status =\t0;\n\tcbp->cb_command =\tFXP_CB_COMMAND_CONFIG | FXP_CB_COMMAND_EL;\n\tcbp->link_addr =\t-1;\t/* (no) next command */\n\tcbp->byte_count =\t22;\t/* (22) bytes to config */\n\tcbp->rx_fifo_limit =\t8;\t/* rx fifo threshold (32 bytes) */\n\tcbp->tx_fifo_limit =\t0;\t/* tx fifo threshold (0 bytes) */\n\tcbp->adaptive_ifs =\t0;\t/* (no) adaptive interframe spacing */\n\tcbp->rx_dma_bytecount =\t0;\t/* (no) rx DMA max */\n\tcbp->tx_dma_bytecount =\t0;\t/* (no) tx DMA max */\n\tcbp->dma_bce =\t\t0;\t/* (disable) dma max counters */\n\tcbp->late_scb =\t\t0;\t/* (don't) defer SCB update */\n\tcbp->tno_int =\t\t0;\t/* (disable) tx not okay interrupt */\n\tcbp->ci_int =\t\t1;\t/* interrupt on CU idle */\n\tcbp->save_bf =\t\tprm;\t/* save bad frames */\n\tcbp->disc_short_rx =\t!prm;\t/* discard short packets */\n\tcbp->underrun_retry =\t1;\t/* retry mode (1) on DMA underrun */\n\tcbp->mediatype =\t!sc->phy_10Mbps_only; /* interface mode */\n\tcbp->nsai =\t\t1;\t/* (don't) disable source addr insert */\n\tcbp->preamble_length =\t2;\t/* (7 byte) preamble */\n\tcbp->loopback =\t\t0;\t/* (don't) loopback */\n\tcbp->linear_priority =\t0;\t/* (normal CSMA/CD operation) */\n\tcbp->linear_pri_mode =\t0;\t/* (wait after xmit only) */\n\tcbp->interfrm_spacing =\t6;\t/* (96 bits of) interframe spacing */\n\tcbp->promiscuous =\tprm;\t/* promiscuous mode */\n\tcbp->bcast_disable =\t0;\t/* (don't) disable broadcasts */\n\tcbp->crscdt =\t\t0;\t/* (CRS only) */\n\tcbp->stripping =\t!prm;\t/* truncate rx packet to byte count */\n\tcbp->padding =\t\t1;\t/* (do) pad short tx packets */\n\tcbp->rcv_crc_xfer =\t0;\t/* (don't) xfer CRC to host */\n\tcbp->long_rx =\t\tsc->not_82557; /* (enable) long packets */\n\tcbp->force_fdx =\t0;\t/* (don't) force full duplex */\n\tcbp->fdx_pin_en =\t1;\t/* (enable) FDX# pin */\n\tcbp->multi_ia =\t\t0;\t/* (don't) accept multiple IAs */\n\tcbp->mc_all =\t\tsc->all_mcasts;/* accept all multicasts */\n\n\t/*\n\t * Start the config command/DMA.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, vtophys(&cbp->cb_status));\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\t/* ...and wait for it to complete. */\n\twhile (!(cbp->cb_status & FXP_CB_STATUS_C));\n\n\t/*\n\t * Now initialize the station address. Temporarily use the TxCB\n\t * memory area like we did above for the config CB.\n\t */\n\tcb_ias = (struct fxp_cb_ias *) sc->cbl_base;\n\tcb_ias->cb_status = 0;\n\tcb_ias->cb_command = FXP_CB_COMMAND_IAS | FXP_CB_COMMAND_EL;\n\tcb_ias->link_addr = -1;\n\tbcopy(sc->arpcom.ac_enaddr, (void *)cb_ias->macaddr,\n\t    sizeof(sc->arpcom.ac_enaddr));\n\n\t/*\n\t * Start the IAS (Individual Address Setup) command/DMA.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\t/* ...and wait for it to complete. */\n\twhile (!(cb_ias->cb_status & FXP_CB_STATUS_C));\n\n\t/*\n\t * Initialize transmit control block (TxCB) list.\n\t */\n\n\ttxp = sc->cbl_base;\n\tbzero(txp, sizeof(struct fxp_cb_tx) * FXP_NTXCB);\n\tfor (i = 0; i < FXP_NTXCB; i++) {\n\t\ttxp[i].cb_status = FXP_CB_STATUS_C | FXP_CB_STATUS_OK;\n\t\ttxp[i].cb_command = FXP_CB_COMMAND_NOP;\n\t\ttxp[i].link_addr = vtophys(&txp[(i + 1) & FXP_TXCB_MASK].cb_status);\n\t\ttxp[i].tbd_array_addr = vtophys(&txp[i].tbd[0]);\n\t\ttxp[i].next = &txp[(i + 1) & FXP_TXCB_MASK];\n\t}\n\t/*\n\t * Set the suspend flag on the first TxCB and start the control\n\t * unit. It will execute the NOP and then suspend.\n\t */\n\ttxp->cb_command = FXP_CB_COMMAND_NOP | FXP_CB_COMMAND_S;\n\tsc->cbl_first = sc->cbl_last = txp;\n\tsc->tx_queued = 1;\n\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\n\t/*\n\t * Initialize receiver buffer area - RFA.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL,\n\t    vtophys(sc->rfa_headm->m_ext.ext_buf) + RFA_ALIGNMENT_FUDGE);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_RU_START);\n\n\t/*\n\t * Set current media.\n\t */\n\tmii_mediachg(&sc->sc_mii);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tsplx(s);\n\n\t/*\n\t * Start stats updater.\n\t */\n\ttimeout(fxp_stats_update, sc, hz);\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/ic/fxpvar.h>",
            "#include <dev/ic/fxpreg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define FXP_TXCB_MASK\t(FXP_NTXCB - 1)",
            "#define FXP_NTXCB\t128",
            "#define\tRFA_ALIGNMENT_FUDGE\t2"
          ],
          "globals_used": [
            "static u_char fxp_cb_config_template[] = {\n\t0x0, 0x0,\t\t/* cb_status */\n\t0x80, 0x2,\t\t/* cb_command */\n\t0xff, 0xff, 0xff, 0xff,\t/* link_addr */\n\t0x16,\t/*  0 */\n\t0x8,\t/*  1 */\n\t0x0,\t/*  2 */\n\t0x0,\t/*  3 */\n\t0x0,\t/*  4 */\n\t0x80,\t/*  5 */\n\t0xb2,\t/*  6 */\n\t0x3,\t/*  7 */\n\t0x1,\t/*  8 */\n\t0x0,\t/*  9 */\n\t0x26,\t/* 10 */\n\t0x0,\t/* 11 */\n\t0x60,\t/* 12 */\n\t0x0,\t/* 13 */\n\t0xf2,\t/* 14 */\n\t0x48,\t/* 15 */\n\t0x0,\t/* 16 */\n\t0x40,\t/* 17 */\n\t0xf3,\t/* 18 */\n\t0x0,\t/* 19 */\n\t0x3f,\t/* 20 */\n\t0x5\t/* 21 */\n};",
            "static inline void fxp_scb_wait",
            "void fxp_init",
            "void fxp_stop",
            "void fxp_stats_update"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define FXP_TXCB_MASK\t(FXP_NTXCB - 1)\n#define FXP_NTXCB\t128\n#define\tRFA_ALIGNMENT_FUDGE\t2\n\nstatic u_char fxp_cb_config_template[] = {\n\t0x0, 0x0,\t\t/* cb_status */\n\t0x80, 0x2,\t\t/* cb_command */\n\t0xff, 0xff, 0xff, 0xff,\t/* link_addr */\n\t0x16,\t/*  0 */\n\t0x8,\t/*  1 */\n\t0x0,\t/*  2 */\n\t0x0,\t/*  3 */\n\t0x0,\t/*  4 */\n\t0x80,\t/*  5 */\n\t0xb2,\t/*  6 */\n\t0x3,\t/*  7 */\n\t0x1,\t/*  8 */\n\t0x0,\t/*  9 */\n\t0x26,\t/* 10 */\n\t0x0,\t/* 11 */\n\t0x60,\t/* 12 */\n\t0x0,\t/* 13 */\n\t0xf2,\t/* 14 */\n\t0x48,\t/* 15 */\n\t0x0,\t/* 16 */\n\t0x40,\t/* 17 */\n\t0xf3,\t/* 18 */\n\t0x0,\t/* 19 */\n\t0x3f,\t/* 20 */\n\t0x5\t/* 21 */\n};\nstatic inline void fxp_scb_wait;\nvoid fxp_init;\nvoid fxp_stop;\nvoid fxp_stats_update;\n\nvoid\nfxp_init(xsc)\n\tvoid *xsc;\n{\n\tstruct fxp_softc *sc = xsc;\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tstruct fxp_cb_config *cbp;\n\tstruct fxp_cb_ias *cb_ias;\n\tstruct fxp_cb_tx *txp;\n\tint i, s, prm;\n\n\ts = splimp();\n\t/*\n\t * Cancel any pending I/O\n\t */\n\tfxp_stop(sc, 0);\n\n\tprm = (ifp->if_flags & IFF_PROMISC) ? 1 : 0;\n\n\t/*\n\t * Initialize base of CBL and RFA memory. Loading with zero\n\t * sets it up for regular linear addressing.\n\t */\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, 0);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_BASE);\n\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_RU_BASE);\n\n\t/*\n\t * Initialize base of dump-stats buffer.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, vtophys(sc->fxp_stats));\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_DUMP_ADR);\n\n\t/*\n\t * We temporarily use memory that contains the TxCB list to\n\t * construct the config CB. The TxCB list memory is rebuilt\n\t * later.\n\t */\n\tcbp = (struct fxp_cb_config *) sc->cbl_base;\n\n\t/*\n\t * This bcopy is kind of disgusting, but there are a bunch of must be\n\t * zero and must be one bits in this structure and this is the easiest\n\t * way to initialize them all to proper values.\n\t */\n\tbcopy(fxp_cb_config_template, (void *)&cbp->cb_status,\n\t\tsizeof(fxp_cb_config_template));\n\n\tcbp->cb_status =\t0;\n\tcbp->cb_command =\tFXP_CB_COMMAND_CONFIG | FXP_CB_COMMAND_EL;\n\tcbp->link_addr =\t-1;\t/* (no) next command */\n\tcbp->byte_count =\t22;\t/* (22) bytes to config */\n\tcbp->rx_fifo_limit =\t8;\t/* rx fifo threshold (32 bytes) */\n\tcbp->tx_fifo_limit =\t0;\t/* tx fifo threshold (0 bytes) */\n\tcbp->adaptive_ifs =\t0;\t/* (no) adaptive interframe spacing */\n\tcbp->rx_dma_bytecount =\t0;\t/* (no) rx DMA max */\n\tcbp->tx_dma_bytecount =\t0;\t/* (no) tx DMA max */\n\tcbp->dma_bce =\t\t0;\t/* (disable) dma max counters */\n\tcbp->late_scb =\t\t0;\t/* (don't) defer SCB update */\n\tcbp->tno_int =\t\t0;\t/* (disable) tx not okay interrupt */\n\tcbp->ci_int =\t\t1;\t/* interrupt on CU idle */\n\tcbp->save_bf =\t\tprm;\t/* save bad frames */\n\tcbp->disc_short_rx =\t!prm;\t/* discard short packets */\n\tcbp->underrun_retry =\t1;\t/* retry mode (1) on DMA underrun */\n\tcbp->mediatype =\t!sc->phy_10Mbps_only; /* interface mode */\n\tcbp->nsai =\t\t1;\t/* (don't) disable source addr insert */\n\tcbp->preamble_length =\t2;\t/* (7 byte) preamble */\n\tcbp->loopback =\t\t0;\t/* (don't) loopback */\n\tcbp->linear_priority =\t0;\t/* (normal CSMA/CD operation) */\n\tcbp->linear_pri_mode =\t0;\t/* (wait after xmit only) */\n\tcbp->interfrm_spacing =\t6;\t/* (96 bits of) interframe spacing */\n\tcbp->promiscuous =\tprm;\t/* promiscuous mode */\n\tcbp->bcast_disable =\t0;\t/* (don't) disable broadcasts */\n\tcbp->crscdt =\t\t0;\t/* (CRS only) */\n\tcbp->stripping =\t!prm;\t/* truncate rx packet to byte count */\n\tcbp->padding =\t\t1;\t/* (do) pad short tx packets */\n\tcbp->rcv_crc_xfer =\t0;\t/* (don't) xfer CRC to host */\n\tcbp->long_rx =\t\tsc->not_82557; /* (enable) long packets */\n\tcbp->force_fdx =\t0;\t/* (don't) force full duplex */\n\tcbp->fdx_pin_en =\t1;\t/* (enable) FDX# pin */\n\tcbp->multi_ia =\t\t0;\t/* (don't) accept multiple IAs */\n\tcbp->mc_all =\t\tsc->all_mcasts;/* accept all multicasts */\n\n\t/*\n\t * Start the config command/DMA.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, vtophys(&cbp->cb_status));\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\t/* ...and wait for it to complete. */\n\twhile (!(cbp->cb_status & FXP_CB_STATUS_C));\n\n\t/*\n\t * Now initialize the station address. Temporarily use the TxCB\n\t * memory area like we did above for the config CB.\n\t */\n\tcb_ias = (struct fxp_cb_ias *) sc->cbl_base;\n\tcb_ias->cb_status = 0;\n\tcb_ias->cb_command = FXP_CB_COMMAND_IAS | FXP_CB_COMMAND_EL;\n\tcb_ias->link_addr = -1;\n\tbcopy(sc->arpcom.ac_enaddr, (void *)cb_ias->macaddr,\n\t    sizeof(sc->arpcom.ac_enaddr));\n\n\t/*\n\t * Start the IAS (Individual Address Setup) command/DMA.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\t/* ...and wait for it to complete. */\n\twhile (!(cb_ias->cb_status & FXP_CB_STATUS_C));\n\n\t/*\n\t * Initialize transmit control block (TxCB) list.\n\t */\n\n\ttxp = sc->cbl_base;\n\tbzero(txp, sizeof(struct fxp_cb_tx) * FXP_NTXCB);\n\tfor (i = 0; i < FXP_NTXCB; i++) {\n\t\ttxp[i].cb_status = FXP_CB_STATUS_C | FXP_CB_STATUS_OK;\n\t\ttxp[i].cb_command = FXP_CB_COMMAND_NOP;\n\t\ttxp[i].link_addr = vtophys(&txp[(i + 1) & FXP_TXCB_MASK].cb_status);\n\t\ttxp[i].tbd_array_addr = vtophys(&txp[i].tbd[0]);\n\t\ttxp[i].next = &txp[(i + 1) & FXP_TXCB_MASK];\n\t}\n\t/*\n\t * Set the suspend flag on the first TxCB and start the control\n\t * unit. It will execute the NOP and then suspend.\n\t */\n\ttxp->cb_command = FXP_CB_COMMAND_NOP | FXP_CB_COMMAND_S;\n\tsc->cbl_first = sc->cbl_last = txp;\n\tsc->tx_queued = 1;\n\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_CU_START);\n\n\t/*\n\t * Initialize receiver buffer area - RFA.\n\t */\n\tfxp_scb_wait(sc);\n\tCSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL,\n\t    vtophys(sc->rfa_headm->m_ext.ext_buf) + RFA_ALIGNMENT_FUDGE);\n\tCSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_SCB_COMMAND_RU_START);\n\n\t/*\n\t * Set current media.\n\t */\n\tmii_mediachg(&sc->sc_mii);\n\n\tifp->if_flags |= IFF_RUNNING;\n\tifp->if_flags &= ~IFF_OACTIVE;\n\tsplx(s);\n\n\t/*\n\t * Start stats updater.\n\t */\n\ttimeout(fxp_stats_update, sc, hz);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fxp_stop",
          "args": [
            "sc",
            "0"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "fxp_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
          "lines": "998-1055",
          "snippet": "void\nfxp_stop(sc, drain)\n\tstruct fxp_softc *sc;\n\tint drain;\n{\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tstruct fxp_cb_tx *txp;\n\tint i;\n\n\t/*\n\t * Turn down interface (done early to avoid bad interactions\n\t * between panics, shutdown hooks, and the watchdog timer)\n\t */\n\tifp->if_timer = 0;\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\t/*\n\t * Cancel stats updater.\n\t */\n\tuntimeout(fxp_stats_update, sc);\n\n\t/*\n\t * Issue software reset\n\t */\n\tCSR_WRITE_4(sc, FXP_CSR_PORT, FXP_PORT_SELECTIVE_RESET);\n\tDELAY(10);\n\n\t/*\n\t * Release any xmit buffers.\n\t */\n\tfor (txp = sc->cbl_first; txp != NULL && txp->mb_head != NULL;\n\t    txp = txp->next) {\n\t\tm_freem(txp->mb_head);\n\t\ttxp->mb_head = NULL;\n\t}\n\tsc->tx_queued = 0;\n\n\tif (drain) {\n\t\t/*\n\t\t * Free all the receive buffers then reallocate/reinitialize\n\t\t */\n\t\tif (sc->rfa_headm != NULL)\n\t\t\tm_freem(sc->rfa_headm);\n\t\tsc->rfa_headm = NULL;\n\t\tsc->rfa_tailm = NULL;\n\t\tfor (i = 0; i < FXP_NRFABUFS; i++) {\n\t\t\tif (fxp_add_rfabuf(sc, NULL) != 0) {\n\t\t\t\t/*\n\t\t\t\t * This \"can't happen\" - we're at splimp()\n\t\t\t\t * and we just freed all the buffers we need\n\t\t\t\t * above.\n\t\t\t\t */\n\t\t\t\tpanic(\"fxp_stop: no buffers!\");\n\t\t\t}\n\t\t}\n\t}\n\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/ic/fxpvar.h>",
            "#include <dev/ic/fxpreg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define FXP_NRFABUFS\t64"
          ],
          "globals_used": [
            "void fxp_stop",
            "int fxp_add_rfabuf",
            "void fxp_stats_update"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define FXP_NRFABUFS\t64\n\nvoid fxp_stop;\nint fxp_add_rfabuf;\nvoid fxp_stats_update;\n\nvoid\nfxp_stop(sc, drain)\n\tstruct fxp_softc *sc;\n\tint drain;\n{\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tstruct fxp_cb_tx *txp;\n\tint i;\n\n\t/*\n\t * Turn down interface (done early to avoid bad interactions\n\t * between panics, shutdown hooks, and the watchdog timer)\n\t */\n\tifp->if_timer = 0;\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\t/*\n\t * Cancel stats updater.\n\t */\n\tuntimeout(fxp_stats_update, sc);\n\n\t/*\n\t * Issue software reset\n\t */\n\tCSR_WRITE_4(sc, FXP_CSR_PORT, FXP_PORT_SELECTIVE_RESET);\n\tDELAY(10);\n\n\t/*\n\t * Release any xmit buffers.\n\t */\n\tfor (txp = sc->cbl_first; txp != NULL && txp->mb_head != NULL;\n\t    txp = txp->next) {\n\t\tm_freem(txp->mb_head);\n\t\ttxp->mb_head = NULL;\n\t}\n\tsc->tx_queued = 0;\n\n\tif (drain) {\n\t\t/*\n\t\t * Free all the receive buffers then reallocate/reinitialize\n\t\t */\n\t\tif (sc->rfa_headm != NULL)\n\t\t\tm_freem(sc->rfa_headm);\n\t\tsc->rfa_headm = NULL;\n\t\tsc->rfa_tailm = NULL;\n\t\tfor (i = 0; i < FXP_NRFABUFS; i++) {\n\t\t\tif (fxp_add_rfabuf(sc, NULL) != 0) {\n\t\t\t\t/*\n\t\t\t\t * This \"can't happen\" - we're at splimp()\n\t\t\t\t * and we just freed all the buffers we need\n\t\t\t\t * above.\n\t\t\t\t */\n\t\t\t\tpanic(\"fxp_stop: no buffers!\");\n\t\t\t}\n\t\t}\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "splnet",
          "args": [],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid fxp_init;\nvoid fxp_stop;\nvoid\tfxp_power;\n\nvoid\nfxp_power(why, arg)\n\tint why;\n\tvoid *arg;\n{\n\tstruct fxp_softc *sc = arg;\n\tstruct ifnet *ifp;\n\tint s;\n\n\ts = splnet();\n\tif (why != PWR_RESUME)\n\t\tfxp_stop(sc, 0);\n\telse {\n\t\tifp = &sc->arpcom.ac_if;\n\t\tif (ifp->if_flags & IFF_UP)\n\t\t\tfxp_init(sc);\n\t}\n\tsplx(s);\n}"
  },
  {
    "function_name": "fxp_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
    "lines": "268-273",
    "snippet": "void\nfxp_shutdown(sc)\n\tvoid *sc;\n{\n\tfxp_stop((struct fxp_softc *) sc, 0);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/ic/fxpvar.h>",
      "#include <dev/ic/fxpreg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void fxp_stop",
      "void\tfxp_shutdown"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fxp_stop",
          "args": [
            "(struct fxp_softc *) sc",
            "0"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "fxp_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
          "lines": "998-1055",
          "snippet": "void\nfxp_stop(sc, drain)\n\tstruct fxp_softc *sc;\n\tint drain;\n{\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tstruct fxp_cb_tx *txp;\n\tint i;\n\n\t/*\n\t * Turn down interface (done early to avoid bad interactions\n\t * between panics, shutdown hooks, and the watchdog timer)\n\t */\n\tifp->if_timer = 0;\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\t/*\n\t * Cancel stats updater.\n\t */\n\tuntimeout(fxp_stats_update, sc);\n\n\t/*\n\t * Issue software reset\n\t */\n\tCSR_WRITE_4(sc, FXP_CSR_PORT, FXP_PORT_SELECTIVE_RESET);\n\tDELAY(10);\n\n\t/*\n\t * Release any xmit buffers.\n\t */\n\tfor (txp = sc->cbl_first; txp != NULL && txp->mb_head != NULL;\n\t    txp = txp->next) {\n\t\tm_freem(txp->mb_head);\n\t\ttxp->mb_head = NULL;\n\t}\n\tsc->tx_queued = 0;\n\n\tif (drain) {\n\t\t/*\n\t\t * Free all the receive buffers then reallocate/reinitialize\n\t\t */\n\t\tif (sc->rfa_headm != NULL)\n\t\t\tm_freem(sc->rfa_headm);\n\t\tsc->rfa_headm = NULL;\n\t\tsc->rfa_tailm = NULL;\n\t\tfor (i = 0; i < FXP_NRFABUFS; i++) {\n\t\t\tif (fxp_add_rfabuf(sc, NULL) != 0) {\n\t\t\t\t/*\n\t\t\t\t * This \"can't happen\" - we're at splimp()\n\t\t\t\t * and we just freed all the buffers we need\n\t\t\t\t * above.\n\t\t\t\t */\n\t\t\t\tpanic(\"fxp_stop: no buffers!\");\n\t\t\t}\n\t\t}\n\t}\n\n}",
          "includes": [
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/ic/fxpvar.h>",
            "#include <dev/ic/fxpreg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define FXP_NRFABUFS\t64"
          ],
          "globals_used": [
            "void fxp_stop",
            "int fxp_add_rfabuf",
            "void fxp_stats_update"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\n#define FXP_NRFABUFS\t64\n\nvoid fxp_stop;\nint fxp_add_rfabuf;\nvoid fxp_stats_update;\n\nvoid\nfxp_stop(sc, drain)\n\tstruct fxp_softc *sc;\n\tint drain;\n{\n\tstruct ifnet *ifp = &sc->arpcom.ac_if;\n\tstruct fxp_cb_tx *txp;\n\tint i;\n\n\t/*\n\t * Turn down interface (done early to avoid bad interactions\n\t * between panics, shutdown hooks, and the watchdog timer)\n\t */\n\tifp->if_timer = 0;\n\tifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);\n\n\t/*\n\t * Cancel stats updater.\n\t */\n\tuntimeout(fxp_stats_update, sc);\n\n\t/*\n\t * Issue software reset\n\t */\n\tCSR_WRITE_4(sc, FXP_CSR_PORT, FXP_PORT_SELECTIVE_RESET);\n\tDELAY(10);\n\n\t/*\n\t * Release any xmit buffers.\n\t */\n\tfor (txp = sc->cbl_first; txp != NULL && txp->mb_head != NULL;\n\t    txp = txp->next) {\n\t\tm_freem(txp->mb_head);\n\t\ttxp->mb_head = NULL;\n\t}\n\tsc->tx_queued = 0;\n\n\tif (drain) {\n\t\t/*\n\t\t * Free all the receive buffers then reallocate/reinitialize\n\t\t */\n\t\tif (sc->rfa_headm != NULL)\n\t\t\tm_freem(sc->rfa_headm);\n\t\tsc->rfa_headm = NULL;\n\t\tsc->rfa_tailm = NULL;\n\t\tfor (i = 0; i < FXP_NRFABUFS; i++) {\n\t\t\tif (fxp_add_rfabuf(sc, NULL) != 0) {\n\t\t\t\t/*\n\t\t\t\t * This \"can't happen\" - we're at splimp()\n\t\t\t\t * and we just freed all the buffers we need\n\t\t\t\t * above.\n\t\t\t\t */\n\t\t\t\tpanic(\"fxp_stop: no buffers!\");\n\t\t\t}\n\t\t}\n\t}\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid fxp_stop;\nvoid\tfxp_shutdown;\n\nvoid\nfxp_shutdown(sc)\n\tvoid *sc;\n{\n\tfxp_stop((struct fxp_softc *) sc, 0);\n}"
  },
  {
    "function_name": "fxp_scb_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
    "lines": "237-244",
    "snippet": "static inline void\nfxp_scb_wait(sc)\n\tstruct fxp_softc *sc;\n{\n\tint i = 10000;\n\n\twhile (CSR_READ_1(sc, FXP_CSR_SCB_COMMAND) && --i);\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/ic/fxpvar.h>",
      "#include <dev/ic/fxpreg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void fxp_scb_wait"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSR_READ_1",
          "args": [
            "sc",
            "FXP_CSR_SCB_COMMAND"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic inline void fxp_scb_wait;\n\nstatic inline void\nfxp_scb_wait(sc)\n\tstruct fxp_softc *sc;\n{\n\tint i = 10000;\n\n\twhile (CSR_READ_1(sc, FXP_CSR_SCB_COMMAND) && --i);\n}"
  },
  {
    "function_name": "fxp_lwcopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/fxp.c",
    "lines": "122-131",
    "snippet": "static __inline void\nfxp_lwcopy(src, dst)\n\tvolatile u_int32_t *src, *dst;\n{\n\tvolatile u_int16_t *a = (u_int16_t *)src;\n\tvolatile u_int16_t *b = (u_int16_t *)dst;\n\n\tb[0] = a[0];\n\tb[1] = a[1];\n}",
    "includes": [
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/ic/fxpvar.h>",
      "#include <dev/ic/fxpreg.h>",
      "#include <dev/mii/miivar.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <machine/cpu.h>",
      "#include <vm/vm.h>",
      "#include <netinet/if_ether.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netipx/ipx_if.h>",
      "#include <netipx/ipx.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if_dl.h>",
      "#include <net/if.h>",
      "#include <sys/syslog.h>",
      "#include <sys/socket.h>",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include \"bpfilter.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __inline void fxp_lwcopy"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <dev/ic/fxpvar.h>\n#include <dev/ic/fxpreg.h>\n#include <dev/mii/miivar.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nstatic __inline void fxp_lwcopy;\n\nstatic __inline void\nfxp_lwcopy(src, dst)\n\tvolatile u_int32_t *src, *dst;\n{\n\tvolatile u_int16_t *a = (u_int16_t *)src;\n\tvolatile u_int16_t *b = (u_int16_t *)dst;\n\n\tb[0] = a[0];\n\tb[1] = a[1];\n}"
  }
]