[
  {
    "function_name": "ncr5380_show_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
    "lines": "2556-2600",
    "snippet": "void\nncr5380_show_state()\n{\n\tstruct ncr5380_softc *sc;\n\tstruct sci_req *sr;\n\tint i, j, k;\n\n\tsc = ncr5380_debug_sc;\n\n\tif (sc == NULL) {\n\t\tdb_printf(\"ncr5380_debug_sc == NULL\\n\");\n\t\treturn;\n\t}\n\n\tdb_printf(\"sc_ncmds=%d\\n\",  \tsc->sc_ncmds);\n\tk = -1;\t/* which is current? */\n\tfor (i = 0; i < SCI_OPENINGS; i++) {\n\t\tsr = &sc->sc_ring[i];\n\t\tif (sr->sr_xs) {\n\t\t\tif (sr == sc->sc_current)\n\t\t\t\tk = i;\n\t\t\tdb_printf(\"req %d: (sr=%p)\", i, (long)sr);\n\t\t\tncr5380_show_req(sr);\n\t\t}\n\t}\n\tdb_printf(\"sc_rr=%d, current=%d\\n\", sc->sc_rr, k);\n\n\tdb_printf(\"Active request matrix:\\n\");\n\tfor(i = 0; i < 8; i++) {\t\t/* targets */\n\t\tfor (j = 0; j < 8; j++) {\t/* LUN */\n\t\t\tsr = sc->sc_matrix[i][j];\n\t\t\tif (sr) {\n\t\t\t\tdb_printf(\"TID=%d LUN=%d sr=0x%x\\n\", i, j, (long)sr);\n\t\t\t}\n\t\t}\n\t}\n\n\tdb_printf(\"sc_state=0x%x\\n\",\tsc->sc_state);\n\tdb_printf(\"sc_current=%p\\n\",\tsc->sc_current);\n\tdb_printf(\"sc_dataptr=%p\\n\",\tsc->sc_dataptr);\n\tdb_printf(\"sc_datalen=0x%x\\n\",\tsc->sc_datalen);\n\n\tdb_printf(\"sc_prevphase=%d\\n\",\tsc->sc_prevphase);\n\tdb_printf(\"sc_msgpriq=0x%x\\n\",\tsc->sc_msgpriq);\n}",
    "includes": [
      "#include <dev/ic/ncr5380var.h>",
      "#include <dev/ic/ncr5380reg.h>",
      "#include <ddb/db_output.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "db_printf",
          "args": [
            "\"sc_msgpriq=0x%x\\n\"",
            "sc->sc_msgpriq"
          ],
          "line": 2599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_printf",
          "args": [
            "\"sc_prevphase=%d\\n\"",
            "sc->sc_prevphase"
          ],
          "line": 2598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_printf",
          "args": [
            "\"sc_datalen=0x%x\\n\"",
            "sc->sc_datalen"
          ],
          "line": 2596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_printf",
          "args": [
            "\"sc_dataptr=%p\\n\"",
            "sc->sc_dataptr"
          ],
          "line": 2595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_printf",
          "args": [
            "\"sc_current=%p\\n\"",
            "sc->sc_current"
          ],
          "line": 2594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_printf",
          "args": [
            "\"sc_state=0x%x\\n\"",
            "sc->sc_state"
          ],
          "line": 2593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_printf",
          "args": [
            "\"TID=%d LUN=%d sr=0x%x\\n\"",
            "i",
            "j",
            "(long)sr"
          ],
          "line": 2588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_printf",
          "args": [
            "\"Active request matrix:\\n\""
          ],
          "line": 2583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_printf",
          "args": [
            "\"sc_rr=%d, current=%d\\n\"",
            "sc->sc_rr",
            "k"
          ],
          "line": 2581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr5380_show_req",
          "args": [
            "sr"
          ],
          "line": 2578
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_show_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "2530-2554",
          "snippet": "void\nncr5380_show_req(sr)\n\tstruct sci_req *sr;\n{\n\tstruct scsi_xfer *xs = sr->sr_xs;\n\n\tdb_printf(\"TID=%d \",\tsr->sr_target);\n\tdb_printf(\"LUN=%d \",\tsr->sr_lun);\n\tdb_printf(\"dh=%p \",\tsr->sr_dma_hand);\n\tdb_printf(\"dptr=%p \",\tsr->sr_dataptr);\n\tdb_printf(\"dlen=0x%x \",\tsr->sr_datalen);\n\tdb_printf(\"flags=%d \",\tsr->sr_flags);\n\tdb_printf(\"stat=%d \",\tsr->sr_status);\n\n\tif (xs == NULL) {\n\t\tdb_printf(\"(xs=NULL)\\n\");\n\t\treturn;\n\t}\n\tdb_printf(\"\\n\");\n#ifdef\tSCSIDEBUG\n\tshow_scsi_xs(xs);\n#else\n\tdb_printf(\"xs=%p\\n\", xs);\n#endif\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\nncr5380_show_req(sr)\n\tstruct sci_req *sr;\n{\n\tstruct scsi_xfer *xs = sr->sr_xs;\n\n\tdb_printf(\"TID=%d \",\tsr->sr_target);\n\tdb_printf(\"LUN=%d \",\tsr->sr_lun);\n\tdb_printf(\"dh=%p \",\tsr->sr_dma_hand);\n\tdb_printf(\"dptr=%p \",\tsr->sr_dataptr);\n\tdb_printf(\"dlen=0x%x \",\tsr->sr_datalen);\n\tdb_printf(\"flags=%d \",\tsr->sr_flags);\n\tdb_printf(\"stat=%d \",\tsr->sr_status);\n\n\tif (xs == NULL) {\n\t\tdb_printf(\"(xs=NULL)\\n\");\n\t\treturn;\n\t}\n\tdb_printf(\"\\n\");\n#ifdef\tSCSIDEBUG\n\tshow_scsi_xs(xs);\n#else\n\tdb_printf(\"xs=%p\\n\", xs);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "db_printf",
          "args": [
            "\"req %d: (sr=%p)\"",
            "i",
            "(long)sr"
          ],
          "line": 2577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_printf",
          "args": [
            "\"sc_ncmds=%d\\n\"",
            "sc->sc_ncmds"
          ],
          "line": 2570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_printf",
          "args": [
            "\"ncr5380_debug_sc == NULL\\n\""
          ],
          "line": 2566
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\nncr5380_show_state()\n{\n\tstruct ncr5380_softc *sc;\n\tstruct sci_req *sr;\n\tint i, j, k;\n\n\tsc = ncr5380_debug_sc;\n\n\tif (sc == NULL) {\n\t\tdb_printf(\"ncr5380_debug_sc == NULL\\n\");\n\t\treturn;\n\t}\n\n\tdb_printf(\"sc_ncmds=%d\\n\",  \tsc->sc_ncmds);\n\tk = -1;\t/* which is current? */\n\tfor (i = 0; i < SCI_OPENINGS; i++) {\n\t\tsr = &sc->sc_ring[i];\n\t\tif (sr->sr_xs) {\n\t\t\tif (sr == sc->sc_current)\n\t\t\t\tk = i;\n\t\t\tdb_printf(\"req %d: (sr=%p)\", i, (long)sr);\n\t\t\tncr5380_show_req(sr);\n\t\t}\n\t}\n\tdb_printf(\"sc_rr=%d, current=%d\\n\", sc->sc_rr, k);\n\n\tdb_printf(\"Active request matrix:\\n\");\n\tfor(i = 0; i < 8; i++) {\t\t/* targets */\n\t\tfor (j = 0; j < 8; j++) {\t/* LUN */\n\t\t\tsr = sc->sc_matrix[i][j];\n\t\t\tif (sr) {\n\t\t\t\tdb_printf(\"TID=%d LUN=%d sr=0x%x\\n\", i, j, (long)sr);\n\t\t\t}\n\t\t}\n\t}\n\n\tdb_printf(\"sc_state=0x%x\\n\",\tsc->sc_state);\n\tdb_printf(\"sc_current=%p\\n\",\tsc->sc_current);\n\tdb_printf(\"sc_dataptr=%p\\n\",\tsc->sc_dataptr);\n\tdb_printf(\"sc_datalen=0x%x\\n\",\tsc->sc_datalen);\n\n\tdb_printf(\"sc_prevphase=%d\\n\",\tsc->sc_prevphase);\n\tdb_printf(\"sc_msgpriq=0x%x\\n\",\tsc->sc_msgpriq);\n}"
  },
  {
    "function_name": "ncr5380_show_req",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
    "lines": "2530-2554",
    "snippet": "void\nncr5380_show_req(sr)\n\tstruct sci_req *sr;\n{\n\tstruct scsi_xfer *xs = sr->sr_xs;\n\n\tdb_printf(\"TID=%d \",\tsr->sr_target);\n\tdb_printf(\"LUN=%d \",\tsr->sr_lun);\n\tdb_printf(\"dh=%p \",\tsr->sr_dma_hand);\n\tdb_printf(\"dptr=%p \",\tsr->sr_dataptr);\n\tdb_printf(\"dlen=0x%x \",\tsr->sr_datalen);\n\tdb_printf(\"flags=%d \",\tsr->sr_flags);\n\tdb_printf(\"stat=%d \",\tsr->sr_status);\n\n\tif (xs == NULL) {\n\t\tdb_printf(\"(xs=NULL)\\n\");\n\t\treturn;\n\t}\n\tdb_printf(\"\\n\");\n#ifdef\tSCSIDEBUG\n\tshow_scsi_xs(xs);\n#else\n\tdb_printf(\"xs=%p\\n\", xs);\n#endif\n}",
    "includes": [
      "#include <dev/ic/ncr5380var.h>",
      "#include <dev/ic/ncr5380reg.h>",
      "#include <ddb/db_output.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "db_printf",
          "args": [
            "\"xs=%p\\n\"",
            "xs"
          ],
          "line": 2552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_scsi_xs",
          "args": [
            "xs"
          ],
          "line": 2550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_printf",
          "args": [
            "\"\\n\""
          ],
          "line": 2548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_printf",
          "args": [
            "\"(xs=NULL)\\n\""
          ],
          "line": 2545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_printf",
          "args": [
            "\"stat=%d \"",
            "sr->sr_status"
          ],
          "line": 2542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_printf",
          "args": [
            "\"flags=%d \"",
            "sr->sr_flags"
          ],
          "line": 2541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_printf",
          "args": [
            "\"dlen=0x%x \"",
            "sr->sr_datalen"
          ],
          "line": 2540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_printf",
          "args": [
            "\"dptr=%p \"",
            "sr->sr_dataptr"
          ],
          "line": 2539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_printf",
          "args": [
            "\"dh=%p \"",
            "sr->sr_dma_hand"
          ],
          "line": 2538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_printf",
          "args": [
            "\"LUN=%d \"",
            "sr->sr_lun"
          ],
          "line": 2537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_printf",
          "args": [
            "\"TID=%d \"",
            "sr->sr_target"
          ],
          "line": 2536
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\nncr5380_show_req(sr)\n\tstruct sci_req *sr;\n{\n\tstruct scsi_xfer *xs = sr->sr_xs;\n\n\tdb_printf(\"TID=%d \",\tsr->sr_target);\n\tdb_printf(\"LUN=%d \",\tsr->sr_lun);\n\tdb_printf(\"dh=%p \",\tsr->sr_dma_hand);\n\tdb_printf(\"dptr=%p \",\tsr->sr_dataptr);\n\tdb_printf(\"dlen=0x%x \",\tsr->sr_datalen);\n\tdb_printf(\"flags=%d \",\tsr->sr_flags);\n\tdb_printf(\"stat=%d \",\tsr->sr_status);\n\n\tif (xs == NULL) {\n\t\tdb_printf(\"(xs=NULL)\\n\");\n\t\treturn;\n\t}\n\tdb_printf(\"\\n\");\n#ifdef\tSCSIDEBUG\n\tshow_scsi_xs(xs);\n#else\n\tdb_printf(\"xs=%p\\n\", xs);\n#endif\n}"
  },
  {
    "function_name": "ncr5380_show_trace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
    "lines": "2513-2528",
    "snippet": "void\nncr5380_show_trace()\n{\n\tstruct trace_ent *tr;\n\tint idx;\n\n\tidx = ncr5380_traceidx;\n\tdo {\n\t\ttr = &ncr5380_tracebuf[idx];\n\t\tidx++;\n\t\tif (idx >= TRACE_MAX)\n\t\t\tidx = 0;\n\t\tif (tr->msg)\n\t\t\tdb_printf(tr->msg, tr->val);\n\t} while (idx != ncr5380_traceidx);\n}",
    "includes": [
      "#include <dev/ic/ncr5380var.h>",
      "#include <dev/ic/ncr5380reg.h>",
      "#include <ddb/db_output.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\tTRACE_MAX\t1024"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "db_printf",
          "args": [
            "tr->msg",
            "tr->val"
          ],
          "line": 2526
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tTRACE_MAX\t1024\n\nvoid\nncr5380_show_trace()\n{\n\tstruct trace_ent *tr;\n\tint idx;\n\n\tidx = ncr5380_traceidx;\n\tdo {\n\t\ttr = &ncr5380_tracebuf[idx];\n\t\tidx++;\n\t\tif (idx >= TRACE_MAX)\n\t\t\tidx = 0;\n\t\tif (tr->msg)\n\t\t\tdb_printf(tr->msg, tr->val);\n\t} while (idx != ncr5380_traceidx);\n}"
  },
  {
    "function_name": "ncr5380_clear_trace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
    "lines": "2506-2511",
    "snippet": "void\nncr5380_clear_trace()\n{\n\tncr5380_traceidx = 0;\n\tbzero((char*) ncr5380_tracebuf, sizeof(ncr5380_tracebuf));\n}",
    "includes": [
      "#include <dev/ic/ncr5380var.h>",
      "#include <dev/ic/ncr5380reg.h>",
      "#include <ddb/db_output.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char*) ncr5380_tracebuf",
            "sizeof(ncr5380_tracebuf)"
          ],
          "line": 2510
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\nncr5380_clear_trace()\n{\n\tncr5380_traceidx = 0;\n\tbzero((char*) ncr5380_tracebuf, sizeof(ncr5380_tracebuf));\n}"
  },
  {
    "function_name": "ncr5380_trace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
    "lines": "2483-2503",
    "snippet": "void\nncr5380_trace(msg, val)\n\tchar *msg;\n\tlong  val;\n{\n\tregister struct trace_ent *tr;\n\tregister int s;\n\n\ts = splbio();\n\n\ttr = &ncr5380_tracebuf[ncr5380_traceidx];\n\n\tncr5380_traceidx++;\n\tif (ncr5380_traceidx >= TRACE_MAX)\n\t\tncr5380_traceidx = 0;\n\n\ttr->msg = msg;\n\ttr->val = val;\n\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/ic/ncr5380var.h>",
      "#include <dev/ic/ncr5380reg.h>",
      "#include <ddb/db_output.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\tTRACE_MAX\t1024"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 2502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 2491
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tTRACE_MAX\t1024\n\nvoid\nncr5380_trace(msg, val)\n\tchar *msg;\n\tlong  val;\n{\n\tregister struct trace_ent *tr;\n\tregister int s;\n\n\ts = splbio();\n\n\ttr = &ncr5380_tracebuf[ncr5380_traceidx];\n\n\tncr5380_traceidx++;\n\tif (ncr5380_traceidx >= TRACE_MAX)\n\t\tncr5380_traceidx = 0;\n\n\ttr->msg = msg;\n\ttr->val = val;\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "ncr5380_show_sense",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
    "lines": "2462-2473",
    "snippet": "static void\nncr5380_show_sense(xs)\n\tstruct scsi_xfer *xs;\n{\n\tu_char\t*b = (u_char *)&xs->sense;\n\tint\ti;\n\n\tprintf(\"sense:\");\n\tfor (i = 0; i < sizeof(xs->sense); i++)\n\t\tprintf(\" %02x\", b[i]);\n\tprintf(\"\\n\");\n}",
    "includes": [
      "#include <dev/ic/ncr5380var.h>",
      "#include <dev/ic/ncr5380reg.h>",
      "#include <ddb/db_output.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 2472
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void\nncr5380_show_sense(xs)\n\tstruct scsi_xfer *xs;\n{\n\tu_char\t*b = (u_char *)&xs->sense;\n\tint\ti;\n\n\tprintf(\"sense:\");\n\tfor (i = 0; i < sizeof(xs->sense); i++)\n\t\tprintf(\" %02x\", b[i]);\n\tprintf(\"\\n\");\n}"
  },
  {
    "function_name": "ncr5380_show_scsi_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
    "lines": "2438-2459",
    "snippet": "static void\nncr5380_show_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tu_char\t*b = (u_char *) xs->cmd;\n\tint\ti  = 0;\n\n\tif ( ! ( xs->flags & SCSI_RESET ) ) {\n\t\tprintf(\"si(%d:%d:%d)-\",\n\t\t    xs->sc_link->scsibus, xs->sc_link->target,\n\t\t    xs->sc_link->lun);\n\t\twhile (i < xs->cmdlen) {\n\t\t\tif (i) printf(\",\");\n\t\t\tprintf(\"%x\",b[i++]);\n\t\t}\n\t\tprintf(\"-\\n\");\n\t} else {\n\t\tprintf(\"si(%d:%d:%d)-RESET-\\n\",\n\t\t    xs->sc_link->scsibus, xs->sc_link->target,\n\t\t    xs->sc_link->lun);\n\t}\n}",
    "includes": [
      "#include <dev/ic/ncr5380var.h>",
      "#include <dev/ic/ncr5380reg.h>",
      "#include <ddb/db_output.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"si(%d:%d:%d)-RESET-\\n\"",
            "xs->sc_link->scsibus",
            "xs->sc_link->target",
            "xs->sc_link->lun"
          ],
          "line": 2455
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void\nncr5380_show_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tu_char\t*b = (u_char *) xs->cmd;\n\tint\ti  = 0;\n\n\tif ( ! ( xs->flags & SCSI_RESET ) ) {\n\t\tprintf(\"si(%d:%d:%d)-\",\n\t\t    xs->sc_link->scsibus, xs->sc_link->target,\n\t\t    xs->sc_link->lun);\n\t\twhile (i < xs->cmdlen) {\n\t\t\tif (i) printf(\",\");\n\t\t\tprintf(\"%x\",b[i++]);\n\t\t}\n\t\tprintf(\"-\\n\");\n\t} else {\n\t\tprintf(\"si(%d:%d:%d)-RESET-\\n\",\n\t\t    xs->sc_link->scsibus, xs->sc_link->target,\n\t\t    xs->sc_link->lun);\n\t}\n}"
  },
  {
    "function_name": "ncr5380_machine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
    "lines": "2191-2433",
    "snippet": "static void\nncr5380_machine(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tstruct sci_req *sr;\n\tstruct scsi_xfer *xs;\n\tint act_flags, phase, timo;\n\n#ifdef\tDIAGNOSTIC\n\tif (sc->sc_state == NCR_IDLE)\n\t\tpanic(\"ncr5380_machine: state=idle\");\n\tif (sc->sc_current == NULL)\n\t\tpanic(\"ncr5380_machine: no current cmd\");\n#endif\n\n\tsr = sc->sc_current;\n\txs = sr->sr_xs;\n\tact_flags = ACT_CONTINUE;\n\n\t/*\n\t * This will be called by ncr5380_intr() when DMA is\n\t * complete.  Must stop DMA before touching the 5380 or\n\t * there will be \"register conflict\" errors.\n\t */\n\tif (sc->sc_state & NCR_DOINGDMA) {\n\t\t/* Pick-up where where we left off... */\n\t\tgoto dma_done;\n\t}\n\nnext_phase:\n\n\tif (!SCI_BUSY(sc)) {\n\t\t/* Unexpected disconnect */\n\t\tprintf(\"ncr5380_machine: unexpected disconnect.\\n\");\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\tact_flags |= (ACT_DISCONNECT | ACT_CMD_DONE);\n\t\tgoto do_actions;\n\t}\n\n\t/*\n\t * Wait for REQ before reading the phase.\n\t * Need to wait longer than usual here, because\n\t * some devices are just plain slow...\n\t */\n\ttimo = ncr5380_wait_phase_timo;\n\tfor (;;) {\n\t\tif (*sc->sci_bus_csr & SCI_BUS_REQ)\n\t\t\tbreak;\n\t\tif (--timo <= 0) {\n\t\t\tif (sc->sc_state & NCR_ABORTING) {\n\t\t\t\tprintf(\"%s: no REQ while aborting, reset\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tact_flags |= ACT_RESET_BUS;\n\t\t\t\tgoto do_actions;\n\t\t\t}\n\t\t\tprintf(\"%s: no REQ for next phase, abort\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tsc->sc_state |= NCR_ABORTING;\n\t\t\tncr_sched_msgout(sc, SEND_ABORT);\n\t\t\tgoto next_phase;\n\t\t}\n\t\tdelay(100);\n\t}\n\n\tphase = SCI_BUS_PHASE(*sc->sci_bus_csr);\n\tNCR_TRACE(\"machine: phase=%s\\n\",\n\t\t\t  (long) phase_names[phase & 7]);\n\n\t/*\n\t * We assume that the device knows what it's doing,\n\t * so any phase is good.\n\t */\n\n#if 0\n\t/*\n\t * XXX: Do not ACK the phase yet! do it later...\n\t * XXX: ... each phase routine does that itself.\n\t * In particular, DMA needs it done LATER.\n\t */\n\t*sc->sci_tcmd = phase;\t/* acknowledge phase change */\n#endif\n\n\tswitch (phase) {\n\n\tcase PHASE_DATA_OUT:\n\tcase PHASE_DATA_IN:\n\t\tact_flags = ncr5380_data_xfer(sc, phase);\n\t\tbreak;\n\n\tcase PHASE_COMMAND:\n\t\tact_flags = ncr5380_command(sc);\n\t\tbreak;\n\n\tcase PHASE_STATUS:\n\t\tact_flags = ncr5380_status(sc);\n\t\tbreak;\n\n\tcase PHASE_MSG_OUT:\n\t\tact_flags = ncr5380_msg_out(sc);\n\t\tbreak;\n\n\tcase PHASE_MSG_IN:\n\t\tact_flags = ncr5380_msg_in(sc);\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"ncr5380_machine: Unexpected phase 0x%x\\n\", phase);\n\t\tsc->sc_state |= NCR_ABORTING;\n\t\tncr_sched_msgout(sc, SEND_ABORT);\n\t\tgoto next_phase;\n\n\t} /* switch */\n\tsc->sc_prevphase = phase;\n\ndo_actions:\n\t__asm(\"_ncr5380_actions:\");\n\n\tif (act_flags & ACT_WAIT_DMA) {\n\t\tact_flags &= ~ACT_WAIT_DMA;\n\t\t/* Wait for DMA to complete (polling, or interrupt). */\n\t\tif ((sr->sr_flags & SR_IMMED) == 0) {\n\t\t\tNCR_TRACE(\"machine: wait for DMA intr.\\n\", 0);\n\t\t\treturn; \t/* will resume at dma_done */\n\t\t}\n\t\t/* Busy-wait for it to finish. */\n\t\tNCR_TRACE(\"machine: dma_poll, dh=0x%x\\n\",\n\t\t\t\t  (long) sr->sr_dma_hand);\n\t\t(*sc->sc_dma_poll)(sc);\n\tdma_done:\n\t\t/* Return here after interrupt. */\n\t\tif (sr->sr_flags & SR_OVERDUE)\n\t\t\tsc->sc_state |= NCR_ABORTING;\n\t\tNCR_TRACE(\"machine: dma_stop, dh=0x%x\\n\",\n\t\t\t\t  (long) sr->sr_dma_hand);\n\t\t(*sc->sc_dma_stop)(sc);\n\t\tSCI_CLR_INTR(sc);\t/* XXX */\n\t\t/*\n\t\t * While DMA is running we can not touch the SBC,\n\t\t * so various places just set NCR_ABORTING and\n\t\t * expect us the \"kick it\" when DMA is done.\n\t\t */\n\t\tif (sc->sc_state & NCR_ABORTING) {\n\t\t\tncr_sched_msgout(sc, SEND_ABORT);\n\t\t}\n\t}\n\n\t/*\n\t * Check for parity error.\n\t * XXX - better place to check?\n\t */\n\tif (*(sc->sci_csr) & SCI_CSR_PERR) {\n\t\tprintf(\"%s: parity error!\\n\", sc->sc_dev.dv_xname);\n\t\t/* XXX: sc->sc_state |= NCR_ABORTING; */\n\t\tncr_sched_msgout(sc, SEND_PARITY_ERROR);\n\t}\n\n\tif (act_flags == ACT_CONTINUE)\n\t\tgoto next_phase;\n\t/* All other actions \"break\" from the loop. */\n\n\tNCR_TRACE(\"machine: act_flags=0x%x\\n\", act_flags);\n\n\tif (act_flags & ACT_RESET_BUS) {\n\t\tact_flags |= ACT_CMD_DONE;\n\t\t/*\n\t\t * Reset the SCSI bus, usually due to a timeout.\n\t\t * The error code XS_TIMEOUT allows retries.\n\t\t */\n\t\tsc->sc_state |= NCR_ABORTING;\n\t\tprintf(\"%s: reset SCSI bus for TID=%d LUN=%d\\n\",\n\t\t    sc->sc_dev.dv_xname, sr->sr_target, sr->sr_lun);\n\t\tncr5380_reset_scsibus(sc);\n\t}\n\n\tif (act_flags & ACT_CMD_DONE) {\n\t\tact_flags |= ACT_DISCONNECT;\n\t\t/* Need to call scsi_done() */\n\t\t/* XXX: from the aic6360 driver, but why? */\n\t\tif (sc->sc_datalen < 0) {\n\t\t\tprintf(\"%s: %d extra bytes from %d:%d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, -sc->sc_datalen,\n\t\t\t    sr->sr_target, sr->sr_lun);\n\t\t\tsc->sc_datalen = 0;\n\t\t}\n\t\txs->resid = sc->sc_datalen;\n\t\t/* Note: this will clear sc_current */\n\t\tNCR_TRACE(\"machine: call done, cur=0x%x\\n\", (long)sr);\n\t\tncr5380_done(sc);\n\t}\n\n\tif (act_flags & ACT_DISCONNECT) {\n\t\t/*\n\t\t * The device has dropped BSY (or will soon).\n\t\t * We have to wait here for BSY to drop, otherwise\n\t\t * the next command may decide we need a bus reset.\n\t\t */\n\t\ttimo = ncr5380_wait_req_timo;\t/* XXX */\n\t\tfor (;;) {\n\t\t\tif (!SCI_BUSY(sc))\n\t\t\t\tgoto busfree;\n\t\t\tif (--timo <= 0)\n\t\t\t\tbreak;\n\t\t\tdelay(2);\n\t\t}\n\t\t/* Device is sitting on the bus! */\n\t\tprintf(\"%s: Target %d LUN %d stuck busy, resetting...\\n\",\n\t\t    sc->sc_dev.dv_xname, sr->sr_target, sr->sr_lun);\n\t\tncr5380_reset_scsibus(sc);\n\tbusfree:\n\t\tNCR_TRACE(\"machine: discon, waited %d\\n\",\n\t\t\tncr5380_wait_nrq_timo - timo);\n\n\t\t*sc->sci_icmd = 0;\n\t\t*sc->sci_mode = 0;\n\t\t*sc->sci_tcmd = PHASE_INVALID;\n\t\t*sc->sci_sel_enb = 0;\n\t\tSCI_CLR_INTR(sc);\n\t\t*sc->sci_sel_enb = 0x80;\n\n\t\tif ((act_flags & ACT_CMD_DONE) == 0) {\n\t\t\t__asm(\"_ncr5380_disconnected:\");\n\t\t\tNCR_TRACE(\"machine: discon, cur=0x%x\\n\", (long)sr);\n\t\t}\n\n\t\t/*\n\t\t * We may be here due to a disconnect message,\n\t\t * in which case we did NOT call ncr5380_done,\n\t\t * and we need to clear sc_current.\n\t\t */\n\t\tsc->sc_state = NCR_IDLE;\n\t\tsc->sc_current = NULL;\n\n\t\t/* Paranoia: clear everything. */\n\t\tsc->sc_dataptr = NULL;\n\t\tsc->sc_datalen = 0;\n\t\tsc->sc_prevphase = PHASE_INVALID;\n\t\tsc->sc_msgpriq = 0;\n\t\tsc->sc_msgoutq = 0;\n\t\tsc->sc_msgout  = 0;\n\n\t\t/* Our caller will re-enable interrupts. */\n\t}\n}",
    "includes": [
      "#include <dev/ic/ncr5380var.h>",
      "#include <dev/ic/ncr5380reg.h>",
      "#include <ddb/db_output.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define ACT_WAIT_DMA\t0x10\t/* Wait for DMA to complete */",
      "#define ACT_RESET_BUS\t0x04\t/* Need bus reset (cmd timeout) */",
      "#define ACT_CMD_DONE\t0x02\t/* Need to call scsi_done() */",
      "#define ACT_DISCONNECT\t0x01\t/* Target is disconnecting */",
      "#define ACT_CONTINUE\t0x00\t/* No flags: expect another phase */"
    ],
    "globals_used": [
      "static void\tncr5380_done",
      "static int\tncr5380_msg_in",
      "static int\tncr5380_msg_out",
      "static int\tncr5380_data_xfer",
      "static int\tncr5380_command",
      "static int\tncr5380_status",
      "static void\tncr5380_machine",
      "static char *\nphase_names[8] = {\n\t\"DATA_OUT\",\n\t\"DATA_IN\",\n\t\"COMMAND\",\n\t\"STATUS\",\n\t\"UNSPEC1\",\n\t\"UNSPEC2\",\n\t\"MSG_OUT\",\n\t\"MSG_IN\",\n};",
      "int ncr5380_wait_phase_timo = 1000 * 10 * 300;",
      "int ncr5380_wait_req_timo = 1000 * 50;",
      "int ncr5380_wait_nrq_timo = 1000 * 25;",
      "static __inline void ncr_sched_msgout"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"machine: discon, cur=0x%x\\n\"",
            "(long)sr"
          ],
          "line": 2412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCI_CLR_INTR",
          "args": [
            "sc"
          ],
          "line": 2407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"machine: discon, waited %d\\n\"",
            "ncr5380_wait_nrq_timo - timo"
          ],
          "line": 2400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr5380_reset_scsibus",
          "args": [
            "sc"
          ],
          "line": 2398
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_reset_scsibus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "391-411",
          "snippet": "void\nncr5380_reset_scsibus(sc)\n\tstruct ncr5380_softc *sc;\n{\n\n\tNCR_TRACE(\"reset_scsibus, cur=0x%x\\n\",\n\t\t\t  (long) sc->sc_current);\n\n\t*sc->sci_icmd = SCI_ICMD_RST;\n\tdelay(500);\n\t*sc->sci_icmd = 0;\n\n\t*sc->sci_mode = 0;\n\t*sc->sci_tcmd = PHASE_INVALID;\n\n\tSCI_CLR_INTR(sc);\n\t/* XXX - Need long delay here! */\n\tdelay(100000);\n\n\t/* XXX - Need to cancel disconnected requests. */\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\nncr5380_reset_scsibus(sc)\n\tstruct ncr5380_softc *sc;\n{\n\n\tNCR_TRACE(\"reset_scsibus, cur=0x%x\\n\",\n\t\t\t  (long) sc->sc_current);\n\n\t*sc->sci_icmd = SCI_ICMD_RST;\n\tdelay(500);\n\t*sc->sci_icmd = 0;\n\n\t*sc->sci_mode = 0;\n\t*sc->sci_tcmd = PHASE_INVALID;\n\n\tSCI_CLR_INTR(sc);\n\t/* XXX - Need long delay here! */\n\tdelay(100000);\n\n\t/* XXX - Need to cancel disconnected requests. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: Target %d LUN %d stuck busy, resetting...\\n\"",
            "sc->sc_dev.dv_xname",
            "sr->sr_target",
            "sr->sr_lun"
          ],
          "line": 2396
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "2"
          ],
          "line": 2393
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCI_BUSY",
          "args": [
            "sc"
          ],
          "line": 2389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr5380_done",
          "args": [
            "sc"
          ],
          "line": 2378
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "696-818",
          "snippet": "static void\nncr5380_done(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tstruct\tsci_req *sr;\n\tstruct\tscsi_xfer *xs;\n\n#ifdef\tDIAGNOSTIC\n\tif (sc->sc_state == NCR_IDLE)\n\t\tpanic(\"ncr5380_done: state=idle\");\n\tif (sc->sc_current == NULL)\n\t\tpanic(\"ncr5380_done: current=0\");\n#endif\n\n\tsr = sc->sc_current;\n\txs = sr->sr_xs;\n\n\tNCR_TRACE(\"done: top, cur=0x%x\\n\", (long) sc->sc_current);\n\n\t/*\n\t * Clean up DMA resources for this command.\n\t */\n\tif (sr->sr_dma_hand) {\n\t\tNCR_TRACE(\"done: dma_free, dh=0x%x\\n\",\n\t\t\t\t  (long) sr->sr_dma_hand);\n\t\t(*sc->sc_dma_free)(sc);\n\t}\n#ifdef\tDIAGNOSTIC\n\tif (sr->sr_dma_hand)\n\t\tpanic(\"ncr5380_done: dma free did not\");\n#endif\n\n\tif (sc->sc_state & NCR_ABORTING) {\n\t\tNCR_TRACE(\"done: aborting, error=%d\\n\", xs->error);\n\t\tif (xs->error == XS_NOERROR)\n\t\t\txs->error = XS_TIMEOUT;\n\t}\n\n\tNCR_TRACE(\"done: check error=%d\\n\", (long) xs->error);\n\n\t/* If error is already set, ignore sr_status value. */\n\tif (xs->error != XS_NOERROR)\n\t\tgoto finish;\n\n\tNCR_TRACE(\"done: check status=%d\\n\", sr->sr_status);\n\n\tswitch (sr->sr_status) {\n\tcase SCSI_OK:\t/* 0 */\n\t\tif (sr->sr_flags & SR_SENSE) {\n#ifdef\tNCR5380_DEBUG\n\t\t\tif (ncr5380_debug & NCR_DBG_CMDS) {\n\t\t\t\tncr5380_show_sense(xs);\n\t\t\t}\n#endif\n\t\t\txs->error = XS_SENSE;\n\t\t}\n\t\tbreak;\n\n\tcase SCSI_CHECK:\n\t\tif (sr->sr_flags & SR_SENSE) {\n\t\t\t/* Sense command also asked for sense? */\n\t\t\tprintf(\"ncr5380_done: sense asked for sense\\n\");\n\t\t\tNCR_BREAK();\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\tbreak;\n\t\t}\n\t\tsr->sr_flags |= SR_SENSE;\n\t\tNCR_TRACE(\"done: get sense, sr=0x%x\\n\", (long) sr);\n\t\t/*\n\t\t * Leave queued, but clear sc_current so we start over\n\t\t * with selection.  Guaranteed to get the same request.\n\t\t */\n\t\tsc->sc_state = NCR_IDLE;\n\t\tsc->sc_current = NULL;\n\t\tsc->sc_matrix[sr->sr_target][sr->sr_lun] = NULL;\n\t\treturn;\t\t/* XXX */\n\n\tcase SCSI_BUSY:\n\t\txs->error = XS_BUSY;\n\t\tbreak;\n\n\tcase -1:\n\t\t/* This is our \"impossible\" initial value. */\n\t\t/* fallthrough */\n\tdefault:\n\t\tprintf(\"%s: target %d, bad status=%d\\n\",\n\t\t    sc->sc_dev.dv_xname, sr->sr_target, sr->sr_status);\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\tbreak;\n\t}\n\nfinish:\n\n\tNCR_TRACE(\"done: finish, error=%d\\n\", xs->error);\n\n\t/*\n\t * Dequeue the finished command, but don't clear sc_state until\n\t * after the call to scsi_done(), because that may call back to\n\t * ncr5380_scsi_cmd() - unwanted recursion!\n\t *\n\t * Keeping sc->sc_state != idle terminates the recursion.\n\t */\n#ifdef\tDIAGNOSTIC\n\tif ((sc->sc_state & NCR_WORKING) == 0)\n\t\tpanic(\"ncr5380_done: bad state\");\n#endif\n\n\t/* Clear our pointers to the request. */\n\tsc->sc_current = NULL;\n\tsc->sc_matrix[sr->sr_target][sr->sr_lun] = NULL;\n\tuntimeout(ncr5380_cmd_timeout, sr);\n\n\t/* Make the request free. */\n\tsr->sr_xs = NULL;\n\tsc->sc_ncmds--;\n\n\t/* Tell common SCSI code it is done. */\n\txs->flags |= ITSDONE;\n\tscsi_done(xs);\n\n\tsc->sc_state = NCR_IDLE;\n\t/* Now ncr5380_sched() may be called again. */\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tNCR_DBG_CMDS\t2"
          ],
          "globals_used": [
            "static void\tncr5380_sched",
            "static void\tncr5380_done",
            "void\tncr5380_cmd_timeout"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tNCR_DBG_CMDS\t2\n\nstatic void\tncr5380_sched;\nstatic void\tncr5380_done;\nvoid\tncr5380_cmd_timeout;\n\nstatic void\nncr5380_done(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tstruct\tsci_req *sr;\n\tstruct\tscsi_xfer *xs;\n\n#ifdef\tDIAGNOSTIC\n\tif (sc->sc_state == NCR_IDLE)\n\t\tpanic(\"ncr5380_done: state=idle\");\n\tif (sc->sc_current == NULL)\n\t\tpanic(\"ncr5380_done: current=0\");\n#endif\n\n\tsr = sc->sc_current;\n\txs = sr->sr_xs;\n\n\tNCR_TRACE(\"done: top, cur=0x%x\\n\", (long) sc->sc_current);\n\n\t/*\n\t * Clean up DMA resources for this command.\n\t */\n\tif (sr->sr_dma_hand) {\n\t\tNCR_TRACE(\"done: dma_free, dh=0x%x\\n\",\n\t\t\t\t  (long) sr->sr_dma_hand);\n\t\t(*sc->sc_dma_free)(sc);\n\t}\n#ifdef\tDIAGNOSTIC\n\tif (sr->sr_dma_hand)\n\t\tpanic(\"ncr5380_done: dma free did not\");\n#endif\n\n\tif (sc->sc_state & NCR_ABORTING) {\n\t\tNCR_TRACE(\"done: aborting, error=%d\\n\", xs->error);\n\t\tif (xs->error == XS_NOERROR)\n\t\t\txs->error = XS_TIMEOUT;\n\t}\n\n\tNCR_TRACE(\"done: check error=%d\\n\", (long) xs->error);\n\n\t/* If error is already set, ignore sr_status value. */\n\tif (xs->error != XS_NOERROR)\n\t\tgoto finish;\n\n\tNCR_TRACE(\"done: check status=%d\\n\", sr->sr_status);\n\n\tswitch (sr->sr_status) {\n\tcase SCSI_OK:\t/* 0 */\n\t\tif (sr->sr_flags & SR_SENSE) {\n#ifdef\tNCR5380_DEBUG\n\t\t\tif (ncr5380_debug & NCR_DBG_CMDS) {\n\t\t\t\tncr5380_show_sense(xs);\n\t\t\t}\n#endif\n\t\t\txs->error = XS_SENSE;\n\t\t}\n\t\tbreak;\n\n\tcase SCSI_CHECK:\n\t\tif (sr->sr_flags & SR_SENSE) {\n\t\t\t/* Sense command also asked for sense? */\n\t\t\tprintf(\"ncr5380_done: sense asked for sense\\n\");\n\t\t\tNCR_BREAK();\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\tbreak;\n\t\t}\n\t\tsr->sr_flags |= SR_SENSE;\n\t\tNCR_TRACE(\"done: get sense, sr=0x%x\\n\", (long) sr);\n\t\t/*\n\t\t * Leave queued, but clear sc_current so we start over\n\t\t * with selection.  Guaranteed to get the same request.\n\t\t */\n\t\tsc->sc_state = NCR_IDLE;\n\t\tsc->sc_current = NULL;\n\t\tsc->sc_matrix[sr->sr_target][sr->sr_lun] = NULL;\n\t\treturn;\t\t/* XXX */\n\n\tcase SCSI_BUSY:\n\t\txs->error = XS_BUSY;\n\t\tbreak;\n\n\tcase -1:\n\t\t/* This is our \"impossible\" initial value. */\n\t\t/* fallthrough */\n\tdefault:\n\t\tprintf(\"%s: target %d, bad status=%d\\n\",\n\t\t    sc->sc_dev.dv_xname, sr->sr_target, sr->sr_status);\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\tbreak;\n\t}\n\nfinish:\n\n\tNCR_TRACE(\"done: finish, error=%d\\n\", xs->error);\n\n\t/*\n\t * Dequeue the finished command, but don't clear sc_state until\n\t * after the call to scsi_done(), because that may call back to\n\t * ncr5380_scsi_cmd() - unwanted recursion!\n\t *\n\t * Keeping sc->sc_state != idle terminates the recursion.\n\t */\n#ifdef\tDIAGNOSTIC\n\tif ((sc->sc_state & NCR_WORKING) == 0)\n\t\tpanic(\"ncr5380_done: bad state\");\n#endif\n\n\t/* Clear our pointers to the request. */\n\tsc->sc_current = NULL;\n\tsc->sc_matrix[sr->sr_target][sr->sr_lun] = NULL;\n\tuntimeout(ncr5380_cmd_timeout, sr);\n\n\t/* Make the request free. */\n\tsr->sr_xs = NULL;\n\tsc->sc_ncmds--;\n\n\t/* Tell common SCSI code it is done. */\n\txs->flags |= ITSDONE;\n\tscsi_done(xs);\n\n\tsc->sc_state = NCR_IDLE;\n\t/* Now ncr5380_sched() may be called again. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"machine: call done, cur=0x%x\\n\"",
            "(long)sr"
          ],
          "line": 2377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"machine: act_flags=0x%x\\n\"",
            "act_flags"
          ],
          "line": 2351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr_sched_msgout",
          "args": [
            "sc",
            "SEND_PARITY_ERROR"
          ],
          "line": 2344
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_sched_msgout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "222-235",
          "snippet": "static __inline void\nncr_sched_msgout(sc, msg_code)\n\tstruct ncr5380_softc *sc;\n\tint msg_code;\n{\n\t/* First time, raise ATN line. */\n\tif (sc->sc_msgpriq == 0) {\n\t\tregister u_char icmd;\n\t\ticmd = *sc->sci_icmd & SCI_ICMD_RMASK;\n\t\t*sc->sci_icmd = icmd | SCI_ICMD_ATN;\n\t\tdelay(2);\n\t}\n\tsc->sc_msgpriq |= msg_code;\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline void ncr_sched_msgout"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic __inline void ncr_sched_msgout;\n\nstatic __inline void\nncr_sched_msgout(sc, msg_code)\n\tstruct ncr5380_softc *sc;\n\tint msg_code;\n{\n\t/* First time, raise ATN line. */\n\tif (sc->sc_msgpriq == 0) {\n\t\tregister u_char icmd;\n\t\ticmd = *sc->sci_icmd & SCI_ICMD_RMASK;\n\t\t*sc->sci_icmd = icmd | SCI_ICMD_ATN;\n\t\tdelay(2);\n\t}\n\tsc->sc_msgpriq |= msg_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCI_CLR_INTR",
          "args": [
            "sc"
          ],
          "line": 2326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc"
          ],
          "line": 2325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"machine: dma_stop, dh=0x%x\\n\"",
            "(long) sr->sr_dma_hand"
          ],
          "line": 2323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc"
          ],
          "line": 2318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"machine: dma_poll, dh=0x%x\\n\"",
            "(long) sr->sr_dma_hand"
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"machine: wait for DMA intr.\\n\"",
            "0"
          ],
          "line": 2312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr5380_msg_in",
          "args": [
            "sc"
          ],
          "line": 2293
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_msg_in",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "1552-1767",
          "snippet": "static int\nncr5380_msg_in(sc)\n\tregister struct ncr5380_softc *sc;\n{\n\tstruct sci_req *sr = sc->sc_current;\n\tstruct scsi_xfer *xs = sr->sr_xs;\n\tint n, phase;\n\tint act_flags;\n\tregister u_char icmd;\n\n\t/* acknowledge phase change */\n\t*sc->sci_tcmd = PHASE_MSG_IN;\n\n\tact_flags = ACT_CONTINUE;\n\ticmd = *sc->sci_icmd & SCI_ICMD_RMASK;\n\n\tif (sc->sc_prevphase == PHASE_MSG_IN) {\n\t\t/* This is a continuation of the previous message. */\n\t\tn = sc->sc_imp - sc->sc_imess;\n\t\tNCR_TRACE(\"msg_in: continuation, n=%d\\n\", n);\n\t\tgoto nextbyte;\n\t}\n\n\t/* This is a new MESSAGE IN phase.  Clean up our state. */\n\tsc->sc_state &= ~NCR_DROP_MSGIN;\n\nnextmsg:\n\tn = 0;\n\tsc->sc_imp = &sc->sc_imess[n];\n\nnextbyte:\n\t/*\n\t * Read a whole message, but don't ack the last byte.  If we reject the\n\t * message, we have to assert ATN during the message transfer phase\n\t * itself.\n\t */\n\tfor (;;) {\n\t\t/*\n\t\t * Read a message byte.\n\t\t * First, check BSY, REQ, phase...\n\t\t */\n\t\tif (!SCI_BUSY(sc)) {\n\t\t\tNCR_TRACE(\"msg_in: lost BSY, n=%d\\n\", n);\n\t\t\t/* XXX - Assume the command completed? */\n\t\t\tact_flags |= (ACT_DISCONNECT | ACT_CMD_DONE);\n\t\t\treturn (act_flags);\n\t\t}\n\t\tif (ncr5380_wait_req(sc)) {\n\t\t\tNCR_TRACE(\"msg_in: BSY but no REQ, n=%d\\n\", n);\n\t\t\t/* Just let ncr5380_machine() handle it... */\n\t\t\treturn (act_flags);\n\t\t}\n\t\tphase = SCI_BUS_PHASE(*sc->sci_bus_csr);\n\t\tif (phase != PHASE_MSG_IN) {\n\t\t\t/*\n\t\t\t * Target left MESSAGE IN, probably because it\n\t\t\t * a) noticed our ATN signal, or\n\t\t\t * b) ran out of messages.\n\t\t\t */\n\t\t\treturn (act_flags);\n\t\t}\n\t\t/* Still in MESSAGE IN phase, and REQ is asserted. */\n\t\tif (*sc->sci_csr & SCI_CSR_PERR) {\n\t\t\tncr_sched_msgout(sc, SEND_PARITY_ERROR);\n\t\t\tsc->sc_state |= NCR_DROP_MSGIN;\n\t\t}\n\n\t\t/* Gather incoming message bytes if needed. */\n\t\tif ((sc->sc_state & NCR_DROP_MSGIN) == 0) {\n\t\t\tif (n >= NCR_MAX_MSG_LEN) {\n\t\t\t\tncr_sched_msgout(sc, SEND_REJECT);\n\t\t\t\tsc->sc_state |= NCR_DROP_MSGIN;\n\t\t\t} else {\n\t\t\t\t*sc->sc_imp++ = *sc->sci_data;\n\t\t\t\tn++;\n\t\t\t\t/*\n\t\t\t\t * This testing is suboptimal, but most\n\t\t\t\t * messages will be of the one byte variety, so\n\t\t\t\t * it should not affect performance\n\t\t\t\t * significantly.\n\t\t\t\t */\n\t\t\t\tif (n == 1 && IS1BYTEMSG(sc->sc_imess[0]))\n\t\t\t\t\tgoto have_msg;\n\t\t\t\tif (n == 2 && IS2BYTEMSG(sc->sc_imess[0]))\n\t\t\t\t\tgoto have_msg;\n\t\t\t\tif (n >= 3 && ISEXTMSG(sc->sc_imess[0]) &&\n\t\t\t\t\tn == sc->sc_imess[1] + 2)\n\t\t\t\t\tgoto have_msg;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we reach this spot we're either:\n\t\t * a) in the middle of a multi-byte message, or\n\t\t * b) dropping bytes.\n\t\t */\n\n\t\t/* Ack the last byte read. */\n\t\ticmd |= SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\tif (ncr5380_wait_not_req(sc)) {\n\t\t\tNCR_TRACE(\"msg_in: drop, stuck REQ, n=%d\\n\", n);\n\t\t\tact_flags |= ACT_RESET_BUS;\n\t\t}\n\n\t\ticmd &= ~SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\tif (act_flags != ACT_CONTINUE)\n\t\t\treturn (act_flags);\n\n\t\t/* back to nextbyte */\n\t}\n\nhave_msg:\n\t/* We now have a complete message.  Parse it. */\n\n\tswitch (sc->sc_imess[0]) {\n\tcase MSG_CMDCOMPLETE:\n\t\tNCR_TRACE(\"msg_in: CMDCOMPLETE\\n\", 0);\n\t\t/* Target is about to disconnect. */\n\t\tact_flags |= (ACT_DISCONNECT | ACT_CMD_DONE);\n\t\tbreak;\n\n\tcase MSG_PARITY_ERROR:\n\t\tNCR_TRACE(\"msg_in: PARITY_ERROR\\n\", 0);\n\t\t/* Resend the last message. */\n\t\tncr_sched_msgout(sc, sc->sc_msgout);\n\t\tbreak;\n\n\tcase MSG_MESSAGE_REJECT:\n\t\t/* The target rejects the last message we sent. */\n\t\tNCR_TRACE(\"msg_in: got reject for 0x%x\\n\", sc->sc_msgout);\n\t\tswitch (sc->sc_msgout) {\n\t\tcase SEND_IDENTIFY:\n\t\t\t/* Really old target controller? */\n\t\t\t/* XXX ... */\n\t\t\tbreak;\n\t\tcase SEND_INIT_DET_ERR:\n\t\t\tgoto abort;\n\t\t}\n\t\tbreak;\n\n\tcase MSG_NOOP:\n\t\tNCR_TRACE(\"msg_in: NOOP\\n\", 0);\n\t\tbreak;\n\n\tcase MSG_DISCONNECT:\n\t\tNCR_TRACE(\"msg_in: DISCONNECT\\n\", 0);\n\t\t/* Target is about to disconnect. */\n\t\tact_flags |= ACT_DISCONNECT;\n\t\tif ((xs->sc_link->quirks & SDEV_AUTOSAVE) == 0)\n\t\t\tbreak;\n\t\t/*FALLTHROUGH*/\n\n\tcase MSG_SAVEDATAPOINTER:\n\t\tNCR_TRACE(\"msg_in: SAVE_PTRS\\n\", 0);\n\t\tsr->sr_dataptr = sc->sc_dataptr;\n\t\tsr->sr_datalen = sc->sc_datalen;\n\t\tbreak;\n\n\tcase MSG_RESTOREPOINTERS:\n\t\tNCR_TRACE(\"msg_in: RESTORE_PTRS\\n\", 0);\n\t\tsc->sc_dataptr = sr->sr_dataptr;\n\t\tsc->sc_datalen = sr->sr_datalen;\n\t\tbreak;\n\n\tcase MSG_EXTENDED:\n\t\tswitch (sc->sc_imess[2]) {\n\t\tcase MSG_EXT_SDTR:\n\t\tcase MSG_EXT_WDTR:\n\t\t\t/* The ncr5380 can not do synchronous mode. */\n\t\t\tgoto reject;\n\t\tdefault:\n\t\t\tprintf(\"%s: unrecognized MESSAGE EXTENDED; sending REJECT\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tNCR_BREAK();\n\t\t\tgoto reject;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tNCR_TRACE(\"msg_in: eh? imsg=0x%x\\n\", sc->sc_imess[0]);\n\t\tprintf(\"%s: unrecognized MESSAGE; sending REJECT\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tNCR_BREAK();\n\t\t/* fallthrough */\n\treject:\n\t\tncr_sched_msgout(sc, SEND_REJECT);\n\t\tbreak;\n\n\tabort:\n\t\tsc->sc_state |= NCR_ABORTING;\n\t\tncr_sched_msgout(sc, SEND_ABORT);\n\t\tbreak;\n\t}\n\n\t/* Ack the last byte read. */\n\ticmd |= SCI_ICMD_ACK;\n\t*sc->sci_icmd = icmd;\n\n\tif (ncr5380_wait_not_req(sc)) {\n\t\tNCR_TRACE(\"msg_in: last, stuck REQ, n=%d\\n\", n);\n\t\tact_flags |= ACT_RESET_BUS;\n\t}\n\n\ticmd &= ~SCI_ICMD_ACK;\n\t*sc->sci_icmd = icmd;\n\n\t/* Go get the next message, if any. */\n\tif (act_flags == ACT_CONTINUE)\n\t\tgoto nextmsg;\n\n\treturn (act_flags);\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define ACT_RESET_BUS\t0x04\t/* Need bus reset (cmd timeout) */",
            "#define ACT_CMD_DONE\t0x02\t/* Need to call scsi_done() */",
            "#define ACT_DISCONNECT\t0x01\t/* Target is disconnecting */",
            "#define ACT_CONTINUE\t0x00\t/* No flags: expect another phase */"
          ],
          "globals_used": [
            "static int\tncr5380_msg_in",
            "static void\tncr5380_machine",
            "static __inline int ncr5380_wait_req",
            "static __inline int ncr5380_wait_not_req",
            "static __inline void ncr_sched_msgout"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define ACT_RESET_BUS\t0x04\t/* Need bus reset (cmd timeout) */\n#define ACT_CMD_DONE\t0x02\t/* Need to call scsi_done() */\n#define ACT_DISCONNECT\t0x01\t/* Target is disconnecting */\n#define ACT_CONTINUE\t0x00\t/* No flags: expect another phase */\n\nstatic int\tncr5380_msg_in;\nstatic void\tncr5380_machine;\nstatic __inline int ncr5380_wait_req;\nstatic __inline int ncr5380_wait_not_req;\nstatic __inline void ncr_sched_msgout;\n\nstatic int\nncr5380_msg_in(sc)\n\tregister struct ncr5380_softc *sc;\n{\n\tstruct sci_req *sr = sc->sc_current;\n\tstruct scsi_xfer *xs = sr->sr_xs;\n\tint n, phase;\n\tint act_flags;\n\tregister u_char icmd;\n\n\t/* acknowledge phase change */\n\t*sc->sci_tcmd = PHASE_MSG_IN;\n\n\tact_flags = ACT_CONTINUE;\n\ticmd = *sc->sci_icmd & SCI_ICMD_RMASK;\n\n\tif (sc->sc_prevphase == PHASE_MSG_IN) {\n\t\t/* This is a continuation of the previous message. */\n\t\tn = sc->sc_imp - sc->sc_imess;\n\t\tNCR_TRACE(\"msg_in: continuation, n=%d\\n\", n);\n\t\tgoto nextbyte;\n\t}\n\n\t/* This is a new MESSAGE IN phase.  Clean up our state. */\n\tsc->sc_state &= ~NCR_DROP_MSGIN;\n\nnextmsg:\n\tn = 0;\n\tsc->sc_imp = &sc->sc_imess[n];\n\nnextbyte:\n\t/*\n\t * Read a whole message, but don't ack the last byte.  If we reject the\n\t * message, we have to assert ATN during the message transfer phase\n\t * itself.\n\t */\n\tfor (;;) {\n\t\t/*\n\t\t * Read a message byte.\n\t\t * First, check BSY, REQ, phase...\n\t\t */\n\t\tif (!SCI_BUSY(sc)) {\n\t\t\tNCR_TRACE(\"msg_in: lost BSY, n=%d\\n\", n);\n\t\t\t/* XXX - Assume the command completed? */\n\t\t\tact_flags |= (ACT_DISCONNECT | ACT_CMD_DONE);\n\t\t\treturn (act_flags);\n\t\t}\n\t\tif (ncr5380_wait_req(sc)) {\n\t\t\tNCR_TRACE(\"msg_in: BSY but no REQ, n=%d\\n\", n);\n\t\t\t/* Just let ncr5380_machine() handle it... */\n\t\t\treturn (act_flags);\n\t\t}\n\t\tphase = SCI_BUS_PHASE(*sc->sci_bus_csr);\n\t\tif (phase != PHASE_MSG_IN) {\n\t\t\t/*\n\t\t\t * Target left MESSAGE IN, probably because it\n\t\t\t * a) noticed our ATN signal, or\n\t\t\t * b) ran out of messages.\n\t\t\t */\n\t\t\treturn (act_flags);\n\t\t}\n\t\t/* Still in MESSAGE IN phase, and REQ is asserted. */\n\t\tif (*sc->sci_csr & SCI_CSR_PERR) {\n\t\t\tncr_sched_msgout(sc, SEND_PARITY_ERROR);\n\t\t\tsc->sc_state |= NCR_DROP_MSGIN;\n\t\t}\n\n\t\t/* Gather incoming message bytes if needed. */\n\t\tif ((sc->sc_state & NCR_DROP_MSGIN) == 0) {\n\t\t\tif (n >= NCR_MAX_MSG_LEN) {\n\t\t\t\tncr_sched_msgout(sc, SEND_REJECT);\n\t\t\t\tsc->sc_state |= NCR_DROP_MSGIN;\n\t\t\t} else {\n\t\t\t\t*sc->sc_imp++ = *sc->sci_data;\n\t\t\t\tn++;\n\t\t\t\t/*\n\t\t\t\t * This testing is suboptimal, but most\n\t\t\t\t * messages will be of the one byte variety, so\n\t\t\t\t * it should not affect performance\n\t\t\t\t * significantly.\n\t\t\t\t */\n\t\t\t\tif (n == 1 && IS1BYTEMSG(sc->sc_imess[0]))\n\t\t\t\t\tgoto have_msg;\n\t\t\t\tif (n == 2 && IS2BYTEMSG(sc->sc_imess[0]))\n\t\t\t\t\tgoto have_msg;\n\t\t\t\tif (n >= 3 && ISEXTMSG(sc->sc_imess[0]) &&\n\t\t\t\t\tn == sc->sc_imess[1] + 2)\n\t\t\t\t\tgoto have_msg;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we reach this spot we're either:\n\t\t * a) in the middle of a multi-byte message, or\n\t\t * b) dropping bytes.\n\t\t */\n\n\t\t/* Ack the last byte read. */\n\t\ticmd |= SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\tif (ncr5380_wait_not_req(sc)) {\n\t\t\tNCR_TRACE(\"msg_in: drop, stuck REQ, n=%d\\n\", n);\n\t\t\tact_flags |= ACT_RESET_BUS;\n\t\t}\n\n\t\ticmd &= ~SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\tif (act_flags != ACT_CONTINUE)\n\t\t\treturn (act_flags);\n\n\t\t/* back to nextbyte */\n\t}\n\nhave_msg:\n\t/* We now have a complete message.  Parse it. */\n\n\tswitch (sc->sc_imess[0]) {\n\tcase MSG_CMDCOMPLETE:\n\t\tNCR_TRACE(\"msg_in: CMDCOMPLETE\\n\", 0);\n\t\t/* Target is about to disconnect. */\n\t\tact_flags |= (ACT_DISCONNECT | ACT_CMD_DONE);\n\t\tbreak;\n\n\tcase MSG_PARITY_ERROR:\n\t\tNCR_TRACE(\"msg_in: PARITY_ERROR\\n\", 0);\n\t\t/* Resend the last message. */\n\t\tncr_sched_msgout(sc, sc->sc_msgout);\n\t\tbreak;\n\n\tcase MSG_MESSAGE_REJECT:\n\t\t/* The target rejects the last message we sent. */\n\t\tNCR_TRACE(\"msg_in: got reject for 0x%x\\n\", sc->sc_msgout);\n\t\tswitch (sc->sc_msgout) {\n\t\tcase SEND_IDENTIFY:\n\t\t\t/* Really old target controller? */\n\t\t\t/* XXX ... */\n\t\t\tbreak;\n\t\tcase SEND_INIT_DET_ERR:\n\t\t\tgoto abort;\n\t\t}\n\t\tbreak;\n\n\tcase MSG_NOOP:\n\t\tNCR_TRACE(\"msg_in: NOOP\\n\", 0);\n\t\tbreak;\n\n\tcase MSG_DISCONNECT:\n\t\tNCR_TRACE(\"msg_in: DISCONNECT\\n\", 0);\n\t\t/* Target is about to disconnect. */\n\t\tact_flags |= ACT_DISCONNECT;\n\t\tif ((xs->sc_link->quirks & SDEV_AUTOSAVE) == 0)\n\t\t\tbreak;\n\t\t/*FALLTHROUGH*/\n\n\tcase MSG_SAVEDATAPOINTER:\n\t\tNCR_TRACE(\"msg_in: SAVE_PTRS\\n\", 0);\n\t\tsr->sr_dataptr = sc->sc_dataptr;\n\t\tsr->sr_datalen = sc->sc_datalen;\n\t\tbreak;\n\n\tcase MSG_RESTOREPOINTERS:\n\t\tNCR_TRACE(\"msg_in: RESTORE_PTRS\\n\", 0);\n\t\tsc->sc_dataptr = sr->sr_dataptr;\n\t\tsc->sc_datalen = sr->sr_datalen;\n\t\tbreak;\n\n\tcase MSG_EXTENDED:\n\t\tswitch (sc->sc_imess[2]) {\n\t\tcase MSG_EXT_SDTR:\n\t\tcase MSG_EXT_WDTR:\n\t\t\t/* The ncr5380 can not do synchronous mode. */\n\t\t\tgoto reject;\n\t\tdefault:\n\t\t\tprintf(\"%s: unrecognized MESSAGE EXTENDED; sending REJECT\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tNCR_BREAK();\n\t\t\tgoto reject;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tNCR_TRACE(\"msg_in: eh? imsg=0x%x\\n\", sc->sc_imess[0]);\n\t\tprintf(\"%s: unrecognized MESSAGE; sending REJECT\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tNCR_BREAK();\n\t\t/* fallthrough */\n\treject:\n\t\tncr_sched_msgout(sc, SEND_REJECT);\n\t\tbreak;\n\n\tabort:\n\t\tsc->sc_state |= NCR_ABORTING;\n\t\tncr_sched_msgout(sc, SEND_ABORT);\n\t\tbreak;\n\t}\n\n\t/* Ack the last byte read. */\n\ticmd |= SCI_ICMD_ACK;\n\t*sc->sci_icmd = icmd;\n\n\tif (ncr5380_wait_not_req(sc)) {\n\t\tNCR_TRACE(\"msg_in: last, stuck REQ, n=%d\\n\", n);\n\t\tact_flags |= ACT_RESET_BUS;\n\t}\n\n\ticmd &= ~SCI_ICMD_ACK;\n\t*sc->sci_icmd = icmd;\n\n\t/* Go get the next message, if any. */\n\tif (act_flags == ACT_CONTINUE)\n\t\tgoto nextmsg;\n\n\treturn (act_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr5380_msg_out",
          "args": [
            "sc"
          ],
          "line": 2289
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_msg_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "1789-2004",
          "snippet": "static int\nncr5380_msg_out(sc)\n\tregister struct ncr5380_softc *sc;\n{\n\tstruct sci_req *sr = sc->sc_current;\n\tint act_flags, n, phase, progress;\n\tregister u_char icmd, msg;\n\n\t/* acknowledge phase change */\n\t*sc->sci_tcmd = PHASE_MSG_OUT;\n\n\tprogress = 0;\t/* did we send any messages? */\n\tact_flags = ACT_CONTINUE;\n\n\t/*\n\t * Set ATN.  If we're just sending a trivial 1-byte message,\n\t * we'll clear ATN later on anyway.  Also drive the data bus.\n\t */\n\ticmd = *sc->sci_icmd & SCI_ICMD_RMASK;\n\ticmd |= (SCI_ICMD_ATN | SCI_ICMD_DATA);\n\t*sc->sci_icmd = icmd;\n\n\tif (sc->sc_prevphase == PHASE_MSG_OUT) {\n\t\tif (sc->sc_omp == sc->sc_omess) {\n\t\t\t/*\n\t\t\t * This is a retransmission.\n\t\t\t *\n\t\t\t * We get here if the target stayed in MESSAGE OUT\n\t\t\t * phase.  Section 5.1.9.2 of the SCSI 2 spec indicates\n\t\t\t * that all of the previously transmitted messages must\n\t\t\t * be sent again, in the same order.  Therefore, we\n\t\t\t * requeue all the previously transmitted messages, and\n\t\t\t * start again from the top.  Our simple priority\n\t\t\t * scheme keeps the messages in the right order.\n\t\t\t */\n\t\t\tsc->sc_msgpriq |= sc->sc_msgoutq;\n\t\t\tNCR_TRACE(\"msg_out: retrans priq=0x%x\\n\", sc->sc_msgpriq);\n\t\t} else {\n\t\t\t/* This is a continuation of the previous message. */\n\t\t\tn = sc->sc_omp - sc->sc_omess;\n\t\t\tNCR_TRACE(\"msg_out: continuation, n=%d\\n\", n);\n\t\t\tgoto nextbyte;\n\t\t}\n\t}\n\n\t/* No messages transmitted so far. */\n\tsc->sc_msgoutq = 0;\n\nnextmsg:\n\t/* Pick up highest priority message. */\n\tsc->sc_msgout = sc->sc_msgpriq & -sc->sc_msgpriq;\n\tsc->sc_msgpriq &= ~sc->sc_msgout;\n\tsc->sc_msgoutq |= sc->sc_msgout;\n\n\t/* Build the outgoing message data. */\n\tswitch (sc->sc_msgout) {\n\tcase SEND_IDENTIFY:\n\t\tNCR_TRACE(\"msg_out: SEND_IDENTIFY\\n\", 0);\n\t\tif (sr == NULL) {\n\t\t\tprintf(\"%s: SEND_IDENTIFY while not connected; sending NOOP\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tNCR_BREAK();\n\t\t\tgoto noop;\n\t\t}\n\t\t/*\n\t\t * The identify message we send determines whether \n\t\t * disconnect/reselect is allowed for this command.\n\t\t * 0xC0+LUN: allows it, 0x80+LUN disallows it.\n\t\t */\n\t\tmsg = 0xc0;\t/* MSG_IDENTIFY(0,1) */\n\t\tif (sc->sc_no_disconnect & (1 << sr->sr_target))\n\t\t\tmsg = 0x80;\n\t\tif (sr->sr_flags & (SR_IMMED | SR_SENSE))\n\t\t\tmsg = 0x80;\n\t\tsc->sc_omess[0] = msg | sr->sr_lun;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_DEV_RESET:\n\t\tNCR_TRACE(\"msg_out: SEND_DEV_RESET\\n\", 0);\n\t\t/* Expect disconnect after this! */\n\t\t/* XXX: Kill jobs for this target? */\n\t\tact_flags |= (ACT_DISCONNECT | ACT_CMD_DONE);\n\t\tsc->sc_omess[0] = MSG_BUS_DEV_RESET;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_REJECT:\n\t\tNCR_TRACE(\"msg_out: SEND_REJECT\\n\", 0);\n\t\tsc->sc_omess[0] = MSG_MESSAGE_REJECT;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_PARITY_ERROR:\n\t\tNCR_TRACE(\"msg_out: SEND_PARITY_ERROR\\n\", 0);\n\t\tsc->sc_omess[0] = MSG_PARITY_ERROR;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_INIT_DET_ERR:\n\t\tNCR_TRACE(\"msg_out: SEND_INIT_DET_ERR\\n\", 0);\n\t\tsc->sc_omess[0] = MSG_INITIATOR_DET_ERR;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_ABORT:\n\t\tNCR_TRACE(\"msg_out: SEND_ABORT\\n\", 0);\n\t\t/* Expect disconnect after this! */\n\t\t/* XXX: Set error flag? */\n\t\tact_flags |= (ACT_DISCONNECT | ACT_CMD_DONE);\n\t\tsc->sc_omess[0] = MSG_ABORT;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase 0:\n\t\tprintf(\"%s: unexpected MESSAGE OUT; sending NOOP\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tNCR_BREAK();\n\tnoop:\n\t\tNCR_TRACE(\"msg_out: send NOOP\\n\", 0);\n\t\tsc->sc_omess[0] = MSG_NOOP;\n\t\tn = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"%s: weird MESSAGE OUT; sending NOOP\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tNCR_BREAK();\n\t\tgoto noop;\n\t}\n\tsc->sc_omp = &sc->sc_omess[n];\n\nnextbyte:\n\t/* Send message bytes. */\n\twhile (n > 0) {\n\t\t/*\n\t\t * Send a message byte.\n\t\t * First check BSY, REQ, phase...\n\t\t */\n\t\tif (!SCI_BUSY(sc)) {\n\t\t\tNCR_TRACE(\"msg_out: lost BSY, n=%d\\n\", n);\n\t\t\tgoto out;\n\t\t}\n\t\tif (ncr5380_wait_req(sc)) {\n\t\t\tNCR_TRACE(\"msg_out: no REQ, n=%d\\n\", n);\n\t\t\tgoto out;\n\t\t}\n\t\tphase = SCI_BUS_PHASE(*sc->sci_bus_csr);\n\t\tif (phase != PHASE_MSG_OUT) {\n\t\t\t/*\n\t\t\t * Target left MESSAGE OUT, possibly to reject\n\t\t\t * our message.\n\t\t\t */\n\t\t\tNCR_TRACE(\"msg_out: new phase=%d\\n\", phase);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Yes, we can send this message byte. */\n\t\t--n;\n\n\t\t/* Clear ATN before last byte if this is the last message. */\n\t\tif (n == 0 && sc->sc_msgpriq == 0) {\n\t\t\ticmd &= ~SCI_ICMD_ATN;\n\t\t\t*sc->sci_icmd = icmd;\n\t\t\t/* 2 deskew delays */\n\t\t\tdelay(2);\t/* XXX */\n\t\t}\n\n\t\t/* Put data on the bus. */\n\t\t*sc->sci_odata = *--sc->sc_omp;\n\n\t\t/* Raise ACK to tell target data is on the bus. */\n\t\ticmd |= SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\t/* Wait for REQ to be negated. */\n\t\tif (ncr5380_wait_not_req(sc)) {\n\t\t\tNCR_TRACE(\"msg_out: stuck REQ, n=%d\\n\", n);\n\t\t\tact_flags |= ACT_RESET_BUS;\n\t\t}\n\n\t\t/* Finally, drop ACK. */\n\t\ticmd &= ~SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\t/* Stuck bus or something... */\n\t\tif (act_flags & ACT_RESET_BUS)\n\t\t\tgoto out;\n\n\t}\n\tprogress++;\n\n\t/* We get here only if the entire message has been transmitted. */\n\tif (sc->sc_msgpriq != 0) {\n\t\t/* There are more outgoing messages. */\n\t\tgoto nextmsg;\n\t}\n\n\t/*\n\t * The last message has been transmitted.  We need to remember the last\n\t * message transmitted (in case the target switches to MESSAGE IN phase\n\t * and sends a MESSAGE REJECT), and the list of messages transmitted\n\t * this time around (in case the target stays in MESSAGE OUT phase to\n\t * request a retransmit).\n\t */\n\nout:\n\t/* Stop driving the data bus. */\n\ticmd &= ~SCI_ICMD_DATA;\n\t*sc->sci_icmd = icmd;\n\n\tif (!progress)\n\t\tact_flags |= ACT_RESET_BUS;\n\n\treturn (act_flags);\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define ACT_RESET_BUS\t0x04\t/* Need bus reset (cmd timeout) */",
            "#define ACT_CMD_DONE\t0x02\t/* Need to call scsi_done() */",
            "#define ACT_DISCONNECT\t0x01\t/* Target is disconnecting */",
            "#define ACT_CONTINUE\t0x00\t/* No flags: expect another phase */"
          ],
          "globals_used": [
            "static int\tncr5380_msg_out",
            "static __inline int ncr5380_wait_req",
            "static __inline int ncr5380_wait_not_req"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define ACT_RESET_BUS\t0x04\t/* Need bus reset (cmd timeout) */\n#define ACT_CMD_DONE\t0x02\t/* Need to call scsi_done() */\n#define ACT_DISCONNECT\t0x01\t/* Target is disconnecting */\n#define ACT_CONTINUE\t0x00\t/* No flags: expect another phase */\n\nstatic int\tncr5380_msg_out;\nstatic __inline int ncr5380_wait_req;\nstatic __inline int ncr5380_wait_not_req;\n\nstatic int\nncr5380_msg_out(sc)\n\tregister struct ncr5380_softc *sc;\n{\n\tstruct sci_req *sr = sc->sc_current;\n\tint act_flags, n, phase, progress;\n\tregister u_char icmd, msg;\n\n\t/* acknowledge phase change */\n\t*sc->sci_tcmd = PHASE_MSG_OUT;\n\n\tprogress = 0;\t/* did we send any messages? */\n\tact_flags = ACT_CONTINUE;\n\n\t/*\n\t * Set ATN.  If we're just sending a trivial 1-byte message,\n\t * we'll clear ATN later on anyway.  Also drive the data bus.\n\t */\n\ticmd = *sc->sci_icmd & SCI_ICMD_RMASK;\n\ticmd |= (SCI_ICMD_ATN | SCI_ICMD_DATA);\n\t*sc->sci_icmd = icmd;\n\n\tif (sc->sc_prevphase == PHASE_MSG_OUT) {\n\t\tif (sc->sc_omp == sc->sc_omess) {\n\t\t\t/*\n\t\t\t * This is a retransmission.\n\t\t\t *\n\t\t\t * We get here if the target stayed in MESSAGE OUT\n\t\t\t * phase.  Section 5.1.9.2 of the SCSI 2 spec indicates\n\t\t\t * that all of the previously transmitted messages must\n\t\t\t * be sent again, in the same order.  Therefore, we\n\t\t\t * requeue all the previously transmitted messages, and\n\t\t\t * start again from the top.  Our simple priority\n\t\t\t * scheme keeps the messages in the right order.\n\t\t\t */\n\t\t\tsc->sc_msgpriq |= sc->sc_msgoutq;\n\t\t\tNCR_TRACE(\"msg_out: retrans priq=0x%x\\n\", sc->sc_msgpriq);\n\t\t} else {\n\t\t\t/* This is a continuation of the previous message. */\n\t\t\tn = sc->sc_omp - sc->sc_omess;\n\t\t\tNCR_TRACE(\"msg_out: continuation, n=%d\\n\", n);\n\t\t\tgoto nextbyte;\n\t\t}\n\t}\n\n\t/* No messages transmitted so far. */\n\tsc->sc_msgoutq = 0;\n\nnextmsg:\n\t/* Pick up highest priority message. */\n\tsc->sc_msgout = sc->sc_msgpriq & -sc->sc_msgpriq;\n\tsc->sc_msgpriq &= ~sc->sc_msgout;\n\tsc->sc_msgoutq |= sc->sc_msgout;\n\n\t/* Build the outgoing message data. */\n\tswitch (sc->sc_msgout) {\n\tcase SEND_IDENTIFY:\n\t\tNCR_TRACE(\"msg_out: SEND_IDENTIFY\\n\", 0);\n\t\tif (sr == NULL) {\n\t\t\tprintf(\"%s: SEND_IDENTIFY while not connected; sending NOOP\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tNCR_BREAK();\n\t\t\tgoto noop;\n\t\t}\n\t\t/*\n\t\t * The identify message we send determines whether \n\t\t * disconnect/reselect is allowed for this command.\n\t\t * 0xC0+LUN: allows it, 0x80+LUN disallows it.\n\t\t */\n\t\tmsg = 0xc0;\t/* MSG_IDENTIFY(0,1) */\n\t\tif (sc->sc_no_disconnect & (1 << sr->sr_target))\n\t\t\tmsg = 0x80;\n\t\tif (sr->sr_flags & (SR_IMMED | SR_SENSE))\n\t\t\tmsg = 0x80;\n\t\tsc->sc_omess[0] = msg | sr->sr_lun;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_DEV_RESET:\n\t\tNCR_TRACE(\"msg_out: SEND_DEV_RESET\\n\", 0);\n\t\t/* Expect disconnect after this! */\n\t\t/* XXX: Kill jobs for this target? */\n\t\tact_flags |= (ACT_DISCONNECT | ACT_CMD_DONE);\n\t\tsc->sc_omess[0] = MSG_BUS_DEV_RESET;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_REJECT:\n\t\tNCR_TRACE(\"msg_out: SEND_REJECT\\n\", 0);\n\t\tsc->sc_omess[0] = MSG_MESSAGE_REJECT;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_PARITY_ERROR:\n\t\tNCR_TRACE(\"msg_out: SEND_PARITY_ERROR\\n\", 0);\n\t\tsc->sc_omess[0] = MSG_PARITY_ERROR;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_INIT_DET_ERR:\n\t\tNCR_TRACE(\"msg_out: SEND_INIT_DET_ERR\\n\", 0);\n\t\tsc->sc_omess[0] = MSG_INITIATOR_DET_ERR;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_ABORT:\n\t\tNCR_TRACE(\"msg_out: SEND_ABORT\\n\", 0);\n\t\t/* Expect disconnect after this! */\n\t\t/* XXX: Set error flag? */\n\t\tact_flags |= (ACT_DISCONNECT | ACT_CMD_DONE);\n\t\tsc->sc_omess[0] = MSG_ABORT;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase 0:\n\t\tprintf(\"%s: unexpected MESSAGE OUT; sending NOOP\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tNCR_BREAK();\n\tnoop:\n\t\tNCR_TRACE(\"msg_out: send NOOP\\n\", 0);\n\t\tsc->sc_omess[0] = MSG_NOOP;\n\t\tn = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"%s: weird MESSAGE OUT; sending NOOP\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tNCR_BREAK();\n\t\tgoto noop;\n\t}\n\tsc->sc_omp = &sc->sc_omess[n];\n\nnextbyte:\n\t/* Send message bytes. */\n\twhile (n > 0) {\n\t\t/*\n\t\t * Send a message byte.\n\t\t * First check BSY, REQ, phase...\n\t\t */\n\t\tif (!SCI_BUSY(sc)) {\n\t\t\tNCR_TRACE(\"msg_out: lost BSY, n=%d\\n\", n);\n\t\t\tgoto out;\n\t\t}\n\t\tif (ncr5380_wait_req(sc)) {\n\t\t\tNCR_TRACE(\"msg_out: no REQ, n=%d\\n\", n);\n\t\t\tgoto out;\n\t\t}\n\t\tphase = SCI_BUS_PHASE(*sc->sci_bus_csr);\n\t\tif (phase != PHASE_MSG_OUT) {\n\t\t\t/*\n\t\t\t * Target left MESSAGE OUT, possibly to reject\n\t\t\t * our message.\n\t\t\t */\n\t\t\tNCR_TRACE(\"msg_out: new phase=%d\\n\", phase);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Yes, we can send this message byte. */\n\t\t--n;\n\n\t\t/* Clear ATN before last byte if this is the last message. */\n\t\tif (n == 0 && sc->sc_msgpriq == 0) {\n\t\t\ticmd &= ~SCI_ICMD_ATN;\n\t\t\t*sc->sci_icmd = icmd;\n\t\t\t/* 2 deskew delays */\n\t\t\tdelay(2);\t/* XXX */\n\t\t}\n\n\t\t/* Put data on the bus. */\n\t\t*sc->sci_odata = *--sc->sc_omp;\n\n\t\t/* Raise ACK to tell target data is on the bus. */\n\t\ticmd |= SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\t/* Wait for REQ to be negated. */\n\t\tif (ncr5380_wait_not_req(sc)) {\n\t\t\tNCR_TRACE(\"msg_out: stuck REQ, n=%d\\n\", n);\n\t\t\tact_flags |= ACT_RESET_BUS;\n\t\t}\n\n\t\t/* Finally, drop ACK. */\n\t\ticmd &= ~SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\t/* Stuck bus or something... */\n\t\tif (act_flags & ACT_RESET_BUS)\n\t\t\tgoto out;\n\n\t}\n\tprogress++;\n\n\t/* We get here only if the entire message has been transmitted. */\n\tif (sc->sc_msgpriq != 0) {\n\t\t/* There are more outgoing messages. */\n\t\tgoto nextmsg;\n\t}\n\n\t/*\n\t * The last message has been transmitted.  We need to remember the last\n\t * message transmitted (in case the target switches to MESSAGE IN phase\n\t * and sends a MESSAGE REJECT), and the list of messages transmitted\n\t * this time around (in case the target stays in MESSAGE OUT phase to\n\t * request a retransmit).\n\t */\n\nout:\n\t/* Stop driving the data bus. */\n\ticmd &= ~SCI_ICMD_DATA;\n\t*sc->sci_icmd = icmd;\n\n\tif (!progress)\n\t\tact_flags |= ACT_RESET_BUS;\n\n\treturn (act_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr5380_status",
          "args": [
            "sc"
          ],
          "line": 2285
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "2160-2179",
          "snippet": "static int\nncr5380_status(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tint len;\n\tu_char status;\n\tstruct sci_req *sr = sc->sc_current;\n\n\t/* acknowledge phase change */\n\t*sc->sci_tcmd = PHASE_STATUS;\n\n\tlen = ncr5380_pio_in(sc, PHASE_STATUS, 1, &status);\n\tif (len) {\n\t\tsr->sr_status = status;\n\t} else {\n\t\tprintf(\"ncr5380_status: none?\\n\");\n\t}\n\n\treturn ACT_CONTINUE;\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define ACT_CONTINUE\t0x00\t/* No flags: expect another phase */"
          ],
          "globals_used": [
            "static int\tncr5380_status"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define ACT_CONTINUE\t0x00\t/* No flags: expect another phase */\n\nstatic int\tncr5380_status;\n\nstatic int\nncr5380_status(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tint len;\n\tu_char status;\n\tstruct sci_req *sr = sc->sc_current;\n\n\t/* acknowledge phase change */\n\t*sc->sci_tcmd = PHASE_STATUS;\n\n\tlen = ncr5380_pio_in(sc, PHASE_STATUS, 1, &status);\n\tif (len) {\n\t\tsr->sr_status = status;\n\t} else {\n\t\tprintf(\"ncr5380_status: none?\\n\");\n\t}\n\n\treturn ACT_CONTINUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr5380_command",
          "args": [
            "sc"
          ],
          "line": 2281
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "2010-2054",
          "snippet": "static int\nncr5380_command(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tstruct sci_req *sr = sc->sc_current;\n\tstruct scsi_xfer *xs = sr->sr_xs;\n\tstruct scsi_sense rqs;\n\tint len;\n\n\t/* acknowledge phase change */\n\t*sc->sci_tcmd = PHASE_COMMAND;\n\n\tif (sr->sr_flags & SR_SENSE) {\n\t\trqs.opcode = REQUEST_SENSE;\n\t\trqs.byte2 = xs->sc_link->lun << 5;\n\t\trqs.length = sizeof(xs->sense);\n\n\t\trqs.unused[0] = rqs.unused[1] = rqs.control = 0;\n\t\tlen = ncr5380_pio_out(sc, PHASE_COMMAND, sizeof(rqs),\n\t\t\t(u_char *)&rqs);\n\t}\n\telse {\n\t\t/* Assume command can be sent in one go. */\n\t\t/* XXX: Do this using DMA, and get a phase change intr? */\n\t\tlen = ncr5380_pio_out(sc, PHASE_COMMAND, xs->cmdlen,\n\t\t\t(u_char *)xs->cmd);\n\t}\n\n\tif (len != xs->cmdlen) {\n#ifdef\tNCR5380_DEBUG\n\t\tprintf(\"ncr5380_command: short transfer: wanted %d got %d.\\n\",\n\t\t    xs->cmdlen, len);\n\t\tncr5380_show_scsi_cmd(xs);\n\t\tNCR_BREAK();\n#endif\n\t\tif (len < 6) {\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\tsc->sc_state |= NCR_ABORTING;\n\t\t\tncr_sched_msgout(sc, SEND_ABORT);\n\t\t}\n\n\t}\n\n\treturn ACT_CONTINUE;\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define ACT_CONTINUE\t0x00\t/* No flags: expect another phase */"
          ],
          "globals_used": [
            "static int\tncr5380_command",
            "static __inline void ncr_sched_msgout"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define ACT_CONTINUE\t0x00\t/* No flags: expect another phase */\n\nstatic int\tncr5380_command;\nstatic __inline void ncr_sched_msgout;\n\nstatic int\nncr5380_command(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tstruct sci_req *sr = sc->sc_current;\n\tstruct scsi_xfer *xs = sr->sr_xs;\n\tstruct scsi_sense rqs;\n\tint len;\n\n\t/* acknowledge phase change */\n\t*sc->sci_tcmd = PHASE_COMMAND;\n\n\tif (sr->sr_flags & SR_SENSE) {\n\t\trqs.opcode = REQUEST_SENSE;\n\t\trqs.byte2 = xs->sc_link->lun << 5;\n\t\trqs.length = sizeof(xs->sense);\n\n\t\trqs.unused[0] = rqs.unused[1] = rqs.control = 0;\n\t\tlen = ncr5380_pio_out(sc, PHASE_COMMAND, sizeof(rqs),\n\t\t\t(u_char *)&rqs);\n\t}\n\telse {\n\t\t/* Assume command can be sent in one go. */\n\t\t/* XXX: Do this using DMA, and get a phase change intr? */\n\t\tlen = ncr5380_pio_out(sc, PHASE_COMMAND, xs->cmdlen,\n\t\t\t(u_char *)xs->cmd);\n\t}\n\n\tif (len != xs->cmdlen) {\n#ifdef\tNCR5380_DEBUG\n\t\tprintf(\"ncr5380_command: short transfer: wanted %d got %d.\\n\",\n\t\t    xs->cmdlen, len);\n\t\tncr5380_show_scsi_cmd(xs);\n\t\tNCR_BREAK();\n#endif\n\t\tif (len < 6) {\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\tsc->sc_state |= NCR_ABORTING;\n\t\t\tncr_sched_msgout(sc, SEND_ABORT);\n\t\t}\n\n\t}\n\n\treturn ACT_CONTINUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr5380_data_xfer",
          "args": [
            "sc",
            "phase"
          ],
          "line": 2277
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_data_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "2060-2157",
          "snippet": "static int\nncr5380_data_xfer(sc, phase)\n\tstruct ncr5380_softc *sc;\n\tint phase;\n{\n\tstruct sci_req *sr = sc->sc_current;\n\tstruct scsi_xfer *xs = sr->sr_xs;\n\tint expected_phase;\n\tint len;\n\n\tif (sr->sr_flags & SR_SENSE) {\n\t\tNCR_TRACE(\"data_xfer: get sense, sr=0x%x\\n\", (long)sr);\n\t\tif (phase != PHASE_DATA_IN) {\n\t\t\tprintf(\"%s: sense phase error\\n\", sc->sc_dev.dv_xname);\n\t\t\tgoto abort;\n\t\t}\n\t\t/* acknowledge phase change */\n\t\t*sc->sci_tcmd = PHASE_DATA_IN;\n\t\tlen = ncr5380_pio_in(sc, phase, sizeof(xs->sense),\n\t\t\t\t(u_char *)&xs->sense);\n\t\treturn ACT_CONTINUE;\n\t}\n\n\t/*\n\t * When aborting a command, disallow any data phase.\n\t */\n\tif (sc->sc_state & NCR_ABORTING) {\n\t\tprintf(\"%s: aborting, but phase=%s (reset)\\n\",\n\t\t    sc->sc_dev.dv_xname, phase_names[phase & 7]);\n\t\treturn ACT_RESET_BUS;\t/* XXX */\n\t}\n\n\t/* Validate expected phase (data_in or data_out) */\n\texpected_phase = (xs->flags & SCSI_DATA_OUT) ?\n\t\tPHASE_DATA_OUT : PHASE_DATA_IN;\n\tif (phase != expected_phase) {\n\t\tprintf(\"%s: data phase error\\n\", sc->sc_dev.dv_xname);\n\t\tgoto abort;\n\t}\n\n\t/* Make sure we have some data to move. */\n\tif (sc->sc_datalen <= 0) {\n\t\t/* Device needs padding. */\n\t\tif (phase == PHASE_DATA_IN)\n\t\t\tncr5380_pio_in(sc, phase, 4096, NULL);\n\t\telse\n\t\t\tncr5380_pio_out(sc, phase, 4096, NULL);\n\t\t/* Make sure that caused a phase change. */\n\t\tif (SCI_BUS_PHASE(*sc->sci_bus_csr) == phase) {\n\t\t\t/* More than 4k is just too much! */\n\t\t\tprintf(\"%s: too much data padding\\n\",\n\t\t\t       sc->sc_dev.dv_xname);\n\t\t\tgoto abort;\n\t\t}\n\t\treturn ACT_CONTINUE;\n\t}\n\n\t/*\n\t * Attempt DMA only if dma_alloc gave us a DMA handle AND\n\t * there is enough left to transfer so DMA is worth while.\n\t */\n\tif (sr->sr_dma_hand &&\n\t\t(sc->sc_datalen >= sc->sc_min_dma_len))\n\t{\n\t\t/*\n\t\t * OK, really start DMA.  Note, the MD start function\n\t\t * is responsible for setting the TCMD register, etc.\n\t\t * (Acknowledge the phase change there, not here.)\n\t\t */\n\t\tNCR_TRACE(\"data_xfer: dma_start, dh=0x%x\\n\",\n\t\t          (long) sr->sr_dma_hand);\n\t\t(*sc->sc_dma_start)(sc);\n\t\treturn ACT_WAIT_DMA;\n\t}\n\n\t/*\n\t * Doing PIO for data transfer.  (Possibly \"Pseudo DMA\")\n\t * XXX:  Do PDMA functions need to set tcmd later?\n\t */\n\tNCR_TRACE(\"data_xfer: doing PIO, len=%d\\n\", sc->sc_datalen);\n\t/* acknowledge phase change */\n\t*sc->sci_tcmd = phase;\t/* XXX: OK for PDMA? */\n\tif (phase == PHASE_DATA_OUT) {\n\t\tlen = (*sc->sc_pio_out)(sc, phase, sc->sc_datalen, sc->sc_dataptr);\n\t} else {\n\t\tlen = (*sc->sc_pio_in) (sc, phase, sc->sc_datalen, sc->sc_dataptr);\n\t}\n\tsc->sc_dataptr += len;\n\tsc->sc_datalen -= len;\n\n\tNCR_TRACE(\"data_xfer: did PIO, resid=%d\\n\", sc->sc_datalen);\n\treturn (ACT_CONTINUE);\n\nabort:\n\tsc->sc_state |= NCR_ABORTING;\n\tncr_sched_msgout(sc, SEND_ABORT);\n\treturn (ACT_CONTINUE);\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define ACT_WAIT_DMA\t0x10\t/* Wait for DMA to complete */",
            "#define ACT_RESET_BUS\t0x04\t/* Need bus reset (cmd timeout) */",
            "#define ACT_CONTINUE\t0x00\t/* No flags: expect another phase */"
          ],
          "globals_used": [
            "static int\tncr5380_data_xfer",
            "static char *\nphase_names[8] = {\n\t\"DATA_OUT\",\n\t\"DATA_IN\",\n\t\"COMMAND\",\n\t\"STATUS\",\n\t\"UNSPEC1\",\n\t\"UNSPEC2\",\n\t\"MSG_OUT\",\n\t\"MSG_IN\",\n};",
            "static __inline void ncr_sched_msgout"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define ACT_WAIT_DMA\t0x10\t/* Wait for DMA to complete */\n#define ACT_RESET_BUS\t0x04\t/* Need bus reset (cmd timeout) */\n#define ACT_CONTINUE\t0x00\t/* No flags: expect another phase */\n\nstatic int\tncr5380_data_xfer;\nstatic char *\nphase_names[8] = {\n\t\"DATA_OUT\",\n\t\"DATA_IN\",\n\t\"COMMAND\",\n\t\"STATUS\",\n\t\"UNSPEC1\",\n\t\"UNSPEC2\",\n\t\"MSG_OUT\",\n\t\"MSG_IN\",\n};\nstatic __inline void ncr_sched_msgout;\n\nstatic int\nncr5380_data_xfer(sc, phase)\n\tstruct ncr5380_softc *sc;\n\tint phase;\n{\n\tstruct sci_req *sr = sc->sc_current;\n\tstruct scsi_xfer *xs = sr->sr_xs;\n\tint expected_phase;\n\tint len;\n\n\tif (sr->sr_flags & SR_SENSE) {\n\t\tNCR_TRACE(\"data_xfer: get sense, sr=0x%x\\n\", (long)sr);\n\t\tif (phase != PHASE_DATA_IN) {\n\t\t\tprintf(\"%s: sense phase error\\n\", sc->sc_dev.dv_xname);\n\t\t\tgoto abort;\n\t\t}\n\t\t/* acknowledge phase change */\n\t\t*sc->sci_tcmd = PHASE_DATA_IN;\n\t\tlen = ncr5380_pio_in(sc, phase, sizeof(xs->sense),\n\t\t\t\t(u_char *)&xs->sense);\n\t\treturn ACT_CONTINUE;\n\t}\n\n\t/*\n\t * When aborting a command, disallow any data phase.\n\t */\n\tif (sc->sc_state & NCR_ABORTING) {\n\t\tprintf(\"%s: aborting, but phase=%s (reset)\\n\",\n\t\t    sc->sc_dev.dv_xname, phase_names[phase & 7]);\n\t\treturn ACT_RESET_BUS;\t/* XXX */\n\t}\n\n\t/* Validate expected phase (data_in or data_out) */\n\texpected_phase = (xs->flags & SCSI_DATA_OUT) ?\n\t\tPHASE_DATA_OUT : PHASE_DATA_IN;\n\tif (phase != expected_phase) {\n\t\tprintf(\"%s: data phase error\\n\", sc->sc_dev.dv_xname);\n\t\tgoto abort;\n\t}\n\n\t/* Make sure we have some data to move. */\n\tif (sc->sc_datalen <= 0) {\n\t\t/* Device needs padding. */\n\t\tif (phase == PHASE_DATA_IN)\n\t\t\tncr5380_pio_in(sc, phase, 4096, NULL);\n\t\telse\n\t\t\tncr5380_pio_out(sc, phase, 4096, NULL);\n\t\t/* Make sure that caused a phase change. */\n\t\tif (SCI_BUS_PHASE(*sc->sci_bus_csr) == phase) {\n\t\t\t/* More than 4k is just too much! */\n\t\t\tprintf(\"%s: too much data padding\\n\",\n\t\t\t       sc->sc_dev.dv_xname);\n\t\t\tgoto abort;\n\t\t}\n\t\treturn ACT_CONTINUE;\n\t}\n\n\t/*\n\t * Attempt DMA only if dma_alloc gave us a DMA handle AND\n\t * there is enough left to transfer so DMA is worth while.\n\t */\n\tif (sr->sr_dma_hand &&\n\t\t(sc->sc_datalen >= sc->sc_min_dma_len))\n\t{\n\t\t/*\n\t\t * OK, really start DMA.  Note, the MD start function\n\t\t * is responsible for setting the TCMD register, etc.\n\t\t * (Acknowledge the phase change there, not here.)\n\t\t */\n\t\tNCR_TRACE(\"data_xfer: dma_start, dh=0x%x\\n\",\n\t\t          (long) sr->sr_dma_hand);\n\t\t(*sc->sc_dma_start)(sc);\n\t\treturn ACT_WAIT_DMA;\n\t}\n\n\t/*\n\t * Doing PIO for data transfer.  (Possibly \"Pseudo DMA\")\n\t * XXX:  Do PDMA functions need to set tcmd later?\n\t */\n\tNCR_TRACE(\"data_xfer: doing PIO, len=%d\\n\", sc->sc_datalen);\n\t/* acknowledge phase change */\n\t*sc->sci_tcmd = phase;\t/* XXX: OK for PDMA? */\n\tif (phase == PHASE_DATA_OUT) {\n\t\tlen = (*sc->sc_pio_out)(sc, phase, sc->sc_datalen, sc->sc_dataptr);\n\t} else {\n\t\tlen = (*sc->sc_pio_in) (sc, phase, sc->sc_datalen, sc->sc_dataptr);\n\t}\n\tsc->sc_dataptr += len;\n\tsc->sc_datalen -= len;\n\n\tNCR_TRACE(\"data_xfer: did PIO, resid=%d\\n\", sc->sc_datalen);\n\treturn (ACT_CONTINUE);\n\nabort:\n\tsc->sc_state |= NCR_ABORTING;\n\tncr_sched_msgout(sc, SEND_ABORT);\n\treturn (ACT_CONTINUE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"machine: phase=%s\\n\"",
            "(long) phase_names[phase & 7]"
          ],
          "line": 2256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCI_BUS_PHASE",
          "args": [
            "*sc->sci_bus_csr"
          ],
          "line": 2255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCI_BUSY",
          "args": [
            "sc"
          ],
          "line": 2222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ncr5380_machine: no current cmd\""
          ],
          "line": 2203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ncr5380_machine: state=idle\""
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define ACT_WAIT_DMA\t0x10\t/* Wait for DMA to complete */\n#define ACT_RESET_BUS\t0x04\t/* Need bus reset (cmd timeout) */\n#define ACT_CMD_DONE\t0x02\t/* Need to call scsi_done() */\n#define ACT_DISCONNECT\t0x01\t/* Target is disconnecting */\n#define ACT_CONTINUE\t0x00\t/* No flags: expect another phase */\n\nstatic void\tncr5380_done;\nstatic int\tncr5380_msg_in;\nstatic int\tncr5380_msg_out;\nstatic int\tncr5380_data_xfer;\nstatic int\tncr5380_command;\nstatic int\tncr5380_status;\nstatic void\tncr5380_machine;\nstatic char *\nphase_names[8] = {\n\t\"DATA_OUT\",\n\t\"DATA_IN\",\n\t\"COMMAND\",\n\t\"STATUS\",\n\t\"UNSPEC1\",\n\t\"UNSPEC2\",\n\t\"MSG_OUT\",\n\t\"MSG_IN\",\n};\nint ncr5380_wait_phase_timo = 1000 * 10 * 300;\nint ncr5380_wait_req_timo = 1000 * 50;\nint ncr5380_wait_nrq_timo = 1000 * 25;\nstatic __inline void ncr_sched_msgout;\n\nstatic void\nncr5380_machine(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tstruct sci_req *sr;\n\tstruct scsi_xfer *xs;\n\tint act_flags, phase, timo;\n\n#ifdef\tDIAGNOSTIC\n\tif (sc->sc_state == NCR_IDLE)\n\t\tpanic(\"ncr5380_machine: state=idle\");\n\tif (sc->sc_current == NULL)\n\t\tpanic(\"ncr5380_machine: no current cmd\");\n#endif\n\n\tsr = sc->sc_current;\n\txs = sr->sr_xs;\n\tact_flags = ACT_CONTINUE;\n\n\t/*\n\t * This will be called by ncr5380_intr() when DMA is\n\t * complete.  Must stop DMA before touching the 5380 or\n\t * there will be \"register conflict\" errors.\n\t */\n\tif (sc->sc_state & NCR_DOINGDMA) {\n\t\t/* Pick-up where where we left off... */\n\t\tgoto dma_done;\n\t}\n\nnext_phase:\n\n\tif (!SCI_BUSY(sc)) {\n\t\t/* Unexpected disconnect */\n\t\tprintf(\"ncr5380_machine: unexpected disconnect.\\n\");\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\tact_flags |= (ACT_DISCONNECT | ACT_CMD_DONE);\n\t\tgoto do_actions;\n\t}\n\n\t/*\n\t * Wait for REQ before reading the phase.\n\t * Need to wait longer than usual here, because\n\t * some devices are just plain slow...\n\t */\n\ttimo = ncr5380_wait_phase_timo;\n\tfor (;;) {\n\t\tif (*sc->sci_bus_csr & SCI_BUS_REQ)\n\t\t\tbreak;\n\t\tif (--timo <= 0) {\n\t\t\tif (sc->sc_state & NCR_ABORTING) {\n\t\t\t\tprintf(\"%s: no REQ while aborting, reset\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tact_flags |= ACT_RESET_BUS;\n\t\t\t\tgoto do_actions;\n\t\t\t}\n\t\t\tprintf(\"%s: no REQ for next phase, abort\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tsc->sc_state |= NCR_ABORTING;\n\t\t\tncr_sched_msgout(sc, SEND_ABORT);\n\t\t\tgoto next_phase;\n\t\t}\n\t\tdelay(100);\n\t}\n\n\tphase = SCI_BUS_PHASE(*sc->sci_bus_csr);\n\tNCR_TRACE(\"machine: phase=%s\\n\",\n\t\t\t  (long) phase_names[phase & 7]);\n\n\t/*\n\t * We assume that the device knows what it's doing,\n\t * so any phase is good.\n\t */\n\n#if 0\n\t/*\n\t * XXX: Do not ACK the phase yet! do it later...\n\t * XXX: ... each phase routine does that itself.\n\t * In particular, DMA needs it done LATER.\n\t */\n\t*sc->sci_tcmd = phase;\t/* acknowledge phase change */\n#endif\n\n\tswitch (phase) {\n\n\tcase PHASE_DATA_OUT:\n\tcase PHASE_DATA_IN:\n\t\tact_flags = ncr5380_data_xfer(sc, phase);\n\t\tbreak;\n\n\tcase PHASE_COMMAND:\n\t\tact_flags = ncr5380_command(sc);\n\t\tbreak;\n\n\tcase PHASE_STATUS:\n\t\tact_flags = ncr5380_status(sc);\n\t\tbreak;\n\n\tcase PHASE_MSG_OUT:\n\t\tact_flags = ncr5380_msg_out(sc);\n\t\tbreak;\n\n\tcase PHASE_MSG_IN:\n\t\tact_flags = ncr5380_msg_in(sc);\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"ncr5380_machine: Unexpected phase 0x%x\\n\", phase);\n\t\tsc->sc_state |= NCR_ABORTING;\n\t\tncr_sched_msgout(sc, SEND_ABORT);\n\t\tgoto next_phase;\n\n\t} /* switch */\n\tsc->sc_prevphase = phase;\n\ndo_actions:\n\t__asm(\"_ncr5380_actions:\");\n\n\tif (act_flags & ACT_WAIT_DMA) {\n\t\tact_flags &= ~ACT_WAIT_DMA;\n\t\t/* Wait for DMA to complete (polling, or interrupt). */\n\t\tif ((sr->sr_flags & SR_IMMED) == 0) {\n\t\t\tNCR_TRACE(\"machine: wait for DMA intr.\\n\", 0);\n\t\t\treturn; \t/* will resume at dma_done */\n\t\t}\n\t\t/* Busy-wait for it to finish. */\n\t\tNCR_TRACE(\"machine: dma_poll, dh=0x%x\\n\",\n\t\t\t\t  (long) sr->sr_dma_hand);\n\t\t(*sc->sc_dma_poll)(sc);\n\tdma_done:\n\t\t/* Return here after interrupt. */\n\t\tif (sr->sr_flags & SR_OVERDUE)\n\t\t\tsc->sc_state |= NCR_ABORTING;\n\t\tNCR_TRACE(\"machine: dma_stop, dh=0x%x\\n\",\n\t\t\t\t  (long) sr->sr_dma_hand);\n\t\t(*sc->sc_dma_stop)(sc);\n\t\tSCI_CLR_INTR(sc);\t/* XXX */\n\t\t/*\n\t\t * While DMA is running we can not touch the SBC,\n\t\t * so various places just set NCR_ABORTING and\n\t\t * expect us the \"kick it\" when DMA is done.\n\t\t */\n\t\tif (sc->sc_state & NCR_ABORTING) {\n\t\t\tncr_sched_msgout(sc, SEND_ABORT);\n\t\t}\n\t}\n\n\t/*\n\t * Check for parity error.\n\t * XXX - better place to check?\n\t */\n\tif (*(sc->sci_csr) & SCI_CSR_PERR) {\n\t\tprintf(\"%s: parity error!\\n\", sc->sc_dev.dv_xname);\n\t\t/* XXX: sc->sc_state |= NCR_ABORTING; */\n\t\tncr_sched_msgout(sc, SEND_PARITY_ERROR);\n\t}\n\n\tif (act_flags == ACT_CONTINUE)\n\t\tgoto next_phase;\n\t/* All other actions \"break\" from the loop. */\n\n\tNCR_TRACE(\"machine: act_flags=0x%x\\n\", act_flags);\n\n\tif (act_flags & ACT_RESET_BUS) {\n\t\tact_flags |= ACT_CMD_DONE;\n\t\t/*\n\t\t * Reset the SCSI bus, usually due to a timeout.\n\t\t * The error code XS_TIMEOUT allows retries.\n\t\t */\n\t\tsc->sc_state |= NCR_ABORTING;\n\t\tprintf(\"%s: reset SCSI bus for TID=%d LUN=%d\\n\",\n\t\t    sc->sc_dev.dv_xname, sr->sr_target, sr->sr_lun);\n\t\tncr5380_reset_scsibus(sc);\n\t}\n\n\tif (act_flags & ACT_CMD_DONE) {\n\t\tact_flags |= ACT_DISCONNECT;\n\t\t/* Need to call scsi_done() */\n\t\t/* XXX: from the aic6360 driver, but why? */\n\t\tif (sc->sc_datalen < 0) {\n\t\t\tprintf(\"%s: %d extra bytes from %d:%d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, -sc->sc_datalen,\n\t\t\t    sr->sr_target, sr->sr_lun);\n\t\t\tsc->sc_datalen = 0;\n\t\t}\n\t\txs->resid = sc->sc_datalen;\n\t\t/* Note: this will clear sc_current */\n\t\tNCR_TRACE(\"machine: call done, cur=0x%x\\n\", (long)sr);\n\t\tncr5380_done(sc);\n\t}\n\n\tif (act_flags & ACT_DISCONNECT) {\n\t\t/*\n\t\t * The device has dropped BSY (or will soon).\n\t\t * We have to wait here for BSY to drop, otherwise\n\t\t * the next command may decide we need a bus reset.\n\t\t */\n\t\ttimo = ncr5380_wait_req_timo;\t/* XXX */\n\t\tfor (;;) {\n\t\t\tif (!SCI_BUSY(sc))\n\t\t\t\tgoto busfree;\n\t\t\tif (--timo <= 0)\n\t\t\t\tbreak;\n\t\t\tdelay(2);\n\t\t}\n\t\t/* Device is sitting on the bus! */\n\t\tprintf(\"%s: Target %d LUN %d stuck busy, resetting...\\n\",\n\t\t    sc->sc_dev.dv_xname, sr->sr_target, sr->sr_lun);\n\t\tncr5380_reset_scsibus(sc);\n\tbusfree:\n\t\tNCR_TRACE(\"machine: discon, waited %d\\n\",\n\t\t\tncr5380_wait_nrq_timo - timo);\n\n\t\t*sc->sci_icmd = 0;\n\t\t*sc->sci_mode = 0;\n\t\t*sc->sci_tcmd = PHASE_INVALID;\n\t\t*sc->sci_sel_enb = 0;\n\t\tSCI_CLR_INTR(sc);\n\t\t*sc->sci_sel_enb = 0x80;\n\n\t\tif ((act_flags & ACT_CMD_DONE) == 0) {\n\t\t\t__asm(\"_ncr5380_disconnected:\");\n\t\t\tNCR_TRACE(\"machine: discon, cur=0x%x\\n\", (long)sr);\n\t\t}\n\n\t\t/*\n\t\t * We may be here due to a disconnect message,\n\t\t * in which case we did NOT call ncr5380_done,\n\t\t * and we need to clear sc_current.\n\t\t */\n\t\tsc->sc_state = NCR_IDLE;\n\t\tsc->sc_current = NULL;\n\n\t\t/* Paranoia: clear everything. */\n\t\tsc->sc_dataptr = NULL;\n\t\tsc->sc_datalen = 0;\n\t\tsc->sc_prevphase = PHASE_INVALID;\n\t\tsc->sc_msgpriq = 0;\n\t\tsc->sc_msgoutq = 0;\n\t\tsc->sc_msgout  = 0;\n\n\t\t/* Our caller will re-enable interrupts. */\n\t}\n}"
  },
  {
    "function_name": "ncr5380_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
    "lines": "2160-2179",
    "snippet": "static int\nncr5380_status(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tint len;\n\tu_char status;\n\tstruct sci_req *sr = sc->sc_current;\n\n\t/* acknowledge phase change */\n\t*sc->sci_tcmd = PHASE_STATUS;\n\n\tlen = ncr5380_pio_in(sc, PHASE_STATUS, 1, &status);\n\tif (len) {\n\t\tsr->sr_status = status;\n\t} else {\n\t\tprintf(\"ncr5380_status: none?\\n\");\n\t}\n\n\treturn ACT_CONTINUE;\n}",
    "includes": [
      "#include <dev/ic/ncr5380var.h>",
      "#include <dev/ic/ncr5380reg.h>",
      "#include <ddb/db_output.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define ACT_CONTINUE\t0x00\t/* No flags: expect another phase */"
    ],
    "globals_used": [
      "static int\tncr5380_status"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ncr5380_status: none?\\n\""
          ],
          "line": 2175
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr5380_pio_in",
          "args": [
            "sc",
            "PHASE_STATUS",
            "1",
            "&status"
          ],
          "line": 2171
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_pio_in",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "299-351",
          "snippet": "int\nncr5380_pio_in(sc, phase, count, data)\n\tstruct ncr5380_softc *sc;\n\tint phase, count;\n\tunsigned char\t\t\t*data;\n{\n\tregister u_char \ticmd;\n\tregister int\t\tresid;\n\tregister int\t\terror;\n\n\ticmd = *(sc->sci_icmd) & SCI_ICMD_RMASK;\n\n\tresid = count;\n\twhile (resid > 0) {\n\t\tif (!SCI_BUSY(sc)) {\n\t\t\tNCR_TRACE(\"pio_in: lost BSY, resid=%d\\n\", resid);\n\t\t\tbreak;\n\t\t}\n\t\tif (ncr5380_wait_req(sc)) {\n\t\t\tNCR_TRACE(\"pio_in: no REQ, resid=%d\\n\", resid);\n\t\t\tbreak;\n\t\t}\n\t\t/* A phase change is not valid until AFTER REQ rises! */\n\t\tif (SCI_BUS_PHASE(*sc->sci_bus_csr) != phase)\n\t\t\tbreak;\n\n\t\t/* Read the data bus. */\n\t\tif (data)\n\t\t\t*data++ = *sc->sci_data;\n\t\telse\n\t\t\t(void) *sc->sci_data;\n\n\t\t/* Tell target we got it. */\n\t\ticmd |= SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\t/* Wait for target to drop REQ... */\n\t\terror = ncr5380_wait_not_req(sc);\n\n\t\t/* OK, we can drop ACK. */\n\t\ticmd &= ~SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\tif (error) {\n\t\t\tNCR_TRACE(\"pio_in: stuck REQ, resid=%d\\n\", resid);\n\t\t\tbreak;\n\t\t}\n\n\t\t--resid;\n\t}\n\n\treturn (count - resid);\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline int ncr5380_wait_req",
            "static __inline int ncr5380_wait_not_req"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic __inline int ncr5380_wait_req;\nstatic __inline int ncr5380_wait_not_req;\n\nint\nncr5380_pio_in(sc, phase, count, data)\n\tstruct ncr5380_softc *sc;\n\tint phase, count;\n\tunsigned char\t\t\t*data;\n{\n\tregister u_char \ticmd;\n\tregister int\t\tresid;\n\tregister int\t\terror;\n\n\ticmd = *(sc->sci_icmd) & SCI_ICMD_RMASK;\n\n\tresid = count;\n\twhile (resid > 0) {\n\t\tif (!SCI_BUSY(sc)) {\n\t\t\tNCR_TRACE(\"pio_in: lost BSY, resid=%d\\n\", resid);\n\t\t\tbreak;\n\t\t}\n\t\tif (ncr5380_wait_req(sc)) {\n\t\t\tNCR_TRACE(\"pio_in: no REQ, resid=%d\\n\", resid);\n\t\t\tbreak;\n\t\t}\n\t\t/* A phase change is not valid until AFTER REQ rises! */\n\t\tif (SCI_BUS_PHASE(*sc->sci_bus_csr) != phase)\n\t\t\tbreak;\n\n\t\t/* Read the data bus. */\n\t\tif (data)\n\t\t\t*data++ = *sc->sci_data;\n\t\telse\n\t\t\t(void) *sc->sci_data;\n\n\t\t/* Tell target we got it. */\n\t\ticmd |= SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\t/* Wait for target to drop REQ... */\n\t\terror = ncr5380_wait_not_req(sc);\n\n\t\t/* OK, we can drop ACK. */\n\t\ticmd &= ~SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\tif (error) {\n\t\t\tNCR_TRACE(\"pio_in: stuck REQ, resid=%d\\n\", resid);\n\t\t\tbreak;\n\t\t}\n\n\t\t--resid;\n\t}\n\n\treturn (count - resid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define ACT_CONTINUE\t0x00\t/* No flags: expect another phase */\n\nstatic int\tncr5380_status;\n\nstatic int\nncr5380_status(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tint len;\n\tu_char status;\n\tstruct sci_req *sr = sc->sc_current;\n\n\t/* acknowledge phase change */\n\t*sc->sci_tcmd = PHASE_STATUS;\n\n\tlen = ncr5380_pio_in(sc, PHASE_STATUS, 1, &status);\n\tif (len) {\n\t\tsr->sr_status = status;\n\t} else {\n\t\tprintf(\"ncr5380_status: none?\\n\");\n\t}\n\n\treturn ACT_CONTINUE;\n}"
  },
  {
    "function_name": "ncr5380_data_xfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
    "lines": "2060-2157",
    "snippet": "static int\nncr5380_data_xfer(sc, phase)\n\tstruct ncr5380_softc *sc;\n\tint phase;\n{\n\tstruct sci_req *sr = sc->sc_current;\n\tstruct scsi_xfer *xs = sr->sr_xs;\n\tint expected_phase;\n\tint len;\n\n\tif (sr->sr_flags & SR_SENSE) {\n\t\tNCR_TRACE(\"data_xfer: get sense, sr=0x%x\\n\", (long)sr);\n\t\tif (phase != PHASE_DATA_IN) {\n\t\t\tprintf(\"%s: sense phase error\\n\", sc->sc_dev.dv_xname);\n\t\t\tgoto abort;\n\t\t}\n\t\t/* acknowledge phase change */\n\t\t*sc->sci_tcmd = PHASE_DATA_IN;\n\t\tlen = ncr5380_pio_in(sc, phase, sizeof(xs->sense),\n\t\t\t\t(u_char *)&xs->sense);\n\t\treturn ACT_CONTINUE;\n\t}\n\n\t/*\n\t * When aborting a command, disallow any data phase.\n\t */\n\tif (sc->sc_state & NCR_ABORTING) {\n\t\tprintf(\"%s: aborting, but phase=%s (reset)\\n\",\n\t\t    sc->sc_dev.dv_xname, phase_names[phase & 7]);\n\t\treturn ACT_RESET_BUS;\t/* XXX */\n\t}\n\n\t/* Validate expected phase (data_in or data_out) */\n\texpected_phase = (xs->flags & SCSI_DATA_OUT) ?\n\t\tPHASE_DATA_OUT : PHASE_DATA_IN;\n\tif (phase != expected_phase) {\n\t\tprintf(\"%s: data phase error\\n\", sc->sc_dev.dv_xname);\n\t\tgoto abort;\n\t}\n\n\t/* Make sure we have some data to move. */\n\tif (sc->sc_datalen <= 0) {\n\t\t/* Device needs padding. */\n\t\tif (phase == PHASE_DATA_IN)\n\t\t\tncr5380_pio_in(sc, phase, 4096, NULL);\n\t\telse\n\t\t\tncr5380_pio_out(sc, phase, 4096, NULL);\n\t\t/* Make sure that caused a phase change. */\n\t\tif (SCI_BUS_PHASE(*sc->sci_bus_csr) == phase) {\n\t\t\t/* More than 4k is just too much! */\n\t\t\tprintf(\"%s: too much data padding\\n\",\n\t\t\t       sc->sc_dev.dv_xname);\n\t\t\tgoto abort;\n\t\t}\n\t\treturn ACT_CONTINUE;\n\t}\n\n\t/*\n\t * Attempt DMA only if dma_alloc gave us a DMA handle AND\n\t * there is enough left to transfer so DMA is worth while.\n\t */\n\tif (sr->sr_dma_hand &&\n\t\t(sc->sc_datalen >= sc->sc_min_dma_len))\n\t{\n\t\t/*\n\t\t * OK, really start DMA.  Note, the MD start function\n\t\t * is responsible for setting the TCMD register, etc.\n\t\t * (Acknowledge the phase change there, not here.)\n\t\t */\n\t\tNCR_TRACE(\"data_xfer: dma_start, dh=0x%x\\n\",\n\t\t          (long) sr->sr_dma_hand);\n\t\t(*sc->sc_dma_start)(sc);\n\t\treturn ACT_WAIT_DMA;\n\t}\n\n\t/*\n\t * Doing PIO for data transfer.  (Possibly \"Pseudo DMA\")\n\t * XXX:  Do PDMA functions need to set tcmd later?\n\t */\n\tNCR_TRACE(\"data_xfer: doing PIO, len=%d\\n\", sc->sc_datalen);\n\t/* acknowledge phase change */\n\t*sc->sci_tcmd = phase;\t/* XXX: OK for PDMA? */\n\tif (phase == PHASE_DATA_OUT) {\n\t\tlen = (*sc->sc_pio_out)(sc, phase, sc->sc_datalen, sc->sc_dataptr);\n\t} else {\n\t\tlen = (*sc->sc_pio_in) (sc, phase, sc->sc_datalen, sc->sc_dataptr);\n\t}\n\tsc->sc_dataptr += len;\n\tsc->sc_datalen -= len;\n\n\tNCR_TRACE(\"data_xfer: did PIO, resid=%d\\n\", sc->sc_datalen);\n\treturn (ACT_CONTINUE);\n\nabort:\n\tsc->sc_state |= NCR_ABORTING;\n\tncr_sched_msgout(sc, SEND_ABORT);\n\treturn (ACT_CONTINUE);\n}",
    "includes": [
      "#include <dev/ic/ncr5380var.h>",
      "#include <dev/ic/ncr5380reg.h>",
      "#include <ddb/db_output.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define ACT_WAIT_DMA\t0x10\t/* Wait for DMA to complete */",
      "#define ACT_RESET_BUS\t0x04\t/* Need bus reset (cmd timeout) */",
      "#define ACT_CONTINUE\t0x00\t/* No flags: expect another phase */"
    ],
    "globals_used": [
      "static int\tncr5380_data_xfer",
      "static char *\nphase_names[8] = {\n\t\"DATA_OUT\",\n\t\"DATA_IN\",\n\t\"COMMAND\",\n\t\"STATUS\",\n\t\"UNSPEC1\",\n\t\"UNSPEC2\",\n\t\"MSG_OUT\",\n\t\"MSG_IN\",\n};",
      "static __inline void ncr_sched_msgout"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncr_sched_msgout",
          "args": [
            "sc",
            "SEND_ABORT"
          ],
          "line": 2155
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_sched_msgout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "222-235",
          "snippet": "static __inline void\nncr_sched_msgout(sc, msg_code)\n\tstruct ncr5380_softc *sc;\n\tint msg_code;\n{\n\t/* First time, raise ATN line. */\n\tif (sc->sc_msgpriq == 0) {\n\t\tregister u_char icmd;\n\t\ticmd = *sc->sci_icmd & SCI_ICMD_RMASK;\n\t\t*sc->sci_icmd = icmd | SCI_ICMD_ATN;\n\t\tdelay(2);\n\t}\n\tsc->sc_msgpriq |= msg_code;\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline void ncr_sched_msgout"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic __inline void ncr_sched_msgout;\n\nstatic __inline void\nncr_sched_msgout(sc, msg_code)\n\tstruct ncr5380_softc *sc;\n\tint msg_code;\n{\n\t/* First time, raise ATN line. */\n\tif (sc->sc_msgpriq == 0) {\n\t\tregister u_char icmd;\n\t\ticmd = *sc->sci_icmd & SCI_ICMD_RMASK;\n\t\t*sc->sci_icmd = icmd | SCI_ICMD_ATN;\n\t\tdelay(2);\n\t}\n\tsc->sc_msgpriq |= msg_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"data_xfer: did PIO, resid=%d\\n\"",
            "sc->sc_datalen"
          ],
          "line": 2150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "phase",
            "sc->sc_datalen",
            "sc->sc_dataptr"
          ],
          "line": 2145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "phase",
            "sc->sc_datalen",
            "sc->sc_dataptr"
          ],
          "line": 2143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"data_xfer: doing PIO, len=%d\\n\"",
            "sc->sc_datalen"
          ],
          "line": 2139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc"
          ],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"data_xfer: dma_start, dh=0x%x\\n\"",
            "(long) sr->sr_dma_hand"
          ],
          "line": 2129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: too much data padding\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 2110
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCI_BUS_PHASE",
          "args": [
            "*sc->sci_bus_csr"
          ],
          "line": 2108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr5380_pio_out",
          "args": [
            "sc",
            "phase",
            "4096",
            "NULL"
          ],
          "line": 2106
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_pio_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "238-296",
          "snippet": "int\nncr5380_pio_out(sc, phase, count, data)\n\tstruct ncr5380_softc *sc;\n\tint phase, count;\n\tunsigned char\t\t*data;\n{\n\tregister u_char \ticmd;\n\tregister int\t\tresid;\n\tregister int\t\terror;\n\n\ticmd = *(sc->sci_icmd) & SCI_ICMD_RMASK;\n\n\ticmd |= SCI_ICMD_DATA;\n\t*sc->sci_icmd = icmd;\n\n\tresid = count;\n\twhile (resid > 0) {\n\t\tif (!SCI_BUSY(sc)) {\n\t\t\tNCR_TRACE(\"pio_out: lost BSY, resid=%d\\n\", resid);\n\t\t\tbreak;\n\t\t}\n\t\tif (ncr5380_wait_req(sc)) {\n\t\t\tNCR_TRACE(\"pio_out: no REQ, resid=%d\\n\", resid);\n\t\t\tbreak;\n\t\t}\n\t\tif (SCI_BUS_PHASE(*sc->sci_bus_csr) != phase)\n\t\t\tbreak;\n\n\t\t/* Put the data on the bus. */\n\t\tif (data)\n\t\t\t*sc->sci_odata = *data++;\n\t\telse\n\t\t\t*sc->sci_odata = 0;\n\n\t\t/* Tell the target it's there. */\n\t\ticmd |= SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\t/* Wait for target to get it. */\n\t\terror = ncr5380_wait_not_req(sc);\n\n\t\t/* OK, it's got it (or we gave up waiting). */\n\t\ticmd &= ~SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\tif (error) {\n\t\t\tNCR_TRACE(\"pio_out: stuck REQ, resid=%d\\n\", resid);\n\t\t\tbreak;\n\t\t}\n\n\t\t--resid;\n\t}\n\n\t/* Stop driving the data bus. */\n\ticmd &= ~SCI_ICMD_DATA;\n\t*sc->sci_icmd = icmd;\n\n\treturn (count - resid);\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline int ncr5380_wait_req",
            "static __inline int ncr5380_wait_not_req"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic __inline int ncr5380_wait_req;\nstatic __inline int ncr5380_wait_not_req;\n\nint\nncr5380_pio_out(sc, phase, count, data)\n\tstruct ncr5380_softc *sc;\n\tint phase, count;\n\tunsigned char\t\t*data;\n{\n\tregister u_char \ticmd;\n\tregister int\t\tresid;\n\tregister int\t\terror;\n\n\ticmd = *(sc->sci_icmd) & SCI_ICMD_RMASK;\n\n\ticmd |= SCI_ICMD_DATA;\n\t*sc->sci_icmd = icmd;\n\n\tresid = count;\n\twhile (resid > 0) {\n\t\tif (!SCI_BUSY(sc)) {\n\t\t\tNCR_TRACE(\"pio_out: lost BSY, resid=%d\\n\", resid);\n\t\t\tbreak;\n\t\t}\n\t\tif (ncr5380_wait_req(sc)) {\n\t\t\tNCR_TRACE(\"pio_out: no REQ, resid=%d\\n\", resid);\n\t\t\tbreak;\n\t\t}\n\t\tif (SCI_BUS_PHASE(*sc->sci_bus_csr) != phase)\n\t\t\tbreak;\n\n\t\t/* Put the data on the bus. */\n\t\tif (data)\n\t\t\t*sc->sci_odata = *data++;\n\t\telse\n\t\t\t*sc->sci_odata = 0;\n\n\t\t/* Tell the target it's there. */\n\t\ticmd |= SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\t/* Wait for target to get it. */\n\t\terror = ncr5380_wait_not_req(sc);\n\n\t\t/* OK, it's got it (or we gave up waiting). */\n\t\ticmd &= ~SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\tif (error) {\n\t\t\tNCR_TRACE(\"pio_out: stuck REQ, resid=%d\\n\", resid);\n\t\t\tbreak;\n\t\t}\n\n\t\t--resid;\n\t}\n\n\t/* Stop driving the data bus. */\n\ticmd &= ~SCI_ICMD_DATA;\n\t*sc->sci_icmd = icmd;\n\n\treturn (count - resid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr5380_pio_in",
          "args": [
            "sc",
            "phase",
            "4096",
            "NULL"
          ],
          "line": 2104
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_pio_in",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "299-351",
          "snippet": "int\nncr5380_pio_in(sc, phase, count, data)\n\tstruct ncr5380_softc *sc;\n\tint phase, count;\n\tunsigned char\t\t\t*data;\n{\n\tregister u_char \ticmd;\n\tregister int\t\tresid;\n\tregister int\t\terror;\n\n\ticmd = *(sc->sci_icmd) & SCI_ICMD_RMASK;\n\n\tresid = count;\n\twhile (resid > 0) {\n\t\tif (!SCI_BUSY(sc)) {\n\t\t\tNCR_TRACE(\"pio_in: lost BSY, resid=%d\\n\", resid);\n\t\t\tbreak;\n\t\t}\n\t\tif (ncr5380_wait_req(sc)) {\n\t\t\tNCR_TRACE(\"pio_in: no REQ, resid=%d\\n\", resid);\n\t\t\tbreak;\n\t\t}\n\t\t/* A phase change is not valid until AFTER REQ rises! */\n\t\tif (SCI_BUS_PHASE(*sc->sci_bus_csr) != phase)\n\t\t\tbreak;\n\n\t\t/* Read the data bus. */\n\t\tif (data)\n\t\t\t*data++ = *sc->sci_data;\n\t\telse\n\t\t\t(void) *sc->sci_data;\n\n\t\t/* Tell target we got it. */\n\t\ticmd |= SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\t/* Wait for target to drop REQ... */\n\t\terror = ncr5380_wait_not_req(sc);\n\n\t\t/* OK, we can drop ACK. */\n\t\ticmd &= ~SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\tif (error) {\n\t\t\tNCR_TRACE(\"pio_in: stuck REQ, resid=%d\\n\", resid);\n\t\t\tbreak;\n\t\t}\n\n\t\t--resid;\n\t}\n\n\treturn (count - resid);\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline int ncr5380_wait_req",
            "static __inline int ncr5380_wait_not_req"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic __inline int ncr5380_wait_req;\nstatic __inline int ncr5380_wait_not_req;\n\nint\nncr5380_pio_in(sc, phase, count, data)\n\tstruct ncr5380_softc *sc;\n\tint phase, count;\n\tunsigned char\t\t\t*data;\n{\n\tregister u_char \ticmd;\n\tregister int\t\tresid;\n\tregister int\t\terror;\n\n\ticmd = *(sc->sci_icmd) & SCI_ICMD_RMASK;\n\n\tresid = count;\n\twhile (resid > 0) {\n\t\tif (!SCI_BUSY(sc)) {\n\t\t\tNCR_TRACE(\"pio_in: lost BSY, resid=%d\\n\", resid);\n\t\t\tbreak;\n\t\t}\n\t\tif (ncr5380_wait_req(sc)) {\n\t\t\tNCR_TRACE(\"pio_in: no REQ, resid=%d\\n\", resid);\n\t\t\tbreak;\n\t\t}\n\t\t/* A phase change is not valid until AFTER REQ rises! */\n\t\tif (SCI_BUS_PHASE(*sc->sci_bus_csr) != phase)\n\t\t\tbreak;\n\n\t\t/* Read the data bus. */\n\t\tif (data)\n\t\t\t*data++ = *sc->sci_data;\n\t\telse\n\t\t\t(void) *sc->sci_data;\n\n\t\t/* Tell target we got it. */\n\t\ticmd |= SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\t/* Wait for target to drop REQ... */\n\t\terror = ncr5380_wait_not_req(sc);\n\n\t\t/* OK, we can drop ACK. */\n\t\ticmd &= ~SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\tif (error) {\n\t\t\tNCR_TRACE(\"pio_in: stuck REQ, resid=%d\\n\", resid);\n\t\t\tbreak;\n\t\t}\n\n\t\t--resid;\n\t}\n\n\treturn (count - resid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"data_xfer: get sense, sr=0x%x\\n\"",
            "(long)sr"
          ],
          "line": 2071
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define ACT_WAIT_DMA\t0x10\t/* Wait for DMA to complete */\n#define ACT_RESET_BUS\t0x04\t/* Need bus reset (cmd timeout) */\n#define ACT_CONTINUE\t0x00\t/* No flags: expect another phase */\n\nstatic int\tncr5380_data_xfer;\nstatic char *\nphase_names[8] = {\n\t\"DATA_OUT\",\n\t\"DATA_IN\",\n\t\"COMMAND\",\n\t\"STATUS\",\n\t\"UNSPEC1\",\n\t\"UNSPEC2\",\n\t\"MSG_OUT\",\n\t\"MSG_IN\",\n};\nstatic __inline void ncr_sched_msgout;\n\nstatic int\nncr5380_data_xfer(sc, phase)\n\tstruct ncr5380_softc *sc;\n\tint phase;\n{\n\tstruct sci_req *sr = sc->sc_current;\n\tstruct scsi_xfer *xs = sr->sr_xs;\n\tint expected_phase;\n\tint len;\n\n\tif (sr->sr_flags & SR_SENSE) {\n\t\tNCR_TRACE(\"data_xfer: get sense, sr=0x%x\\n\", (long)sr);\n\t\tif (phase != PHASE_DATA_IN) {\n\t\t\tprintf(\"%s: sense phase error\\n\", sc->sc_dev.dv_xname);\n\t\t\tgoto abort;\n\t\t}\n\t\t/* acknowledge phase change */\n\t\t*sc->sci_tcmd = PHASE_DATA_IN;\n\t\tlen = ncr5380_pio_in(sc, phase, sizeof(xs->sense),\n\t\t\t\t(u_char *)&xs->sense);\n\t\treturn ACT_CONTINUE;\n\t}\n\n\t/*\n\t * When aborting a command, disallow any data phase.\n\t */\n\tif (sc->sc_state & NCR_ABORTING) {\n\t\tprintf(\"%s: aborting, but phase=%s (reset)\\n\",\n\t\t    sc->sc_dev.dv_xname, phase_names[phase & 7]);\n\t\treturn ACT_RESET_BUS;\t/* XXX */\n\t}\n\n\t/* Validate expected phase (data_in or data_out) */\n\texpected_phase = (xs->flags & SCSI_DATA_OUT) ?\n\t\tPHASE_DATA_OUT : PHASE_DATA_IN;\n\tif (phase != expected_phase) {\n\t\tprintf(\"%s: data phase error\\n\", sc->sc_dev.dv_xname);\n\t\tgoto abort;\n\t}\n\n\t/* Make sure we have some data to move. */\n\tif (sc->sc_datalen <= 0) {\n\t\t/* Device needs padding. */\n\t\tif (phase == PHASE_DATA_IN)\n\t\t\tncr5380_pio_in(sc, phase, 4096, NULL);\n\t\telse\n\t\t\tncr5380_pio_out(sc, phase, 4096, NULL);\n\t\t/* Make sure that caused a phase change. */\n\t\tif (SCI_BUS_PHASE(*sc->sci_bus_csr) == phase) {\n\t\t\t/* More than 4k is just too much! */\n\t\t\tprintf(\"%s: too much data padding\\n\",\n\t\t\t       sc->sc_dev.dv_xname);\n\t\t\tgoto abort;\n\t\t}\n\t\treturn ACT_CONTINUE;\n\t}\n\n\t/*\n\t * Attempt DMA only if dma_alloc gave us a DMA handle AND\n\t * there is enough left to transfer so DMA is worth while.\n\t */\n\tif (sr->sr_dma_hand &&\n\t\t(sc->sc_datalen >= sc->sc_min_dma_len))\n\t{\n\t\t/*\n\t\t * OK, really start DMA.  Note, the MD start function\n\t\t * is responsible for setting the TCMD register, etc.\n\t\t * (Acknowledge the phase change there, not here.)\n\t\t */\n\t\tNCR_TRACE(\"data_xfer: dma_start, dh=0x%x\\n\",\n\t\t          (long) sr->sr_dma_hand);\n\t\t(*sc->sc_dma_start)(sc);\n\t\treturn ACT_WAIT_DMA;\n\t}\n\n\t/*\n\t * Doing PIO for data transfer.  (Possibly \"Pseudo DMA\")\n\t * XXX:  Do PDMA functions need to set tcmd later?\n\t */\n\tNCR_TRACE(\"data_xfer: doing PIO, len=%d\\n\", sc->sc_datalen);\n\t/* acknowledge phase change */\n\t*sc->sci_tcmd = phase;\t/* XXX: OK for PDMA? */\n\tif (phase == PHASE_DATA_OUT) {\n\t\tlen = (*sc->sc_pio_out)(sc, phase, sc->sc_datalen, sc->sc_dataptr);\n\t} else {\n\t\tlen = (*sc->sc_pio_in) (sc, phase, sc->sc_datalen, sc->sc_dataptr);\n\t}\n\tsc->sc_dataptr += len;\n\tsc->sc_datalen -= len;\n\n\tNCR_TRACE(\"data_xfer: did PIO, resid=%d\\n\", sc->sc_datalen);\n\treturn (ACT_CONTINUE);\n\nabort:\n\tsc->sc_state |= NCR_ABORTING;\n\tncr_sched_msgout(sc, SEND_ABORT);\n\treturn (ACT_CONTINUE);\n}"
  },
  {
    "function_name": "ncr5380_command",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
    "lines": "2010-2054",
    "snippet": "static int\nncr5380_command(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tstruct sci_req *sr = sc->sc_current;\n\tstruct scsi_xfer *xs = sr->sr_xs;\n\tstruct scsi_sense rqs;\n\tint len;\n\n\t/* acknowledge phase change */\n\t*sc->sci_tcmd = PHASE_COMMAND;\n\n\tif (sr->sr_flags & SR_SENSE) {\n\t\trqs.opcode = REQUEST_SENSE;\n\t\trqs.byte2 = xs->sc_link->lun << 5;\n\t\trqs.length = sizeof(xs->sense);\n\n\t\trqs.unused[0] = rqs.unused[1] = rqs.control = 0;\n\t\tlen = ncr5380_pio_out(sc, PHASE_COMMAND, sizeof(rqs),\n\t\t\t(u_char *)&rqs);\n\t}\n\telse {\n\t\t/* Assume command can be sent in one go. */\n\t\t/* XXX: Do this using DMA, and get a phase change intr? */\n\t\tlen = ncr5380_pio_out(sc, PHASE_COMMAND, xs->cmdlen,\n\t\t\t(u_char *)xs->cmd);\n\t}\n\n\tif (len != xs->cmdlen) {\n#ifdef\tNCR5380_DEBUG\n\t\tprintf(\"ncr5380_command: short transfer: wanted %d got %d.\\n\",\n\t\t    xs->cmdlen, len);\n\t\tncr5380_show_scsi_cmd(xs);\n\t\tNCR_BREAK();\n#endif\n\t\tif (len < 6) {\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\tsc->sc_state |= NCR_ABORTING;\n\t\t\tncr_sched_msgout(sc, SEND_ABORT);\n\t\t}\n\n\t}\n\n\treturn ACT_CONTINUE;\n}",
    "includes": [
      "#include <dev/ic/ncr5380var.h>",
      "#include <dev/ic/ncr5380reg.h>",
      "#include <ddb/db_output.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define ACT_CONTINUE\t0x00\t/* No flags: expect another phase */"
    ],
    "globals_used": [
      "static int\tncr5380_command",
      "static __inline void ncr_sched_msgout"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncr_sched_msgout",
          "args": [
            "sc",
            "SEND_ABORT"
          ],
          "line": 2048
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_sched_msgout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "222-235",
          "snippet": "static __inline void\nncr_sched_msgout(sc, msg_code)\n\tstruct ncr5380_softc *sc;\n\tint msg_code;\n{\n\t/* First time, raise ATN line. */\n\tif (sc->sc_msgpriq == 0) {\n\t\tregister u_char icmd;\n\t\ticmd = *sc->sci_icmd & SCI_ICMD_RMASK;\n\t\t*sc->sci_icmd = icmd | SCI_ICMD_ATN;\n\t\tdelay(2);\n\t}\n\tsc->sc_msgpriq |= msg_code;\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline void ncr_sched_msgout"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic __inline void ncr_sched_msgout;\n\nstatic __inline void\nncr_sched_msgout(sc, msg_code)\n\tstruct ncr5380_softc *sc;\n\tint msg_code;\n{\n\t/* First time, raise ATN line. */\n\tif (sc->sc_msgpriq == 0) {\n\t\tregister u_char icmd;\n\t\ticmd = *sc->sci_icmd & SCI_ICMD_RMASK;\n\t\t*sc->sci_icmd = icmd | SCI_ICMD_ATN;\n\t\tdelay(2);\n\t}\n\tsc->sc_msgpriq |= msg_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCR_BREAK",
          "args": [],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr5380_show_scsi_cmd",
          "args": [
            "xs"
          ],
          "line": 2042
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_show_scsi_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "2438-2459",
          "snippet": "static void\nncr5380_show_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tu_char\t*b = (u_char *) xs->cmd;\n\tint\ti  = 0;\n\n\tif ( ! ( xs->flags & SCSI_RESET ) ) {\n\t\tprintf(\"si(%d:%d:%d)-\",\n\t\t    xs->sc_link->scsibus, xs->sc_link->target,\n\t\t    xs->sc_link->lun);\n\t\twhile (i < xs->cmdlen) {\n\t\t\tif (i) printf(\",\");\n\t\t\tprintf(\"%x\",b[i++]);\n\t\t}\n\t\tprintf(\"-\\n\");\n\t} else {\n\t\tprintf(\"si(%d:%d:%d)-RESET-\\n\",\n\t\t    xs->sc_link->scsibus, xs->sc_link->target,\n\t\t    xs->sc_link->lun);\n\t}\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void\nncr5380_show_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tu_char\t*b = (u_char *) xs->cmd;\n\tint\ti  = 0;\n\n\tif ( ! ( xs->flags & SCSI_RESET ) ) {\n\t\tprintf(\"si(%d:%d:%d)-\",\n\t\t    xs->sc_link->scsibus, xs->sc_link->target,\n\t\t    xs->sc_link->lun);\n\t\twhile (i < xs->cmdlen) {\n\t\t\tif (i) printf(\",\");\n\t\t\tprintf(\"%x\",b[i++]);\n\t\t}\n\t\tprintf(\"-\\n\");\n\t} else {\n\t\tprintf(\"si(%d:%d:%d)-RESET-\\n\",\n\t\t    xs->sc_link->scsibus, xs->sc_link->target,\n\t\t    xs->sc_link->lun);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ncr5380_command: short transfer: wanted %d got %d.\\n\"",
            "xs->cmdlen",
            "len"
          ],
          "line": 2040
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr5380_pio_out",
          "args": [
            "sc",
            "PHASE_COMMAND",
            "xs->cmdlen",
            "(u_char *)xs->cmd"
          ],
          "line": 2034
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_pio_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "238-296",
          "snippet": "int\nncr5380_pio_out(sc, phase, count, data)\n\tstruct ncr5380_softc *sc;\n\tint phase, count;\n\tunsigned char\t\t*data;\n{\n\tregister u_char \ticmd;\n\tregister int\t\tresid;\n\tregister int\t\terror;\n\n\ticmd = *(sc->sci_icmd) & SCI_ICMD_RMASK;\n\n\ticmd |= SCI_ICMD_DATA;\n\t*sc->sci_icmd = icmd;\n\n\tresid = count;\n\twhile (resid > 0) {\n\t\tif (!SCI_BUSY(sc)) {\n\t\t\tNCR_TRACE(\"pio_out: lost BSY, resid=%d\\n\", resid);\n\t\t\tbreak;\n\t\t}\n\t\tif (ncr5380_wait_req(sc)) {\n\t\t\tNCR_TRACE(\"pio_out: no REQ, resid=%d\\n\", resid);\n\t\t\tbreak;\n\t\t}\n\t\tif (SCI_BUS_PHASE(*sc->sci_bus_csr) != phase)\n\t\t\tbreak;\n\n\t\t/* Put the data on the bus. */\n\t\tif (data)\n\t\t\t*sc->sci_odata = *data++;\n\t\telse\n\t\t\t*sc->sci_odata = 0;\n\n\t\t/* Tell the target it's there. */\n\t\ticmd |= SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\t/* Wait for target to get it. */\n\t\terror = ncr5380_wait_not_req(sc);\n\n\t\t/* OK, it's got it (or we gave up waiting). */\n\t\ticmd &= ~SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\tif (error) {\n\t\t\tNCR_TRACE(\"pio_out: stuck REQ, resid=%d\\n\", resid);\n\t\t\tbreak;\n\t\t}\n\n\t\t--resid;\n\t}\n\n\t/* Stop driving the data bus. */\n\ticmd &= ~SCI_ICMD_DATA;\n\t*sc->sci_icmd = icmd;\n\n\treturn (count - resid);\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline int ncr5380_wait_req",
            "static __inline int ncr5380_wait_not_req"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic __inline int ncr5380_wait_req;\nstatic __inline int ncr5380_wait_not_req;\n\nint\nncr5380_pio_out(sc, phase, count, data)\n\tstruct ncr5380_softc *sc;\n\tint phase, count;\n\tunsigned char\t\t*data;\n{\n\tregister u_char \ticmd;\n\tregister int\t\tresid;\n\tregister int\t\terror;\n\n\ticmd = *(sc->sci_icmd) & SCI_ICMD_RMASK;\n\n\ticmd |= SCI_ICMD_DATA;\n\t*sc->sci_icmd = icmd;\n\n\tresid = count;\n\twhile (resid > 0) {\n\t\tif (!SCI_BUSY(sc)) {\n\t\t\tNCR_TRACE(\"pio_out: lost BSY, resid=%d\\n\", resid);\n\t\t\tbreak;\n\t\t}\n\t\tif (ncr5380_wait_req(sc)) {\n\t\t\tNCR_TRACE(\"pio_out: no REQ, resid=%d\\n\", resid);\n\t\t\tbreak;\n\t\t}\n\t\tif (SCI_BUS_PHASE(*sc->sci_bus_csr) != phase)\n\t\t\tbreak;\n\n\t\t/* Put the data on the bus. */\n\t\tif (data)\n\t\t\t*sc->sci_odata = *data++;\n\t\telse\n\t\t\t*sc->sci_odata = 0;\n\n\t\t/* Tell the target it's there. */\n\t\ticmd |= SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\t/* Wait for target to get it. */\n\t\terror = ncr5380_wait_not_req(sc);\n\n\t\t/* OK, it's got it (or we gave up waiting). */\n\t\ticmd &= ~SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\tif (error) {\n\t\t\tNCR_TRACE(\"pio_out: stuck REQ, resid=%d\\n\", resid);\n\t\t\tbreak;\n\t\t}\n\n\t\t--resid;\n\t}\n\n\t/* Stop driving the data bus. */\n\ticmd &= ~SCI_ICMD_DATA;\n\t*sc->sci_icmd = icmd;\n\n\treturn (count - resid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define ACT_CONTINUE\t0x00\t/* No flags: expect another phase */\n\nstatic int\tncr5380_command;\nstatic __inline void ncr_sched_msgout;\n\nstatic int\nncr5380_command(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tstruct sci_req *sr = sc->sc_current;\n\tstruct scsi_xfer *xs = sr->sr_xs;\n\tstruct scsi_sense rqs;\n\tint len;\n\n\t/* acknowledge phase change */\n\t*sc->sci_tcmd = PHASE_COMMAND;\n\n\tif (sr->sr_flags & SR_SENSE) {\n\t\trqs.opcode = REQUEST_SENSE;\n\t\trqs.byte2 = xs->sc_link->lun << 5;\n\t\trqs.length = sizeof(xs->sense);\n\n\t\trqs.unused[0] = rqs.unused[1] = rqs.control = 0;\n\t\tlen = ncr5380_pio_out(sc, PHASE_COMMAND, sizeof(rqs),\n\t\t\t(u_char *)&rqs);\n\t}\n\telse {\n\t\t/* Assume command can be sent in one go. */\n\t\t/* XXX: Do this using DMA, and get a phase change intr? */\n\t\tlen = ncr5380_pio_out(sc, PHASE_COMMAND, xs->cmdlen,\n\t\t\t(u_char *)xs->cmd);\n\t}\n\n\tif (len != xs->cmdlen) {\n#ifdef\tNCR5380_DEBUG\n\t\tprintf(\"ncr5380_command: short transfer: wanted %d got %d.\\n\",\n\t\t    xs->cmdlen, len);\n\t\tncr5380_show_scsi_cmd(xs);\n\t\tNCR_BREAK();\n#endif\n\t\tif (len < 6) {\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\tsc->sc_state |= NCR_ABORTING;\n\t\t\tncr_sched_msgout(sc, SEND_ABORT);\n\t\t}\n\n\t}\n\n\treturn ACT_CONTINUE;\n}"
  },
  {
    "function_name": "ncr5380_msg_out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
    "lines": "1789-2004",
    "snippet": "static int\nncr5380_msg_out(sc)\n\tregister struct ncr5380_softc *sc;\n{\n\tstruct sci_req *sr = sc->sc_current;\n\tint act_flags, n, phase, progress;\n\tregister u_char icmd, msg;\n\n\t/* acknowledge phase change */\n\t*sc->sci_tcmd = PHASE_MSG_OUT;\n\n\tprogress = 0;\t/* did we send any messages? */\n\tact_flags = ACT_CONTINUE;\n\n\t/*\n\t * Set ATN.  If we're just sending a trivial 1-byte message,\n\t * we'll clear ATN later on anyway.  Also drive the data bus.\n\t */\n\ticmd = *sc->sci_icmd & SCI_ICMD_RMASK;\n\ticmd |= (SCI_ICMD_ATN | SCI_ICMD_DATA);\n\t*sc->sci_icmd = icmd;\n\n\tif (sc->sc_prevphase == PHASE_MSG_OUT) {\n\t\tif (sc->sc_omp == sc->sc_omess) {\n\t\t\t/*\n\t\t\t * This is a retransmission.\n\t\t\t *\n\t\t\t * We get here if the target stayed in MESSAGE OUT\n\t\t\t * phase.  Section 5.1.9.2 of the SCSI 2 spec indicates\n\t\t\t * that all of the previously transmitted messages must\n\t\t\t * be sent again, in the same order.  Therefore, we\n\t\t\t * requeue all the previously transmitted messages, and\n\t\t\t * start again from the top.  Our simple priority\n\t\t\t * scheme keeps the messages in the right order.\n\t\t\t */\n\t\t\tsc->sc_msgpriq |= sc->sc_msgoutq;\n\t\t\tNCR_TRACE(\"msg_out: retrans priq=0x%x\\n\", sc->sc_msgpriq);\n\t\t} else {\n\t\t\t/* This is a continuation of the previous message. */\n\t\t\tn = sc->sc_omp - sc->sc_omess;\n\t\t\tNCR_TRACE(\"msg_out: continuation, n=%d\\n\", n);\n\t\t\tgoto nextbyte;\n\t\t}\n\t}\n\n\t/* No messages transmitted so far. */\n\tsc->sc_msgoutq = 0;\n\nnextmsg:\n\t/* Pick up highest priority message. */\n\tsc->sc_msgout = sc->sc_msgpriq & -sc->sc_msgpriq;\n\tsc->sc_msgpriq &= ~sc->sc_msgout;\n\tsc->sc_msgoutq |= sc->sc_msgout;\n\n\t/* Build the outgoing message data. */\n\tswitch (sc->sc_msgout) {\n\tcase SEND_IDENTIFY:\n\t\tNCR_TRACE(\"msg_out: SEND_IDENTIFY\\n\", 0);\n\t\tif (sr == NULL) {\n\t\t\tprintf(\"%s: SEND_IDENTIFY while not connected; sending NOOP\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tNCR_BREAK();\n\t\t\tgoto noop;\n\t\t}\n\t\t/*\n\t\t * The identify message we send determines whether \n\t\t * disconnect/reselect is allowed for this command.\n\t\t * 0xC0+LUN: allows it, 0x80+LUN disallows it.\n\t\t */\n\t\tmsg = 0xc0;\t/* MSG_IDENTIFY(0,1) */\n\t\tif (sc->sc_no_disconnect & (1 << sr->sr_target))\n\t\t\tmsg = 0x80;\n\t\tif (sr->sr_flags & (SR_IMMED | SR_SENSE))\n\t\t\tmsg = 0x80;\n\t\tsc->sc_omess[0] = msg | sr->sr_lun;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_DEV_RESET:\n\t\tNCR_TRACE(\"msg_out: SEND_DEV_RESET\\n\", 0);\n\t\t/* Expect disconnect after this! */\n\t\t/* XXX: Kill jobs for this target? */\n\t\tact_flags |= (ACT_DISCONNECT | ACT_CMD_DONE);\n\t\tsc->sc_omess[0] = MSG_BUS_DEV_RESET;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_REJECT:\n\t\tNCR_TRACE(\"msg_out: SEND_REJECT\\n\", 0);\n\t\tsc->sc_omess[0] = MSG_MESSAGE_REJECT;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_PARITY_ERROR:\n\t\tNCR_TRACE(\"msg_out: SEND_PARITY_ERROR\\n\", 0);\n\t\tsc->sc_omess[0] = MSG_PARITY_ERROR;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_INIT_DET_ERR:\n\t\tNCR_TRACE(\"msg_out: SEND_INIT_DET_ERR\\n\", 0);\n\t\tsc->sc_omess[0] = MSG_INITIATOR_DET_ERR;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_ABORT:\n\t\tNCR_TRACE(\"msg_out: SEND_ABORT\\n\", 0);\n\t\t/* Expect disconnect after this! */\n\t\t/* XXX: Set error flag? */\n\t\tact_flags |= (ACT_DISCONNECT | ACT_CMD_DONE);\n\t\tsc->sc_omess[0] = MSG_ABORT;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase 0:\n\t\tprintf(\"%s: unexpected MESSAGE OUT; sending NOOP\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tNCR_BREAK();\n\tnoop:\n\t\tNCR_TRACE(\"msg_out: send NOOP\\n\", 0);\n\t\tsc->sc_omess[0] = MSG_NOOP;\n\t\tn = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"%s: weird MESSAGE OUT; sending NOOP\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tNCR_BREAK();\n\t\tgoto noop;\n\t}\n\tsc->sc_omp = &sc->sc_omess[n];\n\nnextbyte:\n\t/* Send message bytes. */\n\twhile (n > 0) {\n\t\t/*\n\t\t * Send a message byte.\n\t\t * First check BSY, REQ, phase...\n\t\t */\n\t\tif (!SCI_BUSY(sc)) {\n\t\t\tNCR_TRACE(\"msg_out: lost BSY, n=%d\\n\", n);\n\t\t\tgoto out;\n\t\t}\n\t\tif (ncr5380_wait_req(sc)) {\n\t\t\tNCR_TRACE(\"msg_out: no REQ, n=%d\\n\", n);\n\t\t\tgoto out;\n\t\t}\n\t\tphase = SCI_BUS_PHASE(*sc->sci_bus_csr);\n\t\tif (phase != PHASE_MSG_OUT) {\n\t\t\t/*\n\t\t\t * Target left MESSAGE OUT, possibly to reject\n\t\t\t * our message.\n\t\t\t */\n\t\t\tNCR_TRACE(\"msg_out: new phase=%d\\n\", phase);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Yes, we can send this message byte. */\n\t\t--n;\n\n\t\t/* Clear ATN before last byte if this is the last message. */\n\t\tif (n == 0 && sc->sc_msgpriq == 0) {\n\t\t\ticmd &= ~SCI_ICMD_ATN;\n\t\t\t*sc->sci_icmd = icmd;\n\t\t\t/* 2 deskew delays */\n\t\t\tdelay(2);\t/* XXX */\n\t\t}\n\n\t\t/* Put data on the bus. */\n\t\t*sc->sci_odata = *--sc->sc_omp;\n\n\t\t/* Raise ACK to tell target data is on the bus. */\n\t\ticmd |= SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\t/* Wait for REQ to be negated. */\n\t\tif (ncr5380_wait_not_req(sc)) {\n\t\t\tNCR_TRACE(\"msg_out: stuck REQ, n=%d\\n\", n);\n\t\t\tact_flags |= ACT_RESET_BUS;\n\t\t}\n\n\t\t/* Finally, drop ACK. */\n\t\ticmd &= ~SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\t/* Stuck bus or something... */\n\t\tif (act_flags & ACT_RESET_BUS)\n\t\t\tgoto out;\n\n\t}\n\tprogress++;\n\n\t/* We get here only if the entire message has been transmitted. */\n\tif (sc->sc_msgpriq != 0) {\n\t\t/* There are more outgoing messages. */\n\t\tgoto nextmsg;\n\t}\n\n\t/*\n\t * The last message has been transmitted.  We need to remember the last\n\t * message transmitted (in case the target switches to MESSAGE IN phase\n\t * and sends a MESSAGE REJECT), and the list of messages transmitted\n\t * this time around (in case the target stays in MESSAGE OUT phase to\n\t * request a retransmit).\n\t */\n\nout:\n\t/* Stop driving the data bus. */\n\ticmd &= ~SCI_ICMD_DATA;\n\t*sc->sci_icmd = icmd;\n\n\tif (!progress)\n\t\tact_flags |= ACT_RESET_BUS;\n\n\treturn (act_flags);\n}",
    "includes": [
      "#include <dev/ic/ncr5380var.h>",
      "#include <dev/ic/ncr5380reg.h>",
      "#include <ddb/db_output.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define ACT_RESET_BUS\t0x04\t/* Need bus reset (cmd timeout) */",
      "#define ACT_CMD_DONE\t0x02\t/* Need to call scsi_done() */",
      "#define ACT_DISCONNECT\t0x01\t/* Target is disconnecting */",
      "#define ACT_CONTINUE\t0x00\t/* No flags: expect another phase */"
    ],
    "globals_used": [
      "static int\tncr5380_msg_out",
      "static __inline int ncr5380_wait_req",
      "static __inline int ncr5380_wait_not_req"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"msg_out: stuck REQ, n=%d\\n\"",
            "n"
          ],
          "line": 1966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr5380_wait_not_req",
          "args": [
            "sc"
          ],
          "line": 1965
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_wait_not_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "205-219",
          "snippet": "static __inline int ncr5380_wait_not_req(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tregister int timo = ncr5380_wait_nrq_timo;\n\tfor (;;) {\n\t\tif ((*sc->sci_bus_csr & SCI_BUS_REQ) == 0) {\n\t\t\ttimo = 0;\t/* return 0 */\n\t\t\tbreak;\n\t\t}\n\t\tif (--timo < 0)\n\t\t\tbreak;\t/* return -1 */\n\t\tdelay(2);\n\t}\n\treturn (timo);\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncr5380_wait_nrq_timo = 1000 * 25;",
            "static __inline int ncr5380_wait_not_req"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint ncr5380_wait_nrq_timo = 1000 * 25;\nstatic __inline int ncr5380_wait_not_req;\n\nstatic __inline int ncr5380_wait_not_req(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tregister int timo = ncr5380_wait_nrq_timo;\n\tfor (;;) {\n\t\tif ((*sc->sci_bus_csr & SCI_BUS_REQ) == 0) {\n\t\t\ttimo = 0;\t/* return 0 */\n\t\t\tbreak;\n\t\t}\n\t\tif (--timo < 0)\n\t\t\tbreak;\t/* return -1 */\n\t\tdelay(2);\n\t}\n\treturn (timo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "2"
          ],
          "line": 1954
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"msg_out: new phase=%d\\n\"",
            "phase"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCI_BUS_PHASE",
          "args": [
            "*sc->sci_bus_csr"
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"msg_out: no REQ, n=%d\\n\"",
            "n"
          ],
          "line": 1933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr5380_wait_req",
          "args": [
            "sc"
          ],
          "line": 1932
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_wait_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "188-202",
          "snippet": "static __inline int ncr5380_wait_req(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tregister int timo = ncr5380_wait_req_timo;\n\tfor (;;) {\n\t\tif (*sc->sci_bus_csr & SCI_BUS_REQ) {\n\t\t\ttimo = 0;\t/* return 0 */\n\t\t\tbreak;\n\t\t}\n\t\tif (--timo < 0)\n\t\t\tbreak;\t/* return -1 */\n\t\tdelay(2);\n\t}\n\treturn (timo);\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncr5380_wait_req_timo = 1000 * 50;",
            "static __inline int ncr5380_wait_req"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint ncr5380_wait_req_timo = 1000 * 50;\nstatic __inline int ncr5380_wait_req;\n\nstatic __inline int ncr5380_wait_req(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tregister int timo = ncr5380_wait_req_timo;\n\tfor (;;) {\n\t\tif (*sc->sci_bus_csr & SCI_BUS_REQ) {\n\t\t\ttimo = 0;\t/* return 0 */\n\t\t\tbreak;\n\t\t}\n\t\tif (--timo < 0)\n\t\t\tbreak;\t/* return -1 */\n\t\tdelay(2);\n\t}\n\treturn (timo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"msg_out: lost BSY, n=%d\\n\"",
            "n"
          ],
          "line": 1929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCI_BUSY",
          "args": [
            "sc"
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_BREAK",
          "args": [],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: weird MESSAGE OUT; sending NOOP\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1914
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"msg_out: send NOOP\\n\"",
            "0"
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_BREAK",
          "args": [],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"msg_out: SEND_ABORT\\n\"",
            "0"
          ],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"msg_out: SEND_INIT_DET_ERR\\n\"",
            "0"
          ],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"msg_out: SEND_PARITY_ERROR\\n\"",
            "0"
          ],
          "line": 1883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"msg_out: SEND_REJECT\\n\"",
            "0"
          ],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"msg_out: SEND_DEV_RESET\\n\"",
            "0"
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_BREAK",
          "args": [],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"msg_out: SEND_IDENTIFY\\n\"",
            "0"
          ],
          "line": 1846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"msg_out: continuation, n=%d\\n\"",
            "n"
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"msg_out: retrans priq=0x%x\\n\"",
            "sc->sc_msgpriq"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define ACT_RESET_BUS\t0x04\t/* Need bus reset (cmd timeout) */\n#define ACT_CMD_DONE\t0x02\t/* Need to call scsi_done() */\n#define ACT_DISCONNECT\t0x01\t/* Target is disconnecting */\n#define ACT_CONTINUE\t0x00\t/* No flags: expect another phase */\n\nstatic int\tncr5380_msg_out;\nstatic __inline int ncr5380_wait_req;\nstatic __inline int ncr5380_wait_not_req;\n\nstatic int\nncr5380_msg_out(sc)\n\tregister struct ncr5380_softc *sc;\n{\n\tstruct sci_req *sr = sc->sc_current;\n\tint act_flags, n, phase, progress;\n\tregister u_char icmd, msg;\n\n\t/* acknowledge phase change */\n\t*sc->sci_tcmd = PHASE_MSG_OUT;\n\n\tprogress = 0;\t/* did we send any messages? */\n\tact_flags = ACT_CONTINUE;\n\n\t/*\n\t * Set ATN.  If we're just sending a trivial 1-byte message,\n\t * we'll clear ATN later on anyway.  Also drive the data bus.\n\t */\n\ticmd = *sc->sci_icmd & SCI_ICMD_RMASK;\n\ticmd |= (SCI_ICMD_ATN | SCI_ICMD_DATA);\n\t*sc->sci_icmd = icmd;\n\n\tif (sc->sc_prevphase == PHASE_MSG_OUT) {\n\t\tif (sc->sc_omp == sc->sc_omess) {\n\t\t\t/*\n\t\t\t * This is a retransmission.\n\t\t\t *\n\t\t\t * We get here if the target stayed in MESSAGE OUT\n\t\t\t * phase.  Section 5.1.9.2 of the SCSI 2 spec indicates\n\t\t\t * that all of the previously transmitted messages must\n\t\t\t * be sent again, in the same order.  Therefore, we\n\t\t\t * requeue all the previously transmitted messages, and\n\t\t\t * start again from the top.  Our simple priority\n\t\t\t * scheme keeps the messages in the right order.\n\t\t\t */\n\t\t\tsc->sc_msgpriq |= sc->sc_msgoutq;\n\t\t\tNCR_TRACE(\"msg_out: retrans priq=0x%x\\n\", sc->sc_msgpriq);\n\t\t} else {\n\t\t\t/* This is a continuation of the previous message. */\n\t\t\tn = sc->sc_omp - sc->sc_omess;\n\t\t\tNCR_TRACE(\"msg_out: continuation, n=%d\\n\", n);\n\t\t\tgoto nextbyte;\n\t\t}\n\t}\n\n\t/* No messages transmitted so far. */\n\tsc->sc_msgoutq = 0;\n\nnextmsg:\n\t/* Pick up highest priority message. */\n\tsc->sc_msgout = sc->sc_msgpriq & -sc->sc_msgpriq;\n\tsc->sc_msgpriq &= ~sc->sc_msgout;\n\tsc->sc_msgoutq |= sc->sc_msgout;\n\n\t/* Build the outgoing message data. */\n\tswitch (sc->sc_msgout) {\n\tcase SEND_IDENTIFY:\n\t\tNCR_TRACE(\"msg_out: SEND_IDENTIFY\\n\", 0);\n\t\tif (sr == NULL) {\n\t\t\tprintf(\"%s: SEND_IDENTIFY while not connected; sending NOOP\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tNCR_BREAK();\n\t\t\tgoto noop;\n\t\t}\n\t\t/*\n\t\t * The identify message we send determines whether \n\t\t * disconnect/reselect is allowed for this command.\n\t\t * 0xC0+LUN: allows it, 0x80+LUN disallows it.\n\t\t */\n\t\tmsg = 0xc0;\t/* MSG_IDENTIFY(0,1) */\n\t\tif (sc->sc_no_disconnect & (1 << sr->sr_target))\n\t\t\tmsg = 0x80;\n\t\tif (sr->sr_flags & (SR_IMMED | SR_SENSE))\n\t\t\tmsg = 0x80;\n\t\tsc->sc_omess[0] = msg | sr->sr_lun;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_DEV_RESET:\n\t\tNCR_TRACE(\"msg_out: SEND_DEV_RESET\\n\", 0);\n\t\t/* Expect disconnect after this! */\n\t\t/* XXX: Kill jobs for this target? */\n\t\tact_flags |= (ACT_DISCONNECT | ACT_CMD_DONE);\n\t\tsc->sc_omess[0] = MSG_BUS_DEV_RESET;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_REJECT:\n\t\tNCR_TRACE(\"msg_out: SEND_REJECT\\n\", 0);\n\t\tsc->sc_omess[0] = MSG_MESSAGE_REJECT;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_PARITY_ERROR:\n\t\tNCR_TRACE(\"msg_out: SEND_PARITY_ERROR\\n\", 0);\n\t\tsc->sc_omess[0] = MSG_PARITY_ERROR;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_INIT_DET_ERR:\n\t\tNCR_TRACE(\"msg_out: SEND_INIT_DET_ERR\\n\", 0);\n\t\tsc->sc_omess[0] = MSG_INITIATOR_DET_ERR;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_ABORT:\n\t\tNCR_TRACE(\"msg_out: SEND_ABORT\\n\", 0);\n\t\t/* Expect disconnect after this! */\n\t\t/* XXX: Set error flag? */\n\t\tact_flags |= (ACT_DISCONNECT | ACT_CMD_DONE);\n\t\tsc->sc_omess[0] = MSG_ABORT;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase 0:\n\t\tprintf(\"%s: unexpected MESSAGE OUT; sending NOOP\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tNCR_BREAK();\n\tnoop:\n\t\tNCR_TRACE(\"msg_out: send NOOP\\n\", 0);\n\t\tsc->sc_omess[0] = MSG_NOOP;\n\t\tn = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"%s: weird MESSAGE OUT; sending NOOP\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tNCR_BREAK();\n\t\tgoto noop;\n\t}\n\tsc->sc_omp = &sc->sc_omess[n];\n\nnextbyte:\n\t/* Send message bytes. */\n\twhile (n > 0) {\n\t\t/*\n\t\t * Send a message byte.\n\t\t * First check BSY, REQ, phase...\n\t\t */\n\t\tif (!SCI_BUSY(sc)) {\n\t\t\tNCR_TRACE(\"msg_out: lost BSY, n=%d\\n\", n);\n\t\t\tgoto out;\n\t\t}\n\t\tif (ncr5380_wait_req(sc)) {\n\t\t\tNCR_TRACE(\"msg_out: no REQ, n=%d\\n\", n);\n\t\t\tgoto out;\n\t\t}\n\t\tphase = SCI_BUS_PHASE(*sc->sci_bus_csr);\n\t\tif (phase != PHASE_MSG_OUT) {\n\t\t\t/*\n\t\t\t * Target left MESSAGE OUT, possibly to reject\n\t\t\t * our message.\n\t\t\t */\n\t\t\tNCR_TRACE(\"msg_out: new phase=%d\\n\", phase);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Yes, we can send this message byte. */\n\t\t--n;\n\n\t\t/* Clear ATN before last byte if this is the last message. */\n\t\tif (n == 0 && sc->sc_msgpriq == 0) {\n\t\t\ticmd &= ~SCI_ICMD_ATN;\n\t\t\t*sc->sci_icmd = icmd;\n\t\t\t/* 2 deskew delays */\n\t\t\tdelay(2);\t/* XXX */\n\t\t}\n\n\t\t/* Put data on the bus. */\n\t\t*sc->sci_odata = *--sc->sc_omp;\n\n\t\t/* Raise ACK to tell target data is on the bus. */\n\t\ticmd |= SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\t/* Wait for REQ to be negated. */\n\t\tif (ncr5380_wait_not_req(sc)) {\n\t\t\tNCR_TRACE(\"msg_out: stuck REQ, n=%d\\n\", n);\n\t\t\tact_flags |= ACT_RESET_BUS;\n\t\t}\n\n\t\t/* Finally, drop ACK. */\n\t\ticmd &= ~SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\t/* Stuck bus or something... */\n\t\tif (act_flags & ACT_RESET_BUS)\n\t\t\tgoto out;\n\n\t}\n\tprogress++;\n\n\t/* We get here only if the entire message has been transmitted. */\n\tif (sc->sc_msgpriq != 0) {\n\t\t/* There are more outgoing messages. */\n\t\tgoto nextmsg;\n\t}\n\n\t/*\n\t * The last message has been transmitted.  We need to remember the last\n\t * message transmitted (in case the target switches to MESSAGE IN phase\n\t * and sends a MESSAGE REJECT), and the list of messages transmitted\n\t * this time around (in case the target stays in MESSAGE OUT phase to\n\t * request a retransmit).\n\t */\n\nout:\n\t/* Stop driving the data bus. */\n\ticmd &= ~SCI_ICMD_DATA;\n\t*sc->sci_icmd = icmd;\n\n\tif (!progress)\n\t\tact_flags |= ACT_RESET_BUS;\n\n\treturn (act_flags);\n}"
  },
  {
    "function_name": "ncr5380_msg_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
    "lines": "1552-1767",
    "snippet": "static int\nncr5380_msg_in(sc)\n\tregister struct ncr5380_softc *sc;\n{\n\tstruct sci_req *sr = sc->sc_current;\n\tstruct scsi_xfer *xs = sr->sr_xs;\n\tint n, phase;\n\tint act_flags;\n\tregister u_char icmd;\n\n\t/* acknowledge phase change */\n\t*sc->sci_tcmd = PHASE_MSG_IN;\n\n\tact_flags = ACT_CONTINUE;\n\ticmd = *sc->sci_icmd & SCI_ICMD_RMASK;\n\n\tif (sc->sc_prevphase == PHASE_MSG_IN) {\n\t\t/* This is a continuation of the previous message. */\n\t\tn = sc->sc_imp - sc->sc_imess;\n\t\tNCR_TRACE(\"msg_in: continuation, n=%d\\n\", n);\n\t\tgoto nextbyte;\n\t}\n\n\t/* This is a new MESSAGE IN phase.  Clean up our state. */\n\tsc->sc_state &= ~NCR_DROP_MSGIN;\n\nnextmsg:\n\tn = 0;\n\tsc->sc_imp = &sc->sc_imess[n];\n\nnextbyte:\n\t/*\n\t * Read a whole message, but don't ack the last byte.  If we reject the\n\t * message, we have to assert ATN during the message transfer phase\n\t * itself.\n\t */\n\tfor (;;) {\n\t\t/*\n\t\t * Read a message byte.\n\t\t * First, check BSY, REQ, phase...\n\t\t */\n\t\tif (!SCI_BUSY(sc)) {\n\t\t\tNCR_TRACE(\"msg_in: lost BSY, n=%d\\n\", n);\n\t\t\t/* XXX - Assume the command completed? */\n\t\t\tact_flags |= (ACT_DISCONNECT | ACT_CMD_DONE);\n\t\t\treturn (act_flags);\n\t\t}\n\t\tif (ncr5380_wait_req(sc)) {\n\t\t\tNCR_TRACE(\"msg_in: BSY but no REQ, n=%d\\n\", n);\n\t\t\t/* Just let ncr5380_machine() handle it... */\n\t\t\treturn (act_flags);\n\t\t}\n\t\tphase = SCI_BUS_PHASE(*sc->sci_bus_csr);\n\t\tif (phase != PHASE_MSG_IN) {\n\t\t\t/*\n\t\t\t * Target left MESSAGE IN, probably because it\n\t\t\t * a) noticed our ATN signal, or\n\t\t\t * b) ran out of messages.\n\t\t\t */\n\t\t\treturn (act_flags);\n\t\t}\n\t\t/* Still in MESSAGE IN phase, and REQ is asserted. */\n\t\tif (*sc->sci_csr & SCI_CSR_PERR) {\n\t\t\tncr_sched_msgout(sc, SEND_PARITY_ERROR);\n\t\t\tsc->sc_state |= NCR_DROP_MSGIN;\n\t\t}\n\n\t\t/* Gather incoming message bytes if needed. */\n\t\tif ((sc->sc_state & NCR_DROP_MSGIN) == 0) {\n\t\t\tif (n >= NCR_MAX_MSG_LEN) {\n\t\t\t\tncr_sched_msgout(sc, SEND_REJECT);\n\t\t\t\tsc->sc_state |= NCR_DROP_MSGIN;\n\t\t\t} else {\n\t\t\t\t*sc->sc_imp++ = *sc->sci_data;\n\t\t\t\tn++;\n\t\t\t\t/*\n\t\t\t\t * This testing is suboptimal, but most\n\t\t\t\t * messages will be of the one byte variety, so\n\t\t\t\t * it should not affect performance\n\t\t\t\t * significantly.\n\t\t\t\t */\n\t\t\t\tif (n == 1 && IS1BYTEMSG(sc->sc_imess[0]))\n\t\t\t\t\tgoto have_msg;\n\t\t\t\tif (n == 2 && IS2BYTEMSG(sc->sc_imess[0]))\n\t\t\t\t\tgoto have_msg;\n\t\t\t\tif (n >= 3 && ISEXTMSG(sc->sc_imess[0]) &&\n\t\t\t\t\tn == sc->sc_imess[1] + 2)\n\t\t\t\t\tgoto have_msg;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we reach this spot we're either:\n\t\t * a) in the middle of a multi-byte message, or\n\t\t * b) dropping bytes.\n\t\t */\n\n\t\t/* Ack the last byte read. */\n\t\ticmd |= SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\tif (ncr5380_wait_not_req(sc)) {\n\t\t\tNCR_TRACE(\"msg_in: drop, stuck REQ, n=%d\\n\", n);\n\t\t\tact_flags |= ACT_RESET_BUS;\n\t\t}\n\n\t\ticmd &= ~SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\tif (act_flags != ACT_CONTINUE)\n\t\t\treturn (act_flags);\n\n\t\t/* back to nextbyte */\n\t}\n\nhave_msg:\n\t/* We now have a complete message.  Parse it. */\n\n\tswitch (sc->sc_imess[0]) {\n\tcase MSG_CMDCOMPLETE:\n\t\tNCR_TRACE(\"msg_in: CMDCOMPLETE\\n\", 0);\n\t\t/* Target is about to disconnect. */\n\t\tact_flags |= (ACT_DISCONNECT | ACT_CMD_DONE);\n\t\tbreak;\n\n\tcase MSG_PARITY_ERROR:\n\t\tNCR_TRACE(\"msg_in: PARITY_ERROR\\n\", 0);\n\t\t/* Resend the last message. */\n\t\tncr_sched_msgout(sc, sc->sc_msgout);\n\t\tbreak;\n\n\tcase MSG_MESSAGE_REJECT:\n\t\t/* The target rejects the last message we sent. */\n\t\tNCR_TRACE(\"msg_in: got reject for 0x%x\\n\", sc->sc_msgout);\n\t\tswitch (sc->sc_msgout) {\n\t\tcase SEND_IDENTIFY:\n\t\t\t/* Really old target controller? */\n\t\t\t/* XXX ... */\n\t\t\tbreak;\n\t\tcase SEND_INIT_DET_ERR:\n\t\t\tgoto abort;\n\t\t}\n\t\tbreak;\n\n\tcase MSG_NOOP:\n\t\tNCR_TRACE(\"msg_in: NOOP\\n\", 0);\n\t\tbreak;\n\n\tcase MSG_DISCONNECT:\n\t\tNCR_TRACE(\"msg_in: DISCONNECT\\n\", 0);\n\t\t/* Target is about to disconnect. */\n\t\tact_flags |= ACT_DISCONNECT;\n\t\tif ((xs->sc_link->quirks & SDEV_AUTOSAVE) == 0)\n\t\t\tbreak;\n\t\t/*FALLTHROUGH*/\n\n\tcase MSG_SAVEDATAPOINTER:\n\t\tNCR_TRACE(\"msg_in: SAVE_PTRS\\n\", 0);\n\t\tsr->sr_dataptr = sc->sc_dataptr;\n\t\tsr->sr_datalen = sc->sc_datalen;\n\t\tbreak;\n\n\tcase MSG_RESTOREPOINTERS:\n\t\tNCR_TRACE(\"msg_in: RESTORE_PTRS\\n\", 0);\n\t\tsc->sc_dataptr = sr->sr_dataptr;\n\t\tsc->sc_datalen = sr->sr_datalen;\n\t\tbreak;\n\n\tcase MSG_EXTENDED:\n\t\tswitch (sc->sc_imess[2]) {\n\t\tcase MSG_EXT_SDTR:\n\t\tcase MSG_EXT_WDTR:\n\t\t\t/* The ncr5380 can not do synchronous mode. */\n\t\t\tgoto reject;\n\t\tdefault:\n\t\t\tprintf(\"%s: unrecognized MESSAGE EXTENDED; sending REJECT\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tNCR_BREAK();\n\t\t\tgoto reject;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tNCR_TRACE(\"msg_in: eh? imsg=0x%x\\n\", sc->sc_imess[0]);\n\t\tprintf(\"%s: unrecognized MESSAGE; sending REJECT\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tNCR_BREAK();\n\t\t/* fallthrough */\n\treject:\n\t\tncr_sched_msgout(sc, SEND_REJECT);\n\t\tbreak;\n\n\tabort:\n\t\tsc->sc_state |= NCR_ABORTING;\n\t\tncr_sched_msgout(sc, SEND_ABORT);\n\t\tbreak;\n\t}\n\n\t/* Ack the last byte read. */\n\ticmd |= SCI_ICMD_ACK;\n\t*sc->sci_icmd = icmd;\n\n\tif (ncr5380_wait_not_req(sc)) {\n\t\tNCR_TRACE(\"msg_in: last, stuck REQ, n=%d\\n\", n);\n\t\tact_flags |= ACT_RESET_BUS;\n\t}\n\n\ticmd &= ~SCI_ICMD_ACK;\n\t*sc->sci_icmd = icmd;\n\n\t/* Go get the next message, if any. */\n\tif (act_flags == ACT_CONTINUE)\n\t\tgoto nextmsg;\n\n\treturn (act_flags);\n}",
    "includes": [
      "#include <dev/ic/ncr5380var.h>",
      "#include <dev/ic/ncr5380reg.h>",
      "#include <ddb/db_output.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define ACT_RESET_BUS\t0x04\t/* Need bus reset (cmd timeout) */",
      "#define ACT_CMD_DONE\t0x02\t/* Need to call scsi_done() */",
      "#define ACT_DISCONNECT\t0x01\t/* Target is disconnecting */",
      "#define ACT_CONTINUE\t0x00\t/* No flags: expect another phase */"
    ],
    "globals_used": [
      "static int\tncr5380_msg_in",
      "static void\tncr5380_machine",
      "static __inline int ncr5380_wait_req",
      "static __inline int ncr5380_wait_not_req",
      "static __inline void ncr_sched_msgout"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"msg_in: last, stuck REQ, n=%d\\n\"",
            "n"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr5380_wait_not_req",
          "args": [
            "sc"
          ],
          "line": 1754
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_wait_not_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "205-219",
          "snippet": "static __inline int ncr5380_wait_not_req(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tregister int timo = ncr5380_wait_nrq_timo;\n\tfor (;;) {\n\t\tif ((*sc->sci_bus_csr & SCI_BUS_REQ) == 0) {\n\t\t\ttimo = 0;\t/* return 0 */\n\t\t\tbreak;\n\t\t}\n\t\tif (--timo < 0)\n\t\t\tbreak;\t/* return -1 */\n\t\tdelay(2);\n\t}\n\treturn (timo);\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncr5380_wait_nrq_timo = 1000 * 25;",
            "static __inline int ncr5380_wait_not_req"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint ncr5380_wait_nrq_timo = 1000 * 25;\nstatic __inline int ncr5380_wait_not_req;\n\nstatic __inline int ncr5380_wait_not_req(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tregister int timo = ncr5380_wait_nrq_timo;\n\tfor (;;) {\n\t\tif ((*sc->sci_bus_csr & SCI_BUS_REQ) == 0) {\n\t\t\ttimo = 0;\t/* return 0 */\n\t\t\tbreak;\n\t\t}\n\t\tif (--timo < 0)\n\t\t\tbreak;\t/* return -1 */\n\t\tdelay(2);\n\t}\n\treturn (timo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr_sched_msgout",
          "args": [
            "sc",
            "SEND_ABORT"
          ],
          "line": 1746
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_sched_msgout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "222-235",
          "snippet": "static __inline void\nncr_sched_msgout(sc, msg_code)\n\tstruct ncr5380_softc *sc;\n\tint msg_code;\n{\n\t/* First time, raise ATN line. */\n\tif (sc->sc_msgpriq == 0) {\n\t\tregister u_char icmd;\n\t\ticmd = *sc->sci_icmd & SCI_ICMD_RMASK;\n\t\t*sc->sci_icmd = icmd | SCI_ICMD_ATN;\n\t\tdelay(2);\n\t}\n\tsc->sc_msgpriq |= msg_code;\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline void ncr_sched_msgout"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic __inline void ncr_sched_msgout;\n\nstatic __inline void\nncr_sched_msgout(sc, msg_code)\n\tstruct ncr5380_softc *sc;\n\tint msg_code;\n{\n\t/* First time, raise ATN line. */\n\tif (sc->sc_msgpriq == 0) {\n\t\tregister u_char icmd;\n\t\ticmd = *sc->sci_icmd & SCI_ICMD_RMASK;\n\t\t*sc->sci_icmd = icmd | SCI_ICMD_ATN;\n\t\tdelay(2);\n\t}\n\tsc->sc_msgpriq |= msg_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCR_BREAK",
          "args": [],
          "line": 1738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: unrecognized MESSAGE; sending REJECT\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1736
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"msg_in: eh? imsg=0x%x\\n\"",
            "sc->sc_imess[0]"
          ],
          "line": 1735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_BREAK",
          "args": [],
          "line": 1729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"msg_in: RESTORE_PTRS\\n\"",
            "0"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"msg_in: SAVE_PTRS\\n\"",
            "0"
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"msg_in: DISCONNECT\\n\"",
            "0"
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"msg_in: NOOP\\n\"",
            "0"
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"msg_in: got reject for 0x%x\\n\"",
            "sc->sc_msgout"
          ],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"msg_in: PARITY_ERROR\\n\"",
            "0"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"msg_in: CMDCOMPLETE\\n\"",
            "0"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"msg_in: drop, stuck REQ, n=%d\\n\"",
            "n"
          ],
          "line": 1654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISEXTMSG",
          "args": [
            "sc->sc_imess[0]"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS2BYTEMSG",
          "args": [
            "sc->sc_imess[0]"
          ],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS1BYTEMSG",
          "args": [
            "sc->sc_imess[0]"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCI_BUS_PHASE",
          "args": [
            "*sc->sci_bus_csr"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"msg_in: BSY but no REQ, n=%d\\n\"",
            "n"
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr5380_wait_req",
          "args": [
            "sc"
          ],
          "line": 1599
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_wait_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "188-202",
          "snippet": "static __inline int ncr5380_wait_req(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tregister int timo = ncr5380_wait_req_timo;\n\tfor (;;) {\n\t\tif (*sc->sci_bus_csr & SCI_BUS_REQ) {\n\t\t\ttimo = 0;\t/* return 0 */\n\t\t\tbreak;\n\t\t}\n\t\tif (--timo < 0)\n\t\t\tbreak;\t/* return -1 */\n\t\tdelay(2);\n\t}\n\treturn (timo);\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncr5380_wait_req_timo = 1000 * 50;",
            "static __inline int ncr5380_wait_req"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint ncr5380_wait_req_timo = 1000 * 50;\nstatic __inline int ncr5380_wait_req;\n\nstatic __inline int ncr5380_wait_req(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tregister int timo = ncr5380_wait_req_timo;\n\tfor (;;) {\n\t\tif (*sc->sci_bus_csr & SCI_BUS_REQ) {\n\t\t\ttimo = 0;\t/* return 0 */\n\t\t\tbreak;\n\t\t}\n\t\tif (--timo < 0)\n\t\t\tbreak;\t/* return -1 */\n\t\tdelay(2);\n\t}\n\treturn (timo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"msg_in: lost BSY, n=%d\\n\"",
            "n"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCI_BUSY",
          "args": [
            "sc"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"msg_in: continuation, n=%d\\n\"",
            "n"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define ACT_RESET_BUS\t0x04\t/* Need bus reset (cmd timeout) */\n#define ACT_CMD_DONE\t0x02\t/* Need to call scsi_done() */\n#define ACT_DISCONNECT\t0x01\t/* Target is disconnecting */\n#define ACT_CONTINUE\t0x00\t/* No flags: expect another phase */\n\nstatic int\tncr5380_msg_in;\nstatic void\tncr5380_machine;\nstatic __inline int ncr5380_wait_req;\nstatic __inline int ncr5380_wait_not_req;\nstatic __inline void ncr_sched_msgout;\n\nstatic int\nncr5380_msg_in(sc)\n\tregister struct ncr5380_softc *sc;\n{\n\tstruct sci_req *sr = sc->sc_current;\n\tstruct scsi_xfer *xs = sr->sr_xs;\n\tint n, phase;\n\tint act_flags;\n\tregister u_char icmd;\n\n\t/* acknowledge phase change */\n\t*sc->sci_tcmd = PHASE_MSG_IN;\n\n\tact_flags = ACT_CONTINUE;\n\ticmd = *sc->sci_icmd & SCI_ICMD_RMASK;\n\n\tif (sc->sc_prevphase == PHASE_MSG_IN) {\n\t\t/* This is a continuation of the previous message. */\n\t\tn = sc->sc_imp - sc->sc_imess;\n\t\tNCR_TRACE(\"msg_in: continuation, n=%d\\n\", n);\n\t\tgoto nextbyte;\n\t}\n\n\t/* This is a new MESSAGE IN phase.  Clean up our state. */\n\tsc->sc_state &= ~NCR_DROP_MSGIN;\n\nnextmsg:\n\tn = 0;\n\tsc->sc_imp = &sc->sc_imess[n];\n\nnextbyte:\n\t/*\n\t * Read a whole message, but don't ack the last byte.  If we reject the\n\t * message, we have to assert ATN during the message transfer phase\n\t * itself.\n\t */\n\tfor (;;) {\n\t\t/*\n\t\t * Read a message byte.\n\t\t * First, check BSY, REQ, phase...\n\t\t */\n\t\tif (!SCI_BUSY(sc)) {\n\t\t\tNCR_TRACE(\"msg_in: lost BSY, n=%d\\n\", n);\n\t\t\t/* XXX - Assume the command completed? */\n\t\t\tact_flags |= (ACT_DISCONNECT | ACT_CMD_DONE);\n\t\t\treturn (act_flags);\n\t\t}\n\t\tif (ncr5380_wait_req(sc)) {\n\t\t\tNCR_TRACE(\"msg_in: BSY but no REQ, n=%d\\n\", n);\n\t\t\t/* Just let ncr5380_machine() handle it... */\n\t\t\treturn (act_flags);\n\t\t}\n\t\tphase = SCI_BUS_PHASE(*sc->sci_bus_csr);\n\t\tif (phase != PHASE_MSG_IN) {\n\t\t\t/*\n\t\t\t * Target left MESSAGE IN, probably because it\n\t\t\t * a) noticed our ATN signal, or\n\t\t\t * b) ran out of messages.\n\t\t\t */\n\t\t\treturn (act_flags);\n\t\t}\n\t\t/* Still in MESSAGE IN phase, and REQ is asserted. */\n\t\tif (*sc->sci_csr & SCI_CSR_PERR) {\n\t\t\tncr_sched_msgout(sc, SEND_PARITY_ERROR);\n\t\t\tsc->sc_state |= NCR_DROP_MSGIN;\n\t\t}\n\n\t\t/* Gather incoming message bytes if needed. */\n\t\tif ((sc->sc_state & NCR_DROP_MSGIN) == 0) {\n\t\t\tif (n >= NCR_MAX_MSG_LEN) {\n\t\t\t\tncr_sched_msgout(sc, SEND_REJECT);\n\t\t\t\tsc->sc_state |= NCR_DROP_MSGIN;\n\t\t\t} else {\n\t\t\t\t*sc->sc_imp++ = *sc->sci_data;\n\t\t\t\tn++;\n\t\t\t\t/*\n\t\t\t\t * This testing is suboptimal, but most\n\t\t\t\t * messages will be of the one byte variety, so\n\t\t\t\t * it should not affect performance\n\t\t\t\t * significantly.\n\t\t\t\t */\n\t\t\t\tif (n == 1 && IS1BYTEMSG(sc->sc_imess[0]))\n\t\t\t\t\tgoto have_msg;\n\t\t\t\tif (n == 2 && IS2BYTEMSG(sc->sc_imess[0]))\n\t\t\t\t\tgoto have_msg;\n\t\t\t\tif (n >= 3 && ISEXTMSG(sc->sc_imess[0]) &&\n\t\t\t\t\tn == sc->sc_imess[1] + 2)\n\t\t\t\t\tgoto have_msg;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we reach this spot we're either:\n\t\t * a) in the middle of a multi-byte message, or\n\t\t * b) dropping bytes.\n\t\t */\n\n\t\t/* Ack the last byte read. */\n\t\ticmd |= SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\tif (ncr5380_wait_not_req(sc)) {\n\t\t\tNCR_TRACE(\"msg_in: drop, stuck REQ, n=%d\\n\", n);\n\t\t\tact_flags |= ACT_RESET_BUS;\n\t\t}\n\n\t\ticmd &= ~SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\tif (act_flags != ACT_CONTINUE)\n\t\t\treturn (act_flags);\n\n\t\t/* back to nextbyte */\n\t}\n\nhave_msg:\n\t/* We now have a complete message.  Parse it. */\n\n\tswitch (sc->sc_imess[0]) {\n\tcase MSG_CMDCOMPLETE:\n\t\tNCR_TRACE(\"msg_in: CMDCOMPLETE\\n\", 0);\n\t\t/* Target is about to disconnect. */\n\t\tact_flags |= (ACT_DISCONNECT | ACT_CMD_DONE);\n\t\tbreak;\n\n\tcase MSG_PARITY_ERROR:\n\t\tNCR_TRACE(\"msg_in: PARITY_ERROR\\n\", 0);\n\t\t/* Resend the last message. */\n\t\tncr_sched_msgout(sc, sc->sc_msgout);\n\t\tbreak;\n\n\tcase MSG_MESSAGE_REJECT:\n\t\t/* The target rejects the last message we sent. */\n\t\tNCR_TRACE(\"msg_in: got reject for 0x%x\\n\", sc->sc_msgout);\n\t\tswitch (sc->sc_msgout) {\n\t\tcase SEND_IDENTIFY:\n\t\t\t/* Really old target controller? */\n\t\t\t/* XXX ... */\n\t\t\tbreak;\n\t\tcase SEND_INIT_DET_ERR:\n\t\t\tgoto abort;\n\t\t}\n\t\tbreak;\n\n\tcase MSG_NOOP:\n\t\tNCR_TRACE(\"msg_in: NOOP\\n\", 0);\n\t\tbreak;\n\n\tcase MSG_DISCONNECT:\n\t\tNCR_TRACE(\"msg_in: DISCONNECT\\n\", 0);\n\t\t/* Target is about to disconnect. */\n\t\tact_flags |= ACT_DISCONNECT;\n\t\tif ((xs->sc_link->quirks & SDEV_AUTOSAVE) == 0)\n\t\t\tbreak;\n\t\t/*FALLTHROUGH*/\n\n\tcase MSG_SAVEDATAPOINTER:\n\t\tNCR_TRACE(\"msg_in: SAVE_PTRS\\n\", 0);\n\t\tsr->sr_dataptr = sc->sc_dataptr;\n\t\tsr->sr_datalen = sc->sc_datalen;\n\t\tbreak;\n\n\tcase MSG_RESTOREPOINTERS:\n\t\tNCR_TRACE(\"msg_in: RESTORE_PTRS\\n\", 0);\n\t\tsc->sc_dataptr = sr->sr_dataptr;\n\t\tsc->sc_datalen = sr->sr_datalen;\n\t\tbreak;\n\n\tcase MSG_EXTENDED:\n\t\tswitch (sc->sc_imess[2]) {\n\t\tcase MSG_EXT_SDTR:\n\t\tcase MSG_EXT_WDTR:\n\t\t\t/* The ncr5380 can not do synchronous mode. */\n\t\t\tgoto reject;\n\t\tdefault:\n\t\t\tprintf(\"%s: unrecognized MESSAGE EXTENDED; sending REJECT\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tNCR_BREAK();\n\t\t\tgoto reject;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tNCR_TRACE(\"msg_in: eh? imsg=0x%x\\n\", sc->sc_imess[0]);\n\t\tprintf(\"%s: unrecognized MESSAGE; sending REJECT\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tNCR_BREAK();\n\t\t/* fallthrough */\n\treject:\n\t\tncr_sched_msgout(sc, SEND_REJECT);\n\t\tbreak;\n\n\tabort:\n\t\tsc->sc_state |= NCR_ABORTING;\n\t\tncr_sched_msgout(sc, SEND_ABORT);\n\t\tbreak;\n\t}\n\n\t/* Ack the last byte read. */\n\ticmd |= SCI_ICMD_ACK;\n\t*sc->sci_icmd = icmd;\n\n\tif (ncr5380_wait_not_req(sc)) {\n\t\tNCR_TRACE(\"msg_in: last, stuck REQ, n=%d\\n\", n);\n\t\tact_flags |= ACT_RESET_BUS;\n\t}\n\n\ticmd &= ~SCI_ICMD_ACK;\n\t*sc->sci_icmd = icmd;\n\n\t/* Go get the next message, if any. */\n\tif (act_flags == ACT_CONTINUE)\n\t\tgoto nextmsg;\n\n\treturn (act_flags);\n}"
  },
  {
    "function_name": "ncr5380_select",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
    "lines": "1309-1506",
    "snippet": "static int\nncr5380_select(sc, sr)\n\tstruct ncr5380_softc *sc;\n\tstruct sci_req *sr;\n{\n\tint timo, s, target_mask;\n\tu_char data, icmd;\n\n\t/* Check for reselect */\n\tncr5380_reselect(sc);\n\tif (sc->sc_current) {\n\t\tNCR_TRACE(\"select: reselect, cur=0x%x\\n\",\n\t\t\t\t  (long) sc->sc_current);\n\t\treturn XS_BUSY;\t/* reselected */\n\t}\n\n\t/*\n\t * Set phase bits to 0, otherwise the 5380 won't drive the bus during\n\t * selection.\n\t */\n\t*sc->sci_tcmd = PHASE_DATA_OUT;\n\t*sc->sci_icmd = icmd = 0;\n\t*sc->sci_mode = 0;\n\n\t/*\n\t * Arbitrate for the bus.  The 5380 takes care of the\n\t * time-critical bus interactions.  We set our ID bit\n\t * in the output data register and set MODE_ARB.  The\n\t * 5380 watches for the required \"bus free\" period.\n\t * If and when the \"bus free\" period is detected, the\n\t * 5380 drives BSY, drives the data bus, and sets the\n\t * \"arbitration in progress\" (AIP) bit to let us know\n\t * arbitration has started (and that it asserts BSY).\n\t * We then wait for one arbitration delay (2.2uS) and\n\t * check the ICMD_LST bit, which will be set if some\n\t * other target drives SEL during arbitration.\n\t *\n\t * There is a time-critical section during the period\n\t * after we enter arbitration up until we assert SEL.\n\t * Avoid long interrupts during this period.\n\t */\n\ts = splimp();\t/* XXX: Begin time-critical section */\n\n\t*(sc->sci_odata) = 0x80;\t/* OUR_ID */\n\t*(sc->sci_mode) = SCI_MODE_ARB;\n\n#define\tWAIT_AIP_USEC\t20\t/* pleanty of time */\n\t/* Wait for the AIP bit to turn on. */\n\ttimo = WAIT_AIP_USEC;\n\tfor (;;) {\n\t\tif (*(sc->sci_icmd) & SCI_ICMD_AIP)\n\t\t\tbreak;\n\t\tif (timo <= 0) {\n\t\t\t/*\n\t\t\t * Did not see any \"bus free\" period.\n\t\t\t * The usual reason is a reselection,\n\t\t\t * so treat this as arbitration loss.\n\t\t\t */\n\t\t\tNCR_TRACE(\"select: bus busy, rc=%d\\n\", XS_BUSY);\n\t\t\tgoto lost_arb;\n\t\t}\n\t\ttimo -= 2;\n\t\tdelay(2);\n\t}\n\tNCR_TRACE(\"select: have AIP after %d uSec.\\n\",\n\t\t\t  WAIT_AIP_USEC - timo);\n\n\t/* Got AIP.  Wait one arbitration delay (2.2 uS.) */\n\tdelay(3);\n\n\t/* Check for ICMD_LST */\n\tif (*(sc->sci_icmd) & SCI_ICMD_LST) {\n\t\t/* Some other target asserted SEL. */\n\t\tNCR_TRACE(\"select: lost one, rc=%d\\n\", XS_BUSY);\n\t\tgoto lost_arb;\n\t}\n\n\t/*\n\t * No other device has declared itself the winner.\n\t * The spec. says to check for higher IDs, but we\n\t * are always the highest (ID=7) so don't bother.\n\t * We can now declare victory by asserting SEL.\n\t *\n\t * Note that the 5380 is asserting BSY because we\n\t * have entered arbitration mode.  We will now hold\n\t * BSY directly so we can turn off ARB mode.\n\t */\n\ticmd = (SCI_ICMD_BSY | SCI_ICMD_SEL);\n\t*sc->sci_icmd = icmd;\n\n\t/*\n\t * \"The SCSI device that wins arbitration shall wait\n\t *  at least a bus clear delay plus a bus settle delay\n\t *  after asserting the SEL signal before changing\n\t *  any [other] signal.\"  (1.2uS. total)\n\t */\n\tdelay(2);\n\n\t/*\n\t * Check one last time to see if we really did\n\t * win arbitration.  This might only happen if\n\t * there can be a higher selection ID than ours.\n\t * Keep this code for reference anyway...\n\t */\n\tif (*(sc->sci_icmd) & SCI_ICMD_LST) {\n\t\t/* Some other target asserted SEL. */\n\t\tNCR_TRACE(\"select: lost two, rc=%d\\n\", XS_BUSY);\n\n\tlost_arb:\n\t\t*sc->sci_icmd = 0;\n\t\t*sc->sci_mode = 0;\n\n\t\tsplx(s);\t/* XXX: End of time-critical section. */\n\n\t\t/*\n\t\t * When we lose arbitration, it usually means\n\t\t * there is a target trying to reselect us.\n\t\t */\n\t\tncr5380_reselect(sc);\n\t\treturn XS_BUSY;\n\t}\n\n\t/* Leave ARB mode Now that we drive BSY+SEL */\n\t*sc->sci_mode = 0;\n\t*sc->sci_sel_enb = 0;\n\n\tsplx(s);\t/* XXX: End of time-critical section. */\n\n\t/*\n\t * Arbitration is complete.  Now do selection:\n\t * Drive the data bus with the ID bits for both\n\t * the host and target.  Also set ATN now, to\n\t * ask the target for a message out phase.\n\t */\n\ttarget_mask = (1 << sr->sr_target);\n\tdata = 0x80 | target_mask;\n\t*(sc->sci_odata) = data;\n\ticmd |= (SCI_ICMD_DATA | SCI_ICMD_ATN);\n\t*(sc->sci_icmd) = icmd;\n\tdelay(2);\t/* two deskew delays. */\n\n\t/* De-assert BSY (targets sample the data now). */\n\ticmd &= ~SCI_ICMD_BSY;\n\t*(sc->sci_icmd) = icmd;\n\tdelay(3);\t/* Bus settle delay. */\n\n\t/*\n\t * Wait for the target to assert BSY.\n\t * SCSI spec. says wait for 250 mS.\n\t */\n\tfor (timo = 25000;;) {\n\t\tif (*sc->sci_bus_csr & SCI_BUS_BSY)\n\t\t\tgoto success;\n\t\tif (--timo <= 0)\n\t\t\tbreak;\n\t\tdelay(10);\n\t}\n\n\t/*\n\t * There is no reaction from the target.  Start the selection\n\t * timeout procedure. We release the databus but keep SEL+ATN\n\t * asserted. After that we wait a 'selection abort time' (200\n\t * usecs) and 2 deskew delays (90 ns) and check BSY again.\n\t * When BSY is asserted, we assume the selection succeeded,\n\t * otherwise we release the bus.\n\t */\n\ticmd &= ~SCI_ICMD_DATA;\n\t*(sc->sci_icmd) = icmd;\n\tdelay(201);\n\tif ((*sc->sci_bus_csr & SCI_BUS_BSY) == 0) {\n\t\t/* Really no device on bus */\n\t\t*sc->sci_tcmd = PHASE_INVALID;\n\t\t*sc->sci_icmd = 0;\n\t\t*sc->sci_mode = 0;\n\t\t*sc->sci_sel_enb = 0;\n\t\tSCI_CLR_INTR(sc);\n\t\t*sc->sci_sel_enb = 0x80;\n\t\tNCR_TRACE(\"select: device down, rc=%d\\n\", XS_SELTIMEOUT);\n\t\treturn XS_SELTIMEOUT;\n\t}\n\nsuccess:\n\t/*\n\t * The target is now driving BSY, so we can stop\n\t * driving SEL and the data bus (keep ATN true).\n\t * Configure the ncr5380 to monitor BSY, parity.\n\t */\n\ticmd &= ~(SCI_ICMD_DATA | SCI_ICMD_SEL);\n\t*sc->sci_icmd = icmd;\n\n\t/* If this target's bit is set, do NOT check parity. */\n\tif (sc->sc_parity_disable & target_mask)\n\t\t*sc->sci_mode = (SCI_MODE_MONBSY);\n\telse\n\t\t*sc->sci_mode = (SCI_MODE_MONBSY | SCI_MODE_PAR_CHK);\n\n\treturn XS_NOERROR;\n}",
    "includes": [
      "#include <dev/ic/ncr5380var.h>",
      "#include <dev/ic/ncr5380reg.h>",
      "#include <ddb/db_output.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\tWAIT_AIP_USEC\t20\t/* pleanty of time */"
    ],
    "globals_used": [
      "static int\tncr5380_select",
      "static void\tncr5380_reselect"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"select: device down, rc=%d\\n\"",
            "XS_SELTIMEOUT"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCI_CLR_INTR",
          "args": [
            "sc"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "201"
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr5380_reselect",
          "args": [
            "sc"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_reselect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "1075-1296",
          "snippet": "void\nncr5380_reselect(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tstruct sci_req *sr;\n\tint target, lun, phase, timo;\n\tint target_mask;\n\tu_char bus, data, icmd, msg;\n\n#ifdef\tDIAGNOSTIC\n\t/*\n\t * Note: sc_state will be \"idle\" when ncr5380_intr()\n\t * calls, or \"working\" when ncr5380_select() calls.\n\t * (So don't test that in this DIAGNOSTIC)\n\t */\n\tif (sc->sc_current)\n\t\tpanic(\"ncr5380_reselect: current set\");\n#endif\n\n\t/*\n\t * First, check the select line.\n\t * (That has to be set first.)\n\t */\n\tbus = *(sc->sci_bus_csr);\n\tif ((bus & SCI_BUS_SEL) == 0) {\n\t\t/* Not a selection or reselection. */\n\t\treturn;\n\t}\n\n\t/*\n\t * The target will assert BSY first (for bus arbitration),\n\t * then raise SEL, and finally drop BSY.  Only then is the\n\t * data bus required to have valid selection ID bits set.\n\t * Wait for: SEL==1, BSY==0 before reading the data bus.\n\t * While this theoretically can happen, we are aparently\n\t * never fast enough to get here before BSY drops.\n\t */\n\ttimo = ncr5380_wait_nrq_timo;\n\tfor (;;) {\n\t\tif ((bus & SCI_BUS_BSY) == 0)\n\t\t\tbreak;\n\t\t/* Probably never get here... */\n\t\tif (--timo <= 0) {\n\t\t\tprintf(\"%s: reselect, BSY stuck, bus=0x%x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, bus);\n\t\t\t/* Not much we can do. Reset the bus. */\n\t\t\tncr5380_reset_scsibus(sc);\n\t\t\treturn;\n\t\t}\n\t\tdelay(2);\n\t\tbus = *(sc->sci_bus_csr);\n\t\t/* If SEL went away, forget it. */\n\t\tif ((bus & SCI_BUS_SEL) == 0)\n\t\t\treturn;\n\t\t/* Still have SEL, check BSY. */\n\t}\n\tNCR_TRACE(\"reselect, valid data after %d loops\\n\",\n\t\t\t  ncr5380_wait_nrq_timo - timo);\n\n\t/*\n\t * Good.  We have SEL=1 and BSY=0.  Now wait for a\n\t * \"bus settle delay\" before we sample the data bus\n\t */\n\tdelay(2);\n\tdata = *(sc->sci_data) & 0xFF;\n\t/* Parity check is implicit in data validation below. */\n\n\t/*\n\t * Is this a reselect (I/O == 1) or have we been\n\t * selected as a target? (I/O == 0)\n\t */\n\tif ((bus & SCI_BUS_IO) == 0) {\n\t\tprintf(\"%s: selected as target, data=0x%x\\n\",\n\t\t    sc->sc_dev.dv_xname, data);\n\t\t/* Not much we can do. Reset the bus. */\n\t\t/* XXX: send some sort of message? */\n\t\tncr5380_reset_scsibus(sc);\n\t\treturn;\n\t}\n\n\t/*\n\t * OK, this is a reselection.\n\t */\n\tfor (target = 0; target < 7; target++) {\n\t\ttarget_mask = (1 << target);\n\t\tif (data & target_mask)\n\t\t\tbreak;\n\t}\n\tif ((data & 0x7F) != target_mask) {\n\t\t/* No selecting ID? or >2 IDs on bus? */\n\t\tprintf(\"%s: bad reselect, data=0x%x\\n\",\n\t\t    sc->sc_dev.dv_xname, data);\n\t\treturn;\n\t}\n\n\tNCR_TRACE(\"reselect: target=0x%x\\n\", target);\n\n\t/* Raise BSY to acknowledge target reselection. */\n\t*(sc->sci_icmd) = SCI_ICMD_BSY;\n\n\t/* Wait for target to drop SEL. */\n\ttimo = ncr5380_wait_nrq_timo;\n\tfor (;;) {\n\t\tbus = *(sc->sci_bus_csr);\n\t\tif ((bus & SCI_BUS_SEL) == 0)\n\t\t\tbreak;\t/* success */\n\t\tif (--timo <= 0) {\n\t\t\tprintf(\"%s: reselect, SEL stuck, bus=0x%x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, bus);\n\t\t\tNCR_BREAK();\n\t\t\t/* assume connected (fail later if not) */\n\t\t\tbreak;\n\t\t}\n\t\tdelay(2);\n\t}\n\n\t/* Now we drop BSY, and we are connected. */\n\t*(sc->sci_icmd) = 0;\n\t*sc->sci_sel_enb = 0;\n\tSCI_CLR_INTR(sc);\n\n\t/*\n\t * At this point the target should send an IDENTIFY message,\n\t * which will permit us to determine the reselecting LUN.\n\t * If not, we assume LUN 0.\n\t */\n\tlun = 0;\n\t/* Wait for REQ before reading bus phase. */\n\tif (ncr5380_wait_req(sc)) {\n\t\tprintf(\"%s: reselect, no REQ\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\t/* Try to send an ABORT message. */\n\t\tgoto abort;\n\t}\n\tphase = SCI_BUS_PHASE(*sc->sci_bus_csr);\n\tif (phase != PHASE_MSG_IN) {\n\t\tprintf(\"%s: reselect, phase=%d\\n\",\n\t\t    sc->sc_dev.dv_xname, phase);\n\t\tgoto abort;\n\t}\n\n\t/* Ack. the change to PHASE_MSG_IN */\n\t*(sc->sci_tcmd) = PHASE_MSG_IN;\n\n\t/* Peek at the message byte without consuming it! */\n\tmsg = *(sc->sci_data);\n\tif ((msg & 0x80) == 0) {\n\t\tprintf(\"%s: reselect, not identify, msg=%d\\n\",\n\t\t    sc->sc_dev.dv_xname, msg);\n\t\tgoto abort;\n\t}\n\tlun = msg & 7;\n\t\n\t/* We now know target/LUN.  Do we have the request? */\n\tsr = sc->sc_matrix[target][lun];\n\tif (sr) {\n\t\t/* We now have a nexus. */\n\t\tsc->sc_state |= NCR_WORKING;\n\t\tsc->sc_current = sr;\n\t\tNCR_TRACE(\"reselect: resume sr=0x%x\\n\", (long)sr);\n\n\t\t/* Implicit restore pointers message */\n\t\tsc->sc_dataptr = sr->sr_dataptr;\n\t\tsc->sc_datalen = sr->sr_datalen;\n\n\t\tsc->sc_prevphase = PHASE_INVALID;\n\t\tsc->sc_msgpriq = 0;\n\t\tsc->sc_msgoutq = 0;\n\t\tsc->sc_msgout  = 0;\n\n\t\t/* XXX: Restore the normal mode register. */\n\t\t/* If this target's bit is set, do NOT check parity. */\n\t\tif (sc->sc_parity_disable & target_mask)\n\t\t\t*sc->sci_mode = (SCI_MODE_MONBSY);\n\t\telse\n\t\t\t*sc->sci_mode = (SCI_MODE_MONBSY | SCI_MODE_PAR_CHK);\n\n\t\t/*\n\t\t * Another hack for the Sun3 \"si\", which needs\n\t\t * some setup done to its DMA engine before the\n\t\t * target puts the SCSI bus into any DATA phase.\n\t\t */\n\t\tif (sr->sr_dma_hand && sc->sc_dma_setup) {\n\t\t\tNCR_TRACE(\"reselect: call DMA setup, dh=0x%x\\n\",\n\t\t\t\t\t  (long) sr->sr_dma_hand);\n\t\t    sc->sc_dma_setup(sc);\n\t\t}\n\n\t\t/* Now consume the IDENTIFY message. */\n\t\tncr5380_pio_in(sc, PHASE_MSG_IN, 1, &msg);\n\t\treturn;\n\t}\n\n\tprintf(\"%s: phantom reselect: target=%d, LUN=%d\\n\",\n\t    sc->sc_dev.dv_xname, target, lun);\nabort:\n\t/*\n\t * Try to send an ABORT message.  This makes us\n\t * temporarily busy, but no current command...\n\t */\n\tsc->sc_state |= NCR_ABORTING;\n\n\t/* Raise ATN, delay, raise ACK... */\n\ticmd = SCI_ICMD_ATN;\n\t*sc->sci_icmd = icmd;\n\tdelay(2);\n\n\t/* Now consume the IDENTIFY message. */\n\tncr5380_pio_in(sc, PHASE_MSG_IN, 1, &msg);\n\n\t/* Finally try to send the ABORT. */\n\tsc->sc_prevphase = PHASE_INVALID;\n\tsc->sc_msgpriq = SEND_ABORT;\n\tncr5380_msg_out(sc);\n\n\t*(sc->sci_tcmd) = PHASE_INVALID;\n\t*sc->sci_sel_enb = 0;\n\tSCI_CLR_INTR(sc);\n\t*sc->sci_sel_enb = 0x80;\n\n\tsc->sc_state &= ~NCR_ABORTING;\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tncr5380_select",
            "static void\tncr5380_reselect",
            "static int\tncr5380_msg_out",
            "int ncr5380_wait_nrq_timo = 1000 * 25;",
            "static __inline int ncr5380_wait_req"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int\tncr5380_select;\nstatic void\tncr5380_reselect;\nstatic int\tncr5380_msg_out;\nint ncr5380_wait_nrq_timo = 1000 * 25;\nstatic __inline int ncr5380_wait_req;\n\nvoid\nncr5380_reselect(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tstruct sci_req *sr;\n\tint target, lun, phase, timo;\n\tint target_mask;\n\tu_char bus, data, icmd, msg;\n\n#ifdef\tDIAGNOSTIC\n\t/*\n\t * Note: sc_state will be \"idle\" when ncr5380_intr()\n\t * calls, or \"working\" when ncr5380_select() calls.\n\t * (So don't test that in this DIAGNOSTIC)\n\t */\n\tif (sc->sc_current)\n\t\tpanic(\"ncr5380_reselect: current set\");\n#endif\n\n\t/*\n\t * First, check the select line.\n\t * (That has to be set first.)\n\t */\n\tbus = *(sc->sci_bus_csr);\n\tif ((bus & SCI_BUS_SEL) == 0) {\n\t\t/* Not a selection or reselection. */\n\t\treturn;\n\t}\n\n\t/*\n\t * The target will assert BSY first (for bus arbitration),\n\t * then raise SEL, and finally drop BSY.  Only then is the\n\t * data bus required to have valid selection ID bits set.\n\t * Wait for: SEL==1, BSY==0 before reading the data bus.\n\t * While this theoretically can happen, we are aparently\n\t * never fast enough to get here before BSY drops.\n\t */\n\ttimo = ncr5380_wait_nrq_timo;\n\tfor (;;) {\n\t\tif ((bus & SCI_BUS_BSY) == 0)\n\t\t\tbreak;\n\t\t/* Probably never get here... */\n\t\tif (--timo <= 0) {\n\t\t\tprintf(\"%s: reselect, BSY stuck, bus=0x%x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, bus);\n\t\t\t/* Not much we can do. Reset the bus. */\n\t\t\tncr5380_reset_scsibus(sc);\n\t\t\treturn;\n\t\t}\n\t\tdelay(2);\n\t\tbus = *(sc->sci_bus_csr);\n\t\t/* If SEL went away, forget it. */\n\t\tif ((bus & SCI_BUS_SEL) == 0)\n\t\t\treturn;\n\t\t/* Still have SEL, check BSY. */\n\t}\n\tNCR_TRACE(\"reselect, valid data after %d loops\\n\",\n\t\t\t  ncr5380_wait_nrq_timo - timo);\n\n\t/*\n\t * Good.  We have SEL=1 and BSY=0.  Now wait for a\n\t * \"bus settle delay\" before we sample the data bus\n\t */\n\tdelay(2);\n\tdata = *(sc->sci_data) & 0xFF;\n\t/* Parity check is implicit in data validation below. */\n\n\t/*\n\t * Is this a reselect (I/O == 1) or have we been\n\t * selected as a target? (I/O == 0)\n\t */\n\tif ((bus & SCI_BUS_IO) == 0) {\n\t\tprintf(\"%s: selected as target, data=0x%x\\n\",\n\t\t    sc->sc_dev.dv_xname, data);\n\t\t/* Not much we can do. Reset the bus. */\n\t\t/* XXX: send some sort of message? */\n\t\tncr5380_reset_scsibus(sc);\n\t\treturn;\n\t}\n\n\t/*\n\t * OK, this is a reselection.\n\t */\n\tfor (target = 0; target < 7; target++) {\n\t\ttarget_mask = (1 << target);\n\t\tif (data & target_mask)\n\t\t\tbreak;\n\t}\n\tif ((data & 0x7F) != target_mask) {\n\t\t/* No selecting ID? or >2 IDs on bus? */\n\t\tprintf(\"%s: bad reselect, data=0x%x\\n\",\n\t\t    sc->sc_dev.dv_xname, data);\n\t\treturn;\n\t}\n\n\tNCR_TRACE(\"reselect: target=0x%x\\n\", target);\n\n\t/* Raise BSY to acknowledge target reselection. */\n\t*(sc->sci_icmd) = SCI_ICMD_BSY;\n\n\t/* Wait for target to drop SEL. */\n\ttimo = ncr5380_wait_nrq_timo;\n\tfor (;;) {\n\t\tbus = *(sc->sci_bus_csr);\n\t\tif ((bus & SCI_BUS_SEL) == 0)\n\t\t\tbreak;\t/* success */\n\t\tif (--timo <= 0) {\n\t\t\tprintf(\"%s: reselect, SEL stuck, bus=0x%x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, bus);\n\t\t\tNCR_BREAK();\n\t\t\t/* assume connected (fail later if not) */\n\t\t\tbreak;\n\t\t}\n\t\tdelay(2);\n\t}\n\n\t/* Now we drop BSY, and we are connected. */\n\t*(sc->sci_icmd) = 0;\n\t*sc->sci_sel_enb = 0;\n\tSCI_CLR_INTR(sc);\n\n\t/*\n\t * At this point the target should send an IDENTIFY message,\n\t * which will permit us to determine the reselecting LUN.\n\t * If not, we assume LUN 0.\n\t */\n\tlun = 0;\n\t/* Wait for REQ before reading bus phase. */\n\tif (ncr5380_wait_req(sc)) {\n\t\tprintf(\"%s: reselect, no REQ\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\t/* Try to send an ABORT message. */\n\t\tgoto abort;\n\t}\n\tphase = SCI_BUS_PHASE(*sc->sci_bus_csr);\n\tif (phase != PHASE_MSG_IN) {\n\t\tprintf(\"%s: reselect, phase=%d\\n\",\n\t\t    sc->sc_dev.dv_xname, phase);\n\t\tgoto abort;\n\t}\n\n\t/* Ack. the change to PHASE_MSG_IN */\n\t*(sc->sci_tcmd) = PHASE_MSG_IN;\n\n\t/* Peek at the message byte without consuming it! */\n\tmsg = *(sc->sci_data);\n\tif ((msg & 0x80) == 0) {\n\t\tprintf(\"%s: reselect, not identify, msg=%d\\n\",\n\t\t    sc->sc_dev.dv_xname, msg);\n\t\tgoto abort;\n\t}\n\tlun = msg & 7;\n\t\n\t/* We now know target/LUN.  Do we have the request? */\n\tsr = sc->sc_matrix[target][lun];\n\tif (sr) {\n\t\t/* We now have a nexus. */\n\t\tsc->sc_state |= NCR_WORKING;\n\t\tsc->sc_current = sr;\n\t\tNCR_TRACE(\"reselect: resume sr=0x%x\\n\", (long)sr);\n\n\t\t/* Implicit restore pointers message */\n\t\tsc->sc_dataptr = sr->sr_dataptr;\n\t\tsc->sc_datalen = sr->sr_datalen;\n\n\t\tsc->sc_prevphase = PHASE_INVALID;\n\t\tsc->sc_msgpriq = 0;\n\t\tsc->sc_msgoutq = 0;\n\t\tsc->sc_msgout  = 0;\n\n\t\t/* XXX: Restore the normal mode register. */\n\t\t/* If this target's bit is set, do NOT check parity. */\n\t\tif (sc->sc_parity_disable & target_mask)\n\t\t\t*sc->sci_mode = (SCI_MODE_MONBSY);\n\t\telse\n\t\t\t*sc->sci_mode = (SCI_MODE_MONBSY | SCI_MODE_PAR_CHK);\n\n\t\t/*\n\t\t * Another hack for the Sun3 \"si\", which needs\n\t\t * some setup done to its DMA engine before the\n\t\t * target puts the SCSI bus into any DATA phase.\n\t\t */\n\t\tif (sr->sr_dma_hand && sc->sc_dma_setup) {\n\t\t\tNCR_TRACE(\"reselect: call DMA setup, dh=0x%x\\n\",\n\t\t\t\t\t  (long) sr->sr_dma_hand);\n\t\t    sc->sc_dma_setup(sc);\n\t\t}\n\n\t\t/* Now consume the IDENTIFY message. */\n\t\tncr5380_pio_in(sc, PHASE_MSG_IN, 1, &msg);\n\t\treturn;\n\t}\n\n\tprintf(\"%s: phantom reselect: target=%d, LUN=%d\\n\",\n\t    sc->sc_dev.dv_xname, target, lun);\nabort:\n\t/*\n\t * Try to send an ABORT message.  This makes us\n\t * temporarily busy, but no current command...\n\t */\n\tsc->sc_state |= NCR_ABORTING;\n\n\t/* Raise ATN, delay, raise ACK... */\n\ticmd = SCI_ICMD_ATN;\n\t*sc->sci_icmd = icmd;\n\tdelay(2);\n\n\t/* Now consume the IDENTIFY message. */\n\tncr5380_pio_in(sc, PHASE_MSG_IN, 1, &msg);\n\n\t/* Finally try to send the ABORT. */\n\tsc->sc_prevphase = PHASE_INVALID;\n\tsc->sc_msgpriq = SEND_ABORT;\n\tncr5380_msg_out(sc);\n\n\t*(sc->sci_tcmd) = PHASE_INVALID;\n\t*sc->sci_sel_enb = 0;\n\tSCI_CLR_INTR(sc);\n\t*sc->sci_sel_enb = 0x80;\n\n\tsc->sc_state &= ~NCR_ABORTING;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"select: lost two, rc=%d\\n\"",
            "XS_BUSY"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"select: lost one, rc=%d\\n\"",
            "XS_BUSY"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"select: have AIP after %d uSec.\\n\"",
            "WAIT_AIP_USEC - timo"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"select: bus busy, rc=%d\\n\"",
            "XS_BUSY"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splimp",
          "args": [],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"select: reselect, cur=0x%x\\n\"",
            "(long) sc->sc_current"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tWAIT_AIP_USEC\t20\t/* pleanty of time */\n\nstatic int\tncr5380_select;\nstatic void\tncr5380_reselect;\n\nstatic int\nncr5380_select(sc, sr)\n\tstruct ncr5380_softc *sc;\n\tstruct sci_req *sr;\n{\n\tint timo, s, target_mask;\n\tu_char data, icmd;\n\n\t/* Check for reselect */\n\tncr5380_reselect(sc);\n\tif (sc->sc_current) {\n\t\tNCR_TRACE(\"select: reselect, cur=0x%x\\n\",\n\t\t\t\t  (long) sc->sc_current);\n\t\treturn XS_BUSY;\t/* reselected */\n\t}\n\n\t/*\n\t * Set phase bits to 0, otherwise the 5380 won't drive the bus during\n\t * selection.\n\t */\n\t*sc->sci_tcmd = PHASE_DATA_OUT;\n\t*sc->sci_icmd = icmd = 0;\n\t*sc->sci_mode = 0;\n\n\t/*\n\t * Arbitrate for the bus.  The 5380 takes care of the\n\t * time-critical bus interactions.  We set our ID bit\n\t * in the output data register and set MODE_ARB.  The\n\t * 5380 watches for the required \"bus free\" period.\n\t * If and when the \"bus free\" period is detected, the\n\t * 5380 drives BSY, drives the data bus, and sets the\n\t * \"arbitration in progress\" (AIP) bit to let us know\n\t * arbitration has started (and that it asserts BSY).\n\t * We then wait for one arbitration delay (2.2uS) and\n\t * check the ICMD_LST bit, which will be set if some\n\t * other target drives SEL during arbitration.\n\t *\n\t * There is a time-critical section during the period\n\t * after we enter arbitration up until we assert SEL.\n\t * Avoid long interrupts during this period.\n\t */\n\ts = splimp();\t/* XXX: Begin time-critical section */\n\n\t*(sc->sci_odata) = 0x80;\t/* OUR_ID */\n\t*(sc->sci_mode) = SCI_MODE_ARB;\n\n#define\tWAIT_AIP_USEC\t20\t/* pleanty of time */\n\t/* Wait for the AIP bit to turn on. */\n\ttimo = WAIT_AIP_USEC;\n\tfor (;;) {\n\t\tif (*(sc->sci_icmd) & SCI_ICMD_AIP)\n\t\t\tbreak;\n\t\tif (timo <= 0) {\n\t\t\t/*\n\t\t\t * Did not see any \"bus free\" period.\n\t\t\t * The usual reason is a reselection,\n\t\t\t * so treat this as arbitration loss.\n\t\t\t */\n\t\t\tNCR_TRACE(\"select: bus busy, rc=%d\\n\", XS_BUSY);\n\t\t\tgoto lost_arb;\n\t\t}\n\t\ttimo -= 2;\n\t\tdelay(2);\n\t}\n\tNCR_TRACE(\"select: have AIP after %d uSec.\\n\",\n\t\t\t  WAIT_AIP_USEC - timo);\n\n\t/* Got AIP.  Wait one arbitration delay (2.2 uS.) */\n\tdelay(3);\n\n\t/* Check for ICMD_LST */\n\tif (*(sc->sci_icmd) & SCI_ICMD_LST) {\n\t\t/* Some other target asserted SEL. */\n\t\tNCR_TRACE(\"select: lost one, rc=%d\\n\", XS_BUSY);\n\t\tgoto lost_arb;\n\t}\n\n\t/*\n\t * No other device has declared itself the winner.\n\t * The spec. says to check for higher IDs, but we\n\t * are always the highest (ID=7) so don't bother.\n\t * We can now declare victory by asserting SEL.\n\t *\n\t * Note that the 5380 is asserting BSY because we\n\t * have entered arbitration mode.  We will now hold\n\t * BSY directly so we can turn off ARB mode.\n\t */\n\ticmd = (SCI_ICMD_BSY | SCI_ICMD_SEL);\n\t*sc->sci_icmd = icmd;\n\n\t/*\n\t * \"The SCSI device that wins arbitration shall wait\n\t *  at least a bus clear delay plus a bus settle delay\n\t *  after asserting the SEL signal before changing\n\t *  any [other] signal.\"  (1.2uS. total)\n\t */\n\tdelay(2);\n\n\t/*\n\t * Check one last time to see if we really did\n\t * win arbitration.  This might only happen if\n\t * there can be a higher selection ID than ours.\n\t * Keep this code for reference anyway...\n\t */\n\tif (*(sc->sci_icmd) & SCI_ICMD_LST) {\n\t\t/* Some other target asserted SEL. */\n\t\tNCR_TRACE(\"select: lost two, rc=%d\\n\", XS_BUSY);\n\n\tlost_arb:\n\t\t*sc->sci_icmd = 0;\n\t\t*sc->sci_mode = 0;\n\n\t\tsplx(s);\t/* XXX: End of time-critical section. */\n\n\t\t/*\n\t\t * When we lose arbitration, it usually means\n\t\t * there is a target trying to reselect us.\n\t\t */\n\t\tncr5380_reselect(sc);\n\t\treturn XS_BUSY;\n\t}\n\n\t/* Leave ARB mode Now that we drive BSY+SEL */\n\t*sc->sci_mode = 0;\n\t*sc->sci_sel_enb = 0;\n\n\tsplx(s);\t/* XXX: End of time-critical section. */\n\n\t/*\n\t * Arbitration is complete.  Now do selection:\n\t * Drive the data bus with the ID bits for both\n\t * the host and target.  Also set ATN now, to\n\t * ask the target for a message out phase.\n\t */\n\ttarget_mask = (1 << sr->sr_target);\n\tdata = 0x80 | target_mask;\n\t*(sc->sci_odata) = data;\n\ticmd |= (SCI_ICMD_DATA | SCI_ICMD_ATN);\n\t*(sc->sci_icmd) = icmd;\n\tdelay(2);\t/* two deskew delays. */\n\n\t/* De-assert BSY (targets sample the data now). */\n\ticmd &= ~SCI_ICMD_BSY;\n\t*(sc->sci_icmd) = icmd;\n\tdelay(3);\t/* Bus settle delay. */\n\n\t/*\n\t * Wait for the target to assert BSY.\n\t * SCSI spec. says wait for 250 mS.\n\t */\n\tfor (timo = 25000;;) {\n\t\tif (*sc->sci_bus_csr & SCI_BUS_BSY)\n\t\t\tgoto success;\n\t\tif (--timo <= 0)\n\t\t\tbreak;\n\t\tdelay(10);\n\t}\n\n\t/*\n\t * There is no reaction from the target.  Start the selection\n\t * timeout procedure. We release the databus but keep SEL+ATN\n\t * asserted. After that we wait a 'selection abort time' (200\n\t * usecs) and 2 deskew delays (90 ns) and check BSY again.\n\t * When BSY is asserted, we assume the selection succeeded,\n\t * otherwise we release the bus.\n\t */\n\ticmd &= ~SCI_ICMD_DATA;\n\t*(sc->sci_icmd) = icmd;\n\tdelay(201);\n\tif ((*sc->sci_bus_csr & SCI_BUS_BSY) == 0) {\n\t\t/* Really no device on bus */\n\t\t*sc->sci_tcmd = PHASE_INVALID;\n\t\t*sc->sci_icmd = 0;\n\t\t*sc->sci_mode = 0;\n\t\t*sc->sci_sel_enb = 0;\n\t\tSCI_CLR_INTR(sc);\n\t\t*sc->sci_sel_enb = 0x80;\n\t\tNCR_TRACE(\"select: device down, rc=%d\\n\", XS_SELTIMEOUT);\n\t\treturn XS_SELTIMEOUT;\n\t}\n\nsuccess:\n\t/*\n\t * The target is now driving BSY, so we can stop\n\t * driving SEL and the data bus (keep ATN true).\n\t * Configure the ncr5380 to monitor BSY, parity.\n\t */\n\ticmd &= ~(SCI_ICMD_DATA | SCI_ICMD_SEL);\n\t*sc->sci_icmd = icmd;\n\n\t/* If this target's bit is set, do NOT check parity. */\n\tif (sc->sc_parity_disable & target_mask)\n\t\t*sc->sci_mode = (SCI_MODE_MONBSY);\n\telse\n\t\t*sc->sci_mode = (SCI_MODE_MONBSY | SCI_MODE_PAR_CHK);\n\n\treturn XS_NOERROR;\n}"
  },
  {
    "function_name": "ncr5380_reselect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
    "lines": "1075-1296",
    "snippet": "void\nncr5380_reselect(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tstruct sci_req *sr;\n\tint target, lun, phase, timo;\n\tint target_mask;\n\tu_char bus, data, icmd, msg;\n\n#ifdef\tDIAGNOSTIC\n\t/*\n\t * Note: sc_state will be \"idle\" when ncr5380_intr()\n\t * calls, or \"working\" when ncr5380_select() calls.\n\t * (So don't test that in this DIAGNOSTIC)\n\t */\n\tif (sc->sc_current)\n\t\tpanic(\"ncr5380_reselect: current set\");\n#endif\n\n\t/*\n\t * First, check the select line.\n\t * (That has to be set first.)\n\t */\n\tbus = *(sc->sci_bus_csr);\n\tif ((bus & SCI_BUS_SEL) == 0) {\n\t\t/* Not a selection or reselection. */\n\t\treturn;\n\t}\n\n\t/*\n\t * The target will assert BSY first (for bus arbitration),\n\t * then raise SEL, and finally drop BSY.  Only then is the\n\t * data bus required to have valid selection ID bits set.\n\t * Wait for: SEL==1, BSY==0 before reading the data bus.\n\t * While this theoretically can happen, we are aparently\n\t * never fast enough to get here before BSY drops.\n\t */\n\ttimo = ncr5380_wait_nrq_timo;\n\tfor (;;) {\n\t\tif ((bus & SCI_BUS_BSY) == 0)\n\t\t\tbreak;\n\t\t/* Probably never get here... */\n\t\tif (--timo <= 0) {\n\t\t\tprintf(\"%s: reselect, BSY stuck, bus=0x%x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, bus);\n\t\t\t/* Not much we can do. Reset the bus. */\n\t\t\tncr5380_reset_scsibus(sc);\n\t\t\treturn;\n\t\t}\n\t\tdelay(2);\n\t\tbus = *(sc->sci_bus_csr);\n\t\t/* If SEL went away, forget it. */\n\t\tif ((bus & SCI_BUS_SEL) == 0)\n\t\t\treturn;\n\t\t/* Still have SEL, check BSY. */\n\t}\n\tNCR_TRACE(\"reselect, valid data after %d loops\\n\",\n\t\t\t  ncr5380_wait_nrq_timo - timo);\n\n\t/*\n\t * Good.  We have SEL=1 and BSY=0.  Now wait for a\n\t * \"bus settle delay\" before we sample the data bus\n\t */\n\tdelay(2);\n\tdata = *(sc->sci_data) & 0xFF;\n\t/* Parity check is implicit in data validation below. */\n\n\t/*\n\t * Is this a reselect (I/O == 1) or have we been\n\t * selected as a target? (I/O == 0)\n\t */\n\tif ((bus & SCI_BUS_IO) == 0) {\n\t\tprintf(\"%s: selected as target, data=0x%x\\n\",\n\t\t    sc->sc_dev.dv_xname, data);\n\t\t/* Not much we can do. Reset the bus. */\n\t\t/* XXX: send some sort of message? */\n\t\tncr5380_reset_scsibus(sc);\n\t\treturn;\n\t}\n\n\t/*\n\t * OK, this is a reselection.\n\t */\n\tfor (target = 0; target < 7; target++) {\n\t\ttarget_mask = (1 << target);\n\t\tif (data & target_mask)\n\t\t\tbreak;\n\t}\n\tif ((data & 0x7F) != target_mask) {\n\t\t/* No selecting ID? or >2 IDs on bus? */\n\t\tprintf(\"%s: bad reselect, data=0x%x\\n\",\n\t\t    sc->sc_dev.dv_xname, data);\n\t\treturn;\n\t}\n\n\tNCR_TRACE(\"reselect: target=0x%x\\n\", target);\n\n\t/* Raise BSY to acknowledge target reselection. */\n\t*(sc->sci_icmd) = SCI_ICMD_BSY;\n\n\t/* Wait for target to drop SEL. */\n\ttimo = ncr5380_wait_nrq_timo;\n\tfor (;;) {\n\t\tbus = *(sc->sci_bus_csr);\n\t\tif ((bus & SCI_BUS_SEL) == 0)\n\t\t\tbreak;\t/* success */\n\t\tif (--timo <= 0) {\n\t\t\tprintf(\"%s: reselect, SEL stuck, bus=0x%x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, bus);\n\t\t\tNCR_BREAK();\n\t\t\t/* assume connected (fail later if not) */\n\t\t\tbreak;\n\t\t}\n\t\tdelay(2);\n\t}\n\n\t/* Now we drop BSY, and we are connected. */\n\t*(sc->sci_icmd) = 0;\n\t*sc->sci_sel_enb = 0;\n\tSCI_CLR_INTR(sc);\n\n\t/*\n\t * At this point the target should send an IDENTIFY message,\n\t * which will permit us to determine the reselecting LUN.\n\t * If not, we assume LUN 0.\n\t */\n\tlun = 0;\n\t/* Wait for REQ before reading bus phase. */\n\tif (ncr5380_wait_req(sc)) {\n\t\tprintf(\"%s: reselect, no REQ\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\t/* Try to send an ABORT message. */\n\t\tgoto abort;\n\t}\n\tphase = SCI_BUS_PHASE(*sc->sci_bus_csr);\n\tif (phase != PHASE_MSG_IN) {\n\t\tprintf(\"%s: reselect, phase=%d\\n\",\n\t\t    sc->sc_dev.dv_xname, phase);\n\t\tgoto abort;\n\t}\n\n\t/* Ack. the change to PHASE_MSG_IN */\n\t*(sc->sci_tcmd) = PHASE_MSG_IN;\n\n\t/* Peek at the message byte without consuming it! */\n\tmsg = *(sc->sci_data);\n\tif ((msg & 0x80) == 0) {\n\t\tprintf(\"%s: reselect, not identify, msg=%d\\n\",\n\t\t    sc->sc_dev.dv_xname, msg);\n\t\tgoto abort;\n\t}\n\tlun = msg & 7;\n\t\n\t/* We now know target/LUN.  Do we have the request? */\n\tsr = sc->sc_matrix[target][lun];\n\tif (sr) {\n\t\t/* We now have a nexus. */\n\t\tsc->sc_state |= NCR_WORKING;\n\t\tsc->sc_current = sr;\n\t\tNCR_TRACE(\"reselect: resume sr=0x%x\\n\", (long)sr);\n\n\t\t/* Implicit restore pointers message */\n\t\tsc->sc_dataptr = sr->sr_dataptr;\n\t\tsc->sc_datalen = sr->sr_datalen;\n\n\t\tsc->sc_prevphase = PHASE_INVALID;\n\t\tsc->sc_msgpriq = 0;\n\t\tsc->sc_msgoutq = 0;\n\t\tsc->sc_msgout  = 0;\n\n\t\t/* XXX: Restore the normal mode register. */\n\t\t/* If this target's bit is set, do NOT check parity. */\n\t\tif (sc->sc_parity_disable & target_mask)\n\t\t\t*sc->sci_mode = (SCI_MODE_MONBSY);\n\t\telse\n\t\t\t*sc->sci_mode = (SCI_MODE_MONBSY | SCI_MODE_PAR_CHK);\n\n\t\t/*\n\t\t * Another hack for the Sun3 \"si\", which needs\n\t\t * some setup done to its DMA engine before the\n\t\t * target puts the SCSI bus into any DATA phase.\n\t\t */\n\t\tif (sr->sr_dma_hand && sc->sc_dma_setup) {\n\t\t\tNCR_TRACE(\"reselect: call DMA setup, dh=0x%x\\n\",\n\t\t\t\t\t  (long) sr->sr_dma_hand);\n\t\t    sc->sc_dma_setup(sc);\n\t\t}\n\n\t\t/* Now consume the IDENTIFY message. */\n\t\tncr5380_pio_in(sc, PHASE_MSG_IN, 1, &msg);\n\t\treturn;\n\t}\n\n\tprintf(\"%s: phantom reselect: target=%d, LUN=%d\\n\",\n\t    sc->sc_dev.dv_xname, target, lun);\nabort:\n\t/*\n\t * Try to send an ABORT message.  This makes us\n\t * temporarily busy, but no current command...\n\t */\n\tsc->sc_state |= NCR_ABORTING;\n\n\t/* Raise ATN, delay, raise ACK... */\n\ticmd = SCI_ICMD_ATN;\n\t*sc->sci_icmd = icmd;\n\tdelay(2);\n\n\t/* Now consume the IDENTIFY message. */\n\tncr5380_pio_in(sc, PHASE_MSG_IN, 1, &msg);\n\n\t/* Finally try to send the ABORT. */\n\tsc->sc_prevphase = PHASE_INVALID;\n\tsc->sc_msgpriq = SEND_ABORT;\n\tncr5380_msg_out(sc);\n\n\t*(sc->sci_tcmd) = PHASE_INVALID;\n\t*sc->sci_sel_enb = 0;\n\tSCI_CLR_INTR(sc);\n\t*sc->sci_sel_enb = 0x80;\n\n\tsc->sc_state &= ~NCR_ABORTING;\n}",
    "includes": [
      "#include <dev/ic/ncr5380var.h>",
      "#include <dev/ic/ncr5380reg.h>",
      "#include <ddb/db_output.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tncr5380_select",
      "static void\tncr5380_reselect",
      "static int\tncr5380_msg_out",
      "int ncr5380_wait_nrq_timo = 1000 * 25;",
      "static __inline int ncr5380_wait_req"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SCI_CLR_INTR",
          "args": [
            "sc"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr5380_msg_out",
          "args": [
            "sc"
          ],
          "line": 1288
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_msg_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "1789-2004",
          "snippet": "static int\nncr5380_msg_out(sc)\n\tregister struct ncr5380_softc *sc;\n{\n\tstruct sci_req *sr = sc->sc_current;\n\tint act_flags, n, phase, progress;\n\tregister u_char icmd, msg;\n\n\t/* acknowledge phase change */\n\t*sc->sci_tcmd = PHASE_MSG_OUT;\n\n\tprogress = 0;\t/* did we send any messages? */\n\tact_flags = ACT_CONTINUE;\n\n\t/*\n\t * Set ATN.  If we're just sending a trivial 1-byte message,\n\t * we'll clear ATN later on anyway.  Also drive the data bus.\n\t */\n\ticmd = *sc->sci_icmd & SCI_ICMD_RMASK;\n\ticmd |= (SCI_ICMD_ATN | SCI_ICMD_DATA);\n\t*sc->sci_icmd = icmd;\n\n\tif (sc->sc_prevphase == PHASE_MSG_OUT) {\n\t\tif (sc->sc_omp == sc->sc_omess) {\n\t\t\t/*\n\t\t\t * This is a retransmission.\n\t\t\t *\n\t\t\t * We get here if the target stayed in MESSAGE OUT\n\t\t\t * phase.  Section 5.1.9.2 of the SCSI 2 spec indicates\n\t\t\t * that all of the previously transmitted messages must\n\t\t\t * be sent again, in the same order.  Therefore, we\n\t\t\t * requeue all the previously transmitted messages, and\n\t\t\t * start again from the top.  Our simple priority\n\t\t\t * scheme keeps the messages in the right order.\n\t\t\t */\n\t\t\tsc->sc_msgpriq |= sc->sc_msgoutq;\n\t\t\tNCR_TRACE(\"msg_out: retrans priq=0x%x\\n\", sc->sc_msgpriq);\n\t\t} else {\n\t\t\t/* This is a continuation of the previous message. */\n\t\t\tn = sc->sc_omp - sc->sc_omess;\n\t\t\tNCR_TRACE(\"msg_out: continuation, n=%d\\n\", n);\n\t\t\tgoto nextbyte;\n\t\t}\n\t}\n\n\t/* No messages transmitted so far. */\n\tsc->sc_msgoutq = 0;\n\nnextmsg:\n\t/* Pick up highest priority message. */\n\tsc->sc_msgout = sc->sc_msgpriq & -sc->sc_msgpriq;\n\tsc->sc_msgpriq &= ~sc->sc_msgout;\n\tsc->sc_msgoutq |= sc->sc_msgout;\n\n\t/* Build the outgoing message data. */\n\tswitch (sc->sc_msgout) {\n\tcase SEND_IDENTIFY:\n\t\tNCR_TRACE(\"msg_out: SEND_IDENTIFY\\n\", 0);\n\t\tif (sr == NULL) {\n\t\t\tprintf(\"%s: SEND_IDENTIFY while not connected; sending NOOP\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tNCR_BREAK();\n\t\t\tgoto noop;\n\t\t}\n\t\t/*\n\t\t * The identify message we send determines whether \n\t\t * disconnect/reselect is allowed for this command.\n\t\t * 0xC0+LUN: allows it, 0x80+LUN disallows it.\n\t\t */\n\t\tmsg = 0xc0;\t/* MSG_IDENTIFY(0,1) */\n\t\tif (sc->sc_no_disconnect & (1 << sr->sr_target))\n\t\t\tmsg = 0x80;\n\t\tif (sr->sr_flags & (SR_IMMED | SR_SENSE))\n\t\t\tmsg = 0x80;\n\t\tsc->sc_omess[0] = msg | sr->sr_lun;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_DEV_RESET:\n\t\tNCR_TRACE(\"msg_out: SEND_DEV_RESET\\n\", 0);\n\t\t/* Expect disconnect after this! */\n\t\t/* XXX: Kill jobs for this target? */\n\t\tact_flags |= (ACT_DISCONNECT | ACT_CMD_DONE);\n\t\tsc->sc_omess[0] = MSG_BUS_DEV_RESET;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_REJECT:\n\t\tNCR_TRACE(\"msg_out: SEND_REJECT\\n\", 0);\n\t\tsc->sc_omess[0] = MSG_MESSAGE_REJECT;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_PARITY_ERROR:\n\t\tNCR_TRACE(\"msg_out: SEND_PARITY_ERROR\\n\", 0);\n\t\tsc->sc_omess[0] = MSG_PARITY_ERROR;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_INIT_DET_ERR:\n\t\tNCR_TRACE(\"msg_out: SEND_INIT_DET_ERR\\n\", 0);\n\t\tsc->sc_omess[0] = MSG_INITIATOR_DET_ERR;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_ABORT:\n\t\tNCR_TRACE(\"msg_out: SEND_ABORT\\n\", 0);\n\t\t/* Expect disconnect after this! */\n\t\t/* XXX: Set error flag? */\n\t\tact_flags |= (ACT_DISCONNECT | ACT_CMD_DONE);\n\t\tsc->sc_omess[0] = MSG_ABORT;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase 0:\n\t\tprintf(\"%s: unexpected MESSAGE OUT; sending NOOP\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tNCR_BREAK();\n\tnoop:\n\t\tNCR_TRACE(\"msg_out: send NOOP\\n\", 0);\n\t\tsc->sc_omess[0] = MSG_NOOP;\n\t\tn = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"%s: weird MESSAGE OUT; sending NOOP\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tNCR_BREAK();\n\t\tgoto noop;\n\t}\n\tsc->sc_omp = &sc->sc_omess[n];\n\nnextbyte:\n\t/* Send message bytes. */\n\twhile (n > 0) {\n\t\t/*\n\t\t * Send a message byte.\n\t\t * First check BSY, REQ, phase...\n\t\t */\n\t\tif (!SCI_BUSY(sc)) {\n\t\t\tNCR_TRACE(\"msg_out: lost BSY, n=%d\\n\", n);\n\t\t\tgoto out;\n\t\t}\n\t\tif (ncr5380_wait_req(sc)) {\n\t\t\tNCR_TRACE(\"msg_out: no REQ, n=%d\\n\", n);\n\t\t\tgoto out;\n\t\t}\n\t\tphase = SCI_BUS_PHASE(*sc->sci_bus_csr);\n\t\tif (phase != PHASE_MSG_OUT) {\n\t\t\t/*\n\t\t\t * Target left MESSAGE OUT, possibly to reject\n\t\t\t * our message.\n\t\t\t */\n\t\t\tNCR_TRACE(\"msg_out: new phase=%d\\n\", phase);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Yes, we can send this message byte. */\n\t\t--n;\n\n\t\t/* Clear ATN before last byte if this is the last message. */\n\t\tif (n == 0 && sc->sc_msgpriq == 0) {\n\t\t\ticmd &= ~SCI_ICMD_ATN;\n\t\t\t*sc->sci_icmd = icmd;\n\t\t\t/* 2 deskew delays */\n\t\t\tdelay(2);\t/* XXX */\n\t\t}\n\n\t\t/* Put data on the bus. */\n\t\t*sc->sci_odata = *--sc->sc_omp;\n\n\t\t/* Raise ACK to tell target data is on the bus. */\n\t\ticmd |= SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\t/* Wait for REQ to be negated. */\n\t\tif (ncr5380_wait_not_req(sc)) {\n\t\t\tNCR_TRACE(\"msg_out: stuck REQ, n=%d\\n\", n);\n\t\t\tact_flags |= ACT_RESET_BUS;\n\t\t}\n\n\t\t/* Finally, drop ACK. */\n\t\ticmd &= ~SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\t/* Stuck bus or something... */\n\t\tif (act_flags & ACT_RESET_BUS)\n\t\t\tgoto out;\n\n\t}\n\tprogress++;\n\n\t/* We get here only if the entire message has been transmitted. */\n\tif (sc->sc_msgpriq != 0) {\n\t\t/* There are more outgoing messages. */\n\t\tgoto nextmsg;\n\t}\n\n\t/*\n\t * The last message has been transmitted.  We need to remember the last\n\t * message transmitted (in case the target switches to MESSAGE IN phase\n\t * and sends a MESSAGE REJECT), and the list of messages transmitted\n\t * this time around (in case the target stays in MESSAGE OUT phase to\n\t * request a retransmit).\n\t */\n\nout:\n\t/* Stop driving the data bus. */\n\ticmd &= ~SCI_ICMD_DATA;\n\t*sc->sci_icmd = icmd;\n\n\tif (!progress)\n\t\tact_flags |= ACT_RESET_BUS;\n\n\treturn (act_flags);\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define ACT_RESET_BUS\t0x04\t/* Need bus reset (cmd timeout) */",
            "#define ACT_CMD_DONE\t0x02\t/* Need to call scsi_done() */",
            "#define ACT_DISCONNECT\t0x01\t/* Target is disconnecting */",
            "#define ACT_CONTINUE\t0x00\t/* No flags: expect another phase */"
          ],
          "globals_used": [
            "static int\tncr5380_msg_out",
            "static __inline int ncr5380_wait_req",
            "static __inline int ncr5380_wait_not_req"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define ACT_RESET_BUS\t0x04\t/* Need bus reset (cmd timeout) */\n#define ACT_CMD_DONE\t0x02\t/* Need to call scsi_done() */\n#define ACT_DISCONNECT\t0x01\t/* Target is disconnecting */\n#define ACT_CONTINUE\t0x00\t/* No flags: expect another phase */\n\nstatic int\tncr5380_msg_out;\nstatic __inline int ncr5380_wait_req;\nstatic __inline int ncr5380_wait_not_req;\n\nstatic int\nncr5380_msg_out(sc)\n\tregister struct ncr5380_softc *sc;\n{\n\tstruct sci_req *sr = sc->sc_current;\n\tint act_flags, n, phase, progress;\n\tregister u_char icmd, msg;\n\n\t/* acknowledge phase change */\n\t*sc->sci_tcmd = PHASE_MSG_OUT;\n\n\tprogress = 0;\t/* did we send any messages? */\n\tact_flags = ACT_CONTINUE;\n\n\t/*\n\t * Set ATN.  If we're just sending a trivial 1-byte message,\n\t * we'll clear ATN later on anyway.  Also drive the data bus.\n\t */\n\ticmd = *sc->sci_icmd & SCI_ICMD_RMASK;\n\ticmd |= (SCI_ICMD_ATN | SCI_ICMD_DATA);\n\t*sc->sci_icmd = icmd;\n\n\tif (sc->sc_prevphase == PHASE_MSG_OUT) {\n\t\tif (sc->sc_omp == sc->sc_omess) {\n\t\t\t/*\n\t\t\t * This is a retransmission.\n\t\t\t *\n\t\t\t * We get here if the target stayed in MESSAGE OUT\n\t\t\t * phase.  Section 5.1.9.2 of the SCSI 2 spec indicates\n\t\t\t * that all of the previously transmitted messages must\n\t\t\t * be sent again, in the same order.  Therefore, we\n\t\t\t * requeue all the previously transmitted messages, and\n\t\t\t * start again from the top.  Our simple priority\n\t\t\t * scheme keeps the messages in the right order.\n\t\t\t */\n\t\t\tsc->sc_msgpriq |= sc->sc_msgoutq;\n\t\t\tNCR_TRACE(\"msg_out: retrans priq=0x%x\\n\", sc->sc_msgpriq);\n\t\t} else {\n\t\t\t/* This is a continuation of the previous message. */\n\t\t\tn = sc->sc_omp - sc->sc_omess;\n\t\t\tNCR_TRACE(\"msg_out: continuation, n=%d\\n\", n);\n\t\t\tgoto nextbyte;\n\t\t}\n\t}\n\n\t/* No messages transmitted so far. */\n\tsc->sc_msgoutq = 0;\n\nnextmsg:\n\t/* Pick up highest priority message. */\n\tsc->sc_msgout = sc->sc_msgpriq & -sc->sc_msgpriq;\n\tsc->sc_msgpriq &= ~sc->sc_msgout;\n\tsc->sc_msgoutq |= sc->sc_msgout;\n\n\t/* Build the outgoing message data. */\n\tswitch (sc->sc_msgout) {\n\tcase SEND_IDENTIFY:\n\t\tNCR_TRACE(\"msg_out: SEND_IDENTIFY\\n\", 0);\n\t\tif (sr == NULL) {\n\t\t\tprintf(\"%s: SEND_IDENTIFY while not connected; sending NOOP\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tNCR_BREAK();\n\t\t\tgoto noop;\n\t\t}\n\t\t/*\n\t\t * The identify message we send determines whether \n\t\t * disconnect/reselect is allowed for this command.\n\t\t * 0xC0+LUN: allows it, 0x80+LUN disallows it.\n\t\t */\n\t\tmsg = 0xc0;\t/* MSG_IDENTIFY(0,1) */\n\t\tif (sc->sc_no_disconnect & (1 << sr->sr_target))\n\t\t\tmsg = 0x80;\n\t\tif (sr->sr_flags & (SR_IMMED | SR_SENSE))\n\t\t\tmsg = 0x80;\n\t\tsc->sc_omess[0] = msg | sr->sr_lun;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_DEV_RESET:\n\t\tNCR_TRACE(\"msg_out: SEND_DEV_RESET\\n\", 0);\n\t\t/* Expect disconnect after this! */\n\t\t/* XXX: Kill jobs for this target? */\n\t\tact_flags |= (ACT_DISCONNECT | ACT_CMD_DONE);\n\t\tsc->sc_omess[0] = MSG_BUS_DEV_RESET;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_REJECT:\n\t\tNCR_TRACE(\"msg_out: SEND_REJECT\\n\", 0);\n\t\tsc->sc_omess[0] = MSG_MESSAGE_REJECT;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_PARITY_ERROR:\n\t\tNCR_TRACE(\"msg_out: SEND_PARITY_ERROR\\n\", 0);\n\t\tsc->sc_omess[0] = MSG_PARITY_ERROR;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_INIT_DET_ERR:\n\t\tNCR_TRACE(\"msg_out: SEND_INIT_DET_ERR\\n\", 0);\n\t\tsc->sc_omess[0] = MSG_INITIATOR_DET_ERR;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase SEND_ABORT:\n\t\tNCR_TRACE(\"msg_out: SEND_ABORT\\n\", 0);\n\t\t/* Expect disconnect after this! */\n\t\t/* XXX: Set error flag? */\n\t\tact_flags |= (ACT_DISCONNECT | ACT_CMD_DONE);\n\t\tsc->sc_omess[0] = MSG_ABORT;\n\t\tn = 1;\n\t\tbreak;\n\n\tcase 0:\n\t\tprintf(\"%s: unexpected MESSAGE OUT; sending NOOP\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tNCR_BREAK();\n\tnoop:\n\t\tNCR_TRACE(\"msg_out: send NOOP\\n\", 0);\n\t\tsc->sc_omess[0] = MSG_NOOP;\n\t\tn = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"%s: weird MESSAGE OUT; sending NOOP\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tNCR_BREAK();\n\t\tgoto noop;\n\t}\n\tsc->sc_omp = &sc->sc_omess[n];\n\nnextbyte:\n\t/* Send message bytes. */\n\twhile (n > 0) {\n\t\t/*\n\t\t * Send a message byte.\n\t\t * First check BSY, REQ, phase...\n\t\t */\n\t\tif (!SCI_BUSY(sc)) {\n\t\t\tNCR_TRACE(\"msg_out: lost BSY, n=%d\\n\", n);\n\t\t\tgoto out;\n\t\t}\n\t\tif (ncr5380_wait_req(sc)) {\n\t\t\tNCR_TRACE(\"msg_out: no REQ, n=%d\\n\", n);\n\t\t\tgoto out;\n\t\t}\n\t\tphase = SCI_BUS_PHASE(*sc->sci_bus_csr);\n\t\tif (phase != PHASE_MSG_OUT) {\n\t\t\t/*\n\t\t\t * Target left MESSAGE OUT, possibly to reject\n\t\t\t * our message.\n\t\t\t */\n\t\t\tNCR_TRACE(\"msg_out: new phase=%d\\n\", phase);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Yes, we can send this message byte. */\n\t\t--n;\n\n\t\t/* Clear ATN before last byte if this is the last message. */\n\t\tif (n == 0 && sc->sc_msgpriq == 0) {\n\t\t\ticmd &= ~SCI_ICMD_ATN;\n\t\t\t*sc->sci_icmd = icmd;\n\t\t\t/* 2 deskew delays */\n\t\t\tdelay(2);\t/* XXX */\n\t\t}\n\n\t\t/* Put data on the bus. */\n\t\t*sc->sci_odata = *--sc->sc_omp;\n\n\t\t/* Raise ACK to tell target data is on the bus. */\n\t\ticmd |= SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\t/* Wait for REQ to be negated. */\n\t\tif (ncr5380_wait_not_req(sc)) {\n\t\t\tNCR_TRACE(\"msg_out: stuck REQ, n=%d\\n\", n);\n\t\t\tact_flags |= ACT_RESET_BUS;\n\t\t}\n\n\t\t/* Finally, drop ACK. */\n\t\ticmd &= ~SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\t/* Stuck bus or something... */\n\t\tif (act_flags & ACT_RESET_BUS)\n\t\t\tgoto out;\n\n\t}\n\tprogress++;\n\n\t/* We get here only if the entire message has been transmitted. */\n\tif (sc->sc_msgpriq != 0) {\n\t\t/* There are more outgoing messages. */\n\t\tgoto nextmsg;\n\t}\n\n\t/*\n\t * The last message has been transmitted.  We need to remember the last\n\t * message transmitted (in case the target switches to MESSAGE IN phase\n\t * and sends a MESSAGE REJECT), and the list of messages transmitted\n\t * this time around (in case the target stays in MESSAGE OUT phase to\n\t * request a retransmit).\n\t */\n\nout:\n\t/* Stop driving the data bus. */\n\ticmd &= ~SCI_ICMD_DATA;\n\t*sc->sci_icmd = icmd;\n\n\tif (!progress)\n\t\tact_flags |= ACT_RESET_BUS;\n\n\treturn (act_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncr5380_pio_in",
          "args": [
            "sc",
            "PHASE_MSG_IN",
            "1",
            "&msg"
          ],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_pio_in",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "299-351",
          "snippet": "int\nncr5380_pio_in(sc, phase, count, data)\n\tstruct ncr5380_softc *sc;\n\tint phase, count;\n\tunsigned char\t\t\t*data;\n{\n\tregister u_char \ticmd;\n\tregister int\t\tresid;\n\tregister int\t\terror;\n\n\ticmd = *(sc->sci_icmd) & SCI_ICMD_RMASK;\n\n\tresid = count;\n\twhile (resid > 0) {\n\t\tif (!SCI_BUSY(sc)) {\n\t\t\tNCR_TRACE(\"pio_in: lost BSY, resid=%d\\n\", resid);\n\t\t\tbreak;\n\t\t}\n\t\tif (ncr5380_wait_req(sc)) {\n\t\t\tNCR_TRACE(\"pio_in: no REQ, resid=%d\\n\", resid);\n\t\t\tbreak;\n\t\t}\n\t\t/* A phase change is not valid until AFTER REQ rises! */\n\t\tif (SCI_BUS_PHASE(*sc->sci_bus_csr) != phase)\n\t\t\tbreak;\n\n\t\t/* Read the data bus. */\n\t\tif (data)\n\t\t\t*data++ = *sc->sci_data;\n\t\telse\n\t\t\t(void) *sc->sci_data;\n\n\t\t/* Tell target we got it. */\n\t\ticmd |= SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\t/* Wait for target to drop REQ... */\n\t\terror = ncr5380_wait_not_req(sc);\n\n\t\t/* OK, we can drop ACK. */\n\t\ticmd &= ~SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\tif (error) {\n\t\t\tNCR_TRACE(\"pio_in: stuck REQ, resid=%d\\n\", resid);\n\t\t\tbreak;\n\t\t}\n\n\t\t--resid;\n\t}\n\n\treturn (count - resid);\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline int ncr5380_wait_req",
            "static __inline int ncr5380_wait_not_req"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic __inline int ncr5380_wait_req;\nstatic __inline int ncr5380_wait_not_req;\n\nint\nncr5380_pio_in(sc, phase, count, data)\n\tstruct ncr5380_softc *sc;\n\tint phase, count;\n\tunsigned char\t\t\t*data;\n{\n\tregister u_char \ticmd;\n\tregister int\t\tresid;\n\tregister int\t\terror;\n\n\ticmd = *(sc->sci_icmd) & SCI_ICMD_RMASK;\n\n\tresid = count;\n\twhile (resid > 0) {\n\t\tif (!SCI_BUSY(sc)) {\n\t\t\tNCR_TRACE(\"pio_in: lost BSY, resid=%d\\n\", resid);\n\t\t\tbreak;\n\t\t}\n\t\tif (ncr5380_wait_req(sc)) {\n\t\t\tNCR_TRACE(\"pio_in: no REQ, resid=%d\\n\", resid);\n\t\t\tbreak;\n\t\t}\n\t\t/* A phase change is not valid until AFTER REQ rises! */\n\t\tif (SCI_BUS_PHASE(*sc->sci_bus_csr) != phase)\n\t\t\tbreak;\n\n\t\t/* Read the data bus. */\n\t\tif (data)\n\t\t\t*data++ = *sc->sci_data;\n\t\telse\n\t\t\t(void) *sc->sci_data;\n\n\t\t/* Tell target we got it. */\n\t\ticmd |= SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\t/* Wait for target to drop REQ... */\n\t\terror = ncr5380_wait_not_req(sc);\n\n\t\t/* OK, we can drop ACK. */\n\t\ticmd &= ~SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\tif (error) {\n\t\t\tNCR_TRACE(\"pio_in: stuck REQ, resid=%d\\n\", resid);\n\t\t\tbreak;\n\t\t}\n\n\t\t--resid;\n\t}\n\n\treturn (count - resid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "2"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: phantom reselect: target=%d, LUN=%d\\n\"",
            "sc->sc_dev.dv_xname",
            "target",
            "lun"
          ],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc->sc_dma_setup",
          "args": [
            "sc"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"reselect: call DMA setup, dh=0x%x\\n\"",
            "(long) sr->sr_dma_hand"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"reselect: resume sr=0x%x\\n\"",
            "(long)sr"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCI_BUS_PHASE",
          "args": [
            "*sc->sci_bus_csr"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr5380_wait_req",
          "args": [
            "sc"
          ],
          "line": 1203
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_wait_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "188-202",
          "snippet": "static __inline int ncr5380_wait_req(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tregister int timo = ncr5380_wait_req_timo;\n\tfor (;;) {\n\t\tif (*sc->sci_bus_csr & SCI_BUS_REQ) {\n\t\t\ttimo = 0;\t/* return 0 */\n\t\t\tbreak;\n\t\t}\n\t\tif (--timo < 0)\n\t\t\tbreak;\t/* return -1 */\n\t\tdelay(2);\n\t}\n\treturn (timo);\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncr5380_wait_req_timo = 1000 * 50;",
            "static __inline int ncr5380_wait_req"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint ncr5380_wait_req_timo = 1000 * 50;\nstatic __inline int ncr5380_wait_req;\n\nstatic __inline int ncr5380_wait_req(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tregister int timo = ncr5380_wait_req_timo;\n\tfor (;;) {\n\t\tif (*sc->sci_bus_csr & SCI_BUS_REQ) {\n\t\t\ttimo = 0;\t/* return 0 */\n\t\t\tbreak;\n\t\t}\n\t\tif (--timo < 0)\n\t\t\tbreak;\t/* return -1 */\n\t\tdelay(2);\n\t}\n\treturn (timo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCI_CLR_INTR",
          "args": [
            "sc"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_BREAK",
          "args": [],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"reselect: target=0x%x\\n\"",
            "target"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr5380_reset_scsibus",
          "args": [
            "sc"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_reset_scsibus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "391-411",
          "snippet": "void\nncr5380_reset_scsibus(sc)\n\tstruct ncr5380_softc *sc;\n{\n\n\tNCR_TRACE(\"reset_scsibus, cur=0x%x\\n\",\n\t\t\t  (long) sc->sc_current);\n\n\t*sc->sci_icmd = SCI_ICMD_RST;\n\tdelay(500);\n\t*sc->sci_icmd = 0;\n\n\t*sc->sci_mode = 0;\n\t*sc->sci_tcmd = PHASE_INVALID;\n\n\tSCI_CLR_INTR(sc);\n\t/* XXX - Need long delay here! */\n\tdelay(100000);\n\n\t/* XXX - Need to cancel disconnected requests. */\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\nncr5380_reset_scsibus(sc)\n\tstruct ncr5380_softc *sc;\n{\n\n\tNCR_TRACE(\"reset_scsibus, cur=0x%x\\n\",\n\t\t\t  (long) sc->sc_current);\n\n\t*sc->sci_icmd = SCI_ICMD_RST;\n\tdelay(500);\n\t*sc->sci_icmd = 0;\n\n\t*sc->sci_mode = 0;\n\t*sc->sci_tcmd = PHASE_INVALID;\n\n\tSCI_CLR_INTR(sc);\n\t/* XXX - Need long delay here! */\n\tdelay(100000);\n\n\t/* XXX - Need to cancel disconnected requests. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"reselect, valid data after %d loops\\n\"",
            "ncr5380_wait_nrq_timo - timo"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ncr5380_reselect: current set\""
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int\tncr5380_select;\nstatic void\tncr5380_reselect;\nstatic int\tncr5380_msg_out;\nint ncr5380_wait_nrq_timo = 1000 * 25;\nstatic __inline int ncr5380_wait_req;\n\nvoid\nncr5380_reselect(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tstruct sci_req *sr;\n\tint target, lun, phase, timo;\n\tint target_mask;\n\tu_char bus, data, icmd, msg;\n\n#ifdef\tDIAGNOSTIC\n\t/*\n\t * Note: sc_state will be \"idle\" when ncr5380_intr()\n\t * calls, or \"working\" when ncr5380_select() calls.\n\t * (So don't test that in this DIAGNOSTIC)\n\t */\n\tif (sc->sc_current)\n\t\tpanic(\"ncr5380_reselect: current set\");\n#endif\n\n\t/*\n\t * First, check the select line.\n\t * (That has to be set first.)\n\t */\n\tbus = *(sc->sci_bus_csr);\n\tif ((bus & SCI_BUS_SEL) == 0) {\n\t\t/* Not a selection or reselection. */\n\t\treturn;\n\t}\n\n\t/*\n\t * The target will assert BSY first (for bus arbitration),\n\t * then raise SEL, and finally drop BSY.  Only then is the\n\t * data bus required to have valid selection ID bits set.\n\t * Wait for: SEL==1, BSY==0 before reading the data bus.\n\t * While this theoretically can happen, we are aparently\n\t * never fast enough to get here before BSY drops.\n\t */\n\ttimo = ncr5380_wait_nrq_timo;\n\tfor (;;) {\n\t\tif ((bus & SCI_BUS_BSY) == 0)\n\t\t\tbreak;\n\t\t/* Probably never get here... */\n\t\tif (--timo <= 0) {\n\t\t\tprintf(\"%s: reselect, BSY stuck, bus=0x%x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, bus);\n\t\t\t/* Not much we can do. Reset the bus. */\n\t\t\tncr5380_reset_scsibus(sc);\n\t\t\treturn;\n\t\t}\n\t\tdelay(2);\n\t\tbus = *(sc->sci_bus_csr);\n\t\t/* If SEL went away, forget it. */\n\t\tif ((bus & SCI_BUS_SEL) == 0)\n\t\t\treturn;\n\t\t/* Still have SEL, check BSY. */\n\t}\n\tNCR_TRACE(\"reselect, valid data after %d loops\\n\",\n\t\t\t  ncr5380_wait_nrq_timo - timo);\n\n\t/*\n\t * Good.  We have SEL=1 and BSY=0.  Now wait for a\n\t * \"bus settle delay\" before we sample the data bus\n\t */\n\tdelay(2);\n\tdata = *(sc->sci_data) & 0xFF;\n\t/* Parity check is implicit in data validation below. */\n\n\t/*\n\t * Is this a reselect (I/O == 1) or have we been\n\t * selected as a target? (I/O == 0)\n\t */\n\tif ((bus & SCI_BUS_IO) == 0) {\n\t\tprintf(\"%s: selected as target, data=0x%x\\n\",\n\t\t    sc->sc_dev.dv_xname, data);\n\t\t/* Not much we can do. Reset the bus. */\n\t\t/* XXX: send some sort of message? */\n\t\tncr5380_reset_scsibus(sc);\n\t\treturn;\n\t}\n\n\t/*\n\t * OK, this is a reselection.\n\t */\n\tfor (target = 0; target < 7; target++) {\n\t\ttarget_mask = (1 << target);\n\t\tif (data & target_mask)\n\t\t\tbreak;\n\t}\n\tif ((data & 0x7F) != target_mask) {\n\t\t/* No selecting ID? or >2 IDs on bus? */\n\t\tprintf(\"%s: bad reselect, data=0x%x\\n\",\n\t\t    sc->sc_dev.dv_xname, data);\n\t\treturn;\n\t}\n\n\tNCR_TRACE(\"reselect: target=0x%x\\n\", target);\n\n\t/* Raise BSY to acknowledge target reselection. */\n\t*(sc->sci_icmd) = SCI_ICMD_BSY;\n\n\t/* Wait for target to drop SEL. */\n\ttimo = ncr5380_wait_nrq_timo;\n\tfor (;;) {\n\t\tbus = *(sc->sci_bus_csr);\n\t\tif ((bus & SCI_BUS_SEL) == 0)\n\t\t\tbreak;\t/* success */\n\t\tif (--timo <= 0) {\n\t\t\tprintf(\"%s: reselect, SEL stuck, bus=0x%x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, bus);\n\t\t\tNCR_BREAK();\n\t\t\t/* assume connected (fail later if not) */\n\t\t\tbreak;\n\t\t}\n\t\tdelay(2);\n\t}\n\n\t/* Now we drop BSY, and we are connected. */\n\t*(sc->sci_icmd) = 0;\n\t*sc->sci_sel_enb = 0;\n\tSCI_CLR_INTR(sc);\n\n\t/*\n\t * At this point the target should send an IDENTIFY message,\n\t * which will permit us to determine the reselecting LUN.\n\t * If not, we assume LUN 0.\n\t */\n\tlun = 0;\n\t/* Wait for REQ before reading bus phase. */\n\tif (ncr5380_wait_req(sc)) {\n\t\tprintf(\"%s: reselect, no REQ\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\t/* Try to send an ABORT message. */\n\t\tgoto abort;\n\t}\n\tphase = SCI_BUS_PHASE(*sc->sci_bus_csr);\n\tif (phase != PHASE_MSG_IN) {\n\t\tprintf(\"%s: reselect, phase=%d\\n\",\n\t\t    sc->sc_dev.dv_xname, phase);\n\t\tgoto abort;\n\t}\n\n\t/* Ack. the change to PHASE_MSG_IN */\n\t*(sc->sci_tcmd) = PHASE_MSG_IN;\n\n\t/* Peek at the message byte without consuming it! */\n\tmsg = *(sc->sci_data);\n\tif ((msg & 0x80) == 0) {\n\t\tprintf(\"%s: reselect, not identify, msg=%d\\n\",\n\t\t    sc->sc_dev.dv_xname, msg);\n\t\tgoto abort;\n\t}\n\tlun = msg & 7;\n\t\n\t/* We now know target/LUN.  Do we have the request? */\n\tsr = sc->sc_matrix[target][lun];\n\tif (sr) {\n\t\t/* We now have a nexus. */\n\t\tsc->sc_state |= NCR_WORKING;\n\t\tsc->sc_current = sr;\n\t\tNCR_TRACE(\"reselect: resume sr=0x%x\\n\", (long)sr);\n\n\t\t/* Implicit restore pointers message */\n\t\tsc->sc_dataptr = sr->sr_dataptr;\n\t\tsc->sc_datalen = sr->sr_datalen;\n\n\t\tsc->sc_prevphase = PHASE_INVALID;\n\t\tsc->sc_msgpriq = 0;\n\t\tsc->sc_msgoutq = 0;\n\t\tsc->sc_msgout  = 0;\n\n\t\t/* XXX: Restore the normal mode register. */\n\t\t/* If this target's bit is set, do NOT check parity. */\n\t\tif (sc->sc_parity_disable & target_mask)\n\t\t\t*sc->sci_mode = (SCI_MODE_MONBSY);\n\t\telse\n\t\t\t*sc->sci_mode = (SCI_MODE_MONBSY | SCI_MODE_PAR_CHK);\n\n\t\t/*\n\t\t * Another hack for the Sun3 \"si\", which needs\n\t\t * some setup done to its DMA engine before the\n\t\t * target puts the SCSI bus into any DATA phase.\n\t\t */\n\t\tif (sr->sr_dma_hand && sc->sc_dma_setup) {\n\t\t\tNCR_TRACE(\"reselect: call DMA setup, dh=0x%x\\n\",\n\t\t\t\t\t  (long) sr->sr_dma_hand);\n\t\t    sc->sc_dma_setup(sc);\n\t\t}\n\n\t\t/* Now consume the IDENTIFY message. */\n\t\tncr5380_pio_in(sc, PHASE_MSG_IN, 1, &msg);\n\t\treturn;\n\t}\n\n\tprintf(\"%s: phantom reselect: target=%d, LUN=%d\\n\",\n\t    sc->sc_dev.dv_xname, target, lun);\nabort:\n\t/*\n\t * Try to send an ABORT message.  This makes us\n\t * temporarily busy, but no current command...\n\t */\n\tsc->sc_state |= NCR_ABORTING;\n\n\t/* Raise ATN, delay, raise ACK... */\n\ticmd = SCI_ICMD_ATN;\n\t*sc->sci_icmd = icmd;\n\tdelay(2);\n\n\t/* Now consume the IDENTIFY message. */\n\tncr5380_pio_in(sc, PHASE_MSG_IN, 1, &msg);\n\n\t/* Finally try to send the ABORT. */\n\tsc->sc_prevphase = PHASE_INVALID;\n\tsc->sc_msgpriq = SEND_ABORT;\n\tncr5380_msg_out(sc);\n\n\t*(sc->sci_tcmd) = PHASE_INVALID;\n\t*sc->sci_sel_enb = 0;\n\tSCI_CLR_INTR(sc);\n\t*sc->sci_sel_enb = 0x80;\n\n\tsc->sc_state &= ~NCR_ABORTING;\n}"
  },
  {
    "function_name": "ncr5380_sched",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
    "lines": "827-1063",
    "snippet": "static void\nncr5380_sched(sc)\n\tstruct\tncr5380_softc *sc;\n{\n\tstruct sci_req\t*sr;\n\tstruct scsi_xfer *xs;\n\tint\ttarget = 0, lun = 0;\n\tint\terror, i;\n\n\t/* Another hack (Er.. hook!) for the sun3 si: */\n\tif (sc->sc_intr_off) {\n\t\tNCR_TRACE(\"sched: top, intr off\\n\", 0);\n\t    sc->sc_intr_off(sc);\n\t}\n\nnext_job:\n\t/*\n\t * Grab the next job from queue.  Must be idle.\n\t */\n#ifdef\tDIAGNOSTIC\n\tif (sc->sc_state != NCR_IDLE)\n\t\tpanic(\"ncr5380_sched: not idle\");\n\tif (sc->sc_current)\n\t\tpanic(\"ncr5380_sched: current set\");\n#endif\n\n\t/*\n\t * Always start the search where we last looked.\n\t * The REQUEST_SENSE logic depends on this to\n\t * choose the same job as was last picked, so it\n\t * can just clear sc_current and reschedule.\n\t * (Avoids loss of \"contingent allegiance\".)\n\t */\n\ti = sc->sc_rr;\n\tsr = NULL;\n\tdo {\n\t\tif (sc->sc_ring[i].sr_xs) {\n\t\t\ttarget = sc->sc_ring[i].sr_target;\n\t\t\tlun = sc->sc_ring[i].sr_lun;\n\t\t\tif (sc->sc_matrix[target][lun] == NULL) {\n\t\t\t\t/*\n\t\t\t\t * Do not mark the  target/LUN busy yet,\n\t\t\t\t * because reselect may cause some other\n\t\t\t\t * job to become the current one, so we\n\t\t\t\t * might not actually start this job.\n\t\t\t\t * Instead, set sc_matrix later on.\n\t\t\t\t */\n\t\t\t\tsc->sc_rr = i;\n\t\t\t\tsr = &sc->sc_ring[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t\tif (i == SCI_OPENINGS)\n\t\t\ti = 0;\n\t} while (i != sc->sc_rr);\n\n\tif (sr == NULL) {\n\t\tNCR_TRACE(\"sched: no work, cur=0x%x\\n\",\n\t\t\t\t  (long) sc->sc_current);\n\n\t\t/* Another hack (Er.. hook!) for the sun3 si: */\n\t\tif (sc->sc_intr_on) {\n\t\t\tNCR_TRACE(\"sched: ret, intr ON\\n\", 0);\n\t\t    sc->sc_intr_on(sc);\n\t\t}\n\n\t\treturn;\t\t/* No more work to do. */\n\t}\n\n\tNCR_TRACE(\"sched: select for t/l=0x%02x\\n\",\n\t\t\t  (sr->sr_target << 4) | sr->sr_lun);\n\n\tsc->sc_state = NCR_WORKING;\n\terror = ncr5380_select(sc, sr);\n\tif (sc->sc_current) {\n\t\t/* Lost the race!  reselected out from under us! */\n\t\t/* Work with the reselected job. */\n\t\tif (sr->sr_flags & SR_IMMED) {\n\t\t\tprintf(\"%s: reselected while polling (abort)\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t/* Abort the reselected job. */\n\t\t\tsc->sc_state |= NCR_ABORTING;\n\t\t\tsc->sc_msgpriq |= SEND_ABORT;\n\t\t}\n\t\tsr = sc->sc_current;\n\t\txs = sr->sr_xs;\n\t\tNCR_TRACE(\"sched: reselect, new sr=0x%x\\n\", (long)sr);\n\t\tgoto have_nexus;\n\t}\n\n\t/* Normal selection result.  Target/LUN is now busy. */\n\tsc->sc_matrix[target][lun] = sr;\n\tsc->sc_current = sr;\t/* connected */\n\txs = sr->sr_xs;\n\n\t/*\n\t * Initialize pointers, etc. for this job\n\t */\n\tsc->sc_dataptr  = sr->sr_dataptr;\n\tsc->sc_datalen  = sr->sr_datalen;\n\tsc->sc_prevphase = PHASE_INVALID;\n\tsc->sc_msgpriq = SEND_IDENTIFY;\n\tsc->sc_msgoutq = 0;\n\tsc->sc_msgout  = 0;\n\n\tNCR_TRACE(\"sched: select rv=%d\\n\", error);\n\n\tswitch (error) {\n\tcase XS_NOERROR:\n\t\tbreak;\n\n\tcase XS_BUSY:\n\t\t/* XXX - Reset and try again. */\n\t\tprintf(\"%s: select found SCSI bus busy, resetting...\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tncr5380_reset_scsibus(sc);\n\t\t/* fallthrough */\n\tcase XS_SELTIMEOUT:\n\tdefault:\n\t\txs->error = error;\t/* from select */\n\t\tNCR_TRACE(\"sched: call done, sr=0x%x\\n\", (long)sr);\n\t\tncr5380_done(sc);\n\n\t\t/* Paranoia: clear everything. */\n\t\tsc->sc_dataptr = NULL;\n\t\tsc->sc_datalen = 0;\n\t\tsc->sc_prevphase = PHASE_INVALID;\n\t\tsc->sc_msgpriq = 0;\n\t\tsc->sc_msgoutq = 0;\n\t\tsc->sc_msgout  = 0;\n\n\t\tgoto next_job;\n\t}\n\n\t/*\n\t * Selection was successful.  Normally, this means\n\t * we are starting a new command.  However, this\n\t * might be the termination of an overdue job.\n\t */\n\tif (sr->sr_flags & SR_OVERDUE) {\n\t\tNCR_TRACE(\"sched: overdue, sr=0x%x\\n\", (long)sr);\n\t\tsc->sc_state |= NCR_ABORTING;\n\t\tsc->sc_msgpriq |= SEND_ABORT;\n\t\tgoto have_nexus;\n\t}\n\n\t/*\n\t * This may be the continuation of some job that\n\t * completed with a \"check condition\" code.\n\t */\n\tif (sr->sr_flags & SR_SENSE) {\n\t\tNCR_TRACE(\"sched: get sense, sr=0x%x\\n\", (long)sr);\n\t\t/* Do not allocate DMA, nor set timeout. */\n\t\tgoto have_nexus;\n\t}\n\n\t/*\n\t * OK, we are starting a new command.\n\t * Initialize and allocate resources for the new command.\n\t * Device reset is special (only uses MSG_OUT phase).\n\t * Normal commands start in MSG_OUT phase where we will\n\t * send and IDENDIFY message, and then expect CMD phase.\n\t */\n#ifdef\tNCR5380_DEBUG\n\tif (ncr5380_debug & NCR_DBG_CMDS) {\n\t\tprintf(\"ncr5380_sched: begin, target=%d, LUN=%d\\n\",\n\t\t    xs->sc_link->target, xs->sc_link->lun);\n\t\tncr5380_show_scsi_cmd(xs);\n\t}\n#endif\n\tif (xs->flags & SCSI_RESET) {\n\t\tNCR_TRACE(\"sched: cmd=reset, sr=0x%x\\n\", (long)sr);\n\t\t/* Not an error, so do not set NCR_ABORTING */\n\t\tsc->sc_msgpriq |= SEND_DEV_RESET;\n\t\tgoto have_nexus;\n\t}\n\n#ifdef\tDIAGNOSTIC\n\tif ((xs->flags & (SCSI_DATA_IN | SCSI_DATA_OUT)) == 0) {\n\t\tif (sc->sc_dataptr) {\n\t\t\tprintf(\"%s: ptr but no data in/out flags?\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tNCR_BREAK();\n\t\t\tsc->sc_dataptr = NULL;\n\t\t}\n\t}\n#endif\n\n\t/* Allocate DMA space (maybe) */\n\tif (sc->sc_dataptr && sc->sc_dma_alloc &&\n\t\t(sc->sc_datalen >= sc->sc_min_dma_len))\n\t{\n\t\tNCR_TRACE(\"sched: dma_alloc, len=%d\\n\", sc->sc_datalen);\n\t\t(*sc->sc_dma_alloc)(sc);\n\t}\n\n\t/*\n\t * Initialization hook called just after select,\n\t * at the beginning of COMMAND phase.\n\t * (but AFTER the DMA allocation is done)\n\t *\n\t * The evil Sun \"si\" adapter (OBIO variant) needs some\n\t * setup done to the DMA engine BEFORE the target puts\n\t * the SCSI bus into any DATA phase.\n\t */\n\tif (sr->sr_dma_hand && sc->sc_dma_setup) {\n\t\tNCR_TRACE(\"sched: dma_setup, dh=0x%x\\n\",\n\t\t\t\t  (long) sr->sr_dma_hand);\n\t    sc->sc_dma_setup(sc);\n\t}\n\n\t/*\n\t * Schedule a timeout for the job we are starting.\n\t */\n\tif ((sr->sr_flags & SR_IMMED) == 0) {\n\t\ti = (xs->timeout * hz) / 1000;\n\t\tNCR_TRACE(\"sched: set timeout=%d\\n\", i);\n\t\ttimeout(ncr5380_cmd_timeout, sr, i);\n\t}\n\nhave_nexus:\n\tNCR_TRACE(\"sched: call machine, cur=0x%x\\n\",\n\t\t\t  (long) sc->sc_current);\n\tncr5380_machine(sc);\n\tNCR_TRACE(\"sched: machine done, cur=0x%x\\n\",\n\t\t\t  (long) sc->sc_current);\n\n\t/*\n\t * What state did ncr5380_machine() leave us in?\n\t * Hopefully it sometimes completes a job...\n\t */\n\tif (sc->sc_state == NCR_IDLE)\n\t\tgoto next_job;\n\n\treturn; \t/* Have work in progress. */\n}",
    "includes": [
      "#include <dev/ic/ncr5380var.h>",
      "#include <dev/ic/ncr5380reg.h>",
      "#include <ddb/db_output.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\tNCR_DBG_CMDS\t2"
    ],
    "globals_used": [
      "static void\tncr5380_sched",
      "static void\tncr5380_done",
      "static int\tncr5380_select",
      "static void\tncr5380_machine",
      "void\tncr5380_cmd_timeout"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"sched: machine done, cur=0x%x\\n\"",
            "(long) sc->sc_current"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr5380_machine",
          "args": [
            "sc"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_machine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "2191-2433",
          "snippet": "static void\nncr5380_machine(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tstruct sci_req *sr;\n\tstruct scsi_xfer *xs;\n\tint act_flags, phase, timo;\n\n#ifdef\tDIAGNOSTIC\n\tif (sc->sc_state == NCR_IDLE)\n\t\tpanic(\"ncr5380_machine: state=idle\");\n\tif (sc->sc_current == NULL)\n\t\tpanic(\"ncr5380_machine: no current cmd\");\n#endif\n\n\tsr = sc->sc_current;\n\txs = sr->sr_xs;\n\tact_flags = ACT_CONTINUE;\n\n\t/*\n\t * This will be called by ncr5380_intr() when DMA is\n\t * complete.  Must stop DMA before touching the 5380 or\n\t * there will be \"register conflict\" errors.\n\t */\n\tif (sc->sc_state & NCR_DOINGDMA) {\n\t\t/* Pick-up where where we left off... */\n\t\tgoto dma_done;\n\t}\n\nnext_phase:\n\n\tif (!SCI_BUSY(sc)) {\n\t\t/* Unexpected disconnect */\n\t\tprintf(\"ncr5380_machine: unexpected disconnect.\\n\");\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\tact_flags |= (ACT_DISCONNECT | ACT_CMD_DONE);\n\t\tgoto do_actions;\n\t}\n\n\t/*\n\t * Wait for REQ before reading the phase.\n\t * Need to wait longer than usual here, because\n\t * some devices are just plain slow...\n\t */\n\ttimo = ncr5380_wait_phase_timo;\n\tfor (;;) {\n\t\tif (*sc->sci_bus_csr & SCI_BUS_REQ)\n\t\t\tbreak;\n\t\tif (--timo <= 0) {\n\t\t\tif (sc->sc_state & NCR_ABORTING) {\n\t\t\t\tprintf(\"%s: no REQ while aborting, reset\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tact_flags |= ACT_RESET_BUS;\n\t\t\t\tgoto do_actions;\n\t\t\t}\n\t\t\tprintf(\"%s: no REQ for next phase, abort\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tsc->sc_state |= NCR_ABORTING;\n\t\t\tncr_sched_msgout(sc, SEND_ABORT);\n\t\t\tgoto next_phase;\n\t\t}\n\t\tdelay(100);\n\t}\n\n\tphase = SCI_BUS_PHASE(*sc->sci_bus_csr);\n\tNCR_TRACE(\"machine: phase=%s\\n\",\n\t\t\t  (long) phase_names[phase & 7]);\n\n\t/*\n\t * We assume that the device knows what it's doing,\n\t * so any phase is good.\n\t */\n\n#if 0\n\t/*\n\t * XXX: Do not ACK the phase yet! do it later...\n\t * XXX: ... each phase routine does that itself.\n\t * In particular, DMA needs it done LATER.\n\t */\n\t*sc->sci_tcmd = phase;\t/* acknowledge phase change */\n#endif\n\n\tswitch (phase) {\n\n\tcase PHASE_DATA_OUT:\n\tcase PHASE_DATA_IN:\n\t\tact_flags = ncr5380_data_xfer(sc, phase);\n\t\tbreak;\n\n\tcase PHASE_COMMAND:\n\t\tact_flags = ncr5380_command(sc);\n\t\tbreak;\n\n\tcase PHASE_STATUS:\n\t\tact_flags = ncr5380_status(sc);\n\t\tbreak;\n\n\tcase PHASE_MSG_OUT:\n\t\tact_flags = ncr5380_msg_out(sc);\n\t\tbreak;\n\n\tcase PHASE_MSG_IN:\n\t\tact_flags = ncr5380_msg_in(sc);\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"ncr5380_machine: Unexpected phase 0x%x\\n\", phase);\n\t\tsc->sc_state |= NCR_ABORTING;\n\t\tncr_sched_msgout(sc, SEND_ABORT);\n\t\tgoto next_phase;\n\n\t} /* switch */\n\tsc->sc_prevphase = phase;\n\ndo_actions:\n\t__asm(\"_ncr5380_actions:\");\n\n\tif (act_flags & ACT_WAIT_DMA) {\n\t\tact_flags &= ~ACT_WAIT_DMA;\n\t\t/* Wait for DMA to complete (polling, or interrupt). */\n\t\tif ((sr->sr_flags & SR_IMMED) == 0) {\n\t\t\tNCR_TRACE(\"machine: wait for DMA intr.\\n\", 0);\n\t\t\treturn; \t/* will resume at dma_done */\n\t\t}\n\t\t/* Busy-wait for it to finish. */\n\t\tNCR_TRACE(\"machine: dma_poll, dh=0x%x\\n\",\n\t\t\t\t  (long) sr->sr_dma_hand);\n\t\t(*sc->sc_dma_poll)(sc);\n\tdma_done:\n\t\t/* Return here after interrupt. */\n\t\tif (sr->sr_flags & SR_OVERDUE)\n\t\t\tsc->sc_state |= NCR_ABORTING;\n\t\tNCR_TRACE(\"machine: dma_stop, dh=0x%x\\n\",\n\t\t\t\t  (long) sr->sr_dma_hand);\n\t\t(*sc->sc_dma_stop)(sc);\n\t\tSCI_CLR_INTR(sc);\t/* XXX */\n\t\t/*\n\t\t * While DMA is running we can not touch the SBC,\n\t\t * so various places just set NCR_ABORTING and\n\t\t * expect us the \"kick it\" when DMA is done.\n\t\t */\n\t\tif (sc->sc_state & NCR_ABORTING) {\n\t\t\tncr_sched_msgout(sc, SEND_ABORT);\n\t\t}\n\t}\n\n\t/*\n\t * Check for parity error.\n\t * XXX - better place to check?\n\t */\n\tif (*(sc->sci_csr) & SCI_CSR_PERR) {\n\t\tprintf(\"%s: parity error!\\n\", sc->sc_dev.dv_xname);\n\t\t/* XXX: sc->sc_state |= NCR_ABORTING; */\n\t\tncr_sched_msgout(sc, SEND_PARITY_ERROR);\n\t}\n\n\tif (act_flags == ACT_CONTINUE)\n\t\tgoto next_phase;\n\t/* All other actions \"break\" from the loop. */\n\n\tNCR_TRACE(\"machine: act_flags=0x%x\\n\", act_flags);\n\n\tif (act_flags & ACT_RESET_BUS) {\n\t\tact_flags |= ACT_CMD_DONE;\n\t\t/*\n\t\t * Reset the SCSI bus, usually due to a timeout.\n\t\t * The error code XS_TIMEOUT allows retries.\n\t\t */\n\t\tsc->sc_state |= NCR_ABORTING;\n\t\tprintf(\"%s: reset SCSI bus for TID=%d LUN=%d\\n\",\n\t\t    sc->sc_dev.dv_xname, sr->sr_target, sr->sr_lun);\n\t\tncr5380_reset_scsibus(sc);\n\t}\n\n\tif (act_flags & ACT_CMD_DONE) {\n\t\tact_flags |= ACT_DISCONNECT;\n\t\t/* Need to call scsi_done() */\n\t\t/* XXX: from the aic6360 driver, but why? */\n\t\tif (sc->sc_datalen < 0) {\n\t\t\tprintf(\"%s: %d extra bytes from %d:%d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, -sc->sc_datalen,\n\t\t\t    sr->sr_target, sr->sr_lun);\n\t\t\tsc->sc_datalen = 0;\n\t\t}\n\t\txs->resid = sc->sc_datalen;\n\t\t/* Note: this will clear sc_current */\n\t\tNCR_TRACE(\"machine: call done, cur=0x%x\\n\", (long)sr);\n\t\tncr5380_done(sc);\n\t}\n\n\tif (act_flags & ACT_DISCONNECT) {\n\t\t/*\n\t\t * The device has dropped BSY (or will soon).\n\t\t * We have to wait here for BSY to drop, otherwise\n\t\t * the next command may decide we need a bus reset.\n\t\t */\n\t\ttimo = ncr5380_wait_req_timo;\t/* XXX */\n\t\tfor (;;) {\n\t\t\tif (!SCI_BUSY(sc))\n\t\t\t\tgoto busfree;\n\t\t\tif (--timo <= 0)\n\t\t\t\tbreak;\n\t\t\tdelay(2);\n\t\t}\n\t\t/* Device is sitting on the bus! */\n\t\tprintf(\"%s: Target %d LUN %d stuck busy, resetting...\\n\",\n\t\t    sc->sc_dev.dv_xname, sr->sr_target, sr->sr_lun);\n\t\tncr5380_reset_scsibus(sc);\n\tbusfree:\n\t\tNCR_TRACE(\"machine: discon, waited %d\\n\",\n\t\t\tncr5380_wait_nrq_timo - timo);\n\n\t\t*sc->sci_icmd = 0;\n\t\t*sc->sci_mode = 0;\n\t\t*sc->sci_tcmd = PHASE_INVALID;\n\t\t*sc->sci_sel_enb = 0;\n\t\tSCI_CLR_INTR(sc);\n\t\t*sc->sci_sel_enb = 0x80;\n\n\t\tif ((act_flags & ACT_CMD_DONE) == 0) {\n\t\t\t__asm(\"_ncr5380_disconnected:\");\n\t\t\tNCR_TRACE(\"machine: discon, cur=0x%x\\n\", (long)sr);\n\t\t}\n\n\t\t/*\n\t\t * We may be here due to a disconnect message,\n\t\t * in which case we did NOT call ncr5380_done,\n\t\t * and we need to clear sc_current.\n\t\t */\n\t\tsc->sc_state = NCR_IDLE;\n\t\tsc->sc_current = NULL;\n\n\t\t/* Paranoia: clear everything. */\n\t\tsc->sc_dataptr = NULL;\n\t\tsc->sc_datalen = 0;\n\t\tsc->sc_prevphase = PHASE_INVALID;\n\t\tsc->sc_msgpriq = 0;\n\t\tsc->sc_msgoutq = 0;\n\t\tsc->sc_msgout  = 0;\n\n\t\t/* Our caller will re-enable interrupts. */\n\t}\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define ACT_WAIT_DMA\t0x10\t/* Wait for DMA to complete */",
            "#define ACT_RESET_BUS\t0x04\t/* Need bus reset (cmd timeout) */",
            "#define ACT_CMD_DONE\t0x02\t/* Need to call scsi_done() */",
            "#define ACT_DISCONNECT\t0x01\t/* Target is disconnecting */",
            "#define ACT_CONTINUE\t0x00\t/* No flags: expect another phase */"
          ],
          "globals_used": [
            "static void\tncr5380_done",
            "static int\tncr5380_msg_in",
            "static int\tncr5380_msg_out",
            "static int\tncr5380_data_xfer",
            "static int\tncr5380_command",
            "static int\tncr5380_status",
            "static void\tncr5380_machine",
            "static char *\nphase_names[8] = {\n\t\"DATA_OUT\",\n\t\"DATA_IN\",\n\t\"COMMAND\",\n\t\"STATUS\",\n\t\"UNSPEC1\",\n\t\"UNSPEC2\",\n\t\"MSG_OUT\",\n\t\"MSG_IN\",\n};",
            "int ncr5380_wait_phase_timo = 1000 * 10 * 300;",
            "int ncr5380_wait_req_timo = 1000 * 50;",
            "int ncr5380_wait_nrq_timo = 1000 * 25;",
            "static __inline void ncr_sched_msgout"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define ACT_WAIT_DMA\t0x10\t/* Wait for DMA to complete */\n#define ACT_RESET_BUS\t0x04\t/* Need bus reset (cmd timeout) */\n#define ACT_CMD_DONE\t0x02\t/* Need to call scsi_done() */\n#define ACT_DISCONNECT\t0x01\t/* Target is disconnecting */\n#define ACT_CONTINUE\t0x00\t/* No flags: expect another phase */\n\nstatic void\tncr5380_done;\nstatic int\tncr5380_msg_in;\nstatic int\tncr5380_msg_out;\nstatic int\tncr5380_data_xfer;\nstatic int\tncr5380_command;\nstatic int\tncr5380_status;\nstatic void\tncr5380_machine;\nstatic char *\nphase_names[8] = {\n\t\"DATA_OUT\",\n\t\"DATA_IN\",\n\t\"COMMAND\",\n\t\"STATUS\",\n\t\"UNSPEC1\",\n\t\"UNSPEC2\",\n\t\"MSG_OUT\",\n\t\"MSG_IN\",\n};\nint ncr5380_wait_phase_timo = 1000 * 10 * 300;\nint ncr5380_wait_req_timo = 1000 * 50;\nint ncr5380_wait_nrq_timo = 1000 * 25;\nstatic __inline void ncr_sched_msgout;\n\nstatic void\nncr5380_machine(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tstruct sci_req *sr;\n\tstruct scsi_xfer *xs;\n\tint act_flags, phase, timo;\n\n#ifdef\tDIAGNOSTIC\n\tif (sc->sc_state == NCR_IDLE)\n\t\tpanic(\"ncr5380_machine: state=idle\");\n\tif (sc->sc_current == NULL)\n\t\tpanic(\"ncr5380_machine: no current cmd\");\n#endif\n\n\tsr = sc->sc_current;\n\txs = sr->sr_xs;\n\tact_flags = ACT_CONTINUE;\n\n\t/*\n\t * This will be called by ncr5380_intr() when DMA is\n\t * complete.  Must stop DMA before touching the 5380 or\n\t * there will be \"register conflict\" errors.\n\t */\n\tif (sc->sc_state & NCR_DOINGDMA) {\n\t\t/* Pick-up where where we left off... */\n\t\tgoto dma_done;\n\t}\n\nnext_phase:\n\n\tif (!SCI_BUSY(sc)) {\n\t\t/* Unexpected disconnect */\n\t\tprintf(\"ncr5380_machine: unexpected disconnect.\\n\");\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\tact_flags |= (ACT_DISCONNECT | ACT_CMD_DONE);\n\t\tgoto do_actions;\n\t}\n\n\t/*\n\t * Wait for REQ before reading the phase.\n\t * Need to wait longer than usual here, because\n\t * some devices are just plain slow...\n\t */\n\ttimo = ncr5380_wait_phase_timo;\n\tfor (;;) {\n\t\tif (*sc->sci_bus_csr & SCI_BUS_REQ)\n\t\t\tbreak;\n\t\tif (--timo <= 0) {\n\t\t\tif (sc->sc_state & NCR_ABORTING) {\n\t\t\t\tprintf(\"%s: no REQ while aborting, reset\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tact_flags |= ACT_RESET_BUS;\n\t\t\t\tgoto do_actions;\n\t\t\t}\n\t\t\tprintf(\"%s: no REQ for next phase, abort\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tsc->sc_state |= NCR_ABORTING;\n\t\t\tncr_sched_msgout(sc, SEND_ABORT);\n\t\t\tgoto next_phase;\n\t\t}\n\t\tdelay(100);\n\t}\n\n\tphase = SCI_BUS_PHASE(*sc->sci_bus_csr);\n\tNCR_TRACE(\"machine: phase=%s\\n\",\n\t\t\t  (long) phase_names[phase & 7]);\n\n\t/*\n\t * We assume that the device knows what it's doing,\n\t * so any phase is good.\n\t */\n\n#if 0\n\t/*\n\t * XXX: Do not ACK the phase yet! do it later...\n\t * XXX: ... each phase routine does that itself.\n\t * In particular, DMA needs it done LATER.\n\t */\n\t*sc->sci_tcmd = phase;\t/* acknowledge phase change */\n#endif\n\n\tswitch (phase) {\n\n\tcase PHASE_DATA_OUT:\n\tcase PHASE_DATA_IN:\n\t\tact_flags = ncr5380_data_xfer(sc, phase);\n\t\tbreak;\n\n\tcase PHASE_COMMAND:\n\t\tact_flags = ncr5380_command(sc);\n\t\tbreak;\n\n\tcase PHASE_STATUS:\n\t\tact_flags = ncr5380_status(sc);\n\t\tbreak;\n\n\tcase PHASE_MSG_OUT:\n\t\tact_flags = ncr5380_msg_out(sc);\n\t\tbreak;\n\n\tcase PHASE_MSG_IN:\n\t\tact_flags = ncr5380_msg_in(sc);\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"ncr5380_machine: Unexpected phase 0x%x\\n\", phase);\n\t\tsc->sc_state |= NCR_ABORTING;\n\t\tncr_sched_msgout(sc, SEND_ABORT);\n\t\tgoto next_phase;\n\n\t} /* switch */\n\tsc->sc_prevphase = phase;\n\ndo_actions:\n\t__asm(\"_ncr5380_actions:\");\n\n\tif (act_flags & ACT_WAIT_DMA) {\n\t\tact_flags &= ~ACT_WAIT_DMA;\n\t\t/* Wait for DMA to complete (polling, or interrupt). */\n\t\tif ((sr->sr_flags & SR_IMMED) == 0) {\n\t\t\tNCR_TRACE(\"machine: wait for DMA intr.\\n\", 0);\n\t\t\treturn; \t/* will resume at dma_done */\n\t\t}\n\t\t/* Busy-wait for it to finish. */\n\t\tNCR_TRACE(\"machine: dma_poll, dh=0x%x\\n\",\n\t\t\t\t  (long) sr->sr_dma_hand);\n\t\t(*sc->sc_dma_poll)(sc);\n\tdma_done:\n\t\t/* Return here after interrupt. */\n\t\tif (sr->sr_flags & SR_OVERDUE)\n\t\t\tsc->sc_state |= NCR_ABORTING;\n\t\tNCR_TRACE(\"machine: dma_stop, dh=0x%x\\n\",\n\t\t\t\t  (long) sr->sr_dma_hand);\n\t\t(*sc->sc_dma_stop)(sc);\n\t\tSCI_CLR_INTR(sc);\t/* XXX */\n\t\t/*\n\t\t * While DMA is running we can not touch the SBC,\n\t\t * so various places just set NCR_ABORTING and\n\t\t * expect us the \"kick it\" when DMA is done.\n\t\t */\n\t\tif (sc->sc_state & NCR_ABORTING) {\n\t\t\tncr_sched_msgout(sc, SEND_ABORT);\n\t\t}\n\t}\n\n\t/*\n\t * Check for parity error.\n\t * XXX - better place to check?\n\t */\n\tif (*(sc->sci_csr) & SCI_CSR_PERR) {\n\t\tprintf(\"%s: parity error!\\n\", sc->sc_dev.dv_xname);\n\t\t/* XXX: sc->sc_state |= NCR_ABORTING; */\n\t\tncr_sched_msgout(sc, SEND_PARITY_ERROR);\n\t}\n\n\tif (act_flags == ACT_CONTINUE)\n\t\tgoto next_phase;\n\t/* All other actions \"break\" from the loop. */\n\n\tNCR_TRACE(\"machine: act_flags=0x%x\\n\", act_flags);\n\n\tif (act_flags & ACT_RESET_BUS) {\n\t\tact_flags |= ACT_CMD_DONE;\n\t\t/*\n\t\t * Reset the SCSI bus, usually due to a timeout.\n\t\t * The error code XS_TIMEOUT allows retries.\n\t\t */\n\t\tsc->sc_state |= NCR_ABORTING;\n\t\tprintf(\"%s: reset SCSI bus for TID=%d LUN=%d\\n\",\n\t\t    sc->sc_dev.dv_xname, sr->sr_target, sr->sr_lun);\n\t\tncr5380_reset_scsibus(sc);\n\t}\n\n\tif (act_flags & ACT_CMD_DONE) {\n\t\tact_flags |= ACT_DISCONNECT;\n\t\t/* Need to call scsi_done() */\n\t\t/* XXX: from the aic6360 driver, but why? */\n\t\tif (sc->sc_datalen < 0) {\n\t\t\tprintf(\"%s: %d extra bytes from %d:%d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, -sc->sc_datalen,\n\t\t\t    sr->sr_target, sr->sr_lun);\n\t\t\tsc->sc_datalen = 0;\n\t\t}\n\t\txs->resid = sc->sc_datalen;\n\t\t/* Note: this will clear sc_current */\n\t\tNCR_TRACE(\"machine: call done, cur=0x%x\\n\", (long)sr);\n\t\tncr5380_done(sc);\n\t}\n\n\tif (act_flags & ACT_DISCONNECT) {\n\t\t/*\n\t\t * The device has dropped BSY (or will soon).\n\t\t * We have to wait here for BSY to drop, otherwise\n\t\t * the next command may decide we need a bus reset.\n\t\t */\n\t\ttimo = ncr5380_wait_req_timo;\t/* XXX */\n\t\tfor (;;) {\n\t\t\tif (!SCI_BUSY(sc))\n\t\t\t\tgoto busfree;\n\t\t\tif (--timo <= 0)\n\t\t\t\tbreak;\n\t\t\tdelay(2);\n\t\t}\n\t\t/* Device is sitting on the bus! */\n\t\tprintf(\"%s: Target %d LUN %d stuck busy, resetting...\\n\",\n\t\t    sc->sc_dev.dv_xname, sr->sr_target, sr->sr_lun);\n\t\tncr5380_reset_scsibus(sc);\n\tbusfree:\n\t\tNCR_TRACE(\"machine: discon, waited %d\\n\",\n\t\t\tncr5380_wait_nrq_timo - timo);\n\n\t\t*sc->sci_icmd = 0;\n\t\t*sc->sci_mode = 0;\n\t\t*sc->sci_tcmd = PHASE_INVALID;\n\t\t*sc->sci_sel_enb = 0;\n\t\tSCI_CLR_INTR(sc);\n\t\t*sc->sci_sel_enb = 0x80;\n\n\t\tif ((act_flags & ACT_CMD_DONE) == 0) {\n\t\t\t__asm(\"_ncr5380_disconnected:\");\n\t\t\tNCR_TRACE(\"machine: discon, cur=0x%x\\n\", (long)sr);\n\t\t}\n\n\t\t/*\n\t\t * We may be here due to a disconnect message,\n\t\t * in which case we did NOT call ncr5380_done,\n\t\t * and we need to clear sc_current.\n\t\t */\n\t\tsc->sc_state = NCR_IDLE;\n\t\tsc->sc_current = NULL;\n\n\t\t/* Paranoia: clear everything. */\n\t\tsc->sc_dataptr = NULL;\n\t\tsc->sc_datalen = 0;\n\t\tsc->sc_prevphase = PHASE_INVALID;\n\t\tsc->sc_msgpriq = 0;\n\t\tsc->sc_msgoutq = 0;\n\t\tsc->sc_msgout  = 0;\n\n\t\t/* Our caller will re-enable interrupts. */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"sched: call machine, cur=0x%x\\n\"",
            "(long) sc->sc_current"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "ncr5380_cmd_timeout",
            "sr",
            "i"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_cmd_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "518-578",
          "snippet": "void\nncr5380_cmd_timeout(arg)\n\tvoid *arg;\n{\n\tstruct sci_req *sr = arg;\n\tstruct scsi_xfer *xs;\n\tstruct scsi_link *sc_link;\n\tstruct ncr5380_softc *sc;\n\tint s;\n\n\ts = splbio();\n\n\t/* Get all our variables... */\n\txs = sr->sr_xs;\n\tif (xs == NULL) {\n\t\tprintf(\"ncr5380_cmd_timeout: no scsi_xfer\\n\");\n\t\tgoto out;\n\t}\n\tsc_link = xs->sc_link;\n\tsc = sc_link->adapter_softc;\n\n\tprintf(\"%s: cmd timeout, targ=%d, lun=%d\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    sr->sr_target, sr->sr_lun);\n\n\t/*\n\t * Mark the overdue job as failed, and arrange for\n\t * ncr5380_machine to terminate it.  If the victim\n\t * is the current job, call ncr5380_machine() now.\n\t * Otherwise arrange for ncr5380_sched() to do it.\n\t */\n\tsr->sr_flags |= SR_OVERDUE;\n\tif (sc->sc_current == sr) {\n\t\tNCR_TRACE(\"cmd_tmo: call abort, sr=0x%x\\n\", (long) sr);\n\t\tncr5380_abort(sc);\n\t} else {\n\t\t/*\n\t\t * The driver may be idle, or busy with another job.\n\t\t * Arrange for ncr5380_sched() to do the deed.\n\t\t */\n\t\tNCR_TRACE(\"cmd_tmo: clear matrix, t/l=0x%02x\\n\",\n\t\t\t\t  (sr->sr_target << 4) | sr->sr_lun);\n\t\tsc->sc_matrix[sr->sr_target][sr->sr_lun] = NULL;\n\t}\n\n\t/*\n\t * We may have aborted the current job, or may have\n\t * already been idle. In either case, we should now\n\t * be idle, so try to start another job.\n\t */\n\tif (sc->sc_state == NCR_IDLE) {\n\t\tNCR_TRACE(\"cmd_tmo: call sched, cur=0x%x\\n\",\n\t\t\t\t  (long) sc->sc_current);\n\t\tncr5380_sched(sc);\n\t\tNCR_TRACE(\"cmd_tmo: sched done, cur=0x%x\\n\",\n\t\t\t\t  (long) sc->sc_current);\n\t}\n\nout:\n\tsplx(s);\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tncr5380_sched",
            "static void\tncr5380_machine",
            "void\tncr5380_abort",
            "void\tncr5380_cmd_timeout"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void\tncr5380_sched;\nstatic void\tncr5380_machine;\nvoid\tncr5380_abort;\nvoid\tncr5380_cmd_timeout;\n\nvoid\nncr5380_cmd_timeout(arg)\n\tvoid *arg;\n{\n\tstruct sci_req *sr = arg;\n\tstruct scsi_xfer *xs;\n\tstruct scsi_link *sc_link;\n\tstruct ncr5380_softc *sc;\n\tint s;\n\n\ts = splbio();\n\n\t/* Get all our variables... */\n\txs = sr->sr_xs;\n\tif (xs == NULL) {\n\t\tprintf(\"ncr5380_cmd_timeout: no scsi_xfer\\n\");\n\t\tgoto out;\n\t}\n\tsc_link = xs->sc_link;\n\tsc = sc_link->adapter_softc;\n\n\tprintf(\"%s: cmd timeout, targ=%d, lun=%d\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    sr->sr_target, sr->sr_lun);\n\n\t/*\n\t * Mark the overdue job as failed, and arrange for\n\t * ncr5380_machine to terminate it.  If the victim\n\t * is the current job, call ncr5380_machine() now.\n\t * Otherwise arrange for ncr5380_sched() to do it.\n\t */\n\tsr->sr_flags |= SR_OVERDUE;\n\tif (sc->sc_current == sr) {\n\t\tNCR_TRACE(\"cmd_tmo: call abort, sr=0x%x\\n\", (long) sr);\n\t\tncr5380_abort(sc);\n\t} else {\n\t\t/*\n\t\t * The driver may be idle, or busy with another job.\n\t\t * Arrange for ncr5380_sched() to do the deed.\n\t\t */\n\t\tNCR_TRACE(\"cmd_tmo: clear matrix, t/l=0x%02x\\n\",\n\t\t\t\t  (sr->sr_target << 4) | sr->sr_lun);\n\t\tsc->sc_matrix[sr->sr_target][sr->sr_lun] = NULL;\n\t}\n\n\t/*\n\t * We may have aborted the current job, or may have\n\t * already been idle. In either case, we should now\n\t * be idle, so try to start another job.\n\t */\n\tif (sc->sc_state == NCR_IDLE) {\n\t\tNCR_TRACE(\"cmd_tmo: call sched, cur=0x%x\\n\",\n\t\t\t\t  (long) sc->sc_current);\n\t\tncr5380_sched(sc);\n\t\tNCR_TRACE(\"cmd_tmo: sched done, cur=0x%x\\n\",\n\t\t\t\t  (long) sc->sc_current);\n\t}\n\nout:\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"sched: set timeout=%d\\n\"",
            "i"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->sc_dma_setup",
          "args": [
            "sc"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"sched: dma_setup, dh=0x%x\\n\"",
            "(long) sr->sr_dma_hand"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"sched: dma_alloc, len=%d\\n\"",
            "sc->sc_datalen"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_BREAK",
          "args": [],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: ptr but no data in/out flags?\\n\"",
            "sc->sc_dev.dv_xname"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"sched: cmd=reset, sr=0x%x\\n\"",
            "(long)sr"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr5380_show_scsi_cmd",
          "args": [
            "xs"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_show_scsi_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "2438-2459",
          "snippet": "static void\nncr5380_show_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tu_char\t*b = (u_char *) xs->cmd;\n\tint\ti  = 0;\n\n\tif ( ! ( xs->flags & SCSI_RESET ) ) {\n\t\tprintf(\"si(%d:%d:%d)-\",\n\t\t    xs->sc_link->scsibus, xs->sc_link->target,\n\t\t    xs->sc_link->lun);\n\t\twhile (i < xs->cmdlen) {\n\t\t\tif (i) printf(\",\");\n\t\t\tprintf(\"%x\",b[i++]);\n\t\t}\n\t\tprintf(\"-\\n\");\n\t} else {\n\t\tprintf(\"si(%d:%d:%d)-RESET-\\n\",\n\t\t    xs->sc_link->scsibus, xs->sc_link->target,\n\t\t    xs->sc_link->lun);\n\t}\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void\nncr5380_show_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tu_char\t*b = (u_char *) xs->cmd;\n\tint\ti  = 0;\n\n\tif ( ! ( xs->flags & SCSI_RESET ) ) {\n\t\tprintf(\"si(%d:%d:%d)-\",\n\t\t    xs->sc_link->scsibus, xs->sc_link->target,\n\t\t    xs->sc_link->lun);\n\t\twhile (i < xs->cmdlen) {\n\t\t\tif (i) printf(\",\");\n\t\t\tprintf(\"%x\",b[i++]);\n\t\t}\n\t\tprintf(\"-\\n\");\n\t} else {\n\t\tprintf(\"si(%d:%d:%d)-RESET-\\n\",\n\t\t    xs->sc_link->scsibus, xs->sc_link->target,\n\t\t    xs->sc_link->lun);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"sched: get sense, sr=0x%x\\n\"",
            "(long)sr"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"sched: overdue, sr=0x%x\\n\"",
            "(long)sr"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr5380_done",
          "args": [
            "sc"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "696-818",
          "snippet": "static void\nncr5380_done(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tstruct\tsci_req *sr;\n\tstruct\tscsi_xfer *xs;\n\n#ifdef\tDIAGNOSTIC\n\tif (sc->sc_state == NCR_IDLE)\n\t\tpanic(\"ncr5380_done: state=idle\");\n\tif (sc->sc_current == NULL)\n\t\tpanic(\"ncr5380_done: current=0\");\n#endif\n\n\tsr = sc->sc_current;\n\txs = sr->sr_xs;\n\n\tNCR_TRACE(\"done: top, cur=0x%x\\n\", (long) sc->sc_current);\n\n\t/*\n\t * Clean up DMA resources for this command.\n\t */\n\tif (sr->sr_dma_hand) {\n\t\tNCR_TRACE(\"done: dma_free, dh=0x%x\\n\",\n\t\t\t\t  (long) sr->sr_dma_hand);\n\t\t(*sc->sc_dma_free)(sc);\n\t}\n#ifdef\tDIAGNOSTIC\n\tif (sr->sr_dma_hand)\n\t\tpanic(\"ncr5380_done: dma free did not\");\n#endif\n\n\tif (sc->sc_state & NCR_ABORTING) {\n\t\tNCR_TRACE(\"done: aborting, error=%d\\n\", xs->error);\n\t\tif (xs->error == XS_NOERROR)\n\t\t\txs->error = XS_TIMEOUT;\n\t}\n\n\tNCR_TRACE(\"done: check error=%d\\n\", (long) xs->error);\n\n\t/* If error is already set, ignore sr_status value. */\n\tif (xs->error != XS_NOERROR)\n\t\tgoto finish;\n\n\tNCR_TRACE(\"done: check status=%d\\n\", sr->sr_status);\n\n\tswitch (sr->sr_status) {\n\tcase SCSI_OK:\t/* 0 */\n\t\tif (sr->sr_flags & SR_SENSE) {\n#ifdef\tNCR5380_DEBUG\n\t\t\tif (ncr5380_debug & NCR_DBG_CMDS) {\n\t\t\t\tncr5380_show_sense(xs);\n\t\t\t}\n#endif\n\t\t\txs->error = XS_SENSE;\n\t\t}\n\t\tbreak;\n\n\tcase SCSI_CHECK:\n\t\tif (sr->sr_flags & SR_SENSE) {\n\t\t\t/* Sense command also asked for sense? */\n\t\t\tprintf(\"ncr5380_done: sense asked for sense\\n\");\n\t\t\tNCR_BREAK();\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\tbreak;\n\t\t}\n\t\tsr->sr_flags |= SR_SENSE;\n\t\tNCR_TRACE(\"done: get sense, sr=0x%x\\n\", (long) sr);\n\t\t/*\n\t\t * Leave queued, but clear sc_current so we start over\n\t\t * with selection.  Guaranteed to get the same request.\n\t\t */\n\t\tsc->sc_state = NCR_IDLE;\n\t\tsc->sc_current = NULL;\n\t\tsc->sc_matrix[sr->sr_target][sr->sr_lun] = NULL;\n\t\treturn;\t\t/* XXX */\n\n\tcase SCSI_BUSY:\n\t\txs->error = XS_BUSY;\n\t\tbreak;\n\n\tcase -1:\n\t\t/* This is our \"impossible\" initial value. */\n\t\t/* fallthrough */\n\tdefault:\n\t\tprintf(\"%s: target %d, bad status=%d\\n\",\n\t\t    sc->sc_dev.dv_xname, sr->sr_target, sr->sr_status);\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\tbreak;\n\t}\n\nfinish:\n\n\tNCR_TRACE(\"done: finish, error=%d\\n\", xs->error);\n\n\t/*\n\t * Dequeue the finished command, but don't clear sc_state until\n\t * after the call to scsi_done(), because that may call back to\n\t * ncr5380_scsi_cmd() - unwanted recursion!\n\t *\n\t * Keeping sc->sc_state != idle terminates the recursion.\n\t */\n#ifdef\tDIAGNOSTIC\n\tif ((sc->sc_state & NCR_WORKING) == 0)\n\t\tpanic(\"ncr5380_done: bad state\");\n#endif\n\n\t/* Clear our pointers to the request. */\n\tsc->sc_current = NULL;\n\tsc->sc_matrix[sr->sr_target][sr->sr_lun] = NULL;\n\tuntimeout(ncr5380_cmd_timeout, sr);\n\n\t/* Make the request free. */\n\tsr->sr_xs = NULL;\n\tsc->sc_ncmds--;\n\n\t/* Tell common SCSI code it is done. */\n\txs->flags |= ITSDONE;\n\tscsi_done(xs);\n\n\tsc->sc_state = NCR_IDLE;\n\t/* Now ncr5380_sched() may be called again. */\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tNCR_DBG_CMDS\t2"
          ],
          "globals_used": [
            "static void\tncr5380_sched",
            "static void\tncr5380_done",
            "void\tncr5380_cmd_timeout"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tNCR_DBG_CMDS\t2\n\nstatic void\tncr5380_sched;\nstatic void\tncr5380_done;\nvoid\tncr5380_cmd_timeout;\n\nstatic void\nncr5380_done(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tstruct\tsci_req *sr;\n\tstruct\tscsi_xfer *xs;\n\n#ifdef\tDIAGNOSTIC\n\tif (sc->sc_state == NCR_IDLE)\n\t\tpanic(\"ncr5380_done: state=idle\");\n\tif (sc->sc_current == NULL)\n\t\tpanic(\"ncr5380_done: current=0\");\n#endif\n\n\tsr = sc->sc_current;\n\txs = sr->sr_xs;\n\n\tNCR_TRACE(\"done: top, cur=0x%x\\n\", (long) sc->sc_current);\n\n\t/*\n\t * Clean up DMA resources for this command.\n\t */\n\tif (sr->sr_dma_hand) {\n\t\tNCR_TRACE(\"done: dma_free, dh=0x%x\\n\",\n\t\t\t\t  (long) sr->sr_dma_hand);\n\t\t(*sc->sc_dma_free)(sc);\n\t}\n#ifdef\tDIAGNOSTIC\n\tif (sr->sr_dma_hand)\n\t\tpanic(\"ncr5380_done: dma free did not\");\n#endif\n\n\tif (sc->sc_state & NCR_ABORTING) {\n\t\tNCR_TRACE(\"done: aborting, error=%d\\n\", xs->error);\n\t\tif (xs->error == XS_NOERROR)\n\t\t\txs->error = XS_TIMEOUT;\n\t}\n\n\tNCR_TRACE(\"done: check error=%d\\n\", (long) xs->error);\n\n\t/* If error is already set, ignore sr_status value. */\n\tif (xs->error != XS_NOERROR)\n\t\tgoto finish;\n\n\tNCR_TRACE(\"done: check status=%d\\n\", sr->sr_status);\n\n\tswitch (sr->sr_status) {\n\tcase SCSI_OK:\t/* 0 */\n\t\tif (sr->sr_flags & SR_SENSE) {\n#ifdef\tNCR5380_DEBUG\n\t\t\tif (ncr5380_debug & NCR_DBG_CMDS) {\n\t\t\t\tncr5380_show_sense(xs);\n\t\t\t}\n#endif\n\t\t\txs->error = XS_SENSE;\n\t\t}\n\t\tbreak;\n\n\tcase SCSI_CHECK:\n\t\tif (sr->sr_flags & SR_SENSE) {\n\t\t\t/* Sense command also asked for sense? */\n\t\t\tprintf(\"ncr5380_done: sense asked for sense\\n\");\n\t\t\tNCR_BREAK();\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\tbreak;\n\t\t}\n\t\tsr->sr_flags |= SR_SENSE;\n\t\tNCR_TRACE(\"done: get sense, sr=0x%x\\n\", (long) sr);\n\t\t/*\n\t\t * Leave queued, but clear sc_current so we start over\n\t\t * with selection.  Guaranteed to get the same request.\n\t\t */\n\t\tsc->sc_state = NCR_IDLE;\n\t\tsc->sc_current = NULL;\n\t\tsc->sc_matrix[sr->sr_target][sr->sr_lun] = NULL;\n\t\treturn;\t\t/* XXX */\n\n\tcase SCSI_BUSY:\n\t\txs->error = XS_BUSY;\n\t\tbreak;\n\n\tcase -1:\n\t\t/* This is our \"impossible\" initial value. */\n\t\t/* fallthrough */\n\tdefault:\n\t\tprintf(\"%s: target %d, bad status=%d\\n\",\n\t\t    sc->sc_dev.dv_xname, sr->sr_target, sr->sr_status);\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\tbreak;\n\t}\n\nfinish:\n\n\tNCR_TRACE(\"done: finish, error=%d\\n\", xs->error);\n\n\t/*\n\t * Dequeue the finished command, but don't clear sc_state until\n\t * after the call to scsi_done(), because that may call back to\n\t * ncr5380_scsi_cmd() - unwanted recursion!\n\t *\n\t * Keeping sc->sc_state != idle terminates the recursion.\n\t */\n#ifdef\tDIAGNOSTIC\n\tif ((sc->sc_state & NCR_WORKING) == 0)\n\t\tpanic(\"ncr5380_done: bad state\");\n#endif\n\n\t/* Clear our pointers to the request. */\n\tsc->sc_current = NULL;\n\tsc->sc_matrix[sr->sr_target][sr->sr_lun] = NULL;\n\tuntimeout(ncr5380_cmd_timeout, sr);\n\n\t/* Make the request free. */\n\tsr->sr_xs = NULL;\n\tsc->sc_ncmds--;\n\n\t/* Tell common SCSI code it is done. */\n\txs->flags |= ITSDONE;\n\tscsi_done(xs);\n\n\tsc->sc_state = NCR_IDLE;\n\t/* Now ncr5380_sched() may be called again. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"sched: call done, sr=0x%x\\n\"",
            "(long)sr"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr5380_reset_scsibus",
          "args": [
            "sc"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_reset_scsibus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "391-411",
          "snippet": "void\nncr5380_reset_scsibus(sc)\n\tstruct ncr5380_softc *sc;\n{\n\n\tNCR_TRACE(\"reset_scsibus, cur=0x%x\\n\",\n\t\t\t  (long) sc->sc_current);\n\n\t*sc->sci_icmd = SCI_ICMD_RST;\n\tdelay(500);\n\t*sc->sci_icmd = 0;\n\n\t*sc->sci_mode = 0;\n\t*sc->sci_tcmd = PHASE_INVALID;\n\n\tSCI_CLR_INTR(sc);\n\t/* XXX - Need long delay here! */\n\tdelay(100000);\n\n\t/* XXX - Need to cancel disconnected requests. */\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\nncr5380_reset_scsibus(sc)\n\tstruct ncr5380_softc *sc;\n{\n\n\tNCR_TRACE(\"reset_scsibus, cur=0x%x\\n\",\n\t\t\t  (long) sc->sc_current);\n\n\t*sc->sci_icmd = SCI_ICMD_RST;\n\tdelay(500);\n\t*sc->sci_icmd = 0;\n\n\t*sc->sci_mode = 0;\n\t*sc->sci_tcmd = PHASE_INVALID;\n\n\tSCI_CLR_INTR(sc);\n\t/* XXX - Need long delay here! */\n\tdelay(100000);\n\n\t/* XXX - Need to cancel disconnected requests. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"sched: select rv=%d\\n\"",
            "error"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"sched: reselect, new sr=0x%x\\n\"",
            "(long)sr"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr5380_select",
          "args": [
            "sc",
            "sr"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_select",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "1309-1506",
          "snippet": "static int\nncr5380_select(sc, sr)\n\tstruct ncr5380_softc *sc;\n\tstruct sci_req *sr;\n{\n\tint timo, s, target_mask;\n\tu_char data, icmd;\n\n\t/* Check for reselect */\n\tncr5380_reselect(sc);\n\tif (sc->sc_current) {\n\t\tNCR_TRACE(\"select: reselect, cur=0x%x\\n\",\n\t\t\t\t  (long) sc->sc_current);\n\t\treturn XS_BUSY;\t/* reselected */\n\t}\n\n\t/*\n\t * Set phase bits to 0, otherwise the 5380 won't drive the bus during\n\t * selection.\n\t */\n\t*sc->sci_tcmd = PHASE_DATA_OUT;\n\t*sc->sci_icmd = icmd = 0;\n\t*sc->sci_mode = 0;\n\n\t/*\n\t * Arbitrate for the bus.  The 5380 takes care of the\n\t * time-critical bus interactions.  We set our ID bit\n\t * in the output data register and set MODE_ARB.  The\n\t * 5380 watches for the required \"bus free\" period.\n\t * If and when the \"bus free\" period is detected, the\n\t * 5380 drives BSY, drives the data bus, and sets the\n\t * \"arbitration in progress\" (AIP) bit to let us know\n\t * arbitration has started (and that it asserts BSY).\n\t * We then wait for one arbitration delay (2.2uS) and\n\t * check the ICMD_LST bit, which will be set if some\n\t * other target drives SEL during arbitration.\n\t *\n\t * There is a time-critical section during the period\n\t * after we enter arbitration up until we assert SEL.\n\t * Avoid long interrupts during this period.\n\t */\n\ts = splimp();\t/* XXX: Begin time-critical section */\n\n\t*(sc->sci_odata) = 0x80;\t/* OUR_ID */\n\t*(sc->sci_mode) = SCI_MODE_ARB;\n\n#define\tWAIT_AIP_USEC\t20\t/* pleanty of time */\n\t/* Wait for the AIP bit to turn on. */\n\ttimo = WAIT_AIP_USEC;\n\tfor (;;) {\n\t\tif (*(sc->sci_icmd) & SCI_ICMD_AIP)\n\t\t\tbreak;\n\t\tif (timo <= 0) {\n\t\t\t/*\n\t\t\t * Did not see any \"bus free\" period.\n\t\t\t * The usual reason is a reselection,\n\t\t\t * so treat this as arbitration loss.\n\t\t\t */\n\t\t\tNCR_TRACE(\"select: bus busy, rc=%d\\n\", XS_BUSY);\n\t\t\tgoto lost_arb;\n\t\t}\n\t\ttimo -= 2;\n\t\tdelay(2);\n\t}\n\tNCR_TRACE(\"select: have AIP after %d uSec.\\n\",\n\t\t\t  WAIT_AIP_USEC - timo);\n\n\t/* Got AIP.  Wait one arbitration delay (2.2 uS.) */\n\tdelay(3);\n\n\t/* Check for ICMD_LST */\n\tif (*(sc->sci_icmd) & SCI_ICMD_LST) {\n\t\t/* Some other target asserted SEL. */\n\t\tNCR_TRACE(\"select: lost one, rc=%d\\n\", XS_BUSY);\n\t\tgoto lost_arb;\n\t}\n\n\t/*\n\t * No other device has declared itself the winner.\n\t * The spec. says to check for higher IDs, but we\n\t * are always the highest (ID=7) so don't bother.\n\t * We can now declare victory by asserting SEL.\n\t *\n\t * Note that the 5380 is asserting BSY because we\n\t * have entered arbitration mode.  We will now hold\n\t * BSY directly so we can turn off ARB mode.\n\t */\n\ticmd = (SCI_ICMD_BSY | SCI_ICMD_SEL);\n\t*sc->sci_icmd = icmd;\n\n\t/*\n\t * \"The SCSI device that wins arbitration shall wait\n\t *  at least a bus clear delay plus a bus settle delay\n\t *  after asserting the SEL signal before changing\n\t *  any [other] signal.\"  (1.2uS. total)\n\t */\n\tdelay(2);\n\n\t/*\n\t * Check one last time to see if we really did\n\t * win arbitration.  This might only happen if\n\t * there can be a higher selection ID than ours.\n\t * Keep this code for reference anyway...\n\t */\n\tif (*(sc->sci_icmd) & SCI_ICMD_LST) {\n\t\t/* Some other target asserted SEL. */\n\t\tNCR_TRACE(\"select: lost two, rc=%d\\n\", XS_BUSY);\n\n\tlost_arb:\n\t\t*sc->sci_icmd = 0;\n\t\t*sc->sci_mode = 0;\n\n\t\tsplx(s);\t/* XXX: End of time-critical section. */\n\n\t\t/*\n\t\t * When we lose arbitration, it usually means\n\t\t * there is a target trying to reselect us.\n\t\t */\n\t\tncr5380_reselect(sc);\n\t\treturn XS_BUSY;\n\t}\n\n\t/* Leave ARB mode Now that we drive BSY+SEL */\n\t*sc->sci_mode = 0;\n\t*sc->sci_sel_enb = 0;\n\n\tsplx(s);\t/* XXX: End of time-critical section. */\n\n\t/*\n\t * Arbitration is complete.  Now do selection:\n\t * Drive the data bus with the ID bits for both\n\t * the host and target.  Also set ATN now, to\n\t * ask the target for a message out phase.\n\t */\n\ttarget_mask = (1 << sr->sr_target);\n\tdata = 0x80 | target_mask;\n\t*(sc->sci_odata) = data;\n\ticmd |= (SCI_ICMD_DATA | SCI_ICMD_ATN);\n\t*(sc->sci_icmd) = icmd;\n\tdelay(2);\t/* two deskew delays. */\n\n\t/* De-assert BSY (targets sample the data now). */\n\ticmd &= ~SCI_ICMD_BSY;\n\t*(sc->sci_icmd) = icmd;\n\tdelay(3);\t/* Bus settle delay. */\n\n\t/*\n\t * Wait for the target to assert BSY.\n\t * SCSI spec. says wait for 250 mS.\n\t */\n\tfor (timo = 25000;;) {\n\t\tif (*sc->sci_bus_csr & SCI_BUS_BSY)\n\t\t\tgoto success;\n\t\tif (--timo <= 0)\n\t\t\tbreak;\n\t\tdelay(10);\n\t}\n\n\t/*\n\t * There is no reaction from the target.  Start the selection\n\t * timeout procedure. We release the databus but keep SEL+ATN\n\t * asserted. After that we wait a 'selection abort time' (200\n\t * usecs) and 2 deskew delays (90 ns) and check BSY again.\n\t * When BSY is asserted, we assume the selection succeeded,\n\t * otherwise we release the bus.\n\t */\n\ticmd &= ~SCI_ICMD_DATA;\n\t*(sc->sci_icmd) = icmd;\n\tdelay(201);\n\tif ((*sc->sci_bus_csr & SCI_BUS_BSY) == 0) {\n\t\t/* Really no device on bus */\n\t\t*sc->sci_tcmd = PHASE_INVALID;\n\t\t*sc->sci_icmd = 0;\n\t\t*sc->sci_mode = 0;\n\t\t*sc->sci_sel_enb = 0;\n\t\tSCI_CLR_INTR(sc);\n\t\t*sc->sci_sel_enb = 0x80;\n\t\tNCR_TRACE(\"select: device down, rc=%d\\n\", XS_SELTIMEOUT);\n\t\treturn XS_SELTIMEOUT;\n\t}\n\nsuccess:\n\t/*\n\t * The target is now driving BSY, so we can stop\n\t * driving SEL and the data bus (keep ATN true).\n\t * Configure the ncr5380 to monitor BSY, parity.\n\t */\n\ticmd &= ~(SCI_ICMD_DATA | SCI_ICMD_SEL);\n\t*sc->sci_icmd = icmd;\n\n\t/* If this target's bit is set, do NOT check parity. */\n\tif (sc->sc_parity_disable & target_mask)\n\t\t*sc->sci_mode = (SCI_MODE_MONBSY);\n\telse\n\t\t*sc->sci_mode = (SCI_MODE_MONBSY | SCI_MODE_PAR_CHK);\n\n\treturn XS_NOERROR;\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tWAIT_AIP_USEC\t20\t/* pleanty of time */"
          ],
          "globals_used": [
            "static int\tncr5380_select",
            "static void\tncr5380_reselect"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tWAIT_AIP_USEC\t20\t/* pleanty of time */\n\nstatic int\tncr5380_select;\nstatic void\tncr5380_reselect;\n\nstatic int\nncr5380_select(sc, sr)\n\tstruct ncr5380_softc *sc;\n\tstruct sci_req *sr;\n{\n\tint timo, s, target_mask;\n\tu_char data, icmd;\n\n\t/* Check for reselect */\n\tncr5380_reselect(sc);\n\tif (sc->sc_current) {\n\t\tNCR_TRACE(\"select: reselect, cur=0x%x\\n\",\n\t\t\t\t  (long) sc->sc_current);\n\t\treturn XS_BUSY;\t/* reselected */\n\t}\n\n\t/*\n\t * Set phase bits to 0, otherwise the 5380 won't drive the bus during\n\t * selection.\n\t */\n\t*sc->sci_tcmd = PHASE_DATA_OUT;\n\t*sc->sci_icmd = icmd = 0;\n\t*sc->sci_mode = 0;\n\n\t/*\n\t * Arbitrate for the bus.  The 5380 takes care of the\n\t * time-critical bus interactions.  We set our ID bit\n\t * in the output data register and set MODE_ARB.  The\n\t * 5380 watches for the required \"bus free\" period.\n\t * If and when the \"bus free\" period is detected, the\n\t * 5380 drives BSY, drives the data bus, and sets the\n\t * \"arbitration in progress\" (AIP) bit to let us know\n\t * arbitration has started (and that it asserts BSY).\n\t * We then wait for one arbitration delay (2.2uS) and\n\t * check the ICMD_LST bit, which will be set if some\n\t * other target drives SEL during arbitration.\n\t *\n\t * There is a time-critical section during the period\n\t * after we enter arbitration up until we assert SEL.\n\t * Avoid long interrupts during this period.\n\t */\n\ts = splimp();\t/* XXX: Begin time-critical section */\n\n\t*(sc->sci_odata) = 0x80;\t/* OUR_ID */\n\t*(sc->sci_mode) = SCI_MODE_ARB;\n\n#define\tWAIT_AIP_USEC\t20\t/* pleanty of time */\n\t/* Wait for the AIP bit to turn on. */\n\ttimo = WAIT_AIP_USEC;\n\tfor (;;) {\n\t\tif (*(sc->sci_icmd) & SCI_ICMD_AIP)\n\t\t\tbreak;\n\t\tif (timo <= 0) {\n\t\t\t/*\n\t\t\t * Did not see any \"bus free\" period.\n\t\t\t * The usual reason is a reselection,\n\t\t\t * so treat this as arbitration loss.\n\t\t\t */\n\t\t\tNCR_TRACE(\"select: bus busy, rc=%d\\n\", XS_BUSY);\n\t\t\tgoto lost_arb;\n\t\t}\n\t\ttimo -= 2;\n\t\tdelay(2);\n\t}\n\tNCR_TRACE(\"select: have AIP after %d uSec.\\n\",\n\t\t\t  WAIT_AIP_USEC - timo);\n\n\t/* Got AIP.  Wait one arbitration delay (2.2 uS.) */\n\tdelay(3);\n\n\t/* Check for ICMD_LST */\n\tif (*(sc->sci_icmd) & SCI_ICMD_LST) {\n\t\t/* Some other target asserted SEL. */\n\t\tNCR_TRACE(\"select: lost one, rc=%d\\n\", XS_BUSY);\n\t\tgoto lost_arb;\n\t}\n\n\t/*\n\t * No other device has declared itself the winner.\n\t * The spec. says to check for higher IDs, but we\n\t * are always the highest (ID=7) so don't bother.\n\t * We can now declare victory by asserting SEL.\n\t *\n\t * Note that the 5380 is asserting BSY because we\n\t * have entered arbitration mode.  We will now hold\n\t * BSY directly so we can turn off ARB mode.\n\t */\n\ticmd = (SCI_ICMD_BSY | SCI_ICMD_SEL);\n\t*sc->sci_icmd = icmd;\n\n\t/*\n\t * \"The SCSI device that wins arbitration shall wait\n\t *  at least a bus clear delay plus a bus settle delay\n\t *  after asserting the SEL signal before changing\n\t *  any [other] signal.\"  (1.2uS. total)\n\t */\n\tdelay(2);\n\n\t/*\n\t * Check one last time to see if we really did\n\t * win arbitration.  This might only happen if\n\t * there can be a higher selection ID than ours.\n\t * Keep this code for reference anyway...\n\t */\n\tif (*(sc->sci_icmd) & SCI_ICMD_LST) {\n\t\t/* Some other target asserted SEL. */\n\t\tNCR_TRACE(\"select: lost two, rc=%d\\n\", XS_BUSY);\n\n\tlost_arb:\n\t\t*sc->sci_icmd = 0;\n\t\t*sc->sci_mode = 0;\n\n\t\tsplx(s);\t/* XXX: End of time-critical section. */\n\n\t\t/*\n\t\t * When we lose arbitration, it usually means\n\t\t * there is a target trying to reselect us.\n\t\t */\n\t\tncr5380_reselect(sc);\n\t\treturn XS_BUSY;\n\t}\n\n\t/* Leave ARB mode Now that we drive BSY+SEL */\n\t*sc->sci_mode = 0;\n\t*sc->sci_sel_enb = 0;\n\n\tsplx(s);\t/* XXX: End of time-critical section. */\n\n\t/*\n\t * Arbitration is complete.  Now do selection:\n\t * Drive the data bus with the ID bits for both\n\t * the host and target.  Also set ATN now, to\n\t * ask the target for a message out phase.\n\t */\n\ttarget_mask = (1 << sr->sr_target);\n\tdata = 0x80 | target_mask;\n\t*(sc->sci_odata) = data;\n\ticmd |= (SCI_ICMD_DATA | SCI_ICMD_ATN);\n\t*(sc->sci_icmd) = icmd;\n\tdelay(2);\t/* two deskew delays. */\n\n\t/* De-assert BSY (targets sample the data now). */\n\ticmd &= ~SCI_ICMD_BSY;\n\t*(sc->sci_icmd) = icmd;\n\tdelay(3);\t/* Bus settle delay. */\n\n\t/*\n\t * Wait for the target to assert BSY.\n\t * SCSI spec. says wait for 250 mS.\n\t */\n\tfor (timo = 25000;;) {\n\t\tif (*sc->sci_bus_csr & SCI_BUS_BSY)\n\t\t\tgoto success;\n\t\tif (--timo <= 0)\n\t\t\tbreak;\n\t\tdelay(10);\n\t}\n\n\t/*\n\t * There is no reaction from the target.  Start the selection\n\t * timeout procedure. We release the databus but keep SEL+ATN\n\t * asserted. After that we wait a 'selection abort time' (200\n\t * usecs) and 2 deskew delays (90 ns) and check BSY again.\n\t * When BSY is asserted, we assume the selection succeeded,\n\t * otherwise we release the bus.\n\t */\n\ticmd &= ~SCI_ICMD_DATA;\n\t*(sc->sci_icmd) = icmd;\n\tdelay(201);\n\tif ((*sc->sci_bus_csr & SCI_BUS_BSY) == 0) {\n\t\t/* Really no device on bus */\n\t\t*sc->sci_tcmd = PHASE_INVALID;\n\t\t*sc->sci_icmd = 0;\n\t\t*sc->sci_mode = 0;\n\t\t*sc->sci_sel_enb = 0;\n\t\tSCI_CLR_INTR(sc);\n\t\t*sc->sci_sel_enb = 0x80;\n\t\tNCR_TRACE(\"select: device down, rc=%d\\n\", XS_SELTIMEOUT);\n\t\treturn XS_SELTIMEOUT;\n\t}\n\nsuccess:\n\t/*\n\t * The target is now driving BSY, so we can stop\n\t * driving SEL and the data bus (keep ATN true).\n\t * Configure the ncr5380 to monitor BSY, parity.\n\t */\n\ticmd &= ~(SCI_ICMD_DATA | SCI_ICMD_SEL);\n\t*sc->sci_icmd = icmd;\n\n\t/* If this target's bit is set, do NOT check parity. */\n\tif (sc->sc_parity_disable & target_mask)\n\t\t*sc->sci_mode = (SCI_MODE_MONBSY);\n\telse\n\t\t*sc->sci_mode = (SCI_MODE_MONBSY | SCI_MODE_PAR_CHK);\n\n\treturn XS_NOERROR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"sched: select for t/l=0x%02x\\n\"",
            "(sr->sr_target << 4) | sr->sr_lun"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->sc_intr_on",
          "args": [
            "sc"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"sched: ret, intr ON\\n\"",
            "0"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"sched: no work, cur=0x%x\\n\"",
            "(long) sc->sc_current"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ncr5380_sched: current set\""
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ncr5380_sched: not idle\""
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sc->sc_intr_off",
          "args": [
            "sc"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"sched: top, intr off\\n\"",
            "0"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tNCR_DBG_CMDS\t2\n\nstatic void\tncr5380_sched;\nstatic void\tncr5380_done;\nstatic int\tncr5380_select;\nstatic void\tncr5380_machine;\nvoid\tncr5380_cmd_timeout;\n\nstatic void\nncr5380_sched(sc)\n\tstruct\tncr5380_softc *sc;\n{\n\tstruct sci_req\t*sr;\n\tstruct scsi_xfer *xs;\n\tint\ttarget = 0, lun = 0;\n\tint\terror, i;\n\n\t/* Another hack (Er.. hook!) for the sun3 si: */\n\tif (sc->sc_intr_off) {\n\t\tNCR_TRACE(\"sched: top, intr off\\n\", 0);\n\t    sc->sc_intr_off(sc);\n\t}\n\nnext_job:\n\t/*\n\t * Grab the next job from queue.  Must be idle.\n\t */\n#ifdef\tDIAGNOSTIC\n\tif (sc->sc_state != NCR_IDLE)\n\t\tpanic(\"ncr5380_sched: not idle\");\n\tif (sc->sc_current)\n\t\tpanic(\"ncr5380_sched: current set\");\n#endif\n\n\t/*\n\t * Always start the search where we last looked.\n\t * The REQUEST_SENSE logic depends on this to\n\t * choose the same job as was last picked, so it\n\t * can just clear sc_current and reschedule.\n\t * (Avoids loss of \"contingent allegiance\".)\n\t */\n\ti = sc->sc_rr;\n\tsr = NULL;\n\tdo {\n\t\tif (sc->sc_ring[i].sr_xs) {\n\t\t\ttarget = sc->sc_ring[i].sr_target;\n\t\t\tlun = sc->sc_ring[i].sr_lun;\n\t\t\tif (sc->sc_matrix[target][lun] == NULL) {\n\t\t\t\t/*\n\t\t\t\t * Do not mark the  target/LUN busy yet,\n\t\t\t\t * because reselect may cause some other\n\t\t\t\t * job to become the current one, so we\n\t\t\t\t * might not actually start this job.\n\t\t\t\t * Instead, set sc_matrix later on.\n\t\t\t\t */\n\t\t\t\tsc->sc_rr = i;\n\t\t\t\tsr = &sc->sc_ring[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t\tif (i == SCI_OPENINGS)\n\t\t\ti = 0;\n\t} while (i != sc->sc_rr);\n\n\tif (sr == NULL) {\n\t\tNCR_TRACE(\"sched: no work, cur=0x%x\\n\",\n\t\t\t\t  (long) sc->sc_current);\n\n\t\t/* Another hack (Er.. hook!) for the sun3 si: */\n\t\tif (sc->sc_intr_on) {\n\t\t\tNCR_TRACE(\"sched: ret, intr ON\\n\", 0);\n\t\t    sc->sc_intr_on(sc);\n\t\t}\n\n\t\treturn;\t\t/* No more work to do. */\n\t}\n\n\tNCR_TRACE(\"sched: select for t/l=0x%02x\\n\",\n\t\t\t  (sr->sr_target << 4) | sr->sr_lun);\n\n\tsc->sc_state = NCR_WORKING;\n\terror = ncr5380_select(sc, sr);\n\tif (sc->sc_current) {\n\t\t/* Lost the race!  reselected out from under us! */\n\t\t/* Work with the reselected job. */\n\t\tif (sr->sr_flags & SR_IMMED) {\n\t\t\tprintf(\"%s: reselected while polling (abort)\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t/* Abort the reselected job. */\n\t\t\tsc->sc_state |= NCR_ABORTING;\n\t\t\tsc->sc_msgpriq |= SEND_ABORT;\n\t\t}\n\t\tsr = sc->sc_current;\n\t\txs = sr->sr_xs;\n\t\tNCR_TRACE(\"sched: reselect, new sr=0x%x\\n\", (long)sr);\n\t\tgoto have_nexus;\n\t}\n\n\t/* Normal selection result.  Target/LUN is now busy. */\n\tsc->sc_matrix[target][lun] = sr;\n\tsc->sc_current = sr;\t/* connected */\n\txs = sr->sr_xs;\n\n\t/*\n\t * Initialize pointers, etc. for this job\n\t */\n\tsc->sc_dataptr  = sr->sr_dataptr;\n\tsc->sc_datalen  = sr->sr_datalen;\n\tsc->sc_prevphase = PHASE_INVALID;\n\tsc->sc_msgpriq = SEND_IDENTIFY;\n\tsc->sc_msgoutq = 0;\n\tsc->sc_msgout  = 0;\n\n\tNCR_TRACE(\"sched: select rv=%d\\n\", error);\n\n\tswitch (error) {\n\tcase XS_NOERROR:\n\t\tbreak;\n\n\tcase XS_BUSY:\n\t\t/* XXX - Reset and try again. */\n\t\tprintf(\"%s: select found SCSI bus busy, resetting...\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tncr5380_reset_scsibus(sc);\n\t\t/* fallthrough */\n\tcase XS_SELTIMEOUT:\n\tdefault:\n\t\txs->error = error;\t/* from select */\n\t\tNCR_TRACE(\"sched: call done, sr=0x%x\\n\", (long)sr);\n\t\tncr5380_done(sc);\n\n\t\t/* Paranoia: clear everything. */\n\t\tsc->sc_dataptr = NULL;\n\t\tsc->sc_datalen = 0;\n\t\tsc->sc_prevphase = PHASE_INVALID;\n\t\tsc->sc_msgpriq = 0;\n\t\tsc->sc_msgoutq = 0;\n\t\tsc->sc_msgout  = 0;\n\n\t\tgoto next_job;\n\t}\n\n\t/*\n\t * Selection was successful.  Normally, this means\n\t * we are starting a new command.  However, this\n\t * might be the termination of an overdue job.\n\t */\n\tif (sr->sr_flags & SR_OVERDUE) {\n\t\tNCR_TRACE(\"sched: overdue, sr=0x%x\\n\", (long)sr);\n\t\tsc->sc_state |= NCR_ABORTING;\n\t\tsc->sc_msgpriq |= SEND_ABORT;\n\t\tgoto have_nexus;\n\t}\n\n\t/*\n\t * This may be the continuation of some job that\n\t * completed with a \"check condition\" code.\n\t */\n\tif (sr->sr_flags & SR_SENSE) {\n\t\tNCR_TRACE(\"sched: get sense, sr=0x%x\\n\", (long)sr);\n\t\t/* Do not allocate DMA, nor set timeout. */\n\t\tgoto have_nexus;\n\t}\n\n\t/*\n\t * OK, we are starting a new command.\n\t * Initialize and allocate resources for the new command.\n\t * Device reset is special (only uses MSG_OUT phase).\n\t * Normal commands start in MSG_OUT phase where we will\n\t * send and IDENDIFY message, and then expect CMD phase.\n\t */\n#ifdef\tNCR5380_DEBUG\n\tif (ncr5380_debug & NCR_DBG_CMDS) {\n\t\tprintf(\"ncr5380_sched: begin, target=%d, LUN=%d\\n\",\n\t\t    xs->sc_link->target, xs->sc_link->lun);\n\t\tncr5380_show_scsi_cmd(xs);\n\t}\n#endif\n\tif (xs->flags & SCSI_RESET) {\n\t\tNCR_TRACE(\"sched: cmd=reset, sr=0x%x\\n\", (long)sr);\n\t\t/* Not an error, so do not set NCR_ABORTING */\n\t\tsc->sc_msgpriq |= SEND_DEV_RESET;\n\t\tgoto have_nexus;\n\t}\n\n#ifdef\tDIAGNOSTIC\n\tif ((xs->flags & (SCSI_DATA_IN | SCSI_DATA_OUT)) == 0) {\n\t\tif (sc->sc_dataptr) {\n\t\t\tprintf(\"%s: ptr but no data in/out flags?\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tNCR_BREAK();\n\t\t\tsc->sc_dataptr = NULL;\n\t\t}\n\t}\n#endif\n\n\t/* Allocate DMA space (maybe) */\n\tif (sc->sc_dataptr && sc->sc_dma_alloc &&\n\t\t(sc->sc_datalen >= sc->sc_min_dma_len))\n\t{\n\t\tNCR_TRACE(\"sched: dma_alloc, len=%d\\n\", sc->sc_datalen);\n\t\t(*sc->sc_dma_alloc)(sc);\n\t}\n\n\t/*\n\t * Initialization hook called just after select,\n\t * at the beginning of COMMAND phase.\n\t * (but AFTER the DMA allocation is done)\n\t *\n\t * The evil Sun \"si\" adapter (OBIO variant) needs some\n\t * setup done to the DMA engine BEFORE the target puts\n\t * the SCSI bus into any DATA phase.\n\t */\n\tif (sr->sr_dma_hand && sc->sc_dma_setup) {\n\t\tNCR_TRACE(\"sched: dma_setup, dh=0x%x\\n\",\n\t\t\t\t  (long) sr->sr_dma_hand);\n\t    sc->sc_dma_setup(sc);\n\t}\n\n\t/*\n\t * Schedule a timeout for the job we are starting.\n\t */\n\tif ((sr->sr_flags & SR_IMMED) == 0) {\n\t\ti = (xs->timeout * hz) / 1000;\n\t\tNCR_TRACE(\"sched: set timeout=%d\\n\", i);\n\t\ttimeout(ncr5380_cmd_timeout, sr, i);\n\t}\n\nhave_nexus:\n\tNCR_TRACE(\"sched: call machine, cur=0x%x\\n\",\n\t\t\t  (long) sc->sc_current);\n\tncr5380_machine(sc);\n\tNCR_TRACE(\"sched: machine done, cur=0x%x\\n\",\n\t\t\t  (long) sc->sc_current);\n\n\t/*\n\t * What state did ncr5380_machine() leave us in?\n\t * Hopefully it sometimes completes a job...\n\t */\n\tif (sc->sc_state == NCR_IDLE)\n\t\tgoto next_job;\n\n\treturn; \t/* Have work in progress. */\n}"
  },
  {
    "function_name": "ncr5380_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
    "lines": "696-818",
    "snippet": "static void\nncr5380_done(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tstruct\tsci_req *sr;\n\tstruct\tscsi_xfer *xs;\n\n#ifdef\tDIAGNOSTIC\n\tif (sc->sc_state == NCR_IDLE)\n\t\tpanic(\"ncr5380_done: state=idle\");\n\tif (sc->sc_current == NULL)\n\t\tpanic(\"ncr5380_done: current=0\");\n#endif\n\n\tsr = sc->sc_current;\n\txs = sr->sr_xs;\n\n\tNCR_TRACE(\"done: top, cur=0x%x\\n\", (long) sc->sc_current);\n\n\t/*\n\t * Clean up DMA resources for this command.\n\t */\n\tif (sr->sr_dma_hand) {\n\t\tNCR_TRACE(\"done: dma_free, dh=0x%x\\n\",\n\t\t\t\t  (long) sr->sr_dma_hand);\n\t\t(*sc->sc_dma_free)(sc);\n\t}\n#ifdef\tDIAGNOSTIC\n\tif (sr->sr_dma_hand)\n\t\tpanic(\"ncr5380_done: dma free did not\");\n#endif\n\n\tif (sc->sc_state & NCR_ABORTING) {\n\t\tNCR_TRACE(\"done: aborting, error=%d\\n\", xs->error);\n\t\tif (xs->error == XS_NOERROR)\n\t\t\txs->error = XS_TIMEOUT;\n\t}\n\n\tNCR_TRACE(\"done: check error=%d\\n\", (long) xs->error);\n\n\t/* If error is already set, ignore sr_status value. */\n\tif (xs->error != XS_NOERROR)\n\t\tgoto finish;\n\n\tNCR_TRACE(\"done: check status=%d\\n\", sr->sr_status);\n\n\tswitch (sr->sr_status) {\n\tcase SCSI_OK:\t/* 0 */\n\t\tif (sr->sr_flags & SR_SENSE) {\n#ifdef\tNCR5380_DEBUG\n\t\t\tif (ncr5380_debug & NCR_DBG_CMDS) {\n\t\t\t\tncr5380_show_sense(xs);\n\t\t\t}\n#endif\n\t\t\txs->error = XS_SENSE;\n\t\t}\n\t\tbreak;\n\n\tcase SCSI_CHECK:\n\t\tif (sr->sr_flags & SR_SENSE) {\n\t\t\t/* Sense command also asked for sense? */\n\t\t\tprintf(\"ncr5380_done: sense asked for sense\\n\");\n\t\t\tNCR_BREAK();\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\tbreak;\n\t\t}\n\t\tsr->sr_flags |= SR_SENSE;\n\t\tNCR_TRACE(\"done: get sense, sr=0x%x\\n\", (long) sr);\n\t\t/*\n\t\t * Leave queued, but clear sc_current so we start over\n\t\t * with selection.  Guaranteed to get the same request.\n\t\t */\n\t\tsc->sc_state = NCR_IDLE;\n\t\tsc->sc_current = NULL;\n\t\tsc->sc_matrix[sr->sr_target][sr->sr_lun] = NULL;\n\t\treturn;\t\t/* XXX */\n\n\tcase SCSI_BUSY:\n\t\txs->error = XS_BUSY;\n\t\tbreak;\n\n\tcase -1:\n\t\t/* This is our \"impossible\" initial value. */\n\t\t/* fallthrough */\n\tdefault:\n\t\tprintf(\"%s: target %d, bad status=%d\\n\",\n\t\t    sc->sc_dev.dv_xname, sr->sr_target, sr->sr_status);\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\tbreak;\n\t}\n\nfinish:\n\n\tNCR_TRACE(\"done: finish, error=%d\\n\", xs->error);\n\n\t/*\n\t * Dequeue the finished command, but don't clear sc_state until\n\t * after the call to scsi_done(), because that may call back to\n\t * ncr5380_scsi_cmd() - unwanted recursion!\n\t *\n\t * Keeping sc->sc_state != idle terminates the recursion.\n\t */\n#ifdef\tDIAGNOSTIC\n\tif ((sc->sc_state & NCR_WORKING) == 0)\n\t\tpanic(\"ncr5380_done: bad state\");\n#endif\n\n\t/* Clear our pointers to the request. */\n\tsc->sc_current = NULL;\n\tsc->sc_matrix[sr->sr_target][sr->sr_lun] = NULL;\n\tuntimeout(ncr5380_cmd_timeout, sr);\n\n\t/* Make the request free. */\n\tsr->sr_xs = NULL;\n\tsc->sc_ncmds--;\n\n\t/* Tell common SCSI code it is done. */\n\txs->flags |= ITSDONE;\n\tscsi_done(xs);\n\n\tsc->sc_state = NCR_IDLE;\n\t/* Now ncr5380_sched() may be called again. */\n}",
    "includes": [
      "#include <dev/ic/ncr5380var.h>",
      "#include <dev/ic/ncr5380reg.h>",
      "#include <ddb/db_output.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [
      "#define\tNCR_DBG_CMDS\t2"
    ],
    "globals_used": [
      "static void\tncr5380_sched",
      "static void\tncr5380_done",
      "void\tncr5380_cmd_timeout"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scsi_done",
          "args": [
            "xs"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "ncr5380_cmd_timeout",
            "sr"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ncr5380_done: bad state\""
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"done: finish, error=%d\\n\"",
            "xs->error"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: target %d, bad status=%d\\n\"",
            "sc->sc_dev.dv_xname",
            "sr->sr_target",
            "sr->sr_status"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"done: get sense, sr=0x%x\\n\"",
            "(long) sr"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_BREAK",
          "args": [],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr5380_show_sense",
          "args": [
            "xs"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_show_sense",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "2462-2473",
          "snippet": "static void\nncr5380_show_sense(xs)\n\tstruct scsi_xfer *xs;\n{\n\tu_char\t*b = (u_char *)&xs->sense;\n\tint\ti;\n\n\tprintf(\"sense:\");\n\tfor (i = 0; i < sizeof(xs->sense); i++)\n\t\tprintf(\" %02x\", b[i]);\n\tprintf(\"\\n\");\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void\nncr5380_show_sense(xs)\n\tstruct scsi_xfer *xs;\n{\n\tu_char\t*b = (u_char *)&xs->sense;\n\tint\ti;\n\n\tprintf(\"sense:\");\n\tfor (i = 0; i < sizeof(xs->sense); i++)\n\t\tprintf(\" %02x\", b[i]);\n\tprintf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"done: check status=%d\\n\"",
            "sr->sr_status"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"done: check error=%d\\n\"",
            "(long) xs->error"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"done: aborting, error=%d\\n\"",
            "xs->error"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ncr5380_done: dma free did not\""
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"done: dma_free, dh=0x%x\\n\"",
            "(long) sr->sr_dma_hand"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"done: top, cur=0x%x\\n\"",
            "(long) sc->sc_current"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ncr5380_done: current=0\""
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ncr5380_done: state=idle\""
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tNCR_DBG_CMDS\t2\n\nstatic void\tncr5380_sched;\nstatic void\tncr5380_done;\nvoid\tncr5380_cmd_timeout;\n\nstatic void\nncr5380_done(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tstruct\tsci_req *sr;\n\tstruct\tscsi_xfer *xs;\n\n#ifdef\tDIAGNOSTIC\n\tif (sc->sc_state == NCR_IDLE)\n\t\tpanic(\"ncr5380_done: state=idle\");\n\tif (sc->sc_current == NULL)\n\t\tpanic(\"ncr5380_done: current=0\");\n#endif\n\n\tsr = sc->sc_current;\n\txs = sr->sr_xs;\n\n\tNCR_TRACE(\"done: top, cur=0x%x\\n\", (long) sc->sc_current);\n\n\t/*\n\t * Clean up DMA resources for this command.\n\t */\n\tif (sr->sr_dma_hand) {\n\t\tNCR_TRACE(\"done: dma_free, dh=0x%x\\n\",\n\t\t\t\t  (long) sr->sr_dma_hand);\n\t\t(*sc->sc_dma_free)(sc);\n\t}\n#ifdef\tDIAGNOSTIC\n\tif (sr->sr_dma_hand)\n\t\tpanic(\"ncr5380_done: dma free did not\");\n#endif\n\n\tif (sc->sc_state & NCR_ABORTING) {\n\t\tNCR_TRACE(\"done: aborting, error=%d\\n\", xs->error);\n\t\tif (xs->error == XS_NOERROR)\n\t\t\txs->error = XS_TIMEOUT;\n\t}\n\n\tNCR_TRACE(\"done: check error=%d\\n\", (long) xs->error);\n\n\t/* If error is already set, ignore sr_status value. */\n\tif (xs->error != XS_NOERROR)\n\t\tgoto finish;\n\n\tNCR_TRACE(\"done: check status=%d\\n\", sr->sr_status);\n\n\tswitch (sr->sr_status) {\n\tcase SCSI_OK:\t/* 0 */\n\t\tif (sr->sr_flags & SR_SENSE) {\n#ifdef\tNCR5380_DEBUG\n\t\t\tif (ncr5380_debug & NCR_DBG_CMDS) {\n\t\t\t\tncr5380_show_sense(xs);\n\t\t\t}\n#endif\n\t\t\txs->error = XS_SENSE;\n\t\t}\n\t\tbreak;\n\n\tcase SCSI_CHECK:\n\t\tif (sr->sr_flags & SR_SENSE) {\n\t\t\t/* Sense command also asked for sense? */\n\t\t\tprintf(\"ncr5380_done: sense asked for sense\\n\");\n\t\t\tNCR_BREAK();\n\t\t\txs->error = XS_DRIVER_STUFFUP;\n\t\t\tbreak;\n\t\t}\n\t\tsr->sr_flags |= SR_SENSE;\n\t\tNCR_TRACE(\"done: get sense, sr=0x%x\\n\", (long) sr);\n\t\t/*\n\t\t * Leave queued, but clear sc_current so we start over\n\t\t * with selection.  Guaranteed to get the same request.\n\t\t */\n\t\tsc->sc_state = NCR_IDLE;\n\t\tsc->sc_current = NULL;\n\t\tsc->sc_matrix[sr->sr_target][sr->sr_lun] = NULL;\n\t\treturn;\t\t/* XXX */\n\n\tcase SCSI_BUSY:\n\t\txs->error = XS_BUSY;\n\t\tbreak;\n\n\tcase -1:\n\t\t/* This is our \"impossible\" initial value. */\n\t\t/* fallthrough */\n\tdefault:\n\t\tprintf(\"%s: target %d, bad status=%d\\n\",\n\t\t    sc->sc_dev.dv_xname, sr->sr_target, sr->sr_status);\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\tbreak;\n\t}\n\nfinish:\n\n\tNCR_TRACE(\"done: finish, error=%d\\n\", xs->error);\n\n\t/*\n\t * Dequeue the finished command, but don't clear sc_state until\n\t * after the call to scsi_done(), because that may call back to\n\t * ncr5380_scsi_cmd() - unwanted recursion!\n\t *\n\t * Keeping sc->sc_state != idle terminates the recursion.\n\t */\n#ifdef\tDIAGNOSTIC\n\tif ((sc->sc_state & NCR_WORKING) == 0)\n\t\tpanic(\"ncr5380_done: bad state\");\n#endif\n\n\t/* Clear our pointers to the request. */\n\tsc->sc_current = NULL;\n\tsc->sc_matrix[sr->sr_target][sr->sr_lun] = NULL;\n\tuntimeout(ncr5380_cmd_timeout, sr);\n\n\t/* Make the request free. */\n\tsr->sr_xs = NULL;\n\tsc->sc_ncmds--;\n\n\t/* Tell common SCSI code it is done. */\n\txs->flags |= ITSDONE;\n\tscsi_done(xs);\n\n\tsc->sc_state = NCR_IDLE;\n\t/* Now ncr5380_sched() may be called again. */\n}"
  },
  {
    "function_name": "ncr5380_scsi_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
    "lines": "593-689",
    "snippet": "int\nncr5380_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tstruct\tncr5380_softc *sc;\n\tstruct sci_req\t*sr;\n\tint s, rv, i, flags;\n\textern int cold;\t\t/* XXX */\n\n\tsc = xs->sc_link->adapter_softc;\n\n\tflags = xs->flags;\n\t/*\n\t * XXX: Hack: During autoconfig, force polling mode.\n\t * Needed as long as sdsize() can be called while cold,\n\t * otherwise timeouts will never call back (grumble).\n\t */\n\tif (cold)\n\t\tflags |= SCSI_POLL;\n\n\tif (sc->sc_flags & NCR5380_FORCE_POLLING)\n\t\tflags |= SCSI_POLL;\n\n\tif (flags & SCSI_DATA_UIO)\n\t\tpanic(\"ncr5380: scsi data uio requested\");\n\n\ts = splbio();\n\n\tif (flags & SCSI_POLL) {\n\t\t/* Terminate any current command. */\n\t\tsr = sc->sc_current;\n\t\tif (sr) {\n\t\t\tprintf(\"%s: polled request aborting %d/%d\\n\",\n\t\t\t    sc->sc_dev.dv_xname,\n\t\t\t    sr->sr_target, sr->sr_lun);\n\t\t\tncr5380_abort(sc);\n\t\t}\n\t\tif (sc->sc_state != NCR_IDLE) {\n\t\t\tpanic(\"ncr5380_scsi_cmd: polled request, abort failed\");\n\t\t}\n\t}\n\n\t/*\n\t * Find lowest empty slot in ring buffer.\n\t * XXX: What about \"fairness\" and cmd order?\n\t */\n\tfor (i = 0; i < SCI_OPENINGS; i++)\n\t\tif (sc->sc_ring[i].sr_xs == NULL)\n\t\t\tgoto new;\n\n\trv = TRY_AGAIN_LATER;\n\tNCR_TRACE(\"scsi_cmd: no openings, rv=%d\\n\", rv);\n\tgoto out;\n\nnew:\n\t/* Create queue entry */\n\tsr = &sc->sc_ring[i];\n\tsr->sr_xs = xs;\n\tsr->sr_target = xs->sc_link->target;\n\tsr->sr_lun = xs->sc_link->lun;\n\tsr->sr_dma_hand = NULL;\n\tsr->sr_dataptr = xs->data;\n\tsr->sr_datalen = xs->datalen;\n\tsr->sr_flags = (flags & SCSI_POLL) ? SR_IMMED : 0;\n\tsr->sr_status = -1;\t/* no value */\n\tsc->sc_ncmds++;\n\trv = SUCCESSFULLY_QUEUED;\n\n\tNCR_TRACE(\"scsi_cmd: new sr=0x%x\\n\", (long)sr);\n\n\tif (flags & SCSI_POLL) {\n\t\t/* Force this new command to be next. */\n\t\tsc->sc_rr = i;\n\t}\n\n\t/*\n\t * If we were idle, run some commands...\n\t */\n\tif (sc->sc_state == NCR_IDLE) {\n\t\tNCR_TRACE(\"scsi_cmd: call sched, cur=0x%x\\n\",\n\t\t\t\t  (long) sc->sc_current);\n\t\tncr5380_sched(sc);\n\t\tNCR_TRACE(\"scsi_cmd: sched done, cur=0x%x\\n\",\n\t\t\t\t  (long) sc->sc_current);\n\t}\n\n\tif (flags & SCSI_POLL) {\n\t\t/* Make sure ncr5380_sched() finished it. */\n\t\tif ((xs->flags & ITSDONE) == 0)\n\t\t\tpanic(\"ncr5380_scsi_cmd: poll didn't finish\");\n\t\trv = COMPLETE;\n\t}\n\nout:\n\tsplx(s);\n\treturn (rv);\n}",
    "includes": [
      "#include <dev/ic/ncr5380var.h>",
      "#include <dev/ic/ncr5380reg.h>",
      "#include <ddb/db_output.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\tncr5380_sched",
      "void\tncr5380_abort"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ncr5380_scsi_cmd: poll didn't finish\""
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"scsi_cmd: sched done, cur=0x%x\\n\"",
            "(long) sc->sc_current"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr5380_sched",
          "args": [
            "sc"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_sched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "827-1063",
          "snippet": "static void\nncr5380_sched(sc)\n\tstruct\tncr5380_softc *sc;\n{\n\tstruct sci_req\t*sr;\n\tstruct scsi_xfer *xs;\n\tint\ttarget = 0, lun = 0;\n\tint\terror, i;\n\n\t/* Another hack (Er.. hook!) for the sun3 si: */\n\tif (sc->sc_intr_off) {\n\t\tNCR_TRACE(\"sched: top, intr off\\n\", 0);\n\t    sc->sc_intr_off(sc);\n\t}\n\nnext_job:\n\t/*\n\t * Grab the next job from queue.  Must be idle.\n\t */\n#ifdef\tDIAGNOSTIC\n\tif (sc->sc_state != NCR_IDLE)\n\t\tpanic(\"ncr5380_sched: not idle\");\n\tif (sc->sc_current)\n\t\tpanic(\"ncr5380_sched: current set\");\n#endif\n\n\t/*\n\t * Always start the search where we last looked.\n\t * The REQUEST_SENSE logic depends on this to\n\t * choose the same job as was last picked, so it\n\t * can just clear sc_current and reschedule.\n\t * (Avoids loss of \"contingent allegiance\".)\n\t */\n\ti = sc->sc_rr;\n\tsr = NULL;\n\tdo {\n\t\tif (sc->sc_ring[i].sr_xs) {\n\t\t\ttarget = sc->sc_ring[i].sr_target;\n\t\t\tlun = sc->sc_ring[i].sr_lun;\n\t\t\tif (sc->sc_matrix[target][lun] == NULL) {\n\t\t\t\t/*\n\t\t\t\t * Do not mark the  target/LUN busy yet,\n\t\t\t\t * because reselect may cause some other\n\t\t\t\t * job to become the current one, so we\n\t\t\t\t * might not actually start this job.\n\t\t\t\t * Instead, set sc_matrix later on.\n\t\t\t\t */\n\t\t\t\tsc->sc_rr = i;\n\t\t\t\tsr = &sc->sc_ring[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t\tif (i == SCI_OPENINGS)\n\t\t\ti = 0;\n\t} while (i != sc->sc_rr);\n\n\tif (sr == NULL) {\n\t\tNCR_TRACE(\"sched: no work, cur=0x%x\\n\",\n\t\t\t\t  (long) sc->sc_current);\n\n\t\t/* Another hack (Er.. hook!) for the sun3 si: */\n\t\tif (sc->sc_intr_on) {\n\t\t\tNCR_TRACE(\"sched: ret, intr ON\\n\", 0);\n\t\t    sc->sc_intr_on(sc);\n\t\t}\n\n\t\treturn;\t\t/* No more work to do. */\n\t}\n\n\tNCR_TRACE(\"sched: select for t/l=0x%02x\\n\",\n\t\t\t  (sr->sr_target << 4) | sr->sr_lun);\n\n\tsc->sc_state = NCR_WORKING;\n\terror = ncr5380_select(sc, sr);\n\tif (sc->sc_current) {\n\t\t/* Lost the race!  reselected out from under us! */\n\t\t/* Work with the reselected job. */\n\t\tif (sr->sr_flags & SR_IMMED) {\n\t\t\tprintf(\"%s: reselected while polling (abort)\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t/* Abort the reselected job. */\n\t\t\tsc->sc_state |= NCR_ABORTING;\n\t\t\tsc->sc_msgpriq |= SEND_ABORT;\n\t\t}\n\t\tsr = sc->sc_current;\n\t\txs = sr->sr_xs;\n\t\tNCR_TRACE(\"sched: reselect, new sr=0x%x\\n\", (long)sr);\n\t\tgoto have_nexus;\n\t}\n\n\t/* Normal selection result.  Target/LUN is now busy. */\n\tsc->sc_matrix[target][lun] = sr;\n\tsc->sc_current = sr;\t/* connected */\n\txs = sr->sr_xs;\n\n\t/*\n\t * Initialize pointers, etc. for this job\n\t */\n\tsc->sc_dataptr  = sr->sr_dataptr;\n\tsc->sc_datalen  = sr->sr_datalen;\n\tsc->sc_prevphase = PHASE_INVALID;\n\tsc->sc_msgpriq = SEND_IDENTIFY;\n\tsc->sc_msgoutq = 0;\n\tsc->sc_msgout  = 0;\n\n\tNCR_TRACE(\"sched: select rv=%d\\n\", error);\n\n\tswitch (error) {\n\tcase XS_NOERROR:\n\t\tbreak;\n\n\tcase XS_BUSY:\n\t\t/* XXX - Reset and try again. */\n\t\tprintf(\"%s: select found SCSI bus busy, resetting...\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tncr5380_reset_scsibus(sc);\n\t\t/* fallthrough */\n\tcase XS_SELTIMEOUT:\n\tdefault:\n\t\txs->error = error;\t/* from select */\n\t\tNCR_TRACE(\"sched: call done, sr=0x%x\\n\", (long)sr);\n\t\tncr5380_done(sc);\n\n\t\t/* Paranoia: clear everything. */\n\t\tsc->sc_dataptr = NULL;\n\t\tsc->sc_datalen = 0;\n\t\tsc->sc_prevphase = PHASE_INVALID;\n\t\tsc->sc_msgpriq = 0;\n\t\tsc->sc_msgoutq = 0;\n\t\tsc->sc_msgout  = 0;\n\n\t\tgoto next_job;\n\t}\n\n\t/*\n\t * Selection was successful.  Normally, this means\n\t * we are starting a new command.  However, this\n\t * might be the termination of an overdue job.\n\t */\n\tif (sr->sr_flags & SR_OVERDUE) {\n\t\tNCR_TRACE(\"sched: overdue, sr=0x%x\\n\", (long)sr);\n\t\tsc->sc_state |= NCR_ABORTING;\n\t\tsc->sc_msgpriq |= SEND_ABORT;\n\t\tgoto have_nexus;\n\t}\n\n\t/*\n\t * This may be the continuation of some job that\n\t * completed with a \"check condition\" code.\n\t */\n\tif (sr->sr_flags & SR_SENSE) {\n\t\tNCR_TRACE(\"sched: get sense, sr=0x%x\\n\", (long)sr);\n\t\t/* Do not allocate DMA, nor set timeout. */\n\t\tgoto have_nexus;\n\t}\n\n\t/*\n\t * OK, we are starting a new command.\n\t * Initialize and allocate resources for the new command.\n\t * Device reset is special (only uses MSG_OUT phase).\n\t * Normal commands start in MSG_OUT phase where we will\n\t * send and IDENDIFY message, and then expect CMD phase.\n\t */\n#ifdef\tNCR5380_DEBUG\n\tif (ncr5380_debug & NCR_DBG_CMDS) {\n\t\tprintf(\"ncr5380_sched: begin, target=%d, LUN=%d\\n\",\n\t\t    xs->sc_link->target, xs->sc_link->lun);\n\t\tncr5380_show_scsi_cmd(xs);\n\t}\n#endif\n\tif (xs->flags & SCSI_RESET) {\n\t\tNCR_TRACE(\"sched: cmd=reset, sr=0x%x\\n\", (long)sr);\n\t\t/* Not an error, so do not set NCR_ABORTING */\n\t\tsc->sc_msgpriq |= SEND_DEV_RESET;\n\t\tgoto have_nexus;\n\t}\n\n#ifdef\tDIAGNOSTIC\n\tif ((xs->flags & (SCSI_DATA_IN | SCSI_DATA_OUT)) == 0) {\n\t\tif (sc->sc_dataptr) {\n\t\t\tprintf(\"%s: ptr but no data in/out flags?\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tNCR_BREAK();\n\t\t\tsc->sc_dataptr = NULL;\n\t\t}\n\t}\n#endif\n\n\t/* Allocate DMA space (maybe) */\n\tif (sc->sc_dataptr && sc->sc_dma_alloc &&\n\t\t(sc->sc_datalen >= sc->sc_min_dma_len))\n\t{\n\t\tNCR_TRACE(\"sched: dma_alloc, len=%d\\n\", sc->sc_datalen);\n\t\t(*sc->sc_dma_alloc)(sc);\n\t}\n\n\t/*\n\t * Initialization hook called just after select,\n\t * at the beginning of COMMAND phase.\n\t * (but AFTER the DMA allocation is done)\n\t *\n\t * The evil Sun \"si\" adapter (OBIO variant) needs some\n\t * setup done to the DMA engine BEFORE the target puts\n\t * the SCSI bus into any DATA phase.\n\t */\n\tif (sr->sr_dma_hand && sc->sc_dma_setup) {\n\t\tNCR_TRACE(\"sched: dma_setup, dh=0x%x\\n\",\n\t\t\t\t  (long) sr->sr_dma_hand);\n\t    sc->sc_dma_setup(sc);\n\t}\n\n\t/*\n\t * Schedule a timeout for the job we are starting.\n\t */\n\tif ((sr->sr_flags & SR_IMMED) == 0) {\n\t\ti = (xs->timeout * hz) / 1000;\n\t\tNCR_TRACE(\"sched: set timeout=%d\\n\", i);\n\t\ttimeout(ncr5380_cmd_timeout, sr, i);\n\t}\n\nhave_nexus:\n\tNCR_TRACE(\"sched: call machine, cur=0x%x\\n\",\n\t\t\t  (long) sc->sc_current);\n\tncr5380_machine(sc);\n\tNCR_TRACE(\"sched: machine done, cur=0x%x\\n\",\n\t\t\t  (long) sc->sc_current);\n\n\t/*\n\t * What state did ncr5380_machine() leave us in?\n\t * Hopefully it sometimes completes a job...\n\t */\n\tif (sc->sc_state == NCR_IDLE)\n\t\tgoto next_job;\n\n\treturn; \t/* Have work in progress. */\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tNCR_DBG_CMDS\t2"
          ],
          "globals_used": [
            "static void\tncr5380_sched",
            "static void\tncr5380_done",
            "static int\tncr5380_select",
            "static void\tncr5380_machine",
            "void\tncr5380_cmd_timeout"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tNCR_DBG_CMDS\t2\n\nstatic void\tncr5380_sched;\nstatic void\tncr5380_done;\nstatic int\tncr5380_select;\nstatic void\tncr5380_machine;\nvoid\tncr5380_cmd_timeout;\n\nstatic void\nncr5380_sched(sc)\n\tstruct\tncr5380_softc *sc;\n{\n\tstruct sci_req\t*sr;\n\tstruct scsi_xfer *xs;\n\tint\ttarget = 0, lun = 0;\n\tint\terror, i;\n\n\t/* Another hack (Er.. hook!) for the sun3 si: */\n\tif (sc->sc_intr_off) {\n\t\tNCR_TRACE(\"sched: top, intr off\\n\", 0);\n\t    sc->sc_intr_off(sc);\n\t}\n\nnext_job:\n\t/*\n\t * Grab the next job from queue.  Must be idle.\n\t */\n#ifdef\tDIAGNOSTIC\n\tif (sc->sc_state != NCR_IDLE)\n\t\tpanic(\"ncr5380_sched: not idle\");\n\tif (sc->sc_current)\n\t\tpanic(\"ncr5380_sched: current set\");\n#endif\n\n\t/*\n\t * Always start the search where we last looked.\n\t * The REQUEST_SENSE logic depends on this to\n\t * choose the same job as was last picked, so it\n\t * can just clear sc_current and reschedule.\n\t * (Avoids loss of \"contingent allegiance\".)\n\t */\n\ti = sc->sc_rr;\n\tsr = NULL;\n\tdo {\n\t\tif (sc->sc_ring[i].sr_xs) {\n\t\t\ttarget = sc->sc_ring[i].sr_target;\n\t\t\tlun = sc->sc_ring[i].sr_lun;\n\t\t\tif (sc->sc_matrix[target][lun] == NULL) {\n\t\t\t\t/*\n\t\t\t\t * Do not mark the  target/LUN busy yet,\n\t\t\t\t * because reselect may cause some other\n\t\t\t\t * job to become the current one, so we\n\t\t\t\t * might not actually start this job.\n\t\t\t\t * Instead, set sc_matrix later on.\n\t\t\t\t */\n\t\t\t\tsc->sc_rr = i;\n\t\t\t\tsr = &sc->sc_ring[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t\tif (i == SCI_OPENINGS)\n\t\t\ti = 0;\n\t} while (i != sc->sc_rr);\n\n\tif (sr == NULL) {\n\t\tNCR_TRACE(\"sched: no work, cur=0x%x\\n\",\n\t\t\t\t  (long) sc->sc_current);\n\n\t\t/* Another hack (Er.. hook!) for the sun3 si: */\n\t\tif (sc->sc_intr_on) {\n\t\t\tNCR_TRACE(\"sched: ret, intr ON\\n\", 0);\n\t\t    sc->sc_intr_on(sc);\n\t\t}\n\n\t\treturn;\t\t/* No more work to do. */\n\t}\n\n\tNCR_TRACE(\"sched: select for t/l=0x%02x\\n\",\n\t\t\t  (sr->sr_target << 4) | sr->sr_lun);\n\n\tsc->sc_state = NCR_WORKING;\n\terror = ncr5380_select(sc, sr);\n\tif (sc->sc_current) {\n\t\t/* Lost the race!  reselected out from under us! */\n\t\t/* Work with the reselected job. */\n\t\tif (sr->sr_flags & SR_IMMED) {\n\t\t\tprintf(\"%s: reselected while polling (abort)\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t/* Abort the reselected job. */\n\t\t\tsc->sc_state |= NCR_ABORTING;\n\t\t\tsc->sc_msgpriq |= SEND_ABORT;\n\t\t}\n\t\tsr = sc->sc_current;\n\t\txs = sr->sr_xs;\n\t\tNCR_TRACE(\"sched: reselect, new sr=0x%x\\n\", (long)sr);\n\t\tgoto have_nexus;\n\t}\n\n\t/* Normal selection result.  Target/LUN is now busy. */\n\tsc->sc_matrix[target][lun] = sr;\n\tsc->sc_current = sr;\t/* connected */\n\txs = sr->sr_xs;\n\n\t/*\n\t * Initialize pointers, etc. for this job\n\t */\n\tsc->sc_dataptr  = sr->sr_dataptr;\n\tsc->sc_datalen  = sr->sr_datalen;\n\tsc->sc_prevphase = PHASE_INVALID;\n\tsc->sc_msgpriq = SEND_IDENTIFY;\n\tsc->sc_msgoutq = 0;\n\tsc->sc_msgout  = 0;\n\n\tNCR_TRACE(\"sched: select rv=%d\\n\", error);\n\n\tswitch (error) {\n\tcase XS_NOERROR:\n\t\tbreak;\n\n\tcase XS_BUSY:\n\t\t/* XXX - Reset and try again. */\n\t\tprintf(\"%s: select found SCSI bus busy, resetting...\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tncr5380_reset_scsibus(sc);\n\t\t/* fallthrough */\n\tcase XS_SELTIMEOUT:\n\tdefault:\n\t\txs->error = error;\t/* from select */\n\t\tNCR_TRACE(\"sched: call done, sr=0x%x\\n\", (long)sr);\n\t\tncr5380_done(sc);\n\n\t\t/* Paranoia: clear everything. */\n\t\tsc->sc_dataptr = NULL;\n\t\tsc->sc_datalen = 0;\n\t\tsc->sc_prevphase = PHASE_INVALID;\n\t\tsc->sc_msgpriq = 0;\n\t\tsc->sc_msgoutq = 0;\n\t\tsc->sc_msgout  = 0;\n\n\t\tgoto next_job;\n\t}\n\n\t/*\n\t * Selection was successful.  Normally, this means\n\t * we are starting a new command.  However, this\n\t * might be the termination of an overdue job.\n\t */\n\tif (sr->sr_flags & SR_OVERDUE) {\n\t\tNCR_TRACE(\"sched: overdue, sr=0x%x\\n\", (long)sr);\n\t\tsc->sc_state |= NCR_ABORTING;\n\t\tsc->sc_msgpriq |= SEND_ABORT;\n\t\tgoto have_nexus;\n\t}\n\n\t/*\n\t * This may be the continuation of some job that\n\t * completed with a \"check condition\" code.\n\t */\n\tif (sr->sr_flags & SR_SENSE) {\n\t\tNCR_TRACE(\"sched: get sense, sr=0x%x\\n\", (long)sr);\n\t\t/* Do not allocate DMA, nor set timeout. */\n\t\tgoto have_nexus;\n\t}\n\n\t/*\n\t * OK, we are starting a new command.\n\t * Initialize and allocate resources for the new command.\n\t * Device reset is special (only uses MSG_OUT phase).\n\t * Normal commands start in MSG_OUT phase where we will\n\t * send and IDENDIFY message, and then expect CMD phase.\n\t */\n#ifdef\tNCR5380_DEBUG\n\tif (ncr5380_debug & NCR_DBG_CMDS) {\n\t\tprintf(\"ncr5380_sched: begin, target=%d, LUN=%d\\n\",\n\t\t    xs->sc_link->target, xs->sc_link->lun);\n\t\tncr5380_show_scsi_cmd(xs);\n\t}\n#endif\n\tif (xs->flags & SCSI_RESET) {\n\t\tNCR_TRACE(\"sched: cmd=reset, sr=0x%x\\n\", (long)sr);\n\t\t/* Not an error, so do not set NCR_ABORTING */\n\t\tsc->sc_msgpriq |= SEND_DEV_RESET;\n\t\tgoto have_nexus;\n\t}\n\n#ifdef\tDIAGNOSTIC\n\tif ((xs->flags & (SCSI_DATA_IN | SCSI_DATA_OUT)) == 0) {\n\t\tif (sc->sc_dataptr) {\n\t\t\tprintf(\"%s: ptr but no data in/out flags?\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tNCR_BREAK();\n\t\t\tsc->sc_dataptr = NULL;\n\t\t}\n\t}\n#endif\n\n\t/* Allocate DMA space (maybe) */\n\tif (sc->sc_dataptr && sc->sc_dma_alloc &&\n\t\t(sc->sc_datalen >= sc->sc_min_dma_len))\n\t{\n\t\tNCR_TRACE(\"sched: dma_alloc, len=%d\\n\", sc->sc_datalen);\n\t\t(*sc->sc_dma_alloc)(sc);\n\t}\n\n\t/*\n\t * Initialization hook called just after select,\n\t * at the beginning of COMMAND phase.\n\t * (but AFTER the DMA allocation is done)\n\t *\n\t * The evil Sun \"si\" adapter (OBIO variant) needs some\n\t * setup done to the DMA engine BEFORE the target puts\n\t * the SCSI bus into any DATA phase.\n\t */\n\tif (sr->sr_dma_hand && sc->sc_dma_setup) {\n\t\tNCR_TRACE(\"sched: dma_setup, dh=0x%x\\n\",\n\t\t\t\t  (long) sr->sr_dma_hand);\n\t    sc->sc_dma_setup(sc);\n\t}\n\n\t/*\n\t * Schedule a timeout for the job we are starting.\n\t */\n\tif ((sr->sr_flags & SR_IMMED) == 0) {\n\t\ti = (xs->timeout * hz) / 1000;\n\t\tNCR_TRACE(\"sched: set timeout=%d\\n\", i);\n\t\ttimeout(ncr5380_cmd_timeout, sr, i);\n\t}\n\nhave_nexus:\n\tNCR_TRACE(\"sched: call machine, cur=0x%x\\n\",\n\t\t\t  (long) sc->sc_current);\n\tncr5380_machine(sc);\n\tNCR_TRACE(\"sched: machine done, cur=0x%x\\n\",\n\t\t\t  (long) sc->sc_current);\n\n\t/*\n\t * What state did ncr5380_machine() leave us in?\n\t * Hopefully it sometimes completes a job...\n\t */\n\tif (sc->sc_state == NCR_IDLE)\n\t\tgoto next_job;\n\n\treturn; \t/* Have work in progress. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"scsi_cmd: call sched, cur=0x%x\\n\"",
            "(long) sc->sc_current"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"scsi_cmd: new sr=0x%x\\n\"",
            "(long)sr"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"scsi_cmd: no openings, rv=%d\\n\"",
            "rv"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ncr5380_scsi_cmd: polled request, abort failed\""
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr5380_abort",
          "args": [
            "sc"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "481-513",
          "snippet": "void\nncr5380_abort(sc)\n\tstruct ncr5380_softc *sc;\n{\n\n\t/*\n\t * Finish it now.  If DMA is in progress, we\n\t * can not call ncr_sched_msgout() because\n\t * that hits the SBC (avoid DMA conflict).\n\t */\n\n\t/* Another hack (Er.. hook!) for the sun3 si: */\n\tif (sc->sc_intr_off) {\n\t\tNCR_TRACE(\"abort: intr off\\n\", 0);\n\t\tsc->sc_intr_off(sc);\n\t}\n\n\tsc->sc_state |= NCR_ABORTING;\n\tif ((sc->sc_state & NCR_DOINGDMA) == 0) {\n\t\tncr_sched_msgout(sc, SEND_ABORT);\n\t}\n\tNCR_TRACE(\"abort: call machine, cur=0x%x\\n\",\n\t\t\t  (long) sc->sc_current);\n\tncr5380_machine(sc);\n\tNCR_TRACE(\"abort: machine done, cur=0x%x\\n\",\n\t\t\t  (long) sc->sc_current);\n\n\t/* Another hack (Er.. hook!) for the sun3 si: */\n\tif (sc->sc_intr_on) {\n\t\tNCR_TRACE(\"abort: intr ON\\n\", 0);\n\t    sc->sc_intr_on(sc);\n\t}\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tncr5380_machine",
            "void\tncr5380_abort",
            "static __inline void ncr_sched_msgout"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void\tncr5380_machine;\nvoid\tncr5380_abort;\nstatic __inline void ncr_sched_msgout;\n\nvoid\nncr5380_abort(sc)\n\tstruct ncr5380_softc *sc;\n{\n\n\t/*\n\t * Finish it now.  If DMA is in progress, we\n\t * can not call ncr_sched_msgout() because\n\t * that hits the SBC (avoid DMA conflict).\n\t */\n\n\t/* Another hack (Er.. hook!) for the sun3 si: */\n\tif (sc->sc_intr_off) {\n\t\tNCR_TRACE(\"abort: intr off\\n\", 0);\n\t\tsc->sc_intr_off(sc);\n\t}\n\n\tsc->sc_state |= NCR_ABORTING;\n\tif ((sc->sc_state & NCR_DOINGDMA) == 0) {\n\t\tncr_sched_msgout(sc, SEND_ABORT);\n\t}\n\tNCR_TRACE(\"abort: call machine, cur=0x%x\\n\",\n\t\t\t  (long) sc->sc_current);\n\tncr5380_machine(sc);\n\tNCR_TRACE(\"abort: machine done, cur=0x%x\\n\",\n\t\t\t  (long) sc->sc_current);\n\n\t/* Another hack (Er.. hook!) for the sun3 si: */\n\tif (sc->sc_intr_on) {\n\t\tNCR_TRACE(\"abort: intr ON\\n\", 0);\n\t    sc->sc_intr_on(sc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: polled request aborting %d/%d\\n\"",
            "sc->sc_dev.dv_xname",
            "sr->sr_target",
            "sr->sr_lun"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"ncr5380: scsi data uio requested\""
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void\tncr5380_sched;\nvoid\tncr5380_abort;\n\nint\nncr5380_scsi_cmd(xs)\n\tstruct scsi_xfer *xs;\n{\n\tstruct\tncr5380_softc *sc;\n\tstruct sci_req\t*sr;\n\tint s, rv, i, flags;\n\textern int cold;\t\t/* XXX */\n\n\tsc = xs->sc_link->adapter_softc;\n\n\tflags = xs->flags;\n\t/*\n\t * XXX: Hack: During autoconfig, force polling mode.\n\t * Needed as long as sdsize() can be called while cold,\n\t * otherwise timeouts will never call back (grumble).\n\t */\n\tif (cold)\n\t\tflags |= SCSI_POLL;\n\n\tif (sc->sc_flags & NCR5380_FORCE_POLLING)\n\t\tflags |= SCSI_POLL;\n\n\tif (flags & SCSI_DATA_UIO)\n\t\tpanic(\"ncr5380: scsi data uio requested\");\n\n\ts = splbio();\n\n\tif (flags & SCSI_POLL) {\n\t\t/* Terminate any current command. */\n\t\tsr = sc->sc_current;\n\t\tif (sr) {\n\t\t\tprintf(\"%s: polled request aborting %d/%d\\n\",\n\t\t\t    sc->sc_dev.dv_xname,\n\t\t\t    sr->sr_target, sr->sr_lun);\n\t\t\tncr5380_abort(sc);\n\t\t}\n\t\tif (sc->sc_state != NCR_IDLE) {\n\t\t\tpanic(\"ncr5380_scsi_cmd: polled request, abort failed\");\n\t\t}\n\t}\n\n\t/*\n\t * Find lowest empty slot in ring buffer.\n\t * XXX: What about \"fairness\" and cmd order?\n\t */\n\tfor (i = 0; i < SCI_OPENINGS; i++)\n\t\tif (sc->sc_ring[i].sr_xs == NULL)\n\t\t\tgoto new;\n\n\trv = TRY_AGAIN_LATER;\n\tNCR_TRACE(\"scsi_cmd: no openings, rv=%d\\n\", rv);\n\tgoto out;\n\nnew:\n\t/* Create queue entry */\n\tsr = &sc->sc_ring[i];\n\tsr->sr_xs = xs;\n\tsr->sr_target = xs->sc_link->target;\n\tsr->sr_lun = xs->sc_link->lun;\n\tsr->sr_dma_hand = NULL;\n\tsr->sr_dataptr = xs->data;\n\tsr->sr_datalen = xs->datalen;\n\tsr->sr_flags = (flags & SCSI_POLL) ? SR_IMMED : 0;\n\tsr->sr_status = -1;\t/* no value */\n\tsc->sc_ncmds++;\n\trv = SUCCESSFULLY_QUEUED;\n\n\tNCR_TRACE(\"scsi_cmd: new sr=0x%x\\n\", (long)sr);\n\n\tif (flags & SCSI_POLL) {\n\t\t/* Force this new command to be next. */\n\t\tsc->sc_rr = i;\n\t}\n\n\t/*\n\t * If we were idle, run some commands...\n\t */\n\tif (sc->sc_state == NCR_IDLE) {\n\t\tNCR_TRACE(\"scsi_cmd: call sched, cur=0x%x\\n\",\n\t\t\t\t  (long) sc->sc_current);\n\t\tncr5380_sched(sc);\n\t\tNCR_TRACE(\"scsi_cmd: sched done, cur=0x%x\\n\",\n\t\t\t\t  (long) sc->sc_current);\n\t}\n\n\tif (flags & SCSI_POLL) {\n\t\t/* Make sure ncr5380_sched() finished it. */\n\t\tif ((xs->flags & ITSDONE) == 0)\n\t\t\tpanic(\"ncr5380_scsi_cmd: poll didn't finish\");\n\t\trv = COMPLETE;\n\t}\n\nout:\n\tsplx(s);\n\treturn (rv);\n}"
  },
  {
    "function_name": "ncr5380_cmd_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
    "lines": "518-578",
    "snippet": "void\nncr5380_cmd_timeout(arg)\n\tvoid *arg;\n{\n\tstruct sci_req *sr = arg;\n\tstruct scsi_xfer *xs;\n\tstruct scsi_link *sc_link;\n\tstruct ncr5380_softc *sc;\n\tint s;\n\n\ts = splbio();\n\n\t/* Get all our variables... */\n\txs = sr->sr_xs;\n\tif (xs == NULL) {\n\t\tprintf(\"ncr5380_cmd_timeout: no scsi_xfer\\n\");\n\t\tgoto out;\n\t}\n\tsc_link = xs->sc_link;\n\tsc = sc_link->adapter_softc;\n\n\tprintf(\"%s: cmd timeout, targ=%d, lun=%d\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    sr->sr_target, sr->sr_lun);\n\n\t/*\n\t * Mark the overdue job as failed, and arrange for\n\t * ncr5380_machine to terminate it.  If the victim\n\t * is the current job, call ncr5380_machine() now.\n\t * Otherwise arrange for ncr5380_sched() to do it.\n\t */\n\tsr->sr_flags |= SR_OVERDUE;\n\tif (sc->sc_current == sr) {\n\t\tNCR_TRACE(\"cmd_tmo: call abort, sr=0x%x\\n\", (long) sr);\n\t\tncr5380_abort(sc);\n\t} else {\n\t\t/*\n\t\t * The driver may be idle, or busy with another job.\n\t\t * Arrange for ncr5380_sched() to do the deed.\n\t\t */\n\t\tNCR_TRACE(\"cmd_tmo: clear matrix, t/l=0x%02x\\n\",\n\t\t\t\t  (sr->sr_target << 4) | sr->sr_lun);\n\t\tsc->sc_matrix[sr->sr_target][sr->sr_lun] = NULL;\n\t}\n\n\t/*\n\t * We may have aborted the current job, or may have\n\t * already been idle. In either case, we should now\n\t * be idle, so try to start another job.\n\t */\n\tif (sc->sc_state == NCR_IDLE) {\n\t\tNCR_TRACE(\"cmd_tmo: call sched, cur=0x%x\\n\",\n\t\t\t\t  (long) sc->sc_current);\n\t\tncr5380_sched(sc);\n\t\tNCR_TRACE(\"cmd_tmo: sched done, cur=0x%x\\n\",\n\t\t\t\t  (long) sc->sc_current);\n\t}\n\nout:\n\tsplx(s);\n}",
    "includes": [
      "#include <dev/ic/ncr5380var.h>",
      "#include <dev/ic/ncr5380reg.h>",
      "#include <ddb/db_output.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\tncr5380_sched",
      "static void\tncr5380_machine",
      "void\tncr5380_abort",
      "void\tncr5380_cmd_timeout"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"cmd_tmo: sched done, cur=0x%x\\n\"",
            "(long) sc->sc_current"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr5380_sched",
          "args": [
            "sc"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_sched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "827-1063",
          "snippet": "static void\nncr5380_sched(sc)\n\tstruct\tncr5380_softc *sc;\n{\n\tstruct sci_req\t*sr;\n\tstruct scsi_xfer *xs;\n\tint\ttarget = 0, lun = 0;\n\tint\terror, i;\n\n\t/* Another hack (Er.. hook!) for the sun3 si: */\n\tif (sc->sc_intr_off) {\n\t\tNCR_TRACE(\"sched: top, intr off\\n\", 0);\n\t    sc->sc_intr_off(sc);\n\t}\n\nnext_job:\n\t/*\n\t * Grab the next job from queue.  Must be idle.\n\t */\n#ifdef\tDIAGNOSTIC\n\tif (sc->sc_state != NCR_IDLE)\n\t\tpanic(\"ncr5380_sched: not idle\");\n\tif (sc->sc_current)\n\t\tpanic(\"ncr5380_sched: current set\");\n#endif\n\n\t/*\n\t * Always start the search where we last looked.\n\t * The REQUEST_SENSE logic depends on this to\n\t * choose the same job as was last picked, so it\n\t * can just clear sc_current and reschedule.\n\t * (Avoids loss of \"contingent allegiance\".)\n\t */\n\ti = sc->sc_rr;\n\tsr = NULL;\n\tdo {\n\t\tif (sc->sc_ring[i].sr_xs) {\n\t\t\ttarget = sc->sc_ring[i].sr_target;\n\t\t\tlun = sc->sc_ring[i].sr_lun;\n\t\t\tif (sc->sc_matrix[target][lun] == NULL) {\n\t\t\t\t/*\n\t\t\t\t * Do not mark the  target/LUN busy yet,\n\t\t\t\t * because reselect may cause some other\n\t\t\t\t * job to become the current one, so we\n\t\t\t\t * might not actually start this job.\n\t\t\t\t * Instead, set sc_matrix later on.\n\t\t\t\t */\n\t\t\t\tsc->sc_rr = i;\n\t\t\t\tsr = &sc->sc_ring[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t\tif (i == SCI_OPENINGS)\n\t\t\ti = 0;\n\t} while (i != sc->sc_rr);\n\n\tif (sr == NULL) {\n\t\tNCR_TRACE(\"sched: no work, cur=0x%x\\n\",\n\t\t\t\t  (long) sc->sc_current);\n\n\t\t/* Another hack (Er.. hook!) for the sun3 si: */\n\t\tif (sc->sc_intr_on) {\n\t\t\tNCR_TRACE(\"sched: ret, intr ON\\n\", 0);\n\t\t    sc->sc_intr_on(sc);\n\t\t}\n\n\t\treturn;\t\t/* No more work to do. */\n\t}\n\n\tNCR_TRACE(\"sched: select for t/l=0x%02x\\n\",\n\t\t\t  (sr->sr_target << 4) | sr->sr_lun);\n\n\tsc->sc_state = NCR_WORKING;\n\terror = ncr5380_select(sc, sr);\n\tif (sc->sc_current) {\n\t\t/* Lost the race!  reselected out from under us! */\n\t\t/* Work with the reselected job. */\n\t\tif (sr->sr_flags & SR_IMMED) {\n\t\t\tprintf(\"%s: reselected while polling (abort)\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t/* Abort the reselected job. */\n\t\t\tsc->sc_state |= NCR_ABORTING;\n\t\t\tsc->sc_msgpriq |= SEND_ABORT;\n\t\t}\n\t\tsr = sc->sc_current;\n\t\txs = sr->sr_xs;\n\t\tNCR_TRACE(\"sched: reselect, new sr=0x%x\\n\", (long)sr);\n\t\tgoto have_nexus;\n\t}\n\n\t/* Normal selection result.  Target/LUN is now busy. */\n\tsc->sc_matrix[target][lun] = sr;\n\tsc->sc_current = sr;\t/* connected */\n\txs = sr->sr_xs;\n\n\t/*\n\t * Initialize pointers, etc. for this job\n\t */\n\tsc->sc_dataptr  = sr->sr_dataptr;\n\tsc->sc_datalen  = sr->sr_datalen;\n\tsc->sc_prevphase = PHASE_INVALID;\n\tsc->sc_msgpriq = SEND_IDENTIFY;\n\tsc->sc_msgoutq = 0;\n\tsc->sc_msgout  = 0;\n\n\tNCR_TRACE(\"sched: select rv=%d\\n\", error);\n\n\tswitch (error) {\n\tcase XS_NOERROR:\n\t\tbreak;\n\n\tcase XS_BUSY:\n\t\t/* XXX - Reset and try again. */\n\t\tprintf(\"%s: select found SCSI bus busy, resetting...\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tncr5380_reset_scsibus(sc);\n\t\t/* fallthrough */\n\tcase XS_SELTIMEOUT:\n\tdefault:\n\t\txs->error = error;\t/* from select */\n\t\tNCR_TRACE(\"sched: call done, sr=0x%x\\n\", (long)sr);\n\t\tncr5380_done(sc);\n\n\t\t/* Paranoia: clear everything. */\n\t\tsc->sc_dataptr = NULL;\n\t\tsc->sc_datalen = 0;\n\t\tsc->sc_prevphase = PHASE_INVALID;\n\t\tsc->sc_msgpriq = 0;\n\t\tsc->sc_msgoutq = 0;\n\t\tsc->sc_msgout  = 0;\n\n\t\tgoto next_job;\n\t}\n\n\t/*\n\t * Selection was successful.  Normally, this means\n\t * we are starting a new command.  However, this\n\t * might be the termination of an overdue job.\n\t */\n\tif (sr->sr_flags & SR_OVERDUE) {\n\t\tNCR_TRACE(\"sched: overdue, sr=0x%x\\n\", (long)sr);\n\t\tsc->sc_state |= NCR_ABORTING;\n\t\tsc->sc_msgpriq |= SEND_ABORT;\n\t\tgoto have_nexus;\n\t}\n\n\t/*\n\t * This may be the continuation of some job that\n\t * completed with a \"check condition\" code.\n\t */\n\tif (sr->sr_flags & SR_SENSE) {\n\t\tNCR_TRACE(\"sched: get sense, sr=0x%x\\n\", (long)sr);\n\t\t/* Do not allocate DMA, nor set timeout. */\n\t\tgoto have_nexus;\n\t}\n\n\t/*\n\t * OK, we are starting a new command.\n\t * Initialize and allocate resources for the new command.\n\t * Device reset is special (only uses MSG_OUT phase).\n\t * Normal commands start in MSG_OUT phase where we will\n\t * send and IDENDIFY message, and then expect CMD phase.\n\t */\n#ifdef\tNCR5380_DEBUG\n\tif (ncr5380_debug & NCR_DBG_CMDS) {\n\t\tprintf(\"ncr5380_sched: begin, target=%d, LUN=%d\\n\",\n\t\t    xs->sc_link->target, xs->sc_link->lun);\n\t\tncr5380_show_scsi_cmd(xs);\n\t}\n#endif\n\tif (xs->flags & SCSI_RESET) {\n\t\tNCR_TRACE(\"sched: cmd=reset, sr=0x%x\\n\", (long)sr);\n\t\t/* Not an error, so do not set NCR_ABORTING */\n\t\tsc->sc_msgpriq |= SEND_DEV_RESET;\n\t\tgoto have_nexus;\n\t}\n\n#ifdef\tDIAGNOSTIC\n\tif ((xs->flags & (SCSI_DATA_IN | SCSI_DATA_OUT)) == 0) {\n\t\tif (sc->sc_dataptr) {\n\t\t\tprintf(\"%s: ptr but no data in/out flags?\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tNCR_BREAK();\n\t\t\tsc->sc_dataptr = NULL;\n\t\t}\n\t}\n#endif\n\n\t/* Allocate DMA space (maybe) */\n\tif (sc->sc_dataptr && sc->sc_dma_alloc &&\n\t\t(sc->sc_datalen >= sc->sc_min_dma_len))\n\t{\n\t\tNCR_TRACE(\"sched: dma_alloc, len=%d\\n\", sc->sc_datalen);\n\t\t(*sc->sc_dma_alloc)(sc);\n\t}\n\n\t/*\n\t * Initialization hook called just after select,\n\t * at the beginning of COMMAND phase.\n\t * (but AFTER the DMA allocation is done)\n\t *\n\t * The evil Sun \"si\" adapter (OBIO variant) needs some\n\t * setup done to the DMA engine BEFORE the target puts\n\t * the SCSI bus into any DATA phase.\n\t */\n\tif (sr->sr_dma_hand && sc->sc_dma_setup) {\n\t\tNCR_TRACE(\"sched: dma_setup, dh=0x%x\\n\",\n\t\t\t\t  (long) sr->sr_dma_hand);\n\t    sc->sc_dma_setup(sc);\n\t}\n\n\t/*\n\t * Schedule a timeout for the job we are starting.\n\t */\n\tif ((sr->sr_flags & SR_IMMED) == 0) {\n\t\ti = (xs->timeout * hz) / 1000;\n\t\tNCR_TRACE(\"sched: set timeout=%d\\n\", i);\n\t\ttimeout(ncr5380_cmd_timeout, sr, i);\n\t}\n\nhave_nexus:\n\tNCR_TRACE(\"sched: call machine, cur=0x%x\\n\",\n\t\t\t  (long) sc->sc_current);\n\tncr5380_machine(sc);\n\tNCR_TRACE(\"sched: machine done, cur=0x%x\\n\",\n\t\t\t  (long) sc->sc_current);\n\n\t/*\n\t * What state did ncr5380_machine() leave us in?\n\t * Hopefully it sometimes completes a job...\n\t */\n\tif (sc->sc_state == NCR_IDLE)\n\t\tgoto next_job;\n\n\treturn; \t/* Have work in progress. */\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tNCR_DBG_CMDS\t2"
          ],
          "globals_used": [
            "static void\tncr5380_sched",
            "static void\tncr5380_done",
            "static int\tncr5380_select",
            "static void\tncr5380_machine",
            "void\tncr5380_cmd_timeout"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tNCR_DBG_CMDS\t2\n\nstatic void\tncr5380_sched;\nstatic void\tncr5380_done;\nstatic int\tncr5380_select;\nstatic void\tncr5380_machine;\nvoid\tncr5380_cmd_timeout;\n\nstatic void\nncr5380_sched(sc)\n\tstruct\tncr5380_softc *sc;\n{\n\tstruct sci_req\t*sr;\n\tstruct scsi_xfer *xs;\n\tint\ttarget = 0, lun = 0;\n\tint\terror, i;\n\n\t/* Another hack (Er.. hook!) for the sun3 si: */\n\tif (sc->sc_intr_off) {\n\t\tNCR_TRACE(\"sched: top, intr off\\n\", 0);\n\t    sc->sc_intr_off(sc);\n\t}\n\nnext_job:\n\t/*\n\t * Grab the next job from queue.  Must be idle.\n\t */\n#ifdef\tDIAGNOSTIC\n\tif (sc->sc_state != NCR_IDLE)\n\t\tpanic(\"ncr5380_sched: not idle\");\n\tif (sc->sc_current)\n\t\tpanic(\"ncr5380_sched: current set\");\n#endif\n\n\t/*\n\t * Always start the search where we last looked.\n\t * The REQUEST_SENSE logic depends on this to\n\t * choose the same job as was last picked, so it\n\t * can just clear sc_current and reschedule.\n\t * (Avoids loss of \"contingent allegiance\".)\n\t */\n\ti = sc->sc_rr;\n\tsr = NULL;\n\tdo {\n\t\tif (sc->sc_ring[i].sr_xs) {\n\t\t\ttarget = sc->sc_ring[i].sr_target;\n\t\t\tlun = sc->sc_ring[i].sr_lun;\n\t\t\tif (sc->sc_matrix[target][lun] == NULL) {\n\t\t\t\t/*\n\t\t\t\t * Do not mark the  target/LUN busy yet,\n\t\t\t\t * because reselect may cause some other\n\t\t\t\t * job to become the current one, so we\n\t\t\t\t * might not actually start this job.\n\t\t\t\t * Instead, set sc_matrix later on.\n\t\t\t\t */\n\t\t\t\tsc->sc_rr = i;\n\t\t\t\tsr = &sc->sc_ring[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t\tif (i == SCI_OPENINGS)\n\t\t\ti = 0;\n\t} while (i != sc->sc_rr);\n\n\tif (sr == NULL) {\n\t\tNCR_TRACE(\"sched: no work, cur=0x%x\\n\",\n\t\t\t\t  (long) sc->sc_current);\n\n\t\t/* Another hack (Er.. hook!) for the sun3 si: */\n\t\tif (sc->sc_intr_on) {\n\t\t\tNCR_TRACE(\"sched: ret, intr ON\\n\", 0);\n\t\t    sc->sc_intr_on(sc);\n\t\t}\n\n\t\treturn;\t\t/* No more work to do. */\n\t}\n\n\tNCR_TRACE(\"sched: select for t/l=0x%02x\\n\",\n\t\t\t  (sr->sr_target << 4) | sr->sr_lun);\n\n\tsc->sc_state = NCR_WORKING;\n\terror = ncr5380_select(sc, sr);\n\tif (sc->sc_current) {\n\t\t/* Lost the race!  reselected out from under us! */\n\t\t/* Work with the reselected job. */\n\t\tif (sr->sr_flags & SR_IMMED) {\n\t\t\tprintf(\"%s: reselected while polling (abort)\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t/* Abort the reselected job. */\n\t\t\tsc->sc_state |= NCR_ABORTING;\n\t\t\tsc->sc_msgpriq |= SEND_ABORT;\n\t\t}\n\t\tsr = sc->sc_current;\n\t\txs = sr->sr_xs;\n\t\tNCR_TRACE(\"sched: reselect, new sr=0x%x\\n\", (long)sr);\n\t\tgoto have_nexus;\n\t}\n\n\t/* Normal selection result.  Target/LUN is now busy. */\n\tsc->sc_matrix[target][lun] = sr;\n\tsc->sc_current = sr;\t/* connected */\n\txs = sr->sr_xs;\n\n\t/*\n\t * Initialize pointers, etc. for this job\n\t */\n\tsc->sc_dataptr  = sr->sr_dataptr;\n\tsc->sc_datalen  = sr->sr_datalen;\n\tsc->sc_prevphase = PHASE_INVALID;\n\tsc->sc_msgpriq = SEND_IDENTIFY;\n\tsc->sc_msgoutq = 0;\n\tsc->sc_msgout  = 0;\n\n\tNCR_TRACE(\"sched: select rv=%d\\n\", error);\n\n\tswitch (error) {\n\tcase XS_NOERROR:\n\t\tbreak;\n\n\tcase XS_BUSY:\n\t\t/* XXX - Reset and try again. */\n\t\tprintf(\"%s: select found SCSI bus busy, resetting...\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tncr5380_reset_scsibus(sc);\n\t\t/* fallthrough */\n\tcase XS_SELTIMEOUT:\n\tdefault:\n\t\txs->error = error;\t/* from select */\n\t\tNCR_TRACE(\"sched: call done, sr=0x%x\\n\", (long)sr);\n\t\tncr5380_done(sc);\n\n\t\t/* Paranoia: clear everything. */\n\t\tsc->sc_dataptr = NULL;\n\t\tsc->sc_datalen = 0;\n\t\tsc->sc_prevphase = PHASE_INVALID;\n\t\tsc->sc_msgpriq = 0;\n\t\tsc->sc_msgoutq = 0;\n\t\tsc->sc_msgout  = 0;\n\n\t\tgoto next_job;\n\t}\n\n\t/*\n\t * Selection was successful.  Normally, this means\n\t * we are starting a new command.  However, this\n\t * might be the termination of an overdue job.\n\t */\n\tif (sr->sr_flags & SR_OVERDUE) {\n\t\tNCR_TRACE(\"sched: overdue, sr=0x%x\\n\", (long)sr);\n\t\tsc->sc_state |= NCR_ABORTING;\n\t\tsc->sc_msgpriq |= SEND_ABORT;\n\t\tgoto have_nexus;\n\t}\n\n\t/*\n\t * This may be the continuation of some job that\n\t * completed with a \"check condition\" code.\n\t */\n\tif (sr->sr_flags & SR_SENSE) {\n\t\tNCR_TRACE(\"sched: get sense, sr=0x%x\\n\", (long)sr);\n\t\t/* Do not allocate DMA, nor set timeout. */\n\t\tgoto have_nexus;\n\t}\n\n\t/*\n\t * OK, we are starting a new command.\n\t * Initialize and allocate resources for the new command.\n\t * Device reset is special (only uses MSG_OUT phase).\n\t * Normal commands start in MSG_OUT phase where we will\n\t * send and IDENDIFY message, and then expect CMD phase.\n\t */\n#ifdef\tNCR5380_DEBUG\n\tif (ncr5380_debug & NCR_DBG_CMDS) {\n\t\tprintf(\"ncr5380_sched: begin, target=%d, LUN=%d\\n\",\n\t\t    xs->sc_link->target, xs->sc_link->lun);\n\t\tncr5380_show_scsi_cmd(xs);\n\t}\n#endif\n\tif (xs->flags & SCSI_RESET) {\n\t\tNCR_TRACE(\"sched: cmd=reset, sr=0x%x\\n\", (long)sr);\n\t\t/* Not an error, so do not set NCR_ABORTING */\n\t\tsc->sc_msgpriq |= SEND_DEV_RESET;\n\t\tgoto have_nexus;\n\t}\n\n#ifdef\tDIAGNOSTIC\n\tif ((xs->flags & (SCSI_DATA_IN | SCSI_DATA_OUT)) == 0) {\n\t\tif (sc->sc_dataptr) {\n\t\t\tprintf(\"%s: ptr but no data in/out flags?\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tNCR_BREAK();\n\t\t\tsc->sc_dataptr = NULL;\n\t\t}\n\t}\n#endif\n\n\t/* Allocate DMA space (maybe) */\n\tif (sc->sc_dataptr && sc->sc_dma_alloc &&\n\t\t(sc->sc_datalen >= sc->sc_min_dma_len))\n\t{\n\t\tNCR_TRACE(\"sched: dma_alloc, len=%d\\n\", sc->sc_datalen);\n\t\t(*sc->sc_dma_alloc)(sc);\n\t}\n\n\t/*\n\t * Initialization hook called just after select,\n\t * at the beginning of COMMAND phase.\n\t * (but AFTER the DMA allocation is done)\n\t *\n\t * The evil Sun \"si\" adapter (OBIO variant) needs some\n\t * setup done to the DMA engine BEFORE the target puts\n\t * the SCSI bus into any DATA phase.\n\t */\n\tif (sr->sr_dma_hand && sc->sc_dma_setup) {\n\t\tNCR_TRACE(\"sched: dma_setup, dh=0x%x\\n\",\n\t\t\t\t  (long) sr->sr_dma_hand);\n\t    sc->sc_dma_setup(sc);\n\t}\n\n\t/*\n\t * Schedule a timeout for the job we are starting.\n\t */\n\tif ((sr->sr_flags & SR_IMMED) == 0) {\n\t\ti = (xs->timeout * hz) / 1000;\n\t\tNCR_TRACE(\"sched: set timeout=%d\\n\", i);\n\t\ttimeout(ncr5380_cmd_timeout, sr, i);\n\t}\n\nhave_nexus:\n\tNCR_TRACE(\"sched: call machine, cur=0x%x\\n\",\n\t\t\t  (long) sc->sc_current);\n\tncr5380_machine(sc);\n\tNCR_TRACE(\"sched: machine done, cur=0x%x\\n\",\n\t\t\t  (long) sc->sc_current);\n\n\t/*\n\t * What state did ncr5380_machine() leave us in?\n\t * Hopefully it sometimes completes a job...\n\t */\n\tif (sc->sc_state == NCR_IDLE)\n\t\tgoto next_job;\n\n\treturn; \t/* Have work in progress. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"cmd_tmo: call sched, cur=0x%x\\n\"",
            "(long) sc->sc_current"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"cmd_tmo: clear matrix, t/l=0x%02x\\n\"",
            "(sr->sr_target << 4) | sr->sr_lun"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr5380_abort",
          "args": [
            "sc"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "481-513",
          "snippet": "void\nncr5380_abort(sc)\n\tstruct ncr5380_softc *sc;\n{\n\n\t/*\n\t * Finish it now.  If DMA is in progress, we\n\t * can not call ncr_sched_msgout() because\n\t * that hits the SBC (avoid DMA conflict).\n\t */\n\n\t/* Another hack (Er.. hook!) for the sun3 si: */\n\tif (sc->sc_intr_off) {\n\t\tNCR_TRACE(\"abort: intr off\\n\", 0);\n\t\tsc->sc_intr_off(sc);\n\t}\n\n\tsc->sc_state |= NCR_ABORTING;\n\tif ((sc->sc_state & NCR_DOINGDMA) == 0) {\n\t\tncr_sched_msgout(sc, SEND_ABORT);\n\t}\n\tNCR_TRACE(\"abort: call machine, cur=0x%x\\n\",\n\t\t\t  (long) sc->sc_current);\n\tncr5380_machine(sc);\n\tNCR_TRACE(\"abort: machine done, cur=0x%x\\n\",\n\t\t\t  (long) sc->sc_current);\n\n\t/* Another hack (Er.. hook!) for the sun3 si: */\n\tif (sc->sc_intr_on) {\n\t\tNCR_TRACE(\"abort: intr ON\\n\", 0);\n\t    sc->sc_intr_on(sc);\n\t}\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tncr5380_machine",
            "void\tncr5380_abort",
            "static __inline void ncr_sched_msgout"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void\tncr5380_machine;\nvoid\tncr5380_abort;\nstatic __inline void ncr_sched_msgout;\n\nvoid\nncr5380_abort(sc)\n\tstruct ncr5380_softc *sc;\n{\n\n\t/*\n\t * Finish it now.  If DMA is in progress, we\n\t * can not call ncr_sched_msgout() because\n\t * that hits the SBC (avoid DMA conflict).\n\t */\n\n\t/* Another hack (Er.. hook!) for the sun3 si: */\n\tif (sc->sc_intr_off) {\n\t\tNCR_TRACE(\"abort: intr off\\n\", 0);\n\t\tsc->sc_intr_off(sc);\n\t}\n\n\tsc->sc_state |= NCR_ABORTING;\n\tif ((sc->sc_state & NCR_DOINGDMA) == 0) {\n\t\tncr_sched_msgout(sc, SEND_ABORT);\n\t}\n\tNCR_TRACE(\"abort: call machine, cur=0x%x\\n\",\n\t\t\t  (long) sc->sc_current);\n\tncr5380_machine(sc);\n\tNCR_TRACE(\"abort: machine done, cur=0x%x\\n\",\n\t\t\t  (long) sc->sc_current);\n\n\t/* Another hack (Er.. hook!) for the sun3 si: */\n\tif (sc->sc_intr_on) {\n\t\tNCR_TRACE(\"abort: intr ON\\n\", 0);\n\t    sc->sc_intr_on(sc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"cmd_tmo: call abort, sr=0x%x\\n\"",
            "(long) sr"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: cmd timeout, targ=%d, lun=%d\\n\"",
            "sc->sc_dev.dv_xname",
            "sr->sr_target",
            "sr->sr_lun"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "splbio",
          "args": [],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void\tncr5380_sched;\nstatic void\tncr5380_machine;\nvoid\tncr5380_abort;\nvoid\tncr5380_cmd_timeout;\n\nvoid\nncr5380_cmd_timeout(arg)\n\tvoid *arg;\n{\n\tstruct sci_req *sr = arg;\n\tstruct scsi_xfer *xs;\n\tstruct scsi_link *sc_link;\n\tstruct ncr5380_softc *sc;\n\tint s;\n\n\ts = splbio();\n\n\t/* Get all our variables... */\n\txs = sr->sr_xs;\n\tif (xs == NULL) {\n\t\tprintf(\"ncr5380_cmd_timeout: no scsi_xfer\\n\");\n\t\tgoto out;\n\t}\n\tsc_link = xs->sc_link;\n\tsc = sc_link->adapter_softc;\n\n\tprintf(\"%s: cmd timeout, targ=%d, lun=%d\\n\",\n\t    sc->sc_dev.dv_xname,\n\t    sr->sr_target, sr->sr_lun);\n\n\t/*\n\t * Mark the overdue job as failed, and arrange for\n\t * ncr5380_machine to terminate it.  If the victim\n\t * is the current job, call ncr5380_machine() now.\n\t * Otherwise arrange for ncr5380_sched() to do it.\n\t */\n\tsr->sr_flags |= SR_OVERDUE;\n\tif (sc->sc_current == sr) {\n\t\tNCR_TRACE(\"cmd_tmo: call abort, sr=0x%x\\n\", (long) sr);\n\t\tncr5380_abort(sc);\n\t} else {\n\t\t/*\n\t\t * The driver may be idle, or busy with another job.\n\t\t * Arrange for ncr5380_sched() to do the deed.\n\t\t */\n\t\tNCR_TRACE(\"cmd_tmo: clear matrix, t/l=0x%02x\\n\",\n\t\t\t\t  (sr->sr_target << 4) | sr->sr_lun);\n\t\tsc->sc_matrix[sr->sr_target][sr->sr_lun] = NULL;\n\t}\n\n\t/*\n\t * We may have aborted the current job, or may have\n\t * already been idle. In either case, we should now\n\t * be idle, so try to start another job.\n\t */\n\tif (sc->sc_state == NCR_IDLE) {\n\t\tNCR_TRACE(\"cmd_tmo: call sched, cur=0x%x\\n\",\n\t\t\t\t  (long) sc->sc_current);\n\t\tncr5380_sched(sc);\n\t\tNCR_TRACE(\"cmd_tmo: sched done, cur=0x%x\\n\",\n\t\t\t\t  (long) sc->sc_current);\n\t}\n\nout:\n\tsplx(s);\n}"
  },
  {
    "function_name": "ncr5380_abort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
    "lines": "481-513",
    "snippet": "void\nncr5380_abort(sc)\n\tstruct ncr5380_softc *sc;\n{\n\n\t/*\n\t * Finish it now.  If DMA is in progress, we\n\t * can not call ncr_sched_msgout() because\n\t * that hits the SBC (avoid DMA conflict).\n\t */\n\n\t/* Another hack (Er.. hook!) for the sun3 si: */\n\tif (sc->sc_intr_off) {\n\t\tNCR_TRACE(\"abort: intr off\\n\", 0);\n\t\tsc->sc_intr_off(sc);\n\t}\n\n\tsc->sc_state |= NCR_ABORTING;\n\tif ((sc->sc_state & NCR_DOINGDMA) == 0) {\n\t\tncr_sched_msgout(sc, SEND_ABORT);\n\t}\n\tNCR_TRACE(\"abort: call machine, cur=0x%x\\n\",\n\t\t\t  (long) sc->sc_current);\n\tncr5380_machine(sc);\n\tNCR_TRACE(\"abort: machine done, cur=0x%x\\n\",\n\t\t\t  (long) sc->sc_current);\n\n\t/* Another hack (Er.. hook!) for the sun3 si: */\n\tif (sc->sc_intr_on) {\n\t\tNCR_TRACE(\"abort: intr ON\\n\", 0);\n\t    sc->sc_intr_on(sc);\n\t}\n}",
    "includes": [
      "#include <dev/ic/ncr5380var.h>",
      "#include <dev/ic/ncr5380reg.h>",
      "#include <ddb/db_output.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\tncr5380_machine",
      "void\tncr5380_abort",
      "static __inline void ncr_sched_msgout"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sc->sc_intr_on",
          "args": [
            "sc"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"abort: intr ON\\n\"",
            "0"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"abort: machine done, cur=0x%x\\n\"",
            "(long) sc->sc_current"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr5380_machine",
          "args": [
            "sc"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_machine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "2191-2433",
          "snippet": "static void\nncr5380_machine(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tstruct sci_req *sr;\n\tstruct scsi_xfer *xs;\n\tint act_flags, phase, timo;\n\n#ifdef\tDIAGNOSTIC\n\tif (sc->sc_state == NCR_IDLE)\n\t\tpanic(\"ncr5380_machine: state=idle\");\n\tif (sc->sc_current == NULL)\n\t\tpanic(\"ncr5380_machine: no current cmd\");\n#endif\n\n\tsr = sc->sc_current;\n\txs = sr->sr_xs;\n\tact_flags = ACT_CONTINUE;\n\n\t/*\n\t * This will be called by ncr5380_intr() when DMA is\n\t * complete.  Must stop DMA before touching the 5380 or\n\t * there will be \"register conflict\" errors.\n\t */\n\tif (sc->sc_state & NCR_DOINGDMA) {\n\t\t/* Pick-up where where we left off... */\n\t\tgoto dma_done;\n\t}\n\nnext_phase:\n\n\tif (!SCI_BUSY(sc)) {\n\t\t/* Unexpected disconnect */\n\t\tprintf(\"ncr5380_machine: unexpected disconnect.\\n\");\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\tact_flags |= (ACT_DISCONNECT | ACT_CMD_DONE);\n\t\tgoto do_actions;\n\t}\n\n\t/*\n\t * Wait for REQ before reading the phase.\n\t * Need to wait longer than usual here, because\n\t * some devices are just plain slow...\n\t */\n\ttimo = ncr5380_wait_phase_timo;\n\tfor (;;) {\n\t\tif (*sc->sci_bus_csr & SCI_BUS_REQ)\n\t\t\tbreak;\n\t\tif (--timo <= 0) {\n\t\t\tif (sc->sc_state & NCR_ABORTING) {\n\t\t\t\tprintf(\"%s: no REQ while aborting, reset\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tact_flags |= ACT_RESET_BUS;\n\t\t\t\tgoto do_actions;\n\t\t\t}\n\t\t\tprintf(\"%s: no REQ for next phase, abort\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tsc->sc_state |= NCR_ABORTING;\n\t\t\tncr_sched_msgout(sc, SEND_ABORT);\n\t\t\tgoto next_phase;\n\t\t}\n\t\tdelay(100);\n\t}\n\n\tphase = SCI_BUS_PHASE(*sc->sci_bus_csr);\n\tNCR_TRACE(\"machine: phase=%s\\n\",\n\t\t\t  (long) phase_names[phase & 7]);\n\n\t/*\n\t * We assume that the device knows what it's doing,\n\t * so any phase is good.\n\t */\n\n#if 0\n\t/*\n\t * XXX: Do not ACK the phase yet! do it later...\n\t * XXX: ... each phase routine does that itself.\n\t * In particular, DMA needs it done LATER.\n\t */\n\t*sc->sci_tcmd = phase;\t/* acknowledge phase change */\n#endif\n\n\tswitch (phase) {\n\n\tcase PHASE_DATA_OUT:\n\tcase PHASE_DATA_IN:\n\t\tact_flags = ncr5380_data_xfer(sc, phase);\n\t\tbreak;\n\n\tcase PHASE_COMMAND:\n\t\tact_flags = ncr5380_command(sc);\n\t\tbreak;\n\n\tcase PHASE_STATUS:\n\t\tact_flags = ncr5380_status(sc);\n\t\tbreak;\n\n\tcase PHASE_MSG_OUT:\n\t\tact_flags = ncr5380_msg_out(sc);\n\t\tbreak;\n\n\tcase PHASE_MSG_IN:\n\t\tact_flags = ncr5380_msg_in(sc);\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"ncr5380_machine: Unexpected phase 0x%x\\n\", phase);\n\t\tsc->sc_state |= NCR_ABORTING;\n\t\tncr_sched_msgout(sc, SEND_ABORT);\n\t\tgoto next_phase;\n\n\t} /* switch */\n\tsc->sc_prevphase = phase;\n\ndo_actions:\n\t__asm(\"_ncr5380_actions:\");\n\n\tif (act_flags & ACT_WAIT_DMA) {\n\t\tact_flags &= ~ACT_WAIT_DMA;\n\t\t/* Wait for DMA to complete (polling, or interrupt). */\n\t\tif ((sr->sr_flags & SR_IMMED) == 0) {\n\t\t\tNCR_TRACE(\"machine: wait for DMA intr.\\n\", 0);\n\t\t\treturn; \t/* will resume at dma_done */\n\t\t}\n\t\t/* Busy-wait for it to finish. */\n\t\tNCR_TRACE(\"machine: dma_poll, dh=0x%x\\n\",\n\t\t\t\t  (long) sr->sr_dma_hand);\n\t\t(*sc->sc_dma_poll)(sc);\n\tdma_done:\n\t\t/* Return here after interrupt. */\n\t\tif (sr->sr_flags & SR_OVERDUE)\n\t\t\tsc->sc_state |= NCR_ABORTING;\n\t\tNCR_TRACE(\"machine: dma_stop, dh=0x%x\\n\",\n\t\t\t\t  (long) sr->sr_dma_hand);\n\t\t(*sc->sc_dma_stop)(sc);\n\t\tSCI_CLR_INTR(sc);\t/* XXX */\n\t\t/*\n\t\t * While DMA is running we can not touch the SBC,\n\t\t * so various places just set NCR_ABORTING and\n\t\t * expect us the \"kick it\" when DMA is done.\n\t\t */\n\t\tif (sc->sc_state & NCR_ABORTING) {\n\t\t\tncr_sched_msgout(sc, SEND_ABORT);\n\t\t}\n\t}\n\n\t/*\n\t * Check for parity error.\n\t * XXX - better place to check?\n\t */\n\tif (*(sc->sci_csr) & SCI_CSR_PERR) {\n\t\tprintf(\"%s: parity error!\\n\", sc->sc_dev.dv_xname);\n\t\t/* XXX: sc->sc_state |= NCR_ABORTING; */\n\t\tncr_sched_msgout(sc, SEND_PARITY_ERROR);\n\t}\n\n\tif (act_flags == ACT_CONTINUE)\n\t\tgoto next_phase;\n\t/* All other actions \"break\" from the loop. */\n\n\tNCR_TRACE(\"machine: act_flags=0x%x\\n\", act_flags);\n\n\tif (act_flags & ACT_RESET_BUS) {\n\t\tact_flags |= ACT_CMD_DONE;\n\t\t/*\n\t\t * Reset the SCSI bus, usually due to a timeout.\n\t\t * The error code XS_TIMEOUT allows retries.\n\t\t */\n\t\tsc->sc_state |= NCR_ABORTING;\n\t\tprintf(\"%s: reset SCSI bus for TID=%d LUN=%d\\n\",\n\t\t    sc->sc_dev.dv_xname, sr->sr_target, sr->sr_lun);\n\t\tncr5380_reset_scsibus(sc);\n\t}\n\n\tif (act_flags & ACT_CMD_DONE) {\n\t\tact_flags |= ACT_DISCONNECT;\n\t\t/* Need to call scsi_done() */\n\t\t/* XXX: from the aic6360 driver, but why? */\n\t\tif (sc->sc_datalen < 0) {\n\t\t\tprintf(\"%s: %d extra bytes from %d:%d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, -sc->sc_datalen,\n\t\t\t    sr->sr_target, sr->sr_lun);\n\t\t\tsc->sc_datalen = 0;\n\t\t}\n\t\txs->resid = sc->sc_datalen;\n\t\t/* Note: this will clear sc_current */\n\t\tNCR_TRACE(\"machine: call done, cur=0x%x\\n\", (long)sr);\n\t\tncr5380_done(sc);\n\t}\n\n\tif (act_flags & ACT_DISCONNECT) {\n\t\t/*\n\t\t * The device has dropped BSY (or will soon).\n\t\t * We have to wait here for BSY to drop, otherwise\n\t\t * the next command may decide we need a bus reset.\n\t\t */\n\t\ttimo = ncr5380_wait_req_timo;\t/* XXX */\n\t\tfor (;;) {\n\t\t\tif (!SCI_BUSY(sc))\n\t\t\t\tgoto busfree;\n\t\t\tif (--timo <= 0)\n\t\t\t\tbreak;\n\t\t\tdelay(2);\n\t\t}\n\t\t/* Device is sitting on the bus! */\n\t\tprintf(\"%s: Target %d LUN %d stuck busy, resetting...\\n\",\n\t\t    sc->sc_dev.dv_xname, sr->sr_target, sr->sr_lun);\n\t\tncr5380_reset_scsibus(sc);\n\tbusfree:\n\t\tNCR_TRACE(\"machine: discon, waited %d\\n\",\n\t\t\tncr5380_wait_nrq_timo - timo);\n\n\t\t*sc->sci_icmd = 0;\n\t\t*sc->sci_mode = 0;\n\t\t*sc->sci_tcmd = PHASE_INVALID;\n\t\t*sc->sci_sel_enb = 0;\n\t\tSCI_CLR_INTR(sc);\n\t\t*sc->sci_sel_enb = 0x80;\n\n\t\tif ((act_flags & ACT_CMD_DONE) == 0) {\n\t\t\t__asm(\"_ncr5380_disconnected:\");\n\t\t\tNCR_TRACE(\"machine: discon, cur=0x%x\\n\", (long)sr);\n\t\t}\n\n\t\t/*\n\t\t * We may be here due to a disconnect message,\n\t\t * in which case we did NOT call ncr5380_done,\n\t\t * and we need to clear sc_current.\n\t\t */\n\t\tsc->sc_state = NCR_IDLE;\n\t\tsc->sc_current = NULL;\n\n\t\t/* Paranoia: clear everything. */\n\t\tsc->sc_dataptr = NULL;\n\t\tsc->sc_datalen = 0;\n\t\tsc->sc_prevphase = PHASE_INVALID;\n\t\tsc->sc_msgpriq = 0;\n\t\tsc->sc_msgoutq = 0;\n\t\tsc->sc_msgout  = 0;\n\n\t\t/* Our caller will re-enable interrupts. */\n\t}\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define ACT_WAIT_DMA\t0x10\t/* Wait for DMA to complete */",
            "#define ACT_RESET_BUS\t0x04\t/* Need bus reset (cmd timeout) */",
            "#define ACT_CMD_DONE\t0x02\t/* Need to call scsi_done() */",
            "#define ACT_DISCONNECT\t0x01\t/* Target is disconnecting */",
            "#define ACT_CONTINUE\t0x00\t/* No flags: expect another phase */"
          ],
          "globals_used": [
            "static void\tncr5380_done",
            "static int\tncr5380_msg_in",
            "static int\tncr5380_msg_out",
            "static int\tncr5380_data_xfer",
            "static int\tncr5380_command",
            "static int\tncr5380_status",
            "static void\tncr5380_machine",
            "static char *\nphase_names[8] = {\n\t\"DATA_OUT\",\n\t\"DATA_IN\",\n\t\"COMMAND\",\n\t\"STATUS\",\n\t\"UNSPEC1\",\n\t\"UNSPEC2\",\n\t\"MSG_OUT\",\n\t\"MSG_IN\",\n};",
            "int ncr5380_wait_phase_timo = 1000 * 10 * 300;",
            "int ncr5380_wait_req_timo = 1000 * 50;",
            "int ncr5380_wait_nrq_timo = 1000 * 25;",
            "static __inline void ncr_sched_msgout"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define ACT_WAIT_DMA\t0x10\t/* Wait for DMA to complete */\n#define ACT_RESET_BUS\t0x04\t/* Need bus reset (cmd timeout) */\n#define ACT_CMD_DONE\t0x02\t/* Need to call scsi_done() */\n#define ACT_DISCONNECT\t0x01\t/* Target is disconnecting */\n#define ACT_CONTINUE\t0x00\t/* No flags: expect another phase */\n\nstatic void\tncr5380_done;\nstatic int\tncr5380_msg_in;\nstatic int\tncr5380_msg_out;\nstatic int\tncr5380_data_xfer;\nstatic int\tncr5380_command;\nstatic int\tncr5380_status;\nstatic void\tncr5380_machine;\nstatic char *\nphase_names[8] = {\n\t\"DATA_OUT\",\n\t\"DATA_IN\",\n\t\"COMMAND\",\n\t\"STATUS\",\n\t\"UNSPEC1\",\n\t\"UNSPEC2\",\n\t\"MSG_OUT\",\n\t\"MSG_IN\",\n};\nint ncr5380_wait_phase_timo = 1000 * 10 * 300;\nint ncr5380_wait_req_timo = 1000 * 50;\nint ncr5380_wait_nrq_timo = 1000 * 25;\nstatic __inline void ncr_sched_msgout;\n\nstatic void\nncr5380_machine(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tstruct sci_req *sr;\n\tstruct scsi_xfer *xs;\n\tint act_flags, phase, timo;\n\n#ifdef\tDIAGNOSTIC\n\tif (sc->sc_state == NCR_IDLE)\n\t\tpanic(\"ncr5380_machine: state=idle\");\n\tif (sc->sc_current == NULL)\n\t\tpanic(\"ncr5380_machine: no current cmd\");\n#endif\n\n\tsr = sc->sc_current;\n\txs = sr->sr_xs;\n\tact_flags = ACT_CONTINUE;\n\n\t/*\n\t * This will be called by ncr5380_intr() when DMA is\n\t * complete.  Must stop DMA before touching the 5380 or\n\t * there will be \"register conflict\" errors.\n\t */\n\tif (sc->sc_state & NCR_DOINGDMA) {\n\t\t/* Pick-up where where we left off... */\n\t\tgoto dma_done;\n\t}\n\nnext_phase:\n\n\tif (!SCI_BUSY(sc)) {\n\t\t/* Unexpected disconnect */\n\t\tprintf(\"ncr5380_machine: unexpected disconnect.\\n\");\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\tact_flags |= (ACT_DISCONNECT | ACT_CMD_DONE);\n\t\tgoto do_actions;\n\t}\n\n\t/*\n\t * Wait for REQ before reading the phase.\n\t * Need to wait longer than usual here, because\n\t * some devices are just plain slow...\n\t */\n\ttimo = ncr5380_wait_phase_timo;\n\tfor (;;) {\n\t\tif (*sc->sci_bus_csr & SCI_BUS_REQ)\n\t\t\tbreak;\n\t\tif (--timo <= 0) {\n\t\t\tif (sc->sc_state & NCR_ABORTING) {\n\t\t\t\tprintf(\"%s: no REQ while aborting, reset\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tact_flags |= ACT_RESET_BUS;\n\t\t\t\tgoto do_actions;\n\t\t\t}\n\t\t\tprintf(\"%s: no REQ for next phase, abort\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tsc->sc_state |= NCR_ABORTING;\n\t\t\tncr_sched_msgout(sc, SEND_ABORT);\n\t\t\tgoto next_phase;\n\t\t}\n\t\tdelay(100);\n\t}\n\n\tphase = SCI_BUS_PHASE(*sc->sci_bus_csr);\n\tNCR_TRACE(\"machine: phase=%s\\n\",\n\t\t\t  (long) phase_names[phase & 7]);\n\n\t/*\n\t * We assume that the device knows what it's doing,\n\t * so any phase is good.\n\t */\n\n#if 0\n\t/*\n\t * XXX: Do not ACK the phase yet! do it later...\n\t * XXX: ... each phase routine does that itself.\n\t * In particular, DMA needs it done LATER.\n\t */\n\t*sc->sci_tcmd = phase;\t/* acknowledge phase change */\n#endif\n\n\tswitch (phase) {\n\n\tcase PHASE_DATA_OUT:\n\tcase PHASE_DATA_IN:\n\t\tact_flags = ncr5380_data_xfer(sc, phase);\n\t\tbreak;\n\n\tcase PHASE_COMMAND:\n\t\tact_flags = ncr5380_command(sc);\n\t\tbreak;\n\n\tcase PHASE_STATUS:\n\t\tact_flags = ncr5380_status(sc);\n\t\tbreak;\n\n\tcase PHASE_MSG_OUT:\n\t\tact_flags = ncr5380_msg_out(sc);\n\t\tbreak;\n\n\tcase PHASE_MSG_IN:\n\t\tact_flags = ncr5380_msg_in(sc);\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"ncr5380_machine: Unexpected phase 0x%x\\n\", phase);\n\t\tsc->sc_state |= NCR_ABORTING;\n\t\tncr_sched_msgout(sc, SEND_ABORT);\n\t\tgoto next_phase;\n\n\t} /* switch */\n\tsc->sc_prevphase = phase;\n\ndo_actions:\n\t__asm(\"_ncr5380_actions:\");\n\n\tif (act_flags & ACT_WAIT_DMA) {\n\t\tact_flags &= ~ACT_WAIT_DMA;\n\t\t/* Wait for DMA to complete (polling, or interrupt). */\n\t\tif ((sr->sr_flags & SR_IMMED) == 0) {\n\t\t\tNCR_TRACE(\"machine: wait for DMA intr.\\n\", 0);\n\t\t\treturn; \t/* will resume at dma_done */\n\t\t}\n\t\t/* Busy-wait for it to finish. */\n\t\tNCR_TRACE(\"machine: dma_poll, dh=0x%x\\n\",\n\t\t\t\t  (long) sr->sr_dma_hand);\n\t\t(*sc->sc_dma_poll)(sc);\n\tdma_done:\n\t\t/* Return here after interrupt. */\n\t\tif (sr->sr_flags & SR_OVERDUE)\n\t\t\tsc->sc_state |= NCR_ABORTING;\n\t\tNCR_TRACE(\"machine: dma_stop, dh=0x%x\\n\",\n\t\t\t\t  (long) sr->sr_dma_hand);\n\t\t(*sc->sc_dma_stop)(sc);\n\t\tSCI_CLR_INTR(sc);\t/* XXX */\n\t\t/*\n\t\t * While DMA is running we can not touch the SBC,\n\t\t * so various places just set NCR_ABORTING and\n\t\t * expect us the \"kick it\" when DMA is done.\n\t\t */\n\t\tif (sc->sc_state & NCR_ABORTING) {\n\t\t\tncr_sched_msgout(sc, SEND_ABORT);\n\t\t}\n\t}\n\n\t/*\n\t * Check for parity error.\n\t * XXX - better place to check?\n\t */\n\tif (*(sc->sci_csr) & SCI_CSR_PERR) {\n\t\tprintf(\"%s: parity error!\\n\", sc->sc_dev.dv_xname);\n\t\t/* XXX: sc->sc_state |= NCR_ABORTING; */\n\t\tncr_sched_msgout(sc, SEND_PARITY_ERROR);\n\t}\n\n\tif (act_flags == ACT_CONTINUE)\n\t\tgoto next_phase;\n\t/* All other actions \"break\" from the loop. */\n\n\tNCR_TRACE(\"machine: act_flags=0x%x\\n\", act_flags);\n\n\tif (act_flags & ACT_RESET_BUS) {\n\t\tact_flags |= ACT_CMD_DONE;\n\t\t/*\n\t\t * Reset the SCSI bus, usually due to a timeout.\n\t\t * The error code XS_TIMEOUT allows retries.\n\t\t */\n\t\tsc->sc_state |= NCR_ABORTING;\n\t\tprintf(\"%s: reset SCSI bus for TID=%d LUN=%d\\n\",\n\t\t    sc->sc_dev.dv_xname, sr->sr_target, sr->sr_lun);\n\t\tncr5380_reset_scsibus(sc);\n\t}\n\n\tif (act_flags & ACT_CMD_DONE) {\n\t\tact_flags |= ACT_DISCONNECT;\n\t\t/* Need to call scsi_done() */\n\t\t/* XXX: from the aic6360 driver, but why? */\n\t\tif (sc->sc_datalen < 0) {\n\t\t\tprintf(\"%s: %d extra bytes from %d:%d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, -sc->sc_datalen,\n\t\t\t    sr->sr_target, sr->sr_lun);\n\t\t\tsc->sc_datalen = 0;\n\t\t}\n\t\txs->resid = sc->sc_datalen;\n\t\t/* Note: this will clear sc_current */\n\t\tNCR_TRACE(\"machine: call done, cur=0x%x\\n\", (long)sr);\n\t\tncr5380_done(sc);\n\t}\n\n\tif (act_flags & ACT_DISCONNECT) {\n\t\t/*\n\t\t * The device has dropped BSY (or will soon).\n\t\t * We have to wait here for BSY to drop, otherwise\n\t\t * the next command may decide we need a bus reset.\n\t\t */\n\t\ttimo = ncr5380_wait_req_timo;\t/* XXX */\n\t\tfor (;;) {\n\t\t\tif (!SCI_BUSY(sc))\n\t\t\t\tgoto busfree;\n\t\t\tif (--timo <= 0)\n\t\t\t\tbreak;\n\t\t\tdelay(2);\n\t\t}\n\t\t/* Device is sitting on the bus! */\n\t\tprintf(\"%s: Target %d LUN %d stuck busy, resetting...\\n\",\n\t\t    sc->sc_dev.dv_xname, sr->sr_target, sr->sr_lun);\n\t\tncr5380_reset_scsibus(sc);\n\tbusfree:\n\t\tNCR_TRACE(\"machine: discon, waited %d\\n\",\n\t\t\tncr5380_wait_nrq_timo - timo);\n\n\t\t*sc->sci_icmd = 0;\n\t\t*sc->sci_mode = 0;\n\t\t*sc->sci_tcmd = PHASE_INVALID;\n\t\t*sc->sci_sel_enb = 0;\n\t\tSCI_CLR_INTR(sc);\n\t\t*sc->sci_sel_enb = 0x80;\n\n\t\tif ((act_flags & ACT_CMD_DONE) == 0) {\n\t\t\t__asm(\"_ncr5380_disconnected:\");\n\t\t\tNCR_TRACE(\"machine: discon, cur=0x%x\\n\", (long)sr);\n\t\t}\n\n\t\t/*\n\t\t * We may be here due to a disconnect message,\n\t\t * in which case we did NOT call ncr5380_done,\n\t\t * and we need to clear sc_current.\n\t\t */\n\t\tsc->sc_state = NCR_IDLE;\n\t\tsc->sc_current = NULL;\n\n\t\t/* Paranoia: clear everything. */\n\t\tsc->sc_dataptr = NULL;\n\t\tsc->sc_datalen = 0;\n\t\tsc->sc_prevphase = PHASE_INVALID;\n\t\tsc->sc_msgpriq = 0;\n\t\tsc->sc_msgoutq = 0;\n\t\tsc->sc_msgout  = 0;\n\n\t\t/* Our caller will re-enable interrupts. */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"abort: call machine, cur=0x%x\\n\"",
            "(long) sc->sc_current"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr_sched_msgout",
          "args": [
            "sc",
            "SEND_ABORT"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_sched_msgout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "222-235",
          "snippet": "static __inline void\nncr_sched_msgout(sc, msg_code)\n\tstruct ncr5380_softc *sc;\n\tint msg_code;\n{\n\t/* First time, raise ATN line. */\n\tif (sc->sc_msgpriq == 0) {\n\t\tregister u_char icmd;\n\t\ticmd = *sc->sci_icmd & SCI_ICMD_RMASK;\n\t\t*sc->sci_icmd = icmd | SCI_ICMD_ATN;\n\t\tdelay(2);\n\t}\n\tsc->sc_msgpriq |= msg_code;\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __inline void ncr_sched_msgout"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic __inline void ncr_sched_msgout;\n\nstatic __inline void\nncr_sched_msgout(sc, msg_code)\n\tstruct ncr5380_softc *sc;\n\tint msg_code;\n{\n\t/* First time, raise ATN line. */\n\tif (sc->sc_msgpriq == 0) {\n\t\tregister u_char icmd;\n\t\ticmd = *sc->sci_icmd & SCI_ICMD_RMASK;\n\t\t*sc->sci_icmd = icmd | SCI_ICMD_ATN;\n\t\tdelay(2);\n\t}\n\tsc->sc_msgpriq |= msg_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc->sc_intr_off",
          "args": [
            "sc"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"abort: intr off\\n\"",
            "0"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void\tncr5380_machine;\nvoid\tncr5380_abort;\nstatic __inline void ncr_sched_msgout;\n\nvoid\nncr5380_abort(sc)\n\tstruct ncr5380_softc *sc;\n{\n\n\t/*\n\t * Finish it now.  If DMA is in progress, we\n\t * can not call ncr_sched_msgout() because\n\t * that hits the SBC (avoid DMA conflict).\n\t */\n\n\t/* Another hack (Er.. hook!) for the sun3 si: */\n\tif (sc->sc_intr_off) {\n\t\tNCR_TRACE(\"abort: intr off\\n\", 0);\n\t\tsc->sc_intr_off(sc);\n\t}\n\n\tsc->sc_state |= NCR_ABORTING;\n\tif ((sc->sc_state & NCR_DOINGDMA) == 0) {\n\t\tncr_sched_msgout(sc, SEND_ABORT);\n\t}\n\tNCR_TRACE(\"abort: call machine, cur=0x%x\\n\",\n\t\t\t  (long) sc->sc_current);\n\tncr5380_machine(sc);\n\tNCR_TRACE(\"abort: machine done, cur=0x%x\\n\",\n\t\t\t  (long) sc->sc_current);\n\n\t/* Another hack (Er.. hook!) for the sun3 si: */\n\tif (sc->sc_intr_on) {\n\t\tNCR_TRACE(\"abort: intr ON\\n\", 0);\n\t    sc->sc_intr_on(sc);\n\t}\n}"
  },
  {
    "function_name": "ncr5380_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
    "lines": "418-475",
    "snippet": "int\nncr5380_intr(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tint claimed = 0;\n\n\t/*\n\t * Do not touch SBC regs here unless sc_current == NULL\n\t * or it will complain about \"register conflict\" errors.\n\t * Instead, just let ncr5380_machine() deal with it.\n\t */\n\tNCR_TRACE(\"intr: top, state=%d\\n\", sc->sc_state);\n\n\tif (sc->sc_state == NCR_IDLE) {\n\t\t/*\n\t\t * Might be reselect.  ncr5380_reselect() will check,\n\t\t * and set up the connection if so.  This will verify\n\t\t * that sc_current == NULL at the beginning...\n\t\t */\n\n\t\t/* Another hack (Er.. hook!) for the sun3 si: */\n\t\tif (sc->sc_intr_off) {\n\t\t\tNCR_TRACE(\"intr: for reselect, intr off\\n\", 0);\n\t\t    sc->sc_intr_off(sc);\n\t\t}\n\n\t\tncr5380_reselect(sc);\n\t}\n\n\t/*\n\t * The remaining documented interrupt causes are phase mismatch and\n\t * disconnect.  In addition, the sunsi controller may produce a state\n\t * where SCI_CSR_DONE is false, yet DMA is complete.\n\t *\n\t * The procedure in all these cases is to let ncr5380_machine()\n\t * figure out what to do next.\n\t */\n\tif (sc->sc_state & NCR_WORKING) {\n\t\tNCR_TRACE(\"intr: call machine, cur=0x%x\\n\",\n\t\t\t\t  (long) sc->sc_current);\n\t\t/* This will usually free-up the nexus. */\n\t\tncr5380_machine(sc);\n\t\tNCR_TRACE(\"intr: machine done, cur=0x%x\\n\",\n\t\t\t\t  (long) sc->sc_current);\n\t\tclaimed = 1;\n\t}\n\n\t/* Maybe we can run some commands now... */\n\tif (sc->sc_state == NCR_IDLE) {\n\t\tNCR_TRACE(\"intr: call sched, cur=0x%x\\n\",\n\t\t\t\t  (long) sc->sc_current);\n\t\tncr5380_sched(sc);\n\t\tNCR_TRACE(\"intr: sched done, cur=0x%x\\n\",\n\t\t\t\t  (long) sc->sc_current);\n\t}\n\n\treturn claimed;\n}",
    "includes": [
      "#include <dev/ic/ncr5380var.h>",
      "#include <dev/ic/ncr5380reg.h>",
      "#include <ddb/db_output.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\tncr5380_sched",
      "static void\tncr5380_reselect",
      "static void\tncr5380_machine"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"intr: sched done, cur=0x%x\\n\"",
            "(long) sc->sc_current"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr5380_sched",
          "args": [
            "sc"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_sched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "827-1063",
          "snippet": "static void\nncr5380_sched(sc)\n\tstruct\tncr5380_softc *sc;\n{\n\tstruct sci_req\t*sr;\n\tstruct scsi_xfer *xs;\n\tint\ttarget = 0, lun = 0;\n\tint\terror, i;\n\n\t/* Another hack (Er.. hook!) for the sun3 si: */\n\tif (sc->sc_intr_off) {\n\t\tNCR_TRACE(\"sched: top, intr off\\n\", 0);\n\t    sc->sc_intr_off(sc);\n\t}\n\nnext_job:\n\t/*\n\t * Grab the next job from queue.  Must be idle.\n\t */\n#ifdef\tDIAGNOSTIC\n\tif (sc->sc_state != NCR_IDLE)\n\t\tpanic(\"ncr5380_sched: not idle\");\n\tif (sc->sc_current)\n\t\tpanic(\"ncr5380_sched: current set\");\n#endif\n\n\t/*\n\t * Always start the search where we last looked.\n\t * The REQUEST_SENSE logic depends on this to\n\t * choose the same job as was last picked, so it\n\t * can just clear sc_current and reschedule.\n\t * (Avoids loss of \"contingent allegiance\".)\n\t */\n\ti = sc->sc_rr;\n\tsr = NULL;\n\tdo {\n\t\tif (sc->sc_ring[i].sr_xs) {\n\t\t\ttarget = sc->sc_ring[i].sr_target;\n\t\t\tlun = sc->sc_ring[i].sr_lun;\n\t\t\tif (sc->sc_matrix[target][lun] == NULL) {\n\t\t\t\t/*\n\t\t\t\t * Do not mark the  target/LUN busy yet,\n\t\t\t\t * because reselect may cause some other\n\t\t\t\t * job to become the current one, so we\n\t\t\t\t * might not actually start this job.\n\t\t\t\t * Instead, set sc_matrix later on.\n\t\t\t\t */\n\t\t\t\tsc->sc_rr = i;\n\t\t\t\tsr = &sc->sc_ring[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t\tif (i == SCI_OPENINGS)\n\t\t\ti = 0;\n\t} while (i != sc->sc_rr);\n\n\tif (sr == NULL) {\n\t\tNCR_TRACE(\"sched: no work, cur=0x%x\\n\",\n\t\t\t\t  (long) sc->sc_current);\n\n\t\t/* Another hack (Er.. hook!) for the sun3 si: */\n\t\tif (sc->sc_intr_on) {\n\t\t\tNCR_TRACE(\"sched: ret, intr ON\\n\", 0);\n\t\t    sc->sc_intr_on(sc);\n\t\t}\n\n\t\treturn;\t\t/* No more work to do. */\n\t}\n\n\tNCR_TRACE(\"sched: select for t/l=0x%02x\\n\",\n\t\t\t  (sr->sr_target << 4) | sr->sr_lun);\n\n\tsc->sc_state = NCR_WORKING;\n\terror = ncr5380_select(sc, sr);\n\tif (sc->sc_current) {\n\t\t/* Lost the race!  reselected out from under us! */\n\t\t/* Work with the reselected job. */\n\t\tif (sr->sr_flags & SR_IMMED) {\n\t\t\tprintf(\"%s: reselected while polling (abort)\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t/* Abort the reselected job. */\n\t\t\tsc->sc_state |= NCR_ABORTING;\n\t\t\tsc->sc_msgpriq |= SEND_ABORT;\n\t\t}\n\t\tsr = sc->sc_current;\n\t\txs = sr->sr_xs;\n\t\tNCR_TRACE(\"sched: reselect, new sr=0x%x\\n\", (long)sr);\n\t\tgoto have_nexus;\n\t}\n\n\t/* Normal selection result.  Target/LUN is now busy. */\n\tsc->sc_matrix[target][lun] = sr;\n\tsc->sc_current = sr;\t/* connected */\n\txs = sr->sr_xs;\n\n\t/*\n\t * Initialize pointers, etc. for this job\n\t */\n\tsc->sc_dataptr  = sr->sr_dataptr;\n\tsc->sc_datalen  = sr->sr_datalen;\n\tsc->sc_prevphase = PHASE_INVALID;\n\tsc->sc_msgpriq = SEND_IDENTIFY;\n\tsc->sc_msgoutq = 0;\n\tsc->sc_msgout  = 0;\n\n\tNCR_TRACE(\"sched: select rv=%d\\n\", error);\n\n\tswitch (error) {\n\tcase XS_NOERROR:\n\t\tbreak;\n\n\tcase XS_BUSY:\n\t\t/* XXX - Reset and try again. */\n\t\tprintf(\"%s: select found SCSI bus busy, resetting...\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tncr5380_reset_scsibus(sc);\n\t\t/* fallthrough */\n\tcase XS_SELTIMEOUT:\n\tdefault:\n\t\txs->error = error;\t/* from select */\n\t\tNCR_TRACE(\"sched: call done, sr=0x%x\\n\", (long)sr);\n\t\tncr5380_done(sc);\n\n\t\t/* Paranoia: clear everything. */\n\t\tsc->sc_dataptr = NULL;\n\t\tsc->sc_datalen = 0;\n\t\tsc->sc_prevphase = PHASE_INVALID;\n\t\tsc->sc_msgpriq = 0;\n\t\tsc->sc_msgoutq = 0;\n\t\tsc->sc_msgout  = 0;\n\n\t\tgoto next_job;\n\t}\n\n\t/*\n\t * Selection was successful.  Normally, this means\n\t * we are starting a new command.  However, this\n\t * might be the termination of an overdue job.\n\t */\n\tif (sr->sr_flags & SR_OVERDUE) {\n\t\tNCR_TRACE(\"sched: overdue, sr=0x%x\\n\", (long)sr);\n\t\tsc->sc_state |= NCR_ABORTING;\n\t\tsc->sc_msgpriq |= SEND_ABORT;\n\t\tgoto have_nexus;\n\t}\n\n\t/*\n\t * This may be the continuation of some job that\n\t * completed with a \"check condition\" code.\n\t */\n\tif (sr->sr_flags & SR_SENSE) {\n\t\tNCR_TRACE(\"sched: get sense, sr=0x%x\\n\", (long)sr);\n\t\t/* Do not allocate DMA, nor set timeout. */\n\t\tgoto have_nexus;\n\t}\n\n\t/*\n\t * OK, we are starting a new command.\n\t * Initialize and allocate resources for the new command.\n\t * Device reset is special (only uses MSG_OUT phase).\n\t * Normal commands start in MSG_OUT phase where we will\n\t * send and IDENDIFY message, and then expect CMD phase.\n\t */\n#ifdef\tNCR5380_DEBUG\n\tif (ncr5380_debug & NCR_DBG_CMDS) {\n\t\tprintf(\"ncr5380_sched: begin, target=%d, LUN=%d\\n\",\n\t\t    xs->sc_link->target, xs->sc_link->lun);\n\t\tncr5380_show_scsi_cmd(xs);\n\t}\n#endif\n\tif (xs->flags & SCSI_RESET) {\n\t\tNCR_TRACE(\"sched: cmd=reset, sr=0x%x\\n\", (long)sr);\n\t\t/* Not an error, so do not set NCR_ABORTING */\n\t\tsc->sc_msgpriq |= SEND_DEV_RESET;\n\t\tgoto have_nexus;\n\t}\n\n#ifdef\tDIAGNOSTIC\n\tif ((xs->flags & (SCSI_DATA_IN | SCSI_DATA_OUT)) == 0) {\n\t\tif (sc->sc_dataptr) {\n\t\t\tprintf(\"%s: ptr but no data in/out flags?\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tNCR_BREAK();\n\t\t\tsc->sc_dataptr = NULL;\n\t\t}\n\t}\n#endif\n\n\t/* Allocate DMA space (maybe) */\n\tif (sc->sc_dataptr && sc->sc_dma_alloc &&\n\t\t(sc->sc_datalen >= sc->sc_min_dma_len))\n\t{\n\t\tNCR_TRACE(\"sched: dma_alloc, len=%d\\n\", sc->sc_datalen);\n\t\t(*sc->sc_dma_alloc)(sc);\n\t}\n\n\t/*\n\t * Initialization hook called just after select,\n\t * at the beginning of COMMAND phase.\n\t * (but AFTER the DMA allocation is done)\n\t *\n\t * The evil Sun \"si\" adapter (OBIO variant) needs some\n\t * setup done to the DMA engine BEFORE the target puts\n\t * the SCSI bus into any DATA phase.\n\t */\n\tif (sr->sr_dma_hand && sc->sc_dma_setup) {\n\t\tNCR_TRACE(\"sched: dma_setup, dh=0x%x\\n\",\n\t\t\t\t  (long) sr->sr_dma_hand);\n\t    sc->sc_dma_setup(sc);\n\t}\n\n\t/*\n\t * Schedule a timeout for the job we are starting.\n\t */\n\tif ((sr->sr_flags & SR_IMMED) == 0) {\n\t\ti = (xs->timeout * hz) / 1000;\n\t\tNCR_TRACE(\"sched: set timeout=%d\\n\", i);\n\t\ttimeout(ncr5380_cmd_timeout, sr, i);\n\t}\n\nhave_nexus:\n\tNCR_TRACE(\"sched: call machine, cur=0x%x\\n\",\n\t\t\t  (long) sc->sc_current);\n\tncr5380_machine(sc);\n\tNCR_TRACE(\"sched: machine done, cur=0x%x\\n\",\n\t\t\t  (long) sc->sc_current);\n\n\t/*\n\t * What state did ncr5380_machine() leave us in?\n\t * Hopefully it sometimes completes a job...\n\t */\n\tif (sc->sc_state == NCR_IDLE)\n\t\tgoto next_job;\n\n\treturn; \t/* Have work in progress. */\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define\tNCR_DBG_CMDS\t2"
          ],
          "globals_used": [
            "static void\tncr5380_sched",
            "static void\tncr5380_done",
            "static int\tncr5380_select",
            "static void\tncr5380_machine",
            "void\tncr5380_cmd_timeout"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define\tNCR_DBG_CMDS\t2\n\nstatic void\tncr5380_sched;\nstatic void\tncr5380_done;\nstatic int\tncr5380_select;\nstatic void\tncr5380_machine;\nvoid\tncr5380_cmd_timeout;\n\nstatic void\nncr5380_sched(sc)\n\tstruct\tncr5380_softc *sc;\n{\n\tstruct sci_req\t*sr;\n\tstruct scsi_xfer *xs;\n\tint\ttarget = 0, lun = 0;\n\tint\terror, i;\n\n\t/* Another hack (Er.. hook!) for the sun3 si: */\n\tif (sc->sc_intr_off) {\n\t\tNCR_TRACE(\"sched: top, intr off\\n\", 0);\n\t    sc->sc_intr_off(sc);\n\t}\n\nnext_job:\n\t/*\n\t * Grab the next job from queue.  Must be idle.\n\t */\n#ifdef\tDIAGNOSTIC\n\tif (sc->sc_state != NCR_IDLE)\n\t\tpanic(\"ncr5380_sched: not idle\");\n\tif (sc->sc_current)\n\t\tpanic(\"ncr5380_sched: current set\");\n#endif\n\n\t/*\n\t * Always start the search where we last looked.\n\t * The REQUEST_SENSE logic depends on this to\n\t * choose the same job as was last picked, so it\n\t * can just clear sc_current and reschedule.\n\t * (Avoids loss of \"contingent allegiance\".)\n\t */\n\ti = sc->sc_rr;\n\tsr = NULL;\n\tdo {\n\t\tif (sc->sc_ring[i].sr_xs) {\n\t\t\ttarget = sc->sc_ring[i].sr_target;\n\t\t\tlun = sc->sc_ring[i].sr_lun;\n\t\t\tif (sc->sc_matrix[target][lun] == NULL) {\n\t\t\t\t/*\n\t\t\t\t * Do not mark the  target/LUN busy yet,\n\t\t\t\t * because reselect may cause some other\n\t\t\t\t * job to become the current one, so we\n\t\t\t\t * might not actually start this job.\n\t\t\t\t * Instead, set sc_matrix later on.\n\t\t\t\t */\n\t\t\t\tsc->sc_rr = i;\n\t\t\t\tsr = &sc->sc_ring[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t\tif (i == SCI_OPENINGS)\n\t\t\ti = 0;\n\t} while (i != sc->sc_rr);\n\n\tif (sr == NULL) {\n\t\tNCR_TRACE(\"sched: no work, cur=0x%x\\n\",\n\t\t\t\t  (long) sc->sc_current);\n\n\t\t/* Another hack (Er.. hook!) for the sun3 si: */\n\t\tif (sc->sc_intr_on) {\n\t\t\tNCR_TRACE(\"sched: ret, intr ON\\n\", 0);\n\t\t    sc->sc_intr_on(sc);\n\t\t}\n\n\t\treturn;\t\t/* No more work to do. */\n\t}\n\n\tNCR_TRACE(\"sched: select for t/l=0x%02x\\n\",\n\t\t\t  (sr->sr_target << 4) | sr->sr_lun);\n\n\tsc->sc_state = NCR_WORKING;\n\terror = ncr5380_select(sc, sr);\n\tif (sc->sc_current) {\n\t\t/* Lost the race!  reselected out from under us! */\n\t\t/* Work with the reselected job. */\n\t\tif (sr->sr_flags & SR_IMMED) {\n\t\t\tprintf(\"%s: reselected while polling (abort)\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t/* Abort the reselected job. */\n\t\t\tsc->sc_state |= NCR_ABORTING;\n\t\t\tsc->sc_msgpriq |= SEND_ABORT;\n\t\t}\n\t\tsr = sc->sc_current;\n\t\txs = sr->sr_xs;\n\t\tNCR_TRACE(\"sched: reselect, new sr=0x%x\\n\", (long)sr);\n\t\tgoto have_nexus;\n\t}\n\n\t/* Normal selection result.  Target/LUN is now busy. */\n\tsc->sc_matrix[target][lun] = sr;\n\tsc->sc_current = sr;\t/* connected */\n\txs = sr->sr_xs;\n\n\t/*\n\t * Initialize pointers, etc. for this job\n\t */\n\tsc->sc_dataptr  = sr->sr_dataptr;\n\tsc->sc_datalen  = sr->sr_datalen;\n\tsc->sc_prevphase = PHASE_INVALID;\n\tsc->sc_msgpriq = SEND_IDENTIFY;\n\tsc->sc_msgoutq = 0;\n\tsc->sc_msgout  = 0;\n\n\tNCR_TRACE(\"sched: select rv=%d\\n\", error);\n\n\tswitch (error) {\n\tcase XS_NOERROR:\n\t\tbreak;\n\n\tcase XS_BUSY:\n\t\t/* XXX - Reset and try again. */\n\t\tprintf(\"%s: select found SCSI bus busy, resetting...\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\tncr5380_reset_scsibus(sc);\n\t\t/* fallthrough */\n\tcase XS_SELTIMEOUT:\n\tdefault:\n\t\txs->error = error;\t/* from select */\n\t\tNCR_TRACE(\"sched: call done, sr=0x%x\\n\", (long)sr);\n\t\tncr5380_done(sc);\n\n\t\t/* Paranoia: clear everything. */\n\t\tsc->sc_dataptr = NULL;\n\t\tsc->sc_datalen = 0;\n\t\tsc->sc_prevphase = PHASE_INVALID;\n\t\tsc->sc_msgpriq = 0;\n\t\tsc->sc_msgoutq = 0;\n\t\tsc->sc_msgout  = 0;\n\n\t\tgoto next_job;\n\t}\n\n\t/*\n\t * Selection was successful.  Normally, this means\n\t * we are starting a new command.  However, this\n\t * might be the termination of an overdue job.\n\t */\n\tif (sr->sr_flags & SR_OVERDUE) {\n\t\tNCR_TRACE(\"sched: overdue, sr=0x%x\\n\", (long)sr);\n\t\tsc->sc_state |= NCR_ABORTING;\n\t\tsc->sc_msgpriq |= SEND_ABORT;\n\t\tgoto have_nexus;\n\t}\n\n\t/*\n\t * This may be the continuation of some job that\n\t * completed with a \"check condition\" code.\n\t */\n\tif (sr->sr_flags & SR_SENSE) {\n\t\tNCR_TRACE(\"sched: get sense, sr=0x%x\\n\", (long)sr);\n\t\t/* Do not allocate DMA, nor set timeout. */\n\t\tgoto have_nexus;\n\t}\n\n\t/*\n\t * OK, we are starting a new command.\n\t * Initialize and allocate resources for the new command.\n\t * Device reset is special (only uses MSG_OUT phase).\n\t * Normal commands start in MSG_OUT phase where we will\n\t * send and IDENDIFY message, and then expect CMD phase.\n\t */\n#ifdef\tNCR5380_DEBUG\n\tif (ncr5380_debug & NCR_DBG_CMDS) {\n\t\tprintf(\"ncr5380_sched: begin, target=%d, LUN=%d\\n\",\n\t\t    xs->sc_link->target, xs->sc_link->lun);\n\t\tncr5380_show_scsi_cmd(xs);\n\t}\n#endif\n\tif (xs->flags & SCSI_RESET) {\n\t\tNCR_TRACE(\"sched: cmd=reset, sr=0x%x\\n\", (long)sr);\n\t\t/* Not an error, so do not set NCR_ABORTING */\n\t\tsc->sc_msgpriq |= SEND_DEV_RESET;\n\t\tgoto have_nexus;\n\t}\n\n#ifdef\tDIAGNOSTIC\n\tif ((xs->flags & (SCSI_DATA_IN | SCSI_DATA_OUT)) == 0) {\n\t\tif (sc->sc_dataptr) {\n\t\t\tprintf(\"%s: ptr but no data in/out flags?\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tNCR_BREAK();\n\t\t\tsc->sc_dataptr = NULL;\n\t\t}\n\t}\n#endif\n\n\t/* Allocate DMA space (maybe) */\n\tif (sc->sc_dataptr && sc->sc_dma_alloc &&\n\t\t(sc->sc_datalen >= sc->sc_min_dma_len))\n\t{\n\t\tNCR_TRACE(\"sched: dma_alloc, len=%d\\n\", sc->sc_datalen);\n\t\t(*sc->sc_dma_alloc)(sc);\n\t}\n\n\t/*\n\t * Initialization hook called just after select,\n\t * at the beginning of COMMAND phase.\n\t * (but AFTER the DMA allocation is done)\n\t *\n\t * The evil Sun \"si\" adapter (OBIO variant) needs some\n\t * setup done to the DMA engine BEFORE the target puts\n\t * the SCSI bus into any DATA phase.\n\t */\n\tif (sr->sr_dma_hand && sc->sc_dma_setup) {\n\t\tNCR_TRACE(\"sched: dma_setup, dh=0x%x\\n\",\n\t\t\t\t  (long) sr->sr_dma_hand);\n\t    sc->sc_dma_setup(sc);\n\t}\n\n\t/*\n\t * Schedule a timeout for the job we are starting.\n\t */\n\tif ((sr->sr_flags & SR_IMMED) == 0) {\n\t\ti = (xs->timeout * hz) / 1000;\n\t\tNCR_TRACE(\"sched: set timeout=%d\\n\", i);\n\t\ttimeout(ncr5380_cmd_timeout, sr, i);\n\t}\n\nhave_nexus:\n\tNCR_TRACE(\"sched: call machine, cur=0x%x\\n\",\n\t\t\t  (long) sc->sc_current);\n\tncr5380_machine(sc);\n\tNCR_TRACE(\"sched: machine done, cur=0x%x\\n\",\n\t\t\t  (long) sc->sc_current);\n\n\t/*\n\t * What state did ncr5380_machine() leave us in?\n\t * Hopefully it sometimes completes a job...\n\t */\n\tif (sc->sc_state == NCR_IDLE)\n\t\tgoto next_job;\n\n\treturn; \t/* Have work in progress. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"intr: call sched, cur=0x%x\\n\"",
            "(long) sc->sc_current"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"intr: machine done, cur=0x%x\\n\"",
            "(long) sc->sc_current"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr5380_machine",
          "args": [
            "sc"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_machine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "2191-2433",
          "snippet": "static void\nncr5380_machine(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tstruct sci_req *sr;\n\tstruct scsi_xfer *xs;\n\tint act_flags, phase, timo;\n\n#ifdef\tDIAGNOSTIC\n\tif (sc->sc_state == NCR_IDLE)\n\t\tpanic(\"ncr5380_machine: state=idle\");\n\tif (sc->sc_current == NULL)\n\t\tpanic(\"ncr5380_machine: no current cmd\");\n#endif\n\n\tsr = sc->sc_current;\n\txs = sr->sr_xs;\n\tact_flags = ACT_CONTINUE;\n\n\t/*\n\t * This will be called by ncr5380_intr() when DMA is\n\t * complete.  Must stop DMA before touching the 5380 or\n\t * there will be \"register conflict\" errors.\n\t */\n\tif (sc->sc_state & NCR_DOINGDMA) {\n\t\t/* Pick-up where where we left off... */\n\t\tgoto dma_done;\n\t}\n\nnext_phase:\n\n\tif (!SCI_BUSY(sc)) {\n\t\t/* Unexpected disconnect */\n\t\tprintf(\"ncr5380_machine: unexpected disconnect.\\n\");\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\tact_flags |= (ACT_DISCONNECT | ACT_CMD_DONE);\n\t\tgoto do_actions;\n\t}\n\n\t/*\n\t * Wait for REQ before reading the phase.\n\t * Need to wait longer than usual here, because\n\t * some devices are just plain slow...\n\t */\n\ttimo = ncr5380_wait_phase_timo;\n\tfor (;;) {\n\t\tif (*sc->sci_bus_csr & SCI_BUS_REQ)\n\t\t\tbreak;\n\t\tif (--timo <= 0) {\n\t\t\tif (sc->sc_state & NCR_ABORTING) {\n\t\t\t\tprintf(\"%s: no REQ while aborting, reset\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tact_flags |= ACT_RESET_BUS;\n\t\t\t\tgoto do_actions;\n\t\t\t}\n\t\t\tprintf(\"%s: no REQ for next phase, abort\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tsc->sc_state |= NCR_ABORTING;\n\t\t\tncr_sched_msgout(sc, SEND_ABORT);\n\t\t\tgoto next_phase;\n\t\t}\n\t\tdelay(100);\n\t}\n\n\tphase = SCI_BUS_PHASE(*sc->sci_bus_csr);\n\tNCR_TRACE(\"machine: phase=%s\\n\",\n\t\t\t  (long) phase_names[phase & 7]);\n\n\t/*\n\t * We assume that the device knows what it's doing,\n\t * so any phase is good.\n\t */\n\n#if 0\n\t/*\n\t * XXX: Do not ACK the phase yet! do it later...\n\t * XXX: ... each phase routine does that itself.\n\t * In particular, DMA needs it done LATER.\n\t */\n\t*sc->sci_tcmd = phase;\t/* acknowledge phase change */\n#endif\n\n\tswitch (phase) {\n\n\tcase PHASE_DATA_OUT:\n\tcase PHASE_DATA_IN:\n\t\tact_flags = ncr5380_data_xfer(sc, phase);\n\t\tbreak;\n\n\tcase PHASE_COMMAND:\n\t\tact_flags = ncr5380_command(sc);\n\t\tbreak;\n\n\tcase PHASE_STATUS:\n\t\tact_flags = ncr5380_status(sc);\n\t\tbreak;\n\n\tcase PHASE_MSG_OUT:\n\t\tact_flags = ncr5380_msg_out(sc);\n\t\tbreak;\n\n\tcase PHASE_MSG_IN:\n\t\tact_flags = ncr5380_msg_in(sc);\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"ncr5380_machine: Unexpected phase 0x%x\\n\", phase);\n\t\tsc->sc_state |= NCR_ABORTING;\n\t\tncr_sched_msgout(sc, SEND_ABORT);\n\t\tgoto next_phase;\n\n\t} /* switch */\n\tsc->sc_prevphase = phase;\n\ndo_actions:\n\t__asm(\"_ncr5380_actions:\");\n\n\tif (act_flags & ACT_WAIT_DMA) {\n\t\tact_flags &= ~ACT_WAIT_DMA;\n\t\t/* Wait for DMA to complete (polling, or interrupt). */\n\t\tif ((sr->sr_flags & SR_IMMED) == 0) {\n\t\t\tNCR_TRACE(\"machine: wait for DMA intr.\\n\", 0);\n\t\t\treturn; \t/* will resume at dma_done */\n\t\t}\n\t\t/* Busy-wait for it to finish. */\n\t\tNCR_TRACE(\"machine: dma_poll, dh=0x%x\\n\",\n\t\t\t\t  (long) sr->sr_dma_hand);\n\t\t(*sc->sc_dma_poll)(sc);\n\tdma_done:\n\t\t/* Return here after interrupt. */\n\t\tif (sr->sr_flags & SR_OVERDUE)\n\t\t\tsc->sc_state |= NCR_ABORTING;\n\t\tNCR_TRACE(\"machine: dma_stop, dh=0x%x\\n\",\n\t\t\t\t  (long) sr->sr_dma_hand);\n\t\t(*sc->sc_dma_stop)(sc);\n\t\tSCI_CLR_INTR(sc);\t/* XXX */\n\t\t/*\n\t\t * While DMA is running we can not touch the SBC,\n\t\t * so various places just set NCR_ABORTING and\n\t\t * expect us the \"kick it\" when DMA is done.\n\t\t */\n\t\tif (sc->sc_state & NCR_ABORTING) {\n\t\t\tncr_sched_msgout(sc, SEND_ABORT);\n\t\t}\n\t}\n\n\t/*\n\t * Check for parity error.\n\t * XXX - better place to check?\n\t */\n\tif (*(sc->sci_csr) & SCI_CSR_PERR) {\n\t\tprintf(\"%s: parity error!\\n\", sc->sc_dev.dv_xname);\n\t\t/* XXX: sc->sc_state |= NCR_ABORTING; */\n\t\tncr_sched_msgout(sc, SEND_PARITY_ERROR);\n\t}\n\n\tif (act_flags == ACT_CONTINUE)\n\t\tgoto next_phase;\n\t/* All other actions \"break\" from the loop. */\n\n\tNCR_TRACE(\"machine: act_flags=0x%x\\n\", act_flags);\n\n\tif (act_flags & ACT_RESET_BUS) {\n\t\tact_flags |= ACT_CMD_DONE;\n\t\t/*\n\t\t * Reset the SCSI bus, usually due to a timeout.\n\t\t * The error code XS_TIMEOUT allows retries.\n\t\t */\n\t\tsc->sc_state |= NCR_ABORTING;\n\t\tprintf(\"%s: reset SCSI bus for TID=%d LUN=%d\\n\",\n\t\t    sc->sc_dev.dv_xname, sr->sr_target, sr->sr_lun);\n\t\tncr5380_reset_scsibus(sc);\n\t}\n\n\tif (act_flags & ACT_CMD_DONE) {\n\t\tact_flags |= ACT_DISCONNECT;\n\t\t/* Need to call scsi_done() */\n\t\t/* XXX: from the aic6360 driver, but why? */\n\t\tif (sc->sc_datalen < 0) {\n\t\t\tprintf(\"%s: %d extra bytes from %d:%d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, -sc->sc_datalen,\n\t\t\t    sr->sr_target, sr->sr_lun);\n\t\t\tsc->sc_datalen = 0;\n\t\t}\n\t\txs->resid = sc->sc_datalen;\n\t\t/* Note: this will clear sc_current */\n\t\tNCR_TRACE(\"machine: call done, cur=0x%x\\n\", (long)sr);\n\t\tncr5380_done(sc);\n\t}\n\n\tif (act_flags & ACT_DISCONNECT) {\n\t\t/*\n\t\t * The device has dropped BSY (or will soon).\n\t\t * We have to wait here for BSY to drop, otherwise\n\t\t * the next command may decide we need a bus reset.\n\t\t */\n\t\ttimo = ncr5380_wait_req_timo;\t/* XXX */\n\t\tfor (;;) {\n\t\t\tif (!SCI_BUSY(sc))\n\t\t\t\tgoto busfree;\n\t\t\tif (--timo <= 0)\n\t\t\t\tbreak;\n\t\t\tdelay(2);\n\t\t}\n\t\t/* Device is sitting on the bus! */\n\t\tprintf(\"%s: Target %d LUN %d stuck busy, resetting...\\n\",\n\t\t    sc->sc_dev.dv_xname, sr->sr_target, sr->sr_lun);\n\t\tncr5380_reset_scsibus(sc);\n\tbusfree:\n\t\tNCR_TRACE(\"machine: discon, waited %d\\n\",\n\t\t\tncr5380_wait_nrq_timo - timo);\n\n\t\t*sc->sci_icmd = 0;\n\t\t*sc->sci_mode = 0;\n\t\t*sc->sci_tcmd = PHASE_INVALID;\n\t\t*sc->sci_sel_enb = 0;\n\t\tSCI_CLR_INTR(sc);\n\t\t*sc->sci_sel_enb = 0x80;\n\n\t\tif ((act_flags & ACT_CMD_DONE) == 0) {\n\t\t\t__asm(\"_ncr5380_disconnected:\");\n\t\t\tNCR_TRACE(\"machine: discon, cur=0x%x\\n\", (long)sr);\n\t\t}\n\n\t\t/*\n\t\t * We may be here due to a disconnect message,\n\t\t * in which case we did NOT call ncr5380_done,\n\t\t * and we need to clear sc_current.\n\t\t */\n\t\tsc->sc_state = NCR_IDLE;\n\t\tsc->sc_current = NULL;\n\n\t\t/* Paranoia: clear everything. */\n\t\tsc->sc_dataptr = NULL;\n\t\tsc->sc_datalen = 0;\n\t\tsc->sc_prevphase = PHASE_INVALID;\n\t\tsc->sc_msgpriq = 0;\n\t\tsc->sc_msgoutq = 0;\n\t\tsc->sc_msgout  = 0;\n\n\t\t/* Our caller will re-enable interrupts. */\n\t}\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [
            "#define ACT_WAIT_DMA\t0x10\t/* Wait for DMA to complete */",
            "#define ACT_RESET_BUS\t0x04\t/* Need bus reset (cmd timeout) */",
            "#define ACT_CMD_DONE\t0x02\t/* Need to call scsi_done() */",
            "#define ACT_DISCONNECT\t0x01\t/* Target is disconnecting */",
            "#define ACT_CONTINUE\t0x00\t/* No flags: expect another phase */"
          ],
          "globals_used": [
            "static void\tncr5380_done",
            "static int\tncr5380_msg_in",
            "static int\tncr5380_msg_out",
            "static int\tncr5380_data_xfer",
            "static int\tncr5380_command",
            "static int\tncr5380_status",
            "static void\tncr5380_machine",
            "static char *\nphase_names[8] = {\n\t\"DATA_OUT\",\n\t\"DATA_IN\",\n\t\"COMMAND\",\n\t\"STATUS\",\n\t\"UNSPEC1\",\n\t\"UNSPEC2\",\n\t\"MSG_OUT\",\n\t\"MSG_IN\",\n};",
            "int ncr5380_wait_phase_timo = 1000 * 10 * 300;",
            "int ncr5380_wait_req_timo = 1000 * 50;",
            "int ncr5380_wait_nrq_timo = 1000 * 25;",
            "static __inline void ncr_sched_msgout"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\n#define ACT_WAIT_DMA\t0x10\t/* Wait for DMA to complete */\n#define ACT_RESET_BUS\t0x04\t/* Need bus reset (cmd timeout) */\n#define ACT_CMD_DONE\t0x02\t/* Need to call scsi_done() */\n#define ACT_DISCONNECT\t0x01\t/* Target is disconnecting */\n#define ACT_CONTINUE\t0x00\t/* No flags: expect another phase */\n\nstatic void\tncr5380_done;\nstatic int\tncr5380_msg_in;\nstatic int\tncr5380_msg_out;\nstatic int\tncr5380_data_xfer;\nstatic int\tncr5380_command;\nstatic int\tncr5380_status;\nstatic void\tncr5380_machine;\nstatic char *\nphase_names[8] = {\n\t\"DATA_OUT\",\n\t\"DATA_IN\",\n\t\"COMMAND\",\n\t\"STATUS\",\n\t\"UNSPEC1\",\n\t\"UNSPEC2\",\n\t\"MSG_OUT\",\n\t\"MSG_IN\",\n};\nint ncr5380_wait_phase_timo = 1000 * 10 * 300;\nint ncr5380_wait_req_timo = 1000 * 50;\nint ncr5380_wait_nrq_timo = 1000 * 25;\nstatic __inline void ncr_sched_msgout;\n\nstatic void\nncr5380_machine(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tstruct sci_req *sr;\n\tstruct scsi_xfer *xs;\n\tint act_flags, phase, timo;\n\n#ifdef\tDIAGNOSTIC\n\tif (sc->sc_state == NCR_IDLE)\n\t\tpanic(\"ncr5380_machine: state=idle\");\n\tif (sc->sc_current == NULL)\n\t\tpanic(\"ncr5380_machine: no current cmd\");\n#endif\n\n\tsr = sc->sc_current;\n\txs = sr->sr_xs;\n\tact_flags = ACT_CONTINUE;\n\n\t/*\n\t * This will be called by ncr5380_intr() when DMA is\n\t * complete.  Must stop DMA before touching the 5380 or\n\t * there will be \"register conflict\" errors.\n\t */\n\tif (sc->sc_state & NCR_DOINGDMA) {\n\t\t/* Pick-up where where we left off... */\n\t\tgoto dma_done;\n\t}\n\nnext_phase:\n\n\tif (!SCI_BUSY(sc)) {\n\t\t/* Unexpected disconnect */\n\t\tprintf(\"ncr5380_machine: unexpected disconnect.\\n\");\n\t\txs->error = XS_DRIVER_STUFFUP;\n\t\tact_flags |= (ACT_DISCONNECT | ACT_CMD_DONE);\n\t\tgoto do_actions;\n\t}\n\n\t/*\n\t * Wait for REQ before reading the phase.\n\t * Need to wait longer than usual here, because\n\t * some devices are just plain slow...\n\t */\n\ttimo = ncr5380_wait_phase_timo;\n\tfor (;;) {\n\t\tif (*sc->sci_bus_csr & SCI_BUS_REQ)\n\t\t\tbreak;\n\t\tif (--timo <= 0) {\n\t\t\tif (sc->sc_state & NCR_ABORTING) {\n\t\t\t\tprintf(\"%s: no REQ while aborting, reset\\n\",\n\t\t\t\t    sc->sc_dev.dv_xname);\n\t\t\t\tact_flags |= ACT_RESET_BUS;\n\t\t\t\tgoto do_actions;\n\t\t\t}\n\t\t\tprintf(\"%s: no REQ for next phase, abort\\n\",\n\t\t\t    sc->sc_dev.dv_xname);\n\t\t\tsc->sc_state |= NCR_ABORTING;\n\t\t\tncr_sched_msgout(sc, SEND_ABORT);\n\t\t\tgoto next_phase;\n\t\t}\n\t\tdelay(100);\n\t}\n\n\tphase = SCI_BUS_PHASE(*sc->sci_bus_csr);\n\tNCR_TRACE(\"machine: phase=%s\\n\",\n\t\t\t  (long) phase_names[phase & 7]);\n\n\t/*\n\t * We assume that the device knows what it's doing,\n\t * so any phase is good.\n\t */\n\n#if 0\n\t/*\n\t * XXX: Do not ACK the phase yet! do it later...\n\t * XXX: ... each phase routine does that itself.\n\t * In particular, DMA needs it done LATER.\n\t */\n\t*sc->sci_tcmd = phase;\t/* acknowledge phase change */\n#endif\n\n\tswitch (phase) {\n\n\tcase PHASE_DATA_OUT:\n\tcase PHASE_DATA_IN:\n\t\tact_flags = ncr5380_data_xfer(sc, phase);\n\t\tbreak;\n\n\tcase PHASE_COMMAND:\n\t\tact_flags = ncr5380_command(sc);\n\t\tbreak;\n\n\tcase PHASE_STATUS:\n\t\tact_flags = ncr5380_status(sc);\n\t\tbreak;\n\n\tcase PHASE_MSG_OUT:\n\t\tact_flags = ncr5380_msg_out(sc);\n\t\tbreak;\n\n\tcase PHASE_MSG_IN:\n\t\tact_flags = ncr5380_msg_in(sc);\n\t\tbreak;\n\n\tdefault:\n\t\tprintf(\"ncr5380_machine: Unexpected phase 0x%x\\n\", phase);\n\t\tsc->sc_state |= NCR_ABORTING;\n\t\tncr_sched_msgout(sc, SEND_ABORT);\n\t\tgoto next_phase;\n\n\t} /* switch */\n\tsc->sc_prevphase = phase;\n\ndo_actions:\n\t__asm(\"_ncr5380_actions:\");\n\n\tif (act_flags & ACT_WAIT_DMA) {\n\t\tact_flags &= ~ACT_WAIT_DMA;\n\t\t/* Wait for DMA to complete (polling, or interrupt). */\n\t\tif ((sr->sr_flags & SR_IMMED) == 0) {\n\t\t\tNCR_TRACE(\"machine: wait for DMA intr.\\n\", 0);\n\t\t\treturn; \t/* will resume at dma_done */\n\t\t}\n\t\t/* Busy-wait for it to finish. */\n\t\tNCR_TRACE(\"machine: dma_poll, dh=0x%x\\n\",\n\t\t\t\t  (long) sr->sr_dma_hand);\n\t\t(*sc->sc_dma_poll)(sc);\n\tdma_done:\n\t\t/* Return here after interrupt. */\n\t\tif (sr->sr_flags & SR_OVERDUE)\n\t\t\tsc->sc_state |= NCR_ABORTING;\n\t\tNCR_TRACE(\"machine: dma_stop, dh=0x%x\\n\",\n\t\t\t\t  (long) sr->sr_dma_hand);\n\t\t(*sc->sc_dma_stop)(sc);\n\t\tSCI_CLR_INTR(sc);\t/* XXX */\n\t\t/*\n\t\t * While DMA is running we can not touch the SBC,\n\t\t * so various places just set NCR_ABORTING and\n\t\t * expect us the \"kick it\" when DMA is done.\n\t\t */\n\t\tif (sc->sc_state & NCR_ABORTING) {\n\t\t\tncr_sched_msgout(sc, SEND_ABORT);\n\t\t}\n\t}\n\n\t/*\n\t * Check for parity error.\n\t * XXX - better place to check?\n\t */\n\tif (*(sc->sci_csr) & SCI_CSR_PERR) {\n\t\tprintf(\"%s: parity error!\\n\", sc->sc_dev.dv_xname);\n\t\t/* XXX: sc->sc_state |= NCR_ABORTING; */\n\t\tncr_sched_msgout(sc, SEND_PARITY_ERROR);\n\t}\n\n\tif (act_flags == ACT_CONTINUE)\n\t\tgoto next_phase;\n\t/* All other actions \"break\" from the loop. */\n\n\tNCR_TRACE(\"machine: act_flags=0x%x\\n\", act_flags);\n\n\tif (act_flags & ACT_RESET_BUS) {\n\t\tact_flags |= ACT_CMD_DONE;\n\t\t/*\n\t\t * Reset the SCSI bus, usually due to a timeout.\n\t\t * The error code XS_TIMEOUT allows retries.\n\t\t */\n\t\tsc->sc_state |= NCR_ABORTING;\n\t\tprintf(\"%s: reset SCSI bus for TID=%d LUN=%d\\n\",\n\t\t    sc->sc_dev.dv_xname, sr->sr_target, sr->sr_lun);\n\t\tncr5380_reset_scsibus(sc);\n\t}\n\n\tif (act_flags & ACT_CMD_DONE) {\n\t\tact_flags |= ACT_DISCONNECT;\n\t\t/* Need to call scsi_done() */\n\t\t/* XXX: from the aic6360 driver, but why? */\n\t\tif (sc->sc_datalen < 0) {\n\t\t\tprintf(\"%s: %d extra bytes from %d:%d\\n\",\n\t\t\t    sc->sc_dev.dv_xname, -sc->sc_datalen,\n\t\t\t    sr->sr_target, sr->sr_lun);\n\t\t\tsc->sc_datalen = 0;\n\t\t}\n\t\txs->resid = sc->sc_datalen;\n\t\t/* Note: this will clear sc_current */\n\t\tNCR_TRACE(\"machine: call done, cur=0x%x\\n\", (long)sr);\n\t\tncr5380_done(sc);\n\t}\n\n\tif (act_flags & ACT_DISCONNECT) {\n\t\t/*\n\t\t * The device has dropped BSY (or will soon).\n\t\t * We have to wait here for BSY to drop, otherwise\n\t\t * the next command may decide we need a bus reset.\n\t\t */\n\t\ttimo = ncr5380_wait_req_timo;\t/* XXX */\n\t\tfor (;;) {\n\t\t\tif (!SCI_BUSY(sc))\n\t\t\t\tgoto busfree;\n\t\t\tif (--timo <= 0)\n\t\t\t\tbreak;\n\t\t\tdelay(2);\n\t\t}\n\t\t/* Device is sitting on the bus! */\n\t\tprintf(\"%s: Target %d LUN %d stuck busy, resetting...\\n\",\n\t\t    sc->sc_dev.dv_xname, sr->sr_target, sr->sr_lun);\n\t\tncr5380_reset_scsibus(sc);\n\tbusfree:\n\t\tNCR_TRACE(\"machine: discon, waited %d\\n\",\n\t\t\tncr5380_wait_nrq_timo - timo);\n\n\t\t*sc->sci_icmd = 0;\n\t\t*sc->sci_mode = 0;\n\t\t*sc->sci_tcmd = PHASE_INVALID;\n\t\t*sc->sci_sel_enb = 0;\n\t\tSCI_CLR_INTR(sc);\n\t\t*sc->sci_sel_enb = 0x80;\n\n\t\tif ((act_flags & ACT_CMD_DONE) == 0) {\n\t\t\t__asm(\"_ncr5380_disconnected:\");\n\t\t\tNCR_TRACE(\"machine: discon, cur=0x%x\\n\", (long)sr);\n\t\t}\n\n\t\t/*\n\t\t * We may be here due to a disconnect message,\n\t\t * in which case we did NOT call ncr5380_done,\n\t\t * and we need to clear sc_current.\n\t\t */\n\t\tsc->sc_state = NCR_IDLE;\n\t\tsc->sc_current = NULL;\n\n\t\t/* Paranoia: clear everything. */\n\t\tsc->sc_dataptr = NULL;\n\t\tsc->sc_datalen = 0;\n\t\tsc->sc_prevphase = PHASE_INVALID;\n\t\tsc->sc_msgpriq = 0;\n\t\tsc->sc_msgoutq = 0;\n\t\tsc->sc_msgout  = 0;\n\n\t\t/* Our caller will re-enable interrupts. */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"intr: call machine, cur=0x%x\\n\"",
            "(long) sc->sc_current"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr5380_reselect",
          "args": [
            "sc"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_reselect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "1075-1296",
          "snippet": "void\nncr5380_reselect(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tstruct sci_req *sr;\n\tint target, lun, phase, timo;\n\tint target_mask;\n\tu_char bus, data, icmd, msg;\n\n#ifdef\tDIAGNOSTIC\n\t/*\n\t * Note: sc_state will be \"idle\" when ncr5380_intr()\n\t * calls, or \"working\" when ncr5380_select() calls.\n\t * (So don't test that in this DIAGNOSTIC)\n\t */\n\tif (sc->sc_current)\n\t\tpanic(\"ncr5380_reselect: current set\");\n#endif\n\n\t/*\n\t * First, check the select line.\n\t * (That has to be set first.)\n\t */\n\tbus = *(sc->sci_bus_csr);\n\tif ((bus & SCI_BUS_SEL) == 0) {\n\t\t/* Not a selection or reselection. */\n\t\treturn;\n\t}\n\n\t/*\n\t * The target will assert BSY first (for bus arbitration),\n\t * then raise SEL, and finally drop BSY.  Only then is the\n\t * data bus required to have valid selection ID bits set.\n\t * Wait for: SEL==1, BSY==0 before reading the data bus.\n\t * While this theoretically can happen, we are aparently\n\t * never fast enough to get here before BSY drops.\n\t */\n\ttimo = ncr5380_wait_nrq_timo;\n\tfor (;;) {\n\t\tif ((bus & SCI_BUS_BSY) == 0)\n\t\t\tbreak;\n\t\t/* Probably never get here... */\n\t\tif (--timo <= 0) {\n\t\t\tprintf(\"%s: reselect, BSY stuck, bus=0x%x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, bus);\n\t\t\t/* Not much we can do. Reset the bus. */\n\t\t\tncr5380_reset_scsibus(sc);\n\t\t\treturn;\n\t\t}\n\t\tdelay(2);\n\t\tbus = *(sc->sci_bus_csr);\n\t\t/* If SEL went away, forget it. */\n\t\tif ((bus & SCI_BUS_SEL) == 0)\n\t\t\treturn;\n\t\t/* Still have SEL, check BSY. */\n\t}\n\tNCR_TRACE(\"reselect, valid data after %d loops\\n\",\n\t\t\t  ncr5380_wait_nrq_timo - timo);\n\n\t/*\n\t * Good.  We have SEL=1 and BSY=0.  Now wait for a\n\t * \"bus settle delay\" before we sample the data bus\n\t */\n\tdelay(2);\n\tdata = *(sc->sci_data) & 0xFF;\n\t/* Parity check is implicit in data validation below. */\n\n\t/*\n\t * Is this a reselect (I/O == 1) or have we been\n\t * selected as a target? (I/O == 0)\n\t */\n\tif ((bus & SCI_BUS_IO) == 0) {\n\t\tprintf(\"%s: selected as target, data=0x%x\\n\",\n\t\t    sc->sc_dev.dv_xname, data);\n\t\t/* Not much we can do. Reset the bus. */\n\t\t/* XXX: send some sort of message? */\n\t\tncr5380_reset_scsibus(sc);\n\t\treturn;\n\t}\n\n\t/*\n\t * OK, this is a reselection.\n\t */\n\tfor (target = 0; target < 7; target++) {\n\t\ttarget_mask = (1 << target);\n\t\tif (data & target_mask)\n\t\t\tbreak;\n\t}\n\tif ((data & 0x7F) != target_mask) {\n\t\t/* No selecting ID? or >2 IDs on bus? */\n\t\tprintf(\"%s: bad reselect, data=0x%x\\n\",\n\t\t    sc->sc_dev.dv_xname, data);\n\t\treturn;\n\t}\n\n\tNCR_TRACE(\"reselect: target=0x%x\\n\", target);\n\n\t/* Raise BSY to acknowledge target reselection. */\n\t*(sc->sci_icmd) = SCI_ICMD_BSY;\n\n\t/* Wait for target to drop SEL. */\n\ttimo = ncr5380_wait_nrq_timo;\n\tfor (;;) {\n\t\tbus = *(sc->sci_bus_csr);\n\t\tif ((bus & SCI_BUS_SEL) == 0)\n\t\t\tbreak;\t/* success */\n\t\tif (--timo <= 0) {\n\t\t\tprintf(\"%s: reselect, SEL stuck, bus=0x%x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, bus);\n\t\t\tNCR_BREAK();\n\t\t\t/* assume connected (fail later if not) */\n\t\t\tbreak;\n\t\t}\n\t\tdelay(2);\n\t}\n\n\t/* Now we drop BSY, and we are connected. */\n\t*(sc->sci_icmd) = 0;\n\t*sc->sci_sel_enb = 0;\n\tSCI_CLR_INTR(sc);\n\n\t/*\n\t * At this point the target should send an IDENTIFY message,\n\t * which will permit us to determine the reselecting LUN.\n\t * If not, we assume LUN 0.\n\t */\n\tlun = 0;\n\t/* Wait for REQ before reading bus phase. */\n\tif (ncr5380_wait_req(sc)) {\n\t\tprintf(\"%s: reselect, no REQ\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\t/* Try to send an ABORT message. */\n\t\tgoto abort;\n\t}\n\tphase = SCI_BUS_PHASE(*sc->sci_bus_csr);\n\tif (phase != PHASE_MSG_IN) {\n\t\tprintf(\"%s: reselect, phase=%d\\n\",\n\t\t    sc->sc_dev.dv_xname, phase);\n\t\tgoto abort;\n\t}\n\n\t/* Ack. the change to PHASE_MSG_IN */\n\t*(sc->sci_tcmd) = PHASE_MSG_IN;\n\n\t/* Peek at the message byte without consuming it! */\n\tmsg = *(sc->sci_data);\n\tif ((msg & 0x80) == 0) {\n\t\tprintf(\"%s: reselect, not identify, msg=%d\\n\",\n\t\t    sc->sc_dev.dv_xname, msg);\n\t\tgoto abort;\n\t}\n\tlun = msg & 7;\n\t\n\t/* We now know target/LUN.  Do we have the request? */\n\tsr = sc->sc_matrix[target][lun];\n\tif (sr) {\n\t\t/* We now have a nexus. */\n\t\tsc->sc_state |= NCR_WORKING;\n\t\tsc->sc_current = sr;\n\t\tNCR_TRACE(\"reselect: resume sr=0x%x\\n\", (long)sr);\n\n\t\t/* Implicit restore pointers message */\n\t\tsc->sc_dataptr = sr->sr_dataptr;\n\t\tsc->sc_datalen = sr->sr_datalen;\n\n\t\tsc->sc_prevphase = PHASE_INVALID;\n\t\tsc->sc_msgpriq = 0;\n\t\tsc->sc_msgoutq = 0;\n\t\tsc->sc_msgout  = 0;\n\n\t\t/* XXX: Restore the normal mode register. */\n\t\t/* If this target's bit is set, do NOT check parity. */\n\t\tif (sc->sc_parity_disable & target_mask)\n\t\t\t*sc->sci_mode = (SCI_MODE_MONBSY);\n\t\telse\n\t\t\t*sc->sci_mode = (SCI_MODE_MONBSY | SCI_MODE_PAR_CHK);\n\n\t\t/*\n\t\t * Another hack for the Sun3 \"si\", which needs\n\t\t * some setup done to its DMA engine before the\n\t\t * target puts the SCSI bus into any DATA phase.\n\t\t */\n\t\tif (sr->sr_dma_hand && sc->sc_dma_setup) {\n\t\t\tNCR_TRACE(\"reselect: call DMA setup, dh=0x%x\\n\",\n\t\t\t\t\t  (long) sr->sr_dma_hand);\n\t\t    sc->sc_dma_setup(sc);\n\t\t}\n\n\t\t/* Now consume the IDENTIFY message. */\n\t\tncr5380_pio_in(sc, PHASE_MSG_IN, 1, &msg);\n\t\treturn;\n\t}\n\n\tprintf(\"%s: phantom reselect: target=%d, LUN=%d\\n\",\n\t    sc->sc_dev.dv_xname, target, lun);\nabort:\n\t/*\n\t * Try to send an ABORT message.  This makes us\n\t * temporarily busy, but no current command...\n\t */\n\tsc->sc_state |= NCR_ABORTING;\n\n\t/* Raise ATN, delay, raise ACK... */\n\ticmd = SCI_ICMD_ATN;\n\t*sc->sci_icmd = icmd;\n\tdelay(2);\n\n\t/* Now consume the IDENTIFY message. */\n\tncr5380_pio_in(sc, PHASE_MSG_IN, 1, &msg);\n\n\t/* Finally try to send the ABORT. */\n\tsc->sc_prevphase = PHASE_INVALID;\n\tsc->sc_msgpriq = SEND_ABORT;\n\tncr5380_msg_out(sc);\n\n\t*(sc->sci_tcmd) = PHASE_INVALID;\n\t*sc->sci_sel_enb = 0;\n\tSCI_CLR_INTR(sc);\n\t*sc->sci_sel_enb = 0x80;\n\n\tsc->sc_state &= ~NCR_ABORTING;\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tncr5380_select",
            "static void\tncr5380_reselect",
            "static int\tncr5380_msg_out",
            "int ncr5380_wait_nrq_timo = 1000 * 25;",
            "static __inline int ncr5380_wait_req"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int\tncr5380_select;\nstatic void\tncr5380_reselect;\nstatic int\tncr5380_msg_out;\nint ncr5380_wait_nrq_timo = 1000 * 25;\nstatic __inline int ncr5380_wait_req;\n\nvoid\nncr5380_reselect(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tstruct sci_req *sr;\n\tint target, lun, phase, timo;\n\tint target_mask;\n\tu_char bus, data, icmd, msg;\n\n#ifdef\tDIAGNOSTIC\n\t/*\n\t * Note: sc_state will be \"idle\" when ncr5380_intr()\n\t * calls, or \"working\" when ncr5380_select() calls.\n\t * (So don't test that in this DIAGNOSTIC)\n\t */\n\tif (sc->sc_current)\n\t\tpanic(\"ncr5380_reselect: current set\");\n#endif\n\n\t/*\n\t * First, check the select line.\n\t * (That has to be set first.)\n\t */\n\tbus = *(sc->sci_bus_csr);\n\tif ((bus & SCI_BUS_SEL) == 0) {\n\t\t/* Not a selection or reselection. */\n\t\treturn;\n\t}\n\n\t/*\n\t * The target will assert BSY first (for bus arbitration),\n\t * then raise SEL, and finally drop BSY.  Only then is the\n\t * data bus required to have valid selection ID bits set.\n\t * Wait for: SEL==1, BSY==0 before reading the data bus.\n\t * While this theoretically can happen, we are aparently\n\t * never fast enough to get here before BSY drops.\n\t */\n\ttimo = ncr5380_wait_nrq_timo;\n\tfor (;;) {\n\t\tif ((bus & SCI_BUS_BSY) == 0)\n\t\t\tbreak;\n\t\t/* Probably never get here... */\n\t\tif (--timo <= 0) {\n\t\t\tprintf(\"%s: reselect, BSY stuck, bus=0x%x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, bus);\n\t\t\t/* Not much we can do. Reset the bus. */\n\t\t\tncr5380_reset_scsibus(sc);\n\t\t\treturn;\n\t\t}\n\t\tdelay(2);\n\t\tbus = *(sc->sci_bus_csr);\n\t\t/* If SEL went away, forget it. */\n\t\tif ((bus & SCI_BUS_SEL) == 0)\n\t\t\treturn;\n\t\t/* Still have SEL, check BSY. */\n\t}\n\tNCR_TRACE(\"reselect, valid data after %d loops\\n\",\n\t\t\t  ncr5380_wait_nrq_timo - timo);\n\n\t/*\n\t * Good.  We have SEL=1 and BSY=0.  Now wait for a\n\t * \"bus settle delay\" before we sample the data bus\n\t */\n\tdelay(2);\n\tdata = *(sc->sci_data) & 0xFF;\n\t/* Parity check is implicit in data validation below. */\n\n\t/*\n\t * Is this a reselect (I/O == 1) or have we been\n\t * selected as a target? (I/O == 0)\n\t */\n\tif ((bus & SCI_BUS_IO) == 0) {\n\t\tprintf(\"%s: selected as target, data=0x%x\\n\",\n\t\t    sc->sc_dev.dv_xname, data);\n\t\t/* Not much we can do. Reset the bus. */\n\t\t/* XXX: send some sort of message? */\n\t\tncr5380_reset_scsibus(sc);\n\t\treturn;\n\t}\n\n\t/*\n\t * OK, this is a reselection.\n\t */\n\tfor (target = 0; target < 7; target++) {\n\t\ttarget_mask = (1 << target);\n\t\tif (data & target_mask)\n\t\t\tbreak;\n\t}\n\tif ((data & 0x7F) != target_mask) {\n\t\t/* No selecting ID? or >2 IDs on bus? */\n\t\tprintf(\"%s: bad reselect, data=0x%x\\n\",\n\t\t    sc->sc_dev.dv_xname, data);\n\t\treturn;\n\t}\n\n\tNCR_TRACE(\"reselect: target=0x%x\\n\", target);\n\n\t/* Raise BSY to acknowledge target reselection. */\n\t*(sc->sci_icmd) = SCI_ICMD_BSY;\n\n\t/* Wait for target to drop SEL. */\n\ttimo = ncr5380_wait_nrq_timo;\n\tfor (;;) {\n\t\tbus = *(sc->sci_bus_csr);\n\t\tif ((bus & SCI_BUS_SEL) == 0)\n\t\t\tbreak;\t/* success */\n\t\tif (--timo <= 0) {\n\t\t\tprintf(\"%s: reselect, SEL stuck, bus=0x%x\\n\",\n\t\t\t    sc->sc_dev.dv_xname, bus);\n\t\t\tNCR_BREAK();\n\t\t\t/* assume connected (fail later if not) */\n\t\t\tbreak;\n\t\t}\n\t\tdelay(2);\n\t}\n\n\t/* Now we drop BSY, and we are connected. */\n\t*(sc->sci_icmd) = 0;\n\t*sc->sci_sel_enb = 0;\n\tSCI_CLR_INTR(sc);\n\n\t/*\n\t * At this point the target should send an IDENTIFY message,\n\t * which will permit us to determine the reselecting LUN.\n\t * If not, we assume LUN 0.\n\t */\n\tlun = 0;\n\t/* Wait for REQ before reading bus phase. */\n\tif (ncr5380_wait_req(sc)) {\n\t\tprintf(\"%s: reselect, no REQ\\n\",\n\t\t    sc->sc_dev.dv_xname);\n\t\t/* Try to send an ABORT message. */\n\t\tgoto abort;\n\t}\n\tphase = SCI_BUS_PHASE(*sc->sci_bus_csr);\n\tif (phase != PHASE_MSG_IN) {\n\t\tprintf(\"%s: reselect, phase=%d\\n\",\n\t\t    sc->sc_dev.dv_xname, phase);\n\t\tgoto abort;\n\t}\n\n\t/* Ack. the change to PHASE_MSG_IN */\n\t*(sc->sci_tcmd) = PHASE_MSG_IN;\n\n\t/* Peek at the message byte without consuming it! */\n\tmsg = *(sc->sci_data);\n\tif ((msg & 0x80) == 0) {\n\t\tprintf(\"%s: reselect, not identify, msg=%d\\n\",\n\t\t    sc->sc_dev.dv_xname, msg);\n\t\tgoto abort;\n\t}\n\tlun = msg & 7;\n\t\n\t/* We now know target/LUN.  Do we have the request? */\n\tsr = sc->sc_matrix[target][lun];\n\tif (sr) {\n\t\t/* We now have a nexus. */\n\t\tsc->sc_state |= NCR_WORKING;\n\t\tsc->sc_current = sr;\n\t\tNCR_TRACE(\"reselect: resume sr=0x%x\\n\", (long)sr);\n\n\t\t/* Implicit restore pointers message */\n\t\tsc->sc_dataptr = sr->sr_dataptr;\n\t\tsc->sc_datalen = sr->sr_datalen;\n\n\t\tsc->sc_prevphase = PHASE_INVALID;\n\t\tsc->sc_msgpriq = 0;\n\t\tsc->sc_msgoutq = 0;\n\t\tsc->sc_msgout  = 0;\n\n\t\t/* XXX: Restore the normal mode register. */\n\t\t/* If this target's bit is set, do NOT check parity. */\n\t\tif (sc->sc_parity_disable & target_mask)\n\t\t\t*sc->sci_mode = (SCI_MODE_MONBSY);\n\t\telse\n\t\t\t*sc->sci_mode = (SCI_MODE_MONBSY | SCI_MODE_PAR_CHK);\n\n\t\t/*\n\t\t * Another hack for the Sun3 \"si\", which needs\n\t\t * some setup done to its DMA engine before the\n\t\t * target puts the SCSI bus into any DATA phase.\n\t\t */\n\t\tif (sr->sr_dma_hand && sc->sc_dma_setup) {\n\t\t\tNCR_TRACE(\"reselect: call DMA setup, dh=0x%x\\n\",\n\t\t\t\t\t  (long) sr->sr_dma_hand);\n\t\t    sc->sc_dma_setup(sc);\n\t\t}\n\n\t\t/* Now consume the IDENTIFY message. */\n\t\tncr5380_pio_in(sc, PHASE_MSG_IN, 1, &msg);\n\t\treturn;\n\t}\n\n\tprintf(\"%s: phantom reselect: target=%d, LUN=%d\\n\",\n\t    sc->sc_dev.dv_xname, target, lun);\nabort:\n\t/*\n\t * Try to send an ABORT message.  This makes us\n\t * temporarily busy, but no current command...\n\t */\n\tsc->sc_state |= NCR_ABORTING;\n\n\t/* Raise ATN, delay, raise ACK... */\n\ticmd = SCI_ICMD_ATN;\n\t*sc->sci_icmd = icmd;\n\tdelay(2);\n\n\t/* Now consume the IDENTIFY message. */\n\tncr5380_pio_in(sc, PHASE_MSG_IN, 1, &msg);\n\n\t/* Finally try to send the ABORT. */\n\tsc->sc_prevphase = PHASE_INVALID;\n\tsc->sc_msgpriq = SEND_ABORT;\n\tncr5380_msg_out(sc);\n\n\t*(sc->sci_tcmd) = PHASE_INVALID;\n\t*sc->sci_sel_enb = 0;\n\tSCI_CLR_INTR(sc);\n\t*sc->sci_sel_enb = 0x80;\n\n\tsc->sc_state &= ~NCR_ABORTING;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sc->sc_intr_off",
          "args": [
            "sc"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"intr: for reselect, intr off\\n\"",
            "0"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"intr: top, state=%d\\n\"",
            "sc->sc_state"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic void\tncr5380_sched;\nstatic void\tncr5380_reselect;\nstatic void\tncr5380_machine;\n\nint\nncr5380_intr(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tint claimed = 0;\n\n\t/*\n\t * Do not touch SBC regs here unless sc_current == NULL\n\t * or it will complain about \"register conflict\" errors.\n\t * Instead, just let ncr5380_machine() deal with it.\n\t */\n\tNCR_TRACE(\"intr: top, state=%d\\n\", sc->sc_state);\n\n\tif (sc->sc_state == NCR_IDLE) {\n\t\t/*\n\t\t * Might be reselect.  ncr5380_reselect() will check,\n\t\t * and set up the connection if so.  This will verify\n\t\t * that sc_current == NULL at the beginning...\n\t\t */\n\n\t\t/* Another hack (Er.. hook!) for the sun3 si: */\n\t\tif (sc->sc_intr_off) {\n\t\t\tNCR_TRACE(\"intr: for reselect, intr off\\n\", 0);\n\t\t    sc->sc_intr_off(sc);\n\t\t}\n\n\t\tncr5380_reselect(sc);\n\t}\n\n\t/*\n\t * The remaining documented interrupt causes are phase mismatch and\n\t * disconnect.  In addition, the sunsi controller may produce a state\n\t * where SCI_CSR_DONE is false, yet DMA is complete.\n\t *\n\t * The procedure in all these cases is to let ncr5380_machine()\n\t * figure out what to do next.\n\t */\n\tif (sc->sc_state & NCR_WORKING) {\n\t\tNCR_TRACE(\"intr: call machine, cur=0x%x\\n\",\n\t\t\t\t  (long) sc->sc_current);\n\t\t/* This will usually free-up the nexus. */\n\t\tncr5380_machine(sc);\n\t\tNCR_TRACE(\"intr: machine done, cur=0x%x\\n\",\n\t\t\t\t  (long) sc->sc_current);\n\t\tclaimed = 1;\n\t}\n\n\t/* Maybe we can run some commands now... */\n\tif (sc->sc_state == NCR_IDLE) {\n\t\tNCR_TRACE(\"intr: call sched, cur=0x%x\\n\",\n\t\t\t\t  (long) sc->sc_current);\n\t\tncr5380_sched(sc);\n\t\tNCR_TRACE(\"intr: sched done, cur=0x%x\\n\",\n\t\t\t\t  (long) sc->sc_current);\n\t}\n\n\treturn claimed;\n}"
  },
  {
    "function_name": "ncr5380_reset_scsibus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
    "lines": "391-411",
    "snippet": "void\nncr5380_reset_scsibus(sc)\n\tstruct ncr5380_softc *sc;\n{\n\n\tNCR_TRACE(\"reset_scsibus, cur=0x%x\\n\",\n\t\t\t  (long) sc->sc_current);\n\n\t*sc->sci_icmd = SCI_ICMD_RST;\n\tdelay(500);\n\t*sc->sci_icmd = 0;\n\n\t*sc->sci_mode = 0;\n\t*sc->sci_tcmd = PHASE_INVALID;\n\n\tSCI_CLR_INTR(sc);\n\t/* XXX - Need long delay here! */\n\tdelay(100000);\n\n\t/* XXX - Need to cancel disconnected requests. */\n}",
    "includes": [
      "#include <dev/ic/ncr5380var.h>",
      "#include <dev/ic/ncr5380reg.h>",
      "#include <ddb/db_output.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "100000"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCI_CLR_INTR",
          "args": [
            "sc"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"reset_scsibus, cur=0x%x\\n\"",
            "(long) sc->sc_current"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\nncr5380_reset_scsibus(sc)\n\tstruct ncr5380_softc *sc;\n{\n\n\tNCR_TRACE(\"reset_scsibus, cur=0x%x\\n\",\n\t\t\t  (long) sc->sc_current);\n\n\t*sc->sci_icmd = SCI_ICMD_RST;\n\tdelay(500);\n\t*sc->sci_icmd = 0;\n\n\t*sc->sci_mode = 0;\n\t*sc->sci_tcmd = PHASE_INVALID;\n\n\tSCI_CLR_INTR(sc);\n\t/* XXX - Need long delay here! */\n\tdelay(100000);\n\n\t/* XXX - Need to cancel disconnected requests. */\n}"
  },
  {
    "function_name": "ncr5380_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
    "lines": "354-388",
    "snippet": "void\nncr5380_init(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tint i, j;\n\n#ifdef\tNCR5380_DEBUG\n\tncr5380_debug_sc = sc;\n#endif\n\n\tfor (i = 0; i < SCI_OPENINGS; i++)\n\t\tsc->sc_ring[i].sr_xs = NULL;\n\tfor (i = 0; i < 8; i++)\n\t\tfor (j = 0; j < 8; j++)\n\t\t\tsc->sc_matrix[i][j] = NULL;\n\n\tsc->sc_link.openings = 2;\t/* XXX - Not SCI_OPENINGS */\n\tsc->sc_prevphase = PHASE_INVALID;\n\tsc->sc_state = NCR_IDLE;\n\n\t*sc->sci_tcmd = PHASE_INVALID;\n\t*sc->sci_icmd = 0;\n\t*sc->sci_mode = 0;\n\t*sc->sci_sel_enb = 0;\n\tSCI_CLR_INTR(sc);\n\n\t/* XXX: Enable reselect interrupts... */\n\t*sc->sci_sel_enb = 0x80;\n\n\t/* Another hack (Er.. hook!) for the sun3 si: */\n\tif (sc->sc_intr_on) {\n\t\tNCR_TRACE(\"init: intr ON\\n\", 0);\n\t\tsc->sc_intr_on(sc);\n\t}\n}",
    "includes": [
      "#include <dev/ic/ncr5380var.h>",
      "#include <dev/ic/ncr5380reg.h>",
      "#include <ddb/db_output.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sc->sc_intr_on",
          "args": [
            "sc"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"init: intr ON\\n\"",
            "0"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCI_CLR_INTR",
          "args": [
            "sc"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nvoid\nncr5380_init(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tint i, j;\n\n#ifdef\tNCR5380_DEBUG\n\tncr5380_debug_sc = sc;\n#endif\n\n\tfor (i = 0; i < SCI_OPENINGS; i++)\n\t\tsc->sc_ring[i].sr_xs = NULL;\n\tfor (i = 0; i < 8; i++)\n\t\tfor (j = 0; j < 8; j++)\n\t\t\tsc->sc_matrix[i][j] = NULL;\n\n\tsc->sc_link.openings = 2;\t/* XXX - Not SCI_OPENINGS */\n\tsc->sc_prevphase = PHASE_INVALID;\n\tsc->sc_state = NCR_IDLE;\n\n\t*sc->sci_tcmd = PHASE_INVALID;\n\t*sc->sci_icmd = 0;\n\t*sc->sci_mode = 0;\n\t*sc->sci_sel_enb = 0;\n\tSCI_CLR_INTR(sc);\n\n\t/* XXX: Enable reselect interrupts... */\n\t*sc->sci_sel_enb = 0x80;\n\n\t/* Another hack (Er.. hook!) for the sun3 si: */\n\tif (sc->sc_intr_on) {\n\t\tNCR_TRACE(\"init: intr ON\\n\", 0);\n\t\tsc->sc_intr_on(sc);\n\t}\n}"
  },
  {
    "function_name": "ncr5380_pio_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
    "lines": "299-351",
    "snippet": "int\nncr5380_pio_in(sc, phase, count, data)\n\tstruct ncr5380_softc *sc;\n\tint phase, count;\n\tunsigned char\t\t\t*data;\n{\n\tregister u_char \ticmd;\n\tregister int\t\tresid;\n\tregister int\t\terror;\n\n\ticmd = *(sc->sci_icmd) & SCI_ICMD_RMASK;\n\n\tresid = count;\n\twhile (resid > 0) {\n\t\tif (!SCI_BUSY(sc)) {\n\t\t\tNCR_TRACE(\"pio_in: lost BSY, resid=%d\\n\", resid);\n\t\t\tbreak;\n\t\t}\n\t\tif (ncr5380_wait_req(sc)) {\n\t\t\tNCR_TRACE(\"pio_in: no REQ, resid=%d\\n\", resid);\n\t\t\tbreak;\n\t\t}\n\t\t/* A phase change is not valid until AFTER REQ rises! */\n\t\tif (SCI_BUS_PHASE(*sc->sci_bus_csr) != phase)\n\t\t\tbreak;\n\n\t\t/* Read the data bus. */\n\t\tif (data)\n\t\t\t*data++ = *sc->sci_data;\n\t\telse\n\t\t\t(void) *sc->sci_data;\n\n\t\t/* Tell target we got it. */\n\t\ticmd |= SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\t/* Wait for target to drop REQ... */\n\t\terror = ncr5380_wait_not_req(sc);\n\n\t\t/* OK, we can drop ACK. */\n\t\ticmd &= ~SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\tif (error) {\n\t\t\tNCR_TRACE(\"pio_in: stuck REQ, resid=%d\\n\", resid);\n\t\t\tbreak;\n\t\t}\n\n\t\t--resid;\n\t}\n\n\treturn (count - resid);\n}",
    "includes": [
      "#include <dev/ic/ncr5380var.h>",
      "#include <dev/ic/ncr5380reg.h>",
      "#include <ddb/db_output.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __inline int ncr5380_wait_req",
      "static __inline int ncr5380_wait_not_req"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"pio_in: stuck REQ, resid=%d\\n\"",
            "resid"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr5380_wait_not_req",
          "args": [
            "sc"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_wait_not_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "205-219",
          "snippet": "static __inline int ncr5380_wait_not_req(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tregister int timo = ncr5380_wait_nrq_timo;\n\tfor (;;) {\n\t\tif ((*sc->sci_bus_csr & SCI_BUS_REQ) == 0) {\n\t\t\ttimo = 0;\t/* return 0 */\n\t\t\tbreak;\n\t\t}\n\t\tif (--timo < 0)\n\t\t\tbreak;\t/* return -1 */\n\t\tdelay(2);\n\t}\n\treturn (timo);\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncr5380_wait_nrq_timo = 1000 * 25;",
            "static __inline int ncr5380_wait_not_req"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint ncr5380_wait_nrq_timo = 1000 * 25;\nstatic __inline int ncr5380_wait_not_req;\n\nstatic __inline int ncr5380_wait_not_req(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tregister int timo = ncr5380_wait_nrq_timo;\n\tfor (;;) {\n\t\tif ((*sc->sci_bus_csr & SCI_BUS_REQ) == 0) {\n\t\t\ttimo = 0;\t/* return 0 */\n\t\t\tbreak;\n\t\t}\n\t\tif (--timo < 0)\n\t\t\tbreak;\t/* return -1 */\n\t\tdelay(2);\n\t}\n\treturn (timo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCI_BUS_PHASE",
          "args": [
            "*sc->sci_bus_csr"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"pio_in: no REQ, resid=%d\\n\"",
            "resid"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr5380_wait_req",
          "args": [
            "sc"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_wait_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "188-202",
          "snippet": "static __inline int ncr5380_wait_req(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tregister int timo = ncr5380_wait_req_timo;\n\tfor (;;) {\n\t\tif (*sc->sci_bus_csr & SCI_BUS_REQ) {\n\t\t\ttimo = 0;\t/* return 0 */\n\t\t\tbreak;\n\t\t}\n\t\tif (--timo < 0)\n\t\t\tbreak;\t/* return -1 */\n\t\tdelay(2);\n\t}\n\treturn (timo);\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncr5380_wait_req_timo = 1000 * 50;",
            "static __inline int ncr5380_wait_req"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint ncr5380_wait_req_timo = 1000 * 50;\nstatic __inline int ncr5380_wait_req;\n\nstatic __inline int ncr5380_wait_req(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tregister int timo = ncr5380_wait_req_timo;\n\tfor (;;) {\n\t\tif (*sc->sci_bus_csr & SCI_BUS_REQ) {\n\t\t\ttimo = 0;\t/* return 0 */\n\t\t\tbreak;\n\t\t}\n\t\tif (--timo < 0)\n\t\t\tbreak;\t/* return -1 */\n\t\tdelay(2);\n\t}\n\treturn (timo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"pio_in: lost BSY, resid=%d\\n\"",
            "resid"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCI_BUSY",
          "args": [
            "sc"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic __inline int ncr5380_wait_req;\nstatic __inline int ncr5380_wait_not_req;\n\nint\nncr5380_pio_in(sc, phase, count, data)\n\tstruct ncr5380_softc *sc;\n\tint phase, count;\n\tunsigned char\t\t\t*data;\n{\n\tregister u_char \ticmd;\n\tregister int\t\tresid;\n\tregister int\t\terror;\n\n\ticmd = *(sc->sci_icmd) & SCI_ICMD_RMASK;\n\n\tresid = count;\n\twhile (resid > 0) {\n\t\tif (!SCI_BUSY(sc)) {\n\t\t\tNCR_TRACE(\"pio_in: lost BSY, resid=%d\\n\", resid);\n\t\t\tbreak;\n\t\t}\n\t\tif (ncr5380_wait_req(sc)) {\n\t\t\tNCR_TRACE(\"pio_in: no REQ, resid=%d\\n\", resid);\n\t\t\tbreak;\n\t\t}\n\t\t/* A phase change is not valid until AFTER REQ rises! */\n\t\tif (SCI_BUS_PHASE(*sc->sci_bus_csr) != phase)\n\t\t\tbreak;\n\n\t\t/* Read the data bus. */\n\t\tif (data)\n\t\t\t*data++ = *sc->sci_data;\n\t\telse\n\t\t\t(void) *sc->sci_data;\n\n\t\t/* Tell target we got it. */\n\t\ticmd |= SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\t/* Wait for target to drop REQ... */\n\t\terror = ncr5380_wait_not_req(sc);\n\n\t\t/* OK, we can drop ACK. */\n\t\ticmd &= ~SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\tif (error) {\n\t\t\tNCR_TRACE(\"pio_in: stuck REQ, resid=%d\\n\", resid);\n\t\t\tbreak;\n\t\t}\n\n\t\t--resid;\n\t}\n\n\treturn (count - resid);\n}"
  },
  {
    "function_name": "ncr5380_pio_out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
    "lines": "238-296",
    "snippet": "int\nncr5380_pio_out(sc, phase, count, data)\n\tstruct ncr5380_softc *sc;\n\tint phase, count;\n\tunsigned char\t\t*data;\n{\n\tregister u_char \ticmd;\n\tregister int\t\tresid;\n\tregister int\t\terror;\n\n\ticmd = *(sc->sci_icmd) & SCI_ICMD_RMASK;\n\n\ticmd |= SCI_ICMD_DATA;\n\t*sc->sci_icmd = icmd;\n\n\tresid = count;\n\twhile (resid > 0) {\n\t\tif (!SCI_BUSY(sc)) {\n\t\t\tNCR_TRACE(\"pio_out: lost BSY, resid=%d\\n\", resid);\n\t\t\tbreak;\n\t\t}\n\t\tif (ncr5380_wait_req(sc)) {\n\t\t\tNCR_TRACE(\"pio_out: no REQ, resid=%d\\n\", resid);\n\t\t\tbreak;\n\t\t}\n\t\tif (SCI_BUS_PHASE(*sc->sci_bus_csr) != phase)\n\t\t\tbreak;\n\n\t\t/* Put the data on the bus. */\n\t\tif (data)\n\t\t\t*sc->sci_odata = *data++;\n\t\telse\n\t\t\t*sc->sci_odata = 0;\n\n\t\t/* Tell the target it's there. */\n\t\ticmd |= SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\t/* Wait for target to get it. */\n\t\terror = ncr5380_wait_not_req(sc);\n\n\t\t/* OK, it's got it (or we gave up waiting). */\n\t\ticmd &= ~SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\tif (error) {\n\t\t\tNCR_TRACE(\"pio_out: stuck REQ, resid=%d\\n\", resid);\n\t\t\tbreak;\n\t\t}\n\n\t\t--resid;\n\t}\n\n\t/* Stop driving the data bus. */\n\ticmd &= ~SCI_ICMD_DATA;\n\t*sc->sci_icmd = icmd;\n\n\treturn (count - resid);\n}",
    "includes": [
      "#include <dev/ic/ncr5380var.h>",
      "#include <dev/ic/ncr5380reg.h>",
      "#include <ddb/db_output.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __inline int ncr5380_wait_req",
      "static __inline int ncr5380_wait_not_req"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"pio_out: stuck REQ, resid=%d\\n\"",
            "resid"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr5380_wait_not_req",
          "args": [
            "sc"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_wait_not_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "205-219",
          "snippet": "static __inline int ncr5380_wait_not_req(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tregister int timo = ncr5380_wait_nrq_timo;\n\tfor (;;) {\n\t\tif ((*sc->sci_bus_csr & SCI_BUS_REQ) == 0) {\n\t\t\ttimo = 0;\t/* return 0 */\n\t\t\tbreak;\n\t\t}\n\t\tif (--timo < 0)\n\t\t\tbreak;\t/* return -1 */\n\t\tdelay(2);\n\t}\n\treturn (timo);\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncr5380_wait_nrq_timo = 1000 * 25;",
            "static __inline int ncr5380_wait_not_req"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint ncr5380_wait_nrq_timo = 1000 * 25;\nstatic __inline int ncr5380_wait_not_req;\n\nstatic __inline int ncr5380_wait_not_req(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tregister int timo = ncr5380_wait_nrq_timo;\n\tfor (;;) {\n\t\tif ((*sc->sci_bus_csr & SCI_BUS_REQ) == 0) {\n\t\t\ttimo = 0;\t/* return 0 */\n\t\t\tbreak;\n\t\t}\n\t\tif (--timo < 0)\n\t\t\tbreak;\t/* return -1 */\n\t\tdelay(2);\n\t}\n\treturn (timo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCI_BUS_PHASE",
          "args": [
            "*sc->sci_bus_csr"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"pio_out: no REQ, resid=%d\\n\"",
            "resid"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncr5380_wait_req",
          "args": [
            "sc"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "ncr5380_wait_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
          "lines": "188-202",
          "snippet": "static __inline int ncr5380_wait_req(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tregister int timo = ncr5380_wait_req_timo;\n\tfor (;;) {\n\t\tif (*sc->sci_bus_csr & SCI_BUS_REQ) {\n\t\t\ttimo = 0;\t/* return 0 */\n\t\t\tbreak;\n\t\t}\n\t\tif (--timo < 0)\n\t\t\tbreak;\t/* return -1 */\n\t\tdelay(2);\n\t}\n\treturn (timo);\n}",
          "includes": [
            "#include <dev/ic/ncr5380var.h>",
            "#include <dev/ic/ncr5380reg.h>",
            "#include <ddb/db_output.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_message.h>",
            "#include <scsi/scsi_debug.h>",
            "#include <scsi/scsi_all.h>",
            "#include <sys/user.h>",
            "#include <sys/proc.h>",
            "#include <sys/buf.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncr5380_wait_req_timo = 1000 * 50;",
            "static __inline int ncr5380_wait_req"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint ncr5380_wait_req_timo = 1000 * 50;\nstatic __inline int ncr5380_wait_req;\n\nstatic __inline int ncr5380_wait_req(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tregister int timo = ncr5380_wait_req_timo;\n\tfor (;;) {\n\t\tif (*sc->sci_bus_csr & SCI_BUS_REQ) {\n\t\t\ttimo = 0;\t/* return 0 */\n\t\t\tbreak;\n\t\t}\n\t\tif (--timo < 0)\n\t\t\tbreak;\t/* return -1 */\n\t\tdelay(2);\n\t}\n\treturn (timo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCR_TRACE",
          "args": [
            "\"pio_out: lost BSY, resid=%d\\n\"",
            "resid"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCI_BUSY",
          "args": [
            "sc"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic __inline int ncr5380_wait_req;\nstatic __inline int ncr5380_wait_not_req;\n\nint\nncr5380_pio_out(sc, phase, count, data)\n\tstruct ncr5380_softc *sc;\n\tint phase, count;\n\tunsigned char\t\t*data;\n{\n\tregister u_char \ticmd;\n\tregister int\t\tresid;\n\tregister int\t\terror;\n\n\ticmd = *(sc->sci_icmd) & SCI_ICMD_RMASK;\n\n\ticmd |= SCI_ICMD_DATA;\n\t*sc->sci_icmd = icmd;\n\n\tresid = count;\n\twhile (resid > 0) {\n\t\tif (!SCI_BUSY(sc)) {\n\t\t\tNCR_TRACE(\"pio_out: lost BSY, resid=%d\\n\", resid);\n\t\t\tbreak;\n\t\t}\n\t\tif (ncr5380_wait_req(sc)) {\n\t\t\tNCR_TRACE(\"pio_out: no REQ, resid=%d\\n\", resid);\n\t\t\tbreak;\n\t\t}\n\t\tif (SCI_BUS_PHASE(*sc->sci_bus_csr) != phase)\n\t\t\tbreak;\n\n\t\t/* Put the data on the bus. */\n\t\tif (data)\n\t\t\t*sc->sci_odata = *data++;\n\t\telse\n\t\t\t*sc->sci_odata = 0;\n\n\t\t/* Tell the target it's there. */\n\t\ticmd |= SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\t/* Wait for target to get it. */\n\t\terror = ncr5380_wait_not_req(sc);\n\n\t\t/* OK, it's got it (or we gave up waiting). */\n\t\ticmd &= ~SCI_ICMD_ACK;\n\t\t*sc->sci_icmd = icmd;\n\n\t\tif (error) {\n\t\t\tNCR_TRACE(\"pio_out: stuck REQ, resid=%d\\n\", resid);\n\t\t\tbreak;\n\t\t}\n\n\t\t--resid;\n\t}\n\n\t/* Stop driving the data bus. */\n\ticmd &= ~SCI_ICMD_DATA;\n\t*sc->sci_icmd = icmd;\n\n\treturn (count - resid);\n}"
  },
  {
    "function_name": "ncr_sched_msgout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
    "lines": "222-235",
    "snippet": "static __inline void\nncr_sched_msgout(sc, msg_code)\n\tstruct ncr5380_softc *sc;\n\tint msg_code;\n{\n\t/* First time, raise ATN line. */\n\tif (sc->sc_msgpriq == 0) {\n\t\tregister u_char icmd;\n\t\ticmd = *sc->sci_icmd & SCI_ICMD_RMASK;\n\t\t*sc->sci_icmd = icmd | SCI_ICMD_ATN;\n\t\tdelay(2);\n\t}\n\tsc->sc_msgpriq |= msg_code;\n}",
    "includes": [
      "#include <dev/ic/ncr5380var.h>",
      "#include <dev/ic/ncr5380reg.h>",
      "#include <ddb/db_output.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __inline void ncr_sched_msgout"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "2"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic __inline void ncr_sched_msgout;\n\nstatic __inline void\nncr_sched_msgout(sc, msg_code)\n\tstruct ncr5380_softc *sc;\n\tint msg_code;\n{\n\t/* First time, raise ATN line. */\n\tif (sc->sc_msgpriq == 0) {\n\t\tregister u_char icmd;\n\t\ticmd = *sc->sci_icmd & SCI_ICMD_RMASK;\n\t\t*sc->sci_icmd = icmd | SCI_ICMD_ATN;\n\t\tdelay(2);\n\t}\n\tsc->sc_msgpriq |= msg_code;\n}"
  },
  {
    "function_name": "ncr5380_wait_not_req",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
    "lines": "205-219",
    "snippet": "static __inline int ncr5380_wait_not_req(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tregister int timo = ncr5380_wait_nrq_timo;\n\tfor (;;) {\n\t\tif ((*sc->sci_bus_csr & SCI_BUS_REQ) == 0) {\n\t\t\ttimo = 0;\t/* return 0 */\n\t\t\tbreak;\n\t\t}\n\t\tif (--timo < 0)\n\t\t\tbreak;\t/* return -1 */\n\t\tdelay(2);\n\t}\n\treturn (timo);\n}",
    "includes": [
      "#include <dev/ic/ncr5380var.h>",
      "#include <dev/ic/ncr5380reg.h>",
      "#include <ddb/db_output.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ncr5380_wait_nrq_timo = 1000 * 25;",
      "static __inline int ncr5380_wait_not_req"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "2"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint ncr5380_wait_nrq_timo = 1000 * 25;\nstatic __inline int ncr5380_wait_not_req;\n\nstatic __inline int ncr5380_wait_not_req(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tregister int timo = ncr5380_wait_nrq_timo;\n\tfor (;;) {\n\t\tif ((*sc->sci_bus_csr & SCI_BUS_REQ) == 0) {\n\t\t\ttimo = 0;\t/* return 0 */\n\t\t\tbreak;\n\t\t}\n\t\tif (--timo < 0)\n\t\t\tbreak;\t/* return -1 */\n\t\tdelay(2);\n\t}\n\treturn (timo);\n}"
  },
  {
    "function_name": "ncr5380_wait_req",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/ncr5380sbc.c",
    "lines": "188-202",
    "snippet": "static __inline int ncr5380_wait_req(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tregister int timo = ncr5380_wait_req_timo;\n\tfor (;;) {\n\t\tif (*sc->sci_bus_csr & SCI_BUS_REQ) {\n\t\t\ttimo = 0;\t/* return 0 */\n\t\t\tbreak;\n\t\t}\n\t\tif (--timo < 0)\n\t\t\tbreak;\t/* return -1 */\n\t\tdelay(2);\n\t}\n\treturn (timo);\n}",
    "includes": [
      "#include <dev/ic/ncr5380var.h>",
      "#include <dev/ic/ncr5380reg.h>",
      "#include <ddb/db_output.h>",
      "#include <scsi/scsiconf.h>",
      "#include <scsi/scsi_message.h>",
      "#include <scsi/scsi_debug.h>",
      "#include <scsi/scsi_all.h>",
      "#include <sys/user.h>",
      "#include <sys/proc.h>",
      "#include <sys/buf.h>",
      "#include <sys/device.h>",
      "#include <sys/errno.h>",
      "#include <sys/kernel.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ncr5380_wait_req_timo = 1000 * 50;",
      "static __inline int ncr5380_wait_req"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "2"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "dc_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/dc.c",
          "lines": "215-222",
          "snippet": "void dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}",
          "includes": [
            "#include <dev/ic/dcreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void dc_delay"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/dcreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid dc_delay;\n\nvoid dc_delay(sc)\n\tstruct dc_softc\t\t*sc;\n{\n\tint\t\t\tidx;\n\n\tfor (idx = (300 / 33) + 1; idx > 0; idx--)\n\t\tCSR_READ_4(sc, DC_BUSCTL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/ic/ncr5380var.h>\n#include <dev/ic/ncr5380reg.h>\n#include <ddb/db_output.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_message.h>\n#include <scsi/scsi_debug.h>\n#include <scsi/scsi_all.h>\n#include <sys/user.h>\n#include <sys/proc.h>\n#include <sys/buf.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint ncr5380_wait_req_timo = 1000 * 50;\nstatic __inline int ncr5380_wait_req;\n\nstatic __inline int ncr5380_wait_req(sc)\n\tstruct ncr5380_softc *sc;\n{\n\tregister int timo = ncr5380_wait_req_timo;\n\tfor (;;) {\n\t\tif (*sc->sci_bus_csr & SCI_BUS_REQ) {\n\t\t\ttimo = 0;\t/* return 0 */\n\t\t\tbreak;\n\t\t}\n\t\tif (--timo < 0)\n\t\t\tbreak;\t/* return -1 */\n\t\tdelay(2);\n\t}\n\treturn (timo);\n}"
  }
]