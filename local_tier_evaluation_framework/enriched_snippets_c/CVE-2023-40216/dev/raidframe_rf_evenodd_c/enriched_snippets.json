[
  {
    "function_name": "rf_VerifyParityEvenOdd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_evenodd.c",
    "lines": "350-555",
    "snippet": "int \nrf_VerifyParityEvenOdd(raidPtr, raidAddr, parityPDA, correct_it, flags)\n\tRF_Raid_t *raidPtr;\n\tRF_RaidAddr_t raidAddr;\n\tRF_PhysDiskAddr_t *parityPDA;\n\tint     correct_it;\n\tRF_RaidAccessFlags_t flags;\n{\n\tRF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);\n\tRF_RaidAddr_t startAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, raidAddr);\n\tRF_SectorCount_t numsector = parityPDA->numSector;\n\tint     numbytes = rf_RaidAddressToByte(raidPtr, numsector);\n\tint     bytesPerStripe = numbytes * layoutPtr->numDataCol;\n\tRF_DagHeader_t *rd_dag_h, *wr_dag_h;\t/* read, write dag */\n\tRF_DagNode_t *blockNode, *unblockNode, *wrBlock, *wrUnblock;\n\tRF_AccessStripeMapHeader_t *asm_h;\n\tRF_AccessStripeMap_t *asmap;\n\tRF_AllocListElem_t *alloclist;\n\tRF_PhysDiskAddr_t *pda;\n\tchar   *pbuf, *buf, *end_p, *p;\n\tchar   *redundantbuf2;\n\tint     redundantTwoErr = 0, redundantOneErr = 0;\n\tint     parity_cant_correct = RF_FALSE, red2_cant_correct = RF_FALSE,\n\t        parity_corrected = RF_FALSE, red2_corrected = RF_FALSE;\n\tint     i, retcode;\n\tRF_ReconUnitNum_t which_ru;\n\tRF_StripeNum_t psID = rf_RaidAddressToParityStripeID(layoutPtr, raidAddr, &which_ru);\n\tint     stripeWidth = layoutPtr->numDataCol + layoutPtr->numParityCol;\n\tRF_AccTraceEntry_t tracerec;\n\tRF_MCPair_t *mcpair;\n\n\tretcode = RF_PARITY_OKAY;\n\n\tmcpair = rf_AllocMCPair();\n\trf_MakeAllocList(alloclist);\n\tRF_MallocAndAdd(buf, numbytes * (layoutPtr->numDataCol + layoutPtr->numParityCol), (char *), alloclist);\n\tRF_CallocAndAdd(pbuf, 1, numbytes, (char *), alloclist);\t/* use calloc to make\n\t\t\t\t\t\t\t\t\t * sure buffer is zeroed */\n\tend_p = buf + bytesPerStripe;\n\tRF_CallocAndAdd(redundantbuf2, 1, numbytes, (char *), alloclist);\t/* use calloc to make\n\t\t\t\t\t\t\t\t\t\t * sure buffer is zeroed */\n\n\trd_dag_h = rf_MakeSimpleDAG(raidPtr, stripeWidth, numbytes, buf, rf_DiskReadFunc, rf_DiskReadUndoFunc,\n\t    \"Rod\", alloclist, flags, RF_IO_NORMAL_PRIORITY);\n\tblockNode = rd_dag_h->succedents[0];\n\tunblockNode = blockNode->succedents[0]->succedents[0];\n\n\t/* map the stripe and fill in the PDAs in the dag */\n\tasm_h = rf_MapAccess(raidPtr, startAddr, layoutPtr->dataSectorsPerStripe, buf, RF_DONT_REMAP);\n\tasmap = asm_h->stripeMap;\n\n\tfor (pda = asmap->physInfo, i = 0; i < layoutPtr->numDataCol; i++, pda = pda->next) {\n\t\tRF_ASSERT(pda);\n\t\trf_RangeRestrictPDA(raidPtr, parityPDA, pda, 0, 1);\n\t\tRF_ASSERT(pda->numSector != 0);\n\t\tif (rf_TryToRedirectPDA(raidPtr, pda, 0))\n\t\t\tgoto out;\t/* no way to verify parity if disk is\n\t\t\t\t\t * dead.  return w/ good status */\n\t\tblockNode->succedents[i]->params[0].p = pda;\n\t\tblockNode->succedents[i]->params[2].v = psID;\n\t\tblockNode->succedents[i]->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);\n\t}\n\n\tRF_ASSERT(!asmap->parityInfo->next);\n\trf_RangeRestrictPDA(raidPtr, parityPDA, asmap->parityInfo, 0, 1);\n\tRF_ASSERT(asmap->parityInfo->numSector != 0);\n\tif (rf_TryToRedirectPDA(raidPtr, asmap->parityInfo, 1))\n\t\tgoto out;\n\tblockNode->succedents[layoutPtr->numDataCol]->params[0].p = asmap->parityInfo;\n\n\tRF_ASSERT(!asmap->qInfo->next);\n\trf_RangeRestrictPDA(raidPtr, parityPDA, asmap->qInfo, 0, 1);\n\tRF_ASSERT(asmap->qInfo->numSector != 0);\n\tif (rf_TryToRedirectPDA(raidPtr, asmap->qInfo, 1))\n\t\tgoto out;\n\t/* if disk is dead, b/c no reconstruction is implemented right now,\n\t * the function \"rf_TryToRedirectPDA\" always return one, which cause\n\t * go to out and return w/ good status   */\n\tblockNode->succedents[layoutPtr->numDataCol + 1]->params[0].p = asmap->qInfo;\n\n\t/* fire off the DAG */\n\tbzero((char *) &tracerec, sizeof(tracerec));\n\trd_dag_h->tracerec = &tracerec;\n\n\tif (rf_verifyParityDebug) {\n\t\tprintf(\"Parity verify read dag:\\n\");\n\t\trf_PrintDAGList(rd_dag_h);\n\t}\n\tRF_LOCK_MUTEX(mcpair->mutex);\n\tmcpair->flag = 0;\n\trf_DispatchDAG(rd_dag_h, (void (*) (void *)) rf_MCPairWakeupFunc,\n\t    (void *) mcpair);\n\twhile (!mcpair->flag)\n\t\tRF_WAIT_COND(mcpair->cond, mcpair->mutex);\n\tRF_UNLOCK_MUTEX(mcpair->mutex);\n\tif (rd_dag_h->status != rf_enable) {\n\t\tRF_ERRORMSG(\"Unable to verify parity:  can't read the stripe\\n\");\n\t\tretcode = RF_PARITY_COULD_NOT_VERIFY;\n\t\tgoto out;\n\t}\n\tfor (p = buf, i = 0; p < end_p; p += numbytes, i++) {\n\t\trf_e_encToBuf(raidPtr, i, p, RF_EO_MATRIX_DIM - 2, redundantbuf2, numsector);\n\t\t/* the corresponding columes in EvenOdd encoding Matrix for\n\t\t * these p pointers which point to the databuffer in a full\n\t\t * stripe are sequentially from 0 to layoutPtr->numDataCol-1 */\n\t\trf_bxor(p, pbuf, numbytes, NULL);\n\t}\n\tRF_ASSERT(i == layoutPtr->numDataCol);\n\n\tfor (i = 0; i < numbytes; i++) {\n\t\tif (pbuf[i] != buf[bytesPerStripe + i]) {\n\t\t\tif (!correct_it) {\n\t\t\t\tRF_ERRORMSG3(\"Parity verify error: byte %d of parity is 0x%x should be 0x%x\\n\",\n\t\t\t\t    i, (u_char) buf[bytesPerStripe + i], (u_char) pbuf[i]);\n\t\t\t}\n\t\t}\n\t\tredundantOneErr = 1;\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < numbytes; i++) {\n\t\tif (redundantbuf2[i] != buf[bytesPerStripe + numbytes + i]) {\n\t\t\tif (!correct_it) {\n\t\t\t\tRF_ERRORMSG3(\"Parity verify error: byte %d of second redundant information is 0x%x should be 0x%x\\n\",\n\t\t\t\t    i, (u_char) buf[bytesPerStripe + numbytes + i], (u_char) redundantbuf2[i]);\n\t\t\t}\n\t\t\tredundantTwoErr = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (redundantOneErr || redundantTwoErr)\n\t\tretcode = RF_PARITY_BAD;\n\n\t/* correct the first redundant disk, ie parity if it is error    */\n\tif (redundantOneErr && correct_it) {\n\t\twr_dag_h = rf_MakeSimpleDAG(raidPtr, 1, numbytes, pbuf, rf_DiskWriteFunc, rf_DiskWriteUndoFunc,\n\t\t    \"Wnp\", alloclist, flags, RF_IO_NORMAL_PRIORITY);\n\t\twrBlock = wr_dag_h->succedents[0];\n\t\twrUnblock = wrBlock->succedents[0]->succedents[0];\n\t\twrBlock->succedents[0]->params[0].p = asmap->parityInfo;\n\t\twrBlock->succedents[0]->params[2].v = psID;\n\t\twrBlock->succedents[0]->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);\n\t\tbzero((char *) &tracerec, sizeof(tracerec));\n\t\twr_dag_h->tracerec = &tracerec;\n\t\tif (rf_verifyParityDebug) {\n\t\t\tprintf(\"Parity verify write dag:\\n\");\n\t\t\trf_PrintDAGList(wr_dag_h);\n\t\t}\n\t\tRF_LOCK_MUTEX(mcpair->mutex);\n\t\tmcpair->flag = 0;\n\t\trf_DispatchDAG(wr_dag_h, (void (*) (void *)) rf_MCPairWakeupFunc,\n\t\t    (void *) mcpair);\n\t\twhile (!mcpair->flag)\n\t\t\tRF_WAIT_COND(mcpair->cond, mcpair->mutex);\n\t\tRF_UNLOCK_MUTEX(mcpair->mutex);\n\t\tif (wr_dag_h->status != rf_enable) {\n\t\t\tRF_ERRORMSG(\"Unable to correct parity in VerifyParity:  can't write the stripe\\n\");\n\t\t\tparity_cant_correct = RF_TRUE;\n\t\t} else {\n\t\t\tparity_corrected = RF_TRUE;\n\t\t}\n\t\trf_FreeDAG(wr_dag_h);\n\t}\n\tif (redundantTwoErr && correct_it) {\n\t\twr_dag_h = rf_MakeSimpleDAG(raidPtr, 1, numbytes, redundantbuf2, rf_DiskWriteFunc, rf_DiskWriteUndoFunc,\n\t\t    \"Wnred2\", alloclist, flags, RF_IO_NORMAL_PRIORITY);\n\t\twrBlock = wr_dag_h->succedents[0];\n\t\twrUnblock = wrBlock->succedents[0]->succedents[0];\n\t\twrBlock->succedents[0]->params[0].p = asmap->qInfo;\n\t\twrBlock->succedents[0]->params[2].v = psID;\n\t\twrBlock->succedents[0]->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);\n\t\tbzero((char *) &tracerec, sizeof(tracerec));\n\t\twr_dag_h->tracerec = &tracerec;\n\t\tif (rf_verifyParityDebug) {\n\t\t\tprintf(\"Dag of write new second redundant information in parity verify :\\n\");\n\t\t\trf_PrintDAGList(wr_dag_h);\n\t\t}\n\t\tRF_LOCK_MUTEX(mcpair->mutex);\n\t\tmcpair->flag = 0;\n\t\trf_DispatchDAG(wr_dag_h, (void (*) (void *)) rf_MCPairWakeupFunc,\n\t\t    (void *) mcpair);\n\t\twhile (!mcpair->flag)\n\t\t\tRF_WAIT_COND(mcpair->cond, mcpair->mutex);\n\t\tRF_UNLOCK_MUTEX(mcpair->mutex);\n\t\tif (wr_dag_h->status != rf_enable) {\n\t\t\tRF_ERRORMSG(\"Unable to correct second redundant information in VerifyParity:  can't write the stripe\\n\");\n\t\t\tred2_cant_correct = RF_TRUE;\n\t\t} else {\n\t\t\tred2_corrected = RF_TRUE;\n\t\t}\n\t\trf_FreeDAG(wr_dag_h);\n\t}\n\tif ((redundantOneErr && parity_cant_correct) ||\n\t    (redundantTwoErr && red2_cant_correct))\n\t\tretcode = RF_PARITY_COULD_NOT_CORRECT;\n\tif ((retcode = RF_PARITY_BAD) && parity_corrected && red2_corrected)\n\t\tretcode = RF_PARITY_CORRECTED;\n\n\nout:\n\trf_FreeAccessStripeMap(asm_h);\n\trf_FreeAllocList(alloclist);\n\trf_FreeDAG(rd_dag_h);\n\trf_FreeMCPair(mcpair);\n\treturn (retcode);\n}",
    "includes": [
      "#include \"rf_engine.h\"",
      "#include \"rf_evenodd_dags.h\"",
      "#include \"rf_evenodd_dagfuncs.h\"",
      "#include \"rf_evenodd.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_pq.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_evenodd.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_FreeMCPair",
          "args": [
            "mcpair"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FreeMCPair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_mcpair.c",
          "lines": "125-130",
          "snippet": "void \nrf_FreeMCPair(t)\n\tRF_MCPair_t *t;\n{\n\tRF_FREELIST_FREE_CLEAN(rf_mcpair_freelist, t, next, clean_mcpair);\n}",
          "includes": [
            "#include <sys/proc.h>",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_mcpair.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static RF_FreeList_t *rf_mcpair_freelist;",
            "static int init_mcpair(RF_MCPair_t *);",
            "static void clean_mcpair(RF_MCPair_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/proc.h>\n#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic RF_FreeList_t *rf_mcpair_freelist;\nstatic int init_mcpair(RF_MCPair_t *);\nstatic void clean_mcpair(RF_MCPair_t *);\n\nvoid \nrf_FreeMCPair(t)\n\tRF_MCPair_t *t;\n{\n\tRF_FREELIST_FREE_CLEAN(rf_mcpair_freelist, t, next, clean_mcpair);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_FreeDAG",
          "args": [
            "rd_dag_h"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FreeDAGHeader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
          "lines": "257-261",
          "snippet": "void \nrf_FreeDAGHeader(RF_DagHeader_t * dh)\n{\n\tRF_FREELIST_FREE(rf_dagh_freelist, dh, next);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void rf_PrintDAG(RF_DagHeader_t *);",
            "static void rf_ValidateVisitedBits(RF_DagHeader_t *);",
            "static RF_FreeList_t *rf_dagh_freelist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_PrintDAG(RF_DagHeader_t *);\nstatic void rf_ValidateVisitedBits(RF_DagHeader_t *);\nstatic RF_FreeList_t *rf_dagh_freelist;\n\nvoid \nrf_FreeDAGHeader(RF_DagHeader_t * dh)\n{\n\tRF_FREELIST_FREE(rf_dagh_freelist, dh, next);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_FreeAllocList",
          "args": [
            "alloclist"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FreeAllocList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_alloclist.c",
          "lines": "139-164",
          "snippet": "void \nrf_FreeAllocList(l)\n\tRF_AllocListElem_t *l;\n{\n\tint     i;\n\tRF_AllocListElem_t *temp, *p;\n\n\tfor (p = l; p; p = p->next) {\n\t\tRF_ASSERT(p->numPointers >= 0 && p->numPointers <= RF_POINTERS_PER_ALLOC_LIST_ELEMENT);\n\t\tfor (i = 0; i < p->numPointers; i++) {\n\t\t\tRF_ASSERT(p->pointers[i]);\n\t\t\tRF_Free(p->pointers[i], p->sizes[i]);\n\t\t}\n\t}\n\twhile (l) {\n\t\ttemp = l;\n\t\tl = l->next;\n\t\tif (al_free_list_count > RF_AL_FREELIST_MAX) {\n\t\t\tDO_FREE(temp, sizeof(*temp));\n\t\t} else {\n\t\t\ttemp->next = al_free_list;\n\t\t\tal_free_list = temp;\n\t\t\tal_free_list_count++;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define RF_AL_FREELIST_MAX 256"
          ],
          "globals_used": [
            "static RF_AllocListElem_t *al_free_list = NULL;",
            "static int al_free_list_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define RF_AL_FREELIST_MAX 256\n\nstatic RF_AllocListElem_t *al_free_list = NULL;\nstatic int al_free_list_count;\n\nvoid \nrf_FreeAllocList(l)\n\tRF_AllocListElem_t *l;\n{\n\tint     i;\n\tRF_AllocListElem_t *temp, *p;\n\n\tfor (p = l; p; p = p->next) {\n\t\tRF_ASSERT(p->numPointers >= 0 && p->numPointers <= RF_POINTERS_PER_ALLOC_LIST_ELEMENT);\n\t\tfor (i = 0; i < p->numPointers; i++) {\n\t\t\tRF_ASSERT(p->pointers[i]);\n\t\t\tRF_Free(p->pointers[i], p->sizes[i]);\n\t\t}\n\t}\n\twhile (l) {\n\t\ttemp = l;\n\t\tl = l->next;\n\t\tif (al_free_list_count > RF_AL_FREELIST_MAX) {\n\t\t\tDO_FREE(temp, sizeof(*temp));\n\t\t} else {\n\t\t\ttemp->next = al_free_list;\n\t\t\tal_free_list = temp;\n\t\t\tal_free_list_count++;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_FreeAccessStripeMap",
          "args": [
            "asm_h"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "rf_FreeAccessStripeMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_map.c",
          "lines": "537-598",
          "snippet": "void \nrf_FreeAccessStripeMap(hdr)\n\tRF_AccessStripeMapHeader_t *hdr;\n{\n\tRF_AccessStripeMap_t *p, *pt = NULL;\n\tRF_PhysDiskAddr_t *pdp, *trailer, *pdaList = NULL, *pdaEnd = NULL;\n\tint     count = 0, t, asm_count = 0;\n\n\tfor (p = hdr->stripeMap; p; p = p->next) {\n\n\t\t/* link the 3 pda lists into the accumulating pda list */\n\n\t\tif (!pdaList)\n\t\t\tpdaList = p->qInfo;\n\t\telse\n\t\t\tpdaEnd->next = p->qInfo;\n\t\tfor (trailer = NULL, pdp = p->qInfo; pdp;) {\n\t\t\ttrailer = pdp;\n\t\t\tpdp = pdp->next;\n\t\t\tcount++;\n\t\t}\n\t\tif (trailer)\n\t\t\tpdaEnd = trailer;\n\n\t\tif (!pdaList)\n\t\t\tpdaList = p->parityInfo;\n\t\telse\n\t\t\tpdaEnd->next = p->parityInfo;\n\t\tfor (trailer = NULL, pdp = p->parityInfo; pdp;) {\n\t\t\ttrailer = pdp;\n\t\t\tpdp = pdp->next;\n\t\t\tcount++;\n\t\t}\n\t\tif (trailer)\n\t\t\tpdaEnd = trailer;\n\n\t\tif (!pdaList)\n\t\t\tpdaList = p->physInfo;\n\t\telse\n\t\t\tpdaEnd->next = p->physInfo;\n\t\tfor (trailer = NULL, pdp = p->physInfo; pdp;) {\n\t\t\ttrailer = pdp;\n\t\t\tpdp = pdp->next;\n\t\t\tcount++;\n\t\t}\n\t\tif (trailer)\n\t\t\tpdaEnd = trailer;\n\n\t\tpt = p;\n\t\tasm_count++;\n\t}\n\n\t/* debug only */\n\tfor (t = 0, pdp = pdaList; pdp; pdp = pdp->next)\n\t\tt++;\n\tRF_ASSERT(t == count);\n\n\tif (pdaList)\n\t\trf_FreePDAList(pdaList, pdaEnd, count);\n\trf_FreeASMList(hdr->stripeMap, pt, asm_count);\n\trf_FreeAccessStripeMapHeader(hdr);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void rf_FreePDAList(RF_PhysDiskAddr_t * start, RF_PhysDiskAddr_t * end, int count);",
            "static void \nrf_FreeASMList(RF_AccessStripeMap_t * start, RF_AccessStripeMap_t * end,\n    int count);",
            "RF_PhysDiskAddr_t *\nrf_DuplicatePDA(pda)\n\tRF_PhysDiskAddr_t *pda;",
            "RF_PhysDiskAddr_t *\nrf_AllocPDAList(count)\n\tint     count;",
            "RF_AccessStripeMap_t *\nrf_AllocASMList(count)\n\tint     count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic void rf_FreePDAList(RF_PhysDiskAddr_t * start, RF_PhysDiskAddr_t * end, int count);\nstatic void \nrf_FreeASMList(RF_AccessStripeMap_t * start, RF_AccessStripeMap_t * end,\n    int count);\nRF_PhysDiskAddr_t *\nrf_DuplicatePDA(pda)\n\tRF_PhysDiskAddr_t *pda;\nRF_PhysDiskAddr_t *\nrf_AllocPDAList(count)\n\tint     count;\nRF_AccessStripeMap_t *\nrf_AllocASMList(count)\n\tint     count;\n\nvoid \nrf_FreeAccessStripeMap(hdr)\n\tRF_AccessStripeMapHeader_t *hdr;\n{\n\tRF_AccessStripeMap_t *p, *pt = NULL;\n\tRF_PhysDiskAddr_t *pdp, *trailer, *pdaList = NULL, *pdaEnd = NULL;\n\tint     count = 0, t, asm_count = 0;\n\n\tfor (p = hdr->stripeMap; p; p = p->next) {\n\n\t\t/* link the 3 pda lists into the accumulating pda list */\n\n\t\tif (!pdaList)\n\t\t\tpdaList = p->qInfo;\n\t\telse\n\t\t\tpdaEnd->next = p->qInfo;\n\t\tfor (trailer = NULL, pdp = p->qInfo; pdp;) {\n\t\t\ttrailer = pdp;\n\t\t\tpdp = pdp->next;\n\t\t\tcount++;\n\t\t}\n\t\tif (trailer)\n\t\t\tpdaEnd = trailer;\n\n\t\tif (!pdaList)\n\t\t\tpdaList = p->parityInfo;\n\t\telse\n\t\t\tpdaEnd->next = p->parityInfo;\n\t\tfor (trailer = NULL, pdp = p->parityInfo; pdp;) {\n\t\t\ttrailer = pdp;\n\t\t\tpdp = pdp->next;\n\t\t\tcount++;\n\t\t}\n\t\tif (trailer)\n\t\t\tpdaEnd = trailer;\n\n\t\tif (!pdaList)\n\t\t\tpdaList = p->physInfo;\n\t\telse\n\t\t\tpdaEnd->next = p->physInfo;\n\t\tfor (trailer = NULL, pdp = p->physInfo; pdp;) {\n\t\t\ttrailer = pdp;\n\t\t\tpdp = pdp->next;\n\t\t\tcount++;\n\t\t}\n\t\tif (trailer)\n\t\t\tpdaEnd = trailer;\n\n\t\tpt = p;\n\t\tasm_count++;\n\t}\n\n\t/* debug only */\n\tfor (t = 0, pdp = pdaList; pdp; pdp = pdp->next)\n\t\tt++;\n\tRF_ASSERT(t == count);\n\n\tif (pdaList)\n\t\trf_FreePDAList(pdaList, pdaEnd, count);\n\trf_FreeASMList(hdr->stripeMap, pt, asm_count);\n\trf_FreeAccessStripeMapHeader(hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG",
          "args": [
            "\"Unable to correct second redundant information in VerifyParity:  can't write the stripe\\n\""
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "mcpair->mutex"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_WAIT_COND",
          "args": [
            "mcpair->cond",
            "mcpair->mutex"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_DispatchDAG",
          "args": [
            "wr_dag_h",
            "(void (*) (void *)) rf_MCPairWakeupFunc",
            "(void *) mcpair"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "rf_DispatchDAG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_engine.c",
          "lines": "668-695",
          "snippet": "int \nrf_DispatchDAG(\n    RF_DagHeader_t * dag,\n    void (*cbFunc) (void *),\n    void *cbArg)\n{\n\tRF_Raid_t *raidPtr;\n\n\traidPtr = dag->raidPtr;\n\tif (dag->tracerec) {\n\t\tRF_ETIMER_START(dag->tracerec->timer);\n\t}\n\tif (rf_engineDebug || rf_validateDAGDebug) {\n\t\tif (rf_ValidateDAG(dag))\n\t\t\tRF_PANIC();\n\t}\n\tif (rf_engineDebug) {\n\t\tprintf(\"raid%d: Entering DispatchDAG\\n\", raidPtr->raidid);\n\t}\n\traidPtr->dags_in_flight++;\t/* debug only:  blow off proper\n\t\t\t\t\t * locking */\n\tdag->cbFunc = cbFunc;\n\tdag->cbArg = cbArg;\n\tdag->numNodesCompleted = 0;\n\tdag->status = rf_enable;\n\tFireNodeArray(dag->numSuccedents, dag->succedents);\n\treturn (1);\n}",
          "includes": [
            "#include \"rf_raid.h\"",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_dag.h\"",
            "#include <sys/errno.h>",
            "#include \"rf_threadstuff.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_raid.h\"\n#include \"rf_shutdown.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_engine.h\"\n#include \"rf_dag.h\"\n#include <sys/errno.h>\n#include \"rf_threadstuff.h\"\n\nint \nrf_DispatchDAG(\n    RF_DagHeader_t * dag,\n    void (*cbFunc) (void *),\n    void *cbArg)\n{\n\tRF_Raid_t *raidPtr;\n\n\traidPtr = dag->raidPtr;\n\tif (dag->tracerec) {\n\t\tRF_ETIMER_START(dag->tracerec->timer);\n\t}\n\tif (rf_engineDebug || rf_validateDAGDebug) {\n\t\tif (rf_ValidateDAG(dag))\n\t\t\tRF_PANIC();\n\t}\n\tif (rf_engineDebug) {\n\t\tprintf(\"raid%d: Entering DispatchDAG\\n\", raidPtr->raidid);\n\t}\n\traidPtr->dags_in_flight++;\t/* debug only:  blow off proper\n\t\t\t\t\t * locking */\n\tdag->cbFunc = cbFunc;\n\tdag->cbArg = cbArg;\n\tdag->numNodesCompleted = 0;\n\tdag->status = rf_enable;\n\tFireNodeArray(dag->numSuccedents, dag->succedents);\n\treturn (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "mcpair->mutex"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_PrintDAGList",
          "args": [
            "wr_dag_h"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "rf_PrintDAGList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
          "lines": "509-519",
          "snippet": "void \nrf_PrintDAGList(RF_DagHeader_t * dag_h)\n{\n\tint     i = 0;\n\n\tfor (; dag_h; dag_h = dag_h->next) {\n\t\trf_AssignNodeNums(dag_h);\n\t\tprintf(\"\\n\\nDAG %d IN LIST:\\n\", i++);\n\t\trf_PrintDAG(dag_h);\n\t}\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void rf_PrintDAG(RF_DagHeader_t *);",
            "static void rf_ValidateVisitedBits(RF_DagHeader_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nstatic void rf_PrintDAG(RF_DagHeader_t *);\nstatic void rf_ValidateVisitedBits(RF_DagHeader_t *);\n\nvoid \nrf_PrintDAGList(RF_DagHeader_t * dag_h)\n{\n\tint     i = 0;\n\n\tfor (; dag_h; dag_h = dag_h->next) {\n\t\trf_AssignNodeNums(dag_h);\n\t\tprintf(\"\\n\\nDAG %d IN LIST:\\n\", i++);\n\t\trf_PrintDAG(dag_h);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Dag of write new second redundant information in parity verify :\\n\""
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *) &tracerec",
            "sizeof(tracerec)"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_CREATE_PARAM3",
          "args": [
            "RF_IO_NORMAL_PRIORITY",
            "0",
            "0",
            "which_ru"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_MakeSimpleDAG",
          "args": [
            "raidPtr",
            "1",
            "numbytes",
            "redundantbuf2",
            "rf_DiskWriteFunc",
            "rf_DiskWriteUndoFunc",
            "\"Wnred2\"",
            "alloclist",
            "flags",
            "RF_IO_NORMAL_PRIORITY"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG",
          "args": [
            "\"Unable to correct parity in VerifyParity:  can't write the stripe\\n\""
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "mcpair->mutex"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_WAIT_COND",
          "args": [
            "mcpair->cond",
            "mcpair->mutex"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "mcpair->mutex"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *) &tracerec",
            "sizeof(tracerec)"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_CREATE_PARAM3",
          "args": [
            "RF_IO_NORMAL_PRIORITY",
            "0",
            "0",
            "which_ru"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_MakeSimpleDAG",
          "args": [
            "raidPtr",
            "1",
            "numbytes",
            "pbuf",
            "rf_DiskWriteFunc",
            "rf_DiskWriteUndoFunc",
            "\"Wnp\"",
            "alloclist",
            "flags",
            "RF_IO_NORMAL_PRIORITY"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"Parity verify error: byte %d of second redundant information is 0x%x should be 0x%x\\n\"",
            "i",
            "(u_char) buf[bytesPerStripe + numbytes + i]",
            "(u_char) redundantbuf2[i]"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"Parity verify error: byte %d of parity is 0x%x should be 0x%x\\n\"",
            "i",
            "(u_char) buf[bytesPerStripe + i]",
            "(u_char) pbuf[i]"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "i == layoutPtr->numDataCol"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_bxor",
          "args": [
            "p",
            "pbuf",
            "numbytes",
            "NULL"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "rf_bxor3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagfuncs.c",
          "lines": "880-893",
          "snippet": "int \nrf_bxor3(dst, a, b, c, len, bp)\n\tregister unsigned char *dst;\n\tregister unsigned char *a;\n\tregister unsigned char *b;\n\tregister unsigned char *c;\n\tunsigned long len;\n\tvoid   *bp;\n{\n\tRF_ASSERT(((RF_UL(dst) | RF_UL(a) | RF_UL(b) | RF_UL(c) | len) & 0x7) == 0);\n\n\treturn (rf_longword_bxor3((unsigned long *) dst, (unsigned long *) a,\n\t\t(unsigned long *) b, (unsigned long *) c, len >> RF_LONGSHIFT, bp));\n}",
          "includes": [
            "#include \"rf_paritylog.h\"",
            "#include \"rf_kintf.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_diskqueue.h\"",
            "#include \"rf_acctrace.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_layout.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_archs.h\"",
            "#include <sys/param.h>",
            "#include <sys/ioctl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_paritylog.h\"\n#include \"rf_kintf.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_diskqueue.h\"\n#include \"rf_acctrace.h\"\n#include \"rf_etimer.h\"\n#include \"rf_layout.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_archs.h\"\n#include <sys/param.h>\n#include <sys/ioctl.h>\n\nint \nrf_bxor3(dst, a, b, c, len, bp)\n\tregister unsigned char *dst;\n\tregister unsigned char *a;\n\tregister unsigned char *b;\n\tregister unsigned char *c;\n\tunsigned long len;\n\tvoid   *bp;\n{\n\tRF_ASSERT(((RF_UL(dst) | RF_UL(a) | RF_UL(b) | RF_UL(c) | len) & 0x7) == 0);\n\n\treturn (rf_longword_bxor3((unsigned long *) dst, (unsigned long *) a,\n\t\t(unsigned long *) b, (unsigned long *) c, len >> RF_LONGSHIFT, bp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_e_encToBuf",
          "args": [
            "raidPtr",
            "i",
            "p",
            "RF_EO_MATRIX_DIM - 2",
            "redundantbuf2",
            "numsector"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "rf_e_encToBuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_evenodd_dagfuncs.c",
          "lines": "371-387",
          "snippet": "void \nrf_e_encToBuf(\n    RF_Raid_t * raidPtr,\n    RF_RowCol_t srcLogicCol,\n    char *srcbuf,\n    RF_RowCol_t destLogicCol,\n    char *destbuf,\n    int numSector)\n{\n\tint     i, bytesPerSector = rf_RaidAddressToByte(raidPtr, 1);\n\n\tfor (i = 0; i < numSector; i++) {\n\t\trf_e_EncOneSect(srcLogicCol, srcbuf, destLogicCol, destbuf, bytesPerSector);\n\t\tsrcbuf += bytesPerSector;\n\t\tdestbuf += bytesPerSector;\n\t}\n}",
          "includes": [
            "#include \"rf_evenodd_dagfuncs.h\"",
            "#include \"rf_evenodd.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_configure.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_etimer.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dagdegwr.h\"",
            "#include \"rf_dagdegrd.h\"",
            "#include \"rf_dagffwr.h\"",
            "#include \"rf_dagffrd.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_evenodd_dagfuncs.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_configure.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_e_encToBuf(\n    RF_Raid_t * raidPtr,\n    RF_RowCol_t srcLogicCol,\n    char *srcbuf,\n    RF_RowCol_t destLogicCol,\n    char *destbuf,\n    int numSector)\n{\n\tint     i, bytesPerSector = rf_RaidAddressToByte(raidPtr, 1);\n\n\tfor (i = 0; i < numSector; i++) {\n\t\trf_e_EncOneSect(srcLogicCol, srcbuf, destLogicCol, destbuf, bytesPerSector);\n\t\tsrcbuf += bytesPerSector;\n\t\tdestbuf += bytesPerSector;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG",
          "args": [
            "\"Unable to verify parity:  can't read the stripe\\n\""
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "mcpair->mutex"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_WAIT_COND",
          "args": [
            "mcpair->cond",
            "mcpair->mutex"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "mcpair->mutex"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(char *) &tracerec",
            "sizeof(tracerec)"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_TryToRedirectPDA",
          "args": [
            "raidPtr",
            "asmap->qInfo",
            "1"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "rf_TryToRedirectPDA",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_parityscan.c",
          "lines": "315-348",
          "snippet": "int \nrf_TryToRedirectPDA(raidPtr, pda, parity)\n\tRF_Raid_t *raidPtr;\n\tRF_PhysDiskAddr_t *pda;\n\tint     parity;\n{\n\tif (raidPtr->Disks[pda->row][pda->col].status == rf_ds_reconstructing) {\n\t\tif (rf_CheckRUReconstructed(raidPtr->reconControl[pda->row]->reconMap, pda->startSector)) {\n\t\t\tif (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) {\n\t\t\t\tRF_RowCol_t or = pda->row, oc = pda->col;\n\t\t\t\tRF_SectorNum_t os = pda->startSector;\n\t\t\t\tif (parity) {\n\t\t\t\t\t(raidPtr->Layout.map->MapParity) (raidPtr, pda->raidAddress, &pda->row, &pda->col, &pda->startSector, RF_REMAP);\n\t\t\t\t\tif (rf_verifyParityDebug)\n\t\t\t\t\t\tprintf(\"VerifyParity: Redir P r %d c %d sect %ld -> r %d c %d sect %ld\\n\",\n\t\t\t\t\t\t    or, oc, (long) os, pda->row, pda->col, (long) pda->startSector);\n\t\t\t\t} else {\n\t\t\t\t\t(raidPtr->Layout.map->MapSector) (raidPtr, pda->raidAddress, &pda->row, &pda->col, &pda->startSector, RF_REMAP);\n\t\t\t\t\tif (rf_verifyParityDebug)\n\t\t\t\t\t\tprintf(\"VerifyParity: Redir D r %d c %d sect %ld -> r %d c %d sect %ld\\n\",\n\t\t\t\t\t\t    or, oc, (long) os, pda->row, pda->col, (long) pda->startSector);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tRF_RowCol_t spRow = raidPtr->Disks[pda->row][pda->col].spareRow;\n\t\t\t\tRF_RowCol_t spCol = raidPtr->Disks[pda->row][pda->col].spareCol;\n\t\t\t\tpda->row = spRow;\n\t\t\t\tpda->col = spCol;\n\t\t\t}\n\t\t}\n\t}\n\tif (RF_DEAD_DISK(raidPtr->Disks[pda->row][pda->col].status))\n\t\treturn (1);\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_map.h\"",
            "#include \"rf_parityscan.h\"",
            "#include \"rf_engine.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_mcpair.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "RF_DagHeader_t *\nrf_MakeSimpleDAG(raidPtr, nNodes, bytesPerSU, databuf, doFunc, undoFunc, name, alloclist, flags, priority)\n\tRF_Raid_t *raidPtr;",
            "RF_RaidAccessFlags_t flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_map.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_engine.h\"\n#include \"rf_general.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nRF_DagHeader_t *\nrf_MakeSimpleDAG(raidPtr, nNodes, bytesPerSU, databuf, doFunc, undoFunc, name, alloclist, flags, priority)\n\tRF_Raid_t *raidPtr;\nRF_RaidAccessFlags_t flags;\n\nint \nrf_TryToRedirectPDA(raidPtr, pda, parity)\n\tRF_Raid_t *raidPtr;\n\tRF_PhysDiskAddr_t *pda;\n\tint     parity;\n{\n\tif (raidPtr->Disks[pda->row][pda->col].status == rf_ds_reconstructing) {\n\t\tif (rf_CheckRUReconstructed(raidPtr->reconControl[pda->row]->reconMap, pda->startSector)) {\n\t\t\tif (raidPtr->Layout.map->flags & RF_DISTRIBUTE_SPARE) {\n\t\t\t\tRF_RowCol_t or = pda->row, oc = pda->col;\n\t\t\t\tRF_SectorNum_t os = pda->startSector;\n\t\t\t\tif (parity) {\n\t\t\t\t\t(raidPtr->Layout.map->MapParity) (raidPtr, pda->raidAddress, &pda->row, &pda->col, &pda->startSector, RF_REMAP);\n\t\t\t\t\tif (rf_verifyParityDebug)\n\t\t\t\t\t\tprintf(\"VerifyParity: Redir P r %d c %d sect %ld -> r %d c %d sect %ld\\n\",\n\t\t\t\t\t\t    or, oc, (long) os, pda->row, pda->col, (long) pda->startSector);\n\t\t\t\t} else {\n\t\t\t\t\t(raidPtr->Layout.map->MapSector) (raidPtr, pda->raidAddress, &pda->row, &pda->col, &pda->startSector, RF_REMAP);\n\t\t\t\t\tif (rf_verifyParityDebug)\n\t\t\t\t\t\tprintf(\"VerifyParity: Redir D r %d c %d sect %ld -> r %d c %d sect %ld\\n\",\n\t\t\t\t\t\t    or, oc, (long) os, pda->row, pda->col, (long) pda->startSector);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tRF_RowCol_t spRow = raidPtr->Disks[pda->row][pda->col].spareRow;\n\t\t\t\tRF_RowCol_t spCol = raidPtr->Disks[pda->row][pda->col].spareCol;\n\t\t\t\tpda->row = spRow;\n\t\t\t\tpda->col = spCol;\n\t\t\t}\n\t\t}\n\t}\n\tif (RF_DEAD_DISK(raidPtr->Disks[pda->row][pda->col].status))\n\t\treturn (1);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "asmap->qInfo->numSector != 0"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RangeRestrictPDA",
          "args": [
            "raidPtr",
            "parityPDA",
            "asmap->qInfo",
            "0",
            "1"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "rf_RangeRestrictPDA",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_dagutils.c",
          "lines": "1050-1075",
          "snippet": "void \nrf_RangeRestrictPDA(\n    RF_Raid_t * raidPtr,\n    RF_PhysDiskAddr_t * src,\n    RF_PhysDiskAddr_t * dest,\n    int dobuffer,\n    int doraidaddr)\n{\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_SectorNum_t soffs = rf_StripeUnitOffset(layoutPtr, src->startSector);\n\tRF_SectorNum_t doffs = rf_StripeUnitOffset(layoutPtr, dest->startSector);\n\tRF_SectorNum_t send = rf_StripeUnitOffset(layoutPtr, src->startSector + src->numSector - 1);\t/* use -1 to be sure we\n\t\t\t\t\t\t\t\t\t\t\t\t\t * stay within SU */\n\tRF_SectorNum_t dend = rf_StripeUnitOffset(layoutPtr, dest->startSector + dest->numSector - 1);\n\tRF_SectorNum_t subAddr = rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr, dest->startSector);\t/* stripe unit boundary */\n\n\tdest->startSector = subAddr + RF_MAX(soffs, doffs);\n\tdest->numSector = subAddr + RF_MIN(send, dend) + 1 - dest->startSector;\n\n\tif (dobuffer)\n\t\tdest->bufPtr += (soffs > doffs) ? rf_RaidAddressToByte(raidPtr, soffs - doffs) : 0;\n\tif (doraidaddr) {\n\t\tdest->raidAddress = rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr, dest->raidAddress) +\n\t\t    rf_StripeUnitOffset(layoutPtr, dest->startSector);\n\t}\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_dagfuncs.h\"",
            "#include \"rf_dagutils.h\"",
            "#include \"rf_dag.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\"",
            "#include \"rf_archs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_map.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nvoid \nrf_RangeRestrictPDA(\n    RF_Raid_t * raidPtr,\n    RF_PhysDiskAddr_t * src,\n    RF_PhysDiskAddr_t * dest,\n    int dobuffer,\n    int doraidaddr)\n{\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_SectorNum_t soffs = rf_StripeUnitOffset(layoutPtr, src->startSector);\n\tRF_SectorNum_t doffs = rf_StripeUnitOffset(layoutPtr, dest->startSector);\n\tRF_SectorNum_t send = rf_StripeUnitOffset(layoutPtr, src->startSector + src->numSector - 1);\t/* use -1 to be sure we\n\t\t\t\t\t\t\t\t\t\t\t\t\t * stay within SU */\n\tRF_SectorNum_t dend = rf_StripeUnitOffset(layoutPtr, dest->startSector + dest->numSector - 1);\n\tRF_SectorNum_t subAddr = rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr, dest->startSector);\t/* stripe unit boundary */\n\n\tdest->startSector = subAddr + RF_MAX(soffs, doffs);\n\tdest->numSector = subAddr + RF_MIN(send, dend) + 1 - dest->startSector;\n\n\tif (dobuffer)\n\t\tdest->bufPtr += (soffs > doffs) ? rf_RaidAddressToByte(raidPtr, soffs - doffs) : 0;\n\tif (doraidaddr) {\n\t\tdest->raidAddress = rf_RaidAddressOfPrevStripeUnitBoundary(layoutPtr, dest->raidAddress) +\n\t\t    rf_StripeUnitOffset(layoutPtr, dest->startSector);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "!asmap->qInfo->next"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "asmap->parityInfo->numSector != 0"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "!asmap->parityInfo->next"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_CREATE_PARAM3",
          "args": [
            "RF_IO_NORMAL_PRIORITY",
            "0",
            "0",
            "which_ru"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "pda->numSector != 0"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "pda"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_MapAccess",
          "args": [
            "raidPtr",
            "startAddr",
            "layoutPtr->dataSectorsPerStripe",
            "buf",
            "RF_DONT_REMAP"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_MakeSimpleDAG",
          "args": [
            "raidPtr",
            "stripeWidth",
            "numbytes",
            "buf",
            "rf_DiskReadFunc",
            "rf_DiskReadUndoFunc",
            "\"Rod\"",
            "alloclist",
            "flags",
            "RF_IO_NORMAL_PRIORITY"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_CallocAndAdd",
          "args": [
            "redundantbuf2",
            "1",
            "numbytes",
            "(char *), alloclist"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_CallocAndAdd",
          "args": [
            "pbuf",
            "1",
            "numbytes",
            "(char *), alloclist"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_MallocAndAdd",
          "args": [
            "buf",
            "numbytes * (layoutPtr->numDataCol + layoutPtr->numParityCol)",
            "(char *), alloclist"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_MakeAllocList",
          "args": [
            "alloclist"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_AllocMCPair",
          "args": [],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "rf_AllocMCPair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_mcpair.c",
          "lines": "112-123",
          "snippet": "RF_MCPair_t *\nrf_AllocMCPair()\n{\n\tRF_MCPair_t *t;\n\n\tRF_FREELIST_GET_INIT(rf_mcpair_freelist, t, next, (RF_MCPair_t *), init_mcpair);\n\tif (t) {\n\t\tt->flag = 0;\n\t\tt->next = NULL;\n\t}\n\treturn (t);\n}",
          "includes": [
            "#include <sys/proc.h>",
            "#include \"rf_shutdown.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_mcpair.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static RF_FreeList_t *rf_mcpair_freelist;",
            "static int init_mcpair(RF_MCPair_t *);",
            "static void clean_mcpair(RF_MCPair_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/proc.h>\n#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic RF_FreeList_t *rf_mcpair_freelist;\nstatic int init_mcpair(RF_MCPair_t *);\nstatic void clean_mcpair(RF_MCPair_t *);\n\nRF_MCPair_t *\nrf_AllocMCPair()\n{\n\tRF_MCPair_t *t;\n\n\tRF_FREELIST_GET_INIT(rf_mcpair_freelist, t, next, (RF_MCPair_t *), init_mcpair);\n\tif (t) {\n\t\tt->flag = 0;\n\t\tt->next = NULL;\n\t}\n\treturn (t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToParityStripeID",
          "args": [
            "layoutPtr",
            "raidAddr",
            "&which_ru"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressToByte",
          "args": [
            "raidPtr",
            "numsector"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_RaidAddressOfPrevStripeBoundary",
          "args": [
            "layoutPtr",
            "raidAddr"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_engine.h\"\n#include \"rf_evenodd_dags.h\"\n#include \"rf_evenodd_dagfuncs.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_pq.h\"\n#include \"rf_map.h\"\n#include \"rf_utils.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_configure.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nint \nrf_VerifyParityEvenOdd(raidPtr, raidAddr, parityPDA, correct_it, flags)\n\tRF_Raid_t *raidPtr;\n\tRF_RaidAddr_t raidAddr;\n\tRF_PhysDiskAddr_t *parityPDA;\n\tint     correct_it;\n\tRF_RaidAccessFlags_t flags;\n{\n\tRF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);\n\tRF_RaidAddr_t startAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, raidAddr);\n\tRF_SectorCount_t numsector = parityPDA->numSector;\n\tint     numbytes = rf_RaidAddressToByte(raidPtr, numsector);\n\tint     bytesPerStripe = numbytes * layoutPtr->numDataCol;\n\tRF_DagHeader_t *rd_dag_h, *wr_dag_h;\t/* read, write dag */\n\tRF_DagNode_t *blockNode, *unblockNode, *wrBlock, *wrUnblock;\n\tRF_AccessStripeMapHeader_t *asm_h;\n\tRF_AccessStripeMap_t *asmap;\n\tRF_AllocListElem_t *alloclist;\n\tRF_PhysDiskAddr_t *pda;\n\tchar   *pbuf, *buf, *end_p, *p;\n\tchar   *redundantbuf2;\n\tint     redundantTwoErr = 0, redundantOneErr = 0;\n\tint     parity_cant_correct = RF_FALSE, red2_cant_correct = RF_FALSE,\n\t        parity_corrected = RF_FALSE, red2_corrected = RF_FALSE;\n\tint     i, retcode;\n\tRF_ReconUnitNum_t which_ru;\n\tRF_StripeNum_t psID = rf_RaidAddressToParityStripeID(layoutPtr, raidAddr, &which_ru);\n\tint     stripeWidth = layoutPtr->numDataCol + layoutPtr->numParityCol;\n\tRF_AccTraceEntry_t tracerec;\n\tRF_MCPair_t *mcpair;\n\n\tretcode = RF_PARITY_OKAY;\n\n\tmcpair = rf_AllocMCPair();\n\trf_MakeAllocList(alloclist);\n\tRF_MallocAndAdd(buf, numbytes * (layoutPtr->numDataCol + layoutPtr->numParityCol), (char *), alloclist);\n\tRF_CallocAndAdd(pbuf, 1, numbytes, (char *), alloclist);\t/* use calloc to make\n\t\t\t\t\t\t\t\t\t * sure buffer is zeroed */\n\tend_p = buf + bytesPerStripe;\n\tRF_CallocAndAdd(redundantbuf2, 1, numbytes, (char *), alloclist);\t/* use calloc to make\n\t\t\t\t\t\t\t\t\t\t * sure buffer is zeroed */\n\n\trd_dag_h = rf_MakeSimpleDAG(raidPtr, stripeWidth, numbytes, buf, rf_DiskReadFunc, rf_DiskReadUndoFunc,\n\t    \"Rod\", alloclist, flags, RF_IO_NORMAL_PRIORITY);\n\tblockNode = rd_dag_h->succedents[0];\n\tunblockNode = blockNode->succedents[0]->succedents[0];\n\n\t/* map the stripe and fill in the PDAs in the dag */\n\tasm_h = rf_MapAccess(raidPtr, startAddr, layoutPtr->dataSectorsPerStripe, buf, RF_DONT_REMAP);\n\tasmap = asm_h->stripeMap;\n\n\tfor (pda = asmap->physInfo, i = 0; i < layoutPtr->numDataCol; i++, pda = pda->next) {\n\t\tRF_ASSERT(pda);\n\t\trf_RangeRestrictPDA(raidPtr, parityPDA, pda, 0, 1);\n\t\tRF_ASSERT(pda->numSector != 0);\n\t\tif (rf_TryToRedirectPDA(raidPtr, pda, 0))\n\t\t\tgoto out;\t/* no way to verify parity if disk is\n\t\t\t\t\t * dead.  return w/ good status */\n\t\tblockNode->succedents[i]->params[0].p = pda;\n\t\tblockNode->succedents[i]->params[2].v = psID;\n\t\tblockNode->succedents[i]->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);\n\t}\n\n\tRF_ASSERT(!asmap->parityInfo->next);\n\trf_RangeRestrictPDA(raidPtr, parityPDA, asmap->parityInfo, 0, 1);\n\tRF_ASSERT(asmap->parityInfo->numSector != 0);\n\tif (rf_TryToRedirectPDA(raidPtr, asmap->parityInfo, 1))\n\t\tgoto out;\n\tblockNode->succedents[layoutPtr->numDataCol]->params[0].p = asmap->parityInfo;\n\n\tRF_ASSERT(!asmap->qInfo->next);\n\trf_RangeRestrictPDA(raidPtr, parityPDA, asmap->qInfo, 0, 1);\n\tRF_ASSERT(asmap->qInfo->numSector != 0);\n\tif (rf_TryToRedirectPDA(raidPtr, asmap->qInfo, 1))\n\t\tgoto out;\n\t/* if disk is dead, b/c no reconstruction is implemented right now,\n\t * the function \"rf_TryToRedirectPDA\" always return one, which cause\n\t * go to out and return w/ good status   */\n\tblockNode->succedents[layoutPtr->numDataCol + 1]->params[0].p = asmap->qInfo;\n\n\t/* fire off the DAG */\n\tbzero((char *) &tracerec, sizeof(tracerec));\n\trd_dag_h->tracerec = &tracerec;\n\n\tif (rf_verifyParityDebug) {\n\t\tprintf(\"Parity verify read dag:\\n\");\n\t\trf_PrintDAGList(rd_dag_h);\n\t}\n\tRF_LOCK_MUTEX(mcpair->mutex);\n\tmcpair->flag = 0;\n\trf_DispatchDAG(rd_dag_h, (void (*) (void *)) rf_MCPairWakeupFunc,\n\t    (void *) mcpair);\n\twhile (!mcpair->flag)\n\t\tRF_WAIT_COND(mcpair->cond, mcpair->mutex);\n\tRF_UNLOCK_MUTEX(mcpair->mutex);\n\tif (rd_dag_h->status != rf_enable) {\n\t\tRF_ERRORMSG(\"Unable to verify parity:  can't read the stripe\\n\");\n\t\tretcode = RF_PARITY_COULD_NOT_VERIFY;\n\t\tgoto out;\n\t}\n\tfor (p = buf, i = 0; p < end_p; p += numbytes, i++) {\n\t\trf_e_encToBuf(raidPtr, i, p, RF_EO_MATRIX_DIM - 2, redundantbuf2, numsector);\n\t\t/* the corresponding columes in EvenOdd encoding Matrix for\n\t\t * these p pointers which point to the databuffer in a full\n\t\t * stripe are sequentially from 0 to layoutPtr->numDataCol-1 */\n\t\trf_bxor(p, pbuf, numbytes, NULL);\n\t}\n\tRF_ASSERT(i == layoutPtr->numDataCol);\n\n\tfor (i = 0; i < numbytes; i++) {\n\t\tif (pbuf[i] != buf[bytesPerStripe + i]) {\n\t\t\tif (!correct_it) {\n\t\t\t\tRF_ERRORMSG3(\"Parity verify error: byte %d of parity is 0x%x should be 0x%x\\n\",\n\t\t\t\t    i, (u_char) buf[bytesPerStripe + i], (u_char) pbuf[i]);\n\t\t\t}\n\t\t}\n\t\tredundantOneErr = 1;\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < numbytes; i++) {\n\t\tif (redundantbuf2[i] != buf[bytesPerStripe + numbytes + i]) {\n\t\t\tif (!correct_it) {\n\t\t\t\tRF_ERRORMSG3(\"Parity verify error: byte %d of second redundant information is 0x%x should be 0x%x\\n\",\n\t\t\t\t    i, (u_char) buf[bytesPerStripe + numbytes + i], (u_char) redundantbuf2[i]);\n\t\t\t}\n\t\t\tredundantTwoErr = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (redundantOneErr || redundantTwoErr)\n\t\tretcode = RF_PARITY_BAD;\n\n\t/* correct the first redundant disk, ie parity if it is error    */\n\tif (redundantOneErr && correct_it) {\n\t\twr_dag_h = rf_MakeSimpleDAG(raidPtr, 1, numbytes, pbuf, rf_DiskWriteFunc, rf_DiskWriteUndoFunc,\n\t\t    \"Wnp\", alloclist, flags, RF_IO_NORMAL_PRIORITY);\n\t\twrBlock = wr_dag_h->succedents[0];\n\t\twrUnblock = wrBlock->succedents[0]->succedents[0];\n\t\twrBlock->succedents[0]->params[0].p = asmap->parityInfo;\n\t\twrBlock->succedents[0]->params[2].v = psID;\n\t\twrBlock->succedents[0]->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);\n\t\tbzero((char *) &tracerec, sizeof(tracerec));\n\t\twr_dag_h->tracerec = &tracerec;\n\t\tif (rf_verifyParityDebug) {\n\t\t\tprintf(\"Parity verify write dag:\\n\");\n\t\t\trf_PrintDAGList(wr_dag_h);\n\t\t}\n\t\tRF_LOCK_MUTEX(mcpair->mutex);\n\t\tmcpair->flag = 0;\n\t\trf_DispatchDAG(wr_dag_h, (void (*) (void *)) rf_MCPairWakeupFunc,\n\t\t    (void *) mcpair);\n\t\twhile (!mcpair->flag)\n\t\t\tRF_WAIT_COND(mcpair->cond, mcpair->mutex);\n\t\tRF_UNLOCK_MUTEX(mcpair->mutex);\n\t\tif (wr_dag_h->status != rf_enable) {\n\t\t\tRF_ERRORMSG(\"Unable to correct parity in VerifyParity:  can't write the stripe\\n\");\n\t\t\tparity_cant_correct = RF_TRUE;\n\t\t} else {\n\t\t\tparity_corrected = RF_TRUE;\n\t\t}\n\t\trf_FreeDAG(wr_dag_h);\n\t}\n\tif (redundantTwoErr && correct_it) {\n\t\twr_dag_h = rf_MakeSimpleDAG(raidPtr, 1, numbytes, redundantbuf2, rf_DiskWriteFunc, rf_DiskWriteUndoFunc,\n\t\t    \"Wnred2\", alloclist, flags, RF_IO_NORMAL_PRIORITY);\n\t\twrBlock = wr_dag_h->succedents[0];\n\t\twrUnblock = wrBlock->succedents[0]->succedents[0];\n\t\twrBlock->succedents[0]->params[0].p = asmap->qInfo;\n\t\twrBlock->succedents[0]->params[2].v = psID;\n\t\twrBlock->succedents[0]->params[3].v = RF_CREATE_PARAM3(RF_IO_NORMAL_PRIORITY, 0, 0, which_ru);\n\t\tbzero((char *) &tracerec, sizeof(tracerec));\n\t\twr_dag_h->tracerec = &tracerec;\n\t\tif (rf_verifyParityDebug) {\n\t\t\tprintf(\"Dag of write new second redundant information in parity verify :\\n\");\n\t\t\trf_PrintDAGList(wr_dag_h);\n\t\t}\n\t\tRF_LOCK_MUTEX(mcpair->mutex);\n\t\tmcpair->flag = 0;\n\t\trf_DispatchDAG(wr_dag_h, (void (*) (void *)) rf_MCPairWakeupFunc,\n\t\t    (void *) mcpair);\n\t\twhile (!mcpair->flag)\n\t\t\tRF_WAIT_COND(mcpair->cond, mcpair->mutex);\n\t\tRF_UNLOCK_MUTEX(mcpair->mutex);\n\t\tif (wr_dag_h->status != rf_enable) {\n\t\t\tRF_ERRORMSG(\"Unable to correct second redundant information in VerifyParity:  can't write the stripe\\n\");\n\t\t\tred2_cant_correct = RF_TRUE;\n\t\t} else {\n\t\t\tred2_corrected = RF_TRUE;\n\t\t}\n\t\trf_FreeDAG(wr_dag_h);\n\t}\n\tif ((redundantOneErr && parity_cant_correct) ||\n\t    (redundantTwoErr && red2_cant_correct))\n\t\tretcode = RF_PARITY_COULD_NOT_CORRECT;\n\tif ((retcode = RF_PARITY_BAD) && parity_corrected && red2_corrected)\n\t\tretcode = RF_PARITY_CORRECTED;\n\n\nout:\n\trf_FreeAccessStripeMap(asm_h);\n\trf_FreeAllocList(alloclist);\n\trf_FreeDAG(rd_dag_h);\n\trf_FreeMCPair(mcpair);\n\treturn (retcode);\n}"
  },
  {
    "function_name": "rf_EODagSelect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_evenodd.c",
    "lines": "200-347",
    "snippet": "void \nrf_EODagSelect(\n    RF_Raid_t * raidPtr,\n    RF_IoType_t type,\n    RF_AccessStripeMap_t * asmap,\n    RF_VoidFuncPtr * createFunc)\n{\n\tRF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);\n\tunsigned ndfail = asmap->numDataFailed;\n\tunsigned npfail = asmap->numParityFailed + asmap->numQFailed;\n\tunsigned ntfail = npfail + ndfail;\n\n\tRF_ASSERT(RF_IO_IS_R_OR_W(type));\n\tif (ntfail > 2) {\n\t\tRF_ERRORMSG(\"more than two disks failed in a single group!  Aborting I/O operation.\\n\");\n\t\t /* *infoFunc = */ *createFunc = NULL;\n\t\treturn;\n\t}\n\t/* ok, we can do this I/O */\n\tif (type == RF_IO_TYPE_READ) {\n\t\tswitch (ndfail) {\n\t\tcase 0:\n\t\t\t/* fault free read */\n\t\t\t*createFunc = (RF_VoidFuncPtr) rf_CreateFaultFreeReadDAG;\t/* same as raid 5 */\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t/* lost a single data unit */\n\t\t\t/* two cases: (1) parity is not lost. do a normal raid\n\t\t\t * 5 reconstruct read. (2) parity is lost. do a\n\t\t\t * reconstruct read using \"e\". */\n\t\t\tif (ntfail == 2) {\t/* also lost redundancy */\n\t\t\t\tif (asmap->failedPDAs[1]->type == RF_PDA_TYPE_PARITY)\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_EO_110_CreateReadDAG;\n\t\t\t\telse\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_EO_101_CreateReadDAG;\n\t\t\t} else {\n\t\t\t\t/* P and E are ok. But is there a failure in\n\t\t\t\t * some unaccessed data unit? */\n\t\t\t\tif (rf_NumFailedDataUnitsInStripe(raidPtr, asmap) == 2)\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_EO_200_CreateReadDAG;\n\t\t\t\telse\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_EO_100_CreateReadDAG;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t/* *createFunc = rf_EO_200_CreateReadDAG; */\n\t\t\t*createFunc = NULL;\n\t\t\tbreak;\n\t\t}\n\t\treturn;\n\t}\n\t/* a write */\n\tswitch (ntfail) {\n\tcase 0:\t\t/* fault free */\n\t\tif (rf_suppressLocksAndLargeWrites ||\n\t\t    (((asmap->numStripeUnitsAccessed <= (layoutPtr->numDataCol / 2)) && (layoutPtr->numDataCol != 1)) ||\n\t\t\t(asmap->parityInfo->next != NULL) || (asmap->qInfo->next != NULL) || rf_CheckStripeForFailures(raidPtr, asmap))) {\n\n\t\t\t*createFunc = (RF_VoidFuncPtr) rf_EOCreateSmallWriteDAG;\n\t\t} else {\n\t\t\t*createFunc = (RF_VoidFuncPtr) rf_EOCreateLargeWriteDAG;\n\t\t}\n\t\tbreak;\n\n\tcase 1:\t\t/* single disk fault */\n\t\tif (npfail == 1) {\n\t\t\tRF_ASSERT((asmap->failedPDAs[0]->type == RF_PDA_TYPE_PARITY) || (asmap->failedPDAs[0]->type == RF_PDA_TYPE_Q));\n\t\t\tif (asmap->failedPDAs[0]->type == RF_PDA_TYPE_Q) {\t/* q died, treat like\n\t\t\t\t\t\t\t\t\t\t * normal mode raid5\n\t\t\t\t\t\t\t\t\t\t * write. */\n\t\t\t\tif (((asmap->numStripeUnitsAccessed <= (layoutPtr->numDataCol / 2)) || (asmap->numStripeUnitsAccessed == 1))\n\t\t\t\t    || (asmap->parityInfo->next != NULL) || rf_NumFailedDataUnitsInStripe(raidPtr, asmap))\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_EO_001_CreateSmallWriteDAG;\n\t\t\t\telse\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_EO_001_CreateLargeWriteDAG;\n\t\t\t} else {/* parity died, small write only updating Q */\n\t\t\t\tif (((asmap->numStripeUnitsAccessed <= (layoutPtr->numDataCol / 2)) || (asmap->numStripeUnitsAccessed == 1))\n\t\t\t\t    || (asmap->qInfo->next != NULL) || rf_NumFailedDataUnitsInStripe(raidPtr, asmap))\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_EO_010_CreateSmallWriteDAG;\n\t\t\t\telse\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_EO_010_CreateLargeWriteDAG;\n\t\t\t}\n\t\t} else {\t/* data missing. Do a P reconstruct write if\n\t\t\t\t * only a single data unit is lost in the\n\t\t\t\t * stripe, otherwise a reconstruct write which\n\t\t\t\t * employnig both P and E units. */\n\t\t\tif (rf_NumFailedDataUnitsInStripe(raidPtr, asmap) == 2) {\n\t\t\t\tif (asmap->numStripeUnitsAccessed == 1)\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_EO_200_CreateWriteDAG;\n\t\t\t\telse\n\t\t\t\t\t*createFunc = NULL;\t/* No direct support for\n\t\t\t\t\t\t\t\t * this case now, like\n\t\t\t\t\t\t\t\t * that in Raid-5  */\n\t\t\t} else {\n\t\t\t\tif (asmap->numStripeUnitsAccessed != 1 && asmap->failedPDAs[0]->numSector != layoutPtr->sectorsPerStripeUnit)\n\t\t\t\t\t*createFunc = NULL;\t/* No direct support for\n\t\t\t\t\t\t\t\t * this case now, like\n\t\t\t\t\t\t\t\t * that in Raid-5  */\n\t\t\t\telse\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_EO_100_CreateWriteDAG;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase 2:\t\t/* two disk faults */\n\t\tswitch (npfail) {\n\t\tcase 2:\t/* both p and q dead */\n\t\t\t*createFunc = (RF_VoidFuncPtr) rf_EO_011_CreateWriteDAG;\n\t\t\tbreak;\n\t\tcase 1:\t/* either p or q and dead data */\n\t\t\tRF_ASSERT(asmap->failedPDAs[0]->type == RF_PDA_TYPE_DATA);\n\t\t\tRF_ASSERT((asmap->failedPDAs[1]->type == RF_PDA_TYPE_PARITY) || (asmap->failedPDAs[1]->type == RF_PDA_TYPE_Q));\n\t\t\tif (asmap->failedPDAs[1]->type == RF_PDA_TYPE_Q) {\n\t\t\t\tif (asmap->numStripeUnitsAccessed != 1 && asmap->failedPDAs[0]->numSector != layoutPtr->sectorsPerStripeUnit)\n\t\t\t\t\t*createFunc = NULL;\t/* In both PQ and\n\t\t\t\t\t\t\t\t * EvenOdd, no direct\n\t\t\t\t\t\t\t\t * support for this case\n\t\t\t\t\t\t\t\t * now, like that in\n\t\t\t\t\t\t\t\t * Raid-5  */\n\t\t\t\telse\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_EO_101_CreateWriteDAG;\n\t\t\t} else {\n\t\t\t\tif (asmap->numStripeUnitsAccessed != 1 && asmap->failedPDAs[0]->numSector != layoutPtr->sectorsPerStripeUnit)\n\t\t\t\t\t*createFunc = NULL;\t/* No direct support for\n\t\t\t\t\t\t\t\t * this case, like that\n\t\t\t\t\t\t\t\t * in Raid-5  */\n\t\t\t\telse\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_EO_110_CreateWriteDAG;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0:\t/* double data loss */\n\t\t\t/* if(asmap->failedPDAs[0]->numSector +\n\t\t\t * asmap->failedPDAs[1]->numSector == 2 *\n\t\t\t * layoutPtr->sectorsPerStripeUnit ) createFunc =\n\t\t\t * rf_EOCreateLargeWriteDAG; else    \t\t\t\t\t\t\t */\n\t\t\t*createFunc = NULL;\t/* currently, in Evenodd, No\n\t\t\t\t\t\t * support for simultaneous\n\t\t\t\t\t\t * access of both failed SUs */\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\t\t/* more than 2 disk faults */\n\t\t*createFunc = NULL;\n\t\tRF_PANIC();\n\t}\n\treturn;\n}",
    "includes": [
      "#include \"rf_engine.h\"",
      "#include \"rf_evenodd_dags.h\"",
      "#include \"rf_evenodd_dagfuncs.h\"",
      "#include \"rf_evenodd.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_pq.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_evenodd.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_PANIC",
          "args": [],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "(asmap->failedPDAs[1]->type == RF_PDA_TYPE_PARITY) || (asmap->failedPDAs[1]->type == RF_PDA_TYPE_Q)"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "asmap->failedPDAs[0]->type == RF_PDA_TYPE_DATA"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_NumFailedDataUnitsInStripe",
          "args": [
            "raidPtr",
            "asmap"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "rf_NumFailedDataUnitsInStripe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_map.c",
          "lines": "660-689",
          "snippet": "int \nrf_NumFailedDataUnitsInStripe(raidPtr, asmap)\n\tRF_Raid_t *raidPtr;\n\tRF_AccessStripeMap_t *asmap;\n{\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_RowCol_t trow, tcol, row, i;\n\tRF_SectorNum_t diskOffset;\n\tRF_RaidAddr_t sosAddr;\n\tint     numFailures;\n\n\t/* quick out in the fault-free case.  */\n\tRF_LOCK_MUTEX(raidPtr->mutex);\n\tnumFailures = raidPtr->numFailures;\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\tif (numFailures == 0)\n\t\treturn (0);\n\tnumFailures = 0;\n\n\tsosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, asmap->raidAddress);\n\trow = asmap->physInfo->row;\n\tfor (i = 0; i < layoutPtr->numDataCol; i++) {\n\t\t(layoutPtr->map->MapSector) (raidPtr, sosAddr + i * layoutPtr->sectorsPerStripeUnit,\n\t\t    &trow, &tcol, &diskOffset, 0);\n\t\tif (RF_DEAD_DISK(raidPtr->Disks[trow][tcol].status))\n\t\t\tnumFailures++;\n\t}\n\n\treturn numFailures;\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "RF_AccessStripeMapHeader_t *\nrf_MapAccess(raidPtr, raidAddress, numBlocks, buffer, remap)\n\tRF_Raid_t *raidPtr;",
            "RF_RaidAddr_t raidAddress;",
            "RF_AccessStripeMap_t *\nrf_DuplicateASM(asmap)\n\tRF_AccessStripeMap_t *asmap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nRF_AccessStripeMapHeader_t *\nrf_MapAccess(raidPtr, raidAddress, numBlocks, buffer, remap)\n\tRF_Raid_t *raidPtr;\nRF_RaidAddr_t raidAddress;\nRF_AccessStripeMap_t *\nrf_DuplicateASM(asmap)\n\tRF_AccessStripeMap_t *asmap;\n\nint \nrf_NumFailedDataUnitsInStripe(raidPtr, asmap)\n\tRF_Raid_t *raidPtr;\n\tRF_AccessStripeMap_t *asmap;\n{\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_RowCol_t trow, tcol, row, i;\n\tRF_SectorNum_t diskOffset;\n\tRF_RaidAddr_t sosAddr;\n\tint     numFailures;\n\n\t/* quick out in the fault-free case.  */\n\tRF_LOCK_MUTEX(raidPtr->mutex);\n\tnumFailures = raidPtr->numFailures;\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\tif (numFailures == 0)\n\t\treturn (0);\n\tnumFailures = 0;\n\n\tsosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, asmap->raidAddress);\n\trow = asmap->physInfo->row;\n\tfor (i = 0; i < layoutPtr->numDataCol; i++) {\n\t\t(layoutPtr->map->MapSector) (raidPtr, sosAddr + i * layoutPtr->sectorsPerStripeUnit,\n\t\t    &trow, &tcol, &diskOffset, 0);\n\t\tif (RF_DEAD_DISK(raidPtr->Disks[trow][tcol].status))\n\t\t\tnumFailures++;\n\t}\n\n\treturn numFailures;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "(asmap->failedPDAs[0]->type == RF_PDA_TYPE_PARITY) || (asmap->failedPDAs[0]->type == RF_PDA_TYPE_Q)"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_CheckStripeForFailures",
          "args": [
            "raidPtr",
            "asmap"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "rf_CheckStripeForFailures",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_map.c",
          "lines": "608-655",
          "snippet": "int \nrf_CheckStripeForFailures(raidPtr, asmap)\n\tRF_Raid_t *raidPtr;\n\tRF_AccessStripeMap_t *asmap;\n{\n\tRF_RowCol_t trow, tcol, prow, pcol, *diskids, row, i;\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_StripeCount_t stripeOffset;\n\tint     numFailures;\n\tRF_RaidAddr_t sosAddr;\n\tRF_SectorNum_t diskOffset, poffset;\n\tRF_RowCol_t testrow;\n\n\t/* quick out in the fault-free case.  */\n\tRF_LOCK_MUTEX(raidPtr->mutex);\n\tnumFailures = raidPtr->numFailures;\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\tif (numFailures == 0)\n\t\treturn (0);\n\n\tsosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, asmap->raidAddress);\n\trow = asmap->physInfo->row;\n\t(layoutPtr->map->IdentifyStripe) (raidPtr, asmap->raidAddress, &diskids, &testrow);\n\t(layoutPtr->map->MapParity) (raidPtr, asmap->raidAddress, &prow, &pcol, &poffset, 0);\t/* get pcol */\n\n\t/* this need not be true if we've redirected the access to a spare in\n\t * another row RF_ASSERT(row == testrow); */\n\tstripeOffset = 0;\n\tfor (i = 0; i < layoutPtr->numDataCol + layoutPtr->numParityCol; i++) {\n\t\tif (diskids[i] != pcol) {\n\t\t\tif (RF_DEAD_DISK(raidPtr->Disks[testrow][diskids[i]].status)) {\n\t\t\t\tif (raidPtr->status[testrow] != rf_rs_reconstructing)\n\t\t\t\t\treturn (1);\n\t\t\t\tRF_ASSERT(raidPtr->reconControl[testrow]->fcol == diskids[i]);\n\t\t\t\tlayoutPtr->map->MapSector(raidPtr,\n\t\t\t\t    sosAddr + stripeOffset * layoutPtr->sectorsPerStripeUnit,\n\t\t\t\t    &trow, &tcol, &diskOffset, 0);\n\t\t\t\tRF_ASSERT((trow == testrow) && (tcol == diskids[i]));\n\t\t\t\tif (!rf_CheckRUReconstructed(raidPtr->reconControl[testrow]->reconMap, diskOffset))\n\t\t\t\t\treturn (1);\n\t\t\t\tasmap->flags |= RF_ASM_REDIR_LARGE_WRITE;\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tstripeOffset++;\n\t\t}\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_map.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "RF_AccessStripeMapHeader_t *\nrf_MapAccess(raidPtr, raidAddress, numBlocks, buffer, remap)\n\tRF_Raid_t *raidPtr;",
            "RF_RaidAddr_t raidAddress;",
            "RF_AccessStripeMap_t *\nrf_DuplicateASM(asmap)\n\tRF_AccessStripeMap_t *asmap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_freelist.h\"\n#include \"rf_map.h\"\n#include \"rf_general.h\"\n#include \"rf_raid.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nRF_AccessStripeMapHeader_t *\nrf_MapAccess(raidPtr, raidAddress, numBlocks, buffer, remap)\n\tRF_Raid_t *raidPtr;\nRF_RaidAddr_t raidAddress;\nRF_AccessStripeMap_t *\nrf_DuplicateASM(asmap)\n\tRF_AccessStripeMap_t *asmap;\n\nint \nrf_CheckStripeForFailures(raidPtr, asmap)\n\tRF_Raid_t *raidPtr;\n\tRF_AccessStripeMap_t *asmap;\n{\n\tRF_RowCol_t trow, tcol, prow, pcol, *diskids, row, i;\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_StripeCount_t stripeOffset;\n\tint     numFailures;\n\tRF_RaidAddr_t sosAddr;\n\tRF_SectorNum_t diskOffset, poffset;\n\tRF_RowCol_t testrow;\n\n\t/* quick out in the fault-free case.  */\n\tRF_LOCK_MUTEX(raidPtr->mutex);\n\tnumFailures = raidPtr->numFailures;\n\tRF_UNLOCK_MUTEX(raidPtr->mutex);\n\tif (numFailures == 0)\n\t\treturn (0);\n\n\tsosAddr = rf_RaidAddressOfPrevStripeBoundary(layoutPtr, asmap->raidAddress);\n\trow = asmap->physInfo->row;\n\t(layoutPtr->map->IdentifyStripe) (raidPtr, asmap->raidAddress, &diskids, &testrow);\n\t(layoutPtr->map->MapParity) (raidPtr, asmap->raidAddress, &prow, &pcol, &poffset, 0);\t/* get pcol */\n\n\t/* this need not be true if we've redirected the access to a spare in\n\t * another row RF_ASSERT(row == testrow); */\n\tstripeOffset = 0;\n\tfor (i = 0; i < layoutPtr->numDataCol + layoutPtr->numParityCol; i++) {\n\t\tif (diskids[i] != pcol) {\n\t\t\tif (RF_DEAD_DISK(raidPtr->Disks[testrow][diskids[i]].status)) {\n\t\t\t\tif (raidPtr->status[testrow] != rf_rs_reconstructing)\n\t\t\t\t\treturn (1);\n\t\t\t\tRF_ASSERT(raidPtr->reconControl[testrow]->fcol == diskids[i]);\n\t\t\t\tlayoutPtr->map->MapSector(raidPtr,\n\t\t\t\t    sosAddr + stripeOffset * layoutPtr->sectorsPerStripeUnit,\n\t\t\t\t    &trow, &tcol, &diskOffset, 0);\n\t\t\t\tRF_ASSERT((trow == testrow) && (tcol == diskids[i]));\n\t\t\t\tif (!rf_CheckRUReconstructed(raidPtr->reconControl[testrow]->reconMap, diskOffset))\n\t\t\t\t\treturn (1);\n\t\t\t\tasmap->flags |= RF_ASM_REDIR_LARGE_WRITE;\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tstripeOffset++;\n\t\t}\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG",
          "args": [
            "\"more than two disks failed in a single group!  Aborting I/O operation.\\n\""
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "RF_IO_IS_R_OR_W(type)"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_IO_IS_R_OR_W",
          "args": [
            "type"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_engine.h\"\n#include \"rf_evenodd_dags.h\"\n#include \"rf_evenodd_dagfuncs.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_pq.h\"\n#include \"rf_map.h\"\n#include \"rf_utils.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_configure.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nvoid \nrf_EODagSelect(\n    RF_Raid_t * raidPtr,\n    RF_IoType_t type,\n    RF_AccessStripeMap_t * asmap,\n    RF_VoidFuncPtr * createFunc)\n{\n\tRF_RaidLayout_t *layoutPtr = &(raidPtr->Layout);\n\tunsigned ndfail = asmap->numDataFailed;\n\tunsigned npfail = asmap->numParityFailed + asmap->numQFailed;\n\tunsigned ntfail = npfail + ndfail;\n\n\tRF_ASSERT(RF_IO_IS_R_OR_W(type));\n\tif (ntfail > 2) {\n\t\tRF_ERRORMSG(\"more than two disks failed in a single group!  Aborting I/O operation.\\n\");\n\t\t /* *infoFunc = */ *createFunc = NULL;\n\t\treturn;\n\t}\n\t/* ok, we can do this I/O */\n\tif (type == RF_IO_TYPE_READ) {\n\t\tswitch (ndfail) {\n\t\tcase 0:\n\t\t\t/* fault free read */\n\t\t\t*createFunc = (RF_VoidFuncPtr) rf_CreateFaultFreeReadDAG;\t/* same as raid 5 */\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t/* lost a single data unit */\n\t\t\t/* two cases: (1) parity is not lost. do a normal raid\n\t\t\t * 5 reconstruct read. (2) parity is lost. do a\n\t\t\t * reconstruct read using \"e\". */\n\t\t\tif (ntfail == 2) {\t/* also lost redundancy */\n\t\t\t\tif (asmap->failedPDAs[1]->type == RF_PDA_TYPE_PARITY)\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_EO_110_CreateReadDAG;\n\t\t\t\telse\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_EO_101_CreateReadDAG;\n\t\t\t} else {\n\t\t\t\t/* P and E are ok. But is there a failure in\n\t\t\t\t * some unaccessed data unit? */\n\t\t\t\tif (rf_NumFailedDataUnitsInStripe(raidPtr, asmap) == 2)\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_EO_200_CreateReadDAG;\n\t\t\t\telse\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_EO_100_CreateReadDAG;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t/* *createFunc = rf_EO_200_CreateReadDAG; */\n\t\t\t*createFunc = NULL;\n\t\t\tbreak;\n\t\t}\n\t\treturn;\n\t}\n\t/* a write */\n\tswitch (ntfail) {\n\tcase 0:\t\t/* fault free */\n\t\tif (rf_suppressLocksAndLargeWrites ||\n\t\t    (((asmap->numStripeUnitsAccessed <= (layoutPtr->numDataCol / 2)) && (layoutPtr->numDataCol != 1)) ||\n\t\t\t(asmap->parityInfo->next != NULL) || (asmap->qInfo->next != NULL) || rf_CheckStripeForFailures(raidPtr, asmap))) {\n\n\t\t\t*createFunc = (RF_VoidFuncPtr) rf_EOCreateSmallWriteDAG;\n\t\t} else {\n\t\t\t*createFunc = (RF_VoidFuncPtr) rf_EOCreateLargeWriteDAG;\n\t\t}\n\t\tbreak;\n\n\tcase 1:\t\t/* single disk fault */\n\t\tif (npfail == 1) {\n\t\t\tRF_ASSERT((asmap->failedPDAs[0]->type == RF_PDA_TYPE_PARITY) || (asmap->failedPDAs[0]->type == RF_PDA_TYPE_Q));\n\t\t\tif (asmap->failedPDAs[0]->type == RF_PDA_TYPE_Q) {\t/* q died, treat like\n\t\t\t\t\t\t\t\t\t\t * normal mode raid5\n\t\t\t\t\t\t\t\t\t\t * write. */\n\t\t\t\tif (((asmap->numStripeUnitsAccessed <= (layoutPtr->numDataCol / 2)) || (asmap->numStripeUnitsAccessed == 1))\n\t\t\t\t    || (asmap->parityInfo->next != NULL) || rf_NumFailedDataUnitsInStripe(raidPtr, asmap))\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_EO_001_CreateSmallWriteDAG;\n\t\t\t\telse\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_EO_001_CreateLargeWriteDAG;\n\t\t\t} else {/* parity died, small write only updating Q */\n\t\t\t\tif (((asmap->numStripeUnitsAccessed <= (layoutPtr->numDataCol / 2)) || (asmap->numStripeUnitsAccessed == 1))\n\t\t\t\t    || (asmap->qInfo->next != NULL) || rf_NumFailedDataUnitsInStripe(raidPtr, asmap))\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_EO_010_CreateSmallWriteDAG;\n\t\t\t\telse\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_EO_010_CreateLargeWriteDAG;\n\t\t\t}\n\t\t} else {\t/* data missing. Do a P reconstruct write if\n\t\t\t\t * only a single data unit is lost in the\n\t\t\t\t * stripe, otherwise a reconstruct write which\n\t\t\t\t * employnig both P and E units. */\n\t\t\tif (rf_NumFailedDataUnitsInStripe(raidPtr, asmap) == 2) {\n\t\t\t\tif (asmap->numStripeUnitsAccessed == 1)\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_EO_200_CreateWriteDAG;\n\t\t\t\telse\n\t\t\t\t\t*createFunc = NULL;\t/* No direct support for\n\t\t\t\t\t\t\t\t * this case now, like\n\t\t\t\t\t\t\t\t * that in Raid-5  */\n\t\t\t} else {\n\t\t\t\tif (asmap->numStripeUnitsAccessed != 1 && asmap->failedPDAs[0]->numSector != layoutPtr->sectorsPerStripeUnit)\n\t\t\t\t\t*createFunc = NULL;\t/* No direct support for\n\t\t\t\t\t\t\t\t * this case now, like\n\t\t\t\t\t\t\t\t * that in Raid-5  */\n\t\t\t\telse\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_EO_100_CreateWriteDAG;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase 2:\t\t/* two disk faults */\n\t\tswitch (npfail) {\n\t\tcase 2:\t/* both p and q dead */\n\t\t\t*createFunc = (RF_VoidFuncPtr) rf_EO_011_CreateWriteDAG;\n\t\t\tbreak;\n\t\tcase 1:\t/* either p or q and dead data */\n\t\t\tRF_ASSERT(asmap->failedPDAs[0]->type == RF_PDA_TYPE_DATA);\n\t\t\tRF_ASSERT((asmap->failedPDAs[1]->type == RF_PDA_TYPE_PARITY) || (asmap->failedPDAs[1]->type == RF_PDA_TYPE_Q));\n\t\t\tif (asmap->failedPDAs[1]->type == RF_PDA_TYPE_Q) {\n\t\t\t\tif (asmap->numStripeUnitsAccessed != 1 && asmap->failedPDAs[0]->numSector != layoutPtr->sectorsPerStripeUnit)\n\t\t\t\t\t*createFunc = NULL;\t/* In both PQ and\n\t\t\t\t\t\t\t\t * EvenOdd, no direct\n\t\t\t\t\t\t\t\t * support for this case\n\t\t\t\t\t\t\t\t * now, like that in\n\t\t\t\t\t\t\t\t * Raid-5  */\n\t\t\t\telse\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_EO_101_CreateWriteDAG;\n\t\t\t} else {\n\t\t\t\tif (asmap->numStripeUnitsAccessed != 1 && asmap->failedPDAs[0]->numSector != layoutPtr->sectorsPerStripeUnit)\n\t\t\t\t\t*createFunc = NULL;\t/* No direct support for\n\t\t\t\t\t\t\t\t * this case, like that\n\t\t\t\t\t\t\t\t * in Raid-5  */\n\t\t\t\telse\n\t\t\t\t\t*createFunc = (RF_VoidFuncPtr) rf_EO_110_CreateWriteDAG;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0:\t/* double data loss */\n\t\t\t/* if(asmap->failedPDAs[0]->numSector +\n\t\t\t * asmap->failedPDAs[1]->numSector == 2 *\n\t\t\t * layoutPtr->sectorsPerStripeUnit ) createFunc =\n\t\t\t * rf_EOCreateLargeWriteDAG; else    \t\t\t\t\t\t\t */\n\t\t\t*createFunc = NULL;\t/* currently, in Evenodd, No\n\t\t\t\t\t\t * support for simultaneous\n\t\t\t\t\t\t * access of both failed SUs */\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\t\t/* more than 2 disk faults */\n\t\t*createFunc = NULL;\n\t\tRF_PANIC();\n\t}\n\treturn;\n}"
  },
  {
    "function_name": "rf_MapEEvenOdd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_evenodd.c",
    "lines": "182-198",
    "snippet": "void \nrf_MapEEvenOdd(\n    RF_Raid_t * raidPtr,\n    RF_RaidAddr_t raidSector,\n    RF_RowCol_t * row,\n    RF_RowCol_t * col,\n    RF_SectorNum_t * diskSector,\n    int remap)\n{\n\tRF_StripeNum_t SUID = raidSector / raidPtr->Layout.sectorsPerStripeUnit;\n\tRF_StripeNum_t endSUIDofthisStrip = (SUID / raidPtr->Layout.numDataCol + 1) * raidPtr->Layout.numDataCol - 1;\n\n\t*row = 0;\n\t*col = (endSUIDofthisStrip + 1) % raidPtr->numCol;\n\t*diskSector = (SUID / (raidPtr->Layout.numDataCol)) * raidPtr->Layout.sectorsPerStripeUnit +\n\t    (raidSector % raidPtr->Layout.sectorsPerStripeUnit);\n}",
    "includes": [
      "#include \"rf_engine.h\"",
      "#include \"rf_evenodd_dags.h\"",
      "#include \"rf_evenodd_dagfuncs.h\"",
      "#include \"rf_evenodd.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_pq.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_evenodd.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_engine.h\"\n#include \"rf_evenodd_dags.h\"\n#include \"rf_evenodd_dagfuncs.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_pq.h\"\n#include \"rf_map.h\"\n#include \"rf_utils.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_configure.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nvoid \nrf_MapEEvenOdd(\n    RF_Raid_t * raidPtr,\n    RF_RaidAddr_t raidSector,\n    RF_RowCol_t * row,\n    RF_RowCol_t * col,\n    RF_SectorNum_t * diskSector,\n    int remap)\n{\n\tRF_StripeNum_t SUID = raidSector / raidPtr->Layout.sectorsPerStripeUnit;\n\tRF_StripeNum_t endSUIDofthisStrip = (SUID / raidPtr->Layout.numDataCol + 1) * raidPtr->Layout.numDataCol - 1;\n\n\t*row = 0;\n\t*col = (endSUIDofthisStrip + 1) % raidPtr->numCol;\n\t*diskSector = (SUID / (raidPtr->Layout.numDataCol)) * raidPtr->Layout.sectorsPerStripeUnit +\n\t    (raidSector % raidPtr->Layout.sectorsPerStripeUnit);\n}"
  },
  {
    "function_name": "rf_MapParityEvenOdd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_evenodd.c",
    "lines": "164-180",
    "snippet": "void \nrf_MapParityEvenOdd(\n    RF_Raid_t * raidPtr,\n    RF_RaidAddr_t raidSector,\n    RF_RowCol_t * row,\n    RF_RowCol_t * col,\n    RF_SectorNum_t * diskSector,\n    int remap)\n{\n\tRF_StripeNum_t SUID = raidSector / raidPtr->Layout.sectorsPerStripeUnit;\n\tRF_StripeNum_t endSUIDofthisStrip = (SUID / raidPtr->Layout.numDataCol + 1) * raidPtr->Layout.numDataCol - 1;\n\n\t*row = 0;\n\t*col = (endSUIDofthisStrip + 2) % raidPtr->numCol;\n\t*diskSector = (SUID / (raidPtr->Layout.numDataCol)) * raidPtr->Layout.sectorsPerStripeUnit +\n\t    (raidSector % raidPtr->Layout.sectorsPerStripeUnit);\n}",
    "includes": [
      "#include \"rf_engine.h\"",
      "#include \"rf_evenodd_dags.h\"",
      "#include \"rf_evenodd_dagfuncs.h\"",
      "#include \"rf_evenodd.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_pq.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_evenodd.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_engine.h\"\n#include \"rf_evenodd_dags.h\"\n#include \"rf_evenodd_dagfuncs.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_pq.h\"\n#include \"rf_map.h\"\n#include \"rf_utils.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_configure.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nvoid \nrf_MapParityEvenOdd(\n    RF_Raid_t * raidPtr,\n    RF_RaidAddr_t raidSector,\n    RF_RowCol_t * row,\n    RF_RowCol_t * col,\n    RF_SectorNum_t * diskSector,\n    int remap)\n{\n\tRF_StripeNum_t SUID = raidSector / raidPtr->Layout.sectorsPerStripeUnit;\n\tRF_StripeNum_t endSUIDofthisStrip = (SUID / raidPtr->Layout.numDataCol + 1) * raidPtr->Layout.numDataCol - 1;\n\n\t*row = 0;\n\t*col = (endSUIDofthisStrip + 2) % raidPtr->numCol;\n\t*diskSector = (SUID / (raidPtr->Layout.numDataCol)) * raidPtr->Layout.sectorsPerStripeUnit +\n\t    (raidSector % raidPtr->Layout.sectorsPerStripeUnit);\n}"
  },
  {
    "function_name": "rf_IdentifyStripeEvenOdd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_evenodd.c",
    "lines": "136-148",
    "snippet": "void \nrf_IdentifyStripeEvenOdd(\n    RF_Raid_t * raidPtr,\n    RF_RaidAddr_t addr,\n    RF_RowCol_t ** diskids,\n    RF_RowCol_t * outRow)\n{\n\tRF_StripeNum_t stripeID = rf_RaidAddressToStripeID(&raidPtr->Layout, addr);\n\tRF_EvenOddConfigInfo_t *info = (RF_EvenOddConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;\n\n\t*outRow = 0;\n\t*diskids = info->stripeIdentifier[stripeID % raidPtr->numCol];\n}",
    "includes": [
      "#include \"rf_engine.h\"",
      "#include \"rf_evenodd_dags.h\"",
      "#include \"rf_evenodd_dagfuncs.h\"",
      "#include \"rf_evenodd.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_pq.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_evenodd.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_RaidAddressToStripeID",
          "args": [
            "&raidPtr->Layout",
            "addr"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_engine.h\"\n#include \"rf_evenodd_dags.h\"\n#include \"rf_evenodd_dagfuncs.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_pq.h\"\n#include \"rf_map.h\"\n#include \"rf_utils.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_configure.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nvoid \nrf_IdentifyStripeEvenOdd(\n    RF_Raid_t * raidPtr,\n    RF_RaidAddr_t addr,\n    RF_RowCol_t ** diskids,\n    RF_RowCol_t * outRow)\n{\n\tRF_StripeNum_t stripeID = rf_RaidAddressToStripeID(&raidPtr->Layout, addr);\n\tRF_EvenOddConfigInfo_t *info = (RF_EvenOddConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;\n\n\t*outRow = 0;\n\t*diskids = info->stripeIdentifier[stripeID % raidPtr->numCol];\n}"
  },
  {
    "function_name": "rf_GetDefaultHeadSepLimitEvenOdd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_evenodd.c",
    "lines": "130-134",
    "snippet": "RF_HeadSepLimit_t \nrf_GetDefaultHeadSepLimitEvenOdd(RF_Raid_t * raidPtr)\n{\n\treturn (10);\n}",
    "includes": [
      "#include \"rf_engine.h\"",
      "#include \"rf_evenodd_dags.h\"",
      "#include \"rf_evenodd_dagfuncs.h\"",
      "#include \"rf_evenodd.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_pq.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_evenodd.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_engine.h\"\n#include \"rf_evenodd_dags.h\"\n#include \"rf_evenodd_dagfuncs.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_pq.h\"\n#include \"rf_map.h\"\n#include \"rf_utils.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_configure.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nRF_HeadSepLimit_t \nrf_GetDefaultHeadSepLimitEvenOdd(RF_Raid_t * raidPtr)\n{\n\treturn (10);\n}"
  },
  {
    "function_name": "rf_GetDefaultNumFloatingReconBuffersEvenOdd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_evenodd.c",
    "lines": "124-128",
    "snippet": "int \nrf_GetDefaultNumFloatingReconBuffersEvenOdd(RF_Raid_t * raidPtr)\n{\n\treturn (20);\n}",
    "includes": [
      "#include \"rf_engine.h\"",
      "#include \"rf_evenodd_dags.h\"",
      "#include \"rf_evenodd_dagfuncs.h\"",
      "#include \"rf_evenodd.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_pq.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_evenodd.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_engine.h\"\n#include \"rf_evenodd_dags.h\"\n#include \"rf_evenodd_dagfuncs.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_pq.h\"\n#include \"rf_map.h\"\n#include \"rf_utils.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_configure.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nint \nrf_GetDefaultNumFloatingReconBuffersEvenOdd(RF_Raid_t * raidPtr)\n{\n\treturn (20);\n}"
  },
  {
    "function_name": "rf_ConfigureEvenOdd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_evenodd.c",
    "lines": "68-122",
    "snippet": "int \nrf_ConfigureEvenOdd(listp, raidPtr, cfgPtr)\n\tRF_ShutdownList_t **listp;\n\tRF_Raid_t *raidPtr;\n\tRF_Config_t *cfgPtr;\n{\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_EvenOddConfigInfo_t *info;\n\tRF_RowCol_t i, j, startdisk;\n\n\tRF_MallocAndAdd(info, sizeof(RF_EvenOddConfigInfo_t), (RF_EvenOddConfigInfo_t *), raidPtr->cleanupList);\n\tlayoutPtr->layoutSpecificInfo = (void *) info;\n\n\tRF_ASSERT(raidPtr->numRow == 1);\n\n\tinfo->stripeIdentifier = rf_make_2d_array(raidPtr->numCol, raidPtr->numCol, raidPtr->cleanupList);\n\tstartdisk = 0;\n\tfor (i = 0; i < raidPtr->numCol; i++) {\n\t\tfor (j = 0; j < raidPtr->numCol; j++) {\n\t\t\tinfo->stripeIdentifier[i][j] = (startdisk + j) % raidPtr->numCol;\n\t\t}\n\t\tif ((startdisk -= 2) < 0)\n\t\t\tstartdisk += raidPtr->numCol;\n\t}\n\n\t/* fill in the remaining layout parameters */\n\tlayoutPtr->numStripe = layoutPtr->stripeUnitsPerDisk;\n\tlayoutPtr->bytesPerStripeUnit = layoutPtr->sectorsPerStripeUnit << raidPtr->logBytesPerSector;\n\tlayoutPtr->numDataCol = raidPtr->numCol - 2;\t/* ORIG:\n\t\t\t\t\t\t\t * layoutPtr->numDataCol\n\t\t\t\t\t\t\t * = raidPtr->numCol-1;  */\n#if RF_EO_MATRIX_DIM > 17\n\tif (raidPtr->numCol <= 17) {\n\t\tprintf(\"Number of stripe units in a parity stripe is smaller than 17. Please\\n\");\n\t\tprintf(\"define the macro RF_EO_MATRIX_DIM in file rf_evenodd_dagfuncs.h to \\n\");\n\t\tprintf(\"be 17 to increase performance. \\n\");\n\t\treturn (EINVAL);\n\t}\n#elif RF_EO_MATRIX_DIM == 17\n\tif (raidPtr->numCol > 17) {\n\t\tprintf(\"Number of stripe units in a parity stripe is bigger than 17. Please\\n\");\n\t\tprintf(\"define the macro RF_EO_MATRIX_DIM in file rf_evenodd_dagfuncs.h to \\n\");\n\t\tprintf(\"be 257 for encoding and decoding functions to work. \\n\");\n\t\treturn (EINVAL);\n\t}\n#endif\n\tlayoutPtr->dataSectorsPerStripe = layoutPtr->numDataCol * layoutPtr->sectorsPerStripeUnit;\n\tlayoutPtr->numParityCol = 2;\n\tlayoutPtr->dataStripeUnitsPerDisk = layoutPtr->stripeUnitsPerDisk;\n\traidPtr->sectorsPerDisk = layoutPtr->stripeUnitsPerDisk * layoutPtr->sectorsPerStripeUnit;\n\n\traidPtr->totalSectors = layoutPtr->stripeUnitsPerDisk * layoutPtr->numDataCol * layoutPtr->sectorsPerStripeUnit;\n\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_engine.h\"",
      "#include \"rf_evenodd_dags.h\"",
      "#include \"rf_evenodd_dagfuncs.h\"",
      "#include \"rf_evenodd.h\"",
      "#include \"rf_mcpair.h\"",
      "#include \"rf_pq.h\"",
      "#include \"rf_map.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_parityscan.h\"",
      "#include \"rf_configure.h\"",
      "#include \"rf_evenodd.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_etimer.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\"",
      "#include \"rf_archs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"be 257 for encoding and decoding functions to work. \\n\""
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rf_make_2d_array",
          "args": [
            "raidPtr->numCol",
            "raidPtr->numCol",
            "raidPtr->cleanupList"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "raidPtr->numRow == 1"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_MallocAndAdd",
          "args": [
            "info",
            "sizeof(RF_EvenOddConfigInfo_t)",
            "(RF_EvenOddConfigInfo_t *), raidPtr->cleanupList"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_engine.h\"\n#include \"rf_evenodd_dags.h\"\n#include \"rf_evenodd_dagfuncs.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_mcpair.h\"\n#include \"rf_pq.h\"\n#include \"rf_map.h\"\n#include \"rf_utils.h\"\n#include \"rf_parityscan.h\"\n#include \"rf_configure.h\"\n#include \"rf_evenodd.h\"\n#include \"rf_general.h\"\n#include \"rf_etimer.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dagdegwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_dag.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n#include \"rf_archs.h\"\n\nint \nrf_ConfigureEvenOdd(listp, raidPtr, cfgPtr)\n\tRF_ShutdownList_t **listp;\n\tRF_Raid_t *raidPtr;\n\tRF_Config_t *cfgPtr;\n{\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_EvenOddConfigInfo_t *info;\n\tRF_RowCol_t i, j, startdisk;\n\n\tRF_MallocAndAdd(info, sizeof(RF_EvenOddConfigInfo_t), (RF_EvenOddConfigInfo_t *), raidPtr->cleanupList);\n\tlayoutPtr->layoutSpecificInfo = (void *) info;\n\n\tRF_ASSERT(raidPtr->numRow == 1);\n\n\tinfo->stripeIdentifier = rf_make_2d_array(raidPtr->numCol, raidPtr->numCol, raidPtr->cleanupList);\n\tstartdisk = 0;\n\tfor (i = 0; i < raidPtr->numCol; i++) {\n\t\tfor (j = 0; j < raidPtr->numCol; j++) {\n\t\t\tinfo->stripeIdentifier[i][j] = (startdisk + j) % raidPtr->numCol;\n\t\t}\n\t\tif ((startdisk -= 2) < 0)\n\t\t\tstartdisk += raidPtr->numCol;\n\t}\n\n\t/* fill in the remaining layout parameters */\n\tlayoutPtr->numStripe = layoutPtr->stripeUnitsPerDisk;\n\tlayoutPtr->bytesPerStripeUnit = layoutPtr->sectorsPerStripeUnit << raidPtr->logBytesPerSector;\n\tlayoutPtr->numDataCol = raidPtr->numCol - 2;\t/* ORIG:\n\t\t\t\t\t\t\t * layoutPtr->numDataCol\n\t\t\t\t\t\t\t * = raidPtr->numCol-1;  */\n#if RF_EO_MATRIX_DIM > 17\n\tif (raidPtr->numCol <= 17) {\n\t\tprintf(\"Number of stripe units in a parity stripe is smaller than 17. Please\\n\");\n\t\tprintf(\"define the macro RF_EO_MATRIX_DIM in file rf_evenodd_dagfuncs.h to \\n\");\n\t\tprintf(\"be 17 to increase performance. \\n\");\n\t\treturn (EINVAL);\n\t}\n#elif RF_EO_MATRIX_DIM == 17\n\tif (raidPtr->numCol > 17) {\n\t\tprintf(\"Number of stripe units in a parity stripe is bigger than 17. Please\\n\");\n\t\tprintf(\"define the macro RF_EO_MATRIX_DIM in file rf_evenodd_dagfuncs.h to \\n\");\n\t\tprintf(\"be 257 for encoding and decoding functions to work. \\n\");\n\t\treturn (EINVAL);\n\t}\n#endif\n\tlayoutPtr->dataSectorsPerStripe = layoutPtr->numDataCol * layoutPtr->sectorsPerStripeUnit;\n\tlayoutPtr->numParityCol = 2;\n\tlayoutPtr->dataStripeUnitsPerDisk = layoutPtr->stripeUnitsPerDisk;\n\traidPtr->sectorsPerDisk = layoutPtr->stripeUnitsPerDisk * layoutPtr->sectorsPerStripeUnit;\n\n\traidPtr->totalSectors = layoutPtr->stripeUnitsPerDisk * layoutPtr->numDataCol * layoutPtr->sectorsPerStripeUnit;\n\n\treturn (0);\n}"
  }
]